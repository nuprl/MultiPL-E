language: rs
name: HumanEval_43_pairs_sum_to_zero
results:
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ l.len() && j < l.len() {\n        if l[i] + l[j] == 0 {\n            i += 1;\n\
    \            j += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    i == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8a7bmtag.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n  \
    \          i += 1;\n            j += 1;\n            sum += l[i];\n        } else\
    \ {\n            if sum == 0 {\n                return false;\n            }\n\
    \            i += 1;\n        }\n    }\n    sum == 0\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 4 but the
    index is 4'', /tmp/tmplwmjozsr.rs:22:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && x.pairs().fold(false,\
    \ |acc, y| acc && y.sum() == 0))\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pairs` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmps6fya33t.rs:15:44\n   |\n15 |     l.iter().fold(false,\
    \ |acc, x| acc && x.pairs().fold(false, |acc, y| acc && y.sum() == 0))\n   | \
    \                                           ^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpq4w6yal8.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq4w6yal8.rs:16:9\n   |\n16 |     for &x in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpq4w6yal8.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4w6yal8.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for &i in l {\n        if i != 0 {\n            pairs.push(i);\n         \
    \   sum += i;\n        }\n    }\n    if sum == 0 {\n        return true;\n   \
    \ }\n    let mut i = 0;\n    while i < pairs.len() {\n        if pairs[i] == 0\
    \ {\n            pairs.remove(&i);\n            i += 1;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    pairs.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpapq_y303.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpapq_y303.rs:29:26\n   |\n29 |             pairs.remove(&i);\n \
    \  |                          ^^ expected `usize`, found `&usize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n29 -             pairs.remove(&i);\n29 +\
    \             pairs.remove(i);\n   | \n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for x in l {\n        if x == 0 {\n            pairs.push((sum, 0));\n   \
    \     } else {\n            pairs.push((sum, x + 1));\n            sum += x;\n\
    \        }\n    }\n    pairs.len() == 1 && pairs.iter().all(|&(_, y)| y == 0)\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpob8stl6b.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffis2ch_.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpffis2ch_.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 2\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp972i4m34.rs:19:17\n\
    \    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |           \
    \           - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l {\n    |\
    \              - `l` moved due to this implicit call to `.into_iter()`\n...\n\
    19  |     sum == 0 && l.len() == 2\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n  \
    \          i += 1;\n            j += 1;\n        } else {\n            sum +=\
    \ l[i];\n            i += 1;\n        }\n    }\n    sum == 0 && j == l.len()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp38t5fbko.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for &i in l {\n        if i != 0 {\n            pairs.push((i, sum));\n  \
    \          sum += i;\n        }\n    }\n    pairs.len() == 1 && pairs.iter().all(|&(_,\
    \ s)| s == 0)\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpofgechk7.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpae0mp6qv.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpae0mp6qv.rs:19:51\n   |\n19\
    \ |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == l.len()\n\
    \   |                                                   ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpae0mp6qv.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == l.len()\n   |                                           \
    \                         ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for &x in l {\n        if x == 0 {\n            pairs.push((sum, false));\n\
    \            sum = 0;\n        } else {\n            sum += x;\n        }\n  \
    \  }\n    pairs.len() == 1 && pairs[0].0 == 0 && pairs[0].1\n}\n\nfn main() {\n\
    \    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpst1hhehp.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for x in l {\n        if pairs.iter().any(|&y| y > x) {\n            pairs.push(x);\n\
    \            sum += x;\n        }\n    }\n    pairs.iter().any(|&x| x == 0 ||\
    \ x == sum)\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptux0g6xr.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp6axyioht.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:16:9\n   |\n16 | \
    \    for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp6axyioht.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return true;\n        }\n       \
    \ seen.insert(i);\n    }\n    false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpr0cmiw6g.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr0cmiw6g.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpalq0abci.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpalq0abci.rs:19:51\n   |\n19\
    \ |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == l.len()\n\
    \   |                                                   ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpalq0abci.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i|\
    \ i == 0).count() == l.len()\n   |                                           \
    \                         ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffis2ch_.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpffis2ch_.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    while i\
    \ < l.len() {\n        sum += l[i];\n        i += 1;\n    }\n    sum == 0 && l.len()\
    \ == i\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2ln6k2mc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] + l[j] == 0 {\n\
    \            i += 1;\n            j += 1;\n        } else {\n            sum +=\
    \ l[i] + l[j];\n            i += 1;\n            j += 1;\n        }\n    }\n \
    \   sum == 0 && i == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpguxjcb9m.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppn9wlkv0.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    \   |                                                   ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppn9wlkv0.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    \   |                                                   ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] - l[j] == 0 {\n\
    \            sum += l[i];\n            i += 1;\n            j += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    sum == 0 && i == l.len()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl977n8im.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpsr5fe6gy.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i != 0).count() && l.iter().filter(|&i| i != 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsr5fe6gy.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpsr5fe6gy.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i != 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsr5fe6gy.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for &i in l {\n        if i != 0 {\n            sum += i;\n            pairs.push(i);\n\
    \        }\n    }\n    if sum == 0 {\n        false\n    } else {\n        pairs.iter().all(|&i|\
    \ i == 0)\n    }\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprb2eqkze.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpi_oekgja.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpi_oekgja.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi_oekgja.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp6axyioht.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:16:9\n   |\n16 | \
    \    for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp6axyioht.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    for i in l {\n     \
    \   for j in l {\n            if i != j && i + j == 0 {\n                pairs.push((i,\
    \ j));\n            }\n        }\n    }\n    pairs.len() == l.len() && pairs.iter().all(|&(_,\
    \ v)| v == 0)\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpnwso4c24.rs:17:18\n\
    \    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |           \
    \           - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n15  |     let mut pairs = vec![];\n16  |     for i in l {\n\
    \    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    17  |         for j in l {\n    |                  ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for &x in l {\n        if x >= 0 {\n            pairs.push((x, sum));\n  \
    \      }\n        sum += x;\n    }\n    let mut seen = vec![];\n    for &(x, y)\
    \ in pairs {\n        if seen.contains(&y) {\n            return false;\n    \
    \    }\n        seen.push(y);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmponoa6nji.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmponoa6nji.rs:24:9\n   |\n24 |     for &(x, y) in pairs {\n   | \
    \        ^^^^^^^    ----- this expression has type `Option<(_, {integer})>`\n\
    \   |         |\n   |         expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(_, {integer})`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for x in l {\n        if sum == 0 {\n            pairs.push((x, 0));\n   \
    \     } else {\n            pairs.push((x, sum));\n        }\n        sum += x;\n\
    \    }\n    pairs.len() == 1 && pairs.iter().all(|&(_, y)| y == 0)\n}\n\nfn main()\
    \ {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4uqbn2bl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n  \
    \          i += 1;\n            j += 1;\n        } else {\n            sum +=\
    \ l[i];\n            i += 1;\n        }\n    }\n    sum == 0 && j == l.len()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp38t5fbko.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n  \
    \          i += 1;\n            j += 1;\n            sum += 1;\n        } else\
    \ {\n            if sum == 0 {\n                return false;\n            }\n\
    \            i += 1;\n            sum += 1;\n        }\n    }\n    sum == 0\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbn10np8f.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for i in l {\n        if i != 0 {\n            sum += i;\n            pairs.push(i);\n\
    \        }\n    }\n    if sum == 0 {\n        pairs.iter().all(|&x| x == 0)\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq55wg3y2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && x.pairs().fold(false,\
    \ |acc, y| acc && y.sum() == 0))\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pairs` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmps6fya33t.rs:15:44\n   |\n15 |     l.iter().fold(false,\
    \ |acc, x| acc && x.pairs().fold(false, |acc, y| acc && y.sum() == 0))\n   | \
    \                                           ^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut seen = HashSet::new();\n\
    \    for &x in l {\n        if seen.contains(&x) {\n            return false;\n\
    \        }\n        seen.insert(x);\n        sum += x;\n    }\n    sum == 0\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvicd4vwr.rs:16:20\n   |\n16 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvicd4vwr.rs:17:9\n   |\n17 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return true;\n        }\n       \
    \ seen.insert(i);\n    }\n    false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpr0cmiw6g.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr0cmiw6g.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9gxbki3.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpu9gxbki3.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = Vec::new();\n\
    \    for x in l {\n        if x == 0 {\n            pairs.push(vec![]);\n    \
    \    } else {\n            pairs.push(vec![x, sum]);\n        }\n        sum +=\
    \ x;\n    }\n    let mut pairs = pairs.into_iter().filter(|x| x.len() == 2).collect::<Vec<_>>();\n\
    \    pairs.iter().any(|x| x.iter().all(|y| y == 0))\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp2nsgmdfx.rs:26:45\n\
    \   |\n26 |     pairs.iter().any(|x| x.iter().all(|y| y == 0))\n   |         \
    \                                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &i in l {\n        if i == 0 {\n            found = true;\n        } else\
    \ {\n            sum += i;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp15mcn7xw.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = Vec::new();\n\
    \    for x in l {\n        if x == 0 {\n            pairs.push((x, sum));\n  \
    \      } else {\n            sum += x;\n        }\n    }\n    pairs.len() == 2\
    \ && pairs.iter().all(|&(_, y)| y == 0)\n}\n\nfn main() {\n    let candidate =\
    \ pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n  \
    \  assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1zmmdn56.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for &i in l {\n        sum += i;\n        pairs.push(i);\n    }\n    let mut\
    \ pair_count = 0;\n    for &i in pairs {\n        if sum == 0 {\n            return\
    \ false;\n        }\n        sum += i;\n        pair_count += 1;\n    }\n    pair_count\
    \ == pairs.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1xfnzp3b.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n\
    \            sum += l[i];\n            i += 1;\n            j += 1;\n        }\
    \ else {\n            if sum == 0 {\n                return false;\n         \
    \   }\n            sum -= l[i];\n            i += 1;\n        }\n    }\n    if\
    \ i == l.len() {\n        return true;\n    }\n    if j == l.len() {\n       \
    \ return false;\n    }\n    false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzzox6pyz.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzu3nsmcs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzu3nsmcs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n  \
    \          i += 1;\n            j += 1;\n        } else {\n            sum +=\
    \ l[i];\n            i += 1;\n        }\n    }\n    sum == 0 && i != l.len()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg5bcx4hh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 2\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjdpns02j.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpae0mp6qv.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpae0mp6qv.rs:19:51\n   |\n19\
    \ |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == l.len()\n\
    \   |                                                   ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpae0mp6qv.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == l.len()\n   |                                           \
    \                         ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for x in l {\n        if sum == 0 {\n            found = true;\n        }\n\
    \        sum += x;\n    }\n    found\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpif77e3ps.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffis2ch_.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpffis2ch_.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 2\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy4qmdk0q.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &x in l {\n        if seen.contains(&x) {\n            return false;\n\
    \        }\n        seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpqa7ppcl6.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpqa7ppcl6.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqa7ppcl6.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for &x in l {\n        if x == 0 {\n            pairs.push((x, sum));\n  \
    \      } else {\n            sum += x;\n        }\n    }\n    pairs.len() == 2\
    \ && pairs.iter().all(|&(_, s)| s == 0)\n}\n\nfn main() {\n    let candidate =\
    \ pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n  \
    \  assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpah7i09ru.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp6axyioht.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:16:9\n   |\n16 | \
    \    for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp6axyioht.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 2\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjdpns02j.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for x in l {\n        if seen.contains(&x) {\n            return false;\n\
    \        }\n        seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpk6sqk599.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpk6sqk599.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpsr5fe6gy.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i != 0).count() && l.iter().filter(|&i| i != 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsr5fe6gy.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpsr5fe6gy.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i != 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsr5fe6gy.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n\
    \            sum += l[i];\n            i += 1;\n            j += 1;\n        }\
    \ else {\n            if sum == 0 {\n                return false;\n         \
    \   }\n            sum -= l[i];\n            i += 1;\n        }\n    }\n    sum\
    \ == 0 && i == l.len() && j == l.len()\n}\n\nfn main() {\n    let candidate =\
    \ pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n  \
    \  assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqdtqlduv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return true;\n\
    \        }\n        seen.insert(i);\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8uewy15b.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8uewy15b.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8uewy15b.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9gxbki3.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpu9gxbki3.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && x.iter().fold(false,\
    \ |acc, y| acc && y == 0))\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp_11fayms.rs:15:44\n   |\n15 |     l.iter().fold(false,\
    \ |acc, x| acc && x.iter().fold(false, |acc, y| acc && y == 0))\n   |        \
    \                                    ^^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut seen = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n        sum += i;\n    }\n    sum == 0 &&\
    \ true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpttghvfjp.rs:16:20\n   |\n16 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpttghvfjp.rs:17:9\n   |\n17 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 2\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjdpns02j.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum\
    \ = 0;\n    while i < l.len() && j < l.len() {\n        if l[i] == l[j] {\n  \
    \          i += 1;\n            j += 1;\n        } else {\n            sum +=\
    \ l[i];\n            i += 1;\n        }\n    }\n    sum == 0\n}\n\nfn main() {\n\
    \    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuaw0cs3j.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9gxbki3.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpu9gxbki3.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for x in l {\n        if x == 0 {\n            pairs.push(vec![]);\n     \
    \   } else {\n            pairs.push(vec![x, sum]);\n            sum += x;\n \
    \       }\n    }\n    let mut pair = pairs.iter().cloned().collect::<Vec<_>>();\n\
    \    pairs.iter().cloned().for_each(|x| {\n        if x.len() == 2 {\n       \
    \     if x[0] + x[1] == 0 {\n                pair.remove(x);\n            }\n\
    \        }\n    });\n    pairs.len() == 0 && pairs.iter().all(|x| x.len() == 2)\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7yw6cumf.rs:29:29\n   |\n\
    29 |                 pair.remove(x);\n   |                             ^ expected\
    \ `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n      \
    \      found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9gxbki3.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpu9gxbki3.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffis2ch_.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpffis2ch_.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &x in l {\n        if seen.contains(&x) {\n            return true;\n\
    \        }\n        seen.insert(x);\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmplbv8sv1m.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmplbv8sv1m.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplbv8sv1m.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpq4w6yal8.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq4w6yal8.rs:16:9\n   |\n16 |     for &x in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpq4w6yal8.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4w6yal8.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    let mut sum = 0;\n \
    \   for x in l {\n        pairs.push((x, sum));\n        sum += x;\n    }\n  \
    \  let mut seen = vec![];\n    for (x, y) in pairs {\n        if seen.is_empty()\
    \ {\n            seen.push(x);\n        }\n        if seen.is_empty() {\n    \
    \        seen.push(y);\n        }\n        if seen.is_empty() {\n            return\
    \ false;\n        }\n        if seen[0] != x {\n            return false;\n  \
    \      }\n        if seen[1] != y {\n            return false;\n        }\n  \
    \      seen.clear();\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpjkgmmiqv.rs:35:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pair = false;\n   \
    \ for &i in l {\n        if i != 0 {\n            sum += i;\n            if sum\
    \ == 0 {\n                pair = true;\n            }\n        }\n    }\n    pair\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9joc39ae.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp6txell4_.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i != 0).count() && l.iter().filter(|&i| i !=\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6txell4_.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmp6txell4_.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i != 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6txell4_.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i != 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffis2ch_.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpffis2ch_.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return false;\n        }\n      \
    \  seen.insert(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp09dshma8.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp09dshma8.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkq2_42bf.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzu3nsmcs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return true;\n        }\n       \
    \ seen.insert(i);\n    }\n    false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpr0cmiw6g.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr0cmiw6g.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 101
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pair = false;\n   \
    \ for i in l.iter() {\n        sum += i;\n        if sum == 0 {\n            pair\
    \ = true;\n            break;\n        }\n    }\n    pair\n}\n\nfn main() {\n\
    \    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwhyud1i2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpoo638s7r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoo638s7r.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoo638s7r.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n\
    }\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffis2ch_.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpffis2ch_.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\n   |              \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ihx31lf.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp6axyioht.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:16:9\n   |\n16 | \
    \    for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp6axyioht.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpwtt5e2yz.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwtt5e2yz.rs:19:51\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                   ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwtt5e2yz.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i|\
    \ i == 0).count() == 2\n   |                                                 \
    \                   ^ expected `bool`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = vec![];\n \
    \   for &x in l {\n        if x == 0 {\n            pairs.push(vec![]);\n    \
    \    } else {\n            sum += x;\n            pairs.push(vec![sum, x - 1]);\n\
    \        }\n    }\n    let mut seen = vec![];\n    for &x in pairs {\n       \
    \ if !seen.contains(&x[0]) {\n            seen.push(&x[0]);\n        }\n    }\n\
    \    seen.len() == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ls0ojne.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2ls0ojne.rs:26:9\n   |\n26 |     for &x in pairs {\n   |      \
    \   ^^    ----- this expression has type `Option<Vec<{integer}>>`\n   |      \
    \   |\n   |         expected struct `Vec`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `x`\n   |\n   = note: expected\
    \ struct `Vec<{integer}>`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for &i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9h7efc0j.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9h7efc0j.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h7efc0j.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    for &i in l {\n    \
    \    for &j in l {\n            if i + j == 0 {\n                pairs.push((i,\
    \ j));\n            }\n        }\n    }\n    pairs.len() == 2 && pairs.iter().all(|&(i,\
    \ j)| i == j)\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_brdldo.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu_brdldo.rs:17:13\n   |\n17 |         for &j in l {\n   |     \
    \        ^^    - this expression has type `Option<isize>`\n   |             |\n\
    \   |             expected `isize`, found reference\n   |             help: you\
    \ can probably remove the explicit borrow: `j`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp5b4a2i69.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmp5b4a2i69.rs:19:51\n   |\n19\
    \ |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == l.len()\n\
    \   |                                                   ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5b4a2i69.rs:19:68\n   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x|\
    \ x == 0).count() == l.len()\n   |                                           \
    \                         ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for i in l {\n        if seen.contains(&i) {\n            return false;\n\
    \        }\n        seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpb774xhts.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpb774xhts.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp25e5_2ue.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:16:9\n   |\n16 | \
    \    for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp25e5_2ue.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&i| i == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25e5_2ue.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &x in l {\n\
    \        if seen.contains(&x) {\n            return true;\n        }\n       \
    \ seen.insert(x);\n    }\n    false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvcwg6sjo.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvcwg6sjo.rs:16:9\n   |\n16 |     for &x in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = Vec::new();\n\
    \    for &x in l {\n        if x == 0 {\n            pairs.push((x, sum));\n \
    \       } else {\n            sum += x;\n        }\n    }\n    pairs.len() ==\
    \ 2 && pairs.iter().all(|&(_, y)| y == 0)\n}\n\nfn main() {\n    let candidate\
    \ = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvr9mfw04.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count()\
    \ == 2\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp6axyioht.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                         ^^                                      ^^\n\
    \   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&x| x == 0).count() && l.iter().filter(|&x| x == 0).count()\
    \ == 2\n   |                                                                 +++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:16:9\n   |\n16 | \
    \    for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp6axyioht.rs:19:51\n   |\n19 |     sum\
    \ == 0 && l.len() == l.iter().filter(|&x| x == 0).count() == 2\n   |         \
    \                                          ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6axyioht.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&x| x == 0).count() ==\
    \ 2\n   |                                                                    ^\
    \ expected `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen = HashSet::new();\n    for &i in l {\n\
    \        if seen.contains(&i) {\n            return false;\n        }\n      \
    \  seen.insert(i);\n    }\n    true\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp93j6wta6.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp93j6wta6.rs:16:9\n   |\n16 |     for &i in l\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().enumerate().any(|(i, v)| v == 0 && i !=\
    \ 0)\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpm_czomlu.rs:15:41\n\
    \   |\n15 |     l.iter().enumerate().any(|(i, v)| v == 0 && i != 0)\n   |    \
    \                                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && x.iter().fold(false,\
    \ |acc, y| acc && y == 0))\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n \
    \   assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]),\
    \ false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp_11fayms.rs:15:44\n   |\n15 |     l.iter().fold(false,\
    \ |acc, x| acc && x.iter().fold(false, |acc, y| acc && y == 0))\n   |        \
    \                                    ^^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011421
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count()\
    \ == l.len()\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjow0qk9r.rs:19:25\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                         ^^                                   \
    \   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |     sum == 0 &&\
    \ l.len() == l.iter().filter(|&i| i == 0).count() && l.iter().filter(|&i| i ==\
    \ 0).count() == l.len()\n   |                                                \
    \                 +++++++++++++++++++++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjow0qk9r.rs:16:9\n   |\n16 |     for &i in l {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjow0qk9r.rs:19:51\n   |\n19 |     sum == 0 && l.len()\
    \ == l.iter().filter(|&i| i == 0).count() == l.len()\n   |                   \
    \                                ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjow0qk9r.rs:19:68\n\
    \   |\n19 |     sum == 0 && l.len() == l.iter().filter(|&i| i == 0).count() ==\
    \ l.len()\n   |                                                              \
    \      ^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011420
- exit_code: 1
  program: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
    \ True if there are two distinct elements in the list that\n/// sum to zero, and\
    \ False otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n///\
    \ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n///\
    \ true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut pairs = vec![];\n    for i in l {\n     \
    \   for j in l {\n            if i == j {\n                continue;\n       \
    \     }\n            if i + j == 0 {\n                pairs.push((i, j));\n  \
    \          }\n        }\n    }\n    pairs.len() == 1 && pairs.iter().all(|&(_,\
    \ v)| v == 0)\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
    \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
    \ 9, -1, 4, 2, 31]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmp8zzl7iuw.rs:17:18\n\
    \    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |           \
    \           - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n15  |     let mut pairs = vec![];\n16  |     for i in l {\n\
    \    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    17  |         for j in l {\n    |                  ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011421
