language: rs
name: HumanEval_120_maximum
results:
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut max_arr = vec![];\n    let mut max_val = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_val {\n            max_val = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_val {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgn94epm9.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgn94epm9.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgn94epm9.rs:24:23\n   |\n24 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgn94epm9.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpgn94epm9.rs:29:26\n   |\n29 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        arr\n    } else {\n\
    \        let mut max_idx = arr.len();\n        let mut max_val = arr[0];\n   \
    \     for i in 1..k {\n            if arr[i] > max_val {\n                max_idx\
    \ = i;\n                max_val = arr[i];\n            }\n        }\n        arr.split_off(max_idx).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_2qxoea.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpn_2qxoea.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_val {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_2qxoea.rs:24:27\n\
    \   |\n20 |         let mut max_idx = arr.len();\n   |                       \
    \    --------- expected due to this value\n...\n24 |                 max_idx =\
    \ i;\n   |                           ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpn_2qxoea.rs:25:27\n\
    \   |\n25 |                 max_val = arr[i];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpn_2qxoea.rs:28:32\n    |\n28\
    \  |           arr.split_off(max_idx).collect()\n    |                       \
    \           ^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting du"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[1] {\n            max_arr[1] = arr[i];\n           \
    \ max_k = 1;\n        }\n        if arr[i] > max_arr[2] {\n            max_arr[2]\
    \ = arr[i];\n            max_k = 2;\n        }\n        if arr[i] > max_arr[3]\
    \ {\n            max_arr[3] = arr[i];\n            max_k = 3;\n        }\n   \
    \     if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n           \
    \ max_k = 4;\n        }\n        if arr[i] > max_arr[5] {\n            max_arr[5]\
    \ = arr[i];\n            max_k = 5;\n        }\n        i += 1;\n    }\n    if\
    \ max_k == 0 {\n        max_arr\n    } else {\n        max_arr.iter().take(max_k).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9t17t9fi.rs:50:29\n   |\n\
    50 |         max_arr.iter().take(max_k).collect()\n   |                      \
    \       ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n50\
    \ |         max_arr.iter().take(max_k.try_into().unwrap()).collect()\n   |   \
    \                               ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmp9t17t9fi.rs:50:36\n     |\n50   |         max_arr.iter().take(max_k).collect()\n\
    \     |                                    ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = vec![];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i]\
    \ = i;\n    }\n    for i in 0..k {\n        let mut max_val = max_arr[i];\n  \
    \      let mut max_idx = i;\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_val {\n                max_val = max_arr[j];\n                max_idx\
    \ = j;\n            }\n        }\n        max_arr[max_idx] = max_val;\n      \
    \  max_idx[max_idx] = i;\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp0bq3p_z_.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp0bq3p_z_.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp0bq3p_z_.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp0bq3p_z_.rs:24:27\n\
    \   |\n24 |         let mut max_val = max_arr[i];\n   |                      \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp0bq3p_z_.rs:27:16\n\
    \   |\n27 |             if max_arr[j] > max_val {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_num = arr[0];\n        let mut max_idx = 1;\n       \
    \ for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_num;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:28:23\n\
    \   |\n28 |         vec![max_num; max_idx + 1]\n   |                       ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                       +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ arr;\n    }\n    let mut max_idx = arr.len() - 1;\n    let mut max_val = arr[0];\n\
    \    let mut max_so_far = arr[0];\n    for i in 1..arr.len() {\n        if arr[i]\
    \ > max_val {\n            max_val = arr[i];\n            max_idx = i;\n     \
    \   }\n        if arr[i] > max_so_far {\n            max_so_far = arr[i];\n  \
    \      }\n    }\n    let mut result = vec![max_val];\n    for i in 0..k {\n  \
    \      result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpab6r_sjv.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if max_num < arr[i] {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp21nmp8q6.rs:20:22\n\
    \   |\n20 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp21nmp8q6.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp21nmp8q6.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp21nmp8q6.rs:26:26\n   |\n26 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = 0;\n    for idx in 0..arr.len() {\n        if idx\
    \ > max_k {\n            break;\n        }\n        if idx > max_idx {\n     \
    \       max_idx = idx;\n        }\n        if arr[idx] > max_arr[0] {\n      \
    \      max_arr[0] = arr[idx];\n        }\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr.truncate(max_k);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppvrr7u0e.rs:21:18\n   |\n\
    21 |         if idx > max_k {\n   |                  ^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |         if idx > max_k.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppvrr7u0e.rs:32:22\n   |\n32 |     max_arr.truncate(max_k);\n\
    \   |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n32 |     max_arr.truncate(max_k.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    let mut max_pos = 0;\n    let mut pos = 0;\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n            max_pos = pos;\n        }\n        pos = pos + 1;\n \
    \       i = i + 1;\n    }\n    max_arr.push(max_num);\n    if max_pos < k {\n\
    \        max_arr.push(arr[max_pos]);\n    }\n    max_arr\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxmiib1g.rs:32:22\n\
    \   |\n32 |         max_arr.push(arr[max_pos]);\n   |                      ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for i in\
    \ 1..k {\n        if arr[i] > max {\n            max = arr[i];\n            max_idx\
    \ = i;\n        }\n    }\n    let mut res = vec![max];\n    for i in 0..max_idx\
    \ - 1 {\n        res.push(arr[i]);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl2bg6exr.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpl2bg6exr.rs:23:12\n\
    \   |\n23 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpl2bg6exr.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpl2bg6exr.rs:30:18\n   |\n30 |         res.push(arr[i]);\n\
    \   |                  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_arr[1] {\n            max_arr[1] = arr[i];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[2] {\n            max_arr[2] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[3] {\n   \
    \         max_arr[3] = arr[i];\n        }\n    }\n    for i in 0..k {\n      \
    \  if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_arr[5] {\n            max_arr[5]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[6]\
    \ {\n            max_arr[6] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[7] {\n            max_arr[7] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_arr[8] {\n            max_arr[8]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[9]\
    \ {\n            max_arr[9] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[10] {\n            max_arr[10] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[11] {\n        \
    \    max_arr[11] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[12] {\n            max_arr[12] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[13] {\n            max_arr[13]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[14]\
    \ {\n            max_arr[14] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[15] {\n            max_arr[15] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[16] {\n        \
    \    max_arr[16] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[17] {\n            max_arr[17] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[18\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfandujqm.rs:130:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    113 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n114 |         if arr[i] > max_arr[18\n115 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n130 | }\n   \
    \ |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpfandujqm.rs:115:1\n\
    \    |\n114 |         if arr[i] > max_arr[18\n    |         -- this `if` expression\
    \ has a condition, but no block\n115 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmpfandujqm.rs:114:28\n    |\n16  | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n    |                               \
    \                      - closing delimiter possibly meant for this\n...\n114 |\
    \         if arr[i] > max_arr[18\n    |                            ^ unclosed\
    \ delimiter\n115 | }\n    | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfandujqm.rs:17:31\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k {\n   |                               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if k == 0 || arr.len() <= k.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfandujqm.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfandujqm.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |        "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n \
    \   for i in 0..arr.len() {\n        if arr[i] > max_arr[k] {\n            max_arr[k]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[k];\n    }\n    max_arr.push(arr[max_idx]);\n  \
    \  max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpzo76of7g.rs:23:21\n\
    \   |\n23 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpzo76of7g.rs:24:13\n\
    \   |\n24 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpzo76of7g.rs:21:23\n   |\n21 | \
    \    let mut max_idx = -1;\n   |                       ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the type `[_]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpzo76of7g.rs:29:9\n   |\n29 |         max_arr[i]\
    \ = max_arr[k];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpzo76of7g.rs:29:22\n   |\n29 |         max_arr[i] = max_arr[k];\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `Slice"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr;\n    }\n    let mut max_so_far = arr[0];\n    let mut max_so_far_index\
    \ = 0;\n    let mut max_so_far_max_index = 0;\n    for i in 1..k {\n        if\
    \ arr[i] > max_so_far {\n            max_so_far = arr[i];\n            max_so_far_index\
    \ = i;\n            max_so_far_max_index = i;\n        }\n    }\n    for i in\
    \ 0..k {\n        if i == max_so_far_max_index {\n            arr[i] = max_so_far;\n\
    \        } else {\n            arr[i] = arr[i] - max_so_far;\n        }\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwymux2uy.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwymux2uy.rs:24:12\n\
    \   |\n24 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwymux2uy.rs:25:26\n   |\n25 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwymux2uy.rs:32:13\n   |\n32 |            \
    \ arr[i] = max_so_far;\n   |             ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwymux2uy.rs:34:13\n   |\n34 |            \
    \ arr[i] = arr[i] - max_so_far;\n   |             ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_val = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_val {\n            max_val = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_val {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjg2t9j_7.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjg2t9j_7.rs:24:23\n   |\n24 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjg2t9j_7.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjg2t9j_7.rs:29:26\n   |\n29 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_num = arr[0];\n  \
    \      for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n            }\n        }\n        for i in 0..k {\n            if\
    \ arr[i] > max_num {\n                max_arr.push(max_num);\n               \
    \ max_num = arr[i];\n            }\n        }\n        max_arr.push(max_num);\n\
    \        max_arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkyu6zio3.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkyu6zio3.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkyu6zio3.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkyu6zio3.rs:28:16\n   |\n28 |            \
    \ if arr[i] > max_num {\n   |                ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkyu6zio3.rs:30:27\n   |\n30 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `i"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    vec![max; k - max_idx]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:19\n   |\n\
    25 |     vec![max; k - max_idx]\n   |                   ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:15\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |               ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |     vec![max; (k -\
    \ max_idx).try_into().unwrap()]\n   |               +           +++++++++++++++++++++\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpz6v_s1uj.rs:25:17\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |                 ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 && max_k > 0 {\n\
    \        if arr[max_idx] > arr[max_idx - 1] {\n            max_k -= 1;\n     \
    \   } else {\n            max_idx -= 1;\n        }\n    }\n    max_arr.extend(&arr[..max_idx]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp_9c3tnhu.rs:21:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut min_arr = vec![];\n    let mut min_k = k;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut max_val = arr[0];\n    let mut min_val\
    \ = arr[0];\n    for i in arr.iter() {\n        if i > max_val {\n           \
    \ max_val = i;\n            max_pos = i;\n        }\n        if i < min_val {\n\
    \            min_val = i;\n            min_pos = i;\n        }\n        if i ==\
    \ max_val {\n            max_arr.push(max_pos);\n            max_k -= 1;\n   \
    \     }\n        if i == min_val {\n            min_arr.push(min_pos);\n     \
    \       min_k -= 1;\n        }\n    }\n    if max_k == 0 {\n        max_arr.push(max_pos);\n\
    \    }\n    if min_k == 0 {\n        min_arr.push(min_pos);\n    }\n    if max_k\
    \ > min_k {\n        max_arr.push(max_pos);\n        max_arr.push(min_pos);\n\
    \    }\n    if max_k == min_k {\n        max_arr.push(max_pos);\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(min_pos);\n    }\n    if max_k == 0 {\n\
    \        max_arr.push(min_pos);\n    }\n    if min_k == 0 {\n        min_arr.push(min_pos);\n\
    \    }\n    if max_k > min_k {\n        max_arr.push(min_pos);\n        max_arr.push(max_pos);\n\
    \    }\n    if max_k == min_k {\n        max_arr.push(min_pos);\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(max_pos);\n    }\n    if max_k == 0 {\n\
    \        max_arr.push(max_pos);\n    }\n    if min_k == 0 {\n        min_arr.push(min_pos);\n\
    \    }\n    if max_k > min_k {\n        max_arr.push(min_pos);\n        max_arr.push(min_pos);\n\
    \    }\n    if max_k == min_k {\n        max_arr.push(min_pos);\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(min_pos);\n    }\n    if max_k == 0 {\n\
    \        max_arr.push(min_pos);\n    }\n    if min_k == 0 {\n        min_arr.push(min_pos);\n\
    \    }\n    if max_k > min_k {\n        max_arr.push(min_pos);\n        min_arr.push(min_pos);\n\
    \    }\n    if max_k == min_k {\n        max_arr.push(min_pos);\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(min_pos);\n    }\n    if max_k == 0 {\n\
    \        max_arr.push(min_pos);\n    }\n    if min_k == \n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmput3bmijh.rs:111:1\n\
    \    |\n111 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmput3bmijh.rs:26:16\n   |\n26 |         if i > max_val {\n   |  \
    \              ^^^^^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max_val`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmput3bmijh.rs:27:23\n   |\n23 |\
    \     let mut max_val = arr[0];\n   |                       ------ expected due\
    \ to this value\n...\n27 |             max_val = i;\n   |                    \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n27 |             max_val = *i;\n   |                       +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmput3bmijh.rs:28:23\n   |\n22 |\
    \     let mut max_pos = 0;\n   |                       - expected due to this\
    \ value\n...\n28 |             max_pos = i;\n   |                       ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    28 |             max_pos = *i;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmput3bmijh.rs:30:16\n   |\n30 |         if i <\
    \ min_val {\n   |                ^^^^^^^\n   |                |\n   |        \
    \        expected `&isize`, found `isize`\n   |                help: consider\
    \ borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmput3bmijh.rs:31:23\n\
    \   |\n24 |     let mut min_val = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n31 |             min_val = i;\n   |                \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n31 |             min_val = *i;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmput3bmijh.rs:32:23\n   |\n\
    21 |     let mut min_pos = 0;\n   |                       - expected due to this\
    \ value\n...\n32 |             min_pos = i;\n   |                       ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 "
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut max_list\
    \ = vec![];\n    for i in 0..k {\n        max_list.push(arr[max_idx]);\n     \
    \   max_idx += 1;\n    }\n    max_list\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpq3obmzm_.rs:27:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphpzdnxyj.rs:137:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    119 |     for i in 0..k {\n    |                   - unclosed delimiter\n120 |\
    \         if arr[i] > max_num {\n    |                             - this delimiter\
    \ might not be properly closed...\n121 |             max_\n122 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n137 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmphpzdnxyj.rs:121:13\n\
    \    |\n121 |             max_\n    |             ^^^^ not found in this scope\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphpzdnxyj.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphpzdnxyj.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphpzdnxyj.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isi"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = vec![];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i]\
    \ = i;\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[i] {\n                max_arr[j] = max_arr[i];\n                max_idx[j]\
    \ = max_idx[i];\n            }\n        }\n    }\n    for i in 0..k {\n      \
    \  arr[i] = max_arr[i];\n    }\n    for i in 0..k {\n        arr[i] = max_idx[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpe1pc3f53.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpe1pc3f53.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpe1pc3f53.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpe1pc3f53.rs:25:16\n\
    \   |\n25 |             if max_arr[j] > max_arr[i] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpe1pc3f53.rs:25:29\n\
    \   |\n25 |             if max_arr[j] > max_arr[i] {\n   |                   \
    \          ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = h"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = -1;\n      \
    \  for (i, v) in arr.iter().enumerate() {\n            if i == k {\n         \
    \       break;\n            }\n            if v > max_arr[k] {\n             \
    \   max_arr[k] = v;\n                max_idx = i;\n            }\n        }\n\
    \        max_arr.iter().cloned().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkq3p6agc.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkq3p6agc.rs:23:21\n   |\n23 |             if i == k {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n23 |             if i == k.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpkq3p6agc.rs:26:20\n   |\n26 |             if v > max_arr[k]\
    \ {\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkq3p6agc.rs:27:17\n   |\n27 |                 max_arr[k] = v;\n\
    \   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpkq3p6agc.rs:21:27\n   |\n21 |         let mut max_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    an"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_num = arr[0];\n        let mut max_idx = 1;\n       \
    \ for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_num;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:28:23\n\
    \   |\n28 |         vec![max_num; max_idx + 1]\n   |                       ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                       +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    for ele in arr {\n        if max_len < ele {\n            max_len\
    \ = ele;\n        }\n    }\n    for i in 0..max_len {\n        max_arr.push(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpf3fe1g54.rs:25:22\n\
    \   |\n25 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        max_arr.push(arr[i]);\n    }\n    for i in 0..k {\n        let mut\
    \ max_num = max_arr[i];\n        for j in (i + 1)..arr.len() {\n            if\
    \ arr[j] > max_num {\n                max_num = arr[j];\n            }\n     \
    \   }\n        max_arr.push(max_num);\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7hqqd31c.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7hqqd31c.rs:22:27\n   |\n22 |  \
    \       let mut max_num = max_arr[i];\n   |                           ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7hqqd31c.rs:23:27\n   |\n23 |         for j\
    \ in (i + 1)..arr.len() {\n   |                           ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp7hqqd31c.rs:24:16\n   |\n24 |             if arr[j] > max_num {\n\
    \   |                ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7hqqd31c.rs:25:27\n\
    \   |\n25 |                 max_num = arr[j];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_val = arr[0];\n    for v in arr.iter() {\n        if v\
    \ > max_val {\n            max_val = v;\n        }\n        if k == 0 {\n    \
    \        break;\n        }\n        if v > max_val {\n            max_arr = vec![];\n\
    \            max_k = k;\n            max_val = v;\n        }\n        if k ==\
    \ max_k {\n            max_arr.push(v);\n        }\n        k -= 1;\n    }\n \
    \   max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp952wul99.rs:21:16\n   |\n\
    21 |         if v > max_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&isize`, found `isize`\n   |            \
    \    help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp952wul99.rs:22:23\n   |\n19 |     let mut max_val = arr[0];\n \
    \  |                       ------ expected due to this value\n...\n22 |      \
    \       max_val = v;\n   |                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |             max_val\
    \ = *v;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp952wul99.rs:27:16\n   |\n27 |         if v > max_val {\n   |       \
    \         ^^^^^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max_val`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp952wul99.rs:30:23\n   |\n19 |\
    \     let mut max_val = arr[0];\n   |                       ------ expected due\
    \ to this value\n...\n30 |             max_val = v;\n   |                    \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n30 |             max_val = *v;\n   |                       +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp952wul99.rs:37:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n37 |     max_arr\n   |     ^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:19:12\n\
    \   |\n19 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    let\
    \ mut max_val = arr[0];\n    for i in 0..k {\n        if arr[i] > max_val {\n\
    \            max_val = arr[i];\n            max_idx = i;\n        }\n    }\n \
    \   for i in 0..k {\n        if arr[i] == max_val {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfperzbtg.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfperzbtg.rs:24:12\n\
    \   |\n24 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfperzbtg.rs:25:23\n   |\n25 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfperzbtg.rs:30:12\n   |\n30 |         if arr[i]\
    \ == max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfperzbtg.rs:31:26\n   |\n31 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is no"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu6jwrop8.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n129 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpu6jwrop8.rs:114:1\n    |\n113 |         if arr\n\
    \    |         -- this `if` expression has a condition, but no block\n114 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6jwrop8.rs:16:42\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max = arr[0];\n    for i in 1..k {\n        if max < arr[i]\
    \ {\n            max = arr[i];\n        }\n    }\n    vec![max]\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp35i23tvn.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp35i23tvn.rs:22:18\n  \
    \ |\n22 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp35i23tvn.rs:23:19\n   |\n23 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_idx = arr.len() - 1;\n    let mut max_val = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_val {\n            max_idx = i;\n\
    \            max_val = arr[i];\n        }\n    }\n    let mut res = vec![max_val];\n\
    \    for i in 0..max_idx - 1 {\n        res.push(arr[i]);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4yf0n4si.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4yf0n4si.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4yf0n4si.rs:24:23\n\
    \   |\n20 |     let mut max_idx = arr.len() - 1;\n   |                       -------------\
    \ expected due to this value\n...\n24 |             max_idx = i;\n   |       \
    \                ^ expected `usize`, found `isize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4yf0n4si.rs:25:23\n   |\n25 |  \
    \           max_val = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = arr.len();\n\
    \        for i in 0..k {\n            if max_idx > 0 && arr[i] > arr[max_idx]\
    \ {\n                max_arr = max_arr;\n                max_idx = i;\n      \
    \      } else {\n                max_arr.push(arr[i]);\n            }\n      \
    \  }\n        max_arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaazpalp1.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpaazpalp1.rs:23:31\n   |\n23 |  \
    \           if max_idx > 0 && arr[i] > arr[max_idx] {\n   |                  \
    \             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpaazpalp1.rs:25:27\n   |\n21 |\
    \         let mut max_idx = arr.len();\n   |                           ---------\
    \ expected due to this value\n...\n25 |                 max_idx = i;\n   |   \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaazpalp1.rs:27:30\n\
    \   |\n27 |                 max_arr.push(arr[i]);\n   |                      \
    \        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    for ele in arr {\n        if max_len < ele {\n            max_len\
    \ = ele;\n        }\n    }\n    for ele in arr {\n        if max_len == ele {\n\
    \            max_arr.push(ele);\n        }\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpb0q51q8y.rs:24:16\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \         --- move occurs because `arr` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for ele in arr {\n    |         \
    \       --- `arr` moved due to this implicit call to `.into_iter()`\n...\n24 \
    \ |     for ele in arr {\n    |                ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `arr`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n19  |     for ele in &arr {\n    |\
    \                +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    let mut max_val = arr[0];\n    while\
    \ max_idx > 0 && max_k > 0 {\n        if max_val < arr[max_idx] {\n          \
    \  max_val = arr[max_idx];\n            max_idx = max_idx - 1;\n        }\n  \
    \      max_k -= 1;\n    }\n    max_arr.push(max_val);\n    max_k -= 1;\n    max_idx\
    \ -= 1;\n    while max_idx > 0 && max_k > 0 {\n        if max_val < arr[max_idx]\
    \ {\n            max_val = arr[max_idx];\n            max_idx = max_idx - 1;\n\
    \        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n    max_k\
    \ -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n        if max_val\
    \ < arr[max_idx] {\n            max_val = arr[max_idx];\n            max_idx =\
    \ max_idx - 1;\n        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n\
    \    max_k -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n  \
    \      if max_val < arr[max_idx] {\n            max_val = arr[max_idx];\n    \
    \        max_idx = max_idx - 1;\n        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n\
    \    max_k -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n  \
    \      if max_val < arr[max_idx] {\n            max_val = arr[max_idx];\n    \
    \        max_idx = max_idx - 1;\n        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n\
    \    max_k -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n  \
    \      if max_val < arr[max_idx] {\n            max_val = arr[max_idx];\n    \
    \        max_idx = max_idx - 1;\n        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n\
    \    max_k -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n  \
    \      if max_val < arr[max_idx] {\n            max_val = arr[max_idx];\n    \
    \        max_idx = max_idx - 1;\n        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n\
    \    max_k -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n  \
    \      if max_val < arr[max_idx] {\n            max_val = arr[max_idx];\n    \
    \        max_idx = max_idx - 1;\n        }\n        max_k -= 1;\n    }\n    max_arr.push(max_val);\n\
    \    max_k -= 1;\n    max_idx -= 1;\n    while max_idx > 0 && max_k > 0 {\n  \
    \      if max_val < arr[\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpewkiplgw.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    101 |     while max_idx > 0 && max_k > 0 {\n    |                            \
    \        - this delimiter might not be properly closed...\n102 |         if max_val\
    \ < arr[\n103 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n118 | }\n    |   ^\n\nerror: expected expression, found `]`\n   --> /tmp/tmpewkiplgw.rs:103:1\n\
    \    |\n103 | }\n    | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n   --> /tmp/tmpewkiplgw.rs:102:25\n    |\n16  | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    |                                           \
    \          - closing delimiter possibly meant for this\n...\n102 |         if\
    \ max_val < arr[\n    |                         ^ unclosed delimiter\n103 | }\n\
    \    | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpewkiplgw.rs:16:42\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:19:12\n\
    \   |\n19 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_idx = arr.len();\n        let mut max_val = arr[0];\n\
    \        for i in 1..k {\n            if arr[i] > max_val {\n                max_val\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_val;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_drowu8.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpn_drowu8.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_val {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn_drowu8.rs:24:27\n   |\n24 |            \
    \     max_val = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_drowu8.rs:25:27\n\
    \   |\n20 |         let mut max_idx = arr.len();\n   |                       \
    \    --------- expected due to this value\n...\n25 |                 max_idx =\
    \ i;\n   |                           ^ expected `usize`, found `isize`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 1;\n        }\n   \
    \     if arr[i] > max_arr[1] {\n            max_arr[1] = arr[i];\n           \
    \ max_k = 2;\n        }\n        if arr[i] > max_arr[2] {\n            max_arr[2]\
    \ = arr[i];\n            max_k = 3;\n        }\n        if arr[i] > max_arr[3]\
    \ {\n            max_arr[3] = arr[i];\n            max_k = 4;\n        }\n   \
    \     if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n           \
    \ max_k = 5;\n        }\n        if arr[i] > max_arr[5] {\n            max_arr[5]\
    \ = arr[i];\n            max_k = 6;\n        }\n        if arr[i] > max_arr[6]\
    \ {\n            max_arr[6] = arr[i];\n            max_k = 7;\n        }\n   \
    \     if arr[i] > max_arr[7] {\n            max_arr[7] = arr[i];\n           \
    \ max_k = 8;\n        }\n        if arr[i] > max_arr[8] {\n            max_arr[8]\
    \ = arr[i];\n            max_k = 9;\n        }\n        if arr[i] > max_arr[9]\
    \ {\n            max_arr[9] = arr[i];\n            max_k = 10;\n        }\n  \
    \      if arr[i] > max_arr[10] {\n            max_arr[10] = arr[i];\n        \
    \    max_k = 11;\n        }\n        if arr[i] > max_arr[11] {\n            max_arr[11]\
    \ = arr[i];\n            max_k = 12;\n        }\n        if arr[i] > max_arr[12]\
    \ {\n            max_arr[12] = arr[i];\n            max_k = 13;\n        }\n \
    \       if arr[i] > max_arr[13] {\n            max_arr[13] = arr[i];\n       \
    \     max_k = 14;\n        }\n        if arr[i] > max_arr[14] {\n            max_arr[14]\
    \ = arr[i];\n            max_k = 15;\n        }\n        if arr[i] > max_arr[15]\
    \ {\n            max_arr[15] = arr[i];\n            max_k = 16;\n        }\n \
    \       if arr[i] > max_arr[16] {\n            max_arr[16] = arr[i];\n       \
    \     max_k = 17;\n        }\n        if arr[i] > max_arr[17] {\n            max_arr[17]\
    \ = arr[i];\n            max_k = 18;\n        }\n        if arr[i] > max_arr[18]\
    \ {\n            max_arr[18] = arr[i];\n            max_k = 19;\n        }\n \
    \       if arr[i] > max_arr[19] {\n            max_arr[19] = arr[i];\n       \
    \     max_k = 20;\n        }\n        if arr[i] > max_arr[20] {\n            max_arr[20]\
    \ = arr[i];\n            max_k = 21;\n        }\n        if arr[i] > max_arr[21]\
    \ {\n            max_arr[21] = arr[i];\n            max_k = 22;\n        }\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpklm215hy.rs:124:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n109 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n124 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpklm215hy.rs:16:42\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if max_num < arr[i] {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_num < arr[i]\
    \ {\n            max_arr.push(max_num);\n        }\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcbr1h1s0.rs:20:22\n\
    \   |\n20 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcbr1h1s0.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpcbr1h1s0.rs:25:22\n   |\n25 |         if max_num\
    \ < arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n  \
    \  let mut cur_max = arr[0];\n    for &x in arr {\n        if x > cur_max {\n\
    \            cur_max = x;\n        }\n        if max_len == 0 {\n            max_arr.push(cur_max);\n\
    \            break;\n        }\n        if x > max_len {\n            max_len\
    \ = x;\n        }\n    }\n    max_arr.push(cur_max);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl7d08pm3.rs:23:9\n   |\n\
    23 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_k = k;\n        for\
    \ ele in arr {\n            if ele > max_arr[k] {\n                max_arr[k]\
    \ = ele;\n            }\n            if k == max_k {\n                max_arr[k]\
    \ = ele;\n            }\n            k -= 1;\n        }\n        max_arr\n   \
    \ }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp54op9r8q.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp54op9r8q.rs:23:22\n   |\n23 |  \
    \           if ele > max_arr[k] {\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp54op9r8q.rs:24:17\n   |\n24 |         \
    \        max_arr[k] = ele;\n   |                 ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp54op9r8q.rs:27:17\n   |\n27 |                 max_arr[k]\
    \ = ele;\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val\
    \ = arr[0];\n    let mut max_val = arr[0];\n    let mut min_idx = 0;\n    let\
    \ mut max_idx = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n\
    \    for idx in 0..arr.len() {\n        if idx < k {\n            if arr[idx]\
    \ > max_val {\n                max_val = arr[idx];\n                max_idx =\
    \ idx;\n            }\n        } else {\n            if arr[idx] > max_val {\n\
    \                max_val = arr[idx];\n                max_idx = idx;\n       \
    \     }\n        }\n    }\n    for idx in 0..arr.len() {\n        if idx < k {\n\
    \            if arr[idx] < min_val {\n                min_val = arr[idx];\n  \
    \              min_idx = idx;\n            }\n        } else {\n            if\
    \ arr[idx] < min_val {\n                min_val = arr[idx];\n                min_idx\
    \ = idx;\n            }\n        }\n    }\n    if min_idx < k {\n        max_len\
    \ = min_idx;\n    }\n    if max_idx < k {\n        min_len = max_idx;\n    }\n\
    \    for idx in 0..arr.len() {\n        if idx < k {\n            if arr[idx]\
    \ > max_val {\n                max_val = arr[idx];\n                max_idx =\
    \ idx;\n            }\n        } else {\n            if arr[idx] > max_val {\n\
    \                max_val = arr[idx];\n                max_idx = idx;\n       \
    \     }\n        }\n    }\n    for idx in 0..arr.len() {\n        if idx < k {\n\
    \            if arr[idx] < min_val {\n                min_val = arr[idx];\n  \
    \              min_idx = idx;\n            }\n        } else {\n            if\
    \ arr[idx] < min_val {\n                min_val = arr[idx];\n                min_idx\
    \ = idx;\n            }\n        }\n    }\n    if min_idx < k {\n        max_len\
    \ = min_idx;\n    }\n    if max_idx < k {\n        min_len = max_idx;\n    }\n\
    \    for idx in 0..arr.len() {\n        if idx < k {\n            if arr[idx]\
    \ > max_val {\n                max_val = arr[idx];\n                max_idx =\
    \ idx;\n            }\n        } else {\n            if arr[idx] > max_val {\n\
    \                max_val = arr[idx];\n                max_idx = idx;\n       \
    \     }\n        }\n    }\n    for idx in 0..arr.len() {\n        if idx < k {\n\
    \            if arr[idx] < min_val {\n                min_val = arr[idx];\n  \
    \              min_idx = idx;\n            }\n        } else {\n            if\
    \ arr[idx] < min_val {\n                min_val = arr[idx];\n                min_idx\
    \ = idx\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4s5s04bv.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    104 |     for idx in 0..arr.len() {\n    |                             - unclosed\
    \ delimiter\n...\n110 |         } else {\n    |                - unclosed delimiter\n\
    111 |             if arr[idx] < min_val {\n    |                             \
    \      - this delimiter might not be properly closed...\n...\n114 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n129 | }\n    |\
    \   ^\n\nerror[E0425]: cannot find value `min_len` in this scope\n  --> /tmp/tmp4s5s04bv.rs:57:9\n\
    \   |\n57 |         min_len = max_idx;\n   |         ^^^^^^^ help: a local variable\
    \ with a similar name exists: `max_len`\n\nerror[E0425]: cannot find value `min_len`\
    \ in this scope\n  --> /tmp/tmp4s5s04bv.rs:89:9\n   |\n89 |         min_len =\
    \ max_idx;\n   |         ^^^^^^^ help: a local variable with a similar name exists:\
    \ `max_len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4s5s04bv.rs:28:18\n\
    \   |\n28 |         if idx < k {\n   |                  ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n28 |         if idx < k.try_into().unwrap()\
    \ {\n   |                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4s5s04bv.rs:41:18\n   |\n41 |         if idx < k {\n   |      \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n41\
    \ |         if idx < k.try_into().unwrap() {\n   |                   ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4s5s04bv.rs:53:18\n   |\n53 |\
    \     if min_idx < k {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n53 |     if min_idx < k.try_into().unwrap() {\n   |\
    \                   +++++++++++"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = vec![];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i]\
    \ = i;\n    }\n    for i in 0..k {\n        if max_arr[i] > max_arr[max_idx[i]]\
    \ {\n            max_arr[max_idx[i]] = max_arr[i];\n            max_idx[max_idx[i]]\
    \ = i;\n        }\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp1eet9va0.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp1eet9va0.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp1eet9va0.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp1eet9va0.rs:24:12\n\
    \   |\n24 |         if max_arr[i] > max_arr[max_idx[i]] {\n   |            ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp1eet9va0.rs:24:33\n\
    \   |\n24 |         if max_arr[i] > max_arr[max_idx[i]] {\n   |              \
    \                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:19:12\n\
    \   |\n19 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![arr[0]];\n    for i in 1..k {\n     \
    \   if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n  \
    \  }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jws5q2k.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7jws5q2k.rs:22:12\n\
    \   |\n22 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7jws5q2k.rs:23:26\n   |\n23 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6m876kob.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6m876kob.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6m876kob.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp6m876kob.rs:27:23\n   |\n27 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        let\
    \ mut max_val = arr[0];\n        let mut max_idx = 1;\n        for idx in 1..arr.len()\
    \ {\n            if arr[idx] > max_val {\n                max_val = arr[idx];\n\
    \                max_idx = idx;\n            }\n        }\n        max_arr.push(max_val);\n\
    \        max_k -= 1;\n        if max_k == 0 {\n            break;\n        }\n\
    \        arr.swap(0, max_idx);\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvitx53f6.rs:19:9\n\
    \   |\n19 |     let mut max_idx = arr.len();\n   |         ----^^^^^^^\n   | \
    \        |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `arr` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpvitx53f6.rs:34:9\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |            --- help: consider changing\
    \ this to be mutable: `mut arr`\n...\n34 |         arr.swap(0, max_idx);\n   |\
    \         ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 && max_k > 0 {\n\
    \        if arr[max_idx] > arr[max_idx - 1] {\n            max_arr.resize(max_k);\n\
    \            max_k -= 1;\n            max_idx -= 1;\n        } else {\n      \
    \      max_arr.resize(max_k);\n            max_k -= 1;\n        }\n    }\n   \
    \ max_arr.extend(&arr[..max_idx]);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp1ks92f_n.rs:22:21\n     |\n22   |             max_arr.resize(max_k);\n\
    \     |                     ^^^^^^ ----- supplied 1 argument\n     |         \
    \            |\n     |                     expected 2 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 2 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmp1ks92f_n.rs:26:21\n     |\n26 \
    \  |             max_arr.resize(max_k);\n     |                     ^^^^^^ -----\
    \ supplied 1 argument\n     |                     |\n     |                  \
    \   expected 2 arguments\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        arr\n    } else {\n\
    \        let mut max_idx = arr.len() - 1;\n        let mut max_val = arr[k];\n\
    \        let mut max_idx = k;\n        for idx in 0..k {\n            if arr[idx]\
    \ > max_val {\n                max_val = arr[idx];\n                max_idx =\
    \ idx;\n            }\n        }\n        arr.swap(max_idx, k);\n        arr\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixtjt4f9.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpixtjt4f9.rs:21:27\n   |\n21 |  \
    \       let mut max_val = arr[k];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpixtjt4f9.rs:24:16\n   |\n24 |  \
    \           if arr[idx] > max_val {\n   |                ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpixtjt4f9.rs:25:27\n   |\n25 |            \
    \     max_val = arr[idx];\n   |                           ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixtjt4f9.rs:29:18\n\
    \   |\n29 |         arr.swap(max_idx, k);\n   |                  ^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |         arr.sw"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for i in\
    \ 1..k {\n        if arr[i] > max {\n            max = arr[i];\n            max_idx\
    \ = i;\n        }\n    }\n    let mut result = vec![max];\n    for i in 0..max_idx\
    \ - 1 {\n        result.push(arr[i]);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp4210jwh.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpp4210jwh.rs:23:12\n\
    \   |\n23 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpp4210jwh.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpp4210jwh.rs:30:21\n   |\n30 |         result.push(arr[i]);\n\
    \   |                     ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = arr.len() -\
    \ 1;\n    while max_idx >= 0 && max_idx < k {\n        if arr[max_idx] > arr[max_idx\
    \ - 1] {\n            max_arr.resize(max_idx + 1, arr[max_idx]);\n           \
    \ max_idx--;\n        } else {\n            max_arr.resize(max_idx + 1, arr[max_idx\
    \ - 1]);\n        }\n    }\n    max_arr.resize(max_idx + 1, arr[max_idx]);\n \
    \   max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpt8rdeemf.rs:25:22\n\
    \   |\n25 |             max_idx--;\n   |                      ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt8rdeemf.rs:17:30\n   |\n17 |\
    \     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt8rdeemf.rs:22:37\n   |\n22 |\
    \     while max_idx >= 0 && max_idx < k {\n   |                              \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n22 |     while\
    \ max_idx >= 0 && max_idx < k.try_into().unwrap() {\n   |                    \
    \                  ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![vec![0]; k]\n    for i in 0..k {\n        max_arr[i]\
    \ = arr[i].max();\n    }\n    max_arr.iter().cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp4wceqdw4.rs:20:39\n\
    \   |\n20 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                  ^ help: add `;` here\n21 |     for i in 0..k {\n   |     ---\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4wceqdw4.rs:17:21\n\
    \   |\n17 |     if arr.len() <= k {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4wceqdw4.rs:20:37\n   |\n20 |     let mut max_arr = vec![vec![0];\
    \ k]\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()]\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp4wceqdw4.rs:22:9\n\
    \   |\n22 |         max_arr[i] = arr[i].max();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4wceqdw4.rs:22:22\n\
    \   |\n22 |         max_arr[i] = arr[i].max();\n   |                      ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over el"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut cur_max = arr[0];\n    for &x in arr {\n        if x > cur_max\
    \ {\n            cur_max = x;\n        }\n        if cur_max > max_k {\n     \
    \       max_k = cur_max;\n        }\n    }\n    max_arr.push(max_k);\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1ntc8q2.rs:20:9\n   |\n\
    20 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        max_arr.push(arr[i]);\n    }\n    for i in 0..k {\n        let mut\
    \ max_i = i;\n        for j in (i + 1)..k {\n            if arr[j] > max_arr[j]\
    \ {\n                max_i = j;\n            }\n        }\n        max_arr.swap(i,\
    \ max_i);\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7vxqgqf8.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7vxqgqf8.rs:24:16\n   |\n24 |  \
    \           if arr[j] > max_arr[j] {\n   |                ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp7vxqgqf8.rs:24:25\n   |\n24 |             if arr[j]\
    \ > max_arr[j] {\n   |                         ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7vxqgqf8.rs:28:22\n\
    \   |\n28 |         max_arr.swap(i, max_i);\n   |                      ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n28 |         max_arr.swap(i.try_into().unwrap(),\
    \ max_i);\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7vxqgqf8.rs:28:25\n   |\n28 |         max_arr.swap(i, max_i);\n\
    \   |                         ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |       "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n  \
    \  for &i in arr {\n        if i >= max_len {\n            max_len = i;\n    \
    \    }\n    }\n    for i in 0..max_len {\n        let mut max_elem = i;\n    \
    \    for &j in arr {\n            if j == i {\n                continue;\n   \
    \         }\n            if j > max_elem {\n                max_elem = j;\n  \
    \          }\n        }\n        max_arr.push(max_elem);\n    }\n    return max_arr;\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpamhql6mn.rs:22:9\n   |\n\
    22 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpamhql6mn.rs:29:13\n   |\n29 |         for &j in arr {\n   |   \
    \          ^^    --- this expression has type `Option<isize>`\n   |          \
    \   |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `j`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_num = arr[0];\n        let mut max_idx = 1;\n       \
    \ for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_num;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:28:23\n\
    \   |\n28 |         vec![max_num; max_idx + 1]\n   |                       ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                       +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for i in 0..k\
    \ {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n    \
    \        max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_arr[1] {\n            max_arr[1] = arr[i];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[2] {\n            max_arr[2] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[3] {\n   \
    \         max_arr[3] = arr[i];\n        }\n    }\n    for i in 0..k {\n      \
    \  if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_arr[5] {\n            max_arr[5]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[6]\
    \ {\n            max_arr[6] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[7] {\n            max_arr[7] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_arr[8] {\n            max_arr[8]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[9]\
    \ {\n            max_arr[9] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[10] {\n            max_arr[10] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[11] {\n        \
    \    max_arr[11] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[12] {\n            max_arr[12] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[13] {\n            max_arr[13]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[14]\
    \ {\n            max_arr[14] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[15] {\n            max_arr[15] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[16] {\n        \
    \    max_arr[16] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[17] {\n            max_arr[17] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[18] {\n            max_\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpboq7ivkw.rs:131:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    113 |     for i in 0..k {\n    |                   - unclosed delimiter\n114 |\
    \         if arr[i] > max_arr[18] {\n    |                                 - this\
    \ delimiter might not be properly closed...\n115 |             max_\n116 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n131 | }\n\
    \    |   ^\n\nerror[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmpboq7ivkw.rs:115:13\n\
    \    |\n115 |             max_\n    |             ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpboq7ivkw.rs:17:21\n   |\n17 |\
    \     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpboq7ivkw.rs:23:12\n  \
    \ |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpboq7ivkw.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isiz"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr.get(max_i).unwrap() > arr.get(max_i).unwrap() {\n            max_arr.resize(max_i,\
    \ arr.get(max_i).unwrap());\n            max_k -= 1;\n        }\n        max_i\
    \ += 1;\n    }\n    max_arr.extend(&arr[0..max_k]);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp19i36n9a.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmp19i36n9a.rs:21:40\n   |\n21 |         if\
    \ max_arr.get(max_i).unwrap() > arr.get(max_i).unwrap() {\n   |              \
    \                          ^ no implementation for `&isize < isize` and `&isize\
    \ > isize`\n   |\n   = help: the trait `PartialOrd<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialOrd<&isize>` for `&&isize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmp19i36n9a.rs:27:21\n  \
    \ |\n27 |     max_arr.extend(&arr[0..max_k]);\n   |                     ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp19i36n9a.rs:28:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n28 |     max_arr\n   |  \
    \   ^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found st"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![vec![0]; k];\n    for i in\
    \ 0..k {\n        max.iter_mut().enumerate().for_each(|(i, j)| {\n           \
    \ if arr[i] > max[j] {\n                max[j] = arr[i];\n            }\n    \
    \    });\n    }\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp51mpr30n.rs:17:33\n   |\n\
    17 |     let mut max = vec![vec![0]; k];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let mut\
    \ max = vec![vec![0]; k.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `&mut Vec<{integer}>`\n  --> /tmp/tmp51mpr30n.rs:20:25\n   |\n\
    20 |             if arr[i] > max[j] {\n   |                         ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `&mut Vec<{integer}>`\n\
    \   = note: required because of the requirements on the impl of `Index<&mut Vec<{integer}>>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `&mut Vec<{integer}>`\n  --> /tmp/tmp51mpr30n.rs:21:17\n   |\n\
    21 |                 max[j] = arr[i];\n   |                 ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `&mut Vec<{integer}>`\n   = note: required because of\
    \ the requirements on the impl of `Index<&mut Vec<{integer}>>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp51mpr30n.rs:25:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n25 |     max\n   |     ^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_idx = arr.len() - 1;\n        let mut max_val = arr[k];\n\
    \        let mut max_idxs = vec![];\n        for i in 0..k {\n            if arr[i]\
    \ > max_val {\n                max_val = arr[i];\n                max_idx = i;\n\
    \            }\n        }\n        for i in 0..k {\n            if arr[i] == max_val\
    \ {\n                max_idxs.push(i);\n            }\n        }\n        max_idxs.reverse();\n\
    \        vec![max_val] + max_idxs\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn4of5ui0.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpn4of5ui0.rs:21:27\n   |\n21 |  \
    \       let mut max_val = arr[k];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpn4of5ui0.rs:24:16\n   |\n24 |  \
    \           if arr[i] > max_val {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn4of5ui0.rs:25:27\n   |\n25 |            \
    \     max_val = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn4of5ui0.rs:26:27\n\
    \   |\n20 |         let mut max_idx = arr.len() - 1;\n   |                   \
    \        ------------- expected due to this value\n...\n26 |                 max_idx\
    \ = i;\n   |                           ^ expected `usize`, found `isize`\n\nerr"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![vec![0]; k];\n    for i in\
    \ 0..k {\n        for j in 0..arr.len() {\n            if arr[j] > max[j] {\n\
    \                max[j] = arr[j];\n            }\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_l3d7q1.rs:17:33\n   |\n\
    17 |     let mut max = vec![vec![0]; k];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let mut\
    \ max = vec![vec![0]; k.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_l3d7q1.rs:20:25\n\
    \   |\n20 |             if arr[j] > max[j] {\n   |                         ^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_l3d7q1.rs:21:26\n   |\n21 |                 max[j] = arr[j];\n\
    \   |                 ------   ^^^^^^ expected struct `Vec`, found `isize`\n \
    \  |                 |\n   |                 expected due to the type of this\
    \ binding\n   |\n   = note: expected struct `Vec<{integer}>`\n               \
    \ found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_l3d7q1.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max\n   |     ^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_num = arr[0];\n    let mut max_idx = 1;\n  \
    \  for i in 1..arr.len() {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut result =\
    \ vec![];\n    for i in 0..k {\n        result.push(max_num);\n    }\n    for\
    \ i in 0..max_idx+1 {\n        result.push(arr[i]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5, -3, -4, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpr1szc1cp.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[k]\
    \ {\n            max_arr[k] = arr[i];\n            max_k--;\n        }\n     \
    \   i += 1;\n    }\n    max_arr.truncate(max_k);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpe3yq2gqw.rs:23:20\n\
    \   |\n23 |             max_k--;\n   |                    ^ expected expression\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpe3yq2gqw.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpe3yq2gqw.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe3yq2gqw.rs:27:22\n   |\n27 |     max_arr.truncate(max_k);\n  \
    \ |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |     max_arr.truncate(max_k.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = vec![];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i]\
    \ = i;\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[j]\
    \ > max_arr[i] {\n                max_arr[j] = max_arr[i];\n                max_idx[j]\
    \ = max_idx[i];\n            }\n        }\n    }\n    for i in 0..k {\n      \
    \  arr[i] = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpvray6ega.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpvray6ega.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpvray6ega.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpvray6ega.rs:25:16\n\
    \   |\n25 |             if max_arr[j] > max_arr[i] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpvray6ega.rs:25:29\n\
    \   |\n25 |             if max_arr[j] > max_arr[i] {\n   |                   \
    \          ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = h"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        let\
    \ mut max_value = arr[0];\n        for value in arr.iter().skip(1) {\n       \
    \     if value > max_value {\n                max_value = value;\n           \
    \ }\n        }\n        max_arr.push(max_value);\n        max_i -= 1;\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8mme_u5p.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8mme_u5p.rs:23:24\n   |\n23 |             if value > max_value\
    \ {\n   |                        ^^^^^^^^^\n   |                        |\n  \
    \ |                        expected `&isize`, found `isize`\n   |            \
    \            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8mme_u5p.rs:24:29\n   |\n21 |         let mut max_value\
    \ = arr[0];\n   |                             ------ expected due to this value\n\
    ...\n24 |                 max_value = value;\n   |                           \
    \  ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |                 max_value = *value;\n   |           \
    \                  +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_k = k;\n    let mut\
    \ max_i = arr.len() - 1;\n    while max_i < max_k {\n        if arr[max_i] > arr[max_i\
    \ + 1] {\n            max_arr.push(arr[max_i]);\n            max_i += 1;\n   \
    \     } else {\n            max_arr.push(arr[max_i + 1]);\n            max_k -=\
    \ 1;\n        }\n    }\n    max_arr.push(arr[max_k]);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqnz66000.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqnz66000.rs:23:19\n   |\n23 |\
    \     while max_i < max_k {\n   |                   ^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqnz66000.rs:32:18\n  \
    \ |\n32 |     max_arr.push(arr[max_k]);\n   |                  ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = 0;\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[k] {\n            max_arr[k] = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    max_arr.push(arr[max_idx]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9tp274nj.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9tp274nj.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[k] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp9tp274nj.rs:23:21\n   |\n23 |         if arr[i] >\
    \ max_arr[k] {\n   |                     ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp9tp274nj.rs:24:13\n   |\n24 |             max_arr[k]\
    \ = arr[i];\n   |             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp9tp274nj.rs:24:26\n   |\n24 |             max_arr[k] = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemen"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max = arr[0];\n        let mut max_idx = 1;\n        for\
    \ i in 1..k {\n            if arr[i] > max {\n                max = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        vec![arr[max_idx]]\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7c0vqp58.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7c0vqp58.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max {\n   |                ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7c0vqp58.rs:24:23\n   |\n24 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7c0vqp58.rs:28:14\n   |\n28 |         vec![arr[max_idx]]\n\
    \   |              ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = vec![];\n\
    \    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i] = i;\n\
    \    }\n    for i in 1..arr.len() {\n        if arr[i] > max_arr[k-1] {\n    \
    \        max_arr[k-1] = arr[i];\n            max_idx[k-1] = i;\n        }\n  \
    \  }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    for i in 0..k\
    \ {\n        arr[i] = max_idx[i];\n    }\n    return arr;\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp10bljtw1.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp10bljtw1.rs:23:9\n\
    \   |\n23 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp10bljtw1.rs:23:22\n   |\n23 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp10bljtw1.rs:24:9\n   |\n24 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp10bljtw1.rs:27:21\n\
    \   |\n27 |         if arr[i] > max_arr[k-1] {\n   |                     ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the tra"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        if\
    \ max_idx < max_k {\n            max_k -= 1;\n        }\n        if max_k == 0\
    \ {\n            break;\n        }\n        if arr[0] > max_arr[0] {\n       \
    \     max_arr = arr;\n            max_k = 1;\n            max_idx = 0;\n     \
    \   } else {\n            max_arr[0] = max_arr[0];\n            max_idx -= 1;\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewqy1wei.rs:21:22\n   |\n\
    21 |         if max_idx < max_k {\n   |                      ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if max_idx < max_k.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_k = k;\n        let\
    \ mut max_idx = arr.len() - 1;\n        let mut max_val = arr[0];\n        let\
    \ mut i = 0;\n        while i < max_k {\n            if arr[i] > max_val {\n \
    \               max_val = arr[i];\n                max_idx = i;\n            }\n\
    \            i += 1;\n        }\n        max_arr.push(max_val);\n        max_arr.push(arr[max_idx]);\n\
    \        max_arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68vrd98e.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp68vrd98e.rs:26:16\n   |\n26 |  \
    \           if arr[i] > max_val {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp68vrd98e.rs:27:27\n   |\n27 |            \
    \     max_val = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp68vrd98e.rs:28:27\n\
    \   |\n22 |         let mut max_idx = arr.len() - 1;\n   |                   \
    \        ------------- expected due to this value\n...\n28 |                 max_idx\
    \ = i;\n   |                           ^ expected `usize`, found `isize`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = arr.len();\n\
    \        for i in 0..k {\n            if max_idx < arr.len() {\n             \
    \   max_arr = max_arr.push(arr.pop());\n                max_idx -= 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        max_arr\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnzu1_p1m.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnzu1_p1m.rs:24:27\n   |\n20 |         let mut max_arr =\
    \ vec![];\n   |                           ------ expected due to this value\n\
    ...\n24 |                 max_arr = max_arr.push(arr.pop());\n   |           \
    \                ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n \
    \  |\n   = note: expected struct `Vec<Option<isize>>`\n           found unit type\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnzu1_p1m.rs:30:9\n   |\n\
    16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n30 |         max_arr\n   |         ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        let\
    \ mut max_element = arr[0];\n        let mut max_idx = 0;\n        for i in 0..max_k\
    \ {\n            if arr[i] > max_element {\n                max_element = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        max_arr.push(max_element);\n\
    \        max_k -= 1;\n        arr.swap(0, max_idx);\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjin6x9ci.rs:24:16\n\
    \   |\n24 |             if arr[i] > max_element {\n   |                ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjin6x9ci.rs:25:31\n\
    \   |\n25 |                 max_element = arr[i];\n   |                      \
    \         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjin6x9ci.rs:31:21\n   |\n31 |\
    \         arr.swap(0, max_idx);\n   |                     ^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |         arr.swap(0, max_idx.try_into().unwrap());\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[k] {\n            max_arr[k] = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    max_arr.push(arr[max_idx]);\n\
    \    max_arr.sort_unstable();\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe2jx4h3i.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpe2jx4h3i.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[k] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpe2jx4h3i.rs:23:21\n   |\n23 |         if arr[i] >\
    \ max_arr[k] {\n   |                     ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpe2jx4h3i.rs:24:13\n   |\n24 |             max_arr[k]\
    \ = arr[i];\n   |             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpe2jx4h3i.rs:24:26\n   |\n24 |             max_arr[k] = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemen"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut max_idx = vec![];\n    for i in 0..arr.len() {\n        if\
    \ max_len == 0 {\n            break;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_idx[0] = i;\n         \
    \   max_len -= 1;\n        } else {\n            max_arr[0] = max_arr[0];\n  \
    \          max_idx[0] = max_idx[0];\n            max_len -= 1;\n        }\n  \
    \  }\n    for i in 0..k {\n        if max_len == 0 {\n            break;\n   \
    \     }\n        if max_idx[i] < k {\n            max_arr[i] = max_arr[0];\n \
    \           max_idx[i] = 0;\n            max_len -= 1;\n        } else {\n   \
    \         max_arr[i] = max_arr[i];\n            max_idx[i] = max_idx[i];\n   \
    \         max_len -= 1;\n        }\n    }\n    for i in 0..k {\n        if max_len\
    \ == 0 {\n            break;\n        }\n        if max_idx[i] < k {\n       \
    \     max_arr[i] = max_arr[i];\n            max_idx[i] = 0;\n            max_len\
    \ -= 1;\n        } else {\n            max_arr[i] = max_arr[i];\n            max_idx[i]\
    \ = max_idx[i];\n            max_len -= 1;\n        }\n    }\n    for i in 0..k\
    \ {\n        if max_len == 0 {\n            break;\n        }\n        if max_idx[i]\
    \ < k {\n            max_arr[i] = max_arr[i];\n            max_idx[i] = 0;\n \
    \           max_len -= 1;\n        } else {\n            max_arr[i] = max_arr[i];\n\
    \            max_idx[i] = max_idx[i];\n            max_len -= 1;\n        }\n\
    \    }\n    for i in 0..k {\n        if max_len == 0 {\n            break;\n \
    \       }\n        if max_idx[i] < k {\n            max_arr[i] = max_arr[i];\n\
    \            max_idx[i] = 0;\n            max_len -= 1;\n        } else {\n  \
    \          max_arr[i] = max_arr[i];\n            max_idx[i] = max_idx[i];\n  \
    \          max_len -= 1;\n        }\n    }\n    for i in 0..k {\n        if max_len\
    \ == 0 {\n            break;\n        }\n        if max_idx[i] < k {\n       \
    \     max_arr[i] = max_arr[i];\n            max_idx[i] = 0;\n            max_len\
    \ -= 1;\n        } else {\n            max_arr[i] = max_arr[i];\n            max_idx[i]\
    \ = max_idx[i];\n            max_len -= 1;\n        }\n    }\n    for i in 0..k\
    \ {\n        if max_len == 0 {\n            break;\n        }\n        if max_idx[i]\
    \ < k {\n            max_arr[i] = max_arr[i];\n            max_idx[i] = 0;\n \
    \           max_len -= 1;\n        } else {\n            max_arr[i] = max_arr[i];\n\
    \            max_idx[i] = max_idx[i];\n            max_len -= 1;\n        }\n\
    \    }\n    for i in 0..k {\n        if max_len == 0 {\n            break;\n \
    \       }\n        if max_idx[i] < k {\n            max_arr[i] = max_arr[i];\n\
    \            max_\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxnmp3wvf.rs:140:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    118 |     for i in 0..k {\n    |                   - unclosed delimiter\n...\n\
    122 |         if max_idx[i] < k {\n    |                           - this delimiter\
    \ might not be properly closed...\n...\n125 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n140 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `max_` in this scope\n   --> /tmp/tmpxnmp3wvf.rs:124:13\n    |\n\
    124 |             max_\n    |             ^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `[usize]` cannot be indexed by `isize`\n  --> /tmp/tmpxnmp3wvf.rs:38:12\n\
    \   |\n38 |         if max_idx[i] < k {\n   |            ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<usize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpxnmp3wvf.rs:39:13\n   |\n39 |            \
    \ max_arr[i] = max_arr[0];\n   |             ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[usize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpxnmp3wvf.rs:40:13\n   |\n40 |            \
    \ max_idx[i] = 0;\n   |             ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[k]\
    \ {\n            max_arr[k] = arr[i];\n            max_k--;\n        }\n     \
    \   i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp1snam7mk.rs:23:20\n\
    \   |\n23 |             max_k--;\n   |                    ^ expected expression\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp1snam7mk.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp1snam7mk.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n  \
    \  let mut max_idx = arr.len() - 1;\n    while max_len > 0 && max_idx >= 0 {\n\
    \        if arr[max_idx] > arr[max_idx+k] {\n            max_arr[max_len] = arr[max_idx];\n\
    \            max_len--;\n        }\n        max_idx--;\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp77shf12e.rs:26:22\n\
    \   |\n26 |             max_len--;\n   |                      ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmp77shf12e.rs:28:18\n   |\n\
    28 |         max_idx--;\n   |                  ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77shf12e.rs:24:39\n   |\n24 |         if arr[max_idx]\
    \ > arr[max_idx+k] {\n   |                                       ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp77shf12e.rs:24:38\n\
    \   |\n24 |         if arr[max_idx] > arr[max_idx+k] {\n   |                 \
    \                     ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp77shf12e.rs:25:13\n   |\n\
    25 |             max_arr[max_len] = arr[max_idx];\n   |             ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for i\
    \ in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n  \
    \      }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n        \
    \    max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjfcz2ci.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgjfcz2ci.rs:23:12\n  \
    \ |\n23 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgjfcz2ci.rs:24:23\n   |\n24 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgjfcz2ci.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpgjfcz2ci.rs:30:23\n   |\n30 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for\
    \ i in 1..arr.len() {\n        if arr[i] > max {\n            max = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    let mut result = vec![];\n  \
    \  for i in 0..k {\n        result.push(arr[max_idx - i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzb42ed3x.rs:30:35\n   |\n\
    30 |         result.push(arr[max_idx - i]);\n   |                            \
    \       ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpzb42ed3x.rs:30:33\n   |\n30 |         result.push(arr[max_idx\
    \ - i]);\n   |                                 ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[k] {\n            max_arr[k] = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    max_arr.extend_from_slice(&arr[max_idx..]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1k2f8jvh.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1k2f8jvh.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[k] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp1k2f8jvh.rs:23:21\n   |\n23 |         if arr[i] >\
    \ max_arr[k] {\n   |                     ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp1k2f8jvh.rs:24:13\n   |\n24 |             max_arr[k]\
    \ = arr[i];\n   |             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1k2f8jvh.rs:24:26\n   |\n24 |             max_arr[k] = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemen"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_len = k;\n        }\n \
    \       if max_len == k {\n            max_arr.push(arr[i]);\n        }\n    \
    \    if max_len > k {\n            max_len = k;\n        }\n        i += 1;\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpzcmn6hgs.rs:21:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = arr.len() -\
    \ 1;\n        let mut max_val = arr[0];\n        for i in 0..k {\n           \
    \ if max_val > arr[i] {\n                max_val = arr[i];\n                max_idx\
    \ = i;\n            }\n        }\n        for i in 0..k {\n            max_arr.push(arr[max_idx]);\n\
    \            max_idx -= 1;\n        }\n        max_arr\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1osnwvn6.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp1osnwvn6.rs:24:26\n   |\n24 |  \
    \           if max_val > arr[i] {\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp1osnwvn6.rs:25:27\n   |\n25 |  \
    \               max_val = arr[i];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1osnwvn6.rs:26:27\n   |\n21 |         let mut max_idx = arr.len()\
    \ - 1;\n   |                           ------------- expected due to this value\n\
    ...\n26 |                 max_idx = i;\n   |                           ^ expected\
    \ `usize`, found `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        let\
    \ mut max_value = arr[0];\n        for i in 1..arr.len() {\n            if arr[i]\
    \ > max_value {\n                max_value = arr[i];\n            }\n        }\n\
    \        max_arr.push(max_value);\n        max_i -= 1;\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgr7r8y7.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    vec![max; k - max_idx]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:19\n   |\n\
    25 |     vec![max; k - max_idx]\n   |                   ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:15\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |               ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |     vec![max; (k -\
    \ max_idx).try_into().unwrap()]\n   |               +           +++++++++++++++++++++\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpz6v_s1uj.rs:25:17\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |                 ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        let mut max_value = arr[0];\n        for j in 0..arr.len() {\n  \
    \          if arr[j] > max_value {\n                max_value = arr[j];\n    \
    \        }\n        }\n        max_arr.push(max_value);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmp6u7ts7wf.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if max_num > arr[i] {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_num > arr[i]\
    \ {\n            max_arr.push(max_num);\n        }\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpumvc9_1v.rs:20:22\n\
    \   |\n20 |         if max_num > arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpumvc9_1v.rs:21:23\n   |\n21 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpumvc9_1v.rs:25:22\n   |\n25 |         if max_num\
    \ > arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max = arr[0];\n        let mut max_idx = 1;\n        for\
    \ i in 1..k {\n            if arr[i] > max {\n                max = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        vec![max; max_idx\
    \ + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx81uiiqk.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpx81uiiqk.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max {\n   |                ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpx81uiiqk.rs:24:23\n   |\n24 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx81uiiqk.rs:28:19\n\
    \   |\n28 |         vec![max; max_idx + 1]\n   |                   ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                   +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_idx = arr.len() - 1;\n        let mut max_val = arr[k];\n\
    \        let mut max_so_far = vec![];\n        for idx in 0..k {\n           \
    \ if arr[idx] > max_val {\n                max_val = arr[idx];\n             \
    \   max_idx = idx;\n            }\n        }\n        max_so_far.push(max_val);\n\
    \        max_so_far.extend(arr[max_idx..]);\n        max_so_far\n    }\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp29cqtx42.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp29cqtx42.rs:21:27\n   |\n21 |  \
    \       let mut max_val = arr[k];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp29cqtx42.rs:24:16\n   |\n24 |  \
    \           if arr[idx] > max_val {\n   |                ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp29cqtx42.rs:25:27\n   |\n25 |            \
    \     max_val = arr[idx];\n   |                           ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp29cqtx42.rs:26:27\n\
    \   |\n20 |         let mut max_idx = arr.len() - 1;\n   |                   \
    \        ------------- expected due to this value\n...\n26 |                 max_idx\
    \ = idx;\n   |                           ^^^ expected `usize`, found "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[k]\
    \ {\n            max_arr[k] = arr[i];\n            i += 1;\n        }\n      \
    \  else {\n            i += 1;\n        }\n        if i == arr.len() {\n     \
    \       break;\n        }\n    }\n    max_arr.extend_from_slice(&vec![max_k]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp7xmn3_vq.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp7xmn3_vq.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_val = arr[0];\n    for &i in arr {\n        if i > max_val\
    \ {\n            max_val = i;\n        }\n        if max_k == 0 {\n          \
    \  max_arr.push(max_val);\n            break;\n        }\n        if max_k ==\
    \ 1 {\n            max_arr.push(max_val);\n            break;\n        }\n   \
    \     if max_k == 2 {\n            max_arr.push(max_val);\n            break;\n\
    \        }\n        if max_k == 3 {\n            max_arr.push(max_val);\n    \
    \        break;\n        }\n        if max_k == 4 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 5 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 6 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 7 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 8 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 9 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 10 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 11 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 12 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 13 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 14 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 15 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 16 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 17 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 18 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 19 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 20 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 21 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 22 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 23 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 24 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 25 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 26 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 27 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if max_k == 28 {\n            max_\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmplmiffesw.rs:153:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     for &i in arr {\n    |                   - unclosed delimiter\n...\n\
    136 |         if max_k == 28 {\n    |                        - this delimiter\
    \ might not be properly closed...\n137 |             max_\n138 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n153 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmplmiffesw.rs:137:13\n\
    \    |\n137 |             max_\n    |             ^^^^ help: a local variable\
    \ with a similar name exists: `max_k`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplmiffesw.rs:20:9\n   |\n20 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmplmiffesw.rs:20:5\n\
    \    |\n16  |   fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    | \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20  | /     for &i in arr {\n21  | |         if i > max_val\
    \ {\n22  | |             max_val = i;\n23  | |         }\n...   |\n152 | |   \
    \  assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    153 | | }\n    | |__^ expected struct `Vec`, found `()`\n    |\n    = note: expected\
    \ struct `Vec<isize>`\n            found unit type `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_idx = arr.len() - 1;\n    let mut max_value = arr[k];\n\
    \    for i in 0..k {\n        if arr[i] > max_value {\n            max_value =\
    \ arr[i];\n            max_idx = i;\n        }\n    }\n    let mut result = vec![max_value];\n\
    \    for i in 0..k {\n        result[i] = arr[i];\n    }\n    result[max_idx]\
    \ = max_value;\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7xrti0lh.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7xrti0lh.rs:21:25\n\
    \   |\n21 |     let mut max_value = arr[k];\n   |                         ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7xrti0lh.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7xrti0lh.rs:24:25\n   |\n24 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7xrti0lh.rs:25:23\n\
    \   |\n20 |     let mut max_idx = arr.len() - 1;\n   |                       -------------\
    \ expected due to this value\n...\n25 |             max_idx = i;\n   |       \
    \                ^ expected `usize`, foun"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        max_arr.push(arr[i]);\n    }\n    for i in 0..k {\n        let mut\
    \ max_num = max_arr[i];\n        for j in (i + 1)..arr.len() {\n            if\
    \ arr[j] > max_num {\n                max_num = arr[j];\n            }\n     \
    \   }\n        max_arr.push(max_num);\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7hqqd31c.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7hqqd31c.rs:22:27\n   |\n22 |  \
    \       let mut max_num = max_arr[i];\n   |                           ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7hqqd31c.rs:23:27\n   |\n23 |         for j\
    \ in (i + 1)..arr.len() {\n   |                           ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp7hqqd31c.rs:24:16\n   |\n24 |             if arr[j] > max_num {\n\
    \   |                ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7hqqd31c.rs:25:27\n\
    \   |\n25 |                 max_num = arr[j];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        let\
    \ mut max_val = arr[0];\n        let mut max_pos = 0;\n        for (i, val) in\
    \ arr.iter().enumerate() {\n            if val > max_val {\n                max_val\
    \ = val;\n                max_pos = i;\n            }\n        }\n        max_arr.push(max_val);\n\
    \        max_i -= 1;\n        if max_k > max_i {\n            max_k -= 1;\n  \
    \      }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6nwalwvi.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6nwalwvi.rs:24:22\n   |\n24 |             if val > max_val\
    \ {\n   |                      ^^^^^^^\n   |                      |\n   |    \
    \                  expected `&isize`, found `isize`\n   |                    \
    \  help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6nwalwvi.rs:25:27\n   |\n21 |         let mut max_val = arr[0];\n\
    \   |                           ------ expected due to this value\n...\n25 | \
    \                max_val = val;\n   |                           ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |  \
    \               max_val = *val;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6nwalwvi.rs:31:20\n   |\n31 |         if max_k\
    \ > max_i {\n   |                    ^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |         if max_k > max_i.try_into().unwrap() {\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = 0;\n    let mut min_idx = arr.len();\n    while\
    \ min_idx > 0 && max_k > 0 {\n        if arr[min_idx] > arr[max_idx] {\n     \
    \       max_arr.push(arr[min_idx]);\n            min_idx -= 1;\n        } else\
    \ {\n            max_arr.push(arr[max_idx]);\n            max_k -= 1;\n      \
    \  }\n    }\n    while min_idx > 0 {\n        max_arr.push(arr[min_idx]);\n  \
    \      min_idx -= 1;\n    }\n    while max_k > 0 {\n        max_arr.push(arr[max_idx]);\n\
    \        max_k -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp6899ihge.rs:22:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = vec![];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i]\
    \ = i;\n    }\n    for i in 1..arr.len() {\n        let mut max_i = max_idx[i];\n\
    \        let mut max_j = i;\n        for j in i..arr.len() {\n            if arr[j]\
    \ > max_arr[j] {\n                max_i = j;\n                max_j = i;\n   \
    \         }\n        }\n        max_arr[i] = arr[max_i];\n        max_idx[i] =\
    \ max_j;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpaape9ig_.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpaape9ig_.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpaape9ig_.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = arr.len() -\
    \ 1;\n    for i in 0..k {\n        if arr[i] > arr[max_idx] {\n            max_arr.push(arr[i]);\n\
    \            max_idx -= 1;\n        }\n    }\n    max_arr.push(arr[max_idx]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8p3h7o2.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_8p3h7o2.rs:23:12\n\
    \   |\n23 |         if arr[i] > arr[max_idx] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_8p3h7o2.rs:24:26\n   |\n24 |            \
    \ max_arr.push(arr[i]);\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut cur_len = 0;\n    let mut cur_max = arr[0];\n    for &x in\
    \ arr.iter() {\n        if cur_len == max_len {\n            max_arr.push(cur_max);\n\
    \            cur_len = 0;\n        }\n        if x > cur_max {\n            cur_max\
    \ = x;\n            cur_len += 1;\n        }\n    }\n    max_arr.push(cur_max);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5]`,\n right: `[-4, -3, 5]`', /tmp/tmpcbihebhe.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr;\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for i\
    \ in 1..k {\n        if arr[i] > max {\n            max = arr[i];\n          \
    \  max_idx = i;\n        }\n    }\n    vec![max; max_idx + 1]\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4nhbhqmc.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4nhbhqmc.rs:23:12\n\
    \   |\n23 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4nhbhqmc.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4nhbhqmc.rs:28:15\n\
    \   |\n28 |     vec![max; max_idx + 1]\n   |               ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n28 |     vec![max; (max_idx\
    \ + 1).try_into().unwrap()]\n   |               +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for\
    \ i in 1..arr.len() {\n        if arr[i] > max {\n            max = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    let mut result = vec![];\n  \
    \  for i in 0..k {\n        result.push(max);\n    }\n    for i in 0..max_idx\
    \ - k {\n        result.push(arr[i]);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpomr15or1.rs:32:27\n   |\n\
    32 |     for i in 0..max_idx - k {\n   |                           ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpomr15or1.rs:32:25\n   |\n32 |     for i in 0..max_idx - k {\n \
    \  |                         ^ no implementation for `usize - isize`\n   |\n \
    \  = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = vec![];\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_idx[0] = i;\n        }\n    }\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n    \
    \        max_idx[0] = i;\n        }\n        if arr[i] > max_arr[1] {\n      \
    \      max_arr[1] = arr[i];\n            max_idx[1] = i;\n        }\n    }\n \
    \   for i in 2..arr.len() {\n        if arr[i] > max_arr[1] {\n            max_arr[1]\
    \ = arr[i];\n            max_idx[1] = i;\n        }\n        if arr[i] > max_arr[2]\
    \ {\n            max_arr[2] = arr[i];\n            max_idx[2] = i;\n        }\n\
    \    }\n    for i in 3..arr.len() {\n        if arr[i] > max_arr[2] {\n      \
    \      max_arr[2] = arr[i];\n            max_idx[2] = i;\n        }\n    }\n \
    \   for i in max_idx..k {\n        max_arr[i] = arr[i];\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5chsxckl.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5chsxckl.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5chsxckl.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5chsxckl.rs:31:26\n\
    \   |\n31 |             max_idx[0] = i;\n   |             ----------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5chsxckl.rs:35:26\n\
    \   |\n35 |             max_idx[1] = i;\n   |             ----------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5chsxckl.rs:41:26\n\
    \   |\n41 |             max_idx[1] = i;\n   |             ----------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = -1;\n      \
    \  for idx in 0..k {\n            if idx > 0 && arr[idx] > arr[max_idx] {\n  \
    \              max_idx = idx;\n            }\n        }\n        max_arr.push(arr[max_idx]);\n\
    \        max_arr.extend(maximum(&arr[k..], k - 1).iter().cloned());\n        max_arr\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo5cghmni.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpo5cghmni.rs:23:27\n   |\n23 |  \
    \           if idx > 0 && arr[idx] > arr[max_idx] {\n   |                    \
    \       ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpo5cghmni.rs:21:27\n\
    \   |\n21 |         let mut max_idx = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo5cghmni.rs:24:27\n   |\n21 |         let mut max_idx =\
    \ -1;\n   |                           -- expected due to this value\n...\n24 |\
    \                 max_idx = idx;\n   |                           ^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `RangeFrom<isize>`\n  --> /tmp/tmpo5cghmni.rs:28:33\n   |\n28 |         max_arr.extend(maximum(&arr[k..],\
    \ k - 1).iter().cloned());\n   |                                 ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeFrom<usize>\
    \ as SliceInd"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut cur_max = arr[0];\n    let mut cur_max_idx = 1;\n    for &i\
    \ in arr {\n        if i > cur_max {\n            cur_max = i;\n            cur_max_idx\
    \ = 1;\n        }\n        if i == cur_max {\n            cur_max_idx += 1;\n\
    \        }\n        if cur_max_idx > max_k {\n            max_arr.push(cur_max);\n\
    \            max_k = cur_max_idx;\n        }\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45f97pfi.rs:21:9\n   |\n\
    21 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut result =\
    \ vec![max];\n    for i in 1..k {\n        result.push(arr[max_idx - i]);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp386263ad.rs:27:35\n   |\n\
    27 |         result.push(arr[max_idx - i]);\n   |                            \
    \       ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmp386263ad.rs:27:33\n   |\n27 |         result.push(arr[max_idx\
    \ - i]);\n   |                                 ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_val = arr[0];\n \
    \   for i in 1..k {\n        if arr[i] > max_val {\n            max_val = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_val {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpteetpttc.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpteetpttc.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpteetpttc.rs:24:23\n   |\n24 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpteetpttc.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpteetpttc.rs:29:26\n   |\n29 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 && max_k > 0 {\n\
    \        if arr[0] > arr[1] {\n            max_arr.push(arr[0]);\n           \
    \ max_k -= 1;\n        } else {\n            max_arr.push(arr[1]);\n         \
    \   max_k -= 1;\n        }\n        max_idx -= 1;\n    }\n    max_arr.push(arr[0]);\n\
    \    max_arr.push(arr[0]);\n    max_arr\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-3, -3, -3, -3, -3]`,\n right: `[-4, -3, 5]`', /tmp/tmpwlt00awl.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max = arr[0];\n        let mut max_idx = 1;\n        for\
    \ i in 1..arr.len() {\n            if arr[i] > max {\n                max = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        vec![max; max_idx\
    \ + k - 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnl7p0syz.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnl7p0syz.rs:28:29\n   |\n28 |         vec![max; max_idx\
    \ + k - 1]\n   |                             ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpnl7p0syz.rs:28:27\n\
    \   |\n28 |         vec![max; max_idx + k - 1]\n   |                         \
    \  ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = 0;\n    let mut max_j = arr.len();\n    while max_i\
    \ < max_j {\n        if max_k == 0 {\n            break;\n        }\n        if\
    \ arr.get(max_i) > arr.get(max_j) {\n            max_k -= 1;\n        }\n    \
    \    if max_k == 0 {\n            break;\n        }\n        if arr.get(max_i)\
    \ < arr.get(max_j) {\n            max_i += 1;\n        }\n        if max_k ==\
    \ 0 {\n            break;\n        }\n        if arr.get(max_i) == arr.get(max_j)\
    \ {\n            max_i += 1;\n            max_j -= 1;\n        }\n        if max_k\
    \ == 0 {\n            break;\n        }\n        if arr.get(max_i) > arr.get(max_j)\
    \ {\n            max_k -= 1;\n        }\n    }\n    max_arr.extend(&arr[max_i..max_j]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-3, -4, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpz1qm_b3v.rs:54:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_num = arr[0];\n        let mut max_idx = 1;\n       \
    \ for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_num;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:28:23\n\
    \   |\n28 |         vec![max_num; max_idx + 1]\n   |                       ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                       +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = arr[i];\n    }\n    for i in 0..k {\n        for j in i+1..k {\n         \
    \   if max_arr[i] > max_arr[j] {\n                max_arr[i] = max_arr[j];\n \
    \           }\n        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo3u0k7f.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxo3u0k7f.rs:20:37\n   |\n20 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpxo3u0k7f.rs:22:9\n\
    \   |\n22 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxo3u0k7f.rs:22:22\n   |\n22 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxo3u0k7f.rs:26:16\n   |\n26 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = he"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > max {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:19:12\n\
    \   |\n19 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpeo2k8b_u.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val\
    \ = arr[0];\n    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let\
    \ mut min_idx = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n\
    \    let mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 0;\n    let mu\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9yii01v1.rs:85:11\n   |\n\
    85 |     let mu\n   |           ^ help: add `;` here\n86 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9yii01v1.rs:16:42\n \
    \  |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        let\
    \ mut max_val = arr[0];\n        let mut max_idx = 1;\n        for i in 1..arr.len()\
    \ {\n            if arr[i] > max_val {\n                max_val = arr[i];\n  \
    \              max_idx = i;\n            }\n        }\n        max_arr.push(max_val);\n\
    \        max_k -= 1;\n        if max_k == 0 {\n            break;\n        }\n\
    \        arr.remove(&max_idx);\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6utfjpu1.rs:34:20\n   |\n\
    34 |         arr.remove(&max_idx);\n   |                    ^^^^^^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n34\
    \ -         arr.remove(&max_idx);\n34 +         arr.remove(max_idx);\n   | \n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = arr.len()\
    \ - 1;\n    for i in 0..k {\n        if arr[i] > arr[i * 2] {\n            max_arr[i]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] > arr[i * 2] {\n            max_arr[i] = arr[i];\n    \
    \        max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if max_arr[i]\
    \ > arr[i * 2] {\n            max_arr[i] = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] > arr[i * 2] {\n\
    \            max_arr[i] = arr[i];\n            max_idx = i;\n        }\n    }\n\
    \    for i in 0..k {\n        if max_arr[i] > arr[i * 2] {\n            max_arr[i]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] > arr[i * 2] {\n            max_arr[i] = arr[i];\n    \
    \        max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if max_arr[i]\
    \ > arr[i * 2] {\n            max_arr[i] = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] > arr[i * 2] {\n\
    \            max_arr[i] = arr[i];\n            max_idx = i;\n        }\n    }\n\
    \    for i in 0..k {\n        if max_arr[i] > arr[i * 2] {\n            max_arr[i]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] > arr[i * 2] {\n            max_arr[i] = arr[i];\n    \
    \        max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if max_arr[i]\
    \ > arr[i * 2] {\n            max_arr[i] = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] > arr[i * 2] {\n\
    \            max_arr[i] = arr[i];\n            max_idx = i;\n        }\n    }\n\
    \    for i in 0..k {\n        if max_arr[i] > arr[i * 2] {\n            max_arr[i]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i] > arr[i * 2] {\n            max_arr[i] = arr[i];\n    \
    \        max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if max_arr[i]\
    \ > arr[i * 2] {\n            max_arr[i] = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i] > arr[i\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpabfg6lvq.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n113 |         if max_arr[i] > arr[i\n114 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n129 | }\n    |\
    \   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpabfg6lvq.rs:114:1\n  \
    \  |\n113 |         if max_arr[i] > arr[i\n    |         -- this `if` expression\
    \ has a condition, but no block\n114 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmpabfg6lvq.rs:113:28\n    |\n16  | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n    |                               \
    \                      - closing delimiter possibly meant for this\n...\n113 |\
    \         if max_arr[i] > arr[i\n    |                            ^ unclosed delimiter\n\
    114 | }\n    | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpabfg6lvq.rs:17:31\n   |\n17 |     if k == 0 || arr.len() <= k {\n\
    \   |                               ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     if k == 0 || arr.len() <= k.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpabfg6lvq.rs:23:12\n\
    \   |\n23 |         if arr[i] > arr[i * 2] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpabfg6lvq.rs:23:21\n   |\n23 |         if arr[i]\
    \ > arr[i * 2] {\n   |           "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for &i in arr {\n        if i > max_num {\n            max_num = i;\n   \
    \     }\n    }\n    for i in 0..k {\n        if max_num > arr[i] {\n         \
    \   max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    return max_arr;\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkfmq93ft.rs:22:9\n   |\n\
    22 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkfmq93ft.rs:28:22\n   |\n28 |  \
    \       if max_num > arr[i] {\n   |                      ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkfmq93ft.rs:30:23\n   |\n30 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n  \
    \  let mut max_idx = 0;\n    for i in 0..arr.len() {\n        if arr[i] > max_arr[k\
    \ - 1] {\n            max_arr[k - 1] = arr[i];\n            max_len = k - 1;\n\
    \            max_idx = i;\n        }\n        if max_len == 0 {\n            break;\n\
    \        }\n    }\n    max_arr.push(arr[max_idx]);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpi64q8hvh.rs:24:21\n\
    \   |\n24 |         if arr[i] > max_arr[k - 1] {\n   |                     ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpi64q8hvh.rs:25:13\n\
    \   |\n25 |             max_arr[k - 1] = arr[i];\n   |             ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    vec![max; k - max_idx]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:19\n   |\n\
    25 |     vec![max; k - max_idx]\n   |                   ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:15\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |               ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |     vec![max; (k -\
    \ max_idx).try_into().unwrap()]\n   |               +           +++++++++++++++++++++\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpz6v_s1uj.rs:25:17\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |                 ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = vec![];\n    for i in 0..k {\n        max_arr[i] = arr[i];\n        max_idx[i]\
    \ = i;\n    }\n    for i in 1..arr.len() {\n        if arr[i] > max_arr[k] {\n\
    \            max_arr[k] = arr[i];\n            max_idx[k] = i;\n        }\n  \
    \  }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp5_43y7qh.rs:20:9\n\
    \   |\n20 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp5_43y7qh.rs:20:22\n   |\n20 |         max_arr[i] =\
    \ arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp5_43y7qh.rs:21:9\n   |\n21 |         max_idx[i] =\
    \ i;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp5_43y7qh.rs:24:21\n\
    \   |\n24 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp5_43y7qh.rs:25:13\n\
    \   |\n25 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut max_idx = arr.len() - 1;\n    while max_len > 0 && max_idx\
    \ >= 0 {\n        if arr[max_idx] > arr[max_idx-1] {\n            max_arr.pop();\n\
    \            max_len -= 1;\n        } else {\n            max_arr.push(arr[max_idx]);\n\
    \            max_len -= 1;\n        }\n        max_idx -= 1;\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpxj_naide.rs:21:31

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr;\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n    let\
    \ mut max_idx = arr.len() - 1;\n    while max_idx >= 0 && max_len > 0 {\n    \
    \    if arr[max_idx] > arr[max_idx-1] {\n            max_arr.push(arr[max_idx]);\n\
    \            max_len -= 1;\n        } else {\n            max_len -= 1;\n    \
    \    }\n        max_idx -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw1gbwtkq.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_num = arr[0];\n        let mut max_idx = 1;\n       \
    \ for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_num;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphh1pzhhn.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphh1pzhhn.rs:28:23\n\
    \   |\n28 |         vec![max_num; max_idx + 1]\n   |                       ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                       +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    let mut max = arr[0];\n    for i in 1..k {\n        if max < arr[i]\
    \ {\n            max = arr[i];\n        }\n    }\n    vec![max]\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps1mg5y8k.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps1mg5y8k.rs:22:18\n   |\n22 |  \
    \       if max < arr[i] {\n   |                  ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps1mg5y8k.rs:23:19\n   |\n23 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    for ele in arr {\n        if max_len < ele {\n            max_len\
    \ = ele;\n        }\n    }\n    for ele in arr {\n        if max_len == ele {\n\
    \            max_arr.push(ele);\n        }\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpb0q51q8y.rs:24:16\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \         --- move occurs because `arr` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for ele in arr {\n    |         \
    \       --- `arr` moved due to this implicit call to `.into_iter()`\n...\n24 \
    \ |     for ele in arr {\n    |                ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `arr`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n19  |     for ele in &arr {\n    |\
    \                +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_idx = arr.len() - 1;\n        let mut max_val = arr[0];\n\
    \        let mut max_idx = max_idx;\n        for i in 1..arr.len() {\n       \
    \     if arr[i] > max_val {\n                max_val = arr[i];\n             \
    \   max_idx = i;\n            }\n        }\n        vec![max_val; k - max_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptorzk1gi.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptorzk1gi.rs:29:27\n   |\n29 |         vec![max_val; k -\
    \ max_idx]\n   |                           ^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptorzk1gi.rs:29:23\n   |\n29 |\
    \         vec![max_val; k - max_idx]\n   |                       ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |         vec![max_val;\
    \ (k - max_idx).try_into().unwrap()]\n   |                       +           +++++++++++++++++++++\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmptorzk1gi.rs:29:25\n\
    \   |\n29 |         vec![max_val; k - max_idx]\n   |                         ^\
    \ no implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    if k > arr.len() {\n        return vec![];\n    }\n    let\
    \ mut max = arr[0];\n    for i in 1..k {\n        if arr[i] > max {\n        \
    \    max = arr[i];\n        }\n    }\n    vec![max]\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjcpw69iz.rs:20:12\n   |\n\
    20 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpjcpw69iz.rs:25:12\n   |\n25 |  \
    \       if arr[i] > max {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjcpw69iz.rs:26:19\n   |\n26 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = vec![];\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_idx[0] = i;\n        }\n    }\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n    \
    \        max_idx[0] = i;\n        }\n        if arr[i] > max_arr[1] {\n      \
    \      max_arr[1] = arr[i];\n            max_idx[1] = i;\n        }\n    }\n \
    \   for i in 2..arr.len() {\n        if arr[i] > max_arr[1] {\n            max_arr[1]\
    \ = arr[i];\n            max_idx[1] = i;\n        }\n        if arr[i] > max_arr[2]\
    \ {\n            max_arr[2] = arr[i];\n            max_idx[2] = i;\n        }\n\
    \    }\n    for i in 3..arr.len() {\n        if arr[i] > max_arr[2] {\n      \
    \      max_arr[2] = arr[i];\n            max_idx[2] = i;\n        }\n        if\
    \ arr[i] > max_arr[3] {\n            max_arr[3] = arr[i];\n            max_idx[3]\
    \ = i;\n        }\n    }\n    for i in 4..arr.len() {\n        if arr[i] > max_arr[3]\
    \ {\n            max_arr[3] = arr[i];\n            max_idx[3] = i;\n        }\n\
    \        if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n        \
    \    max_idx[4] = i;\n        }\n    }\n    for i in 5..arr.len() {\n        if\
    \ arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n            max_idx[4]\
    \ = i;\n        }\n        if arr[i] > max_arr[5] {\n            max_arr[5] =\
    \ arr[i];\n            max_idx[5] = i;\n        }\n    }\n    for i in 6..arr.len()\
    \ {\n        if arr[i] > max_arr[5] {\n            max_arr[5] = arr[i];\n    \
    \        max_idx[5] = i;\n        }\n        if arr[i] > max_arr[6] {\n      \
    \      max_arr[6] = arr[i];\n            max_idx[6] = i;\n        }\n    }\n \
    \   for i in 7..arr.len() {\n        if arr[i] > max_arr[6] {\n            max_arr[6]\
    \ = arr[i];\n            max_idx[6] = i;\n        }\n        if arr[i] > max_arr[7]\
    \ {\n            max_arr[7] = arr[i];\n            max_idx[7] = i;\n        }\n\
    \    }\n    for i in 8..arr.len() {\n        if arr[i] > max_arr[7] {\n      \
    \      max_arr[7] = arr[i];\n            max_idx[7] = i;\n        }\n        if\
    \ arr[i] > max_arr[8] {\n            max_arr[8] = arr[i];\n            max_idx[8]\
    \ = i;\n        }\n    }\n    for i in 9..arr.len() {\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_kttnenq.rs:124:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    108 |     for i in 9..arr.len() {\n    |                           - this delimiter\
    \ might not be properly closed...\n109 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n124 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_kttnenq.rs:23:12\n  \
    \ |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_kttnenq.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kttnenq.rs:31:26\n\
    \   |\n31 |             max_idx[0] = i;\n   |             ----------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kttnenq.rs:35:26\n\
    \   |\n35 |             max_idx[1] = i;\n   |             ----------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kttnenq.rs:41:26\n\
    \   |\n41 |             max_idx[1] = i;\n   |             ----------   ^ expected\
    \ `isize`, found `usize`\n   |             |\n   |         "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n \
    \   let mut min_idx = -1;\n    let mut min_val = arr[0];\n    for i in 0..arr.len()\
    \ {\n        if arr[i] > min_val {\n            min_val = arr[i];\n          \
    \  min_idx = i;\n        }\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        max_arr.push(arr[max_idx]);\n        max_idx--;\n    }\n    for i in\
    \ 0..k {\n        max_arr.push(arr[min_idx]);\n        min_idx++;\n    }\n   \
    \ max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3qk25zit.rs:36:18\n\
    \   |\n36 |         max_idx--;\n   |                  ^ expected expression\n\n\
    error: Rust has no postfix increment operator\n  --> /tmp/tmp3qk25zit.rs:40:16\n\
    \   |\n40 |         min_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n40 |         { let tmp = min_idx; min_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n40 -  \
    \       min_idx++;\n40 +         min_idx += 1;\n   | \n\nerror[E0425]: cannot\
    \ find value `max_val` in this scope\n  --> /tmp/tmp3qk25zit.rs:29:21\n   |\n\
    29 |         if arr[i] > max_val {\n   |                     ^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_val`\n\nerror[E0425]: cannot find\
    \ value `max_val` in this scope\n  --> /tmp/tmp3qk25zit.rs:30:13\n   |\n30 | \
    \            max_val = arr[i];\n   |             ^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_val`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp3qk25zit.rs:22:23\n   |\n22 |     let mut\
    \ min_idx = -1;\n   |                       ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmp3qk25zit.rs:21:23\n   |\n21 |     let mut max_idx =\
    \ -1;\n   |                       ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for num in arr {\n        if num > max_num {\n            max_num\
    \ = num;\n        }\n    }\n    for i in 0..k {\n        max_arr.push(max_num);\n\
    \    }\n    return max_arr;\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpwe0gjt38.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for i in\
    \ 1..k {\n        if arr[i] > max {\n            max = arr[i];\n            max_idx\
    \ = i;\n        }\n    }\n    vec![max; max_idx + 1]\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaogcf6m7.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaogcf6m7.rs:23:12\n\
    \   |\n23 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpaogcf6m7.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaogcf6m7.rs:28:15\n\
    \   |\n28 |     vec![max; max_idx + 1]\n   |               ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n28 |     vec![max; (max_idx\
    \ + 1).try_into().unwrap()]\n   |               +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut cur_max = arr[0];\n    for i in 1..arr.len() {\n        if\
    \ cur_max < arr[i] {\n            cur_max = arr[i];\n        }\n        if cur_max\
    \ >= max_k {\n            max_arr.push(cur_max);\n        }\n        if cur_max\
    \ > max_k {\n            max_k = cur_max;\n        }\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5]`,\n right: `[-4, -3, 5]`', /tmp/tmpcosgpy6o.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![vec![0]; k]\n    for i in 0..k {\n        max_arr[i]\
    \ = arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].max(|a,\
    \ b| a.cmp(b));\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n  \
    \  }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmprca43vbr.rs:20:39\n\
    \   |\n20 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                  ^ help: add `;` here\n21 |     for i in 0..k {\n   |     ---\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprca43vbr.rs:17:21\n\
    \   |\n17 |     if arr.len() <= k {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprca43vbr.rs:20:37\n   |\n20 |     let mut max_arr = vec![vec![0];\
    \ k]\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()]\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmprca43vbr.rs:22:9\n\
    \   |\n22 |         max_arr[i] = arr[i].max();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprca43vbr.rs:22:22\n\
    \   |\n22 |         max_arr[i] = arr[i].max();\n   |                      ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/t"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_element = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] > max_element {\n            max_element = arr[i];\n           \
    \ max_k = i;\n        }\n    }\n    for i in 0..k {\n        max_arr.push(max_element);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvlfq420p.rs:23:21\n   |\n\
    18 |     let mut max_k = k;\n   |                     - expected due to this value\n\
    ...\n23 |             max_k = i;\n   |                     ^ expected `isize`,\
    \ found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr.len() == 0 || max_arr[0] > arr[max_i] {\n            max_arr.push(arr[max_i]);\n\
    \        }\n        max_i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp016jt1m2.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = arr.len() -\
    \ 1;\n    let mut max_val = arr[0];\n    for i in 0..k {\n        if arr[i] >\
    \ max_val {\n            max_val = arr[i];\n            max_idx = i;\n       \
    \ }\n    }\n    for i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for\
    \ i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq7ahnrjq.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq7ahnrjq.rs:24:12\n\
    \   |\n24 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpq7ahnrjq.rs:25:23\n   |\n25 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq7ahnrjq.rs:26:23\n\
    \   |\n21 |     let mut max_idx = arr.len() - 1;\n   |                       -------------\
    \ expected due to this value\n...\n26 |             max_idx = i;\n   |       \
    \                ^ expected `usize`, found `isize`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpq7ahnrjq.rs:30:9\n   |\n30 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_arr[1] {\n            max_arr[1] = arr[i];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > max_arr[2] {\n            max_arr[2] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[3] {\n   \
    \         max_arr[3] = arr[i];\n        }\n    }\n    for i in 0..k {\n      \
    \  if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if arr[i] > max_arr[5] {\n            max_arr[5]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[6]\
    \ {\n            max_arr[6] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[7] {\n            max_arr[7] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_arr[8] {\n            max_arr[8]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[9]\
    \ {\n            max_arr[9] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[10] {\n            max_arr[10] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[11] {\n        \
    \    max_arr[11] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[12] {\n            max_arr[12] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[13] {\n            max_arr[13]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[14]\
    \ {\n            max_arr[14] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[15] {\n            max_arr[15] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[16] {\n        \
    \    max_arr[16] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[17] {\n            max_arr[17] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[18\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfandujqm.rs:130:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    113 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n114 |         if arr[i] > max_arr[18\n115 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n130 | }\n   \
    \ |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpfandujqm.rs:115:1\n\
    \    |\n114 |         if arr[i] > max_arr[18\n    |         -- this `if` expression\
    \ has a condition, but no block\n115 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmpfandujqm.rs:114:28\n    |\n16  | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n    |                               \
    \                      - closing delimiter possibly meant for this\n...\n114 |\
    \         if arr[i] > max_arr[18\n    |                            ^ unclosed\
    \ delimiter\n115 | }\n    | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfandujqm.rs:17:31\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k {\n   |                               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if k == 0 || arr.len() <= k.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfandujqm.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfandujqm.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |        "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_num = arr[0];\n  \
    \      for i in 1..k {\n            if arr[i] > max_num {\n                max_num\
    \ = arr[i];\n            }\n        }\n        max_arr.push(max_num);\n      \
    \  for i in 1..k {\n            if arr[i] > max_num {\n                max_arr.push(arr[i]);\n\
    \            }\n        }\n        max_arr\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa_2hwfrt.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa_2hwfrt.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_num {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpa_2hwfrt.rs:24:27\n   |\n24 |            \
    \     max_num = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpa_2hwfrt.rs:29:16\n   |\n29 |            \
    \ if arr[i] > max_num {\n   |                ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpa_2hwfrt.rs:30:30\n   |\n30 |            \
    \     max_arr.push(arr[i]);\n   |                              ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for\
    \ i in 0..arr.len() {\n        if arr[i] > max_arr[k] {\n            max_arr[k]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    max_arr.extend_from_slice(&arr[max_idx..k]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk_nlswon.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpk_nlswon.rs:23:21\n\
    \   |\n23 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpk_nlswon.rs:24:13\n\
    \   |\n24 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpk_nlswon.rs:21:23\n   |\n21 | \
    \    let mut max_idx = -1;\n   |                       ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk_nlswon.rs:28:45\n   |\n28 |     max_arr.extend_from_slice(&arr[max_idx..k]);\n\
    \   |                                             ^ expected `usize`, found `isize`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor m"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if max < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpw4el71sn.rs:19:18\n\
    \   |\n19 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpw4el71sn.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_idx = arr.len();\n        let mut max_val = arr[0];\n\
    \        for i in 1..k {\n            if arr[i] > max_val {\n                max_val\
    \ = arr[i];\n                max_idx = i;\n            }\n        }\n        vec![max_val;\
    \ max_idx + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_drowu8.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpn_drowu8.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max_val {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn_drowu8.rs:24:27\n   |\n24 |            \
    \     max_val = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_drowu8.rs:25:27\n\
    \   |\n20 |         let mut max_idx = arr.len();\n   |                       \
    \    --------- expected due to this value\n...\n25 |                 max_idx =\
    \ i;\n   |                           ^ expected `usize`, found `isize`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    if k > arr.len() {\n        return vec![];\n    }\n    let\
    \ mut max_arr = vec![];\n    let mut max_len = k;\n    let mut max_pos = 0;\n\
    \    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if arr[i]\
    \ > max_val {\n            max_val = arr[i];\n            max_pos = i;\n     \
    \   }\n    }\n    for i in 0..k {\n        if max_pos == i {\n            max_arr.push(max_val);\n\
    \        } else {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeeqvotuk.rs:20:12\n   |\n\
    20 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeeqvotuk.rs:34:23\n   |\n34 |         if max_pos == i {\n\
    \   |                       ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n34 |         if max_pos == i.try_into().unwrap() {\n   |        \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpeeqvotuk.rs:37:26\n   |\n37 |         \
    \    max_arr.push(arr[i]);\n   |                          ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n \
    \   for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[max_idx] {\n            max_arr[max_idx] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n   \
    \         max_arr[0] = arr[i];\n        }\n    }\n    for i in 0..k {\n      \
    \  if arr[i] > max_arr[max_idx] {\n            max_arr[max_idx] = arr[i];\n  \
    \      }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n     \
    \       max_arr[0] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_arr[max_idx] {\n            max_arr[max_idx] = arr[i];\n      \
    \  }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n         \
    \   max_arr[0] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_arr[max_idx] {\n            max_arr[max_idx] = arr[i];\n        }\n  \
    \  }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[max_idx]\
    \ {\n            max_arr[max_idx] = arr[i];\n        }\n    }\n    for i in 0..k\
    \ {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n    \
    \    }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[max_idx] {\n \
    \           max_arr[max_idx] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_arr[max_idx] {\n        \
    \    max_arr[max_idx] = arr[i];\n        }\n    }\n    for i in 0..k {\n     \
    \   if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n  \
    \  }\n    for i in 0..k {\n        if arr[i] > max_arr[max_idx] {\n          \
    \  max_arr[max_idx] = arr[i];\n        }\n    }\n    for i in 0..k {\n       \
    \ if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n    }\n\
    \    for i in 0..k {\n        if arr[i] > max_arr[max_idx] {\n            max_arr[max_idx]\
    \ = arr[i];\n        }\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo22rspnx.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo22rspnx.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo22rspnx.rs:29:12\n   |\n29 |         if arr[i]\
    \ > max_arr[max_idx] {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpo22rspnx.rs:29:21\n   |\n29 |         if arr[i] >\
    \ max_arr[max_idx] {\n   |                     ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpo22rspnx.rs:30:13\n   |\n30 |             max_arr[max_idx]\
    \ = arr[i];\n   |             ^^^^^^^^^^^^^^^^ slice indices are "
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_len = k;\n        }\n \
    \       if max_len == k {\n            break;\n        }\n        if arr[i] >\
    \ max_arr[1] {\n            max_arr[1] = arr[i];\n        }\n        i += 1;\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp_064eb5f.rs:21:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 && max_k > 0 {\n\
    \        if arr[max_idx] > arr[max_idx - 1] {\n            max_k -= 1;\n     \
    \   } else {\n            max_idx -= 1;\n        }\n    }\n    max_arr.extend(&arr[..max_idx]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp_9c3tnhu.rs:21:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = 0;\n    let mut min_i = 0;\n    let mut min_k = k;\n\
    \    let mut min_arr = vec![];\n    while min_i < arr.len() && min_k < arr.len()\
    \ {\n        if arr[min_i] >= arr[min_k] {\n            min_arr.push(arr[min_i]);\n\
    \            min_i += 1;\n        } else {\n            min_arr.push(arr[min_k]);\n\
    \            min_k += 1;\n        }\n    }\n    while max_i < arr.len() && max_k\
    \ < arr.len() {\n        if arr[max_i] <= arr[max_k] {\n            max_arr.push(arr[max_i]);\n\
    \            max_i += 1;\n        } else {\n            max_arr.push(arr[max_k]);\n\
    \            max_k += 1;\n        }\n    }\n    if min_i < arr.len() {\n     \
    \   max_arr.extend(min_arr.iter().cloned());\n    }\n    if max_k < arr.len()\
    \ {\n        max_arr.extend(min_arr.iter().cloned());\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rzzkped.rs:23:40\n   |\n\
    23 |     while min_i < arr.len() && min_k < arr.len() {\n   |                \
    \                        ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |     while min_i < arr.len() && min_k < arr.len().try_into().unwrap()\
    \ {\n   |                                                 ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5rzzkped.rs:24:26\n\
    \   |\n24 |         if arr[min_i] >= arr[min_k] {\n   |                      \
    \    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5rzzkped.rs:28:26\n\
    \   |\n28 |             min_arr.push(arr[min_k]);\n   |                      \
    \    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5rzzkped.rs:32:40\n   |\n32 |\
    \     while max_i < arr.len() && max_k < arr.len() {\n   |                   \
    \                     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n32 |     while max_i < arr.len() && max_k < arr.len().try_into().unwrap()\
    \ {\n   |                                                 ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5rzzkped.rs:33:26\n\
    \   |\n33 |         if arr[max_i] <= arr[max_k] {\n   |                    "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = arr.len() -\
    \ 1;\n    let mut max_val = arr[0];\n    for i in 0..k {\n        if max_val <\
    \ arr[i] {\n            max_val = arr[i];\n            max_idx = i;\n        }\n\
    \    }\n    max_arr.push(max_val);\n    for i in 1..max_idx {\n        if arr[i]\
    \ > max_val {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu3zd860n.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpu3zd860n.rs:24:22\n\
    \   |\n24 |         if max_val < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpu3zd860n.rs:25:23\n   |\n25 |  \
    \           max_val = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu3zd860n.rs:26:23\n\
    \   |\n21 |     let mut max_idx = arr.len() - 1;\n   |                       -------------\
    \ expected due to this value\n...\n26 |             max_idx = i;\n   |       \
    \                ^ expected `usize`, found `isize`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    for i in 0..arr.len() {\n        if max_len < arr[i].clone() {\n \
    \           max_len = arr[i].clone();\n        }\n    }\n    for i in 0..k {\n\
    \        max_arr.push(max_len);\n    }\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > max_arr[i] {\n            max_arr[i] = arr[i];\n        }\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmp2spw4tev.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![arr[0]; k]\n    for i in 1..arr.len() {\n    \
    \    if arr[i] > max_arr[k-1] {\n            max_arr[k-1] = arr[i]\n        }\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpap0o0z_z.rs:20:38\n\
    \   |\n20 |     let mut max_arr = vec![arr[0]; k]\n   |                      \
    \                ^ help: add `;` here\n21 |     for i in 1..arr.len() {\n   |\
    \     --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap0o0z_z.rs:17:21\n\
    \   |\n17 |     if arr.len() <= k {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpap0o0z_z.rs:20:36\n   |\n20 |     let mut max_arr = vec![arr[0];\
    \ k]\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max_arr = vec![arr[0]; k.try_into().unwrap()]\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpap0o0z_z.rs:22:21\n\
    \   |\n22 |         if arr[i] > max_arr[k-1] {\n   |                     ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpap0o0z_z.rs:23:13\n\
    \   |\n23 |             max_arr[k-1] = arr[i]\n   |             ^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nF"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut min_k = k;\n    let mut min_arr = vec![];\n    let mut min_idx\
    \ = -1;\n    let mut max_idx = -1;\n    let mut max_val = arr[0];\n    for &i\
    \ in arr {\n        if i < min_val {\n            min_val = i;\n            min_idx\
    \ = i;\n        }\n        if i > max_val {\n            max_val = i;\n      \
    \      max_idx = i;\n        }\n        if i == min_val {\n            min_arr.push(min_val);\n\
    \        }\n        if i == max_val {\n            max_arr.push(max_val);\n  \
    \      }\n        if min_k <= i && i <= max_k {\n            if min_k <= i {\n\
    \                min_arr.push(min_val);\n            }\n            if max_k <=\
    \ i {\n                max_arr.push(max_val);\n            }\n        }\n    }\n\
    \    if min_arr.len() < min_k {\n        min_arr.push(min_val);\n    }\n    if\
    \ max_arr.len() < max_k {\n        max_arr.push(max_val);\n    }\n    if min_arr.len()\
    \ > max_k {\n        min_arr.truncate(max_k);\n    }\n    if max_arr.len() > max_k\
    \ {\n        max_arr.truncate(max_k);\n    }\n    if min_arr.len() > min_k {\n\
    \        min_arr.push(min_val);\n    }\n    if max_arr.len() > min_k {\n     \
    \   max_arr.push(max_val);\n    }\n    if min_arr.len() == min_k {\n        min_arr\n\
    \    }\n    if max_arr.len() == max_k {\n        max_arr\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `min_val` in this scope\n  --> /tmp/tmp7k8lfdic.rs:25:16\n\
    \   |\n25 |         if i < min_val {\n   |                ^^^^^^^ help: a local\
    \ variable with a similar name exists: `max_val`\n\nerror[E0425]: cannot find\
    \ value `min_val` in this scope\n  --> /tmp/tmp7k8lfdic.rs:26:13\n   |\n26 | \
    \            min_val = i;\n   |             ^^^^^^^ help: a local variable with\
    \ a similar name exists: `max_val`\n\nerror[E0425]: cannot find value `min_val`\
    \ in this scope\n  --> /tmp/tmp7k8lfdic.rs:33:17\n   |\n33 |         if i == min_val\
    \ {\n   |                 ^^^^^^^ help: a local variable with a similar name exists:\
    \ `max_val`\n\nerror[E0425]: cannot find value `min_val` in this scope\n  -->\
    \ /tmp/tmp7k8lfdic.rs:34:26\n   |\n34 |             min_arr.push(min_val);\n \
    \  |                          ^^^^^^^ help: a local variable with a similar name\
    \ exists: `max_val`\n\nerror[E0425]: cannot find value `min_val` in this scope\n\
    \  --> /tmp/tmp7k8lfdic.rs:41:30\n   |\n41 |                 min_arr.push(min_val);\n\
    \   |                              ^^^^^^^ help: a local variable with a similar\
    \ name exists: `max_val`\n\nerror[E0425]: cannot find value `min_val` in this\
    \ scope\n  --> /tmp/tmp7k8lfdic.rs:49:22\n   |\n49 |         min_arr.push(min_val);\n\
    \   |                      ^^^^^^^ help: a local variable with a similar name\
    \ exists: `max_val`\n\nerror[E0425]: cannot find value `min_val` in this scope\n\
    \  --> /tmp/tmp7k8lfdic.rs:61:22\n   |\n61 |         min_arr.push(min_val);\n\
    \   |                      ^^^^^^^ help: a local variable with a similar name\
    \ exists: `max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7k8lfdic.rs:24:9\n\
    \   |\n24 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7k8lfdic.rs:48:24\n   |\n48 |     if min_arr.len()\
    \ < min_k {\n   |                   "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_val = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_val {\n            max_val = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_val {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpjg2t9j_7.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjg2t9j_7.rs:24:23\n   |\n24 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjg2t9j_7.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjg2t9j_7.rs:29:26\n   |\n29 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu6jwrop8.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n129 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpu6jwrop8.rs:114:1\n    |\n113 |         if arr\n\
    \    |         -- this `if` expression has a condition, but no block\n114 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6jwrop8.rs:16:42\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n    let\
    \ mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0] {\n  \
    \          max_arr[0] = arr[i];\n            max_len = k;\n        }\n       \
    \ if max_len == k {\n            break;\n        }\n        if arr[i] > max_arr[1]\
    \ {\n            max_arr[1] = arr[i];\n        }\n        i += 1;\n    }\n   \
    \ max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwq94mn_2.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![arr[0]];\n    for i in 1..k {\n     \
    \   if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n  \
    \  }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jws5q2k.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7jws5q2k.rs:22:12\n\
    \   |\n22 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7jws5q2k.rs:23:26\n   |\n23 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        let\
    \ mut max_value = arr[0];\n        for i in 1..arr.len() {\n            if arr[i]\
    \ > max_value {\n                max_value = arr[i];\n                max_i =\
    \ i;\n            }\n        }\n        max_arr.push(max_value);\n        max_k\
    \ -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbophbn6k.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_idx = arr.len();\n\
    \    for i in 0..k {\n        if max_idx > arr.len() {\n            break;\n \
    \       }\n        if arr[i] > max_arr[0] {\n            max_arr = vec![arr[i]];\n\
    \            max_idx = i;\n        } else {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcfow5xyl.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcfow5xyl.rs:26:12\n\
    \   |\n26 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpcfow5xyl.rs:27:28\n   |\n27 |            \
    \ max_arr = vec![arr[i]];\n   |                            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcfow5xyl.rs:28:23\n\
    \   |\n21 |     let mut max_idx = arr.len();\n   |                       ---------\
    \ expected due to this value\n...\n28 |             max_idx = i;\n   |       \
    \                ^ expected `usize`, found `isize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcfow5xyl.rs:30:26\n   |\n30 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut cur_max = arr[0];\n    for x in arr {\n        if x > cur_max\
    \ {\n            cur_max = x;\n        }\n        if x == cur_max {\n        \
    \    max_arr.push(cur_max);\n        }\n        if max_k == 0 {\n            break;\n\
    \        }\n        if x > max_k {\n            max_k = x;\n        }\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-3, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpkntfeotf.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    let mut max_idx = 1;\n    for i in 1..k {\n        if arr[i]\
    \ > max_num {\n            max_num = arr[i];\n            max_idx = i;\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    for i in 0..k {\n        if arr[i]\
    \ > max_num {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp94cxys9_.rs:21:12\n\
    \   |\n21 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp94cxys9_.rs:22:23\n   |\n22 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp94cxys9_.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp94cxys9_.rs:29:26\n   |\n29 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = 0;\n    let mut min_i = 0;\n    let mut min_k = k;\n\
    \    let mut min_arr = vec![];\n    let mut min_arr_i = 0;\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        if arr[i] > arr[i] - max_k {\n           \
    \ max_arr.push(arr[i]);\n            max_k = max_k - 1;\n        }\n        if\
    \ arr[i] < arr[i] - min_k {\n            min_arr.push(arr[i]);\n            min_k\
    \ = min_k + 1;\n        }\n        if arr[i] > arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] < arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] == arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] == arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] > arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] < arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] == arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] == arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] > arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] < arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] == arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] == arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] > arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] < arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n        if arr[i] == arr[i] - max_k {\n            max_arr.push(arr[i]);\n\
    \            max_k = max_k - 1;\n        }\n        if arr[i] == arr[i] - min_k\
    \ {\n            min_arr.push(arr[i]);\n            min_k = min_k + 1;\n     \
    \   }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpuzxxttyp.rs:113:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    25  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n98  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n113 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuzxxttyp.rs:16:42\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut min_arr = vec![];\n    let mut min_k = k;\n    let mut min_val\
    \ = arr[0];\n    let mut max_val = arr[0];\n    let mut i = 0;\n    while i <\
    \ arr.len() {\n        if arr[i] > max_val {\n            max_val = arr[i];\n\
    \            max_arr.push(max_val);\n            max_k -= 1;\n        }\n    \
    \    if arr[i] < min_val {\n            min_val = arr[i];\n            min_arr.push(min_val);\n\
    \            min_k -= 1;\n        }\n        i += 1;\n    }\n    if max_k == 0\
    \ {\n        max_arr.push(max_val);\n    }\n    if min_k == 0 {\n        min_arr.push(min_val);\n\
    \    }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n    }\n    if max_k ==\
    \ min_k {\n        max_arr.push(max_val);\n        min_arr.push(min_val);\n  \
    \  }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n    }\n    if max_k ==\
    \ min_k {\n        max_arr.push(max_val);\n        min_arr.push(min_val);\n  \
    \  }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n    }\n    if max_k ==\
    \ min_k {\n        max_arr.push(max_val);\n        min_arr.push(min_val);\n  \
    \  }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n    }\n    if max_k ==\
    \ min_k {\n        max_arr.push(max_val);\n        min_arr.push(min_val);\n  \
    \  }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n    }\n    if max_k ==\
    \ min_k {\n        max_arr.push(max_val);\n        min_arr.push(min_val);\n  \
    \  }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n    }\n    if max_k ==\
    \ min_k {\n        max_arr.push(max_val);\n        min_arr.push(min_val);\n  \
    \  }\n    if max_k > min_k {\n        max_arr = max_arr.iter().cloned().collect();\n\
    \        min_arr = min_arr.iter().cloned().collect();\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpnhn_qeeg.rs:109:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    91  |     if max_k > min_k {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n94  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n109 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnhn_qeeg.rs:16:42\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max = arr[0];\n        let mut max_idx = 1;\n        for\
    \ i in 1..k {\n            if arr[i] > max {\n                max = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        vec![max; max_idx\
    \ + 1]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx81uiiqk.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpx81uiiqk.rs:23:16\n   |\n23 |  \
    \           if arr[i] > max {\n   |                ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpx81uiiqk.rs:24:23\n   |\n24 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx81uiiqk.rs:28:19\n\
    \   |\n28 |         vec![max; max_idx + 1]\n   |                   ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |         vec![max;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                   +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for &i in arr {\n        if i > max {\n            max = i;\n      \
    \      max_idx = 1;\n        }\n        if i == max {\n            max_idx +=\
    \ 1;\n        }\n    }\n    let mut max_idx = max_idx - k;\n    if max_idx < 0\
    \ {\n        max_idx = 0;\n    }\n    vec![max; max_idx]\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbn00qnjy.rs:19:9\n   |\n\
    19 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbn00qnjy.rs:32:15\n   |\n32 |     vec![max; max_idx]\n   |    \
    \           ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    32 |     vec![max; max_idx.try_into().unwrap()]\n   |                      ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[k]\
    \ {\n            max_arr[k] = arr[i];\n            max_k--;\n        }\n     \
    \   i += 1;\n    }\n    max_arr.extend(vec![max_k].iter().cloned());\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmqxtxvye.rs:23:20\n\
    \   |\n23 |             max_k--;\n   |                    ^ expected expression\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpmqxtxvye.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpmqxtxvye.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![vec![0]; k];\n    let mut max_k = k;\n    let\
    \ mut max_idx = 0;\n    for &i in arr {\n        if max_k == 0 {\n           \
    \ break;\n        }\n        if i > max_arr[k - 1][0] {\n            max_arr[k\
    \ - 1][0] = i;\n            max_k--;\n        } else {\n            max_arr[k\
    \ - 1][1] = i;\n        }\n    }\n    for &i in max_arr {\n        if i[1] > max_arr[k\
    \ - 1][0] {\n            max_k = k;\n            max_idx = i[0];\n        }\n\
    \    }\n    max_arr.iter().cloned().take(max_k).collect()\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp7y56aoys.rs:29:20\n\
    \   |\n29 |             max_k--;\n   |                    ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7y56aoys.rs:17:21\n   |\n17 |\
    \     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7y56aoys.rs:20:37\n   |\n20 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7y56aoys.rs:23:9\n   |\n23 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7y56aoys.rs:27:16\n   |\n27 |  \
    \       if i > max_arr[k - 1][0] {\n   |                ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7y56aoys.rs:28:13\n   |\n28 |  \
    \           max_arr[k - 1][0] = i;\n   |             ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    vec![max; k - max_idx]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:19\n   |\n\
    25 |     vec![max; k - max_idx]\n   |                   ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz6v_s1uj.rs:25:15\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |               ^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |     vec![max; (k -\
    \ max_idx).try_into().unwrap()]\n   |               +           +++++++++++++++++++++\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpz6v_s1uj.rs:25:17\n\
    \   |\n25 |     vec![max; k - max_idx]\n   |                 ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[1] {\n            max_arr[1] = arr[i];\n        \
    \    max_k = k - 1;\n        }\n        if arr[i] > max_arr[2] {\n           \
    \ max_arr[2] = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i]\
    \ > max_arr[3] {\n            max_arr[3] = arr[i];\n            max_k = k - 1;\n\
    \        }\n        if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n\
    \            max_k = k - 1;\n        }\n        if arr[i] > max_arr[5] {\n   \
    \         max_arr[5] = arr[i];\n            max_k = k - 1;\n        }\n      \
    \  if arr[i] > max_arr[6] {\n            max_arr[6] = arr[i];\n            max_k\
    \ = k - 1;\n        }\n        if arr[i] > max_arr[7] {\n            max_arr[7]\
    \ = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i] > max_arr[8]\
    \ {\n            max_arr[8] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[9] {\n            max_arr[9] = arr[i];\n        \
    \    max_k = k - 1;\n        }\n        if arr[i] > max_arr[10] {\n          \
    \  max_arr[10] = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i]\
    \ > max_arr[11] {\n            max_arr[11] = arr[i];\n            max_k = k -\
    \ 1;\n        }\n        if arr[i] > max_arr[12] {\n            max_arr[12] =\
    \ arr[i];\n            max_k = k - 1;\n        }\n        if arr[i] > max_arr[13]\
    \ {\n            max_arr[13] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[14] {\n            max_arr[14] = arr[i];\n      \
    \      max_k = k - 1;\n        }\n        if arr[i] > max_arr[15] {\n        \
    \    max_arr[15] = arr[i];\n            max_k = k - 1;\n        }\n        if\
    \ arr[i] > max_arr[16] {\n            max_arr[16] = arr[i];\n            max_k\
    \ = k - 1;\n        }\n        if arr[i] > max_arr[17] {\n            max_arr[17]\
    \ = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i] > max_arr[18]\
    \ {\n            max_arr[18] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[19] {\n            max_arr[19] = arr[i];\n      \
    \      max_k = k - 1;\n        }\n        if arr[i] > max_arr[20] {\n\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjk4wzoi5.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - unclosed delimiter\n\
    ...\n101 |         if arr[i] > max_arr[20] {\n    |                          \
    \       - this delimiter might not be properly closed...\n102 | \n103 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n118 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpjk4wzoi5.rs:20:5\n\
    \    |\n16  |   fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    | \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20  | /     while i < arr.len() {\n21  | |         if arr[i]\
    \ > max_arr[0] {\n22  | |             max_arr[0] = arr[i];\n23  | |          \
    \   max_k = k - 1;\n...   |\n117 | |     assert_eq!(candidate(vec![1, 2, 3, -23,\
    \ 243, -400, 0], 0), Vec::<isize>::new());\n118 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![];\n    let mut max_len = k;\n    for\
    \ &i in arr {\n        if i >= max_len {\n            max_len = i;\n        }\n\
    \    }\n    for i in 0..max_len {\n        let mut max_element = i;\n        for\
    \ &j in arr {\n            if j == i {\n                continue;\n          \
    \  }\n            if j > max_element {\n                max_element = j;\n   \
    \         }\n        }\n        max_arr.push(max_element);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp308yc7w4.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp308yc7w4.rs:22:9\n   |\n22 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp308yc7w4.rs:29:13\n   |\n29 |         for &j in arr {\n   |   \
    \          ^^    --- this expression has type `Option<isize>`\n   |          \
    \   |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `j`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 1;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[1] = arr[i];\n           \
    \ max_k = 2;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[2]\
    \ = arr[i];\n            max_k = 3;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[3] = arr[i];\n            max_k = 4;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[4] = arr[i];\n           \
    \ max_k = 5;\n        }\n        i += 1;\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpqiz9v6o1.rs:21:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu6jwrop8.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n129 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpu6jwrop8.rs:114:1\n    |\n113 |         if arr\n\
    \    |         -- this `if` expression has a condition, but no block\n114 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6jwrop8.rs:16:42\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        let\
    \ mut max_elem = arr[0];\n        let mut max_idx = 0;\n        for i in 1..arr.len()\
    \ {\n            if arr[i] > max_elem {\n                max_elem = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        max_arr.push(max_elem);\n\
    \        max_k -= 1;\n        if max_k == 0 {\n            break;\n        }\n\
    \        arr.swap(0, max_idx);\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp395uo0ia.rs:19:9\n\
    \   |\n19 |     let mut max_idx = arr.len();\n   |         ----^^^^^^^\n   | \
    \        |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `arr` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp395uo0ia.rs:34:9\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |            --- help: consider changing\
    \ this to be mutable: `mut arr`\n...\n34 |         arr.swap(0, max_idx);\n   |\
    \         ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr.len() < max_k {\n            max_arr.push(arr[max_i]);\n        }\n\
    \        if max_arr[max_i] < arr[max_i] {\n            max_arr.swap(max_i, max_i\
    \ + 1);\n        }\n        max_i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1sar_uw.rs:20:19\n   |\n\
    20 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd1sar_uw.rs:21:28\n   |\n21 |         if max_arr.len()\
    \ < max_k {\n   |                            ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if max_arr.len() < max_k.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[k]\
    \ {\n            max_arr[k] = arr[i];\n            max_k = k + 1;\n        }\n\
    \        i += 1;\n    }\n    max_arr.truncate(max_k);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpbvt_monz.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpbvt_monz.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbvt_monz.rs:27:22\n   |\n27 |     max_arr.truncate(max_k);\n  \
    \ |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |     max_arr.truncate(max_k.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_val = arr[0];\n\
    \    for i in 0..k {\n        if arr[i] > max_val {\n            max_val = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_val {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyyomvgtq.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpyyomvgtq.rs:24:23\n   |\n24 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpyyomvgtq.rs:28:12\n   |\n28 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpyyomvgtq.rs:29:26\n   |\n29 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_val = arr[0];\n    for ele in arr {\n        if ele >\
    \ max_val {\n            max_val = ele;\n        }\n        if max_k == 0 {\n\
    \            break;\n        }\n        if ele > max_val {\n            max_arr\
    \ = vec![max_val];\n            max_k -= 1;\n        }\n        if max_k == 0\
    \ {\n            break;\n        }\n        if ele > max_arr[0] {\n          \
    \  max_arr[0] = ele;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmppefoiaiy.rs:34:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max = arr[0];\n    for i in 1..k {\n        if max\
    \ < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6g9gkh3p.rs:22:18\n\
    \   |\n22 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6g9gkh3p.rs:23:19\n   |\n23 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[1] {\n            max_arr[1] = arr[i];\n        \
    \    max_k = k - 1;\n        }\n        if arr[i] > max_arr[2] {\n           \
    \ max_arr[2] = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i]\
    \ > max_arr[3] {\n            max_arr[3] = arr[i];\n            max_k = k - 1;\n\
    \        }\n        if arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n\
    \            max_k = k - 1;\n        }\n        if arr[i] > max_arr[5] {\n   \
    \         max_arr[5] = arr[i];\n            max_k = k - 1;\n        }\n      \
    \  if arr[i] > max_arr[6] {\n            max_arr[6] = arr[i];\n            max_k\
    \ = k - 1;\n        }\n        if arr[i] > max_arr[7] {\n            max_arr[7]\
    \ = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i] > max_arr[8]\
    \ {\n            max_arr[8] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[9] {\n            max_arr[9] = arr[i];\n        \
    \    max_k = k - 1;\n        }\n        if arr[i] > max_arr[10] {\n          \
    \  max_arr[10] = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i]\
    \ > max_arr[11] {\n            max_arr[11] = arr[i];\n            max_k = k -\
    \ 1;\n        }\n        if arr[i] > max_arr[12] {\n            max_arr[12] =\
    \ arr[i];\n            max_k = k - 1;\n        }\n        if arr[i] > max_arr[13]\
    \ {\n            max_arr[13] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[14] {\n            max_arr[14] = arr[i];\n      \
    \      max_k = k - 1;\n        }\n        if arr[i] > max_arr[15] {\n        \
    \    max_arr[15] = arr[i];\n            max_k = k - 1;\n        }\n        if\
    \ arr[i] > max_arr[16] {\n            max_arr[16] = arr[i];\n            max_k\
    \ = k - 1;\n        }\n        if arr[i] > max_arr[17] {\n            max_arr[17]\
    \ = arr[i];\n            max_k = k - 1;\n        }\n        if arr[i] > max_arr[18]\
    \ {\n            max_arr[18] = arr[i];\n            max_k = k - 1;\n        }\n\
    \        if arr[i] > max_arr[19] {\n            max_arr[19] = arr[i];\n      \
    \      max_k = k - 1;\n        }\n        if arr[i] > max_arr[20] {\n\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjk4wzoi5.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - unclosed delimiter\n\
    ...\n101 |         if arr[i] > max_arr[20] {\n    |                          \
    \       - this delimiter might not be properly closed...\n102 | \n103 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n118 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpjk4wzoi5.rs:20:5\n\
    \    |\n16  |   fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    | \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20  | /     while i < arr.len() {\n21  | |         if arr[i]\
    \ > max_arr[0] {\n22  | |             max_arr[0] = arr[i];\n23  | |          \
    \   max_k = k - 1;\n...   |\n117 | |     assert_eq!(candidate(vec![1, 2, 3, -23,\
    \ 243, -400, 0], 0), Vec::<isize>::new());\n118 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = -1;\n      \
    \  for (i, val) in arr.iter().enumerate() {\n            if val > max_arr[k] {\n\
    \                max_arr[k] = val;\n                max_idx = i;\n           \
    \ }\n        }\n        max_arr.iter().cloned().take(k).collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsfwy1qzd.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpsfwy1qzd.rs:23:22\n   |\n23 |  \
    \           if val > max_arr[k] {\n   |                      ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpsfwy1qzd.rs:24:17\n   |\n24 |         \
    \        max_arr[k] = val;\n   |                 ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the trait bound `usize: Neg` is\
    \ not satisfied\n  --> /tmp/tmpsfwy1qzd.rs:21:27\n   |\n21 |         let mut max_idx\
    \ = -1;\n   |                           ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfwy1qzd.rs:28:38\n\
    \   |\n28 |         max_arr.iter().cloned().take(k).collect()\n   |          \
    \                            ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |         max_arr.iter().cloned()"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_num = arr[0];\n    let mut max_idx = 1;\n    for\
    \ i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \            max_idx = i;\n        }\n    }\n    vec![max_num; max_idx + 1]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprjuenuwv.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprjuenuwv.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmprjuenuwv.rs:24:23\n   |\n24 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjuenuwv.rs:28:19\n\
    \   |\n28 |     vec![max_num; max_idx + 1]\n   |                   ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |     vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                   +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut res = vec![max];\n\
    \    for i in 1..k {\n        res.push(arr[i]);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpka9sen2r.rs:27:18\n\
    \   |\n27 |         res.push(arr[i]);\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n        }\n    }\n    max_arr.push(max_num);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprc859u3g.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmprc859u3g.rs:21:23\n   |\n21 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmprc859u3g.rs:25:12\n   |\n25 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        max_arr.push(arr[i]);\n    }\n    for i in 0..k {\n        for j\
    \ in 0..k {\n            if arr[i] > arr[j] {\n                max_arr[i] = arr[i];\n\
    \                break;\n            }\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa522e_40.rs:19:22\n\
    \   |\n19 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa522e_40.rs:23:16\n   |\n23 |  \
    \           if arr[i] > arr[j] {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpa522e_40.rs:23:25\n   |\n23 |            \
    \ if arr[i] > arr[j] {\n   |                         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpa522e_40.rs:24:17\n   |\n24 |                 max_arr[i]\
    \ = arr[i];\n   |                 ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpa522e_40.rs:24:30\n   |\n24 |                 max_arr[i] = arr[i];\n\
    \   |                              ^^^^^^ slice indices are"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![arr[0]];\n    for i in 1..k {\n     \
    \   if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n  \
    \  }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jws5q2k.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7jws5q2k.rs:22:12\n\
    \   |\n22 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7jws5q2k.rs:23:26\n   |\n23 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        if\
    \ max_idx < max_k {\n            max_k -= max_idx;\n            max_idx -= max_idx;\n\
    \        }\n        let mut max_value = arr[0];\n        for i in 1..max_idx {\n\
    \            if arr[i] > max_value {\n                max_value = arr[i];\n  \
    \          }\n        }\n        max_arr.push(max_value);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxv0nosi3.rs:21:22\n   |\n\
    21 |         if max_idx < max_k {\n   |                      ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if max_idx < max_k.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxv0nosi3.rs:22:22\n   |\n22 |             max_k -= max_idx;\n\
    \   |                      ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract-assign `usize` from `isize`\n  --> /tmp/tmpxv0nosi3.rs:22:19\n\
    \   |\n22 |             max_k -= max_idx;\n   |                   ^^ no implementation\
    \ for `isize -= usize`\n   |\n   = help: the trait `SubAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max = arr[0];\n    for i in 1..k {\n        if max\
    \ < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1i2kifhg.rs:22:18\n\
    \   |\n22 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1i2kifhg.rs:23:19\n   |\n23 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = 0;\n    for &i in arr {\n        if max_k == 0 {\n\
    \            break;\n        }\n        if i > max_arr.get(max_idx).unwrap() {\n\
    \            max_arr.push(max_arr.get(max_idx).unwrap());\n            max_k -=\
    \ 1;\n        }\n        if max_k == 0 {\n            break;\n        }\n    \
    \    if i < max_arr.get(max_idx).unwrap() {\n            max_arr.push(i as isize);\n\
    \            max_k -= 1;\n        }\n        if max_k == 0 {\n            break;\n\
    \        }\n        if i == max_arr.get(max_idx).unwrap() {\n            max_arr.push(i\
    \ as isize);\n            max_k -= 1;\n        }\n        if max_k == 0 {\n  \
    \          break;\n        }\n        if i > max_arr.get(max_idx).unwrap() {\n\
    \            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n \
    \       if max_k == 0 {\n            break;\n        }\n        if i == max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i > max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i == max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i > max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i == max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i > max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i == max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i > max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if i == max_arr.get(max_idx).unwrap()\
    \ {\n            max_arr.push(i as isize);\n            max_k -= 1;\n        }\n\
    \        if max_k == 0 {\n            break;\n        }\n        if \n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1vtxb4sz.rs:131:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     for &i in arr {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n116 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n131 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n   --> /tmp/tmp1vtxb4sz.rs:116:1\n    |\n116 | }\n    | ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1vtxb4sz.rs:20:9\n\
    \   |\n20 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1vtxb4sz.rs:25:26\n   |\n25 |             max_arr.push(max_arr.get(max_idx).unwrap());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                          |\n   | \
    \                         cyclic type of infinite size\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1vtxb4sz.rs:16:42\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        arr\n    } else {\n\
    \        let mut max = arr[0];\n        let mut max_idx = 1;\n        for i in\
    \ 1..arr.len() {\n            if arr[i] > max {\n                max = arr[i];\n\
    \                max_idx = i;\n            }\n        }\n        vec![max; k -\
    \ max_idx]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo5i03d9b.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo5i03d9b.rs:28:23\n   |\n28 |         vec![max; k - max_idx]\n\
    \   |                       ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo5i03d9b.rs:28:19\n   |\n28 |         vec![max;\
    \ k - max_idx]\n   |                   ^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |         vec![max; (k - max_idx).try_into().unwrap()]\n\
    \   |                   +           +++++++++++++++++++++\n\nerror[E0277]: cannot\
    \ subtract `usize` from `isize`\n  --> /tmp/tmpo5i03d9b.rs:28:21\n   |\n28 | \
    \        vec![max; k - max_idx]\n   |                     ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = -1;\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        \
    \    max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i] >\
    \ max_arr[0] {\n            max_arr[0] = arr[i];\n            max_idx = i;\n \
    \       }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n    \
    \        max_arr[0] = arr[i];\n            max_idx = i;\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0] =\
    \ arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n \
    \       if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n         \
    \   max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_idx = i;\n        }\n \
    \   }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        \
    \    max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i] >\
    \ max_arr[0] {\n            max_arr[0] = arr[i];\n            max_idx = i;\n \
    \       }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n    \
    \        max_arr[0] = arr[i];\n            max_idx = i;\n        }\n    }\n  \
    \  for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0] =\
    \ arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n \
    \       if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n         \
    \   max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_idx = i;\n        }\n \
    \   }\n    for i in 0..k {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        \
    \    max_idx = i;\n        }\n    }\n    for i in 0..k {\n        if arr[i] >\
    \ max_arr[0] {\n            max_arr[0] = arr[i];\n            max_idx = i;\n \
    \       }\n    }\n    for i in 0..\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpchs3mf6y.rs:122:1\n    |\n\
    122 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpchs3mf6y.rs:20:12\n   |\n20 |         if arr[i] >\
    \ max_arr[0] {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpchs3mf6y.rs:21:26\n   |\n21 |             max_arr[0] = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpchs3mf6y.rs:26:12\n   |\n26 |         if arr[i] > max_arr[0] {\n\
    \   |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpchs3mf6y.rs:27:26\n\
    \   |\n27 |             max_arr[0] = arr[i];\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpchs3mf6y.rs:32:12\n\
    \  "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        if\
    \ max_idx < max_k {\n            max_k -= 1;\n        }\n        max_idx -= 1;\n\
    \        if arr.get(max_idx) > max_arr.get(max_k) {\n            max_arr.push(arr.get(max_idx));\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjgye5bnj.rs:21:22\n   |\n\
    21 |         if max_idx < max_k {\n   |                      ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if max_idx < max_k.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `isize`\n   --> /tmp/tmpjgye5bnj.rs:25:43\n\
    \    |\n25  |         if arr.get(max_idx) > max_arr.get(max_k) {\n    |      \
    \                                 --- ^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n    |                                       |\n    | \
    \                                      required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `SliceIndex<[_]>` is not implemented for\
    \ `isize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::slice::<impl [T]>::get`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjgye5bnj.rs:29:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n29 |     max_arr\n   |  \
    \   ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Option<&isize>>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_k = 0;\n        }\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n           \
    \ max_k = 0;\n        }\n        if arr\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu6jwrop8.rs:129:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n129 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpu6jwrop8.rs:114:1\n    |\n113 |         if arr\n\
    \    |         -- this `if` expression has a condition, but no block\n114 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6jwrop8.rs:16:42\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_arr = vec![arr[0]];\n    for i in 1..k {\n     \
    \   if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n  \
    \  }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgyaod2_y.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgyaod2_y.rs:22:12\n\
    \   |\n22 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgyaod2_y.rs:23:26\n   |\n23 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    let mut max_idx = -1;\n    for &i in arr {\n        if i >= max_len\
    \ {\n            max_len = i;\n            max_idx = i;\n        }\n    }\n  \
    \  max_arr.push(max_idx);\n    for i in 0..k {\n        if max_arr[i] < 0 {\n\
    \            max_arr[i] = 0;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe7d8xeb2.rs:20:9\n   |\n\
    20 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe7d8xeb2.rs:28:12\n   |\n28 |  \
    \       if max_arr[i] < 0 {\n   |            ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpe7d8xeb2.rs:29:13\n   |\n29 |            \
    \ max_arr[i] = 0;\n   |             ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    for ele in arr {\n        if max_len < ele {\n            max_len\
    \ = ele;\n        }\n    }\n    for i in 0..max_len {\n        max_arr.push(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpf3fe1g54.rs:25:22\n\
    \   |\n25 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val\
    \ = arr[0];\n    let mut max_val = arr[0];\n    for i in arr.iter() {\n      \
    \  if i > max_val {\n            max_val = i;\n            max_idx = i;\n    \
    \    }\n        if i < min_val {\n            min_val = i;\n            min_idx\
    \ = i;\n        }\n    }\n    for i in 0..k {\n        if max_arr[i] > max_val\
    \ {\n            max_arr[i] = max_val;\n            max_k = i;\n        }\n  \
    \      if min_arr[i] < min_val {\n            min_arr[i] = min_val;\n        \
    \    min_k = i;\n        }\n    }\n    max_arr.extend_from_slice(&arr[max_idx..]);\n\
    \    min_arr.extend_from_slice(&arr[min_idx..]);\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `min_arr` in this scope\n  --> /tmp/tmplhkp7usg.rs:38:12\n\
    \   |\n38 |         if min_arr[i] < min_val {\n   |            ^^^^^^^ help: a\
    \ local variable with a similar name exists: `max_arr`\n\nerror[E0425]: cannot\
    \ find value `min_arr` in this scope\n  --> /tmp/tmplhkp7usg.rs:39:13\n   |\n\
    39 |             min_arr[i] = min_val;\n   |             ^^^^^^^ help: a local\
    \ variable with a similar name exists: `max_arr`\n\nerror[E0425]: cannot find\
    \ value `min_k` in this scope\n  --> /tmp/tmplhkp7usg.rs:40:13\n   |\n40 |   \
    \          min_k = i;\n   |             ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `min_arr` in this scope\n  --> /tmp/tmplhkp7usg.rs:44:5\n\
    \   |\n44 |     min_arr.extend_from_slice(&arr[min_idx..]);\n   |     ^^^^^^^\
    \ help: a local variable with a similar name exists: `max_arr`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplhkp7usg.rs:24:16\n   |\n24 |         if i >\
    \ max_val {\n   |                ^^^^^^^\n   |                |\n   |        \
    \        expected `&isize`, found `isize`\n   |                help: consider\
    \ borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplhkp7usg.rs:25:23\n\
    \   |\n22 |     let mut max_val = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n25 |             max_val = i;\n   |                \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n25 |             max_val = *i;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplhkp7usg.rs:26:23\n   |\n\
    19 |     let mut max_idx = 0;\n   |                       - expected due to this\
    \ value\n...\n26 |             max_idx = i;\n   |                       ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    26 |             max_idx = *i;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplhkp7usg.rs:28:16\n   |\n28 |         if i <\
    \ min_val {\n   |                ^^^^^^^\n   |                |\n   |        \
    \        expected `&isize`, found `isize`\n   |                hel"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max_arr = vec![];\n        let mut max_idx = -1;\n      \
    \  for (i, val) in arr.iter().enumerate() {\n            if max_idx < i {\n  \
    \              max_idx = i;\n            }\n            if val > max_arr[0] {\n\
    \                max_arr = vec![val];\n            }\n            if i == k {\n\
    \                break;\n            }\n            max_arr.push(val);\n     \
    \   }\n        max_arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopi4z9ft.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpopi4z9ft.rs:21:27\n   |\n\
    21 |         let mut max_idx = -1;\n   |                           ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpopi4z9ft.rs:29:21\n   |\n29 |             if i == k {\n   |   \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    29 |             if i == k.try_into().unwrap() {\n   |                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpopi4z9ft.rs:34:9\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n34 |         max_arr\n   |         ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[k]\
    \ {\n            max_arr[k] = arr[i];\n            i += 1;\n        }\n      \
    \  i += 1;\n        if i == arr.len() {\n            break;\n        }\n    }\n\
    \    max_arr.sort_unstable();\n    max_arr.truncate(max_k);\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpmw0tduez.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpmw0tduez.rs:22:13\n\
    \   |\n22 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmw0tduez.rs:31:22\n   |\n31 |     max_arr.truncate(max_k);\n  \
    \ |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n31 |     max_arr.truncate(max_k.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_len\
    \ = k;\n    for i in arr.iter().take(max_len) {\n        if i > max_arr.len()\
    \ {\n            max_arr.push(i);\n        } else {\n            if i < max_arr[0]\
    \ {\n                max_arr.swap(0, i);\n            }\n        }\n    }\n  \
    \  max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4d9bvlgi.rs:19:30\n   |\n\
    19 |     for i in arr.iter().take(max_len) {\n   |                           \
    \   ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n19 |     for\
    \ i in arr.iter().take(max_len.try_into().unwrap()) {\n   |                  \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp4d9bvlgi.rs:20:16\n   |\n20 |         if i > max_arr.len() {\n \
    \  |                ^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4d9bvlgi.rs:24:33\n   |\n24 |              \
    \   max_arr.swap(0, i);\n   |                                 ^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4d9bvlgi.rs:28:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n28 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![vec![0]; k];\n    for i in\
    \ 0..k {\n        for j in 0..arr.len() {\n            if arr[j] > max[j] {\n\
    \                max[j] = arr[j];\n            }\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_l3d7q1.rs:17:33\n   |\n\
    17 |     let mut max = vec![vec![0]; k];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let mut\
    \ max = vec![vec![0]; k.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_l3d7q1.rs:20:25\n\
    \   |\n20 |             if arr[j] > max[j] {\n   |                         ^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_l3d7q1.rs:21:26\n   |\n21 |                 max[j] = arr[j];\n\
    \   |                 ------   ^^^^^^ expected struct `Vec`, found `isize`\n \
    \  |                 |\n   |                 expected due to the type of this\
    \ binding\n   |\n   = note: expected struct `Vec<{integer}>`\n               \
    \ found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_l3d7q1.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max\n   |     ^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr\n    }\n    let mut max = arr[0];\n    let mut max_idx = 1;\n    for i in\
    \ 1..k {\n        if arr[i] > max {\n            max = arr[i];\n            max_idx\
    \ = i;\n        }\n    }\n    let mut res = vec![max];\n    for i in 0..max_idx\
    \ - 1 {\n        res.push(arr[i]);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqyibcuxr.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqyibcuxr.rs:23:12\n\
    \   |\n23 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpqyibcuxr.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpqyibcuxr.rs:30:18\n   |\n30 |         res.push(arr[i]);\n\
    \   |                  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 && max_k > 0 {\n\
    \        if max_idx > max_k {\n            max_k -= max_idx;\n            max_idx\
    \ -= max_idx;\n        }\n        if arr[0] > max_arr[0] {\n            max_arr[0]\
    \ = arr[0];\n            max_k -= 1;\n        }\n        if arr[0] < max_arr[0]\
    \ {\n            max_arr[0] = arr[0];\n            max_k -= 1;\n        }\n  \
    \      if arr[1] > max_arr[1] {\n            max_arr[1] = arr[1];\n          \
    \  max_k -= 1;\n        }\n        if arr[1] < max_arr[1] {\n            max_arr[1]\
    \ = arr[1];\n            max_k -= 1;\n        }\n        if arr[2] > max_arr[2]\
    \ {\n            max_arr[2] = arr[2];\n            max_k -= 1;\n        }\n  \
    \      if arr[2] < max_arr[2] {\n            max_arr[2] = arr[2];\n          \
    \  max_k -= 1;\n        }\n        if arr[3] > max_arr[3] {\n            max_arr[3]\
    \ = arr[3];\n            max_k -= 1;\n        }\n        if arr[3] < max_arr[3]\
    \ {\n            max_arr[3] = arr[3];\n            max_k -= 1;\n        }\n  \
    \      if arr[4] > max_arr[4] {\n            max_arr[4] = arr[4];\n          \
    \  max_k -= 1;\n        }\n        if arr[4] < max_arr[4] {\n            max_arr[4]\
    \ = arr[4];\n            max_k -= 1;\n        }\n        if arr[5] > max_arr[5]\
    \ {\n            max_arr[5] = arr[5];\n            max_k -= 1;\n        }\n  \
    \      if arr[5] < max_arr[5] {\n            max_arr[5] = arr[5];\n          \
    \  max_k -= 1;\n        }\n        if arr[6] > max_arr[6] {\n            max_arr[6]\
    \ = arr[6];\n            max_k -= 1;\n        }\n        if arr[6] < max_arr[6]\
    \ {\n            max_arr[6] = arr[6];\n            max_k -= 1;\n        }\n  \
    \      if arr[7] > max_arr[7] {\n            max_arr[7] = arr[7];\n          \
    \  max_k -= 1;\n        }\n        if arr[7] < max_arr[7] {\n            max_arr[7]\
    \ = arr[7];\n            max_k -= 1;\n        }\n        if arr[8] > max_arr[8]\
    \ {\n            max_arr[8] = arr[8];\n            max_k -= 1;\n        }\n  \
    \      if arr[8] < max_arr[8] {\n            max_arr[8] = arr[8];\n          \
    \  max_k -= 1;\n        }\n        if arr[9] > max_arr[9] {\n            max_arr[9]\
    \ = arr[9];\n            max_k -= 1;\n        }\n        if arr[9] < max_arr[9]\
    \ {\n            max_arr[9] = \n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpc_4corp5.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while max_idx > 0 && max_k > 0 {\n    |                            \
    \        - unclosed delimiter\n...\n101 |         if arr[9] < max_arr[9] {\n \
    \   |                                - this delimiter might not be properly closed...\n\
    102 |             max_arr[9] = \n103 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n118 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n   --> /tmp/tmpc_4corp5.rs:103:1\n    |\n103 | }\n    | ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_4corp5.rs:21:22\n\
    \   |\n21 |         if max_idx > max_k {\n   |                      ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         if max_idx\
    \ > max_k.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc_4corp5.rs:22:22\n   |\n22 |\
    \             max_k -= max_idx;\n   |                      ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot subtract-assign `usize` from `isize`\n\
    \  --> /tmp/tmpc_4corp5.rs:22:19\n   |\n22 |             max_k -= max_idx;\n \
    \  |                   ^^ no implementation for `isize -= usize`\n   |\n   = help:\
    \ the trait `SubAssign<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `SubAssign<Rhs>`:\n             <f32 as\
    \ SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i16 as SubAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n   --> /tmp/tmpc_4corp5.rs:20:5\n    |\n16  |   fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    |             "
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr\n    }\n    let mut max_idx = arr.len();\n    let mut max_value = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_value {\n            max_value =\
    \ arr[i];\n            max_idx = i;\n        }\n    }\n    arr.drain(..max_idx);\n\
    \    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe49zkasr.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpe49zkasr.rs:23:12\n\
    \   |\n23 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpe49zkasr.rs:24:25\n   |\n24 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe49zkasr.rs:25:23\n\
    \   |\n20 |     let mut max_idx = arr.len();\n   |                       ---------\
    \ expected due to this value\n...\n25 |             max_idx = i;\n   |       \
    \                ^ expected `usize`, found `isize`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut min_arr = vec![];\n    let mut min_k = k;\n    let mut i =\
    \ 0;\n    while i < arr.len() {\n        if arr[i] > arr[i + 1] {\n          \
    \  max_arr.push(arr[i]);\n            max_k -= 1;\n        } else {\n        \
    \    min_arr.push(arr[i]);\n            min_k -= 1;\n        }\n        i += 1;\n\
    \    }\n    if max_k == min_k {\n        max_arr.push(max_arr.last());\n    }\n\
    \    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if\
    \ max_k > min_k {\n        min_arr.push(min_arr.last());\n    }\n    if max_k\
    \ > min_k {\n        max_arr.push(min_arr.last());\n    }\n    if max_k > min_k\
    \ {\n        max_arr.push(max_arr.last());\n    }\n    if max_k > min_k {\n  \
    \      max_arr.push(max_arr.last());\n    }\n    if max_k > min_k {\n        max_arr.push(max_arr.last());\n\
    \    }\n    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n\
    \    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if max_k\
    \ > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if max_k > min_k\
    \ {\n        max_arr.push(max_arr.last());\n    }\n    if max_k > min_k {\n  \
    \      max_arr.push(max_arr.last());\n    }\n    if max_k > min_k {\n        max_arr.push(max_arr.last());\n\
    \    }\n    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n\
    \    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if max_k\
    \ > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if max_k > min_k\
    \ {\n        max_arr.push(max_arr.last());\n    }\n    if max_k > min_k {\n  \
    \      max_arr.push(max_arr.last());\n    }\n    if max_k > min_k {\n        max_arr.push(max_arr.last());\n\
    \    }\n    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n\
    \    if max_k > min_k {\n        max_arr.push(max_arr.last());\n    }\n    if\
    \ max_k > min_k {\n        max_arr.push(max_arr.last());\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9m_003_g.rs:118:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    101 |     if max_k > min_k {\n    |                      - this delimiter might\
    \ not be properly closed...\n102 |         max_arr.push(max_arr.last());\n103\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n118\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9m_003_g.rs:33:22\n\
    \   |\n33 |         max_arr.push(max_arr.last());\n   |                      ^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9m_003_g.rs:36:22\n   |\n36 |         max_arr.push(max_arr.last());\n\
    \   |                      ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9m_003_g.rs:39:22\n   |\n39 |\
    \         min_arr.push(min_arr.last());\n   |                      ^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9m_003_g.rs:42:22\n   |\n42 |         max_arr.push(min_arr.last());\n\
    \   |                      ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9m_003_g.rs:45:22\n   |\n45 |\
    \         max_arr.push(max_arr.last());\n   |                      ^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9m_003_g.rs:48:22\n   |\n48 |         max_arr.push(max_arr.last());\n\
    \   |                      ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_idx\
    \ = -1;\n    for i in 0..k {\n        if arr[i] > max_arr[k] {\n            max_arr[k]\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr.push(arr[max_idx]);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp44anm0eh.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_arr[k] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp44anm0eh.rs:20:21\n   |\n20 |         if arr[i] >\
    \ max_arr[k] {\n   |                     ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp44anm0eh.rs:21:13\n   |\n21 |             max_arr[k]\
    \ = arr[i];\n   |             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp44anm0eh.rs:21:26\n   |\n21 |             max_arr[k] = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp44anm0eh.rs:26:18\n   |\n26 |     max_arr.push(arr[max_idx]);\n\
    \   |                  ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ o"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for i in 0..k\
    \ {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n    \
    \        max_idx = i;\n        }\n    }\n    for i in 1..k {\n        if arr[i]\
    \ > max_arr[max_idx] {\n            max_arr[max_idx] = arr[i];\n        }\n  \
    \  }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2xdt4br1.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2xdt4br1.rs:23:12\n  \
    \ |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp2xdt4br1.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp2xdt4br1.rs:29:12\n   |\n29 |         if arr[i]\
    \ > max_arr[max_idx] {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp2xdt4br1.rs:29:21\n   |\n29 |         if arr[i] >\
    \ max_arr[max_idx] {\n   |                     ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `is"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = arr.len();\n    while max_idx > 0 {\n        if\
    \ max_idx < max_k {\n            max_k -= 1;\n        }\n        if max_arr.get(max_idx).unwrap()\
    \ > arr.get(max_idx).unwrap() {\n            max_arr.set(max_idx, arr.get(max_idx).unwrap());\n\
    \            max_idx -= 1;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp85ra7z8f.rs:21:22\n   |\n\
    21 |         if max_idx < max_k {\n   |                      ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if max_idx < max_k.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp85ra7z8f.rs:25:21\n\
    \    |\n25  |             max_arr.set(max_idx, arr.get(max_idx).unwrap());\n \
    \   |                     ^^^\n    |\nhelp: consider wrapping the receiver expression\
    \ with the appropriate type\n    |\n25  |             Pin::new(max_arr).set(max_idx,\
    \ arr.get(max_idx).unwrap());\n    |             +++++++++       +\nhelp: consider\
    \ wrapping the receiver expression with the appropriate type\n    |\n25  |   \
    \          Pin::new(&mut max_arr).set(max_idx, arr.get(max_idx).unwrap());\n \
    \   |             +++++++++++++        +\nhelp: there is an associated function\
    \ with a similar name\n    |\n25  |             max_arr.get(max_idx, arr.get(max_idx).unwrap());\n\
    \    |                     ~~~\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009143
