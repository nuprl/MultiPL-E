language: rs
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ < i {\n                min_value = i;\n                min_idx = i;\n      \
    \      }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsjsmjsl3.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsjsmjsl3.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsjsmjsl3.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n33 |   \
    \              min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    let mut min_even_index_in_arr = 0;\n    let mut min_even_index_in_arr2\
    \ = 0;\n    let mut min_even_index_in_arr3 = 0;\n    let mut min_even_index_in_arr4\
    \ = 0;\n    let mut min_even_index_in_arr5 = 0;\n    let mut min_even_index_in_arr6\
    \ = 0;\n    let mut min_even_index_in_arr7 = 0;\n    let mut min_even_index_in_arr8\
    \ = 0;\n    let mut min_even_index_in_arr9 = 0;\n    let mut min_even_index_in_arr10\
    \ = 0;\n    let mut min_even_index_in_arr11 = 0;\n    let mut min_even_index_in_arr12\
    \ = 0;\n    let mut min_even_index_in_arr13 = 0;\n    let mut min_even_index_in_arr14\
    \ = 0;\n    let mut min_even_index_in_arr15 = 0;\n    let mut min_even_index_in_arr16\
    \ = 0;\n    let mut min_even_index_in_arr17 = 0;\n    let mut min_even_index_in_arr18\
    \ = 0;\n    let mut min_even_index_in_arr19 = 0;\n    let mut min_even_index_in_arr20\
    \ = 0;\n    let mut min_even_index_in_arr21 = 0;\n    let mut min_even_index_in_arr22\
    \ = 0;\n    let mut min_even_index_in_arr23 = 0;\n    let mut min_even_index_in_arr24\
    \ = 0;\n    let mut min_even_index_in_arr25 = 0;\n    let mut min_even_index_in_arr26\
    \ = 0;\n    let mut min_even_index_in_arr27 = 0;\n    let mut min_even_index_in_arr28\
    \ = 0;\n    let mut min_even_index_in_arr29 = 0;\n    let mut min_even_index_in_arr30\
    \ = 0;\n    let mut min_even_index_in_arr31 = 0;\n    let mut min_even_index_in_arr32\
    \ = 0;\n    let mut min_even_index_in_arr33 = 0;\n    let mut min_even_index_in_arr34\
    \ = 0;\n    let mut min_even_index_in_arr35 = 0;\n    let mut min_even_index_in_arr36\
    \ = 0;\n    let mut min_even_index_in_arr37 = 0;\n    let mut min_even_index_in_arr38\
    \ = 0;\n    let mut min_even_index_in_arr39 = 0;\n    let mut min_even_index_in_arr40\
    \ = 0;\n    let mut min_even_index_in_arr41 = 0;\n    let mut min_even_index_in_arr42\
    \ = 0;\n    let mut min_even_index_in_arr43 = 0;\n    let mut min_even_index_in_arr44\
    \ = 0;\n    let mut min_even_index_in_arr45 = 0;\n    let mut min_even\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk50cfrz_.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk50cfrz_.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    let mut min_node = None;\n    for &i in arr {\n        if min_value\
    \ == isize::MAX {\n            min_value = i;\n            min_idx = i;\n    \
    \        min_node = Some(i);\n        } else {\n            if min_value == i\
    \ {\n                min_idx = i;\n            }\n        }\n    }\n    if min_value\
    \ == isize::MAX {\n        vec![]\n    } else {\n        min_node.unwrap()\n \
    \   }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5d9_smif.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5d9_smif.rs:44:9\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |         min_node.unwrap()\n   |         ^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &value in arr {\n  \
    \      if value % 2 == 0 {\n            even_values.push(value);\n           \
    \ if value < smallest_value {\n                smallest_value = value;\n     \
    \           smallest_index = even_values.len() - 1;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    even_values[smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwnxzdy4_.rs:30:9\n   |\n\
    30 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwnxzdy4_.rs:42:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n42 |     even_values[smallest_index]\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    let mut smallest_even_value\
    \ = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value == i {\n                smallest_even_value = i;\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    if smallest_even_value.is_zero() {\n        return Vec::new();\n\
    \    }\n    let mut smallest_even_value_index = even_values.iter().position(|&i|\
    \ i == smallest_even_value);\n    even_values.remove(&mut smallest_even_value_index);\n\
    \    even_values.sort_unstable();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    \n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyqgotk2k.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `is_zero` found for type `isize` in the current scope\n  --> /tmp/tmpyqgotk2k.rs:44:28\n\
    \   |\n44 |     if smallest_even_value.is_zero() {\n   |                     \
    \       ^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyqgotk2k.rs:48:24\n   |\n48 |     even_values.remove(&mut smallest_even_value_index);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found mutable reference\n   |\n   = note:           expected type `usize`\n\
    \           found mutable reference `&mut Option<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyqgotk2k.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_idx = isize::MAX;\n    for &i in arr {\n    \
    \    if i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if even_values.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut min_even_value = even_values[even_values.len() - 1];\n   \
    \ let mut min_idx = even_values.len() - 1;\n    for &i in even_values {\n    \
    \    if i < min_value {\n            min_even_value = i;\n            min_idx\
    \ = i;\n        }\n    }\n    let mut result = Vec::new();\n    for &i in even_values\
    \ {\n        if i == min_value {\n            result.push(min_idx);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_iette3s.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_iette3s.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_iette3s.rs:47:23\n   |\n43 |     let mut min_idx = even_values.len()\
    \ - 1;\n   |                       --------------------- expected due to this\
    \ value\n...\n47 |             min_idx = i;\n   |                       ^ expected\
    \ `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_iette3s.rs:51:9\n\
    \   |\n51 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_iette3s.rs:56:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n56 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    if even_values.len() == 1 {\n        return vec![smallest_value,\
    \ smallest_index];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for &i in even_values {\n        if\
    \ i < smallest_even_value {\n            smallest_even_value = i;\n          \
    \  smallest_even_index = i;\n        }\n    }\n    let mut result = vec![smallest_even_value,\
    \ smallest_even_index];\n    for &i in even_values {\n        if i == smallest_even_value\
    \ {\n            result.push(i);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlaa9x2_.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptlaa9x2_.rs:47:9\n   |\n47 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptlaa9x2_.rs:54:9\n   |\n54 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n\
    \    for i in arr.iter() {\n        if *i % 2 == 0 {\n            if *i < min_value\
    \ {\n                min_value = *i;\n                min_idx = i;\n         \
    \   }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:31:21\n   |\n\
    31 |             if *i < min_value {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |             if *i < min_value.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_dkzjx1.rs:32:29\n   |\n27 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n32 | \
    \                min_value = *i;\n   |                             ^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:33:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n33 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:37:10\n\
    \   |\n37 |     vec![min_value, min_idx]\n   |          ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n37 |     vec![min_value.try_into().unwrap(),\
    \ min_idx]\n   |                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = i;\n        }\n        if i == smallest_value\
    \ {\n            smallest_value = i;\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return Vec::new();\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmp7p0p434h.rs:96:5\n\
    \   |\n96 |     even\n   |     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7p0p434h.rs:30:9\n   |\n30 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = isize::MAX;\n    let mut min_even_index\
    \ = isize::MAX;\n    let mut min_even_indexes = Vec::new();\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if min_even_value < i {\n          \
    \      min_even_value = i;\n                min_even_index = i;\n            }\n\
    \        } else {\n            if min_even_index < i {\n                min_even_index\
    \ = i;\n                min_even_indexes.push(min_even_index);\n            }\n\
    \        }\n    }\n    if min_even_indexes.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if min_even_indexes.len() == 1 {\n        return min_even_indexes.iter().cloned().collect();\n\
    \    }\n    if min_even_indexes.len() > 1 {\n        let mut min_even_indexes\
    \ = min_even_indexes.iter().cloned().collect::<Vec<_>>();\n        let mut min_even_index\
    \ = min_even_indexes.iter().cloned().min_by_key(|&i| i).unwrap();\n        let\
    \ mut min_even_value = min_even_indexes.iter().cloned().min_by_key(|&i| i).unwrap();\n\
    \        let mut min_even_indexes = min_even_indexes.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_even_index = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).unwrap();\n        let mut min_even_value = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).unwrap();\n        let mut min_even_indexes = min_even_indexes.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_even_index = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).unwrap();\n        let mut min_even_value = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).unwrap();\n        let mut min_even_indexes = min_even_indexes.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_even_index = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).unwrap();\n        let mut min_even_value = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).unwrap();\n        let mut min_even_indexes = min_even_indexes.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_even_index = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7frt0agh.rs:76:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n49 |     if min_even_indexes.len()\
    \ > 1 {\n   |                                   - this delimiter might not be\
    \ properly closed...\n...\n64 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n76 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp7frt0agh.rs:64:1\n\
    \   |\n64 | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp7frt0agh.rs:63:86\n\
    \   |\n63 |         let mut min_even_index = min_even_indexes.iter().cloned().min_by_key(|&i|\
    \ i).\n   |                                                                  \
    \                    ^ help: add `;` here\n64 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7frt0agh.rs:30:9\n   |\n30 |   \
    \  for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7frt0agh.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = isize::MAX;\n    let mut smallest_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n        }\n        if i < smallest_value\
    \ {\n            smallest_value = i;\n            smallest_index = i;\n      \
    \  }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values[0];\n    for &i in even_values {\n        if i < smallest_even_value\
    \ {\n            smallest_even_value = i;\n            smallest_even_index = i;\n\
    \        }\n    }\n    even_values.remove(&smallest_even_value);\n    even_values.remove(&smallest_even_index);\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.sort();\n\
    \    even_values.dedup();\n    \n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpua4ij35p.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpua4ij35p.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpua4ij35p.rs:50:24\n   |\n50 |     even_values.remove(&smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpua4ij35p.rs:51:24\n   |\n51 |\
    \     even_values.remove(&smallest_even_index);\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpua4ij35p.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index\
    \ = -1;\n    let mut smallest_index = -1;\n    let mut smallest_value = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n                smallest_even_index = i;\n\
    \                smallest_even_value = arr[i];\n            }\n            if\
    \ smallest_index == -1 || smallest_index > i {\n                smallest_index\
    \ = i;\n                smallest_value = arr[i];\n            }\n        }\n \
    \   }\n    if smallest_even_index == -1 {\n        return vec![];\n    }\n   \
    \ let mut result = vec![];\n    if smallest_index == -1 {\n        result.push(smallest_even_value);\n\
    \    } else {\n        result.push(smallest_value);\n        result.push(smallest_even_index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi6tek92h.rs:34:39\n   |\n\
    28 |     let mut smallest_even_index = -1;\n   |                             \
    \      -- expected due to this value\n...\n34 |                 smallest_even_index\
    \ = i;\n   |                                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_even_index\
    \ = *i;\n   |                                       +\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmpi6tek92h.rs:33:65\n   |\n33 |         \
    \    if smallest_even_index == -1 || smallest_even_index > i {\n   |         \
    \                                                        ^ no implementation for\
    \ `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpi6tek92h.rs:35:39\n   |\n35 |        \
    \         smallest_even_value = arr[i];\n   |                                \
    \       ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi6tek92h.rs:38:34\n   |\n29 |\
    \     let mut smallest_index = -1;\n   |                              -- expected\
    \ due to this value\n...\n38 |                 smallest_index = i;\n   |     \
    \                             ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n38 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmpi6tek92"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n            if min_val\
    \ < i {\n                min_val = i;\n                min_idx = i;\n        \
    \    }\n        }\n    }\n    if min_val == i32::MAX {\n        return Vec::new();\n\
    \    }\n    let mut result = Vec::new();\n    for i in arr.iter().cloned() {\n\
    \        if i == min_val {\n            result.push(min_idx);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp54jxanxo.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n31 |             if min_val < i.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp54jxanxo.rs:32:27\n   |\n27 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n32 |   \
    \              min_val = i;\n   |                           ^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp54jxanxo.rs:42:17\n\
    \   |\n42 |         if i == min_val {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n42 |         if i == min_val.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_idx = 0;\n    for &i in arr {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < min_value {\n\
    \                min_value = i;\n                min_idx = i;\n            }\n\
    \        }\n    }\n    if even_values.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut min_value = even_values[0];\n    let mut min_idx = 0;\n  \
    \  for &i in even_values {\n        if i < min_value {\n            min_value\
    \ = i;\n            min_idx = i;\n        }\n    }\n    even_values.remove(min_idx);\n\
    \    even_values\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptvxgaf8d.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptvxgaf8d.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptvxgaf8d.rs:50:24\n   |\n50 |     even_values.remove(min_idx);\n\
    \   |                        ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n50 |     even_values.remove(min_idx.try_into().unwrap());\n   | \
    \                              ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    let mut min_even_index_in_arr = -1;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            if min_even_index == -1 || min_even_index > i\
    \ {\n                min_even_value = i;\n                min_even_index = i;\n\
    \                min_even_index_in_arr = i;\n            }\n        } else {\n\
    \            if min_even_index != -1 && min_even_index == i {\n              \
    \  min_even_index_in_arr += 1;\n            }\n        }\n    }\n    if min_even_index\
    \ == -1 {\n        return Vec::new();\n    }\n    let mut even_values = Vec::new();\n\
    \    for i in min_even_index_in_arr..arr.len() {\n        if arr[i] % 2 == 0 {\n\
    \            even_values.push(arr[i]);\n        }\n    }\n    return even_values;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1qzhvm2f.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1qzhvm2f.rs:47:37\n   |\n47 |     for i in min_even_index_in_arr..arr.len()\
    \ {\n   |                                     ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n \
    \ --> /tmp/tmp1qzhvm2f.rs:48:12\n   |\n48 |         if arr[i] % 2 == 0 {\n   |\
    \            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1qzhvm2f.rs:49:30\n\
    \   |\n49 |             even_values.push(arr[i]);\n   |                      \
    \        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &value in arr {\n  \
    \      if value % 2 == 0 {\n            even_values.push(value);\n           \
    \ if value < smallest_value {\n                smallest_value = value;\n     \
    \           smallest_index = even_values.len() - 1;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return Vec::new();\n    }\n \
    \   let mut smallest_even_value = even_values[smallest_index];\n    let mut smallest_even_index\
    \ = smallest_index;\n    for &value in even_values {\n        if value == smallest_even_value\
    \ {\n            smallest_even_index = even_values.iter().position(|&x| x == value);\n\
    \        }\n    }\n    even_values.remove(&smallest_even_value);\n    even_values.insert(smallest_even_index,\
    \ smallest_value);\n    even_values\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvk8oz7j4.rs:30:9\n   |\n\
    30 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvk8oz7j4.rs:44:9\n   |\n44 |     for &value\
    \ in even_values {\n   |         ^^^^^^    ----------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvk8oz7j4.rs:46:35\n   |\n43 |     let mut smallest_even_index\
    \ = smallest_index;\n   |                                   -------------- expected\
    \ due to this value\n...\n46 |             smallest_even_index = even_values.iter().position(|&x|\
    \ x == value);\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvk8oz7j4.rs:49:24\n   |\n49 |     even_values.remove(&smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = 0;\n    let mut min_even_index_in_arr = 0;\n    let mut even_values = Vec::new();\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == min_even_value {\n            min_even_index = i;\n\
    \            min_even_index_in_arr = i;\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return Vec::new();\n    }\n    if min_even_index == min_even_index_in_arr\
    \ {\n        return Vec::new();\n    }\n    let mut min_even_value = min_even_value;\n\
    \    let mut min_even_index = min_even_index;\n    let mut min_even_index_in_arr\
    \ = min_even_index_in_arr;\n    let mut even_values = even_values;\n    for &i\
    \ in even_values {\n        if i == min_even_value {\n            min_even_index\
    \ = i;\n            min_even_index_in_arr = i;\n        }\n    }\n    let mut\
    \ even_values = even_values;\n    for &i in even_values {\n        if i == min_even_value\
    \ {\n            min_even_index = i;\n            min_even_index_in_arr = i;\n\
    \        }\n    }\n    let mut even_values = even_values;\n    for &i in even_values\
    \ {\n        if i == min_even_value {\n            min_even_index = i;\n     \
    \       min_even_index_in_arr = i;\n        }\n    }\n    let mut even_values\
    \ = even_values;\n    for &i in even_values {\n        if i == min_even_value\
    \ {\n            min_even_index = i;\n            min_even_index_in_arr = i;\n\
    \        }\n    }\n    let mut even_values = even_values;\n    for &i in even_values\
    \ {\n        if i == min_even_value {\n            min_even_index = i;\n     \
    \       min_even_index_in_arr = i;\n        }\n    }\n    let mut even_values\
    \ = even_values;\n    for &i in even_values {\n        if i == min_even_value\
    \ {\n            min_even_index = i;\n            min_even_index_in_arr = i;\n\
    \        }\n    }\n    let mut even_values = even_values;\n    for &i in even_values\
    \ {\n        if i == min_even_value {\n            min_even_index = i;\n     \
    \       min_even_index_in_arr = i;\n        }\n    }\n    let mut even_values\
    \ = even_values;\n    for &i in even_values {\n        if i == min_even_value\
    \ {\n            min_even_index = i;\n            min_even_index_in_arr = i;\n\
    \        }\n    }\n    let mut even_values = even_values;\n    for &i in even_values\
    \ {\n        if i == min_even_value {\n            min_even_index = i;\n\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmplix578yg.rs:122:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n106 |     for &i in even_values\
    \ {\n    |                           - unclosed delimiter\n107 |         if i\
    \ == min_even_value {\n    |                                - this delimiter might\
    \ not be properly closed...\n...\n110 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n122 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplix578yg.rs:31:9\n   |\n31 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplix578yg.rs:50:9\n\
    \   |\n50 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplix578yg.rs:57:9\n   |\n57 |   \
    \  for &i in even_values {\n   |         ^^    ----------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplix578yg.rs:64:9\n   |\n64 |     for &i in even_values\
    \ {\n   |         ^^    ----------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplix"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_value\
    \ == isize {\n                min_value = i;\n                min_idx = i;\n \
    \           } else {\n                if min_value > i {\n                   \
    \ min_value = i;\n                    min_idx = i;\n                }\n      \
    \      }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpbdyg7qbq.rs:31:29\n\
    \   |\n31 |             if min_value == isize {\n   |                        \
    \     ^^^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdyg7qbq.rs:32:29\n\
    \   |\n27 |     let mut min_value = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n32 |                 min_value =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n32 |                 min_value\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbdyg7qbq.rs:33:27\n   |\n28 |     let mut min_idx = 0;\n   |  \
    \                     - expected due to this value\n...\n33 |                \
    \ min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbdyg7qbq.rs:35:32\n   |\n35 |                 if min_value > i\
    \ {\n   |                                ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 if\
    \ min_value > *i {\n   |                                +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbdyg7qbq.rs:36:33\n   |\n27 |     let mut min_value = isize::MAX;\n\
    \   |                         ---------- expected due to this value\n...\n36 |\
    \                     min_value = i;\n   |                                 ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    36 |                     min_value = *i;\n   |                               \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdyg7qbq.rs:37:31\n   |\n\
    28 |     let mut min_idx = 0;\n   |                       - expected due to this\
    \ value\n...\n37 |                     min_idx = i;\n   |                    \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |                     min_"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value: isize = 0;\n    let mut min_even_index:\
    \ usize = 0;\n    let mut min_value: isize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvlcaytmc.rs:83:17\n   |\n\
    83 |     let mut min_\n   |                 ^ help: add `;` here\n84 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvlcaytmc.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < min_value {\n                min_value = i;\n                min_index =\
    \ i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n     \
    \   return vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    let mut smallest_value = even_values[0];\n    let mut smallest_index\
    \ = even_values[0];\n    for i in even_values.iter().rev() {\n        if i < min_value\
    \ {\n            min_value = i;\n            smallest_value = i;\n           \
    \ smallest_index = i;\n        }\n    }\n    vec![smallest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfuwowphm.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfuwowphm.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfuwowphm.rs:35:29\n\
    \   |\n29 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n35 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_index\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfuwowphm.rs:43:21\n   |\n43 |         return vec![even_values[0]];\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the type\n   |\n43 |         return vec![*even_values[0]];\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfuwowphm.rs:48:16\n\
    \   |\n48 |         if i < min_value {\n   |                ^^^^^^^^^ expected\
    \ `&&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfuwowphm.rs:49:25\n\
    \   |\n28 |     let mut min_value = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n49 |             min_value = i;\n\
    \   |                         ^ expected `isize`, found `&&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n49 |             min_value = **i;\n\
    \   |                         ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfuwowphm.rs:54:10\n\
    \   |\n54 |     vec![s"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbq2rnlvu.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbq2rnlvu.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbq2rnlvu.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0615]: attempted to take value of method `dedup`\
    \ on type `Vec<&isize>`\n  --> /tmp/tmpbq2rnlvu.rs:94:17\n   |\n94 |     even_values.dedup\n\
    \   |                 ^^^^^ method, not a field\n   |\nhelp: use parentheses to\
    \ call the method\n   |\n94 |     even_values.dedup()\n   |                  \
    \    ++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0615.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_val >\
    \ i {\n                min_val = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if min_val == i32::MAX {\n        return Vec::new();\n\
    \    }\n    let mut result = Vec::new();\n    for i in arr.iter() {\n        if\
    \ i == min_val {\n            result.push(min_idx);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqx6vrxqf.rs:31:26\n   |\n\
    31 |             if min_val > i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqx6vrxqf.rs:32:27\n\
    \   |\n27 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n32 |                 min_val = i;\n   |   \
    \                        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqx6vrxqf.rs:33:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n33 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqx6vrxqf.rs:42:17\n   |\n42 |         if i == min_val {\n\
    \   |                 ^^^^^^^ expected `isize`, found `i32`\n\nerror[E0277]: can't\
    \ compare `&isize` with `i32`\n  --> /tmp/tmpqx6vrxqf.rs:42:14\n   |\n42 |   \
    \      if i == min_val {\n   |              ^^ no implementation for `&isize ==\
    \ i32`\n   |\n   = help: the trait `PartialEq<i32>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = vec![0];\n    let mut smallest_index = vec![0];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if smallest_value[0]\
    \ < i {\n                smallest_value = vec![i];\n                smallest_index\
    \ = vec![i];\n            }\n        } else {\n            if smallest_value[0]\
    \ < i {\n                smallest_value = vec![i];\n                smallest_index\
    \ = vec![i];\n            }\n        }\n    }\n    if even_values.len() == 0 {\n\
    \        return vec![];\n    }\n    if even_values.len() == 1 {\n        return\
    \ vec![smallest_value[0], smallest_index[0]];\n    }\n    let mut smallest_value_2\
    \ = vec![0];\n    let mut smallest_index_2 = vec![0];\n    for i in even_values.iter()\
    \ {\n        if i % 2 == 0 {\n            if smallest_value[0] < i {\n       \
    \         smallest_value_2 = vec![i];\n                smallest_index_2 = vec![i];\n\
    \            }\n        } else {\n            if smallest_value[0] < i {\n   \
    \             smallest_value_2 = vec![i];\n                smallest_index_2 =\
    \ vec![i];\n            }\n        }\n    }\n    if smallest_value_2 == smallest_value\
    \ {\n        return vec![smallest_value[0], smallest_index[0]];\n    }\n    if\
    \ smallest_value_2 == smallest_value_2 {\n        return vec![smallest_value_2[0],\
    \ smallest_index_2[0]];\n    }\n    if smallest_value_2 < smallest_value {\n \
    \       return vec![smallest_value[0], smallest_index[0]];\n    }\n    if smallest_value_2\
    \ < smallest_value_2 {\n        return vec![smallest_value_2[0], smallest_index_2[0]];\n\
    \    }\n    if smallest_value < smallest_value_2 {\n        return vec![smallest_value[0],\
    \ smallest_index_2[0]];\n    }\n    if smallest_value < smallest_value {\n   \
    \     return vec![smallest_value_2[0], smallest_index_2[0]];\n    }\n    return\
    \ vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp132lxo25.rs:33:34\n\
    \   |\n33 |             if smallest_value[0] < i {\n   |                     \
    \             ^ no implementation for `isize < &isize` and `isize > &isize`\n\
    \   |\n   = help: the trait `PartialOrd<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp132lxo25.rs:34:39\n\
    \   |\n34 |                 smallest_value = vec![i];\n   |                  \
    \                     ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |                 smallest_value = vec![*i];\n\
    \   |                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp132lxo25.rs:35:39\n   |\n35 |                 smallest_index =\
    \ vec![i];\n   |                                       ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |        \
    \         smallest_index = vec![*i];\n   |                                   \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp132lxo25.rs:38:36\n  \
    \ |\n38 |             if smallest_value[0] < i {\n   |                       \
    \             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n38 |             if smallest_value[0] < *i {\n   |       \
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp132lxo25.rs:39:39\n\
    \   |\n39 |                 smallest_value = vec![i];\n   |                  \
    \                     ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n39 |                 smallest_value = vec![*i];\n\
    \   |                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp132lxo25.rs:40:39\n   |\n40 |                 smallest_index =\
    \ vec![i];\n   |                                       ^ expected"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    even_values.remove(smallest_even_index);\n\
    \    even_values.insert(0, smallest_even_value);\n    even_values\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0r7z2xrr.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0r7z2xrr.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0r7z2xrr.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp0r7z2xrr.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0r7z2xrr.rs:46:20\n   |\n\
    46 |             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0r7z2xrr.rs:52:24\n   |\n52 |     even_values.remove(smallest_even_index);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0r7z2xrr.rs:54:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            min_value = i;\n  \
    \          min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwkccgq7.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    even_values.sort_unstable_by_key(|&i| i);\n\
    \    even_values.into_iter().take(1).collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx71d5omc.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 =\
    \ 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7\
    \ = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10\
    \ = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13\
    \ = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16\
    \ = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19\
    \ = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22\
    \ = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25\
    \ = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28\
    \ = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31\
    \ = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34\
    \ = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37\
    \ = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40\
    \ = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43\
    \ = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46\
    \ = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49\
    \ = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52\
    \ = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55\
    \ = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58\
    \ = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61\
    \ = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1kwtwr9w.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1kwtwr9w.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value >\
    \ i {\n                min_value = i;\n                min_idx = i;\n        \
    \    }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt2o8s61d.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut smallest_value_iter = smallest_value.iter();\n\
    \    let mut smallest_index_iter = smallest_index.iter();\n    let mut smallest_value\
    \ = smallest_value_iter.next();\n    let mut smallest_index = smallest_index_iter.next();\n\
    \    for i in even_values.iter() {\n        if smallest_value.is_none() {\n  \
    \          smallest_value = i;\n            smallest_index = i;\n        } else\
    \ {\n            if i < smallest_value {\n                smallest_value = i;\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    smallest_value.unwrap()\n\
    \        .iter()\n        .enumerate()\n        .map(|(i, _)| {\n            smallest_index\n\
    \                .iter()\n                .enumerate()\n                .map(|(_,\
    \ j)| {\n                    vec![smallest_value, i]\n                })\n   \
    \     })\n        .collect()\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpji5ajay9.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpji5ajay9.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpji5ajay9.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpji5ajay9.rs:48:30\n\
    \   |\n44 |     let mut smallest_value = smallest_value_iter.next();\n   |   \
    \                           -------------------------- expected due to this value\n\
    ...\n48 |             smallest_value = i;\n   |                              ^\
    \ expected enum `Option`, found `&&isize`\n   |\n   = note:   expected enum `Option<&_>`\n\
    \           found reference `&&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n48 |             smallest_value = Some(i);\n   |                      \
    \        +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpji5ajay9.rs:49:30\n\
    \   |\n45 |     let mut smallest_index = smallest_index_iter.next();\n   |   \
    \                           -------------------------- expected due to this value\n\
    ...\n49 |             smallest_index = i;\n   |                              ^\
    \ expected enum `Option`, found `&&isize`\n   |\n   = note:   expected en"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    let mut even_values = Vec::new();\n    for &i in arr {\n  \
    \      if i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    let mut smallest_value = min_value;\n    let mut smallest_idx = min_idx;\n\
    \    for &i in even_values {\n        if i < smallest_value {\n            smallest_value\
    \ = i;\n            smallest_idx = i;\n        }\n    }\n    even_values.remove(&smallest_idx);\n\
    \    even_values.sort();\n    even_values\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9w48pfe5.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9w48pfe5.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9w48pfe5.rs:50:24\n   |\n50 |     even_values.remove(&smallest_idx);\n\
    \   |                        ^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n\
    \    for i in arr.iter() {\n        if *i % 2 == 0 {\n            if *i < min_value\
    \ {\n                min_value = *i;\n                min_idx = i;\n         \
    \   }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:31:21\n   |\n\
    31 |             if *i < min_value {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |             if *i < min_value.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_dkzjx1.rs:32:29\n   |\n27 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n32 | \
    \                min_value = *i;\n   |                             ^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:33:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n33 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:37:10\n\
    \   |\n37 |     vec![min_value, min_idx]\n   |          ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n37 |     vec![min_value.try_into().unwrap(),\
    \ min_idx]\n   |                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_val = even_values[0];\n    let\
    \ mut smallest_even_val_pos = 0;\n    for &i in even_values {\n        if i %\
    \ 2 == 0 {\n            if i < smallest_even_val {\n                smallest_even_val\
    \ = i;\n                smallest_even_val_pos = i;\n            }\n        }\n\
    \    }\n    let mut smallest_even_val_pos_index = smallest_even_val_pos;\n   \
    \ for &i in even_values {\n        if i == smallest_even_val {\n            smallest_even_val_pos_index\
    \ += i;\n        }\n    }\n    even_values.retain(|&i| i != smallest_even_val);\n\
    \    even_values.retain(|&i| i != smallest_even_val_pos);\n    even_values.retain(|&i|\
    \ i != smallest_even_val_pos_index);\n    even_values.retain(|&i| i != smallest_index);\n\
    \    even_values\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfbry7p4i.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfbry7p4i.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfbry7p4i.rs:53:9\n   |\n53 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    let mut current_index =\
    \ 0;\n    let mut current_value = isize::MAX;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i as isize);\n            if current_value\
    \ < i {\n                current_value = i;\n                current_index = current_index\
    \ + 1;\n            }\n        }\n        if current_value == i {\n          \
    \  current_index = current_index + 1;\n        }\n        if current_value < i\
    \ {\n            smallest_value = i;\n            smallest_index = current_index;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_even_value =\
    \ even_values[0];\n        let mut smallest_even_index = even_values.iter().position(|&i|\
    \ i % 2 == 0).unwrap();\n        for &i in even_values {\n            if i % 2\
    \ == 0 {\n                if smallest_even_value < i {\n                    smallest_even_value\
    \ = i;\n                    smallest_even_index = current_index;\n           \
    \     }\n            }\n            if i == smallest_even_value {\n          \
    \      smallest_even_index = current_index;\n            }\n            current_index\
    \ = current_index + 1;\n        }\n        return vec![smallest_even_value];\n\
    \    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpybxtz5dr.rs:32:9\n   |\n\
    32 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpybxtz5dr.rs:57:13\n   |\n57 |         for &i in even_values {\n\
    \   |             ^^    ----------- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = isize::MAX;\n\
    \    let mut smallest_even_index = isize::MAX;\n    for i in even_values.iter()\
    \ {\n        if i < smallest_even_value {\n            smallest_even_value = i;\n\
    \            smallest_even_index = i;\n        }\n    }\n    even_values.remove(smallest_even_index);\n\
    \    even_values.sort();\n    even_values\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqaisb4vb.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqaisb4vb.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqaisb4vb.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqaisb4vb.rs:45:16\n\
    \   |\n45 |         if i < smallest_even_value {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqaisb4vb.rs:46:35\n\
    \   |\n42 |     let mut smallest_even_value = isize::MAX;\n   |              \
    \                     ---------- expected due to this value\n...\n46 |       \
    \      smallest_even_value = i;\n   |                                   ^ expected\
    \ `isize`, found `&&isize`\n   |\nhelp: consider dereferencing the borrow\n  \
    \ |\n46 |             smallest_even_value = **i;\n   |                       \
    \            ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqaisb4vb.rs:47:35\n\
    \   |\n43 |     let mut smallest_even_index = isize::MAX;\n   |              \
    \                     ---------- expected due to this value\n...\n47 |       \
    \      smallest_even"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    for i in 1..arr.len() {\n        if arr[i] % 2 == 0 {\n         \
    \   if min_even_value < arr[i] {\n                min_even_value = arr[i];\n \
    \               min_even_index = i;\n            }\n        }\n    }\n    vec![min_even_index,\
    \ min_even_value]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptp9hi3ha.rs:28:30\n\
    \   |\n28 |     let mut min_even_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptp9hi3ha.rs:37:10\n   |\n37 |     vec![min_even_index,\
    \ min_even_value]\n   |          ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |     vec![min_even_index.try_into().unwrap(), min_even_value]\n\
    \   |                        ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_value =\
    \ i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mu\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpopkumgqb.rs:78:11\n   |\n\
    78 |     let mu\n   |           ^ help: add `;` here\n79 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpopkumgqb.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    let mut min_idx2 = isize::MAX;\n    let mut min_idx3 = isize::MAX;\n\
    \    let mut min_idx4 = isize::MAX;\n    let mut min_idx5 = isize::MAX;\n    let\
    \ mut min_idx6 = isize::MAX;\n    let mut min_idx7 = isize::MAX;\n    let mut\
    \ min_idx8 = isize::MAX;\n    let mut min_idx9 = isize::MAX;\n    let mut min_idx10\
    \ = isize::MAX;\n    let mut min_idx11 = isize::MAX;\n    let mut min_idx12 =\
    \ isize::MAX;\n    let mut min_idx13 = isize::MAX;\n    let mut min_idx14 = isize::MAX;\n\
    \    let mut min_idx15 = isize::MAX;\n    let mut min_idx16 = isize::MAX;\n  \
    \  let mut min_idx17 = isize::MAX;\n    let mut min_idx18 = isize::MAX;\n    let\
    \ mut min_idx19 = isize::MAX;\n    let mut min_idx20 = isize::MAX;\n    let mut\
    \ min_idx21 = isize::MAX;\n    let mut min_idx22 = isize::MAX;\n    let mut min_idx23\
    \ = isize::MAX;\n    let mut min_idx24 = isize::MAX;\n    let mut min_idx25 =\
    \ isize::MAX;\n    let mut min_idx26 = isize::MAX;\n    let mut min_idx27 = isize::MAX;\n\
    \    let mut min_idx28 = isize::MAX;\n    let mut min_idx29 = isize::MAX;\n  \
    \  let mut min_idx30 = isize::MAX;\n    let mut min_idx31 = isize::MAX;\n    let\
    \ mut min_idx32 = isize::MAX;\n    let mut min_idx33 = isize::MAX;\n    let mut\
    \ min_idx34 = isize::MAX;\n    let mut min_idx35 = isize::MAX;\n    let mut min_idx36\
    \ = isize::MAX;\n    let mut min_idx37 = isize::MAX;\n    let mut min_idx38 =\
    \ isize::MAX;\n    let mut min_idx39 = isize::MAX;\n    let mut min_idx40 = \n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpixasgepo.rs:68:1\n\
    \   |\n68 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut min_value =\
    \ isize::MAX;\n    let mut min_index = isize::MAX;\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ min_value {\n                min_value = i;\n                min_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    even_values.sort();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpemln1ocw.rs:96:1\n   |\n96\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpemln1ocw.rs:33:20\n\
    \   |\n33 |             if i < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpemln1ocw.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpemln1ocw.rs:35:29\n\
    \   |\n29 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n35 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_index\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpemln1ocw.rs:95:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n95 |     even_values.\n   |     ^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            }\n            min_value =\
    \ i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4128_318.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4128_318.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = 0;\n   |                       - expected due to this value\n\
    ...\n32 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4128_318.rs:34:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |             min_value = *i;\n   |                         +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n        }\n      \
    \  if even_values.len() == 1 {\n            smallest_value.push(even_values.iter().min().unwrap());\n\
    \            smallest_index.push(even_values.iter().min_index().unwrap());\n \
    \       }\n    }\n    smallest_value\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `min_index` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpea9hf1jh.rs:36:52\n   |\n36 |          \
    \   smallest_index.push(even_values.iter().min_index().unwrap());\n   |      \
    \                                              ^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ &isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpea9hf1jh.rs:39:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n39\
    \ |     smallest_value\n   |     ^^^^^^^^^^^^^^ expected `isize`, found `&&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n\
    \    if even_values.len() > 1 {\n        let mut smallest_value = even_values[0];\n\
    \        let mut smallest_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i < smallest_value {\n                smallest_value = i;\n\
    \                smallest_index = i;\n            }\n        }\n        return\
    \ vec![smallest_value, smallest_index];\n    }\n    return vec![];\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcxtjsq8w.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpcxtjsq8w.rs:34:37\n   |\n34 |                 smallest_value.push(smallest_value[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpcxtjsq8w.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcxtjsq8w.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcxtjsq8w.rs:49:20\n   |\n49 |\
    \             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcxtjsq8w.rs:54:21\n   |\n54 |         return vec![smallest_value, smallest_index];\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n54 |         return vec!["
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    let mut even_values = Vec::new();\n    for &i in arr {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n            if i < min_val {\n   \
    \             min_val = i;\n                min_idx = i;\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n \
    \   }\n    let mut min_even_value = even_values[0];\n    let mut min_even_idx\
    \ = -1;\n    for &i in even_values {\n        if i == min_even_value {\n     \
    \       min_even_idx = i;\n        }\n    }\n    let mut result = Vec::new();\n\
    \    if min_even_idx != -1 {\n        result.push(min_even_value);\n        result.push(min_even_idx);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps1qfxq2m.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps1qfxq2m.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<i32>`\n   |     \
    \    |\n   |         expected `i32`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `i`\n   |\n   = note:   expected type `i32`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps1qfxq2m.rs:54:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n54\
    \ |     result\n   |     ^^^^^^ expected `isize`, found `i32`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<i32>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value ==\
    \ isize::MAX {\n                min_value = i;\n                min_idx = i;\n\
    \            } else {\n                if i < min_value {\n                  \
    \  min_value = i;\n                    min_idx = i;\n                }\n     \
    \       }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprxw39hz7.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    even_values.sort_unstable_by_key(|&i| i);\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_value\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `even_value` in this scope\n  --> /tmp/tmp2tzc_a3k.rs:94:5\n\
    \   |\n94 |     even_value\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `even_values`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2tzc_a3k.rs:30:9\n   |\n30 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4\
    \ = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7\
    \ = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10\
    \ = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13\
    \ = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16\
    \ = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19\
    \ = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22\
    \ = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25\
    \ = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28\
    \ = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31\
    \ = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34\
    \ = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37\
    \ = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40\
    \ = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43\
    \ = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46\
    \ = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49\
    \ = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52\
    \ = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55\
    \ = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58\
    \ = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61\
    \ = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63 = 0;\n    let mu\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqrofg6x1.rs:91:11\n   |\n\
    91 |     let mu\n   |           ^ help: add `;` here\n92 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrofg6x1.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = isize::MAX;\n    for &i in arr {\n  \
    \      if i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_index = i;\n        \
    \    }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    let mut smallest_value = even_values[0];\n    let mut smallest_index\
    \ = even_values[0];\n    for i in even_values.iter().rev() {\n        if i ==\
    \ smallest_value {\n            smallest_index = i;\n        }\n        if i <\
    \ smallest_value {\n            smallest_value = i;\n            smallest_index\
    \ = i;\n        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjsz9v91u.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjsz9v91u.rs:46:30\n   |\n43 |     let mut smallest_index = even_values[0];\n\
    \   |                              -------------- expected due to this value\n\
    ...\n46 |             smallest_index = i;\n   |                              ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n46 |             smallest_index = *i;\n   |                           \
    \   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpjsz9v91u.rs:45:14\n\
    \   |\n45 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjsz9v91u.rs:48:16\n   |\n48 |         if i < smallest_value {\n   |\
    \                ^^^^^^^^^^^^^^\n   |                |\n   |                expected\
    \ `&isize`, found `isize`\n   |                help: consider borrowing here:\
    \ `&smallest_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjsz9v91u.rs:49:30\n\
    \   |\n42 |     let mut smallest_value = even_values[0];\n   |               \
    \               -------------- expected due to this value\n...\n49 |         \
    \    smallest_value = i;\n   |                              ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n49 |  \
    \           smallest_value = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjsz9"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            if smallest_value\
    \ < i {\n                smallest_value = i;\n                smallest_index =\
    \ i;\n            }\n        }\n    }\n    smallest_index\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprm70_y8_.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprm70_y8_.rs:37:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     smallest_index\n   |     ^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut min_value =\
    \ isize::MAX;\n    let mut min_index = -1;\n    for i in arr.iter() {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_index = i;\n        \
    \    }\n        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n\
    \    }\n    let mut smallest_value = even_values[0];\n    let mut smallest_index\
    \ = min_index;\n    for i in even_values.iter() {\n        if i < smallest_value\
    \ {\n            smallest_value = i;\n            smallest_index = i;\n      \
    \  }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplod4gesq.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplod4gesq.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplod4gesq.rs:35:29\n\
    \   |\n29 |     let mut min_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n35 |                 min_index = i;\n   |          \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_index = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplod4gesq.rs:45:16\n\
    \   |\n45 |         if i < smallest_value {\n   |                ^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplod4gesq.rs:47:30\n   |\n43 |     let mut smallest_index = min_index;\n\
    \   |                              --------- expected due to this value\n...\n\
    47 |             smallest_index = i;\n   |                              ^ expected\
    \ integer, found `&&isize`\n   |\nhelp: consider dereferencing the borrow\n  \
    \ |\n47 |             smallest_index = **i;\n   |                            \
    \  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplod4gesq.rs:50:10\n   |\n\
    50 |     vec![smallest_value, smallest_index]\n   |          ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    50 |     vec![*smallest_value, smallest_index]\n   |   "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    let mut mut_arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr\
    \ = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr\
    \ = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr\
    \ = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr\
    \ = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr\
    \ = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ mut_arr = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr\
    \ = mut_arr.iter().cloned().collect::<Vec<_>>();\n    let mut mut_arr = mut_arr.iter().cloned\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7ezlsols.rs:51:44\n   |\n\
    51 |     let mut mut_arr = mut_arr.iter().cloned\n   |                       \
    \                     ^ help: add `;` here\n52 | }\n   | - unexpected token\n\n\
    error[E0615]: attempted to take value of method `cloned` on type `std::slice::Iter<'_,\
    \ isize>`\n  --> /tmp/tmp7ezlsols.rs:51:38\n   |\n51 |     let mut mut_arr = mut_arr.iter().cloned\n\
    \   |                                      ^^^^^^ method, not a field\n   |\n\
    help: use parentheses to call the method\n   |\n51 |     let mut mut_arr = mut_arr.iter().cloned()\n\
    \   |                                            ++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7ezlsols.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0615.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_value =\
    \ i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let\
    \ mut min_value = i32::MAX;\n    let mut min_value = i32::MAX;\n    let mut min_value\
    \ = i32::MAX;\n    let mu\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpopkumgqb.rs:78:11\n   |\n\
    78 |     let mu\n   |           ^ help: add `;` here\n79 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpopkumgqb.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    for i in arr.iter().rev() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n        }\n      \
    \  if i == smallest_value {\n            smallest_index = arr.len() - i;\n   \
    \     }\n        if i == smallest_value {\n            smallest_value = i;\n \
    \       }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    even_values.sort_unstable_by_key(|&x| x);\n    even_values.reverse();\n\
    \    even_values.next().unwrap()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpagz9nyq3.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpagz9nyq3.rs:35:42\n   |\n35 |             smallest_index = arr.len()\
    \ - i;\n   |                                          ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `&isize` from `usize`\n  --> /tmp/tmpagz9nyq3.rs:35:40\n\
    \   |\n35 |             smallest_index = arr.len() - i;\n   |                \
    \                        ^ no implementation for `usize - &isize`\n   |\n   =\
    \ help: the trait `Sub<&isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpagz9nyq3.rs:38:30\n   |\n27 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n38 |             smallest_value = i;\n   |                              ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n38 |             smallest_value = *i;\n   |                           \
    \   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpagz9nyq3.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = hel"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = isize::MAX;\n    let mut min_even_index\
    \ = isize::MAX;\n    let mut min_even = isize::MAX;\n    let mut min_even_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    let mut even_index = Vec::new();\n\
    \    let mut even = isize::MAX;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mut even_index = 0;\n\
    \    let mut even_value = 0;\n    let mut even_index = 0;\n    let mut even_value\
    \ = 0;\n    let mut even_index = 0;\n    let mut even_value = 0;\n    let mut\
    \ even_index = 0;\n    let mut even_value = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd95jtoee.rs:96:11\n   |\n\
    96 |     let mu\n   |           ^ help: add `;` here\n97 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd95jtoee.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    even_values.sort_unstable();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_value\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `even_value` in this scope\n  --> /tmp/tmpvoyj39yj.rs:94:5\n\
    \   |\n94 |     even_value\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `even_values`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvoyj39yj.rs:33:20\n   |\n33 |             if i < smallest_value {\n\
    \   |                    ^^^^^^^^^^^^^^\n   |                    |\n   |     \
    \               expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&smallest_value`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvoyj39yj.rs:34:34\n   |\n28 |     let mut smallest_value = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    34 |                 smallest_value = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n34 |                 smallest_value = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvoyj39yj.rs:35:34\n\
    \   |\n29 |     let mut smallest_index = isize::MAX;\n   |                   \
    \           ---------- expected due to this value\n...\n35 |                 smallest_index\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value\
    \ < i {\n                min_value = i;\n                min_idx = i;\n      \
    \      }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm3p2qoaa.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value: isize = 0;\n    let mut min_even_index:\
    \ usize = 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n   \
    \     if i % 2 == 0 {\n            even_values.push(i);\n            if i == min_even_value\
    \ {\n                min_even_index = even_values.len() - 1;\n            }\n\
    \        } else {\n            min_even_value = i;\n            min_even_index\
    \ = even_values.len() - 1;\n        }\n    }\n    if even_values.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut smallest_even_value = even_values[min_even_index];\n\
    \    let mut smallest_even_index = min_even_index;\n    for &i in even_values\
    \ {\n        if i == smallest_even_value {\n            smallest_even_index =\
    \ i;\n        }\n    }\n    let mut result = vec![];\n    for &i in even_values\
    \ {\n        if i == smallest_even_value {\n            result.push(smallest_even_index);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpalemmg_8.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpalemmg_8.rs:46:9\n   |\n46 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare `usize`\
    \ with `isize`\n  --> /tmp/tmpalemmg_8.rs:47:14\n   |\n47 |         if i == smallest_even_value\
    \ {\n   |              ^^ no implementation for `usize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpalemmg_8.rs:52:9\n   |\n52 | \
    \    for &i in even_values {\n   |         ^^    ----------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpalemmg_8.rs:57:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n57 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_value == i {\n\
    \                min_idx = i;\n            }\n        } else {\n            min_value\
    \ = i;\n            min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxflrthfu.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n        if i\
    \ % 2 == 0 {\n            even_values.push(i);\n            if min_value > i {\n\
    \                min_value = i;\n                min_idx = i;\n            }\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut even_values_iter = even_values.iter().cloned().\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpftsv47ea.rs:64:1\n   |\n64\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpftsv47ea.rs:63:60\n\
    \   |\n63 |     let mut even_values_iter = even_values.iter().cloned().\n   |\
    \                                                            ^ help: add `;` here\n\
    64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpftsv47ea.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmpftsv47ea.rs:46:40\n\
    \   |\n46 |     let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                        ^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpftsv47ea.rs:47:36\n   |\n47 |     let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                    ^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpftsv47ea.rs:49:40\n   |\n49 |     let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                        ^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpftsv47ea.rs:50:36\n   |\n50 |     let mut min_idx_iter = min_idx.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                    ^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpftsv47ea.rs:52:40\n   |\n52 |     let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                        ^^^^ method not found in"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_value_and_index = vec![];\n\
    \    for i in even_values.iter() {\n        if i == smallest_value {\n       \
    \     smallest_value_and_index.push((smallest_value, i));\n        }\n    }\n\
    \    if smallest_value_and_index.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_value_and_index_iter = smallest_value_and_index.iter();\n\
    \    let mut smallest_value_and_index_iter2 = smallest_value_and_index_iter.clone();\n\
    \    let mut smallest_value_and_index_iter3 = smallest_value_and_index_iter2.clone();\n\
    \    let mut smallest_value_and_index_iter4 = smallest_value_and_index_iter3.clone();\n\
    \    let mut smallest_value_and_index_iter5 = smallest_value_and_index_iter4.clone();\n\
    \    let mut smallest_value_and_index_iter6 = smallest_value_and_index_iter5.clone();\n\
    \    let mut smallest_value_and_index_iter7 = smallest_value_and_index_iter6.clone();\n\
    \    let mut smallest_value_and_index_iter8 = smallest_value_and_index_iter7.clone();\n\
    \    let mut smallest_value_and_index_iter9 = smallest_value_and_index_iter8.clone();\n\
    \    let mut smallest_value_and_index_iter10 = smallest_value_and_index_iter9.clone();\n\
    \    let mut smallest_value_and_index_iter11 = smallest_value_and_index_iter10.clone();\n\
    \    let mut smallest_value_and_index_iter12 = smallest_value_and_index_iter11.clone();\n\
    \    let mut smallest_value_and_index_iter13 = smallest_value_and_index_iter12.clone();\n\
    \    let mut smallest_value_and_index_iter14 = smallest_value_and_index_iter13.clone();\n\
    \    let mut smallest_value_and_index_iter15 = smallest_value_and_index_iter14.clone();\n\
    \    let mut smallest_value_and_index_iter16 = smallest_value_and_index_iter15.clone();\n\
    \    let mut smallest_value_and_index_iter17 = smallest_value_and_index_iter16.clone();\n\
    \    let mut smallest_value_and_index_iter18 = smallest_value_and_index_iter17.clone();\n\
    \    let mut smallest_value_and_index_iter19 = smallest_value_\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1ru6pfm3.rs:69:62\n   |\n\
    69 |     let mut smallest_value_and_index_iter19 = smallest_value_\n   |     \
    \                                                         ^ help: add `;` here\n\
    70 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `smallest_value_`\
    \ in this scope\n  --> /tmp/tmp1ru6pfm3.rs:69:47\n   |\n69 |     let mut smallest_value_and_index_iter19\
    \ = smallest_value_\n   |                                               ^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `smallest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1ru6pfm3.rs:30:9\n   |\n30 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp1ru6pfm3.rs:44:14\n   |\n44 |         if i == smallest_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1ru6pfm3.rs:26:30\n   |\n26 |\
    \ fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                   \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index\
    \ = -1;\n    let mut smallest_even_index_in_arr = 0;\n    let mut smallest_even_index_in_arr2\
    \ = 0;\n    let mut smallest_even_index_in_arr3 = 0;\n    let mut smallest_even_index_in_arr4\
    \ = 0;\n    let mut smallest_even_index_in_arr5 = 0;\n    let mut smallest_even_index_in_arr6\
    \ = 0;\n    let mut smallest_even_index_in_arr7 = 0;\n    let mut smallest_even_index_in_arr8\
    \ = 0;\n    let mut smallest_even_index_in_arr9 = 0;\n    let mut smallest_even_index_in_arr10\
    \ = 0;\n    let mut smallest_even_index_in_arr11 = 0;\n    let mut smallest_even_index_in_arr12\
    \ = 0;\n    let mut smallest_even_index_in_arr13 = 0;\n    let mut smallest_even_index_in_arr14\
    \ = 0;\n    let mut smallest_even_index_in_arr15 = 0;\n    let mut smallest_even_index_in_arr16\
    \ = 0;\n    let mut smallest_even_index_in_arr17 = 0;\n    let mut smallest_even_index_in_arr18\
    \ = 0;\n    let mut smallest_even_index_in_arr19 = 0;\n    let mut smallest_even_index_in_arr20\
    \ = 0;\n    let mut smallest_even_index_in_arr21 = 0;\n    let mut smallest_even_index_in_arr22\
    \ = 0;\n    let mut smallest_even_index_in_arr23 = 0;\n    let mut smallest_even_index_in_arr24\
    \ = 0;\n    let mut smallest_even_index_in_arr25 = 0;\n    let mut smallest_even_index_in_arr26\
    \ = 0;\n    let mut smallest_even_index_in_arr27 = 0;\n    let mut smallest_even_index_in_arr28\
    \ = 0;\n    let mut smallest_even_index_in_arr29 = 0;\n    let mut smallest_even_index_in_arr30\
    \ = 0;\n    let mut smallest_even_index_in_arr31 = 0;\n    let mut smallest_even_index_in_arr32\
    \ = 0;\n    let mut smallest_even_index_in_arr33 = 0;\n    let mut smallest_even_index_in_arr34\
    \ = 0;\n    let mut smallest_even_index_in_arr35 = 0;\n    let mut smallest_even_index_in_arr36\
    \ = 0;\n    let mut smallest_even_index_in_arr37 = 0;\n    let mut smallest_even_index_in_arr38\
    \ = 0;\n    let mut smallest_even_index_in_arr39 = 0;\n    let mut smallest_even_index_in_arr40\
    \ = 0;\n    let mut smallest_even_index_in_arr41 = 0;\n    let mut smallest_even\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_xk00gdy.rs:70:26\n   |\n\
    70 |     let mut smallest_even\n   |                          ^ help: add `;`\
    \ here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_xk00gdy.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    let mut min_even_index_in_arr = 0;\n    let mut min_even_index_in_arr2\
    \ = 0;\n    let mut min_even_index_in_arr3 = 0;\n    let mut min_even_index_in_arr4\
    \ = 0;\n    let mut min_even_index_in_arr5 = 0;\n    let mut min_even_index_in_arr6\
    \ = 0;\n    let mut min_even_index_in_arr7 = 0;\n    let mut min_even_index_in_arr8\
    \ = 0;\n    let mut min_even_index_in_arr9 = 0;\n    let mut min_even_index_in_arr10\
    \ = 0;\n    let mut min_even_index_in_arr11 = 0;\n    let mut min_even_index_in_arr12\
    \ = 0;\n    let mut min_even_index_in_arr13 = 0;\n    let mut min_even_index_in_arr14\
    \ = 0;\n    let mut min_even_index_in_arr15 = 0;\n    let mut min_even_index_in_arr16\
    \ = 0;\n    let mut min_even_index_in_arr17 = 0;\n    let mut min_even_index_in_arr18\
    \ = 0;\n    let mut min_even_index_in_arr19 = 0;\n    let mut min_even_index_in_arr20\
    \ = 0;\n    let mut min_even_index_in_arr21 = 0;\n    let mut min_even_index_in_arr22\
    \ = 0;\n    let mut min_even_index_in_arr23 = 0;\n    let mut min_even_index_in_arr24\
    \ = 0;\n    let mut min_even_index_in_arr25 = 0;\n    let mut min_even_index_in_arr26\
    \ = 0;\n    let mut min_even_index_in_arr27 = 0;\n    let mut min_even_index_in_arr28\
    \ = 0;\n    let mut min_even_index_in_arr29 = 0;\n    let mut min_even_index_in_arr30\
    \ = 0;\n    let mut min_even_index_in_arr31 = 0;\n    let mut min_even_index_in_arr32\
    \ = 0;\n    let mut min_even_index_in_arr33 = 0;\n    let mut min_even_index_in_arr34\
    \ = 0;\n    let mut min_even_index_in_arr35 = 0;\n    let mut min_even_index_in_arr36\
    \ = 0;\n    let mut min_even_index_in_arr37 = 0;\n    let mut min_even_index_in_arr38\
    \ = 0;\n    let mut min_even_index_in_arr39 = 0;\n    let mut min_even_index_in_arr40\
    \ = 0;\n    let mut min_even_index_in_arr41 = 0;\n    let mut min_even_index_in_arr42\
    \ = 0;\n    let mut min_even_index_in_arr43 = 0;\n    let mut min_even_index_in_arr44\
    \ = 0;\n    let mut min_even_index_in_arr45 = 0;\n    let mut min_even\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk50cfrz_.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk50cfrz_.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    let mut smallest_even_value\
    \ = 0;\n    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n           \
    \ even_values.push(i);\n            if smallest_even_value\n                <\
    \ i\n                && smallest_even_value\n                < even_values.iter().min().unwrap()\n\
    \            {\n                smallest_even_value = i;\n                smallest_value\
    \ = even_values.iter().min().unwrap();\n                smallest_index = even_values.iter().min_index().unwrap();\n\
    \            }\n        } else {\n            even_values.clear();\n        }\n\
    \    }\n    even_values\n        .into_iter()\n        .filter(|&x| x % 2 == 0)\n\
    \        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpj8dpukqy.rs:35:17\n\
    \   |\n35 |                 < i\n   |                 ^ no implementation for\
    \ `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpj8dpukqy.rs:37:19\n   |\n37 |                 < even_values.iter().min().unwrap()\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n37 |       \
    \          < **even_values.iter().min().unwrap()\n   |                   ++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj8dpukqy.rs:39:39\n   |\n30 |  \
    \   let mut smallest_even_value = 0;\n   |                                   -\
    \ expected due to this value\n...\n39 |                 smallest_even_value =\
    \ i;\n   |                                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n39 |                 smallest_even_value\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj8dpukqy.rs:40:34\n   |\n28 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n40 |                 smallest_value = even_values.iter().min().unwrap();\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&&isize`\n   |\nhelp: consider dereferencing the borrow\n  \
    \ |\n40 |                 smallest_value = **even_values.iter().min().unwrap();\n\
    \   |                                  ++\n\nerror[E0599]: no method named `min_index`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpj8dpukqy.rs:41:53\n\
    \   |\n41 |                 smallest_index = even_values.iter().min_index().unwrap"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_value_with_even_value = vec![];\n    for i in even_values.iter()\
    \ {\n        if i < smallest_value.len() {\n            smallest_value_with_even_value.push(smallest_value[i]);\n\
    \        }\n    }\n    if smallest_value_with_even_value.len() == 0 {\n      \
    \  return vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![smallest_value_with_even_value[0]];\n\
    \    }\n    let mut smallest_value_with_even_value_index = vec![];\n    for i\
    \ in even_values.iter() {\n        if i < smallest_value.len() {\n           \
    \ smallest_value_with_even_value_index.push(smallest_index[i]);\n        }\n \
    \   }\n    if smallest_value_with_even_value_index.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 2 {\n        return vec![smallest_value_with_even_value[0],\
    \ smallest_value_with_even_value[1]];\n    }\n    let mut smallest_value_with_even_value_index_and_smallest_index\
    \ = vec![];\n    for i in even_values.iter() {\n        if i < smallest_value.len()\
    \ {\n            smallest_value_with_even_value_index_and_smallest_index.push(smallest_index[i],\
    \ smallest_value_with_even_value_index[i]);\n        }\n    }\n    if smallest_value_with_even_value_index_and_smallest_index.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 3 {\n   \
    \     return vec![smallest_value_with_even_value[0], smallest_value_with_even_value[1],\
    \ smallest_value_with_even_value[2]];\n    }\n    let mut smallest_value_with_even_value_index_and_smallest_index_and_smallest_value\
    \ = vec![];\n    for i in even_values.iter() {\n        if i < smallest_value.len()\
    \ {\n            smallest_value_with_even_value_index_and_smallest_index_and_smallest_value.push(smallest_index[i],\
    \ smallest_value_with_even_value_index[i], smallest_value[i]);\n        }\n  \
    \  }\n    if smallest_value_with_even_value_index_and_smallest_index_and_smallest_value.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 4 {\n   \
    \     return \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpw7pgkr1f.rs:101:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n87  |     if even_values.len()\
    \ == 4 {\n    |                               - this delimiter might not be properly\
    \ closed...\n88  |         return \n89  | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n101 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw7pgkr1f.rs:33:20\n   |\n33 |             if i < smallest_value.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpw7pgkr1f.rs:34:37\n\
    \   |\n34 |                 smallest_value.push(smallest_value[i]);\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpw7pgkr1f.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw7pgkr1f.rs:44:16\n\
    \   |\n44 |         if i < smallest_value.len() {\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be\
    \ indexed by `&&isize`\n  --> /tmp/tmpw7pgkr1f.rs:45:49\n   |\n45 |          \
    \   smallest_value_with_even_value.push(smallest_value[i]);\n   |            \
    \                        "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_val <\
    \ i {\n                min_val = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if min_val == i32::MAX {\n        return Vec::new();\n\
    \    }\n    let mut ret = Vec::new();\n    for i in arr.iter() {\n        if i\
    \ == min_val {\n            ret.push(min_idx);\n        }\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0dtro3wv.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dtro3wv.rs:32:27\n\
    \   |\n27 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n32 |                 min_val = i;\n   |   \
    \                        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0dtro3wv.rs:33:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n33 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0dtro3wv.rs:42:17\n   |\n42 |         if i == min_val {\n\
    \   |                 ^^^^^^^ expected `isize`, found `i32`\n\nerror[E0277]: can't\
    \ compare `&isize` with `i32`\n  --> /tmp/tmp0dtro3wv.rs:42:14\n   |\n42 |   \
    \      if i == min_val {\n   |              ^^ no implementation for `&isize ==\
    \ i32`\n   |\n   = help: the trait `PartialEq<i32>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    vec![smallest_value, smallest_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpznhk_46g.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpznhk_46g.rs:46:20\n   |\n46 |             if i < smallest_even_value\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&isize`, found `isize`\n   |              \
    \      help: consider borrowing here: `&smallest_even_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpznhk_46g.rs:47:39\n   |\n42 |     let mut smallest_even_value\
    \ = even_values[0];\n   |                                   -------------- expected\
    \ due to this value\n...\n47 |                 smallest_even_value = i;\n   |\
    \                                       ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n47 |                 smallest_even_value\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpznhk_46g.rs:48:39\n   |\n43 |     let mut smallest_even_index\
    \ = even_values[0];\n   |                                   -------------- expected\
    \ due to this value\n...\n48 |                 smallest_even_index = i;\n   |\
    \                                       ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = *i;\n   |                                       +\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_value_and_index = vec![];\n\
    \    for &i in even_values {\n        if i == smallest_value {\n            smallest_value_and_index.push((i,\
    \ &smallest_index));\n        }\n    }\n    smallest_value_and_index.sort_by_key(|&(_,\
    \ index)| index);\n    smallest_value_and_index.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ld86x3_.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9ld86x3_.rs:43:9\n   |\n43 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `(_, &isize)`\n    -->\
    \ /tmp/tmp9ld86x3_.rs:49:46\n     |\n49   |     smallest_value_and_index.iter().cloned().collect()\n\
    \     |                                              ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=(_, &isize)>`\n     |\n     =\
    \ help: the trait `FromIterator<(_, &isize)>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if *i % 2 == 0 {\n            if *i < min_value\
    \ {\n                min_value = *i;\n                min_idx = i;\n         \
    \   }\n        }\n    }\n    if min_idx == -1 {\n        vec![]\n    } else {\n\
    \        vec![min_value, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kwwe1_9.rs:31:21\n   |\n\
    31 |             if *i < min_value {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |             if *i < min_value.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5kwwe1_9.rs:32:29\n   |\n27 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n32 | \
    \                min_value = *i;\n   |                             ^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5kwwe1_9.rs:33:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n33 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5kwwe1_9.rs:40:14\n\
    \   |\n40 |         vec![min_value, min_idx]\n   |              ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n40 |         vec![min_value.try_into().unwrap(),\
    \ min_idx]\n   |                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values.iter().position(|&i| i == smallest_value);\n\
    \    if smallest_even_index == even_values.len() - 1 {\n        smallest_even_index\
    \ = even_values.len() - 1;\n    }\n    even_values.swap(0, smallest_even_index);\n\
    \    even_values\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2gemmhel.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2gemmhel.rs:44:31\n   |\n44 |     if smallest_even_index == even_values.len()\
    \ - 1 {\n   |                               ^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n44 |     if smallest_even_index == Some(even_values.len() - 1) {\n   |\
    \                               +++++                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2gemmhel.rs:45:31\n   |\n43 |     let mut smallest_even_index\
    \ = even_values.iter().position(|&i| i == smallest_value);\n   |             \
    \                      ----------------------------------------------------- expected\
    \ due to this value\n44 |     if smallest_even_index == even_values.len() - 1\
    \ {\n45 |         smallest_even_index = even_values.len() - 1;\n   |         \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n45 |         smallest_even_index\
    \ = Some(even_values.len() - 1);\n   |                               +++++   \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2gemmhel.rs:47:25\n\
    \   |\n47 |     even_values.swap(0, smallest_even_index);\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    let mut min_idx = arr.iter().enumerate().min_by(|&(i, _)| {\n        if min_value\
    \ % 2 == 0 {\n            min_value = i;\n            min_idx = i;\n         \
    \   true\n        } else {\n            false\n        }\n    });\n    min_idx\n\
    \        .1\n        .iter()\n        .enumerate()\n        .min_by(|&(i, _)|\
    \ {\n            if i % 2 == 0 {\n                min_value = i;\n           \
    \     true\n            } else {\n                false\n            }\n     \
    \   })\n        .1\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n\
    \  --> /tmp/tmpccik49g3.rs:29:46\n   |\n29 |     let mut min_idx = arr.iter().enumerate().min_by(|&(i,\
    \ _)| {\n   |                                              ^^^^^^ --------- takes\
    \ 1 argument\n   |                                              |\n   |      \
    \                                        expected closure that takes 2 arguments\n\
    \nerror[E0609]: no field `1` on type `Option<(usize, &isize)>`\n  --> /tmp/tmpccik49g3.rs:39:10\n\
    \   |\n39 |         .1\n   |          ^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0593, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n            if min_val\
    \ < i {\n                min_val = i;\n                min_idx = i;\n        \
    \    }\n        }\n    }\n    if min_val == i32::MAX {\n        return vec![];\n\
    \    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphs75el7s.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n31 |             if min_val < i.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphs75el7s.rs:32:27\n   |\n27 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n32 |   \
    \              min_val = i;\n   |                           ^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphs75el7s.rs:40:10\n\
    \   |\n40 |     vec![min_val, min_idx]\n   |          ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n40 |     vec![min_val.try_into().unwrap(),\
    \ min_idx]\n   |                 ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n          \
    \  if min_value == isize {\n                min_value = i;\n                min_idx\
    \ = i;\n            } else {\n                if min_value > i {\n           \
    \         min_value = i;\n                    min_idx = i;\n                }\n\
    \            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpseftmugx.rs:31:29\n\
    \   |\n31 |             if min_value == isize {\n   |                        \
    \     ^^^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpseftmugx.rs:32:29\n\
    \   |\n27 |     let mut min_value = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n32 |                 min_value =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n32 |                 min_value\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpseftmugx.rs:33:27\n   |\n28 |     let mut min_idx = isize::MAX;\n\
    \   |                       ---------- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpseftmugx.rs:35:32\n   |\n35 |              \
    \   if min_value > i {\n   |                                ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               if min_value > *i {\n   |                                +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpseftmugx.rs:36:33\n   |\n27 |  \
    \   let mut min_value = isize::MAX;\n   |                         ---------- expected\
    \ due to this value\n...\n36 |                     min_value = i;\n   |      \
    \                           ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n36 |                     min_value = *i;\n \
    \  |                                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpseftmugx.rs:37:31\n   |\n28 |     let mut min_idx = isize::MAX;\n  \
    \ |                       ---------- expected due to this value\n...\n37 |   \
    \                  min_idx = i;\n   |                               ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borro"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < min_value {\n                min_value = i;\n                min_index =\
    \ i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n     \
    \   return Vec::new();\n    }\n    let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index_iter = min_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = even_values_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_index = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value_iter.iter().cloned().collect::<Vec<_>>();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsy3ggrsq.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsy3ggrsq.rs:33:20\n \
    \  |\n33 |             if i < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsy3ggrsq.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsy3ggrsq.rs:35:29\n\
    \   |\n29 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n35 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_index\
    \ = *i;\n   |                             +\n\nerror[E0599]: no method named `iter`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpsy3ggrsq.rs:43:40\n\
    \   |\n43 |     let mut min_value_iter = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                        ^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpsy3ggrsq.rs:44:40\n   |\n44 |     let mut min_index_iter = min_index.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                        ^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsy3ggrsq.rs:26:30\n   |\n26 |\
    \ fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                   \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp911by8ww.rs:38:21\n   |\n\
    38 |     vec![min_value, min_idx]\n   |                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n38 |     vec![min_value, min_idx.try_into().unwrap()]\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    even_values.remove(smallest_even_index);\n\
    \    even_values.sort();\n    even_values.insert(0, smallest_even_value);\n  \
    \  even_values\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmaw44q4b.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmaw44q4b.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmaw44q4b.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpmaw44q4b.rs:45:14\n   |\n45 |         if i % 2 == 0 {\n   |   \
    \         - ^ - {integer}\n   |            |\n   |            &&isize\n   |\n\
    help: `%` can be used on `isize`, you can dereference `i`\n   |\n45 |        \
    \ if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmaw44q4b.rs:46:20\n   |\n46 |             if i < smallest_even_value\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmaw44q4b.rs:52:24\n\
    \   |\n52 |     even_values.remove(smallest_even_index);\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmaw44q4b.rs:55:5\n   |\n26 | fn pluck(arr: "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu4pf66y3.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu4pf66y3.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu4pf66y3.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu4pf66y3.rs:26:30\n  \
    \ |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----           \
    \          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            } else {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        }\n   \
    \ }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprd54qfmz.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprd54qfmz.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n32 |                 min_idx = i;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 min_idx = *i;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprd54qfmz.rs:34:29\n\
    \   |\n27 |     let mut min_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n34 |                 min_value = i;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |                 min_value = *i;\n   | \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprd54qfmz.rs:35:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n35 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_val = even_values[0];\n\
    \    let mut smallest_even_val = smallest_even_val % smallest_index;\n    for\
    \ i in even_values.iter().rev() {\n        if i % 2 == 0 {\n            if i <\
    \ smallest_even_val {\n                smallest_even_val = i;\n            }\n\
    \        }\n    }\n    even_values.remove(smallest_even_val);\n    even_values.sort();\n\
    \    even_values.reverse();\n    even_values.insert(0, smallest_even_val);\n \
    \   even_values\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdbjl5it0.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdbjl5it0.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdbjl5it0.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpdbjl5it0.rs:45:14\n   |\n45 |         if i % 2 == 0 {\n   |   \
    \         - ^ - {integer}\n   |            |\n   |            &&isize\n   |\n\
    help: `%` can be used on `isize`, you can dereference `i`\n   |\n45 |        \
    \ if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdbjl5it0.rs:46:20\n   |\n46 |             if i < smallest_even_val {\n\
    \   |                    ^^^^^^^^^^^^^^^^^ expected `&&isize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdbjl5it0.rs:47:37\n   |\n43 |\
    \     let mut smallest_even_val = smallest_even_val % smallest_index;\n   |  \
    \                               ---------------------------------- expected due\
    \ to this value\n...\n47 |                 smallest_even_val = i;\n   |      \
    \                               ^ expected `isize`, found `&&isize`\n   |\nhel"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut min_value =\
    \ isize::MAX;\n    let mut min_idx = isize::MAX;\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ min_value {\n                min_value = i;\n                min_idx = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    even_values.sort_unstable_by(|a, b| a.cmp(b));\n    let\
    \ mut even_values_iter = even_values.iter();\n    let mut even_values_idx = 0;\n\
    \    let mut even_values_value = even_values_iter.next().unwrap();\n    let mut\
    \ even_values_idx = even_values_idx;\n    let mut even_values_value = even_values_value;\n\
    \    let mut even_values_idx = even_values_idx;\n    let mut even_values_value\
    \ = even_values_value;\n    let mut even_values_idx = even_values_idx;\n    let\
    \ mut even_values_value = even_values_value;\n    let mut even_values_idx = even_values_idx;\n\
    \    let mut even_values_value = even_values_value;\n    let mut even_values_idx\
    \ = even_values_idx;\n    let mut even_values_value = even_values_value;\n   \
    \ let mut even_values_idx = even_values_idx;\n    let mut even_values_value =\
    \ even_values_value;\n    let mut even_values_idx = even_values_idx;\n    let\
    \ mut even_values_value = even_values_value;\n    let mut even_values_idx = even_values_idx;\n\
    \    let mut even_values_value = even_values_value;\n    let mut even_values_idx\
    \ = even_values_idx;\n    let mut even_values_value = even_values_value;\n   \
    \ let mut even_values_idx = even_values_idx;\n    let mut even_values_value =\
    \ even_values_value;\n    let mut even_values_idx = even_values_idx;\n    let\
    \ mut even_values_value = even_values_value;\n    let mut even_values_idx = even_values_idx;\n\
    \    let mut even_values_value = even_values_value;\n    let mut even_values_idx\
    \ = even_values_idx;\n    let mut even_values_value = even_values_value;\n   \
    \ let mut even_values_idx = even_values_idx;\n    let mut even_values_value =\
    \ even_values_value;\n    let mut even_values_idx = even_values_idx;\n    let\
    \ mut even_values_value = even_values_value;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqk08metj.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqk08metj.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqk08metj.rs:35:27\n\
    \   |\n29 |     let mut min_idx = isize::MAX;\n   |                       ----------\
    \ expected due to this value\n...\n35 |                 min_idx = i;\n   |   \
    \                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |                 min_idx = *i;\n   |   \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqk08metj.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index\
    \ = -1;\n    let mut smallest_even_index_in_arr = 0;\n    let mut smallest_even_index_in_arr2\
    \ = 0;\n    let mut smallest_even_index_in_arr3 = 0;\n    let mut smallest_even_index_in_arr4\
    \ = 0;\n    let mut smallest_even_index_in_arr5 = 0;\n    let mut smallest_even_index_in_arr6\
    \ = 0;\n    let mut smallest_even_index_in_arr7 = 0;\n    let mut smallest_even_index_in_arr8\
    \ = 0;\n    let mut smallest_even_index_in_arr9 = 0;\n    let mut smallest_even_index_in_arr10\
    \ = 0;\n    let mut smallest_even_index_in_arr11 = 0;\n    let mut smallest_even_index_in_arr12\
    \ = 0;\n    let mut smallest_even_index_in_arr13 = 0;\n    let mut smallest_even_index_in_arr14\
    \ = 0;\n    let mut smallest_even_index_in_arr15 = 0;\n    let mut smallest_even_index_in_arr16\
    \ = 0;\n    let mut smallest_even_index_in_arr17 = 0;\n    let mut smallest_even_index_in_arr18\
    \ = 0;\n    let mut smallest_even_index_in_arr19 = 0;\n    let mut smallest_even_index_in_arr20\
    \ = 0;\n    let mut smallest_even_index_in_arr21 = 0;\n    let mut smallest_even_index_in_arr22\
    \ = 0;\n    let mut smallest_even_index_in_arr23 = 0;\n    let mut smallest_even_index_in_arr24\
    \ = 0;\n    let mut smallest_even_index_in_arr25 = 0;\n    let mut smallest_even_index_in_arr26\
    \ = 0;\n    let mut smallest_even_index_in_arr27 = 0;\n    let mut smallest_even_index_in_arr28\
    \ = 0;\n    let mut smallest_even_index_in_arr29 = 0;\n    let mut smallest_even_index_in_arr30\
    \ = 0;\n    let mut smallest_even_index_in_arr31 = 0;\n    let mut smallest_even_index_in_arr32\
    \ = 0;\n    let mut smallest_even_index_in_arr33 = 0;\n    let mut smallest_even_index_in_arr34\
    \ = 0;\n    let mut smallest_even_index_in_arr35 = 0;\n    let mut smallest_even_index_in_arr36\
    \ = 0;\n    let mut smallest_even_index_in_arr37 = 0;\n    let mut smallest_even_index_in_arr38\
    \ = 0;\n    let mut smallest_even_index_in_arr39 = 0;\n    let mut smallest_even_index_in_arr40\
    \ = 0;\n    let mut smallest_even_index_in_arr41 = 0;\n    let mut smallest_even\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_xk00gdy.rs:70:26\n   |\n\
    70 |     let mut smallest_even\n   |                          ^ help: add `;`\
    \ here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_xk00gdy.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut min_value =\
    \ i32::MAX;\n    let mut min_value_index = -1;\n    let mut max_value = i32::MIN;\n\
    \    let mut max_value_index = -1;\n    for i in arr.iter() {\n        if i %\
    \ 2 == 0 {\n            even_values.push(i);\n            if i < min_value {\n\
    \                min_value = i;\n                min_value_index = i;\n      \
    \      }\n            if i > max_value {\n                max_value = i;\n   \
    \             max_value_index = i;\n            }\n        }\n    }\n    if even_values.is_empty()\
    \ {\n        return vec![];\n    }\n    if min_value == i32::MAX {\n        return\
    \ vec![];\n    }\n    if min_value == i32::MIN {\n        return vec![];\n   \
    \ }\n    if min_value_index == -1 {\n        return vec![];\n    }\n    if max_value\
    \ == i32::MIN {\n        return vec![];\n    }\n    if max_value_index == -1 {\n\
    \        return vec![];\n    }\n    if max_value_index < min_value_index {\n \
    \       return vec![];\n    }\n    if max_value_index > min_value_index {\n  \
    \      return vec![];\n    }\n    let mut result = vec![];\n    for i in even_values.iter()\
    \ {\n        if i == min_value_index {\n            result.push(min_value);\n\
    \        }\n        if i == max_value_index {\n            result.push(max_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp66byng2w.rs:35:20\n   |\n\
    35 |             if i < min_value {\n   |                    ^^^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp66byng2w.rs:36:29\n\
    \   |\n28 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n36 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp66byng2w.rs:37:35\n   |\n29 |     let mut min_value_index\
    \ = -1;\n   |                               -- expected due to this value\n...\n\
    37 |                 min_value_index = i;\n   |                              \
    \     ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n37 |                 min_value_index = *i;\n   |             \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp66byng2w.rs:39:20\n\
    \   |\n39 |             if i > max_value {\n   |                    ^^^^^^^^^\
    \ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp66byng2w.rs:40:29\n\
    \   |\n30 |     let mut max_value = i32::MIN;\n   |                         --------\
    \ expected due to this value\n...\n40 |                 max_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp66byng2w.rs:41:35\n   |\n31 |     let mut max_value_index\
    \ = -1;\n   |                               -- expected due to this value\n...\n\
    41 |                 max_value_index = i;\n   |                              \
    \     ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n41 |                 max_value_index = *i;\n   |             \
    \                      +\n\nerror[E0277]: can't compare `&&isize` with `{integer}`\n\
    \  --> /tmp/tmp66byng2w.rs:71:14\n   |\n71 |         if i == min_value_index {\n\
    \   |              ^^ no implementation for `&&isize == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&&isize`\n  \
    \ = help: the fo"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_val >\
    \ i {\n                min_val = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if min_val == i32::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_val, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wmxi1bq.rs:31:26\n   |\n\
    31 |             if min_val > i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wmxi1bq.rs:32:27\n\
    \   |\n27 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n32 |                 min_val = i;\n   |   \
    \                        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8wmxi1bq.rs:33:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n33 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8wmxi1bq.rs:40:14\n   |\n40 |         vec![min_val, min_idx]\n\
    \   |              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n40 |         vec![min_val.try_into().unwrap(), min_idx]\n   |         \
    \            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if *i % 2 == 0 {\n            if *i < min_val\
    \ {\n                min_val = *i;\n                min_idx = i;\n           \
    \ }\n        }\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj6tnsf86.rs:31:21\n   |\n\
    31 |             if *i < min_val {\n   |                     ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |             if *i < min_val.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj6tnsf86.rs:32:27\n   |\n27 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n32 |   \
    \              min_val = *i;\n   |                           ^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6tnsf86.rs:33:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n33 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6tnsf86.rs:37:10\n\
    \   |\n37 |     vec![min_val, min_idx]\n   |          ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n37 |     vec![min_val.try_into().unwrap(),\
    \ min_idx]\n   |                 ++++++++++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value: isize = 0;\n    let mut smallest_index:\
    \ usize = 0;\n    let mut even_values: Vec<isize> = Vec::new();\n    let mut even_values_index:\
    \ Vec<usize> = Vec::new();\n    for &i in arr {\n        if i % 2 == 0 {\n   \
    \         even_values.push(i);\n            even_values_index.push(i);\n     \
    \   } else {\n            if smallest_value == 0 {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            } else {\n          \
    \      if i < smallest_value {\n                    smallest_value = i;\n    \
    \                smallest_index = i;\n                }\n            }\n     \
    \   }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values_index[0];\n    for &i in even_values {\n        if i == smallest_even_value\
    \ {\n            smallest_even_index = even_values_index[i];\n        }\n    }\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    even_values_index.sort_unstable();\n\
    \    let mut even_values_index = even_values_index.clone();\n    \n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpphzsqbzp.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpphzsqbzp.rs:34:36\n   |\n34 |             even_values_index.push(i);\n\
    \   |                                    ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |             even_values_index.push(i.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpphzsqbzp.rs:38:34\n   |\n28 |     let mut smallest_index:\
    \ usize = 0;\n   |                             ----- expected due to this type\n\
    ...\n38 |                 smallest_index = i;\n   |                          \
    \        ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpphzsqbzp.rs:42:38\n   |\n28 |     let mut smallest_index: usize\
    \ = 0;\n   |                             ----- expected due to this type\n...\n\
    42 |                     smallest_index = i;\n   |                           \
    \           ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpphzsqbzp.rs:52:9\n   |\n52 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpphzsqbzp.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: exp"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_value_and_index = Vec::new();\n\
    \    for i in even_values.iter() {\n        if i == smallest_value {\n       \
    \     smallest_value_and_index.push(i);\n        }\n    }\n    if smallest_value_and_index.len()\
    \ == 0 {\n        return Vec::new();\n    }\n    smallest_value_and_index.sort_unstable_by_key(|&x|\
    \ x);\n    smallest_value_and_index\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0mzy99si.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0mzy99si.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0mzy99si.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0277]: can't compare `&&isize` with `isize`\n\
    \  --> /tmp/tmp0mzy99si.rs:44:14\n   |\n44 |         if i == smallest_value {\n\
    \   |              ^^ no implementation for `&&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0mzy99si.rs:52:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n52 |     smallest_value_and_index\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&&isize`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values.iter().position(|&i| i == smallest_value);\n\
    \    even_values.remove(&mut smallest_value);\n    even_values.remove(&mut smallest_index);\n\
    \    even_values.remove(&mut smallest_even_index);\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjlst1za1.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjlst1za1.rs:44:24\n   |\n44 |     even_values.remove(&mut smallest_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&mut\
    \ isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjlst1za1.rs:45:24\n\
    \   |\n45 |     even_values.remove(&mut smallest_index);\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&mut isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjlst1za1.rs:46:24\n   |\n46 |     even_values.remove(&mut\
    \ smallest_even_index);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found mutable reference\n   |\n   = note:           expected\
    \ type `usize`\n           found mutable reference `&mut Option<usize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index\
    \ = arr[0];\n    for &i in arr {\n        if i % 2 == 0 {\n            if smallest_even_value\
    \ < i {\n                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n            }\n        }\n    }\n    vec![smallest_even_index, smallest_even_value]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcjonj8gd.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = even_values.iter().position(|&x| x == i).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_cftcagq.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_cftcagq.rs:44:26\n   |\n44 |     vec![smallest_value, smallest_index]\n\
    \   |                          ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n44 |     vec![smallest_value, smallest_index.try_into().unwrap()]\n\
    \   |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < min_value {\n                min_value = i;\n                min_index =\
    \ i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n     \
    \   return Vec::new();\n    }\n    let mut smallest_value = even_values[0];\n\
    \    let mut smallest_index = even_values[0];\n    for i in even_values.iter()\
    \ {\n        if i < min_value {\n            min_value = i;\n            smallest_value\
    \ = i;\n            smallest_index = i;\n        }\n    }\n    even_values.remove(&smallest_value);\n\
    \    even_values.sort();\n    even_values.insert(0, smallest_value);\n    even_values.insert(0,\
    \ smallest_index);\n    even_values\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphu11si_p.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphu11si_p.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphu11si_p.rs:35:29\n\
    \   |\n29 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n35 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_index\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphu11si_p.rs:45:16\n   |\n45 |         if i < min_value {\n   |\
    \                ^^^^^^^^^ expected `&&isize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphu11si_p.rs:46:25\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n46 |             min_value = i;\n   |                         ^\
    \ expected `isize`, found `&&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n46 |             min_value = **i;\n   |                         ++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphu11si_p.rs:51:24\n   |\n51 |  \
    \   even_values.remove(&smallest_value);\n   |                        ^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphu11si_p.rs:55:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut even_values = vec![];\n    let mut smallest_value = arr[0];\n    let\
    \ mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            even_values.push(i);\n            if i < smallest_value {\n\
    \                smallest_value = i;\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    even_values.sort_unstable_by_key(|&x| x);\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc55imjxp.rs:36:20\n   |\n\
    36 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpc55imjxp.rs:37:34\n   |\n31 |  \
    \   let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n37 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n37 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc55imjxp.rs:38:34\n   |\n32 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n38 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    38 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc55imjxp.rs:45:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n45 |     even_values.iter().cloned().collect::<Vec<_>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value: isize = 0;\n    let mut min_even_index:\
    \ usize = 0;\n    let mut min_value: isize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvlcaytmc.rs:83:17\n   |\n\
    83 |     let mut min_\n   |                 ^ help: add `;` here\n84 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvlcaytmc.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value\
    \ > i {\n                min_value = i;\n                min_idx = i;\n      \
    \      }\n        }\n    }\n    if min_value == isize::MAX {\n        return Vec::new();\n\
    \    }\n    let mut result = Vec::new();\n    let mut idx = 0;\n    while idx\
    \ < arr.len() {\n        if arr[idx] % 2 == 0 {\n            result.push(arr[idx]);\n\
    \            idx += 1;\n        } else {\n            idx += 1;\n        }\n \
    \   }\n    if result.len() == 1 {\n        return result;\n    }\n    if min_idx\
    \ < result.len() {\n        result.swap(0, min_idx);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx_fu8tww.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx_fu8tww.rs:53:18\n   |\n53 |     if min_idx < result.len() {\n\
    \   |                  ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n53 |     if min_idx < result.len().try_into().unwrap() {\n   |  \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx_fu8tww.rs:54:24\n   |\n54 |         result.swap(0, min_idx);\n\
    \   |                        ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n54 |         result.swap(0, min_idx.try_into().unwrap());\n   | \
    \                              ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    even_values.remove(&smallest_even_value);\n\
    \    even_values.remove(&smallest_even_index);\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    \n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpduvl9jou.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpduvl9jou.rs:46:20\n   |\n46 |             if i < smallest_even_value\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&isize`, found `isize`\n   |              \
    \      help: consider borrowing here: `&smallest_even_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpduvl9jou.rs:47:39\n   |\n42 |     let mut smallest_even_value\
    \ = even_values[0];\n   |                                   -------------- expected\
    \ due to this value\n...\n47 |                 smallest_even_value = i;\n   |\
    \                                       ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n47 |                 smallest_even_value\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpduvl9jou.rs:48:39\n   |\n43 |     let mut smallest_even_index\
    \ = even_values[0];\n   |                                   -------------- expected\
    \ due to this value\n...\n48 |                 smallest_even_index = i;\n   |\
    \                                       ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpduvl9jou.rs:52:24\n   |\n52 |     even_values.remove(&smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpduvl9jou.rs:53:24\n   |\n53 |\
    \     even_values.remove(&smallest_even_index);\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: m"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values.iter().position(|&i| i % 2 == 0).unwrap();\n\
    \    for &i in even_values {\n        if i < smallest_value {\n            smallest_even_value\
    \ = i;\n            smallest_even_index = i;\n        }\n    }\n    even_values.remove(&smallest_even_index);\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg7dil_y6.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg7dil_y6.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg7dil_y6.rs:47:35\n   |\n43 |     let mut smallest_even_index =\
    \ even_values.iter().position(|&i| i % 2 == 0).unwrap();\n   |               \
    \                    ----------------------------------------------------- expected\
    \ due to this value\n...\n47 |             smallest_even_index = i;\n   |    \
    \                               ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg7dil_y6.rs:50:24\n   |\n50 |     even_values.remove(&smallest_even_index);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`\n\
    \   |\nhelp: consider removing the borrow\n   |\n50 -     even_values.remove(&smallest_even_index);\n\
    50 +     even_values.remove(smallest_even_index);\n   | \n\nerror[E0271]: type\
    \ mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n \
    \   --> /tmp/tmpg7dil_y6.rs:53:29\n     |\n53   |     even_values.into_iter().cloned().collect()\n\
    \     |                             ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpg7dil_y6.rs:53:38\n   |\n53 | "
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n\
    \    if even_values.len() > 1 {\n        let mut smallest_value = even_values[0];\n\
    \        let mut smallest_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i < smallest_value {\n                smallest_value = i;\n\
    \                smallest_index = i;\n            }\n        }\n        return\
    \ vec![smallest_value, smallest_index];\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggz1c9zp.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpggz1c9zp.rs:34:37\n   |\n34 |                 smallest_value.push(smallest_value[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpggz1c9zp.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpggz1c9zp.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpggz1c9zp.rs:49:20\n   |\n49 |\
    \             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpggz1c9zp.rs:54:21\n   |\n54 |         return vec![smallest_value, smallest_index];\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n54 |         return vec!["
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = 0;\n    let mut min_even_index_in_arr = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            min_even_value = i;\n            min_even_index =\
    \ i;\n            min_even_index_in_arr = i;\n        }\n    }\n    let mut min_even_index_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr2 = 0;\n    for &i in arr {\n       \
    \ if i % 2 == 0 {\n            min_even_index_in_arr += i;\n        }\n      \
    \  if i % 2 == 1 {\n            min_even_index_in_arr2 += i;\n        }\n    }\n\
    \    if min_even_index_in_arr == min_even_index_in_arr2 {\n        return vec![min_even_value];\n\
    \    }\n    if min_even_index_in_arr < min_even_index_in_arr2 {\n        return\
    \ vec![min_even_value];\n    }\n    if min_even_index_in_arr > min_even_index_in_arr2\
    \ {\n        return vec![min_even_index_in_arr];\n    }\n    return vec![];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp405o_iv0.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp405o_iv0.rs:39:9\n   |\n39 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_value > i {\n\
    \                min_value = i;\n                min_idx = i;\n            }\n\
    \        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3br6olxj.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3br6olxj.rs:37:10\n   |\n37 |     vec![min_value, min_idx]\n  \
    \ |          ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    37 |     vec![min_value.try_into().unwrap(), min_idx]\n   |                  \
    \ ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec![];\n    let mut smallest_index_value\
    \ = vec![];\n    let mut smallest_index_value = vec!\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpjofei8xo.rs:74:1\n\
    \   |\n73 |     let mut smallest_index_value = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n74 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    even_values.sort_unstable_by(|a, b| a.cmp(b));\n\
    \    even_values.into_iter().take(1).collect()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoptf4469.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoptf4469.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoptf4469.rs:35:34\n   |\n29 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n35 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpoptf4469.rs:43:37\n     |\n\
    43   |     even_values.into_iter().take(1).collect()\n     |                 \
    \                    ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            }\n        } else {\n    \
    \        min_value = i;\n            min_idx = i;\n        }\n    }\n    let mut\
    \ result = vec![];\n    if min_idx != arr.len() {\n        result.push(min_value);\n\
    \        result.push(min_idx);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp26j92e5e.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp26j92e5e.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = 0;\n   |                       - expected due to this value\n\
    ...\n32 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp26j92e5e.rs:35:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n35 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             min_value = *i;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp26j92e5e.rs:36:23\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n36 |   \
    \          min_idx = i;\n   |                       ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |        \
    \     min_idx = *i;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp26j92e5e.rs:42:21\n   |\n42 |         result.push(min_idx);\n\
    \   |                     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n42 |         result.push(min_idx.try_into().unwrap());\n   |    \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut smallest_value = arr[0];\n    let mut smallest_index = 0;\n    let\
    \ mut even_values = vec![];\n    for i in arr.iter().rev() {\n        if i % 2\
    \ == 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = i;\n        }\n        if i == smallest_value\
    \ {\n            smallest_value = i;\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     return vec![even_values[0]];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = 0;\n    for i in even_values.iter().rev() {\n\
    \        if i % 2 == 0 {\n            smallest_even_value = i;\n            smallest_even_index\
    \ = i;\n        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpybeodu7_.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpybeodu7_.rs:38:30\n   |\n31 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n38 |       \
    \      smallest_index = i;\n   |                              ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpybeodu7_.rs:41:30\n   |\n30 |     let mut smallest_value\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n41 |             smallest_value = i;\n   |                              ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n41 |             smallest_value = *i;\n   |                           \
    \   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpybeodu7_.rs:40:14\n\
    \   |\n40 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpybeodu7_.rs:48:21\n   |\n48 |         return vec![even_values[0]];\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the type\n   |\n48 |   "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    let mut min_even_index_in_arr = -1;\n    let mut min_even_index_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index = -1;\n\
    \    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr = -1;\n\
    \    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2mjn3wyt.rs:43:436\n   |\n\
    43 |     let mut min_even_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_min_even_value_in_index_in_arr_with_\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                            ^ help: add `;` here\n\
    44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2mjn3wyt.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_value_index\
    \ = 0;\n    let mut min_value_index2 = 0;\n    let mut min_value_index3 = 0;\n\
    \    let mut min_value_index4 = 0;\n    let mut min_value_index5 = 0;\n    let\
    \ mut min_value_index6 = 0;\n    let mut min_value_index7 = 0;\n    let mut min_value_index8\
    \ = 0;\n    let mut min_value_index9 = 0;\n    let mut min_value_index10 = 0;\n\
    \    let mut min_value_index11 = 0;\n    let mut min_value_index12 = 0;\n    let\
    \ mut min_value_index13 = 0;\n    let mut min_value_index14 = 0;\n    let mut\
    \ min_value_index15 = 0;\n    let mut min_value_index16 = 0;\n    let mut min_value_index17\
    \ = 0;\n    let mut min_value_index18 = 0;\n    let mut min_value_index19 = 0;\n\
    \    let mut min_value_index20 = 0;\n    let mut min_value_index21 = 0;\n    let\
    \ mut min_value_index22 = 0;\n    let mut min_value_index23 = 0;\n    let mut\
    \ min_value_index24 = 0;\n    let mut min_value_index25 = 0;\n    let mut min_value_index26\
    \ = 0;\n    let mut min_value_index27 = 0;\n    let mut min_value_index28 = 0;\n\
    \    let mut min_value_index29 = 0;\n    let mut min_value_index30 = 0;\n    let\
    \ mut min_value_index31 = 0;\n    let mut min_value_index32 = 0;\n    let mut\
    \ min_value_index33 = 0;\n    let mut min_value_index34 = 0;\n    let mut min_value_index35\
    \ = 0;\n    let mut min_value_index36 = 0;\n    let mut min_value_index37 = 0;\n\
    \    let mut min_value_index38 = 0;\n    let mut min_value_index39 = 0;\n    let\
    \ mut min_value_index40 = 0;\n    let mut min_value_index41 = 0;\n    let mut\
    \ min_value_index42 = 0;\n    let mut min_value_index43 = 0;\n    let mut min_value_index44\
    \ = 0;\n    let mut min_value_index45 = 0;\n    let mut min_value_index46 = 0;\n\
    \    let mut min_value_index47 = 0;\n    let mut min_value_index48 = 0;\n    let\
    \ mut min_value_index49 = 0;\n    let mut min_value_index50 = 0;\n    let mut\
    \ min_value_index51 = 0;\n    let mut min_value_index52 = 0;\n    let mut min_value_index53\
    \ = 0;\n    let mut min_value_index54 = 0;\n    let mut min_value_index55 = 0;\n\
    \    let mut min_value_index56 = 0;\n    let mut min_value\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpedv___32.rs:84:22\n   |\n\
    84 |     let mut min_value\n   |                      ^ help: add `;` here\n85\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpedv___32.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values[0];\n    for &i in even_values {\n   \
    \     if i < smallest_even_value {\n            smallest_even_value = i;\n   \
    \         smallest_even_index = i;\n        }\n    }\n    even_values.remove(&smallest_even_value);\n\
    \    even_values.remove(&smallest_even_index);\n    even_values.sort();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmp8_j18t3s.rs:95:5\n\
    \   |\n95 |     even\n   |     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8_j18t3s.rs:30:9\n   |\n30 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_j18t3s.rs:44:9\n\
    \   |\n44 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8_j18t3s.rs:50:24\n   |\n50 |  \
    \   even_values.remove(&smallest_even_value);\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_j18t3s.rs:51:24\n\
    \   |\n51 |     even_values.remove(&smallest_even_index);\n   |              \
    \          ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            }\n            min_value =\
    \ i;\n        }\n    }\n    if min_idx == -1 {\n        vec![]\n    } else {\n\
    \        vec![min_value, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8odh2o74.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8odh2o74.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n32 |                 min_idx = i;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 min_idx = *i;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8odh2o74.rs:34:25\n\
    \   |\n27 |     let mut min_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n34 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |             min_value = *i;\n   |     \
    \                    +\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for &x in arr {\n\
    \        if x % 2 == 0 {\n            min_value = x;\n            min_idx = x;\n\
    \        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfc1rx8et.rs:32:9\n   |\n\
    32 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_value_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < min_value {\n                min_value = i;\n                min_value_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut min_value_even_value = min_value;\n\
    \    let mut min_value_even_index = min_value_index;\n    for i in even_values.iter()\
    \ {\n        if i % 2 == 0 {\n            if i < min_value_even_value {\n    \
    \            min_value_even_value = i;\n                min_value_even_index =\
    \ i;\n            }\n        }\n    }\n    even_values.remove(min_value_even_index);\n\
    \    even_values.sort();\n    even_values.dedup();\n    even_values.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv43_jnvt.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv43_jnvt.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv43_jnvt.rs:35:35\n\
    \   |\n29 |     let mut min_value_index = isize::MAX;\n   |                  \
    \             ---------- expected due to this value\n...\n35 |               \
    \  min_value_index = i;\n   |                                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_value_index = *i;\n   |                                  \
    \ +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpv43_jnvt.rs:45:14\n\
    \   |\n45 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n45 |         if *i % 2 == 0 {\n   |         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv43_jnvt.rs:46:20\n   |\n\
    46 |             if i < min_value_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv43_jnvt.rs:47:40\n\
    \   |\n42 |     let mut min_value_even_value = min_value;\n   |              \
    \                      --------- expected due to this value\n...\n47 |       \
    \          min_value_even_value = i;\n   |                                   \
    \     ^ expected `isize`, found `&&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n47 |                 min_valu"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_index = 0;\n\
    \    let mut min_even_value = false;\n    for &x in arr {\n        if x % 2 ==\
    \ 0 {\n            min_even_value = true;\n        }\n        if min_even_value\n\
    \            && (min_value < x || (min_value == x && min_index == 0))\n      \
    \  {\n            min_value = x;\n            min_even_value = false;\n      \
    \      min_index = x;\n        }\n    }\n    min_even_value\n        .iter()\n\
    \        .map(|x| if x == min_value { min_index } else { x })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp57h5i0.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `iter` found for type `bool` in the current scope\n  --> /tmp/tmpwp57h5i0.rs:43:10\n\
    \   |\n43 |         .iter()\n   |          ^^^^ method not found in `bool`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = isize::MAX;\n    let mut smallest_index\
    \ = 0;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            if smallest_value\
    \ < i {\n                smallest_value = i;\n                smallest_index =\
    \ i;\n            }\n        }\n    }\n    vec![smallest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfd4l08ig.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfd4l08ig.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = isize::MAX;\n   |                   \
    \           ---------- expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfd4l08ig.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            }\n            min_value =\
    \ i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4128_318.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4128_318.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = 0;\n   |                       - expected due to this value\n\
    ...\n32 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4128_318.rs:34:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |             min_value = *i;\n   |                         +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n\
    \    if even_values.len() == 2 {\n        if even_values[0] < even_values[1] {\n\
    \            return vec![even_values[0], even_values[1]];\n        }\n       \
    \ return vec![even_values[1], even_values[0]];\n    }\n    if even_values.len()\
    \ == 3 {\n        if even_values[0] < even_values[1] && even_values[0] < even_values[2]\
    \ {\n            return vec![even_values[0], even_values[1], even_values[2]];\n\
    \        }\n        if even_values[1] < even_values[2] && even_values[1] < even_values[0]\
    \ {\n            return vec![even_values[1], even_values[2], even_values[0]];\n\
    \        }\n        if even_values[2] < even_values[0] && even_values[2] < even_values[1]\
    \ {\n            return vec![even_values[2], even_values[0], even_values[1]];\n\
    \        }\n    }\n    if even_values.len() == 4 {\n        if even_values[0]\
    \ < even_values[1] && even_values[0] < even_values[2] && even_values[0] < even_values[3]\
    \ {\n            return vec![even_values[0], even_values[1], even_values[2], even_values[3]];\n\
    \        }\n        if even_values[1] < even_values[2] && even_values[1] < even_values[3]\
    \ && even_values[1] < even_values[0] {\n            return vec![even_values[1],\
    \ even_values[2], even_values[3], even_values[0]];\n        }\n        if even_values[2]\
    \ < even_values[3] && even_values[2] < even_values[0] && even_values[2] < even_values[1]\
    \ {\n            return vec![even_values[2], even_values[3], even_values[0], even_values[1]];\n\
    \        }\n        if even_values[3] < even_values[0] && even_values[3] < even_values[1]\
    \ && even_values[3] < even_values[2] {\n            return vec![even_values[3],\
    \ even_values[0], even_values[1], even_values[2]];\n        }\n    }\n    if even_values.len()\
    \ == 5 {\n        if even_values[0] < even_values[1] && even_values[0] < even_values[2]\
    \ && even_values[0] < even_values[3] && even_values[0] < even\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjyi5rnt7.rs:90:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n76 |     if even_values.len()\
    \ == 5 {\n   |                               - this delimiter might not be properly\
    \ closed...\n77 |         if even_values[0] < even_values[1] && even_values[0]\
    \ < even_values[2] && even_values[0] < even_values[3] && even_values[0] < even\n\
    78 | }\n   | - ...as it matches this but it has different indentation\n...\n90\
    \ | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpjyi5rnt7.rs:78:1\n\
    \   |\n77 |         if even_values[0] < even_values[1] && even_values[0] < even_values[2]\
    \ && even_values[0] < even_values[3] && even_values[0] < even\n   |         --\
    \ this `if` expression has a condition, but no block\n78 | }\n   | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjyi5rnt7.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpjyi5rnt7.rs:34:37\n   |\n34 |                 smallest_value.push(smallest_value[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpjyi5rnt7.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isiz"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    let mut min_idx2 = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n   \
    \         if min_value % 2 == 0 {\n                if x < min_value {\n      \
    \              min_value = x;\n                    min_idx = x;\n            \
    \    }\n            } else {\n                if x < min_value {\n           \
    \         min_value = x;\n                    min_idx2 = x;\n                }\n\
    \            }\n        }\n    }\n    if min_idx2 == min_idx {\n        min_idx2\
    \ = min_idx;\n    }\n    vec![min_value, min_idx2]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzx0my2wr.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = -1;\n\
    \    let mut even_values = Vec::new();\n    for i in arr.iter() {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n            if min_value < i\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if min_idx == -1 {\n        min_idx = 0;\n    }\n    even_values[min_idx..]\n\
    \        .iter()\n        .cloned()\n        .filter(|&x| x % 2 == 0)\n      \
    \  .cloned()\n        .min_by_key(|&x| x)\n        .unwrap()\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzzd3n1zt.rs:33:28\n   |\n\
    33 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzd3n1zt.rs:34:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n34 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzzd3n1zt.rs:35:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n35 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpzzd3n1zt.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpzzd3n1zt.rs:42:19\n   |\n42 | \
    \    if min_idx == -1 {\n   |                   ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzd3n1zt.rs:45:5\n\
    \   |\n26 |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                \
    \                ---------- expected `Vec<isize>` because of return type\n...\n\
    45 | /     even_values[min_idx..]\n46 | |         .iter()\n47 | |         .cloned()\n\
    48 | |         .filter(|&x| x % 2 == 0)\n49 | |     "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    let mut min_idx = arr.iter().enumerate().min_by_key(|(_, v)| {\n        if\
    \ v < min_value {\n            min_value = v;\n            min_idx = *v;\n   \
    \     }\n    });\n    min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpko78m_ib.rs:30:16\n   |\n\
    30 |         if v < min_value {\n   |                ^^^^^^^^^ expected `&&isize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpko78m_ib.rs:31:25\n\
    \   |\n27 |     let mut min_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n31 |             min_value = v;\n   |     \
    \                    ^ expected `isize`, found `&&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |             min_value = **v;\n   |    \
    \                     ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpko78m_ib.rs:32:23\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n32 |             min_idx = *v;\n   |                   \
    \    ^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |             min_idx = **v;\n   |                       +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpko78m_ib.rs:35:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n35 |     min_idx\n   |  \
    \   ^^^^^^^ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found enum `Option<(usize, &isize)>`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    let mut even_values_index = even_values.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort_by(|&(_, v)|\
    \ v);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort_by(|&(_, v)|\
    \ v);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort_by(|&(_, v)|\
    \ v);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort_by(|&(_, v)|\
    \ v);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort_by(|&(_, v)|\
    \ v);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>>();\n    even_values_index.sort_by(|&(_, v)|\
    \ v);\n    even_values_index.dedup();\n    let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `:`, `=`, or `>`, found `}`\n  --> /tmp/tmpf7yaq6fb.rs:63:1\n\
    \   |\n62 |     let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_\n   |                                      \
    \                                                                            \
    \         - expected one of `,`, `:`, `=`, or `>`\n63 | }\n   | ^ unexpected token\n\
    \   |\nhelp: you might have meant to end the type parameters here\n   |\n62 |\
    \     let mut even_values_index = even_values_index.iter().cloned().enumerate().filter(|&(_,\
    \ v)| v % 2 == 0).collect::<Vec<_>\n   |                                     \
    \                                                                            \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf7yaq6fb.rs:33:20\n\
    \   |\n33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpf7yaq6fb.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf7yaq6fb.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0593]: closure is expected to take 2 arguments,\
    \ but it takes 1 argument\n  --> /tmp/tmpf7yaq6fb.rs:45:23\n   |\n45 |   "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_index\
    \ = isize::MAX;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n        \
    \    if min_value < i {\n                min_value = i;\n                min_index\
    \ = i;\n            }\n        }\n    }\n    vec![min_value, min_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5v9lyxq3.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5v9lyxq3.rs:32:29\n   |\n27 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n32 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5v9lyxq3.rs:33:29\n\
    \   |\n28 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n33 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_index\
    \ = *i;\n   |                             +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 1;\n\
    \    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 =\
    \ 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7\
    \ = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10\
    \ = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13\
    \ = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16\
    \ = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19\
    \ = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22\
    \ = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25\
    \ = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28\
    \ = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31\
    \ = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34\
    \ = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37\
    \ = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40\
    \ = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43\
    \ = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46\
    \ = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49\
    \ = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52\
    \ = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55\
    \ = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58\
    \ = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61\
    \ = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6peev_ef.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6peev_ef.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut min_value =\
    \ isize::MAX;\n    let mut min_index = isize::MAX;\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ min_value {\n                min_value = i;\n                min_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_value = even_values[0];\n\
    \        let mut smallest_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i % 2 == 0 {\n                if i < smallest_value {\n  \
    \                  smallest_value = i;\n                    smallest_index = i;\n\
    \                }\n            }\n        }\n        return vec![smallest_value,\
    \ smallest_index];\n    }\n    return vec![];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa65g9rkc.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa65g9rkc.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa65g9rkc.rs:35:29\n\
    \   |\n29 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n35 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_index\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa65g9rkc.rs:43:21\n   |\n43 |         return vec![even_values[0]];\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the type\n   |\n43 |         return vec![*even_values[0]];\n\
    \   |                     +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpa65g9rkc.rs:49:18\n   |\n49 |             if i % 2 == 0 {\n   |\
    \                - ^ - {integer}\n   |                |\n   |                &&isize\n\
    \   |\nhelp: `%` can be used on `isize`, you can dereference `i`\n   |\n49 | \
    \            if *i % 2 == 0 {\n   |                +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa65g9rkc.rs:50:24\n   |\n50 |                 if i < smallest_value\
    \ {\n   |                        ^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    let mut even_values = Vec::new();\n    for &i in arr {\n  \
    \      if i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if even_values.len() == 1 {\n        return even_values;\n    }\n\
    \    let mut min_value = even_values[0];\n    let mut min_idx = even_values.iter().position(|&i|\
    \ i == min_value).unwrap();\n    for i in even_values.iter().rev() {\n       \
    \ if i == min_value {\n            min_value = i;\n            min_idx = even_values.iter().position(|&i|\
    \ i == min_value).unwrap();\n        }\n    }\n    even_values.remove(min_value);\n\
    \    even_values.retain(|&i| i != min_value);\n    even_values.insert(0, min_value);\n\
    \    even_values.insert(0, min_idx);\n    even_values\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc6oscn44.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc6oscn44.rs:49:25\n   |\n45 |     let mut min_value = even_values[0];\n\
    \   |                         -------------- expected due to this value\n...\n\
    49 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n49 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmpc6oscn44.rs:48:14\n   |\n48 | \
    \        if i == min_value {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc6oscn44.rs:53:24\n\
    \   |\n53 |     even_values.remove(min_value);\n   |                        ^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n53 |     even_values.remove(min_value.try_into().unwrap());\n\
    \   |                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc6oscn44.rs:56:27\n   |\n56 |     even_values.insert(0,\
    \ min_idx);\n   |                           ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n56 |     even_values.insert(0, min_idx.try_into().unwrap());\n\
    \   |                                  ++++++++++++++++++++"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    let mut even_values_index = even_values.iter().cloned().enumerate().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by(|&(_, index)| index);\n    let mut even_values_index\
    \ = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n    even_values_index.dedup();\n\
    \    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.dedup();\n    let mut even_values_index = even_values_index.in\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmp7st4q323.rs:66:51\n\
    \   |\n66 |     let mut even_values_index = even_values_index.in\n   |       \
    \                                            ^^ expected identifier, found keyword\n\
    \   |\nhelp: escape `in` to use it as an identifier\n   |\n66 |     let mut even_values_index\
    \ = even_values_index.r#in\n   |                                             \
    \      ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp7st4q323.rs:66:53\n\
    \   |\n66 |     let mut even_values_index = even_values_index.in\n   |       \
    \                                              ^ help: add `;` here\n67 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7st4q323.rs:33:20\n\
    \   |\n33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7st4q323.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7st4q323.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0271]: type mismatch resolving `<Enumerate<Cloned<std::slice::Iter<'_,\
    \ &isize>>> as Iterator>::Item == &_`\n    --> /tmp/tmp7st4q323.rs:44:73\n   \
    \  |\n44   |     let mut even_values_index = even_values.iter().cloned().en"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = arr[0];\n    let mut smallest_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    for i in arr.iter().rev() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n        }\n      \
    \  if i == smallest_value {\n            smallest_index = even_values.iter().position(|&x|\
    \ x == i).unwrap();\n        }\n        if i == smallest_value {\n           \
    \ smallest_value = i;\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    even_values[smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpo8erd5yz.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpo8erd5yz.rs:38:30\n   |\n27 |     let mut smallest_value = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n38\
    \ |             smallest_value = i;\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    38 |             smallest_value = *i;\n   |                              +\n\n\
    error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpo8erd5yz.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpo8erd5yz.rs:44:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |     even_values[smallest_index]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcujtpvyb.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n\
    \    for i in arr.iter() {\n        if *i % 2 == 0 {\n            if *i < min_value\
    \ {\n                min_value = *i;\n                min_idx = i;\n         \
    \   }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:31:21\n   |\n\
    31 |             if *i < min_value {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |             if *i < min_value.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_dkzjx1.rs:32:29\n   |\n27 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n32 | \
    \                min_value = *i;\n   |                             ^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:33:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n33 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dkzjx1.rs:37:10\n\
    \   |\n37 |     vec![min_value, min_idx]\n   |          ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n37 |     vec![min_value.try_into().unwrap(),\
    \ min_idx]\n   |                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_index = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            min_value = i;\n            min_index\
    \ = i;\n        }\n    }\n    let mut result = vec![];\n    for i in arr.iter().rev()\
    \ {\n        if i == min_value {\n            result.push(min_index);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg_vkmpmu.rs:34:25\n   |\n\
    30 |     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n34 |             min_value = i;\n   |              \
    \           ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             min_value = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg_vkmpmu.rs:35:25\n\
    \   |\n31 |     let mut min_index = 0;\n   |                         - expected\
    \ due to this value\n...\n35 |             min_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |             min_index = *i;\n   |                   \
    \      +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpg_vkmpmu.rs:40:14\n\
    \   |\n40 |         if i == min_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = -1;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_index = i;\n        \
    \    }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if min_value == isize::MAX {\n        return even_values;\n    }\n\
    \    let mut min_value_pos = 0;\n    for &i in even_values {\n        if i ==\
    \ min_value {\n            min_value_pos = even_values.iter().position(|&i| i\
    \ == min_value);\n        }\n    }\n    let mut min_value_neg = even_values.iter().position(|&i|\
    \ i == min_value);\n    if min_value_pos == min_value_neg {\n        min_value_pos\
    \ = even_values.iter().position(|&i| i == min_value);\n    }\n    if min_value_pos\
    \ == min_value_neg {\n        min_value_pos = even_values.iter().position(|&i|\
    \ i == min_value);\n    }\n    if min_value_pos == min_value_neg {\n        min_value_pos\
    \ = even_values.iter().position(|&i| i == min_value);\n    }\n    if min_value_pos\
    \ == min_value_neg {\n        min_value_pos = even_values.iter().position(|&i|\
    \ i == min_value);\n    }\n    if min_value_pos == min_value_neg {\n        min_value_pos\
    \ = even_values.iter().position(|&i| i == min_value);\n    }\n    if min_value_pos\
    \ == min_value_neg {\n        min_value_pos = even_values.iter().position(|&i|\
    \ i == min_value);\n    }\n    if min_value_pos == min_value_neg {\n        min_value_pos\
    \ = even_values.iter().position(|&i| i == min_value);\n    }\n    if min_value_pos\
    \ == min_value_neg {\n        min_value_pos = even_values.iter().position(|&i|\
    \ i == min_value);\n    }\n    if min_value_pos == min_value_neg {\n        min_value_pos\
    \ = even_values.iter().position(|&i| i == min_value);\n    }\n    if min_value_pos\
    \ == min_value_neg {\n        min_value_pos = even_values.iter().position(|&i|\
    \ i == min_value);\n    }\n    if min_value_pos == min_value_neg {\n        min_value_pos\
    \ = even_values.iter().position(|&i| i == min_value);\n    }\n    if min_value_pos\
    \ == min_value_neg {\n        min_value_pos = even_values.iter().position(|&i|\
    \ i == min_value);\n    }\n    if min_\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpzqnqbj_6.rs:89:1\n   |\n\
    88 |     if min_\n   |     -- this `if` expression has a condition, but no block\n\
    89 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzqnqbj_6.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzqnqbj_6.rs:46:9\n   |\n46 |     for &i in even_values\
    \ {\n   |         ^^    ----------- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzqnqbj_6.rs:48:29\n   |\n45 |     let mut min_value_pos = 0;\n\
    \   |                             - expected due to this value\n...\n48 |    \
    \         min_value_pos = even_values.iter().position(|&i| i == min_value);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: can't compare `{integer}`\
    \ with `Option<usize>`\n  --> /tmp/tmpzqnqbj_6.rs:52:22\n   |\n52 |     if min_value_pos\
    \ == min_value_neg {\n   |                      ^^ no implementation for `{integer}\
    \ == Option<usize>`\n   |\n   = help: the trait `PartialEq<Option<usize>>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzqnqbj_6.rs:53:25\n   |\n45 |     let mut min_value_pos = 0;\n   | \
    \                            "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    let mut result = vec![smallest_value, smallest_index];\n\
    \    for i in even_values.iter().rev() {\n        if i % 2 == 0 {\n          \
    \  if i == smallest_even_index {\n                result.push(i);\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbpuvpga.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsbpuvpga.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsbpuvpga.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpsbpuvpga.rs:45:14\n   |\n45 |         if i % 2 == 0 {\n   |   \
    \         - ^ - {integer}\n   |            |\n   |            &&isize\n   |\n\
    help: `%` can be used on `isize`, you can dereference `i`\n   |\n45 |        \
    \ if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsbpuvpga.rs:46:20\n   |\n46 |             if i < smallest_even_value\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpsbpuvpga.rs:54:14\n\
    \   |\n54 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `i`\n   |\n54 |         if *i % 2 == 0 "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ -1;\n    let mut min_even_val = isize::MAX;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            if min_even_val < i {\n                min_even_val\
    \ = i;\n                min_idx = i;\n            }\n        }\n        if min_even_val\
    \ == i {\n            if min_value < i {\n                min_value = i;\n   \
    \             min_idx = i;\n            }\n        }\n    }\n    if min_even_val\
    \ == isize::MAX {\n        return vec![];\n    }\n    return vec![min_even_val,\
    \ min_idx];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph4qv5a9p.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_val <\
    \ i {\n                min_val = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    if min_val == i32::MAX {\n        return Vec::new();\n\
    \    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpotl3pdyc.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpotl3pdyc.rs:32:27\n\
    \   |\n27 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n32 |                 min_val = i;\n   |   \
    \                        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpotl3pdyc.rs:33:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n33 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpotl3pdyc.rs:40:10\n   |\n40 |     vec![min_val, min_idx]\n\
    \   |          ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    40 |     vec![min_val.try_into().unwrap(), min_idx]\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = 0;\n    for &i in even_values {\n        if i < smallest_even_value\
    \ {\n            smallest_even_value = i;\n            smallest_even_index = i;\n\
    \        }\n    }\n    even_values.remove(&mut smallest_even_index);\n    even_values.sort();\n\
    \    even_values.insert(0, smallest_even_value);\n    even_values\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5cagap0y.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5cagap0y.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5cagap0y.rs:50:24\n   |\n50 |     even_values.remove(&mut smallest_even_index);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&mut isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_value_index\
    \ = -1;\n    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n       \
    \     if min_value == i32::MAX {\n                min_value = i;\n           \
    \     min_value_index = i;\n            } else {\n                if i < min_value\
    \ {\n                    min_value = i;\n                    min_value_index =\
    \ i;\n                }\n            }\n        }\n    }\n    if min_value ==\
    \ i32::MAX {\n        vec![]\n    } else {\n        vec![min_value, min_value_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcre1uce_.rs:32:29\n   |\n\
    27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n32 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcre1uce_.rs:35:24\n   |\n35 |              \
    \   if i < min_value {\n   |                        ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n35 |                 if i < min_value.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcre1uce_.rs:36:33\n   |\n27 |     let mut min_value\
    \ = i32::MAX;\n   |                         -------- expected due to this value\n\
    ...\n36 |                     min_value = i;\n   |                           \
    \      ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcre1uce_.rs:45:14\n   |\n45 |         vec![min_value, min_value_index]\n\
    \   |              ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n45 |         vec![min_value.try_into().unwrap(), min_value_index]\n   |\
    \                       ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = isize::MAX;\n    let mut\
    \ smallest_even_index = isize::MAX;\n    let mut smallest_value = isize::MAX;\n\
    \    let mut smallest_index = isize::MAX;\n    let mut even_values = Vec::new();\n\
    \    let mut even_values_index = Vec::new();\n    let mut even_values_index =\
    \ Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = Vec::new();\n    let mut even_values_index = Vec::new();\n    let mut even_values_index\
    \ = \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5isdf0m6.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_value_and_index = Vec::new();\n   \
    \ smallest_value_and_index.push(smallest_value, smallest_index);\n    let mut\
    \ smallest_value_and_index_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_value_and_index_iter = smallest_value_and_index_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_value_and_index_iter = smallest_value_and_index_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \    while smallest_value_and_index_iter.any(|&(_, index)| index == smallest_index)\
    \ {\n        smallest_value_and_index.push(smallest_value_and_index_iter.next());\n\
    \    }\n    smallest_value_and_index_iter\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9kzdltrk.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9kzdltrk.rs:43:30\n\
    \     |\n43   |     smallest_value_and_index.push(smallest_value, smallest_index);\n\
    \     |                              ^^^^ --------------  -------------- supplied\
    \ 2 arguments\n     |                              |\n     |                 \
    \             expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp9kzdltrk.rs:45:87\n     |\n45   |     let mut smallest_value_and_index_iter\
    \ = smallest_value_and_index_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \     |                                                                      \
    \                 ^^^^^^ expected reference, found `isize`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `isize`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp9kzdltrk.rs:45:96\n   |\n45 |       let mut smallest_value_and_index_iter\
    \ = smallest_value_and_index_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                                        \
    \                          ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Itera"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < min_value {\n                min_value = i;\n                min_index =\
    \ i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n     \
    \   return vec![];\n    }\n    let mut even_values_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = even_values_iter[0];\n    let mut min_index = even_values_iter[0];\n\
    \    for i in even_values_iter.iter().skip(1) {\n        if i < min_value {\n\
    \            min_value = i;\n            min_index = i;\n        }\n    }\n  \
    \  even_values_iter\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ i)| i == min_index)\n        .map(|(_, i)| i)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmekaoebj.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmekaoebj.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmekaoebj.rs:35:29\n\
    \   |\n29 |     let mut min_index = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n35 |                 min_index =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_index\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmekaoebj.rs:46:16\n   |\n46 |         if i < min_value {\n   |\
    \                ^^^^^^^^^ expected `&isize`, found `isize`\n   |\n   = note:\
    \ expected reference `&&isize`\n              found reference `&isize`\n\nerror[E0277]:\
    \ can't compare `&&isize` with `isize`\n  --> /tmp/tmpmekaoebj.rs:54:28\n   |\n\
    54 |         .filter(|(_, i)| i == min_index)\n   |                          \
    \  ^^ no implementation for `&&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&isize>` for `&&&isize`\n\nerror[E0277]: a value of\
    \ type `Vec<isize>` cannot be built from an iterator "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut smallest_even_value = arr[0];\n    let mut smallest_even_index = -1;\n\
    \    let mut smallest_even_index2 = -1;\n    let mut smallest_even_index3 = -1;\n\
    \    let mut smallest_even_index4 = -1;\n    let mut smallest_even_index5 = -1;\n\
    \    let mut smallest_even_index6 = -1;\n    let mut smallest_even_index7 = -1;\n\
    \    let mut smallest_even_index8 = -1;\n    let mut smallest_even_index9 = -1;\n\
    \    let mut smallest_even_index10 = -1;\n    let mut smallest_even_index11 =\
    \ -1;\n    let mut smallest_even_index12 = -1;\n    let mut smallest_even_index13\
    \ = -1;\n    let mut smallest_even_index14 = -1;\n    let mut smallest_even_index15\
    \ = -1;\n    let mut smallest_even_index16 = -1;\n    let mut smallest_even_index17\
    \ = -1;\n    let mut smallest_even_index18 = -1;\n    let mut smallest_even_index19\
    \ = -1;\n    let mut smallest_even_index20 = -1;\n    let mut smallest_even_index21\
    \ = -1;\n    let mut smallest_even_index22 = -1;\n    let mut smallest_even_index23\
    \ = -1;\n    let mut smallest_even_index24 = -1;\n    let mut smallest_even_index25\
    \ = -1;\n    let mut smallest_even_index26 = -1;\n    let mut smallest_even_index27\
    \ = -1;\n    let mut smallest_even_index28 = -1;\n    let mut smallest_even_index29\
    \ = -1;\n    let mut smallest_even_index30 = -1;\n    let mut smallest_even_index31\
    \ = -1;\n    let mut smallest_even_index32 = -1;\n    let mut smallest_even_index33\
    \ = -1;\n    let mut smallest_even_index34 = -1;\n    let mut smallest_even_index35\
    \ = -1;\n    let mut smallest_even_index36 = -1;\n    let mut smallest_even_index37\
    \ = -1;\n    let mut smallest_even_index38 = -1;\n    let mut smallest_even_index39\
    \ = -1;\n    let mut smallest_even_index40 = -1;\n    let mut smallest_even_index41\
    \ = -1;\n    let mut smallest_even_index42 = -1;\n    let mut smallest_even_index43\
    \ = -1;\n    let mut smallest_even_index44 = -1;\n    let mut smallest_even_index45\
    \ = -1;\n    let mut smallest_even_index\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk8fryvk5.rs:76:32\n   |\n\
    76 |     let mut smallest_even_index\n   |                                ^ help:\
    \ add `;` here\n77 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk8fryvk5.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            }\n            min_value =\
    \ i;\n        }\n    }\n    min_idx\n        .iter()\n        .cloned()\n    \
    \    .filter(|&x| x % 2 == 0)\n        .cloned()\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jh787hh.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7jh787hh.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n32 |                 min_idx = i;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 min_idx = *i;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jh787hh.rs:34:25\n\
    \   |\n27 |     let mut min_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n34 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0599]: no method named `iter` found for type\
    \ `{integer}` in the current scope\n  --> /tmp/tmp7jh787hh.rs:38:10\n   |\n38\
    \ |         .iter()\n   |          ^^^^ method not found in `{integer}`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            } else {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_value = even_values[0];\n        let mut smallest_index\
    \ = even_values[0];\n        for i in even_values.iter().rev() {\n           \
    \ if i < smallest_value {\n                smallest_value = i;\n             \
    \   smallest_index = i;\n            }\n        }\n        return vec![smallest_value,\
    \ smallest_index];\n    }\n    return vec![];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmxxwnjo4.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpmxxwnjo4.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpmxxwnjo4.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpmxxwnjo4.rs:37:17\n   |\n37 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpmxxwnjo4.rs:38:17\n   |\n38 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            min_value\
    \ = i;\n            min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpok0madog.rs:31:25\n   |\n\
    27 |     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n31 |             min_value = i;\n   |              \
    \           ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n31 |             min_value = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpok0madog.rs:32:23\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n32 |             min_idx = i;\n   |                    \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |             min_idx = *i;\n   |                       +\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n           \
    \ if min_value > i {\n                min_value = i;\n                min_idx\
    \ = i;\n            }\n        } else {\n            if min_value > i {\n    \
    \            min_value = i;\n                min_idx2 = i;\n            }\n  \
    \      }\n    }\n    if min_idx2 == min_idx {\n        return vec![min_value,\
    \ min_idx];\n    }\n    if min_idx2 < min_idx {\n        return vec![min_value,\
    \ min_idx2];\n    }\n    return vec![min_value, min_idx];\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6uuyzsyj.rs:35:28\n   |\n\
    35 |             if min_value > i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             if min_value > *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6uuyzsyj.rs:36:29\n   |\n30 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n36 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    36 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6uuyzsyj.rs:37:27\n   |\n31 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n37 |   \
    \              min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n37 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6uuyzsyj.rs:40:28\n   |\n40 |             if\
    \ min_value > i {\n   |                            ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |             if min_value\
    \ > *i {\n   |                            +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6uuyzsyj.rs:41:29\n   |\n30 |     let mut min_value = arr[0];\n\
    \   |                         ------ expected due to this value\n...\n41 |   \
    \              min_value = i;\n   |                             ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n41 |  \
    \               min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6uuyzsyj.rs:42:28\n   |\n32 |     let mut min_idx2\
    \ = 0;\n   |                        - expected due to this value\n...\n42 |  \
    \               min_idx2 = i;\n   |                            ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider deref"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value\
    \ < i {\n                min_value = i;\n                min_idx = i;\n      \
    \      }\n        }\n    }\n    if min_value == isize::MAX {\n        return Vec::new();\n\
    \    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4hk7buca.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    let mut mut_arr = arr.iter().cloned().collect::<Vec<_>>();\n    for i in\
    \ mut_arr.iter_mut() {\n        if *i < *min_val {\n            min_val = *i;\n\
    \            min_idx = i;\n        }\n    }\n    mut_arr[min_idx].cloned()\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `i32` cannot be dereferenced\n  --> /tmp/tmpc7q0x7b5.rs:31:17\n\
    \   |\n31 |         if *i < *min_val {\n   |                 ^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc7q0x7b5.rs:32:23\n   |\n27 |     let mut min_val\
    \ = i32::MAX;\n   |                       -------- expected due to this value\n\
    ...\n32 |             min_val = *i;\n   |                       ^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc7q0x7b5.rs:33:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n33 |             min_idx = i;\n   |                \
    \       ^ expected integer, found `&mut isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |             min_idx = *i;\n   |                     \
    \  +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpc7q0x7b5.rs:28:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0599]: `isize` is not an\
    \ iterator\n  --> /tmp/tmpc7q0x7b5.rs:36:22\n   |\n36 |     mut_arr[min_idx].cloned()\n\
    \   |                      ^^^^^^ `isize` is not an iterator\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `isize: Iterator`\n\
    \           which is required by `&mut isize: Iterator`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n\
    \    for i in arr.iter() {\n        if *i < *min_value {\n            min_value\
    \ = *i;\n            min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `i32` cannot be dereferenced\n  --> /tmp/tmpjoi3z644.rs:30:17\n\
    \   |\n30 |         if *i < *min_value {\n   |                 ^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjoi3z644.rs:31:25\n   |\n27 |  \
    \   let mut min_value = i32::MAX;\n   |                         -------- expected\
    \ due to this value\n...\n31 |             min_value = *i;\n   |             \
    \            ^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjoi3z644.rs:32:23\n   |\n28 |     let mut min_idx = 0;\n   |  \
    \                     - expected due to this value\n...\n32 |             min_idx\
    \ = i;\n   |                       ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n32 |             min_idx = *i;\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjoi3z644.rs:35:10\n\
    \   |\n35 |     vec![min_value, min_idx]\n   |          ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n35 |     vec![min_value.try_into().unwrap(),\
    \ min_idx]\n   |                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_value_index = isize::MAX;\n    for &value in\
    \ arr {\n        if value % 2 == 0 {\n            even_values.push(value);\n \
    \           if value < min_value {\n                min_value = value;\n     \
    \           min_value_index = arr.iter().position(|&x| x == value).unwrap();\n\
    \            }\n        }\n    }\n    if even_values.is_empty() {\n        return\
    \ Vec::new();\n    }\n    even_values.sort_unstable();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5eojznte.rs:30:9\n   |\n\
    30 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5eojznte.rs:35:35\n   |\n29 |     let mut min_value_index\
    \ = isize::MAX;\n   |                               ---------- expected due to\
    \ this value\n...\n35 |                 min_value_index = arr.iter().position(|&x|\
    \ x == value).unwrap();\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5eojznte.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_val = even_values[0];\n    let mut\
    \ smallest_even_val = smallest_index;\n    for &i in even_values {\n        if\
    \ i % 2 == 0 {\n            if i < smallest_even_val {\n                smallest_even_val\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_even_val, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvynccvz.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyvynccvz.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_val < i {\n\
    \                min_val = i;\n                min_idx = i;\n            }\n \
    \       }\n    }\n    if min_val == i32::MAX {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for i in arr {\n        if i == min_val {\n\
    \            result.push(min_idx);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4xlms8dq.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4xlms8dq.rs:42:17\n   |\n42 |         if i == min_val {\n   | \
    \                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    42 |         if i == min_val.try_into().unwrap() {\n   |                     \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xlms8dq.rs:46:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n46\
    \ |     result\n   |     ^^^^^^ expected `isize`, found `i32`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<i32>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    even_values.remove(smallest_even_index);\n\
    \    even_values.insert(0, smallest_even_value);\n    even_values\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqd54c2h1.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqd54c2h1.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqd54c2h1.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpqd54c2h1.rs:45:14\n   |\n45 |         if i % 2 == 0 {\n   |   \
    \         - ^ - {integer}\n   |            |\n   |            &&isize\n   |\n\
    help: `%` can be used on `isize`, you can dereference `i`\n   |\n45 |        \
    \ if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqd54c2h1.rs:46:20\n   |\n46 |             if i < smallest_even_value\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd54c2h1.rs:52:24\n\
    \   |\n52 |     even_values.remove(smallest_even_index);\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqd54c2h1.rs:54:5\n   |\n26 | fn pluck(arr: "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index\
    \ = -1;\n    let mut smallest_even_index_in_arr = -1;\n    let mut smallest_even_index_in_arr_with_no_even_values\
    \ = -1;\n    let mut smallest_even_index_in_arr_with_no_even_values_index = -1;\n\
    \    let mut smallest_even_index_in_arr_with_no_even_values_index_in_arr = -1;\n\
    \    let mut smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values\
    \ = -1;\n    let mut smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_index\
    \ = -1;\n    for &mut node in arr.iter_mut() {\n        if node.value % 2 == 0\
    \ {\n            if smallest_even_index == -1 || smallest_even_index > node.value\
    \ {\n                smallest_even_index = node.value;\n                smallest_even_index_in_arr\
    \ = node.index;\n            }\n            if smallest_even_index_in_arr == -1\
    \ || smallest_even_index_in_arr > node.value {\n                smallest_even_index_in_arr\
    \ = node.index;\n            }\n            if smallest_even_index_in_arr_with_no_even_values\
    \ == -1 || smallest_even_index_in_arr_with_no_even_values > node.value {\n   \
    \             smallest_even_index_in_arr_with_no_even_values = node.index;\n \
    \           }\n            if smallest_even_index_in_arr_with_no_even_values_index\
    \ == -1 || smallest_even_index_in_arr_with_no_even_values_index > node.value {\n\
    \                smallest_even_index_in_arr_with_no_even_values_index = node.index;\n\
    \            }\n            if smallest_even_index_in_arr_with_no_even_values_index_in_arr\
    \ == -1 || smallest_even_index_in_arr_with_no_even_values_index_in_arr > node.value\
    \ {\n                smallest_even_index_in_arr_with_no_even_values_index_in_arr\
    \ = node.index;\n            }\n            if smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values\
    \ == -1 || smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values\
    \ > node.value {\n                smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values\
    \ = node.index;\n            }\n            if smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_index\
    \ == -1 || smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_index\
    \ > node.value {\n                smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxcn4q0de.rs:70:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n35 |     for &mut node in arr.iter_mut()\
    \ {\n   |                                     - unclosed delimiter\n36 |     \
    \    if node.value % 2 == 0 {\n   |                                - unclosed\
    \ delimiter\n...\n56 |             if smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_index\
    \ == -1 || smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_index\
    \ > node.value {\n   |                                                       \
    \                                                                            \
    \                                                                            \
    \   - this delimiter might not be properly closed...\n57 |                 smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_\n\
    58 | }\n   | - ...as it matches this but it has different indentation\n...\n70\
    \ | }\n   |   ^\n\nerror[E0425]: cannot find value `smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_`\
    \ in this scope\n  --> /tmp/tmpxcn4q0de.rs:57:17\n   |\n57 |                 smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values_\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `smallest_even_index_in_arr_with_no_even_values_index_in_arr_with_no_even_values`\n\
    \nerror[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpxcn4q0de.rs:36:17\n   |\n36 |         if node.value % 2 == 0 {\n\
    \   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpxcn4q0de.rs:37:72\n   |\n37 |           \
    \  if smallest_even_index == -1 || smallest_even_index > node.value {\n   |  \
    \                                                                      ^^^^^\n\
    \nerror[E06"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_index\
    \ = isize::MAX;\n    let mut result = Vec::new();\n    for &i in arr {\n     \
    \   if i % 2 == 0 {\n            if min_value == isize::MAX {\n              \
    \  min_value = i;\n                min_index = i;\n            } else {\n    \
    \            if i < min_value {\n                    min_value = i;\n        \
    \            min_index = i;\n                }\n            }\n        }\n   \
    \ }\n    if min_value == isize::MAX {\n        return result;\n    }\n    result.push(min_value);\n\
    \    result.push(min_index);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp6ouqjxw.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 101
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 1;\n\
    \    let mut min_idx2 = 1;\n    for &x in arr.iter().rev() {\n        if x % 2\
    \ == 0 {\n            min_value = x;\n            min_idx = min_idx2;\n      \
    \      min_idx2 = x;\n        }\n        if x == min_value {\n            min_idx2\
    \ = x;\n        }\n    }\n    let mut res = Vec::new();\n    res.push(min_value);\n\
    \    res.push(min_idx);\n    res.push(min_idx2);\n    res\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 4]`,\n right: `[2, 1]`', /tmp/tmp9qgwr_ls.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = -1;\n\
    \    let mut even_values = Vec::new();\n    for i in arr.iter() {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n            if min_value ==\
    \ i32::MAX {\n                min_value = i;\n                min_idx = i;\n \
    \           }\n        } else {\n            if min_value < i {\n            \
    \    min_value = i;\n                min_idx = i;\n            }\n        }\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut even_values_iter = even_values.iter();\n    let mut smallest_value = even_values_iter.next().unwrap();\n\
    \    let mut smallest_idx = -1;\n    for i in even_values_iter {\n        if i\
    \ == smallest_value {\n            smallest_idx = i;\n        }\n    }\n    vec![smallest_value,\
    \ smallest_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp69b9alj.rs:34:29\n   |\n\
    27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n34 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp69b9alj.rs:35:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n35 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp69b9alj.rs:38:28\n   |\n38 |             if\
    \ min_value < i {\n   |                            ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp69b9alj.rs:39:29\n   |\n27 |\
    \     let mut min_value = i32::MAX;\n   |                         -------- expected\
    \ due to this value\n...\n39 |                 min_value = i;\n   |          \
    \                   ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp69b9alj.rs:40:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n40 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n40 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp69b9alj.rs:52:28\n   |\n49 |     let mut smallest_idx\
    \ = -1;\n   |                            -- expected due to this value\n...\n\
    52 |             smallest_idx = i;\n   |                            ^ expected\
    \ integer, found `&&isize`\n   |\nhelp: consider dereferencing the borrow\n  \
    \ |\n52 |             smallest_idx = **i;\n   |                            ++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp69b9alj.rs:55:10\n   |\n55 |\
    \     vec![smallest_value, smallest_idx]\n   |          ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 =\
    \ 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7\
    \ = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10\
    \ = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13\
    \ = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16\
    \ = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19\
    \ = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22\
    \ = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25\
    \ = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28\
    \ = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31\
    \ = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34\
    \ = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37\
    \ = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40\
    \ = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43\
    \ = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46\
    \ = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49\
    \ = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52\
    \ = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55\
    \ = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58\
    \ = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61\
    \ = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63 = 0;\n    let mut min_idx\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1kwtwr9w.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1kwtwr9w.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_index = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ < i {\n                min_value = i;\n                min_index = i;\n    \
    \        }\n        }\n    }\n    vec![min_value, min_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0hcr_cgm.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hcr_cgm.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hcr_cgm.rs:33:29\n   |\n28 |     let mut min_index\
    \ = 0;\n   |                         - expected due to this value\n...\n33 | \
    \                min_index = i;\n   |                             ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_index = *i;\n   |                             +\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_idx = 0;\n    for i in 1..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp911by8ww.rs:38:21\n   |\n\
    38 |     vec![min_value, min_idx]\n   |                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n38 |     vec![min_value, min_idx.try_into().unwrap()]\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    let mut current_index =\
    \ 0;\n    let mut current_value = vec![];\n    for value in arr {\n        if\
    \ value % 2 == 0 {\n            even_values.push(value);\n        }\n        if\
    \ value < smallest_value.len() {\n            smallest_value.push(value);\n  \
    \      }\n        if value < even_values.len() {\n            smallest_index.push(current_index);\n\
    \        }\n        current_index += 1;\n        current_value.push(value);\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if\
    \ even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n    if\
    \ even_values.len() > 1 {\n        let mut smallest_even_value = even_values[0];\n\
    \        let mut smallest_even_index = smallest_index[0];\n        for value in\
    \ even_values {\n            if value < smallest_even_value {\n              \
    \  smallest_even_value = value;\n                smallest_even_index = current_index;\n\
    \            }\n            current_index += 1;\n            current_value.push(value);\n\
    \        }\n        smallest_value.push(smallest_even_value);\n        smallest_index.push(smallest_even_index);\n\
    \    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9uh4obo.rs:36:20\n   |\n\
    36 |         if value < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n36 |         if\
    \ value < smallest_value.len().try_into().unwrap() {\n   |                   \
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf9uh4obo.rs:39:20\n   |\n39 |         if value < even_values.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n39 |         if value < even_values.len().try_into().unwrap()\
    \ {\n   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf9uh4obo.rs:65:10\n   |\n65 |     vec![smallest_value,\
    \ smallest_index]\n   |          ^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_value\
    \ == isize {\n                min_value = i;\n                min_idx = i;\n \
    \           } else {\n                if min_value > i {\n                   \
    \ min_value = i;\n                    min_idx = i;\n                }\n      \
    \      }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpl1gfcfk0.rs:31:29\n\
    \   |\n31 |             if min_value == isize {\n   |                        \
    \     ^^^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl1gfcfk0.rs:32:29\n\
    \   |\n27 |     let mut min_value = isize::MAX;\n   |                        \
    \ ---------- expected due to this value\n...\n32 |                 min_value =\
    \ i;\n   |                             ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n32 |                 min_value\
    \ = *i;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl1gfcfk0.rs:33:27\n   |\n28 |     let mut min_idx = -1;\n   | \
    \                      -- expected due to this value\n...\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl1gfcfk0.rs:35:32\n   |\n35 |                 if min_value > i\
    \ {\n   |                                ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 if\
    \ min_value > *i {\n   |                                +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl1gfcfk0.rs:36:33\n   |\n27 |     let mut min_value = isize::MAX;\n\
    \   |                         ---------- expected due to this value\n...\n36 |\
    \                     min_value = i;\n   |                                 ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    36 |                     min_value = *i;\n   |                               \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl1gfcfk0.rs:37:31\n   |\n\
    28 |     let mut min_idx = -1;\n   |                       -- expected due to\
    \ this value\n...\n37 |                     min_idx = i;\n   |               \
    \                ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |                     "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = vec![0];\n    let mut smallest_index = vec![0];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = 0;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut smallest_value_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_index_iter = smallest_index.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut smallest_value = vec![0];\n    let mut smallest_index = vec![0];\n\
    \    for i in even_values.iter() {\n        if i < smallest_value.len() {\n  \
    \          smallest_value[i] = i;\n            smallest_index[i] = 0;\n      \
    \  }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value[0]\
    \ {\n            smallest_value[0] += 1;\n            smallest_index[0] += 1;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if \n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpakuxbgzb.rs:120:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n106 |     for i in even_values.iter()\
    \ {\n    |                                 - this delimiter might not be properly\
    \ closed...\n107 |         if \n108 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n120 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n   --> /tmp/tmpakuxbgzb.rs:108:1\n    |\n108 | }\n    | ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpakuxbgzb.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmpakuxbgzb.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmpakuxbgzb.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = 0;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpakuxbgzb.rs:47:16\n   |\n47 |\
    \         if i < smallest_value.len() {\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&&isize`\n  --> /tmp/tmpakuxbgzb.rs:48:13\n   |\n48 |       \
    \      "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n        if i\
    \ % 2 == 0 {\n            even_values.push(i);\n            if i < min_value {\n\
    \                min_value = i;\n                min_idx = even_values.len() -\
    \ 1;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n     \
    \   return vec![];\n    }\n    let mut smallest_value = even_values[min_idx];\n\
    \    let mut smallest_idx = min_idx;\n    for &i in even_values {\n        if\
    \ i < smallest_value {\n            smallest_value = i;\n            smallest_idx\
    \ = even_values.len() - 1;\n        }\n    }\n    even_values.remove(&mut smallest_idx);\n\
    \    even_values.sort();\n    even_values\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp276eiu_g.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp276eiu_g.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp276eiu_g.rs:50:24\n   |\n50 |     even_values.remove(&mut smallest_idx);\n\
    \   |                        ^^^^^^^^^^^^^^^^^ expected `usize`, found `&mut usize`\n\
    \   |\nhelp: consider removing the borrow\n   |\n50 -     even_values.remove(&mut\
    \ smallest_idx);\n50 +     even_values.remove(smallest_idx);\n   | \n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_index\
    \ = isize::MAX;\n    let mut min_node_index = 0;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mut min_node_val = isize::MAX;\n\
    \    let mut min_node_val = isize::MAX;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg35w18n0.rs:70:11\n   |\n\
    70 |     let mu\n   |           ^ help: add `;` here\n71 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg35w18n0.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ isize::MAX;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n          \
    \  if min_value < i {\n                min_value = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_dju206d.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_dju206d.rs:32:29\n   |\n27 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n32 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_dju206d.rs:33:27\n\
    \   |\n28 |     let mut min_idx = isize::MAX;\n   |                       ----------\
    \ expected due to this value\n...\n33 |                 min_idx = i;\n   |   \
    \                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n33 |                 min_idx = *i;\n   |   \
    \                        +\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = isize::MAX;\n    let mut smallest_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = even_values.iter().position(|&x| x == i).unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    even_values.sort();\n    even_values.dedup();\n    even_values.into_iter().nth(smallest_index).unwrap()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ylaiem5.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0ylaiem5.rs:46:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n46 |     even_values.into_iter().nth(smallest_index).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_val > i {\n\
    \                min_val = i;\n                min_idx = i;\n            }\n \
    \       }\n    }\n    if min_val == i32::MAX {\n        return Vec::new();\n \
    \   }\n    let mut result = Vec::new();\n    for &i in arr {\n        if i ==\
    \ min_idx {\n            result.push(i);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd0toh2qu.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd0toh2qu.rs:41:9\n   |\n41 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: can't compare `isize` with `i32`\n\
    \  --> /tmp/tmpd0toh2qu.rs:42:14\n   |\n42 |         if i == min_idx {\n   | \
    \             ^^ no implementation for `isize == i32`\n   |\n   = help: the trait\
    \ `PartialEq<i32>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.is_empty() {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_value_and_index = Vec::new();\n\
    \    smallest_value_and_index.push(smallest_value, smallest_index);\n    for &i\
    \ in even_values {\n        if i < smallest_value {\n            smallest_value_and_index.push(i);\n\
    \        }\n    }\n    smallest_value_and_index\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kmph792.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp5kmph792.rs:43:30\n\
    \     |\n43   |     smallest_value_and_index.push(smallest_value, smallest_index);\n\
    \     |                              ^^^^ --------------  -------------- supplied\
    \ 2 arguments\n     |                              |\n     |                 \
    \             expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5kmph792.rs:44:9\n   |\n44 | \
    \    for &i in even_values {\n   |         ^^    ----------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values.iter().position(|&i| i == smallest_value);\n\
    \    even_values.remove(&mut smallest_even_value);\n    even_values.remove(&mut\
    \ smallest_even_index);\n    even_values.sort();\n    even_values.dedup();\n \
    \   even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.ded\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj297ytxx.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj297ytxx.rs:44:24\n   |\n44 |     even_values.remove(&mut smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&mut isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj297ytxx.rs:45:24\n\
    \   |\n45 |     even_values.remove(&mut smallest_even_index);\n   |          \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found mutable reference\n\
    \   |\n   = note:           expected type `usize`\n           found mutable reference\
    \ `&mut Option<usize>`\n\nerror[E0609]: no field `ded` on type `Vec<isize>`\n\
    \  --> /tmp/tmpj297ytxx.rs:91:17\n   |\n91 |     even_values.ded\n   |       \
    \          ^^^ unknown field\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_idx = isize::MAX;\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ min_value {\n                min_value = i;\n                min_idx = i;\n\
    \            }\n        }\n    }\n    if even_values.is_empty() {\n        return\
    \ Vec::new();\n    }\n    let mut even_values_sorted = even_values.clone();\n\
    \    even_values_sorted.sort();\n    let mut smallest_value = even_values_sorted[0];\n\
    \    let mut smallest_idx = even_values.iter().position(|&x| x == smallest_value);\n\
    \    if even_values.len() == 1 {\n        return vec![smallest_value, smallest_idx];\n\
    \    }\n    while even_values_sorted.len() > 1 {\n        if even_values_sorted[0]\
    \ != even_values_sorted[1] {\n            smallest_value = even_values_sorted[0];\n\
    \            smallest_idx = even_values.iter().position(|&x| x == smallest_value);\n\
    \        }\n        even_values_sorted.swap(0, 1);\n    }\n    vec![smallest_value,\
    \ smallest_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0jah0_0x.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0jah0_0x.rs:34:29\n   |\n28 |     let mut min_value\
    \ = isize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n34 |                 min_value = i;\n   |                      \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0jah0_0x.rs:35:27\n\
    \   |\n29 |     let mut min_idx = isize::MAX;\n   |                       ----------\
    \ expected due to this value\n...\n35 |                 min_idx = i;\n   |   \
    \                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |                 min_idx = *i;\n   |   \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0jah0_0x.rs:47:21\n\
    \   |\n47 |         return vec![smallest_value, smallest_idx];\n   |         \
    \            ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n47 |         return vec![*smallest_value, smallest_idx];\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0jah0_0x.rs:56:10\n\
    \   |\n56 |     vec![smallest_value, smallest_idx]\n   |          ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n56 |     vec![*smallest_value, smallest_idx]\n   |          +\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    let mut min_even_index_in_arr = -1;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_even_value < i {\n          \
    \      min_even_value = i;\n                min_even_index = i;\n            \
    \    min_even_index_in_arr = i;\n            }\n        }\n    }\n    if min_even_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut even_values = vec![];\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0],\
    \ min_even_index_in_arr];\n    }\n    let mut smallest_even_value = min_even_value;\n\
    \    let mut smallest_even_index = min_even_index;\n    for i in even_values.iter().rev()\
    \ {\n        if i < smallest_even_value {\n            smallest_even_value = i;\n\
    \            smallest_even_index = i;\n        }\n    }\n    let mut smallest_even_index_in_arr\
    \ = min_even_index_in_arr;\n    for i in even_values.iter().rev() {\n        if\
    \ i == smallest_even_value {\n            smallest_even_index_in_arr = i;\n  \
    \      }\n    }\n    vec![smallest_even_value, smallest_even_index, smallest_even_index_in_arr]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqqh_emvi.rs:32:33\n   |\n\
    32 |             if min_even_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |             if min_even_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqqh_emvi.rs:33:34\n\
    \   |\n27 |     let mut min_even_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n33 |                 min_even_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_even_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqqh_emvi.rs:34:34\n   |\n28 |     let mut min_even_index = -1;\n\
    \   |                              -- expected due to this value\n...\n34 |  \
    \               min_even_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |                 min_even_index = *i;\n   |                              \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqqh_emvi.rs:35:41\n  \
    \ |\n29 |     let mut min_even_index_in_arr = -1;\n   |                      \
    \               -- expected due to this value\n...\n35 |                 min_even_index_in_arr\
    \ = i;\n   |                                         ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |        \
    \         min_even_index_in_arr = *i;\n   |                                  \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqqh_emvi.rs:49:21\n\
    \   |\n49 |         return vec![even_values[0], min_even_index_in_arr];\n   |\
    \                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the type\n   |\n49 |         return vec![*even_values[0],\
    \ min_even_index_in_arr];\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqqh_emvi.rs:54:16\n   |\n54 |  "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values.iter().position(|&i| i == smallest_value);\n\
    \    if smallest_even_index == even_values.len() - 1 {\n        smallest_even_index\
    \ = even_values.len() - 1;\n    }\n    let mut result = Vec::new();\n    for &i\
    \ in even_values {\n        if i == smallest_value {\n            result.push(smallest_value);\n\
    \            result.push(smallest_index);\n        } else {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprm54muso.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprm54muso.rs:44:31\n   |\n44 |     if smallest_even_index == even_values.len()\
    \ - 1 {\n   |                               ^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n44 |     if smallest_even_index == Some(even_values.len() - 1) {\n   |\
    \                               +++++                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprm54muso.rs:45:31\n   |\n43 |     let mut smallest_even_index\
    \ = even_values.iter().position(|&i| i == smallest_value);\n   |             \
    \                      ----------------------------------------------------- expected\
    \ due to this value\n44 |     if smallest_even_index == even_values.len() - 1\
    \ {\n45 |         smallest_even_index = even_values.len() - 1;\n   |         \
    \                      ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n45 |         smallest_even_index\
    \ = Some(even_values.len() - 1);\n   |                               +++++   \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprm54muso.rs:48:9\n\
    \   |\n48 |     for &i in even_values {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx = i;\n            }\n            min_value =\
    \ i;\n        }\n    }\n    if min_idx == -1 {\n        vec![]\n    } else {\n\
    \        vec![min_value, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8odh2o74.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8odh2o74.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n32 |                 min_idx = i;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 min_idx = *i;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8odh2o74.rs:34:25\n\
    \   |\n27 |     let mut min_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n34 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |             min_value = *i;\n   |     \
    \                    +\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = arr[0];\n    let mut min_idx = -1;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_val < i {\n\
    \                min_val = i;\n                min_idx = i;\n            }\n \
    \       }\n    }\n    if min_val == arr[0] {\n        vec![]\n    } else {\n \
    \       vec![min_val, min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnkncei9o.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_value % 2 ==\
    \ 0 {\n                min_value = i;\n                min_idx = i;\n        \
    \    }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljjxfl92.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ < i {\n                min_value = i;\n                min_idx = i;\n      \
    \      }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsjsmjsl3.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsjsmjsl3.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsjsmjsl3.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n33 |   \
    \              min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = isize::MAX;\n    let mut min_even_index\
    \ = isize::MAX;\n    let mut even_values = Vec::new();\n    let mut even_indexes\
    \ = Vec::new();\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            even_indexes.push(i);\n            if min_even_value < i {\n    \
    \            min_even_value = i;\n                min_even_index = i;\n      \
    \      }\n        } else {\n            even_values.clear();\n            even_indexes.clear();\n\
    \        }\n    }\n    if even_values.is_empty() {\n        return even_indexes;\n\
    \    }\n    let mut smallest_even_value = even_values.iter().min().unwrap();\n\
    \    let mut smallest_even_index = even_indexes.iter().min().unwrap();\n    for\
    \ i in even_indexes {\n        if i == smallest_even_index {\n            smallest_even_index\
    \ = i;\n        }\n    }\n    even_indexes.push(smallest_even_index);\n    even_values.push(smallest_even_value);\n\
    \    even_indexes\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprexul9wn.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprexul9wn.rs:50:17\n   |\n50 |         if i == smallest_even_index\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n50 |         if i == *smallest_even_index\
    \ {\n   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprexul9wn.rs:51:35\n\
    \   |\n48 |     let mut smallest_even_index = even_indexes.iter().min().unwrap();\n\
    \   |                                   ---------------------------------- expected\
    \ due to this value\n...\n51 |             smallest_even_index = i;\n   |    \
    \                               ^\n   |                                   |\n\
    \   |                                   expected `&isize`, found `isize`\n   |\
    \                                   help: consider borrowing here: `&i`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprexul9wn.rs:54:23\n   |\n54 |     even_indexes.push(smallest_even_index);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n54 |     even_indexes.push(*smallest_even_index);\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprexul9wn.rs:55:22\n\
    \   |\n55 |     even_values.push(smallest_even_value);\n   |                 \
    \     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n55 |     even_values.push(*smallest_even_value);\n\
    \   |                      +\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n\
    \    if even_values.len() == 2 {\n        if even_values[0] < even_values[1] {\n\
    \            return vec![even_values[0]];\n        }\n        return vec![even_values[1]];\n\
    \    }\n    if even_values.len() == 3 {\n        if even_values[0] < even_values[1]\
    \ && even_values[0] < even_values[2] {\n            return vec![even_values[0]];\n\
    \        }\n        if even_values[1] < even_values[2] {\n            return vec![even_values[1]];\n\
    \        }\n        return vec![even_values[2]];\n    }\n    if even_values.len()\
    \ == 4 {\n        if even_values[0] < even_values[1] && even_values[0] < even_values[2]\
    \ && even_values[0] < even_values[3] {\n            return vec![even_values[0]];\n\
    \        }\n        if even_values[1] < even_values[2] && even_values[1] < even_values[3]\
    \ {\n            return vec![even_values[1]];\n        }\n        if even_values[2]\
    \ < even_values[3] {\n            return vec![even_values[2]];\n        }\n  \
    \      return vec![even_values[3]];\n    }\n    if even_values.len() == 5 {\n\
    \        if even_values[0] < even_values[1] && even_values[0] < even_values[2]\
    \ && even_values[0] < even_values[3] && even_values[0] < even_values[4] {\n  \
    \          return vec![even_values[0]];\n        }\n        if even_values[1]\
    \ < even_values[2] && even_values[1] < even_values[3] && even_values[1] < even_values[4]\
    \ {\n            return vec![even_values[1]];\n        }\n        if even_values[2]\
    \ < even_values[3] && even_values[2] < even_values[4] {\n            return vec![even_values[2]];\n\
    \        }\n        if even_values[3] < even_values[4] {\n            return vec![even_values[3]];\n\
    \        }\n        return vec![even_values[4]];\n    }\n    if even_values.len()\
    \ == 6 {\n        if even_values[0] < even_values[1] && even_values[0] < even_values[2]\
    \ && even_values[0] < even\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphyuhugy5.rs:101:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n87  |     if even_values.len()\
    \ == 6 {\n    |                               - this delimiter might not be properly\
    \ closed...\n88  |         if even_values[0] < even_values[1] && even_values[0]\
    \ < even_values[2] && even_values[0] < even\n89  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n101 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmphyuhugy5.rs:89:1\n   |\n88 |         if even_values[0]\
    \ < even_values[1] && even_values[0] < even_values[2] && even_values[0] < even\n\
    \   |         -- this `if` expression has a condition, but no block\n89 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphyuhugy5.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmphyuhugy5.rs:34:37\n\
    \   |\n34 |                 smallest_value.push(smallest_value[i]);\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmphyuhugy5.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tm"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value: isize = 0;\n    let mut min_even_index:\
    \ usize = 0;\n    let mut min_value: isize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_value_and_index: Vec<isize> = Vec::new();\n    let mut\
    \ even_values: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    let mut even_values_index: Vec<isize> = Vec::new();\n   \
    \ let mut even_indexes_index: Vec<usize> = Vec::new();\n    let mut even_values_index_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes_index_and_index: Vec<usize>\
    \ = Vec::new();\n    let mut even_values_index_and_index_and_index: Vec<isize>\
    \ = Vec::new();\n    let mut even_indexes_index_and_index_and_index: Vec<usize>\
    \ = Vec::new();\n    let mut even_values_index_and_index_and_index_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes_index_and_index_and_index_and_index:\
    \ Vec<usize> = Vec::new();\n    let mut even_values_index_and_index_and_index_and_index_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes_index_and_index_and_index_and_index_and_index:\
    \ Vec<usize> = Vec::new();\n    let mut even_values_index_and_index_and_index_and_index_and_index_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes_index_and_index_and_index_and_index_and_index_and_index:\
    \ Vec<usize> = Vec::new();\n    let mut even_values_index_and_index_and_index_and_index_and_index_and_index_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes_index_and_index_and_index_and_index_and_index_and_index_and_index:\
    \ Vec<usize> = Vec::new();\n    let mut even_values_index_and_index_and_index_and_index_and_index_and_index_and_index_and_index:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes_index_and_index_and_index_and_index_and_index_and_index_and_index_and_index_and_index:\
    \ Vec<usize> = Vec::new();\n    let mut even_values_index_and_index_and_index_and_index_and_index_and_index_\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzoxekero.rs:50:81\n   |\n\
    50 |     let mut even_values_index_and_index_and_index_and_index_and_index_and_index_\n\
    \   |                                                                        \
    \         ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzoxekero.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n        }\n      \
    \  if even_values.len() == 1 {\n            smallest_value.push(even_values.clone());\n\
    \            smallest_index.push(0);\n        }\n        if even_values.len()\
    \ > 1 {\n            if even_values[0] < even_values[1] {\n                smallest_value.push(even_values.clone());\n\
    \                smallest_index.push(0);\n            } else {\n             \
    \   smallest_value.push(even_values.clone());\n                smallest_index.push(1);\n\
    \            }\n        }\n    }\n    smallest_value\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeyowiq9i.rs:48:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n48 |     smallest_value\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<Vec<&isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut min_value\
    \ = isize::MAX;\n    let mut min_index = isize::MAX;\n    for &i in arr {\n  \
    \      if i % 2 == 0 {\n            even_values.push(i);\n            if i < min_value\
    \ {\n                min_value = i;\n                min_index = i;\n        \
    \    }\n        }\n    }\n    if even_values.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut min_value_pos = even_values.iter().position(|&i| i < min_value);\n\
    \    if min_value_pos == even_values.len() {\n        return Vec::new();\n   \
    \ }\n    let mut min_value_pos_index = even_values[min_value_pos];\n    let mut\
    \ min_value_pos_index = min_value_pos_index as usize;\n    let mut even_values_copy\
    \ = even_values.clone();\n    even_values_copy[min_value_pos] = isize::MAX;\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy[min_value_pos_index]\
    \ = isize::MAX;\n    let mut even_values_copy = even_values_copy.clone();\n  \
    \  even_values_copy[min_value_pos_index] = isize::MAX;\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy[min_value_pos_index] = isize::MAX;\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy[min_value_pos_index]\
    \ = isize::MAX;\n    let mut even_values_copy = even_values_copy.clone();\n  \
    \  even_values_copy[min_value_pos_index] = isize::MAX;\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy[min_value_pos_index] = isize::MAX;\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy[min_value_pos_index]\
    \ = isize::MAX;\n    let mut even_values_copy = even_values_copy.clone();\n  \
    \  even_values_copy[min_value_pos_index] = isize::MAX;\n    let mut even_values_copy\
    \ = even_values_copy.clone();\n    even_values_copy[min_value_pos_index] = isize::MAX;\n\
    \    let mut even_values_copy = even_values_copy.clone();\n    even_values_copy[min_value_pos_index]\
    \ = isize::MAX;\n    let mut even_values_copy = even_values_copy.clone();\n  \
    \  even_values_copy[min_value_pos_index] = isize::\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpnherw_t9.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected identifier\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnherw_t9.rs:30:9\n   |\n30 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnherw_t9.rs:43:25\n\
    \   |\n43 |     if min_value_pos == even_values.len() {\n   |                \
    \         ^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   =\
    \ note: expected enum `Option<usize>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n43 |     if min_value_pos == Some(even_values.len())\
    \ {\n   |                         +++++                 +\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpnherw_t9.rs:46:35\n\
    \   |\n46 |     let mut min_value_pos_index = even_values[min_value_pos];\n  \
    \ |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<isize>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpnherw_t9.rs:49:5\n\
    \   |\n49 |     even_values_copy[min_value_pos] = isize::MAX;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_even_value = arr[0];\n    let mut min_even_index\
    \ = -1;\n    let mut min_even_index_in_arr = -1;\n    let mut min_even_index_in_arr2\
    \ = -1;\n    let mut min_even_index_in_arr3 = -1;\n    let mut min_even_index_in_arr4\
    \ = -1;\n    let mut min_even_index_in_arr5 = -1;\n    let mut min_even_index_in_arr6\
    \ = -1;\n    let mut min_even_index_in_arr7 = -1;\n    let mut min_even_index_in_arr8\
    \ = -1;\n    let mut min_even_index_in_arr9 = -1;\n    let mut min_even_index_in_arr10\
    \ = -1;\n    let mut min_even_index_in_arr11 = -1;\n    let mut min_even_index_in_arr12\
    \ = -1;\n    let mut min_even_index_in_arr13 = -1;\n    let mut min_even_index_in_arr14\
    \ = -1;\n    let mut min_even_index_in_arr15 = -1;\n    let mut min_even_index_in_arr16\
    \ = -1;\n    let mut min_even_index_in_arr17 = -1;\n    let mut min_even_index_in_arr18\
    \ = -1;\n    let mut min_even_index_in_arr19 = -1;\n    let mut min_even_index_in_arr20\
    \ = -1;\n    let mut min_even_index_in_arr21 = -1;\n    let mut min_even_index_in_arr22\
    \ = -1;\n    let mut min_even_index_in_arr23 = -1;\n    let mut min_even_index_in_arr24\
    \ = -1;\n    let mut min_even_index_in_arr25 = -1;\n    let mut min_even_index_in_arr26\
    \ = -1;\n    let mut min_even_index_in_arr27 = -1;\n    let mut min_even_index_in_arr28\
    \ = -1;\n    let mut min_even_index_in_arr29 = -1;\n    let mut min_even_index_in_arr30\
    \ = -1;\n    let mut min_even_index_in_arr31 = -1;\n    let mut min_even_index_in_arr32\
    \ = -1;\n    let mut min_even_index_in_arr33 = -1;\n    let mut min_even_index_in_arr34\
    \ = -1;\n    let mut min_even_index_in_arr35 = -1;\n    let mut min_even_index_in_arr36\
    \ = -1;\n    let mut min_even_index_in_arr37 = -1;\n    let mut min_even_index_in_arr38\
    \ = -1;\n    let mut min_even_index_in_arr39 = -1;\n    let mut min_even_index_in_arr40\
    \ = -1;\n    let mut min_even_index_in_arr41 = -1;\n    let mut min_even_index_in_arr42\
    \ = -1;\n    let mut min_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg04ovhhf.rs:71:17\n   |\n\
    71 |     let mut min_\n   |                 ^ help: add `;` here\n72 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg04ovhhf.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if *i < *min_val {\n            min_val =\
    \ *i;\n            min_idx = i;\n        }\n    }\n    min_idx\n        .clone()\n\
    \        .iter()\n        .cloned()\n        .filter(|&x| x % 2 == 0)\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `i32` cannot be dereferenced\n  --> /tmp/tmprnf8znh0.rs:30:17\n\
    \   |\n30 |         if *i < *min_val {\n   |                 ^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprnf8znh0.rs:31:23\n   |\n27 |     let mut min_val\
    \ = i32::MAX;\n   |                       -------- expected due to this value\n\
    ...\n31 |             min_val = *i;\n   |                       ^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprnf8znh0.rs:32:23\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n32 |             min_idx = i;\n   |                \
    \       ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |             min_idx = *i;\n   |                     \
    \  +\n\nerror[E0599]: no method named `iter` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmprnf8znh0.rs:37:10\n   |\n37 |         .iter()\n\
    \   |          ^^^^ method not found in `{integer}`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    for &i in arr {\n      \
    \  if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value\
    \ {\n                smallest_value = i;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n    let\
    \ mut smallest_even_index = even_values[0];\n    for &i in even_values {\n   \
    \     if i < smallest_even_value {\n            smallest_even_value = i;\n   \
    \         smallest_even_index = i;\n        }\n    }\n    even_values.remove(&smallest_even_value);\n\
    \    even_values.remove(&smallest_even_index);\n    even_values.sort();\n    let\
    \ mut even_values_index = even_values.iter().cloned().collect::<Vec<_>>();\n \
    \   even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_index.sort_by_key(|&i| i);\n    let mut even_values_index = even_values_index.into_iter().cloned().collect::<\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmpkvfgku1o.rs:70:1\n   |\n69 |     let mut even_values_index\
    \ = even_values_index.into_iter().cloned().collect::<\n   |                  \
    \                                                                - expected one\
    \ of `>`, a const expression, lifetime, or type\n70 | }\n   | ^ unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkvfgku1o.rs:30:9\n   |\n30 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkvfgku1o.rs:44:9\n   |\n44 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkvfgku1o.rs:50:24\n   |\n50 |     even_values.remove(&smallest_even_value);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkvfgku1o.rs:51:24\n   |\n51 |\
    \     even_values.remove(&smallest_even_index);\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpkvfgku1o.rs:55:63\n     |\n55   |\
    \     let mut even_values_index = even_values_index.into_iter().cloned().collect::<Vec<_>>();\n\
    \     |                                                               ^^^^^^ expected\
    \ reference, found `isize`\n     |\n     = note: expected reference `&_`\n   \
    \                  found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ -1;\n    for &i in arr {\n        if i % 2 == 0 {\n            if min_value\
    \ == isize::MAX {\n                min_value = i;\n                min_idx = i;\n\
    \            } else {\n                if i < min_value {\n                  \
    \  min_value = i;\n                    min_idx = i;\n                }\n     \
    \       }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyjxt11q0.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_index = 0;\n    let mut min_even_value\
    \ = false;\n    for &v in arr.iter().rev() {\n        if v % 2 == 0 {\n      \
    \      min_even_value = true;\n            min_value = v;\n            min_index\
    \ = arr.len() - 1;\n            break;\n        }\n    }\n    if min_even_value\n\
    \        && min_value == arr[0]\n        && min_index == 0\n    {\n        return\
    \ vec![];\n    }\n    if min_even_value\n        && min_value == arr[0]\n    \
    \    && min_index != 0\n    {\n        return vec![min_value, min_index];\n  \
    \  }\n    if min_even_value\n        && min_value == arr[0]\n        && min_index\
    \ == 0\n    {\n        return vec![];\n    }\n    if min_even_value\n        &&\
    \ min_value == arr[0]\n        && min_index != 0\n    {\n        return vec![min_value,\
    \ min_index];\n    }\n    if min_even_value\n        && min_value == arr[0]\n\
    \        && min_index == 0\n    {\n        return vec![];\n    }\n    if min_even_value\n\
    \        && min_value == arr[0]\n        && min_index != 0\n    {\n        return\
    \ vec![min_value, min_index];\n    }\n    if min_even_value\n        && min_value\
    \ == arr[0]\n        && min_index == 0\n    {\n        return vec![];\n    }\n\
    \    if min_even_value\n        && min_value == arr[0]\n        && min_index !=\
    \ 0\n    {\n        return vec![min_value, min_index];\n    }\n    if min_even_value\n\
    \        && min_value == arr[0]\n        && min_index == 0\n    {\n        return\
    \ vec![];\n    }\n    if min_even_value\n        && min_value == arr[0]\n    \
    \    && min_index != 0\n    {\n        return vec![min_value, min_index];\n  \
    \  }\n    if min_even_value\n        && min_value == arr[0]\n        && min_index\
    \ == 0\n    {\n        return vec![];\n    }\n    if min_even_value\n        &&\
    \ min_value == arr[0]\n        && min_index != 0\n    {\n        return vec![min_value,\
    \ min_index];\n    }\n    if min_even_value\n        && min_value == arr[0]\n\
    \        && min_index == 0\n    {\n        return vec![];\n    }\n    if min_even_value\n\
    \        && min_value == arr[0]\n        && min_index != 0\n    {\n        return\
    \ vec![min_value, min_index];\n    }\n    if min_even_value\n        && min_value\
    \ == arr[0]\n        && min_index == 0\n    {\n        return vec![];\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwntmp1_0.rs:51:32\n   |\n\
    51 |         return vec![min_value, min_index];\n   |                        \
    \        ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    51 |         return vec![min_value, min_index.try_into().unwrap()];\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwntmp1_0.rs:63:32\n   |\n63 |         return vec![min_value,\
    \ min_index];\n   |                                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n63 |         return vec![min_value,\
    \ min_index.try_into().unwrap()];\n   |                                      \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwntmp1_0.rs:75:32\n\
    \   |\n75 |         return vec![min_value, min_index];\n   |                 \
    \               ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n75 |         return vec![min_value, min_index.try_into().unwrap()];\n \
    \  |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwntmp1_0.rs:87:32\n   |\n87 |         return\
    \ vec![min_value, min_index];\n   |                                ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n87 |         return vec![min_value,\
    \ min_index.try_into().unwrap()];\n   |                                      \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwntmp1_0.rs:99:32\n\
    \   |\n99 |         return vec![min_value, min_index];\n   |                 \
    \               ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n99 |         return vec![min_valu"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if i < smallest_even_value {\n     \
    \           smallest_even_value = i;\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    vec![smallest_value, smallest_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9hvbrycz.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9hvbrycz.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9hvbrycz.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmp9hvbrycz.rs:45:14\n   |\n45 |         if i % 2 == 0 {\n   |   \
    \         - ^ - {integer}\n   |            |\n   |            &&isize\n   |\n\
    help: `%` can be used on `isize`, you can dereference `i`\n   |\n45 |        \
    \ if *i % 2 == 0 {\n   |            +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9hvbrycz.rs:46:20\n   |\n46 |             if i < smallest_even_value\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9hvbrycz.rs:52:26\n\
    \   |\n52 |     vec![smallest_value, smallest_even_index]\n   |              \
    \            ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n52 |     vec![smallest_value, *sma"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2z95rzu8.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = arr[0];\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_val\
    \ < i {\n                min_val = i;\n                min_idx = i;\n        \
    \    }\n        }\n    }\n    if min_val == arr[0] {\n        vec![]\n    } else\
    \ {\n        vec![min_val, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgcj485yl.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           if min_val < *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgcj485yl.rs:32:27\n   |\n27 |     let mut min_val\
    \ = arr[0];\n   |                       ------ expected due to this value\n...\n\
    32 |                 min_val = i;\n   |                           ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \               min_val = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgcj485yl.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n    let mut smallest_even_index\
    \ = -1;\n    let mut smallest_even_index_in_arr = 0;\n    for &i in arr {\n  \
    \      if i % 2 == 0 {\n            if smallest_even_index == -1 || smallest_even_index\
    \ > i {\n                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n                smallest_even_index_in_arr = i;\n            } else {\n\
    \                if smallest_even_index == i {\n                    smallest_even_index_in_arr\
    \ += 1;\n                }\n            }\n        }\n    }\n    if smallest_even_index\
    \ == -1 {\n        return Vec::new();\n    }\n    let mut result = Vec::new();\n\
    \    for i in 0..smallest_even_index_in_arr {\n        result.push(smallest_even_value);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2mish4wr.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut smallest_value = isize::MAX;\n    let mut smallest_index\
    \ = 0;\n    let mut even_values = Vec::new();\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n        }\n        if i < smallest_value\
    \ {\n            smallest_value = i;\n            smallest_index = i;\n      \
    \  }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values[0];\n    for i in even_values.iter().rev() {\n        if i % 2\
    \ == 0 {\n            if smallest_even_value < i {\n                smallest_even_value\
    \ = i;\n                smallest_even_index = i;\n            }\n        }\n \
    \   }\n    vec![smallest_even_value, smallest_even_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0vwp2nxk.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0vwp2nxk.rs:46:38\n   |\n46 |             if smallest_even_value\
    \ < i {\n   |                                      ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n46 |             if smallest_even_value\
    \ < *i {\n   |                                      +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0vwp2nxk.rs:47:39\n   |\n42 |     let mut smallest_even_value\
    \ = even_values[0];\n   |                                   -------------- expected\
    \ due to this value\n...\n47 |                 smallest_even_value = i;\n   |\
    \                                       ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n47 |                 smallest_even_value\
    \ = *i;\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0vwp2nxk.rs:48:39\n   |\n43 |     let mut smallest_even_index\
    \ = even_values[0];\n   |                                   -------------- expected\
    \ due to this value\n...\n48 |                 smallest_even_index = i;\n   |\
    \                                       ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n48 |                 smallest_even_index\
    \ = *i;\n   |                                       +\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     return vec![even_values[0]];\n    }\n    if even_values.len() > 1 {\n  \
    \      let mut smallest_even_value = even_values[0];\n        let mut smallest_even_index\
    \ = even_values[0];\n        for i in even_values.iter().rev() {\n           \
    \ if i % 2 == 0 {\n                if i < smallest_even_value {\n            \
    \        smallest_even_value = i;\n                    smallest_even_index = i;\n\
    \                }\n            }\n        }\n        smallest_value.push(smallest_even_value);\n\
    \        smallest_index.push(smallest_even_index);\n    }\n    smallest_value\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi7nzncxj.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpi7nzncxj.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpi7nzncxj.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7nzncxj.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpi7nzncxj.rs:49:18\n\
    \   |\n49 |             if i % 2 == 0 {\n   |                - ^ - {integer}\n\
    \   |                |\n   |                &&isize\n   |\nhelp: `%` can be used\
    \ on `isize`, you can dereference `i`\n   |\n49 |             if *i % 2 == 0 {\n\
    \   |                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7nzncxj.rs:50:24\n\
    \   |\n50 |                 if i < smallest_even_value {\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n   |\n   = note:\
    \ expected reference `&&isize`\n              found reference `&isize`\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    let mut min_even_val = i32::MAX;\n    let mut min_even_idx = -1;\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            if min_even_val < i\
    \ {\n                min_even_val = i;\n                min_even_idx = i;\n  \
    \          }\n        } else {\n            if min_val < i {\n               \
    \ min_val = i;\n                min_idx = i;\n            }\n        }\n    }\n\
    \    if min_even_val == i32::MAX {\n        return vec![];\n    }\n    return\
    \ vec![min_even_val, min_even_idx];\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtofscjs.rs:33:31\n   |\n\
    33 |             if min_even_val < i {\n   |                               ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtofscjs.rs:34:32\n\
    \   |\n29 |     let mut min_even_val = i32::MAX;\n   |                       \
    \     -------- expected due to this value\n...\n34 |                 min_even_val\
    \ = i;\n   |                                ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxtofscjs.rs:35:32\n   |\n30 |\
    \     let mut min_even_idx = -1;\n   |                            -- expected\
    \ due to this value\n...\n35 |                 min_even_idx = i;\n   |       \
    \                         ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |                 min_even_idx = *i;\n  \
    \ |                                +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxtofscjs.rs:38:26\n   |\n38 |             if min_val < i {\n   |   \
    \                       ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxtofscjs.rs:39:27\n   |\n27 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n39 |   \
    \              min_val = i;\n   |                           ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtofscjs.rs:40:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n40 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n40 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtofscjs.rs:47:17\n\
    \   |\n47 |     return vec![min_even_val, min_even_idx];\n   |               \
    \  ^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert an\
    \ `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n47 |\
    \     return vec![min_even_val.try_into().unwrap(), min_even_idx];\n   |"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value.push(i);\n          \
    \      smallest_index.push(i);\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     return vec![even_values[0]];\n    }\n    if even_values.len() > 1 {\n  \
    \      let mut smallest_value = even_values[0];\n        let mut smallest_index\
    \ = even_values[0];\n        for i in even_values.iter().rev() {\n           \
    \ if i < smallest_value {\n                smallest_value = i;\n             \
    \   smallest_index = i;\n            }\n        }\n        return vec![smallest_value,\
    \ smallest_index];\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ey9n_9y.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ey9n_9y.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7ey9n_9y.rs:49:20\n   |\n49 |\
    \             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7ey9n_9y.rs:54:21\n   |\n54 |         return vec![smallest_value, smallest_index];\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n54 |         return vec![*smallest_value,\
    \ smallest_index];\n   |                     +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = arr[0];\n    let mut min_idx = 0;\n\
    \    let mut min_idx = arr.iter().enumerate().min_by(|a, b| a.1.cmp(&b.1));\n\
    \    if min_idx == None {\n        return Vec::new();\n    }\n    for i in min_idx.0..arr.len()\
    \ {\n        if arr[i] < min_value {\n            min_value = arr[i];\n      \
    \      min_idx = i;\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `Option<(usize, &isize)>`\n  --> /tmp/tmp2wn2xhzl.rs:33:22\n\
    \   |\n33 |     for i in min_idx.0..arr.len() {\n   |                      ^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2wn2xhzl.rs:36:23\n   |\n29 |\
    \     let mut min_idx = arr.iter().enumerate().min_by(|a, b| a.1.cmp(&b.1));\n\
    \   |                       ---------------------------------------------------\
    \ expected due to this value\n...\n36 |             min_idx = i;\n   |       \
    \                ^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<(usize, &isize)>`\n              found type `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2wn2xhzl.rs:39:21\n   |\n39 |     vec![min_value,\
    \ min_idx]\n   |                     ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<(usize,\
    \ &isize)>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ i < smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    even_values.sort_unstable_by_key(|x| x);\n  \
    \  even_values.dedup();\n    even_values.into_iter().map(|x| x).collect()\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkja7vafv.rs:33:20\n   |\n\
    33 |             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkja7vafv.rs:34:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n34 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkja7vafv.rs:35:34\n   |\n29 |     let mut smallest_index = isize::MAX;\n\
    \   |                              ---------- expected due to this value\n...\n\
    35 |                 smallest_index = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |                 smallest_index = *i;\n   |              \
    \                    +\n\nerror[E0277]: a value of type `Vec<isize>` cannot be\
    \ built from an iterator over elements of type `&isize`\n    --> /tmp/tmpkja7vafv.rs:44:40\n\
    \     |\n44   |     even_values.into_iter().map(|x| x).collect()\n     |     \
    \                                   ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    even_values.sort();\n    even_values.dedup();\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    for &i in even_values\
    \ {\n        if i == smallest_index {\n            result.push(smallest_value);\n\
    \            break;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ibmk9qo.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4ibmk9qo.rs:46:9\n   |\n46 |     for &i in even_values {\n   |\
    \         ^^    ----------- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = i32::MAX;\n    let mut min_idx = 0;\n\
    \    let mut min_node = None;\n    for i in arr.iter() {\n        if *i < *min_value\
    \ {\n            min_value = *i;\n            min_idx = i;\n            min_node\
    \ = Some(i);\n        }\n    }\n    if min_node.is_none() {\n        vec![]\n\
    \    } else {\n        vec![min_value, min_idx]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `i32` cannot be dereferenced\n  --> /tmp/tmp_avzkzt4.rs:31:17\n\
    \   |\n31 |         if *i < *min_value {\n   |                 ^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_avzkzt4.rs:32:25\n   |\n27 |  \
    \   let mut min_value = i32::MAX;\n   |                         -------- expected\
    \ due to this value\n...\n32 |             min_value = *i;\n   |             \
    \            ^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_avzkzt4.rs:33:23\n   |\n28 |     let mut min_idx = 0;\n   |  \
    \                     - expected due to this value\n...\n33 |             min_idx\
    \ = i;\n   |                       ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n33 |             min_idx = *i;\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_avzkzt4.rs:40:14\n\
    \   |\n40 |         vec![min_value, min_idx]\n   |              ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n40 |         vec![min_value.try_into().unwrap(),\
    \ min_idx]\n   |                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = isize::MAX;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value {\n                smallest_value = i;\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return Vec::new();\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values.iter().position(|&i| i == smallest_value);\n\
    \    even_values.retain(|&i| i != smallest_value);\n    even_values.retain(|&i|\
    \ i != smallest_index);\n    even_values.retain(|&i| i != smallest_even_value);\n\
    \    even_values.retain(|&i| i != smallest_even_index);\n    even_values.retain(|&i|\
    \ i != smallest_even_index);\n    even_values.retain(|&i| i != smallest_even_index);\n\
    \    even_values.retain(|&i| i != smallest_even_index);\n    even_values.retain(|&i|\
    \ i != smallest_even_index);\n    even_values.retain(|&i| i != smallest_even_index);\n\
    \    even_values.retain(|&i| i != smallest_even_index);\n    even_values.retain(|&i|\
    \ i != smallest_even_index);\n    even_values.retain(|&i| i != smallest_even_index);\n\
    \    even_values.retain(|&i| i != smallest_even_index);\n    even_values.retain(|&i|\
    \ i != smallest_even_index);\n    even_values.retain(|&i| i != smallest_even_index);\n\
    \    even_values.retain(|&i| i != smallest_even_index);\n    even_values.retain(|&i|\
    \ i != smallest_even_index);\n    even_values.retain(|&i| i != smallest_even_index);\n\
    \    even_values.retain(|&i| i != smallest_even_index);\n    even_values.retain(|&i|\
    \ i != smallest_even_index);\n    even_values.retain(|&i| i != smallest_even_index);\n\
    \    even_values.retain(|&i| i != \n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpxwj3dd7x.rs:66:1\n\
    \   |\n66 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpxwj3dd7x.rs:65:23\n   |\n26 | fn pluck(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                         - closing delimiter\
    \ possibly meant for this\n...\n65 |     even_values.retain(|&i| i != \n   | \
    \                      ^ unclosed delimiter\n66 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwj3dd7x.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxwj3dd7x.rs:47:34\n   |\n47 |     even_values.retain(|&i|\
    \ i != smallest_even_index);\n   |                                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwj3dd7x.rs:48:34\n   |\n48 |     even_values.retain(|&i| i !=\
    \ smallest_even_index);\n   |                                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwj3dd7x.rs:49:34\n   |\n49 |     even_values.retain(|&i| i !=\
    \ smallest_even_index);\n   |                                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwj3dd7x.rs:50:34\n   |\n50 |     even_values.retain(|&i| i !=\
    \ smallest_even_index);\n   |                                  ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: m"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ -1;\n    let mut min_idx2 = -1;\n    for i in arr.iter() {\n        if i.is_even()\
    \ {\n            if min_value == isize {\n                min_value = i;\n   \
    \             min_idx = i;\n                min_idx2 = i;\n            } else\
    \ {\n                if min_value > i {\n                    min_value = i;\n\
    \                    min_idx = i;\n                    min_idx2 = i;\n       \
    \         }\n            }\n        }\n    }\n    if min_idx2 == min_idx {\n \
    \       min_idx2 = min_idx;\n    }\n    vec![min_value, min_idx2]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmparzvll0_.rs:32:29\n\
    \   |\n32 |             if min_value == isize {\n   |                        \
    \     ^^^^^ not a value\n\nerror[E0599]: no method named `is_even` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmparzvll0_.rs:31:14\n   |\n31 | \
    \        if i.is_even() {\n   |              ^^^^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmparzvll0_.rs:33:29\n   |\n27 |\
    \     let mut min_value = isize::MAX;\n   |                         ----------\
    \ expected due to this value\n...\n33 |                 min_value = i;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n33 |                 min_value = *i;\n   | \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmparzvll0_.rs:34:27\n\
    \   |\n28 |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n34 |                 min_idx = i;\n   |            \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmparzvll0_.rs:35:28\n\
    \   |\n29 |     let mut min_idx2 = -1;\n   |                        -- expected\
    \ due to this value\n...\n35 |                 min_idx2 = i;\n   |           \
    \                 ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_idx2 = *i;\n   |                \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmparzvll0_.rs:37:32\n\
    \   |\n37 |                 if min_value > i {\n   |                         \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n37 |                 if min_value > *i {\n   |           \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmparzvll0_.rs:38:33\n\
    \   |\n27 |     let mut min_value = isize::MAX;\n   |                        \
    \ ---------- expected due to thi"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = arr[0];\n    let mut min_idx = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_val\
    \ < i {\n                min_val = i;\n                min_idx = i;\n        \
    \    }\n        }\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj14qpk0p.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           if min_val < *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj14qpk0p.rs:32:27\n   |\n27 |     let mut min_val\
    \ = arr[0];\n   |                       ------ expected due to this value\n...\n\
    32 |                 min_val = i;\n   |                           ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \               min_val = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj14qpk0p.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_value = isize::MAX;\n    let mut min_idx =\
    \ 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4\
    \ = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7\
    \ = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10\
    \ = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13\
    \ = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16\
    \ = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19\
    \ = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22\
    \ = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25\
    \ = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28\
    \ = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31\
    \ = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34\
    \ = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37\
    \ = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40\
    \ = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43\
    \ = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46\
    \ = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49\
    \ = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52\
    \ = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55\
    \ = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58\
    \ = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61\
    \ = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63 = 0;\n    let mu\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqrofg6x1.rs:91:11\n   |\n\
    91 |     let mu\n   |           ^ help: add `;` here\n92 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrofg6x1.rs:26:30\n \
    \  |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     smallest_value[0] = even_values[0];\n        smallest_index[0] = even_values[0];\n\
    \        return vec![smallest_value[0], smallest_index[0]];\n    }\n    let mut\
    \ smallest_value = even_values[0];\n    let mut smallest_index = even_values[0];\n\
    \    for i in even_values.iter().rev() {\n        if i < smallest_value {\n  \
    \          smallest_value = i;\n            smallest_index = i;\n        }\n \
    \   }\n    smallest_value\n        .iter()\n        .enumerate()\n        .filter(|&(_,\
    \ v)| v == smallest_value)\n        .map(|(_, v)| v)\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0zh62uzb.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmp0zh62uzb.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmp0zh62uzb.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0zh62uzb.rs:45:21\n\
    \   |\n45 |         return vec![smallest_value[0], smallest_index[0]];\n   | \
    \                    ^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the type\n   |\n45 |         return vec![*smallest_value[0],\
    \ smallest_index[0]];\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0zh62uzb.rs:50:16\n   |\n50 |         if i < smallest_value\
    \ {\n   |                ^^^^^^^^^^^^^^ expected `&isize`, found `isize`\n   |\n\
    \   = note: expected reference `&&isize`\n              found reference `&isize`\n\
    \nerror[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmp0zh62uzb.rs:56:10\n   |\n56 |         .iter()\n   |   \
    \       ^^^^ method not found in `&isize`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more inf"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut min_value = arr[0];\n    let mut min_idx = 0;\n    let mut min_idx2\
    \ = 0;\n    let mut min_idx3 = 0;\n    let mut min_idx4 = 0;\n    let mut min_idx5\
    \ = 0;\n    let mut min_idx6 = 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8\
    \ = 0;\n    let mut min_idx9 = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11\
    \ = 0;\n    let mut min_idx12 = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14\
    \ = 0;\n    let mut min_idx15 = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17\
    \ = 0;\n    let mut min_idx18 = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20\
    \ = 0;\n    let mut min_idx21 = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23\
    \ = 0;\n    let mut min_idx24 = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26\
    \ = 0;\n    let mut min_idx27 = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29\
    \ = 0;\n    let mut min_idx30 = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32\
    \ = 0;\n    let mut min_idx33 = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35\
    \ = 0;\n    let mut min_idx36 = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38\
    \ = 0;\n    let mut min_idx39 = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41\
    \ = 0;\n    let mut min_idx42 = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44\
    \ = 0;\n    let mut min_idx45 = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47\
    \ = 0;\n    let mut min_idx48 = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50\
    \ = 0;\n    let mut min_idx51 = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53\
    \ = 0;\n    let mut min_idx54 = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56\
    \ = 0;\n    let mut min_idx57 = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59\
    \ = 0;\n    let mut min_idx60 = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2z95rzu8.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    let mut smallest_even_value\
    \ = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value == i {\n                smallest_even_value = i;\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    if\
    \ even_values.len() == 0 {\n        return Vec::new();\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![smallest_even_value];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_even_values = even_values.clone();\n       \
    \ smallest_even_values.sort();\n        if smallest_even_values[0] % 2 == 0 {\n\
    \            smallest_even_values[0] = smallest_even_values[0] / 2;\n        }\n\
    \        return vec![smallest_even_values[0], smallest_index];\n    }\n    return\
    \ vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbjyksc5j.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = isize::MAX;\n    let mut smallest_index = 0;\n    let mut index_of_smallest_value\
    \ = isize::MAX;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n        \
    \    even_values.push(i);\n            if i < smallest_value {\n             \
    \   smallest_value = i;\n                index_of_smallest_value = i;\n      \
    \      }\n        }\n    }\n    if even_values.len() == 0 {\n        return Vec::new();\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() == 2 {\n        if even_values[0] < even_values[1]\
    \ {\n            return vec![even_values[0], even_values[1]];\n        }\n   \
    \     return vec![even_values[1]];\n    }\n    for i in even_values.iter() {\n\
    \        if i < smallest_value {\n            smallest_value = i;\n          \
    \  index_of_smallest_value = i;\n        }\n    }\n    let mut index_of_smallest_value_in_even_values\
    \ = even_values.iter().position(|&x| x == smallest_value);\n    if index_of_smallest_value_in_even_values\
    \ == even_values.len() - 1 {\n        return vec![even_values[index_of_smallest_value_in_even_values]];\n\
    \    }\n    if index_of_smallest_value_in_even_values == even_values.len() - 2\
    \ {\n        if even_values[index_of_smallest_value_in_even_values] < even_values[index_of_smallest_value_in_even_values\
    \ + 1] {\n            return vec![even_values[index_of_smallest_value_in_even_values],\
    \ even_values[index_of_smallest_value_in_even_values + 1]];\n        }\n     \
    \   return vec![even_values[index_of_smallest_value_in_even_values + 1]];\n  \
    \  }\n    for i in even_values.iter().skip(index_of_smallest_value_in_even_values\
    \ + 1).rev() {\n        if i < smallest_value {\n            smallest_value =\
    \ i;\n            index_of_smallest_value = i;\n        }\n    }\n    if index_of_smallest_value\
    \ == even_values.len() - 1 {\n        return vec![even_values[even_values.len()\
    \ - 1]];\n    }\n    for i in even_values.iter().skip(index_of_smallest_value).rev()\
    \ {\n        if i < smallest_value {\n            smallest_value = i;\n      \
    \      index_of_smallest_value = i;\n        }\n    }\n    if index_of_smallest_value\
    \ == even_values.len() - 2 {\n        if even_values[index_of_smallest_value]\
    \ < even_values[index_of_smallest_value + 1] {\n            return vec![even\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3pa779j_.rs:98:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n83 |     if index_of_smallest_value\
    \ == even_values.len() - 2 {\n   |                                           \
    \              - unclosed delimiter\n84 |         if even_values[index_of_smallest_value]\
    \ < even_values[index_of_smallest_value + 1] {\n   |                         \
    \                                                                   - this delimiter\
    \ might not be properly closed...\n85 |             return vec![even\n86 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n98 | }\n\
    \   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp3pa779j_.rs:85:24\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n85 |\
    \             return vec![even\n   |                        ^ unclosed delimiter\n\
    86 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value\
    \ `even` in this scope\n  --> /tmp/tmp3pa779j_.rs:85:25\n   |\n85 |          \
    \   return vec![even\n   |                         ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3pa779j_.rs:34:20\n   |\n34 |\
    \             if i < smallest_value {\n   |                    ^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smallest_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3pa779j_.rs:35:34\n   |\n28 |  \
    \   let mut smallest_value = isize::MAX;\n   |                              ----------\
    \ expected due to this value\n...\n35 |                 smallest_value = i;\n\
    \   |                                  ^ expected `isize`, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n35 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pa779j_.rs:36:43\n  "
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut min_val = i32::MAX;\n    let mut min_idx = -1;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_val <\
    \ i {\n                min_val = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_dqkm6q.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph_dqkm6q.rs:32:27\n\
    \   |\n27 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n32 |                 min_val = i;\n   |   \
    \                        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph_dqkm6q.rs:33:27\n   |\n28 |     let mut min_idx = -1;\n\
    \   |                       -- expected due to this value\n...\n33 |         \
    \        min_idx = i;\n   |                           ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_idx = *i;\n   |                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph_dqkm6q.rs:37:10\n   |\n37 |     vec![min_val, min_idx]\n\
    \   |          ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    37 |     vec![min_val.try_into().unwrap(), min_idx]\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = Vec::new();\n    let mut smallest_value\
    \ = arr[0];\n    let mut smallest_index = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            even_values.push(i);\n        }\n        if i == smallest_value\
    \ {\n            smallest_index = i;\n        }\n        if i == smallest_value\
    \ && smallest_index == i {\n            smallest_value = i;\n        }\n    }\n\
    \    if even_values.len() == 0 {\n        return Vec::new();\n    }\n    even_values.sort();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    \    even_values.dedup();\n    even_values.reverse();\n    even_values.dedup();\n\
    \    even_values.reverse();\n    even_values.dedup();\n    even_values.reverse();\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvjmgd1l.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgvjmgd1l.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
    /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
    /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
    /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut even_values = vec![];\n    let mut smallest_value\
    \ = vec![];\n    let mut smallest_index = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            even_values.push(i);\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     smallest_value[even_values[0] as usize] =\n            smallest_value[even_values[0]\
    \ as usize] as isize;\n        smallest_index[even_values[0] as usize] =\n   \
    \         smallest_index[even_values[0] as usize] as isize;\n        return vec![smallest_value[even_values[0]\
    \ as usize], even_values[0]];\n    }\n    let mut smallest_even_value = vec![];\n\
    \    let mut smallest_even_index = vec![];\n    for i in even_values.iter() {\n\
    \        if i < smallest_even_value.len() {\n            smallest_even_value[i]\
    \ = i;\n            smallest_even_index[i] = i;\n        }\n    }\n    if smallest_even_value.len()\
    \ == 0 {\n        return vec![];\n    }\n    if smallest_even_value.len() == 1\
    \ {\n        smallest_even_value[smallest_even_value[0] as usize] =\n        \
    \    smallest_even_value[smallest_even_value[0] as usize] as isize;\n        smallest_even_index[smallest_even_value[0]\
    \ as usize] =\n            smallest_even_index[smallest_even_value[0] as usize]\
    \ as isize;\n        return vec![smallest_even_value[smallest_even_value[0] as\
    \ usize],\n                     smallest_even_index[smallest_even_value[0] as\
    \ usize]];\n    }\n    let mut smallest_even_value = vec![];\n    let mut smallest_even_index\
    \ = vec![];\n    for i in even_values.iter() {\n        if i < smallest_even_value.len()\
    \ {\n            smallest_even_value[i] = i;\n            smallest_even_index[i]\
    \ = i;\n        }\n    }\n    if smallest_even_value.len() == 0 {\n        return\
    \ vec![];\n    }\n    if smallest_even_value.len() == 1 {\n        smallest_even_value[smallest_even_value[0]\
    \ as usize] =\n            smallest_even_value[smallest_even_value[0] as usize]\
    \ as isize;\n        smallest_even_index[smallest_even_value[0] as usize] =\n\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6vqszd1j.rs:96:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n79 |     if smallest_even_value.len()\
    \ == 1 {\n   |                                       - this delimiter might not\
    \ be properly closed...\n...\n84 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n96 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmp6vqszd1j.rs:84:1\n   |\n84 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6vqszd1j.rs:33:20\n   |\n33 |\
    \             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmp6vqszd1j.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmp6vqszd1j.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6vqszd1j.rs:47:62\n\
    \   |\n47 |         return vec![smallest_value[even_values[0] as usize], even_values[0]];\n\
    \   |                                                              ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n47 |         return vec![smallest_value[even_values[0] as usiz"
  stdout: ''
  timestamp: 1660010662
