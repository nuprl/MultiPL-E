language: rs
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name.clone();\n        let mut extension =\
    \ extension.clone();\n        let mut cap = 0;\n        let mut sm = 0;\n    \
    \    while cap < extension.chars().count() && sm < extension.chars().count() {\n\
    \            let cap_char = extension.chars().nth(cap).unwrap();\n           \
    \ let sm_char = extension.chars().nth(sm).unwrap();\n            if cap_char ==\
    \ sm_char {\n                cap += 1;\n                sm += 1;\n           \
    \ } else {\n                break;\n            }\n        }\n        if cap ==\
    \ extension.chars().count() {\n            strength = -1;\n        } else {\n\
    \            strength = cap - sm;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_f95kioh.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_f95kioh.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_f95kioh.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_f95kioh.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_f95kioh.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_f95kioh.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_f95kioh.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_f95kioh.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_f95kioh.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_f95kioh.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_f95kioh.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.to_string();\n \
    \           break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpx61otlwk.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx61otlwk.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx61otlwk.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx61otlwk.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx61otlwk.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx61otlwk.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx61otlwk.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx61otlwk.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx61otlwk.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx61otlwk.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx61otlwk.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut strength = -1;\n    let mut best_extension = String::from(\"\
    \");\n    for (extension, extension_map) in extensions_map.iter() {\n        let\
    \ mut extension_strength = 0;\n        for letter in extension.chars() {\n   \
    \         extension_strength += extension_map.get(letter).unwrap();\n        }\n\
    \        if extension_strength > strength {\n            strength = extension_strength;\n\
    \            best_extension = extension;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + best_extension.to_string()\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphqrx80l1.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphqrx80l1.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmphqrx80l1.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphqrx80l1.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphqrx80l1.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphqrx80l1.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphqrx80l1.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphqrx80l1.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphqrx80l1.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphqrx80l1.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |          "
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        let mut i = 0;\n        while i < extension_len {\n\
    \            if extension[i] >= class_name[i] {\n                extension_len\
    \ = i;\n            } else {\n                class_len = i;\n            }\n\
    \            i += 1;\n        }\n        if strength == -1 || strength > extension_len\
    \ - class_len {\n            strength = extension_len - class_len;\n         \
    \   extension = extension.to_string();\n        }\n    }\n    extension\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp39urnx95.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp39urnx95.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp39urnx95.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp39urnx95.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp39urnx95.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp39urnx95.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp39urnx95.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp39urnx95.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp39urnx95.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp39urnx95.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp39urnx95.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut counter = 0;\n        while counter < class_name.len() {\n  \
    \          if class_name.chars().all(|c| c.is_uppercase() && c.to_ascii_lowercase()\
    \ == c) {\n                class_name = class_name[..class_name.length() - counter];\n\
    \                counter = 0;\n            } else {\n                counter++;\n\
    \            }\n        }\n        let mut counter = 0;\n        while counter\
    \ < extension.len() {\n            if extension.chars().all(|c| c.is_lowercase()\
    \ && c.to_ascii_uppercase() == c) {\n                extension = extension[..extension.length()\
    \ - counter];\n                counter = 0;\n            } else {\n          \
    \      counter++;\n            }\n        }\n        if strength == -1 || strength\
    \ > extension.chars().count() - class_name.chars().count() {\n            strength\
    \ = extension.chars().count() - class_name.chars().count();\n            extension\
    \ = class_name;\n        }\n    }\n    class_name\n        .to_ascii_lowercase()\n\
    \        .to_string()\n        + \"_\"\n        + extension\n        .to_ascii_lowercase()\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpaysyoah4.rs:29:25\n\
    \   |\n29 |                 counter++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpaysyoah4.rs:38:25\n\
    \   |\n38 |                 counter++;\n   |                         ^ expected\
    \ expression\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpaysyoah4.rs:57:17\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaysyoah4.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaysyoah4.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpaysyoah4.rs:58:25\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaysyoah4.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaysyoah4.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpaysyoah4.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpaysyoah4.rs:60:25\n   |\n60 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpaysyoah4.rs:61:17\n  \
    \ |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaysyoah4.rs"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfog9lu6h.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfog9lu6h.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfog9lu6h.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfog9lu6h.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfog9lu6h.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfog9lu6h.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfog9lu6h.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpes4nea_k.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpes4nea_k.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpes4nea_k.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpes4nea_k.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpes4nea_k.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpes4nea_k.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpes4nea_k.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpes4nea_k.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpes4nea_k.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpes4nea_k.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpes4nea_k.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpes4nea_k.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpes4nea_k.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpes4nea_k.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpes4nea_k.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = if cap > sm {\n            cap - sm\n        } else {\n \
    \           sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6wmceiyq.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6wmceiyq.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6wmceiyq.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6wmceiyq.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6wmceiyq.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6wmceiyq.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6wmceiyq.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6wmceiyq.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6wmceiyq.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6wmceiyq.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6wmceiyq.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_strength = strength;\n            }\n            extension_map.insert(c,\
    \ extension_strength);\n        }\n        extensions_map.insert(extension_strength,\
    \ extension);\n    }\n    let mut max_strength = -1;\n    let mut max_extension\
    \ = String::from(\"\");\n    for (strength, extension) in extensions_map.iter()\
    \ {\n        if strength > max_strength {\n            max_strength = strength;\n\
    \            max_extension = extension;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + max_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpfsgrb87e.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpfsgrb87e.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfsgrb87e.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfsgrb87e.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfsgrb87e.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfsgrb87e.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfsgrb87e.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfsgrb87e.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfsgrb87e.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfsgrb87e.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |          "
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        if strength > 0 {\n            extension = e;\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2rm94tpb.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2rm94tpb.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2rm94tpb.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2rm94tpb.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2rm94tpb.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2rm94tpb.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2rm94tpb.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2rm94tpb.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2rm94tpb.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2rm94tpb.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2rm94tpb.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut i = 0;\n        while i < class_name.len() {\n            let\
    \ mut j = i;\n            while j < class_name.len() {\n                if class_name[j]\
    \ == class_name[i].to_lowercase() {\n                    j += 1;\n           \
    \     } else {\n                    break;\n                }\n            }\n\
    \            let mut k = i;\n            while k < class_name.len() {\n      \
    \          if class_name[k] == class_name[i].to_uppercase() {\n              \
    \      k += 1;\n                } else {\n                    break;\n       \
    \         }\n            }\n            if strength == -1 || strength > k - j\
    \ {\n                strength = k - j;\n                extension = extension;\n\
    \            }\n            i += 1;\n        }\n    }\n    class_name.to_string()\
    \ + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbnefdazy.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbnefdazy.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbnefdazy.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbnefdazy.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbnefdazy.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbnefdazy.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbnefdazy.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbnefdazy.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbnefdazy.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbnefdazy.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbnefdazy.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut i = 0;\n        while i < class_name.len() {\n            if\
    \ class_name[i] == extension[0] {\n                class_name = &class_name[i..];\n\
    \                i += 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        let mut j = 0;\n        while j < extension.len()\
    \ {\n            if extension[j] == class_name[0] {\n                extension\
    \ = &extension[j..];\n                j += 1;\n            } else {\n        \
    \        break;\n            }\n        }\n        if strength == -1 || strength\
    \ > extension.len() / class_name.len() {\n            strength = extension.len()\
    \ / class_name.len();\n            extension = class_name;\n        }\n    }\n\
    \    extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpyc180wb_.rs:51:17\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyc180wb_.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyc180wb_.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyc180wb_.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyc180wb_.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyc180wb_.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyc180wb_.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyc180wb_.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyc180wb_.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyc180wb_.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyc180wb_.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut cap = class_name.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut sm = class_name.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap > sm {\n            cap = cap - sm;\n            class_name =\
    \ class_name.to_string();\n        }\n        if cap > strength {\n          \
    \  strength = cap;\n            extension = extension.to_string();\n        }\n\
    \    }\n    class_name + extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpsthpp3_w.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsthpp3_w.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsthpp3_w.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsthpp3_w.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsthpp3_w.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsthpp3_w.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsthpp3_w.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsthpp3_w.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsthpp3_w.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsthpp3_w.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsthpp3_w.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfog9lu6h.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfog9lu6h.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfog9lu6h.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfog9lu6h.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfog9lu6h.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfog9lu6h.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfog9lu6h.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfog9lu6h.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        while extension_len > class_len {\n            extension_len\
    \ -= class_len;\n            class_len -= 1;\n        }\n        let mut diff\
    \ = extension_len - class_len;\n        while diff > 0 {\n            if extension[diff]\
    \ != class_name[diff] {\n                break;\n            }\n            diff\
    \ -= 1;\n        }\n        if diff == 0 {\n            strength = extension_len;\n\
    \            break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extensions[strength])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5vhthxam.rs:44:17\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5vhthxam.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5vhthxam.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5vhthxam.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5vhthxam.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5vhthxam.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5vhthxam.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5vhthxam.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5vhthxam.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5vhthxam.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5vhthxam.rs:49:17\n   |\n49 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut cap = class_name.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut sm = class_name.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap > sm {\n            strength = cap - sm;\n        } else {\n \
    \           strength = sm - cap;\n        }\n        if strength > 0 {\n     \
    \       break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6ms4vbg2.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6ms4vbg2.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6ms4vbg2.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6ms4vbg2.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6ms4vbg2.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut max_strength = -1;\n    let mut max_extension = String::from(\"\
    \");\n    for (extension, extension_map) in extensions_map.iter() {\n        let\
    \ strength = extension_map.iter().filter(|(_, count)| count > 0).count();\n  \
    \      if strength > max_strength {\n            max_strength = strength;\n  \
    \          max_extension = extension;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + max_extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpdaer20g5.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpdaer20g5.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpdaer20g5.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdaer20g5.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdaer20g5.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdaer20g5.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdaer20g5.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdaer20g5.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdaer20g5.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdaer20g5.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |          "
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n               \
    \ class_name = class_name.to_lowercase();\n            } else if c.is_lowercase()\
    \ {\n                strength += 1;\n                class_name = class_name.to_uppercase();\n\
    \            }\n        }\n        if strength > strength {\n            extension\
    \ = class_name;\n            strength = strength;\n        }\n    }\n    class_name\
    \ + extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpi21f885e.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi21f885e.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi21f885e.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpi21f885e.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi21f885e.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi21f885e.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi21f885e.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi21f885e.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi21f885e.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi21f885e.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi21f885e.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm\n        };\n        if strength > 0 {\n            break;\n      \
    \  }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp931dakvs.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp931dakvs.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp931dakvs.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp931dakvs.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp931dakvs.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp931dakvs.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp931dakvs.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp931dakvs.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp931dakvs.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp931dakvs.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp931dakvs.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659749027
