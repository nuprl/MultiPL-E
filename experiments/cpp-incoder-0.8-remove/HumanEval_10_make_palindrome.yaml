name: HumanEval_10_make_palindrome
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome\
  \ that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the\
  \ longest postfix of supplied string that is a palindrome.\n// - Append to the end\
  \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
  std::string make_palindrome(std::string string) {\n"
tests: "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\
  \")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"\
  xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"\
  jerry\")) == (\"jerryrrej\"));\n}\n"
completions: ["\tstd::reverse(string);\n\tint length = string.length();\n\tstring\
    \ pre = std::string(length - 1, string);\n\tstring rev = std::string(length -\
    \ 1, string);\n\tstring post = std::string(length - 1, string);\n\tstd::string\
    \ palindrome = pre + string + post;\n\treturn palindrome;", "    string postfix\
    \ = \"\";\n    std::string prefix = \"\";\n    bool palindromic = true;\n    for\
    \ (int i = 0; i < string.length(); i++) {\n        if (palindromic) {\n      \
    \      postfix = postfix + string[i];\n        }\n        if (string[i] == string[string.length()\
    \ - 1 - i]) {\n            prefix = prefix + string[i];\n            palindromic\
    \ = false;\n        }\n    }\n    string result = prefix + \"#\" + postfix;\n\
    \    return result;", "    int start = 0, end = string.size() - 1, mid = 0;\n\
    \    while (start < end) {\n        mid = (start + end) / 2;\n        if (string[mid]\
    \ != string[string.size() - 1 - mid])\n            end = mid - 1;\n        else\n\
    \            start = mid + 1;\n    }\n    return string.substr(0, start + 1) +\
    \ \"yay\" + string.substr(start, string.length() - start - 1);", "  string postfix\
    \ = string;\n  size_t longest = 0;\n  for (size_t i = 0; i < postfix.size(); i++)\
    \ {\n    postfix.push_back(string[postfix.size() - i - 1]);\n    if (postfix ==\
    \ string) break;\n    size_t postfix_size = postfix.size();\n    std::string reverse_postfix(postfix.rbegin(),\
    \ postfix.rend());\n    if (postfix_size == longest || postfix_size < longest)\
    \ {\n      longest = postfix_size;\n      postfix = reverse_postfix;\n    }\n\
    \  }\n  postfix.erase(postfix.begin(), postfix.end());\n  return postfix;", " \
    \   // Initialization\n    string rv, ss, tmp;\n    size_t i = 0, j = 0, n = string.length();\n\
    \    size_t ls = n + 1;\n    bool rv = false;\n    // Find the longest postfix\
    \ that is a palindrome\n    while (i < n) {\n        j = i + 1;\n        // Find\
    \ the longest postfix that is a palindrome\n        while (j < n) {\n        \
    \    if (string[i] == string[j])\n                j++;\n            else\n   \
    \             break;\n        }\n        // If no such postfix found, append the\
    \ reverse of supplied string till the end.\n        if (j == n)\n            j\
    \ = n - 1;\n        // Append the reverse of the postfix to string\n        tmp\
    \ = string.substr(i, j + 1);\n        tmp = tmp.substr(0, j) + tmp.substr(j +\
    \ 1, n - j);\n        // Check if the reverse of the postfix is a palindrome\n\
    \        bool ok = true;\n        // If the reverse is not a palindrome, append\
    \ the reverse to string\n        for (size_t k = 0; k < ls / 2; k++)\n       \
    \     ok = ok && (tmp[k] == tmp[n - k - 1]);\n        // Reverse of the postfix\
    \ is palindrome, break out of the loop.\n        if (ok) {\n            ss +=\
    \ tmp;\n            rv = true;\n            break;\n        }\n        i++;\n\
    \    }\n    // If no postfix is a palindrome\n    if (!rv)\n        ss += string;\n\
    \    // Reverse the prefix\n    for (size_t k = 0; k < ls; k++)\n        ss +=\
    \ string[k];\n    rv = rv || ss == string; // Reverse if reversal is possible\n\
    \    return rv ? ss.substr(0, n) + ss.substr(n - 1, ls) : ss;", "    int n = string.length();\n\
    \    int max_len = 0;\n    int max_len_index = 0;\n    int start = 0;\n    int\
    \ end = 0;\n\n    // find longest postfix that is a palindrome and reverse it\n\
    \    for (int i = 0; i < n; i++) {\n        if (string[i] == string[n-1]) {\n\
    \            end++;\n        } else {\n            end = 0;\n        }\n\n   \
    \     if (end == 1) {\n            // find first index in string that is NOT equal\
    \ to n-1\n            start = i;\n        }\n\n        if (end == 2) {\n     \
    \       if (max_len < n-i-1) {\n                max_len = n-i-1;\n           \
    \     max_len_index = i;\n            }\n        }\n    }\n    assert(max_len\
    \ < n);\n    assert(max_len_index >= 0);\n\n    // append reverse of the string\
    \ that is before the palindromic suffix.\n    return std::string(start, max_len_index)\
    \ + std::string(max_len_index+1, n) + std::string(max_len_index+2, n-1);", " \
    \ if (string.empty()) return string;\n  int longest_postfix_len = -1;\n  // Find\
    \ the longest postfix of string which is a palindrome.\n  for (int i = 0; i <\
    \ string.length(); ++i) {\n    if (string[i] == string[string.length() - 1 - i])\
    \ {\n      ++longest_postfix_len;\n    } else {\n      break;\n    }\n  }\n  string\
    \ result;\n  result += string[0];\n  for (int i = 1; i < string.length() - longest_postfix_len;\
    \ ++i) {\n    result += string[i];\n  }\n  result += string[string.length() -\
    \ longest_postfix_len];\n  return result;", "    int n = string.length();\n  \
    \  if (n < 2) return string;\n\n    // Find postfix of palindrome.\n    int start\
    \ = 0, end = n;\n    while (end > start) {\n        int mid = (start + end) /\
    \ 2;\n        if (string[mid] != string[n - mid - 1]) {\n            end = mid;\n\
    \        } else {\n            start = mid + 1;\n        }\n    }\n    int mid_len\
    \ = end - start;\n\n    // Reverse prefix before postfix\n    string prefix =\
    \ string.substr(0, start);\n    string reversed_prefix = reverse(prefix);\n  \
    \  string suffix = string.substr(start, mid_len);\n\n    // Palindrome = prefix\
    \ + reverse + suffix\n    return prefix + reversed_prefix + suffix;", "    std::string\
    \ rstring;\n    auto it = string.begin();\n    auto end = string.end();\n\n  \
    \  while (it != end) {\n        if (*it != *end) return {};\n        rstring +=\
    \ *it;\n        ++it;\n        --end;\n    }\n    rstring += string; // Add the\
    \ remaining part of string\n    return rstring;", "    // The string that begins\
    \ with a postfix that is a palindrome.\n    std::string palindrome_postfix = \"\
    \";\n    // The string that starts with the postfix that comes before the palindromic\
    \ suffix.\n    std::string palindrome_prefix_prefix_length = 0;\n    // The length\
    \ of the string that starts with the postfix that comes before the palindromic\
    \ suffix.\n    int palindrome_prefix_prefix_length_size = 0;\n    // The length\
    \ of the postfix that comes before the palindromic suffix.\n    int postfix_length\
    \ = 0;\n    // The length of the longest palindrome prefix.\n    int max_length\
    \ = 0;\n\n    // The starting postfix length of the supplied string.\n    int\
    \ start_postfix_length = 0;\n    // The length of the starting postfix of the\
    \ supplied string.\n    int palindrome_postfix_length = 0;\n    // The index of\
    \ the next non-space char in the supplied string.\n    int next_char_position\
    \ = 0;\n    // The index of the previous non-space char in the supplied string.\n\
    \    int prev_char_position = 0;\n    // The current length of the supplied string.\n\
    \    int current_length = 0;\n\n    for (int i = 0; i < string.length(); i++)\
    \ {\n        if (string[i] == ' ') {\n            // Spaces are not included in\
    \ the longest palindrome prefix.\n            max_length += 1;\n        } else\
    \ {\n            // Keep track of the length of the longest palindrome prefix.\n\
    \            if (max_length < palindrome_prefix_prefix_length) {\n           \
    \     max_length = palindrome_prefix_prefix_length;\n            }\n         \
    \   // Append the length of the current string prefix to the postfix that comes\
    \ before the palindromic suffix.\n            postfix_length += 1;\n         \
    \   palindrome_postfix += string[i];\n            if (string[i] == string[i -\
    \ 1]) {\n                // Found a palindromic suffix.\n                palindrome_postfix_length\
    \ += 1;\n            } else {\n                // The next character in the supplied\
    \ string is not a palindromic suffix.\n                postfix_length += 1;\n\
    \            }\n            if (palindrome_postfix_length == palindrome_prefix_prefix_length\
    \ + 1) {\n                // Add the length of the current string prefix to the\
    \ postfix that comes before the palindromic suffix.\n                postfix_length\
    \ += 1;\n                palindrome_postfix += string[i];\n            }\n   \
    \         if (string[i] == string[i + 1]) {\n                // The next character\
    \ in the supplied string is not a palindromic suffix.\n                postfix_length\
    \ += 1;\n            }\n            if (postfix_length == palindrome_prefix_prefix_length)\
    \ {\n                // The postfix that comes before the palindromic suffix is\
    \ the longest palindrome prefix.\n                palindrome_prefix_prefix_length_size\
    \ = max_length - postfix_length;", "  int left_index = 1;\n  int right_index =\
    \ 1;\n  int largest = 0;\n  int smallest = string.size();\n  // Find the longest\
    \ palindrome suffix.\n  while ((left_index + 1 < string.size()) && (string[left_index]\
    \ == string[right_index])) {\n    ++left_index;\n    ++right_index;\n  }\n  while\
    \ (left_index < string.size()) {\n    while ((right_index < string.size()) &&\
    \ (string[left_index] == string[right_index])) {\n      ++left_index;\n      ++right_index;\n\
    \    }\n    // If we find a palindrome suffix that is larger.\n    if (left_index\
    \ - right_index > largest) {\n      largest = left_index - right_index;\n    }\n\
    \    while ((left_index < string.size()) && (string[left_index] == string[right_index]))\
    \ {\n      ++left_index;\n      ++right_index;\n    }\n  }\n  std::string palindrome\
    \ = string;\n  // Append the reverse of the suffix that comes before longest.\n\
    \  for (int i = 0; i < largest; ++i) {\n    std::string prefix = palindrome;\n\
    \    std::string suffix = palindrome;\n    std::string suffix = palindrome;\n\
    \    suffix[left_index] = string[right_index];\n    suffix = suffix + suffix;\n\
    \    prefix = prefix + suffix;\n    palindrome = prefix + suffix;\n  }\n  return\
    \ palindrome;", "    std::string reverse_string(string);\n    reverse_string.reserve(reverse_string.length()\
    \ / 2 + 1);\n    reverse_string += std::string(string.length() - reverse_string.size(),\
    \ string[string.length() - 1]);\n    reverse_string += string(string.length()\
    \ / 2 + 1, string[string.length() / 2]);\n    return reverse_string;", "    int\
    \ n = 0, start = 0;\n    for (int i = 0; i < string.length(); i++) {\n       \
    \ string += string[n - i];\n        if (string[i] != string[n])\n            start\
    \ = i;\n        n++;\n    }\n    string += string[n - start];\n    string += std::string(n\
    \ - start, string.length() - start);\n    return string;", "    int length = string.length();\n\
    \    std::string postfix = \"\";\n    for (int i = 0; i <= length/2; i++) {\n\
    \        postfix += string.substr(i, i);\n    }\n    std::string reverse = postfix.substr(0,\
    \ postfix.length()/2);\n    return reverse + postfix + string;", "    std::string\
    \ reverse_string;\n    for (size_t i = 1; i < string.length(); ++i) {\n      \
    \  reverse_string += string[i - 1];\n    }\n    string += reverse_string;\n  \
    \  string += string.substr(reverse_string.length(), string.length());\n    return\
    \ string;", "  std::string postfix_of_biggest;\n  // Find longest postfix of string.\n\
    \  while ((postfix_of_biggest.length() < string.length()) && (string[string.length()\
    \ - 1] != string[0])) {\n    postfix_of_biggest += string[string.length() - 1];\n\
    \    string.pop_back();\n  }\n  // Reverse the postfix of string.\n  for (auto\
    \ i = 0; i < postfix_of_biggest.length(); i++) {\n    string[postfix_of_biggest.length()\
    \ - 1 - i] = string[postfix_of_biggest.length() - i];\n  }\n  string.pop_back();\
    \ // Remove the last postfix character.\n  return string;", "    // Find the length\
    \ of the string\n    int n = string.size();\n    // If there's no palindrome in\
    \ the string return empty string\n    if (n < 2) {\n        return \"\";\n   \
    \ }\n    // Find the longest postfix string of the given string that is a palindrome\n\
    \    std::string postfix = make_postfix_palindrome(string);\n    // If there's\
    \ no postfix return empty string\n    if (postfix.empty()) {\n        return \"\
    \";\n    }\n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix\n    string reverse = string.reverse_copy();\n\
    \    reverse.resize(postfix.size());\n    reverse.append(postfix);\n    return\
    \ reverse;", "    std::string reverse;\n    string temp = string;\n    for (auto\
    \ i = temp.length() - 1; i >= 0; --i)\n        reverse = reverse + temp[i];\n\
    \    reverse = reverse + temp;\n    return reverse;", "    int length = string.length();\n\
    \    int longestPalindromePostfix = length; // longest postfix of string that\
    \ is a palindrome\n    int longestPalindromeSuffix = length; // longest suffix\
    \ of string that is a palindrome\n    int longestPalindromePrefix = length; //\
    \ longest string prefix that is a palindrome\n    int longestPalindromeSuffix\
    \ = length; // longest string suffix that is a palindrome\n    int longestPalindromePrefix\
    \ = length; // longest string prefix that is a palindrome\n    // Find the longest\
    \ postfix of supplied string that is a palindrome\n    for (int i = 1; i < length;\
    \ ++i) {\n        // If the current character is not a letter\n        if (string[i\
    \ - 1] >= 'a' && string[i - 1] <= 'z' ||\n            string[i - 1] >= 'A' &&\
    \ string[i - 1] <= 'Z') {\n            // Then check if the remaining string is\
    \ palindromic\n            bool isPalindromic = true;\n            int j = 0;\n\
    \            for (int k = 0; k < longestPalindromePostfix; ++k) {\n          \
    \      if (string[i] != string[j + k]) {\n                    isPalindromic =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       // If the current character is letter then check if the suffix is palindromic\n\
    \            if (isPalindromic) {\n                longestPalindromePostfix =\
    \ i;\n            }\n        } else {\n            // If the current character\
    \ is a letter then check if the suffix is palindromic\n            if (string[i\
    \ - 1] == 'a' || string[i - 1] == 'A' || string[i - 1] == 'z' ||\n           \
    \     string[i - 1] == 'Z') {\n                bool isPalindromic = true;\n  \
    \              int j = 0;\n                for (int k = 0; k < longestPalindromeSuffix;\
    \ ++k) {\n                    if (string[i] != string[j + k]) {\n            \
    \            isPalindromic = false;\n                        break;\n        \
    \            }\n                }\n                if (isPalindromic) {\n    \
    \                longestPalindromeSuffix = i;\n                }\n           \
    \ }\n        }\n    }\n    // Find the longest prefix of supplied string that\
    \ is a palindrome\n    for (int i = 0; longestPalindromePrefix < length; ++i)\
    \ {\n        // If the current character is not a letter\n        if (string[i\
    \ - 1] >= 'a' && string[i - 1] <= 'z' ||\n            string[i - 1] >= 'A' &&\
    \ string[i - 1] <= 'Z') {\n            // Then check if the remaining string is\
    \ palindromic\n            bool isPalindromic = true;\n            int j = 0;\n\
    \            for (int k = 0; k < longestPalindromePrefix; ++k) {\n", "    int\
    \ n = string.length();\n    std::string reverse(string.rbegin(), string.rend());\n\
    \    std::string prefix;\n    int max_length = n/2;\n    // If n is odd, then\
    \ append odd length to rearrange string.\n    if (n % 2 != 0){\n        max_length++;\n\
    \    }\n    for(int i = 0; i < max_length; i++){\n        prefix += string[i];\n\
    \    }\n    prefix += reverse;\n    return prefix;", "    std::string reversed\
    \ = \"\";\n    int index = 0;\n    while(index != string.length() - 1){\n    \
    \    reversed += string[index];\n        reversed += string[string.length() -\
    \ 1 - index];\n        index++;\n    }\n    return reversed + string[0];", " \
    \   // Find the longest postfix that is a palindrome\n    auto len = string.size();\n\
    \    bool flag = false;\n    for (auto i = 0; i < len; ++i) {\n        if (string[i]\
    \ != string[len - 1 - i]) {\n            flag = true;\n            break;\n  \
    \      }\n    }\n    if (!flag) {\n        return string;\n    }\n    std::string\
    \ reverse = string[len - 1 - i];\n    std::reverse(string.begin() + len - 1 -\
    \ i, string.begin() + i);\n    string += reverse;\n    return string;", "    std::string\
    \ result;\n    int start = 0, end = string.length();\n    while (start < end -\
    \ 1) {\n        if (string[start] == string[end]) end--;\n        else if (string[start]\
    \ != string[end]) { result.push_back(string[start]); start++; end--; }\n     \
    \   else { std::cout << \"No palindrome of \" << string << \".\\n\"; return string;\
    \ }\n    }\n    std::cout << result << \"\\n\";\n    return result;", "\tassert(string.size()\
    \ > 2);\n\tstring postfix = \"\";\n\tfor (int i = 0, j = 0; i < string.size();\
    \ i++) {\n\t\tif (i != j) {\n\t\t\tpostfix += string[i];\n\t\t}\n\t\tif (string[i]\
    \ == string[j]) {\n\t\t\tj++;\n\t\t}\n\t\tif (j == string.size() - i) {\n\t\t\t\
    postfix += string[j];\n\t\t\tj++;\n\t\t}\n\t}\n\tpostfix.reverse();\n\treturn\
    \ string + postfix;", "    int l_size = 0, r_size = 0;\n    std::string longest\
    \ = \"\";\n    for (int i = 0; i < (string.length() / 2); i++) {\n        int\
    \ l_count = (string[i] - 'a') + 1;\n        int r_count = (string[string.length()\
    \ - 1 - i] - 'a') + 1;\n        if (l_count >= r_count) {\n            l_size\
    \ = l_count > l_size ? l_count : l_size;\n            r_count = r_count > r_size\
    \ ? r_count : r_size;\n        } else {\n            r_size = r_count > r_size\
    \ ? r_count : r_size;\n            l_count = l_count > l_size ? l_count : l_size;\n\
    \        }\n    }\n    std::string reverse = \"\";\n    for (int i = 0; i < (string.length()\
    \ / 2); i++) {\n        reverse += string[i + l_size];\n    }\n    reverse +=\
    \ string[string.length() - 1 - r_size];\n    reverse = reverse.substr(0, reverse.length()\
    \ - 1);\n    string l_size = string.substr(0, string.length() / 2);\n    string\
    \ r_size = string.substr(string.length() / 2);\n    string longest = l_size +\
    \ reverse + r_size;\n    return longest;", "    string prefix = string;\n    string\
    \ suffix = string.reverse();\n    while (!prefix.empty() && prefix[0] == suffix[0])\
    \ {\n        prefix = prefix.substr(1);\n        suffix = suffix.substr(0, 1);\n\
    \    }\n    if (prefix.empty() || suffix.empty())\n        return \"\";\n    return\
    \ prefix + suffix;", "    int max_len = 0;\n    for (auto i : string) {\n    \
    \    max_len = max(max_len, i);\n    }\n    string palindrome;\n    palindrome.reserve(max_len\
    \ + 1);\n    for (auto i : string) {\n        if (i != string[max_len - i]) {\n\
    \            int j = max_len - i;\n            while (j > 0 && string[j] != string[j\
    \ - 1]) {\n                --j;\n            }\n            palindrome.append(1,\
    \ string[i]);\n            palindrome.append(j);\n        }\n    }\n    return\
    \ palindrome;", "  string postfix_for_search = \"\";\n  for (int i = 0; i < string.length();\
    \ i++) {\n    postfix_for_search += string.substr(i, 1);\n  }\n  string reverse_prefix\
    \ = \"\";\n  for (int i = string.length(); i > 0; i--) {\n    reverse_prefix +=\
    \ string.substr(i, 1);\n  }\n  if (postfix_for_search == reverse_prefix)\n   \
    \ return string;\n  else\n    return string + reverse_prefix + make_palindrome(postfix_for_search);",
  "  // Find longest palindromic suffix\n  std::string suffix;\n  for (size_t i =\
    \ 0, len = string.length(); i < len; ++i)\n    if (string[i] == string[len - i\
    \ - 1])\n      suffix = string[i];\n  assert(suffix.length() >= 2);\n  // Find\
    \ postfix of longest palindromic suffix that begins with a supplied string.\n\
    \  // Suppose that longest palindromic suffix is AB and suppose that AB begins\
    \ with A.\n  // So, the postfix is ACB.\n  std::string postfix = \"\";\n  for\
    \ (size_t i = 0, len = suffix.length(); i < len; ++i)\n    postfix += string[len\
    \ - i - 1];\n  // Append reverse of the string prefix that comes before the longest\
    \ palindromic suffix.\n  std::string prefix = string.substr(0, len - suffix.length());\n\
    \  std::string reverse = std::string(prefix.rbegin(), prefix.rend());\n  return\
    \ reverse + postfix + suffix;", "  std::stack<char> stack;\n  std::string prefix;\n\
    \  std::string suffix;\n  int i = 0;\n  bool flag = false;\n  stack.push(string[0]);\n\
    \  while (!stack.empty()) {\n    if (stack.top() == string[i]) {\n      i++;\n\
    \      if (i >= string.length()) {\n        flag = true;\n      }\n      continue;\n\
    \    }\n    if (flag) {\n      prefix += stack.top();\n      suffix += string[i];\n\
    \    }\n    if (i == string.length() - 1) {\n      stack.push(string[i]);\n  \
    \    i++;\n      if (i >= string.length()) {\n        flag = true;\n      }\n\
    \    } else {\n      stack.push(string[i]);\n      i++;\n    }\n  }\n  return\
    \ prefix + suffix;", "    // find palindromic suffix\n    std::string longest_palindromic_suffix(string.rbegin(),\
    \ string.rend());\n    // reverse\n    std::reverse(string.begin(), string.end());\n\
    \    string result = string;\n    // append the longest postfix to the end\n \
    \   result += longest_palindromic_suffix;\n    return result;", "  string postfix\
    \ = \"\";\n  int max_length = 0;\n  for (int i = 0; i < string.length(); i++)\
    \ {\n    if (string[i] == string[string.length() - 1 - i]) {\n      max_length++;\n\
    \    }\n  }\n  for (int i = 0; i < max_length; i++) {\n    postfix += string[i];\n\
    \  }\n  return postfix + string[string.length() - max_length];", "    auto last_index\
    \ = string.size() - 1;\n    auto prefix_length = string.substr(0, last_index).rfind(string);\n\
    \    if (prefix_length == std::string::npos) {\n        return \"\";\n    }\n\
    \    auto prefix = string.substr(0, prefix_length);\n    string reversed_prefix;\n\
    \    std::reverse(prefix.begin(), prefix.end());\n    reversed_prefix = prefix\
    \ + reversed_prefix;\n    return reversed_prefix;", "    // Store the longest\
    \ postfix of string that is a palindrome so far.\n    std::string postfix = \"\
    \";\n    int index = 0, len = string.length();\n    int revindex = 0;\n    while\
    \ (true) {\n        index = string.find_first_not_of(\" \", len);\n        if\
    \ (index == std::string::npos) break;\n        postfix.append(string.substr(len,\
    \ index));\n        revindex = len - revindex - postfix.length();\n        postfix.append(string);\n\
    \        revindex += index - len;\n        postfix.append(string.substr(revindex,\
    \ len));\n        len -= index - 1;\n    }\n    return postfix;", "  if (string.empty())\
    \ return string;\n  int max_len = 0, min_len = 0;\n  for (auto c : string) {\n\
    \    int i = c - 'a';\n    if (i >= 0 && i < 26) max_len = max(max_len, i);\n\
    \    else min_len = min(min_len, i);\n  }\n  int max_len = max(max_len, min_len);\n\
    \  string reverse = string;\n  for (int i = max_len; i > 0; i--) {\n    int j\
    \ = string.length() - 1 - i;\n    if (j >= 0 && j < 26) reverse = reverse + tolower(string[j])\
    \ + string[i];\n  }\n  return reverse;", "  assert(string.length() != 0);\n  //\
    \ Find the longest postfix of the string that is a palindrome\n  int size = string.length();\n\
    \  string prefix = string;\n  while (size-- > 0 && (string[size] == ' ' || string[size]\
    \ == '(')) {\n    prefix.erase(size);\n  }\n  assert(size-- == 0);\n  int i =\
    \ size;\n  while (i > 0 && (string[i - 1] == ' ' || string[i - 1] == '(')) {\n\
    \    i -= 1;\n  }\n  assert(i < size);\n  // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n  return prefix\
    \ + string(i + 1, size - 1).rbegin();", "    std::string longest;\n    for (size_t\
    \ i = 0; i < string.length() - 1; i++) {\n        size_t prefix_length = longest.length();\n\
    \        if (string[prefix_length] != string[i]) {\n            longest += string[i]\
    \ + '0';\n            std::string palindrome_suffix = string[prefix_length + 1]\
    \ + '0' + string[i];\n            longest += std::string(std::string::npos, palindrome_suffix);\n\
    \            i += 1;\n        } else {\n            longest += string[i];\n  \
    \          i += 1;\n        }\n    }\n    return longest;", "    // Create a vector\
    \ of possible postfix strings.\n    std::vector<std::string> suffixes;\n\n   \
    \ std::string prefix_suffix(string.size());\n    for (size_t i = 0; i <= string.size();\
    \ ++i) {\n        // Create a palindrome suffix\n        prefix_suffix.push_back(string[i]);\n\
    \        std::string::reverse_iterator it = std::find(string.begin(), string.end(),\
    \ string[i]);\n        if (it != string.end()) {\n            prefix_suffix.push_back(*it);\n\
    \        }\n        // Add postfix suffix and corresponding prefix to the vector\
    \ of possible postfix strings.\n        suffixes.push_back(prefix_suffix);\n \
    \       prefix_suffix.clear();\n    }\n\n    // Find the longest postfix that\
    \ is a palindrome.\n    size_t max_size = 0;\n    for (size_t i = 0; i <= string.size();\
    \ ++i) {\n        if (suffixes[i].size() > max_size) {\n            max_size =\
    \ suffixes[i].size();\n        }\n    }\n\n    // The longest postfix that is\
    \ a palindrome.\n    std::string max_postfix;\n    // Add the longest postfix\
    \ that is a palindrome\n    for (size_t i = 0; i <= string.size(); ++i) {\n  \
    \      if (suffixes[i].size() == max_size) {\n            max_postfix = std::string();\n\
    \            // Add the longest postfix that is a palindrome\n            for\
    \ (size_t j = 0; j < suffixes[i].size(); ++j) {\n                std::ostringstream\
    \ oss;\n                oss << suffixes[i][j];\n                max_postfix =\
    \ max_postfix + oss.str();\n            }\n            break;\n        }\n   \
    \ }\n    return max_postfix;", "    int length = string.length();\n    if (length\
    \ < 2) return string;\n    int left_index = 0, right_index = length;\n    int\
    \ palindrome_length = 0, palindrome_length_left = 0;\n    while (left_index !=\
    \ right_index && left_index != length - 1 && right_index != 0) {\n        if (string[left_index]\
    \ != string[right_index]) { right_index--; } else { left_index++; }\n        if\
    \ (left_index == right_index) {\n            if (left_index == 0) palindrome_length_left\
    \ = right_index;\n            if (right_index == length - 1) palindrome_length\
    \ = left_index;\n        }\n    }\n    string result = (left_index == right_index)\
    \ ? string : string + string[left_index] + string[right_index];\n    if (left_index\
    \ == right_index) palindrome_length = palindrome_length_left;\n    string reverse\
    \ = string[left_index];\n    for (int i = left_index; i <= right_index; i++) reverse\
    \ += string[i];\n    if (left_index != right_index) result += reverse;\n    return\
    \ result + make_palindrome(result);", "    std::string palindrome = \"\";\n  \
    \  int max_len_postfix = 0, max_len_reverse = 0;\n\n    for (auto c : string)\
    \ {\n        char tmp = c;\n        int len_postfix = 0, len_reverse = 0;\n\n\
    \        while (c != string[max_len_reverse]) {\n            len_reverse++;\n\
    \            c += 1;\n        }\n\n        max_len_postfix = max(max_len_postfix,\
    \ len_postfix);\n        max_len_reverse = max(max_len_reverse, len_reverse);\n\
    \n        palindrome += tmp;\n    }\n\n    std::string reverse = palindrome;\n\
    \n    for (int i = max_len_postfix; i >= 0; i--) {\n        reverse[i + max_len_reverse]\
    \ = palindrome[i];\n    }\n\n    return reverse;", "    std::string prefix;\n\
    \    std::string suffix;\n    int postfix_length = string.length();\n    while\
    \ (postfix_length > 0) {\n        int current_postfix_length = postfix_length;\n\
    \        while (current_postfix_length > 0) {\n            current_postfix_length--;\n\
    \            if (string[current_postfix_length] != string[postfix_length - current_postfix_length])\n\
    \                break;\n        }\n        postfix_length = current_postfix_length;\n\
    \        postfix_length++;\n    }\n    prefix = string.substr(0, postfix_length);\n\
    \    suffix = string.reverse_copy(postfix_length - 1, string.length());\n    return\
    \ prefix + suffix;", "    std::string::size_type pos = 0;\n    std::string result\
    \ = \"\";\n    for (size_t i = 0; i < string.length(); ++i) {\n        if (string[i]\
    \ == string[string.length() - 1 - i]) {\n            result += string[i] + string[string.length()\
    \ - 1 - i];\n            ++pos;\n        }\n    }\n    result += string[pos];\n\
    \    return result;", "    // Find longest postfix that is a palindrome\n    int\
    \ longest = 0;\n    for (int i = 0; i < string.size(); ++i) {\n        if (string[i]\
    \ == string[string.length() - 1 - i]) {\n            longest = std::max(longest,\
    \ i + 1);\n        }\n    }\n    std::string postfix = std::string(string.size()\
    \ - longest, '.');\n    std::string reverse;\n    for (int i = 0; i < postfix.size();\
    \ ++i) {\n        reverse.push_back(postfix[postfix.size() - 1 - i]);\n    }\n\
    \    return reverse + string;", "    string prefix_string = \"\";\n    int prefix_len\
    \ = string.length();\n    string suffix = string[prefix_len - 1];\n    int suffix_len\
    \ = suffix.length();\n    for (int i = 0; i <= suffix_len / 2; i++) {\n      \
    \  prefix_string += string[i];\n    }\n    prefix_string += string[suffix_len\
    \ - 1];\n    prefix_string = prefix_string.resize(prefix_len - suffix_len + 1);\n\
    \    string result = prefix_string;\n    string reverse = string[prefix_len -\
    \ 1];\n    for (int i = 0; i <= suffix_len / 2; i++) {\n        reverse += string[i];\n\
    \    }\n    reverse = reverse.reverse();\n    string combined_string = result;\n\
    \    combined_string += reverse;\n    return combined_string;", "  int length\
    \ = string.length();\n  int i = 0;\n  // Find longest palindrome suffix.\n  int\
    \ longest = 0;\n  for (int j = length - 1; j >= 0; j--) {\n    if (string[i] ==\
    \ string[j] && string[i] == string[length - (j + 1)]) {\n      longest = j + 1;\n\
    \    }\n  }\n  // Reverse the suffix\n  string str = \"\";\n  for (int j = 1;\
    \ j <= longest; j++) {\n    str.append(string.substr(i, 1), 1);\n    i--;\n  }\n\
    \  // Append the reverse of the longest palindrome suffix to string\n  str.append(string.substr(i,\
    \ 1), 1);\n  return str;", "    // Find the longest postfix that is a palindrome.\n\
    \    size_t max_length = 0;\n    for (size_t i = 0; i < string.length(); i++)\
    \ {\n        if (string[i] == '-') continue;\n        auto j = string.length()\
    \ - i - 1;\n        while (string[j] != '-' && string[j] != '/') {\n         \
    \   --j;\n        }\n        if (string[j] == '-') {\n            max_length =\
    \ j + 1;\n            break;\n        }\n    }\n    assert(max_length);\n    string\
    \ result = string;\n    for (size_t i = 0; i < max_length; ++i) {\n        result\
    \ += string[i];\n    }\n    for (size_t i = 0; i < max_length; ++i) {\n      \
    \  result += '/';\n    }\n    // Add suffix of reverse of the string before the\
    \ longest postfix that is a palindrome.\n    for (size_t i = max_length - 1; i\
    \ >= 0; i--) {\n        result += '/';\n        if (string[i] != '-') result +=\
    \ string[i];\n    }\n    return result;", "    std::string postfix;\n    size_t\
    \ maxLength;\n    for (size_t i = 0; i != string.length(); ++i) {\n        postfix\
    \ += string[i];\n        maxLength = (i > 0) ? std::min(postfix.length(), maxLength)\
    \ : 0;\n    }\n    std::string reversePrefix;\n    for (size_t i = 0; i != maxLength;\
    \ ++i) {\n        reversePrefix += postfix[postfix.length() - 1 - i];\n    }\n\
    \    postfix += reversePrefix;\n    return postfix;", "    std::string reverse_string\
    \ = \"\";\n    for (auto it=string.cbegin(); it != string.cend(); ++it) {\n  \
    \      reverse_string += string[string.size() - 1 - it];\n    }\n    return string\
    \ + reverse_string;", "    if (string.empty())\n        return string;\n    std::string\
    \ prefix;\n    size_t max_idx = string.length() - 1;\n    for (size_t i = 0; i\
    \ < max_idx; ++i) {\n        if (string[i] == string[max_idx]) {\n           \
    \ prefix = prefix[max_idx] + string[i];\n        } else {\n            break;\n\
    \        }\n    }\n    string reversed;\n    for (size_t i = 0; i < max_idx; ++i)\
    \ {\n        reversed += string[i];\n    }\n    return prefix + reversed;", " \
    \   \n    // Create an empty string.\n    std::string palindrome = \"\";\n   \
    \ \n    // Find the longest postfix of supplied string.\n    auto longest = std::max_element(string.cbegin(),\
    \ string.cend(),\n                                  [](const char a, const char\
    \ b) {\n                                      return a < b ? true : false;\n \
    \                                 });\n    \n    // Find a postfix that is a palindrome.\n\
    \    auto palindrome_pos = std::find_if(string.cbegin(), string.cend(),\n    \
    \                                   [longest](const char a) {\n              \
    \                             return longest == a;\n                         \
    \              });\n    \n    // Append the reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    palindrome += std::string(string.cbegin(),\
    \ std::find_if(string.cbegin(), palindrome_pos,\n                            \
    \                              [longest](const char a) {\n                   \
    \                                           return a != longest;\n           \
    \                                               }));\n    \n    // Return the\
    \ palindrome.\n    return palindrome;", "    std::string reversed = \"\";\n  \
    \  \n    int prefix_length = 0;\n    \n    for (int i = 0; i < string.length();\
    \ i++) {\n        reversed.push_back(string[i]);\n        \n        if (string[i]\
    \ == string[string.length()-i-1]) {\n            prefix_length++;\n        } else\
    \ {\n            break;\n        }\n    }\n    \n    reversed.insert(reversed.end(),\
    \ string.begin() + prefix_length, string.end());\n    return reversed;", "  int\
    \ len = string.length();\n  std::string longest = make_palindrome_helper(string,\
    \ 0);\n  int postfix_len = (len - longest.length()) / 2;\n  string suffix = string(0,\
    \ postfix_len);\n  string reverse = string(0, longest.length() - postfix_len);\n\
    \  string result = prefix + reverse + suffix;\n  return result;", "    int n =\
    \ string.size();\n    // Find the length of longest postfix that can be formed\
    \ from a palindrome.\n    int max_postfix = 0;\n    for(int i = 0; i <= n; i++)\
    \ {\n        max_postfix += (string[n - 1 - i]).size();\n    }\n    // Reverse\
    \ the prefix that comes before longest postfix that could be formed from a palindrome.\n\
    \    string reverse = \"\";\n    for(int i = n-1; i >= 0; i--) {\n        reverse.push_back(string[i]);\n\
    \    }\n    // Append the reverse of longest postfix that could be formed from\
    \ a palindrome.\n    string postfix = reverse + string[n - max_postfix];\n   \
    \ // Append the prefix that comes before longest postfix that could be formed\
    \ from a palindrome.\n    string prefix = string[n - max_postfix].substr(0, n\
    \ - max_postfix);\n    return prefix + postfix;", "    // Find the length of longest\
    \ postfix of supplied string\n    int max_len = 0, len = string.length();\n  \
    \  for (int i = 1; i < len - 1; i++) {\n        int len = std::min(string[i] -\
    \ string[i - 1], len - i);\n        max_len = std::max(max_len, len);\n    }\n\
    \    // Create the reversed string that would be created for suffix\n    string\
    \ reversed = \"0\";\n    for (int i = max_len - 1; i >= 0; i--) {\n        reversed\
    \ = string[i] + reversed;\n    }\n    return string + reversed;", "    std::string\
    \ postfix(string);\n    int index = 0;\n    while(index != postfix.size()-1) {\n\
    \        // reverse string at current index\n        postfix = postfix.substr(0,index)\
    \ + postfix.substr(index+1,postfix.size()-1);\n        index++;\n    }\n    return\
    \ postfix;", "    std::string reverse(string.rbegin(), string.rend());\n    std::string\
    \ result = (reverse + string).substr(0, string.length() / 2);\n    return std::string(result);\
    \ // result is the palindromic string.", "\tstd::reverse(string.begin(), string.end());\n\
    \tstd::string::size_type first_occur = 0;\n\tstd::string::size_type last_occur\
    \ = string.length();\n\twhile (first_occur < last_occur) {\n\t\tstd::string::size_type\
    \ middle = (first_occur + last_occur) / 2;\n\t\tauto middle_index =  string.find(middle,\
    \ middle);\n\t\tif (middle_index == string::npos) {\n\t\t\tbreak;\n\t\t}\n\t\t\
    first_occur = middle;\n\t\tlast_occur = middle_index;\n\t}\n\tstring += std::string(middle,\
    \ string.length());\n\tstring += std::string(string.rbegin(), string.rend());\n\
    \treturn string;", "\t// Base case: string only contains one character.\n\tif\
    \ (string.length() <= 1) return string;\n\t// Recursive case: string contains\
    \ two or more characters.\n\t\n\t// If the string is empty, return the empty string.\n\
    \tif (string.length() == 2) return \"\";\n\t// Find the longest postfix that is\
    \ a palindrome, and add it to the\n\t// returned string.\n\treturn make_palindrome(string\
    \ + string.reverse_iterator());", "    // Base case.\n    if (string.empty())\n\
    \        return string;\n    int start = 0, end = 0;\n    for (size_t i = 0; i\
    \ < string.size(); i++) {\n        // The last character is our first character\
    \ to look at,\n        // which we know is a palindrome.\n        if (string[i]\
    \ == string[string.size() - 1 - i]) {\n            start = i;\n            end\
    \ = string.size() - 1 - i;\n        }\n    }\n    // Base case.\n    if (start\
    \ == end) {\n        // If there is no suffix that is a palindrome,\n        //\
    \ then we can't possibly start with a suffix.\n        return \"\";\n    }\n \
    \   // Find the longest postfix that is a palindrome.\n    int postfix = start;\n\
    \    while (postfix < string.size() - 1) {\n        int length = 1;\n        //\
    \ Find the next character that is a palindrome.\n        int next_char = postfix;\n\
    \        while (next_char < string.size() - 1 && string[next_char] == string[next_char\
    \ + length - 1])\n            length++;\n        // If that character is not a\
    \ palindrome, skip it.\n        if (next_char < string.size() - 1)\n         \
    \   postfix += length;\n        else\n            break;\n    }\n    // Append\
    \ the reverse of string prefix that comes before postfix.\n    return string +\
    \ string.substr(start, string.size() - end) + string[end];", "  if (string.length()\
    \ < 2) return string;\n  // Find the longest prefix of a string that is a palindrome.\n\
    \  int start = 0, end = string.length();\n  while (start < string.length() &&\
    \ string.at(start) != string.at(end - 1)) {\n    ++start;\n    --end;\n  }\n \
    \ assert(start == 0 && end == string.length());\n  // Append the reverse of the\
    \ prefix before the suffix to end of the string.\n  string reversedString;\n \
    \ while (start >= 0) {\n    reversedString.append(1, string.at(end - 1));\n  \
    \  --end;\n    --start;\n  }\n  reversedString.append(1, string.at(start));\n\
    \  return reversedString;", "\t// Make copy of the string so that we don't modify\
    \ the original string.\n\tstd::string copy(string);\n\t// Step 1: Find longest\
    \ palindromic string that begins with a substring.\n\t// Note: String 'a' and\
    \ 'aa' both become 'a'\n\tauto palindromic_substring = string;\n\tstd::reverse(palindromic_substring.begin(),\
    \ palindromic_substring.end());\n\t// Step 2: Append reverse of the palindromic\
    \ suffix to the palindromic substring\n\tpalindromic_substring += palindromic_substring;\n\
    \t// Step 3: Return the palindromic substring with its original substring prefix.\n\
    \treturn copy;", "    size_t length = string.length();\n    if (length < 2) return\
    \ string;\n    std::string reverse_string = \"\";\n    for (size_t index = 0;\
    \ index < length - 1; index++) {\n        reverse_string += string[index];\n \
    \   }\n    return string + std::reverse_copy(reverse_string.begin(), reverse_string.end(),\
    \ string);", "  // Find the longest postfix of supplied string that is a palindrome.\n\
    \  int prefix_length = 0;\n  int i = string.length() - 1;\n  int j = string.length();\n\
    \  while (i >= 0 && j >= 0) {\n    if (string[i] != string[j]) {\n      break;\n\
    \    }\n    i = i - 1;\n    j = j - 1;\n  }\n\n  int prefix_length = j + 1;\n\
    \  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  std::string new_string = string;\n  while (j >= 0)\
    \ {\n    new_string[j] = new_string[j + 1];\n    j = j - 1;\n  }\n  new_string[prefix_length]\
    \ = '\\0';\n  return new_string;", "  int pos = 0;\n  int pos_pre = -1;\n  int\
    \ pos_post = -1;\n  while ((pos = string.find(\" \", pos)) != string::npos) {\n\
    \    pos_post = pos;\n    while (string.find(\" \", pos + 1) != string::npos)\
    \ {\n      pos_pre = string.find(\" \", pos);\n      string += string(string[pos_pre],\
    \ string[pos_post]);\n      pos_pre++;\n      pos_post--;\n    }\n    pos_pre--;\n\
    \    pos_post++;\n    pos = string.find(\" \", pos);\n  }\n  string += string(string[pos_pre],\
    \ string[pos_post]);\n  return string;", "  // Find the longest postfix that is\
    \ a palindrome.\n  int start = 0;\n  int end = string.size();\n  while (end -\
    \ start > 1) {\n    int mid = (end + start) / 2;\n    bool eq = string[mid] ==\
    \ string[string.size() - mid - 1];\n    if (!eq) {\n      start = mid;\n    }\
    \ else {\n      end = mid - 1;\n    }\n  }\n  // Get the substring of the original\
    \ string after the palindromic suffix.\n  std::string postfix = string.substr(start,\
    \ end - start + 1);\n  // Get the reverse of the postfix string.\n  std::string\
    \ reverse = std::string(string.rbegin(), string.rend());\n  // Add them together\
    \ to get the palindrome string from the supplied string.\n  return reverse.substr(0,\
    \ start) + postfix;", "    std::string pre, post;\n    unsigned int len = 0;\n\
    \    for (unsigned int i = 0; i < string.length(); ++i) {\n        if (string[i]\
    \ == string[len - i]) {\n            ++len;\n        } else {\n            if\
    \ (len > 0) {\n                post.push_back(string[len - i - 1]);\n        \
    \    }\n            len = i;\n        }\n    }\n    if (len > 0) {\n        pre.push_back(string[len\
    \ - i - 1]);\n    }\n    return pre + std::string::reverse(string) + post;", " \
    \ string prefix = \"\";\n  bool first_char = true;\n  int longest = 0;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    if (first_char) {\n      prefix\
    \ = prefix[0] + string[i];\n      first_char = false;\n    } else {\n      for\
    \ (int j = 0; j < i; j++) {\n        if (string[j] != prefix[j]) {\n         \
    \ break;\n        }\n      }\n      if (j == i) {\n        longest++;\n      }\n\
    \    }\n  }\n  string reversed = \"\";\n  for (int i = string.length()-1; i >=\
    \ 0; i--) {\n    reversed = reversed + string[i];\n  }\n  assert(longest == 0);\n\
    \  return prefix + reversed;", "  // Find longest palindromic substring\n  int\
    \ start = 0;\n  int length = string.length();\n  while (start + 1 < length) {\n\
    \    int mid = length / 2;\n    int midmid = length / 2 + 1;\n    int midstart\
    \ = mid - midmid;\n    if (string(midmid, string.length()) == string(midstart,\
    \ midmid)) {\n      length = midmid;\n    } else {\n      mid = midmid;\n    }\n\
    \    start = mid;\n  }\n\n  // Find the postfix of longest palindromic substring\n\
    \  int end = start;\n  int mid = end / 2;\n  while (end - 1 < mid) {\n    end\
    \ = mid;\n    mid = end / 2;\n    midmid = end / 2 + 1;\n    if (string(midmid,\
    \ string.length()) == string(midstart, midmid)) {\n      mid = midmid;\n     \
    \ end = mid;\n    } else {\n      midmid = midmid;\n    }\n  }\n  // Append reverse\
    \ of longest postfix to end of the string\n  string newString = string(end, string.length())\
    \ + string(0, end - end);\n  return newString;", "    std::vector<std::string>\
    \ tokens;\n    std::string::size_type pos;\n    std::string::size_type l = 0;\n\
    \    std::string::size_type r = string.size() - 1;\n\n    while (l < r) {\n  \
    \      pos = string.find(' ', l);\n        if (pos != std::string::npos) {\n \
    \           tokens.emplace_back(string.substr(l, pos - l));\n        }\n     \
    \   l = pos + 1;\n        pos = string.rfind(' ', r);\n        if (pos != std::string::npos)\
    \ {\n            tokens.emplace_back(string.substr(r, pos - r));\n        }\n\
    \        r = pos + 1;\n    }\n\n    if (tokens.size() == 0) {\n        return\
    \ string;\n    }\n    std::vector<std::string>::iterator it = tokens.begin();\n\
    \    for (; it != tokens.end(); ++it) {\n        // Check whether the first token\
    \ is a palindrome\n        if ((it->size() >= 2) && (it->at(0) != it->at(it->size()\
    \ - 1))) {\n            return string;\n        }\n\n        // Check whether\
    \ the last token is a palindrome\n        if ((it->size() >= 2) && (it->at(0)\
    \ != it->at(it->size() - 1))) {\n            return string;\n        }\n\n   \
    \     // Append the reverse of the string prefix before the suffix to the original\
    \ string.\n        std::string tmp = it->back();\n        it->pop_back();\n  \
    \      tmp = tmp + it->back();\n        it->pop_back();\n        string += tmp;\n\
    \    }\n\n    return string;", "    int length = string.length();\n    if (length\
    \ == 0) return string; // Nothing to do.\n\n    int max_postfix = length / 2;\n\
    \    int max_prefix = max_postfix;\n    while (max_postfix >= 0 && string.at(max_postfix)\
    \ == string.at(max_prefix - 1)) {\n        max_postfix--;\n        max_prefix--;\n\
    \    }\n    std::string reversed = string.substr(0, max_postfix);\n    string\
    \ postfix = string.substr(max_postfix + 1);\n\n    return reversed + postfix;",
  "  int prefix_len = string.length() - 1;\n  std::string reverse_suffix;\n  for (int\
    \ i = 0; i < string.length(); ++i) {\n    if (string[i] == string[string.length()\
    \ - 1 - i]) {\n      reverse_suffix = string.substr(i, 1);\n      break;\n   \
    \ }\n  }\n  return string(string.rbegin(), string.begin() + prefix_len) + reverse_suffix;",
  "    std::string rev_string=\"\";\n    int start=0;\n    int end=string.size()-1;\n\
    \    while (start<end) {\n        rev_string.append(string.substr(start,end));\n\
    \        int mid = (end+start)/2;\n        if (string[mid]==string[mid+1]) {\n\
    \            if (end-start-1>mid+1) {\n                rev_string.append(\"...\"\
    );\n            }\n            end=mid;\n        } else {\n            start=mid+1;\n\
    \        }\n    }\n    rev_string.append(string.substr(start,end));\n    return\
    \ rev_string;", "  if (string == \"\") return \"\";\n  int size = string.length();\n\
    \  std::string suffix = \"abcdefghijklmnopqrstuvwxyz\"; // O(n)\n  std::string\
    \ prefix = \"zyxwvutsrqponmlkjihgfedcba\"; // O(n)\n  for (int i = size - 1; i\
    \ >= 0; i--) { // O(n)\n    bool found = false;\n    for (int j = 0; j < suffix.length();\
    \ j++) {\n      if (string[i] == suffix[j]) {\n        found = true;\n       \
    \ break;\n      }\n    }\n    if (!found) continue;\n    int j = size - 1; //\
    \ O(n)\n    for (int k = 0; k < prefix.length(); k++) {\n      if (string[i] ==\
    \ prefix[k]) {\n        j--;\n        break;\n      }\n    }\n    string += std::to_string(string[i])\
    \ + std::to_string(string[j]);\n  }\n  return string;", "    int n = string.length();\n\
    \    std::string reversed_string;\n    std::string prefix = string.substr(0,n/2);\n\
    \    std::string suffix = string.substr(n/2);\n    std::string postfix_reversed;\n\
    \    for(int i = 0;i < n;i++){\n        postfix_reversed+=suffix[i];\n    }\n\
    \    reversed_string = prefix + postfix_reversed + suffix;\n    return reversed_string;",
  "    // Convert string to prefix of palindromic suffix.\n    string prefix = string;\
    \ // To not modify original string.\n    size_t prefix_len = 0;\n    for (size_t\
    \ i = 0; i < (int)string.length(); ++i) {\n        prefix_len = prefix_len + (int)string[i];\n\
    \    }\n    for (size_t i = 0; i < (int)string.length() - 1; ++i) {\n        if\
    \ (string[i] != string[string.length() - 1 - i]) {\n            break;\n     \
    \   }\n    }\n    string suffix = string[(string)string.length() - prefix_len];\n\
    \    string reverse = reverse(suffix);\n    string prefix = prefix;\n    string\
    \ postfix = reverse;\n    return prefix + postfix + suffix;", "\tsize_t longest\
    \ = 0;\n\tfor (int i = 0, j = string.size()-1; i < j; i++) {\n\t\tif (string[i]\
    \ != string[j]) {\n\t\t\tlongest = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (longest\
    \ == 0)\n\t\treturn \"\";\n\tstd::string result = string;\n\tstd::string reversed\
    \ = string.reverse_copy();\n\tsize_t start = 0;\n\tsize_t end = reversed.size()\
    \ - 1;\n\twhile (start < end) {\n\t\tif (reversed[start] == reversed[end]) {\n\
    \t\t\treversed.erase(start, end + 1);\n\t\t\tstart = start + (reversed.size()-1);\n\
    \t\t\tend = end - 1;\n\t\t} else {\n\t\t\tstart = start + (reversed.size()-1);\n\
    \t\t\tend = end - 1;\n\t\t}\n\t}\n\treversed.erase(end + 1);\n\tstd::string palindrome\
    \ = string + reversed;\n\treturn palindrome;", "    int length = (int)string.size();\n\
    \    // Find the longest postfix of string that is a palindrome.\n    std::string\
    \ post_fix = \"1\";\n    int max_prefix = (int)string.size() - 1;\n    for (int\
    \ i = 1; i < length; ++i) {\n        int temp = (int)string[i] + max_prefix;\n\
    \        if (temp > max_prefix) {\n            max_prefix = temp;\n          \
    \  post_fix = std::string(max_prefix, string[i]);\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    string prefix = string.substr(0, max_prefix);\n    std::string\
    \ reverse = \"\";\n    for (int i = prefix.size(); i > 0; --i) {\n        reverse.push_back(prefix[i\
    \ - 1]);\n    }\n    reverse.push_back(string[length]);\n    return post_fix +\
    \ reverse;", "    std::string new_string = string;\n    std::string prefix_string\
    \ = get_prefix(string, new_string);\n    std::string suffix_string = get_suffix(string,\
    \ new_string);\n    std::string reversed_string = prefix_string + suffix_string.reverse_copy();\n\
    \    new_string += reversed_string;\n    return new_string;", "    std::string\
    \ ans;\n    std::string prefix;\n    // reverse string\n    reverse(string);\n\
    \    // find longest postfix palindromic suffix\n    for (size_t i = 0; i < string.length();\
    \ ++i) {\n        size_t j = i;\n        for (size_t k = i; k < (string.length()\
    \ - 1); ++k) {\n            if (string[k] != string[j]) {\n                prefix\
    \ = string.substr(i, j + 1);\n                j = k;\n                break;\n\
    \            }\n        }\n        ans = prefix + reverse(string.substr(i, j +\
    \ 1));\n    }\n    return ans;", "    // Make the reversed string\n    std::string\
    \ rev_string = string;\n    rev_string.reserve(rev_string.size()/2);\n    std::reverse(rev_string.begin(),\
    \ rev_string.end());\n    // Find the largest prefix of string that is a palindrome\n\
    \    int start = 0;\n    int end = 0;\n    while (end < rev_string.size()) {\n\
    \        start = end;\n        while (start < rev_string.size() && rev_string[start]\
    \ != rev_string[end]) start++;\n        if (start == rev_string.size()) return\
    \ string; // No longer a palindrome, return original\n        end = rev_string.size()\
    \ - 1;\n        while (end > start && rev_string[end] != rev_string[start]) end--;\n\
    \        rev_string.erase(start, end);\n    }\n    // Put reversed string in front\
    \ of original string\n    rev_string.insert(rev_string.begin(), string);\n   \
    \ return rev_string;", "  // O(n)\n  // O(n)\n  int n = string.length();\n  std::string\
    \ reverse = \"\";\n  for (int i = 0; i < n; ++i) {\n    int j = n - i - 1;\n \
    \   while (j >= 0) {\n      reverse += string[j];\n      j--;\n    }\n  }\n  return\
    \ reverse;", "    int n = string.length();\n    std::string palindrome = string;\n\
    \    for (int i = n - 1; i >= 0; i--) {\n        if (palindrome[i] != string[i])\
    \ {\n            break;\n        }\n        palindrome = std::to_string(palindrome)\
    \ + std::to_string(string[i]);\n    }\n    return palindrome;", "    std::reverse(string.begin(),\
    \ string.end());\n    return string;", "    // Convert string to lowercase\n \
    \   std::string result = string;\n    for (std::string::iterator iter = result.begin();\
    \ iter != result.end(); iter++) {\n        if (*iter >= 'a' && *iter <= 'z') {\n\
    \            *iter = tolower(*iter);\n        }\n    }\n    std::string prefix;\n\
    \    std::string suffix;\n    // Find longest prefix that is a palindrome\n  \
    \  for (std::string::iterator iter = result.begin(); iter != result.end(); iter++)\
    \ {\n        if (*iter == '-') {\n            prefix = prefix;\n            iter\
    \ += 1;\n            while (iter != result.end() && *iter != '*') {\n        \
    \        prefix = prefix * iter++;\n            }\n            iter = result.begin();\n\
    \        }\n    }\n    // Find longest suffix that is a palindrome\n    for (std::string::iterator\
    \ iter = result.end(); iter >= result.begin(); iter--) {\n        if (*iter ==\
    \ '-') {\n            suffix = suffix;\n            iter -= 1;\n            while\
    \ (iter != result.begin() && *iter != '*') {\n                suffix = suffix\
    \ * iter--;\n            }\n            iter = result.end();\n        }\n    }\n\
    \    if (prefix == suffix) {\n        return result;\n    }\n    // Concatenate\
    \ postfix of prefix to postfix of suffix\n    std::string reversed_prefix = prefix;\n\
    \    for (int i = 0; i < prefix.size(); ++i) {\n        reversed_prefix[i] = prefix[prefix.size()\
    \ - 1 - i];\n    }\n    std::string reversed_suffix = suffix;\n    for (int i\
    \ = 0; i < suffix.size(); ++i) {\n        reversed_suffix[i] = suffix[suffix.size()\
    \ - 1 - i];\n    }\n    return reversed_prefix + reversed_suffix;", "    // Store\
    \ the longest postfix of supplied string that is a palindrome.\n    std::string\
    \ postfix;\n    // Store the reverse of the string prefix that comes before palindromic\
    \ suffix.\n    std::string reverse;\n    // Store the length of the longest postfix\
    \ of supplied string that is a palindrome.\n    int postfix_length = 0, reverse_length\
    \ = 0;\n    for (int i = 0; i < string.length(); i++) {\n        // Store the\
    \ length of the longest postfix that is a palindrome.\n        if (string[i] ==\
    \ string[string.length() - i - 1]) {\n            postfix_length++;\n        }\n\
    \    }\n    // Store the length of the reverse of the string prefix that comes\
    \ before palindromic suffix.\n    for (int i = 0; i < string.length(); i++) {\n\
    \        // Store the reverse of the string prefix that comes before palindromic\
    \ suffix.\n        if (string[string.length() - i - 1] == string[i]) {\n     \
    \       reverse.append(string[i]);\n        }\n    }\n    // The length of the\
    \ longest postfix of supplied string that is a palindrome can be less than the\
    \ length of the reverse of the string prefix that comes before it.\n    postfix_length\
    \ = postfix_length < reverse_length ? postfix_length : reverse_length;\n    //\
    \ For the first iteration we need to append the reverse of the string prefix that\
    \ comes before palindromic suffix.\n    postfix.append(reverse);\n    // For the\
    \ rest of the iterations we need to append postfix to the end of the supplied\
    \ string.\n    for (int i = 1; i < postfix_length; i++) {\n        postfix.append(string[i]);\n\
    \    }\n    return postfix;", "    std::string temp;\n    size_t start = 0;\n\
    \    size_t end = string.size() - 1;\n    while (start < end && string[start]\
    \ == string[end]) {\n        start++;\n        end--;\n    }\n    temp = string.substr(start,\
    \ end - start + 1);\n    string += string[end - start];\n    temp = temp + string;\n\
    \    string += temp;\n    return string;", "    int n = string.length();\n   \
    \ int i, start_index, end_index;\n    if (n < 2) return string;\n    end_index\
    \ = 0;\n    start_index = 0;\n    i = 1;\n    while (i <= n) {\n        if (string[end_index]\
    \ == string[n - 1 - i]) {\n            end_index++;\n        } else {\n      \
    \      if (end_index == 0) {\n                start_index = i;\n            }\n\
    \            end_index = i;\n        }\n        i++;\n    }\n    if (end_index\
    \ == n - 1)\n        return string + std::string(n - 1, string[n - 1]);\n    if\
    \ (start_index == 0) {\n        return string;\n    }\n    return string + std::string((n\
    \ - 1) - start_index, string[start_index]);", "    string suffix(string);\n  \
    \  for (auto iter = string.cbegin(); iter != string.cend(); ++iter) {\n      \
    \  if (iter == string.cbegin()) break;\n        if (*iter != *(rev(*iter))) {\n\
    \            suffix = string(iter) + suffix;\n        }\n    }\n    return suffix;",
  "    std::string reverse_string = \"\";\n    // Start from the end of the string\n\
    \    for (int i = string.length() - 1; i >= 0; i--) {\n        reverse_string\
    \ += string[i];\n    }\n    // Check if the reverse string is a palindrome\n \
    \   return reverse_string == string\n            ? string // If the reverse string\
    \ is a palindrome\n            : string + string[string.length() - 1 - std::count(reverse_string.begin(),\
    \ reverse_string.end(), string[0])];", "    std::string reverse(string.rbegin(),\
    \ string.rend());\n    std::string result(string);\n    std::reverse(reverse.begin(),\
    \ reverse.end());\n    result += reverse;\n    return result;", "    std::string\
    \ palindrome = string;\n    for (int i = string.length() - 1; i >= 0; i--) {\n\
    \        if (string[i] != string[string.length() - i - 1]) {\n            palindrome.append(string[i]);\n\
    \            break;\n        }\n    }\n    return palindrome;", "    int n = string.length();\n\
    \    std::string ans = \"\";\n    // Find longest palindromic suffix that is a\
    \ prefix of supplied string.\n    for (int i = 1; i <= n; i++) {\n        // Find\
    \ longest palindromic suffix that is a prefix of supplied string.\n        int\
    \ k = (i - 1) % n;\n        auto prefix = string.substr(0, k);\n        auto suffix\
    \ = string.substr(i, n - i);\n        if (suffix == prefix) {\n            ans\
    \ += suffix;\n        }\n    }\n    return ans;", "    int length = (int)string.length();\n\
    \    if (length < 2)\n        return string;\n    std::string prefix;\n    int\
    \ prefix_length = 0;\n    for (int i = 0; i < length; i++) {\n        if (string[i]\
    \ == string[length - i - 1]) {\n            prefix.push_back(string[i]);\n   \
    \         prefix_length++;\n        } else {\n            break;\n        }\n\
    \    }\n    std::string postfix = string[prefix_length];\n    int postfix_length\
    \ = length - (prefix_length + 1);\n    std::string reverse = string[prefix_length\
    \ + prefix_length - 1];\n    reverse.insert(0, postfix.rbegin(), postfix.rend());\n\
    \    return prefix + reverse;", "    int max_length = 0;\n    int pos = 0;\n \
    \   int length = 0;\n    int i = 0;\n    while ((pos = string.find(\" \", i))\
    \ != std::string::npos) {\n        length += (pos - i);\n        i++;\n    }\n\
    \    for (i = length; i < string.length(); i++) {\n        length++;\n    }\n\
    \    i += 1;\n    // This will be the longest palindromic string ending with \"\
    string\"\n    if (length > string.length() - 2) {\n        length -= 2;\n    }\n\
    \    int j = 0;\n    std::string postfix = \"\";\n    int n = length;\n    while\
    \ (n > 1) {\n        if (string[i] != string[n-1]) {\n            break;\n   \
    \     }\n        n -= 1;\n        postfix = postfix + string[i];\n    }\n    //\
    \ Append postfix to the end of the string\n    int k = i + length - 1;\n    while\
    \ (k >= 0) {\n        string[k] = postfix[k];\n        k -= 1;\n    }\n    string\
    \ += i;\n    return string;", "    string ret(\"\");\n    int longest = 0;\n \
    \   int i = 0;\n    for (auto itr = string.begin(); itr != string.end(); ++itr)\
    \ {\n        // Find postfix that is a palindrome.\n        if (longest < itr\
    \ - i + 1) longest = itr - i + 1;\n        // Find postfix that comes before palindromic\
    \ suffix.\n        auto itr1 = itr + longest;\n        while (itr1 != string.end()\
    \ && *itr1 == *(itr - 1)) {\n            itr1++;\n            itr--;\n       \
    \ }\n        string s = *(itr - 1);\n        ret += s;\n        i = itr - 1 -\
    \ longest;\n    }\n    return ret;", "    // Find largest postfix of string that\
    \ is also a palindrome.\n    int postfix_length = 0;\n    int palindromic_length\
    \ = string.length();\n    for (int i = 1; i <= palindromic_length; i++) {\n  \
    \      int postfix = i - 1;\n        int reverse = 0;\n        while (postfix\
    \ >= 0) {\n            reverse = reverse * 10 + string[postfix--];\n        }\n\
    \        if (reverse == i) {\n            postfix_length = i;\n            break;\n\
    \        }\n    }\n\n    // Append postfix to the end of the original string to\
    \ reverse the string prefix.\n    string prefix = string.pop_back();\n    string\
    \ reverse = \"\";\n    for (int i = postfix_length - 1; i >= 0; i--) {\n     \
    \   reverse = reverse + string[i];\n    }\n\n    // Append reverse of prefix to\
    \ end and reverse the string.\n    string result = reverse + prefix + reverse;\n\
    \    std::reverse(result.begin(), result.end());\n    return result;", "\tstd::string\
    \ ret = \"\";\n\tstd::string tmp = string;\n\tfor (auto c : tmp) {\n\t\tret +=\
    \ c;\n\t}\n\tauto start = (tmp.rfind('0') == std::string::npos) ? tmp.size() :\
    \ 0;\n\tauto end = tmp.size();\n\twhile (start < end) {\n\t\tfor (auto i = start;\
    \ i < end; i++) {\n\t\t\tif (tmp[i] != tmp[end - 1 - i]) {\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tif (i >= start) {\n\t\t\tret = ret + tmp[start];\n\t\t\ttmp\
    \ = tmp + tmp[end - 1 - i];\n\t\t\tstart = i;\n\t\t\tend = end;\n\t\t}\n\t}\n\t\
    return ret;", "\tstring palindrome = \"\";\n\tint palindromic = 0;\n\tint length\
    \ = string.length();\n\tint max_length = 0;\n\tint index = 0;\n\n\twhile (string[index]\
    \ != '\\0') {\n\t\tint curr_length = length - index; // Length of current index\n\
    \t\tif (curr_length > max_length) {\n\t\t\tmax_length = curr_length;\n\t\t\tpalindromic\
    \ = index;\n\t\t}\n\t\tindex++;\n\t}\n\n\tpalindrome += string[palindromic];\n\
    \n\tfor (int i = length - palindromic - 1; i >= 0; i--) {\n\t\tstring += string[length\
    \ - palindromic + i];\n\t\tif (string[i] != string[length - palindromic + i])\
    \ {\n\t\t\tstring += string[palindromic];\n\t\t}\n\t}\n\n\treturn string;", " \
    \ int n = string.length();\n  string postfix = string.substr(0, n - 1);\n  string\
    \ reversedPrefix = \"\";\n  for (int i = 0; i < n; i++) {\n    reversedPrefix\
    \ = reversedPrefix + string[i];\n  }\n  reversedPrefix = reversedPrefix.substr(0,\
    \ n - 1);\n  return postfix + reversedPrefix;", "    std::string suffix(string.rbegin(),\
    \ string.rend());\n    std::string prefix(string);\n    std::string palindrome(prefix.begin(),\
    \ prefix.end());\n    palindrome += suffix;\n    return palindrome;", "    std::string\
    \ longestPalindromicSuffix = \"\";\n    int startIndex = 0;\n    int endIndex\
    \ = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i]\
    \ == string[i + 1])\n            startIndex = i;\n        else\n            endIndex\
    \ = i;\n        if (endIndex < startIndex)\n            break;\n        std::reverse(longestPalindromicSuffix.begin()\
    \ + startIndex, longestPalindromicSuffix.begin() + endIndex);\n    }\n    string\
    \ reversedString = string.substr(startIndex, string.length() - endIndex);\n  \
    \  string retString = longestPalindromicSuffix + reversedString;\n    return retString;",
  "    std::string reversed;\n    std::string prefix = string;\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    while (prefix.size() < string.size()) {\n        reversed.append(prefix,\
    \ prefix.size());\n        std::reverse(prefix.begin(), prefix.end());\n    }\n\
    \    reversed.append(string);\n    return reversed;", "    int start = 0;\n  \
    \  for (int i = string.length() - 1; i >= 0; i--) {\n        if (start == i) {\n\
    \            string += string[i];\n            continue;\n        }\n        string\
    \ += string[i] + string.substr(start, i + 1);\n    }\n    return string;", " \
    \   if (string.size() == 0) return string;\n    auto max_start = max_end(string.begin(),\
    \ string.end()) - 1;\n    // If longest palindromic suffix is the only string\
    \ in the string then it is palindrome.\n    if (max_start == string.length())\
    \ return string;\n    // If the longest palindromic suffix is not in the string\
    \ then we are done.\n    // If there is more than one possible string prefix that\
    \ is a palindromic suffix, return the first such prefix.\n    auto prefix = string.substr(0,\
    \ max_start);\n    auto palindrome_suffix = make_palindrome(string.substr(max_start\
    \ + 1));\n    if (palindrome_suffix == string) return prefix;\n    if (prefix\
    \ == string) return palindrome_suffix;\n    return prefix + palindrome_suffix;",
  "  // Find longest postfix of string that is a palindrome.\n  int ln = string.length();\n\
    \  int max_ln = -1; // to store max length for longest palindrome postfix that\
    \ begins with string.\n  for (int i = 0; i < ln; i++) {\n    for (int j = i; j\
    \ < ln; j++) {\n      if (string[i] != string[j] && string[i] == string[j] &&\
    \ i != j) {\n        // if both string are same and different in any place except\
    \ the postfix i is at.\n        max_ln = std::max(max_ln, j - i);\n        break;\n\
    \      }\n    }\n  }\n  assert(max_ln >= 0);\n\n  // Reverse string that comes\
    \ before longest postfix that is a palindrome.\n  std::string reverse_string =\
    \ \"\";\n  int max_len = max_ln;\n  for (int i = (ln - 1); i >= 0; i--) {\n  \
    \  reverse_string += string[i];\n    if (max_len > 0) {\n      reverse_string\
    \ += string(max_len, string[i]);\n      max_len--;\n    }\n  }\n  assert(max_len\
    \ > 0);\n\n  // Append reverse of longest postfix that is a palindrome.\n  reverse_string\
    \ += string[max_ln];\n  assert(max_len + 1 == ln || string[max_ln] == string[max_len]);\n\
    \  return reverse_string;", "    int length = string.length();\n    int max_length\
    \ = 1;\n    int min_length = 1;\n    int max_length_without_palindrome = 0;\n\
    \    // Find max length prefix that is a palindrome.\n    for (int i = 0; i <\
    \ length; ++i) {\n        // Look for the longest postfix of palindrome that starts\
    \ before the next char.\n        int prefix_length = (length - i) + 1;\n     \
    \   int suffix = string[length - prefix_length];\n        int reversed_suffix;\n\
    \        int reverse_start = i;\n        while (suffix != 0) {\n            if\
    \ (suffix%10 == 0) {\n                reversed_suffix = 0;\n            } else\
    \ if (suffix%10 > 0) {\n                reversed_suffix = suffix%10;\n       \
    \         reverse_start = reverse_start - 1;\n            } else {\n         \
    \       reversed_suffix = suffix%10;\n                reverse_start = reverse_start\
    \ + 1;\n            }\n            if (reversed_suffix != 0) {\n             \
    \   break;\n            }\n            suffix = suffix/10;\n        }\n      \
    \  // Adjust prefix length.\n        if (prefix_length < min_length) {\n     \
    \       min_length = prefix_length;\n        }\n        // Adjust max length suffix\
    \ palindrome.\n        if (reversed_suffix == suffix) {\n            max_length\
    \ = prefix_length + 1;\n            if (max_length >= max_length_without_palindrome)\
    \ {\n                max_length_without_palindrome = max_length;\n           \
    \ }\n        }\n    }\n    // Build palindrome with reverse suffix.\n    std::string\
    \ palindrome;\n    for (int i = min_length - 1; i >= 0; --i) {\n        palindrome.push_back(string[reverse_start\
    \ + i]);\n    }\n    return palindrome;", "    std::string suffix;\n    int length_of_string\
    \ = string.length();\n    for (int i = length_of_string; i > 0; i--) {\n     \
    \   suffix = suffix + string[i - 1];\n    }\n    // Reverse the string before\
    \ the first palindromic suffix\n    string.resize(string.length() - suffix.length());\n\
    \    // Append the reverse of the postfix to the end of the string.\n    string\
    \ += suffix;\n    return string;", "    std::reverse(string.begin(), string.end());\n\
    \    std::string reverse(string);\n    std::string palindrome = string;\n    while\
    \ (reverse.find(palindrome) != std::string::npos) {\n        std::reverse(palindrome.begin(),\
    \ palindrome.end());\n        palindrome += palindrome;\n    }\n    return palindrome;",
  "    std::string s = string;\n    // Find the longest postfix of supplied string\
    \ that is a palindrome\n    auto find_palindrome = [&s](const std::string &prefix_string)\
    \ -> bool {\n        auto prefix_end = s.find(prefix_string);\n        if (prefix_end\
    \ == std::string::npos) {\n            return false;\n        }\n        auto\
    \ prefix_len = prefix_end - s.begin();\n        auto suffix_end = prefix_end +\
    \ prefix_len;\n        auto reversed_suffix_end = suffix_end - 1;\n        if\
    \ (prefix_len == 0 && suffix_end == s.size()) {\n            return true;\n  \
    \      }\n        if (prefix_len < suffix_len) {\n            return false;\n\
    \        }\n        for (auto i = prefix_len; i > suffix_len; i--) {\n       \
    \     if (s[i] != s[reversed_suffix_end]) {\n                return false;\n \
    \           }\n            reversed_suffix_end--;\n        }\n        return true;\n\
    \    };\n\n    // Find first palindromic suffix\n    auto it = find_palindrome(\"\
    a\");\n    if (it == s.end()) return \"a\"; // No such palindrome found\n    std::string\
    \ longest = \"\";\n    while (it != s.end()) {\n        longest = s.substr(it);\n\
    \        it = find_palindrome(longest);\n    }\n    // Append reverse of longest\
    \ palindromic suffix to beginning of string\n    std::string rev_longest = s.substr(s.size()\
    \ - longest.size());\n    rev_longest.insert(0, longest);\n    return rev_longest;",
  "    std::string result = string;\n    int start_index = 0;\n    int end_index =\
    \ string.length();\n    while (start_index < end_index) {\n        char temp =\
    \ string[start_index];\n        int temp_length = string.length();\n        //\
    \ If this letter is in the middle, then move the loop by 1.\n        while (start_index\
    \ + temp_length < end_index) {\n            if (temp == string[start_index + temp_length])\
    \ {\n                start_index += temp_length;\n                end_index -=\
    \ temp_length;\n            } else {\n                break;\n            }\n\
    \            temp_length--;\n        }\n        start_index++;\n        // If\
    \ we are here the letter is in the middle of the string, therefore reverse it.\n\
    \        if (start_index == end_index) { // If start index is equal to the end\
    \ index, then the string is a palindrome.\n            end_index--;\n        }\n\
    \        std::string reversed = \"\";\n        // Go through all the letters in\
    \ the string.\n        while (start_index < end_index) {\n            char current_character\
    \ = string[start_index];\n            reversed = reversed + current_character;\n\
    \            start_index++;\n        }\n        // Append the reversed string\
    \ to the original string.\n        result = result + reversed;\n    }\n    return\
    \ result;", "    int max_length = 0;\n    std::string longest = \"\";\n    for\
    \ (auto character : string) {\n        if (character == '*') {\n            break;\n\
    \        }\n        string prefix = \"*\";\n        for (int i = character.length()\
    \ - 1; i >= 0; i--) {\n            string candidate = prefix + character.substr(0,\
    \ i);\n            if (std::all_of(candidate.rbegin(), candidate.rend(), ::isspace)\
    \ &&\n                std::all_of(candidate.begin(), candidate.end(), ::isalnum)\
    \ &&\n                candidate.length() > max_length) {\n                longest\
    \ = candidate;\n                max_length = candidate.length();\n           \
    \ }\n            prefix += character.substr(0, i);\n        }\n    }\n    if (longest\
    \ == \"\") {\n        return string;\n    }\n    return longest + reverse(string);",
  "    string prefix(\"\", 0);\n    for (auto &c: string) {\n        if (c >= 'a'\
    \ && c <= 'z') {\n            prefix = prefix+std::string(1, c);\n        }\n\
    \    }\n    string suffix(\"\", 0);\n    for (auto &c: string) {\n        if (c\
    \ >= 'a' && c <= 'z') {\n            suffix = suffix+std::string(1, c);\n    \
    \    }\n    }\n    assert(prefix == suffix);\n    suffix = std::reverse(prefix.begin(),\
    \ prefix.end());\n    return prefix+suffix;", "    // Find longest palindromic\
    \ suffix\n    unsigned int len = 0;\n    for (auto &c: string) {\n        if (c\
    \ == string[len]) ++len;\n    }\n\n    // Find palindromic prefix by reversing\
    \ first len-1 characters\n    auto pal = string[len - 1];\n    for (unsigned int\
    \ i = 1; i < len; ++i) {\n        pal = string[len - 1 - i] + pal;\n    }\n\n\
    \    // Make palindrome\n    std::string palstr;\n    for (auto &c: pal) {\n \
    \       palstr += c;\n    }\n    return palstr;", "  // find the longest postfix\
    \ of string that is a palindrome.\n  size_t longest = 0;\n  for (size_t i = 1;\
    \ i < string.size(); i++) {\n    // if the first letter is not the same as the\
    \ last letter\n    if (string[i] != string[i - 1]) {\n      longest = i;\n   \
    \   break;\n    }\n  }\n  // append the reverse of the string prefix that comes\
    \ before the palindromic suffix.\n  std::string reversed_prefix = \"\";\n  for\
    \ (size_t i = 0; i < string.size(); i++) {\n    // if the letters are not the\
    \ same as the last letter\n    if (string[i] != string[longest]) {\n      reversed_prefix\
    \ += string[longest];\n      break;\n    }\n  }\n  // return the appended string\n\
    \  return reversed_prefix + string[longest];", "\tint min_len = string.length();\n\
    \tstd::string prefix = string;\n\tbool is_palindrome = true;\n\tfor (int i = min_len\
    \ - 1; i >= 0; i--) {\n\t\tstring reverse = std::string(prefix.rbegin(), prefix.rend());\n\
    \t\tprefix = prefix + (is_palindrome ? reverse : reverse.reverse());\n\t\tmin_len\
    \ = std::min(min_len, prefix.length());\n\t\tis_palindrome = prefix == string;\n\
    \t}\n\treturn prefix;", "\tint size = string.length();\n\tstd::string temp;\n\t\
    string postfix = \"\";\n\tfor (int i = 0; i < size - 1; i++) {\n\t\ttemp += string[i]\
    \ + postfix;\n\t}\n\tpostfix = temp + string[size - 1] + postfix;\n\treturn postfix;",
  "    int maxlength = 0;\n    int palindromelength = 0;\n    int index = -1;\n  \
    \  for (int i = 0; i < string.size(); i++) {\n        if (string[i] == string[string.length()\
    \ - i - 1]) {\n            palindromelength++;\n        } else {\n           \
    \ maxlength++;\n        }\n    }\n    if (palindromelength > maxlength) {\n  \
    \      index = string.size() - palindromelength - 1;\n    }\n    if (index < 0)\
    \ {\n        index = 0;\n    }\n    // add reverse\n    for (int i = 0; i < palindromelength;\
    \ i++) {\n        string += string[index + palindromelength - i - 1];\n    }\n\
    \    return string;", "    string reverse_string;\n    for (auto i = string.size()\
    \ - 1; i >= 0; --i)\n        reverse_string += string[i];\n    reverse_string\
    \ = string+reverse_string;\n    return reverse_string;", "    // Store the length\
    \ of the longest palindromic substring\n    int max_len = -1;\n    int prefix_len\
    \ = 0, suffix_len = string.length() - 1;\n    while (prefix_len <= suffix_len)\
    \ {\n        int len = (prefix_len + suffix_len) / 2;\n        std::string prefix\
    \ = string.substr(0, len);\n        std::string suffix = string.substr(len + 1,\
    \ string.length() - len);\n        if (suffix == std::string(prefix).rbegin()\
    \ && suffix == std::string(prefix).rend()) {\n            prefix_len = len;\n\
    \            suffix_len = len;\n            continue;\n        }\n        if (len\
    \ > max_len) {\n            max_len = len;\n        }\n        prefix_len = len;\n\
    \        suffix_len = len;\n    }\n    std::string palindrome = string;\n    int\
    \ start = prefix_len - 1;\n    int end = string.length() - suffix_len;\n    while\
    \ (start > -1 && end > -1) {\n        if (palindrome[start] != palindrome[end])\
    \ {\n            break;\n        }\n        start -= 1;\n        end -= 1;\n \
    \   }\n    if (start == -1 || end == -1) {\n        throw std::runtime_error(\"\
    Palindrome is too short\");\n    }\n    std::string::size_type max_start = max_len;\n\
    \    if (end > start) {\n        max_start = end - start;\n    }\n    std::string::size_type\
    \ max_end = max_len;\n    if (start > end) {\n        max_end = start - end;\n\
    \    }\n    palindrome.append(palindrome.data() + max_start, max_end - max_start\
    \ + 1);\n    return palindrome;", "    std::string result;\n    // Start from\
    \ the end of the string and keep appending suffixes in the reverse order.\n  \
    \  for (auto it = string.rbegin(); it != string.rend(); it++) {\n        std::string\
    \ s = *it;\n        bool found = true;\n        // Find longest postfix that is\
    \ palindromic.\n        for (auto it1 = string.rbegin(); it1 != string.rend();\
    \ it1++) {\n            if (it1 != it) {\n                // Found a palindromic\
    \ suffix, continue to the next one.\n                s = s + std::string(std::reverse_iterator<std::string::iterator>(it1++));\n\
    \                // Check if palindrome. Prefix and suffix are palindromes if\
    \ and only if\n                // reversed prefix and suffix are equal to each\
    \ other.\n                std::string::reverse_iterator p1(s), p2(s);\n      \
    \          while (p1 != p2) {\n                    if (*p1 != *p2) {\n       \
    \                 found = false;\n                        break;\n           \
    \         }\n                    p1++;\n                    p2++;\n          \
    \      }\n            }\n        }\n        // Found a palindromic suffix, append\
    \ to the string and continue with the next iteration.\n        if (found)\n  \
    \          result += s;\n    }\n    return result;", "    size_t prefix_length\
    \ = 0;\n    for (std::string::const_iterator it = string.begin(); it != string.end();\
    \ ++it) {\n        if (*it == string[prefix_length]) {\n            ++prefix_length;\n\
    \            continue;\n        }\n        if (prefix_length == 0) {\n       \
    \     string += \"1\";\n        } else {\n            string += \"0\";\n     \
    \   }\n        string += string[prefix_length];\n        prefix_length = 0;\n\
    \    }\n    return string;", "    // Initializing and allocating some space\n\
    \    int len = string.size();\n    std::string ans = \"\";\n    std::string rev_string\
    \ = string;\n    std::string prefix = string;\n    // Iterating over each letter\
    \ of string\n    for (int i = 0; i < len; i++)\n        // If letter is uppercase,\
    \ then it's not a palindrome\n        // and we add it to ans string\n       \
    \ if (string[i] >= 'a' && string[i] <= 'z')\n            ans += string[i];\n \
    \   // Iterating over the reverse of string\n    for (int j = len - 1, i = len\
    \ - 1; i >= 0; i--)\n        // If the current letter is lowercase, then it's\
    \ a palindrome\n        // and we add it to rev_string\n        if (string[i]\
    \ >= 'a' && string[i] <= 'z')\n            rev_string += string[i];\n    // Reverse\
    \ the rev_string\n    rev_string.resize(rev_string.size() - 1);\n    // Find the\
    \ longest postfix of rev_string that is a palindrome\n    std::string rev_ans\
    \ = \"\";\n    // Iterating over the first letter of rev_string\n    for (int\
    \ j = 0; j < rev_string.size(); j++)\n        // If letter is uppercase, then\
    \ it's a palindrome\n        // and we add it to rev_ans\n        if (rev_string[j]\
    \ >= 'a' && rev_string[j] <= 'z')\n            rev_ans += rev_string[j];\n   \
    \ // If the length of prefix and rev_ans are the same, then it's not a palindrome\n\
    \    // and we add it to ans string\n    if (prefix.size() == rev_ans.size())\n\
    \        ans += prefix;\n    // Return the final result\n    return ans;", " \
    \ if (string.empty()) return \"\";\n  int start = 0;\n  for (int i = 0; i < string.length();\
    \ i++) {\n    if (string[i] != string[string.length() - i - 1]) {\n      // Reverse\
    \ the string before appending the postfix of it.\n      std::string prefix = string.substr(start,\
    \ i - start);\n      std::string suffix = string.pop_back();\n      string +=\
    \ string.pop_back() + prefix + suffix;\n      start = i;\n    }\n  }\n  return\
    \ string;", "    // Step 1: Find longest postfix that is a palindrome.\n    int\
    \ longest_postfix = 0, prefix_length = 0, suffix_length = 0;\n    for (size_t\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == string[i + 1])\n\
    \            ++suffix_length;\n        else\n            ++longest_postfix;\n\
    \        if (longest_postfix == 0)\n            prefix_length = i;\n    }\n  \
    \  // Step 2: Append reverse of the prefix to the end\n    std::string new_string\
    \ = \"\";\n    new_string.reserve(longest_postfix + prefix_length);\n    for (size_t\
    \ i = prefix_length; i >= 0; --i)\n        new_string.push_back(string[prefix_length\
    \ - 1 - i]);\n    new_string.append(std::string(suffix_length, '\\0'));\n    //\
    \ Step 3: Append postfix to the end\n    new_string.append(string);\n    return\
    \ new_string;", "    std::string res;\n    string prefix;\n    size_t prefix_size\
    \ = 0;\n    for (auto c: string) {\n        if (c != string[prefix_size]) {\n\
    \            prefix_size++;\n            prefix = prefix.append(c);\n        \
    \    if (prefix_size < string.length()) prefix = prefix.append(string[prefix_size]);\n\
    \        }\n        if (prefix_size == string.length()) res = res;\n        else\
    \ if (c==string[prefix_size]) res = res.append(string[prefix_size]);\n    }\n\
    \    return res;", "    auto prefix_string = string;\n    auto prefix_length =\
    \ string.length();\n\n    // Find the longest postfix string that is a palindrome\n\
    \    auto start = prefix_string.find_last_not_of(\n        prefix_string.rbegin(),\
    \ prefix_string.rend(), [](char c) {\n            return std::isalpha(c) || std::isdigit(c);\n\
    \        });\n    auto end = prefix_string.find_first_not_of(\n        prefix_string.begin(),\
    \ prefix_string.end(), [](char c) {\n            return std::isalpha(c) || std::isdigit(c);\n\
    \        });\n    auto postfix = prefix_string.substr(start, end - start + 1);\n\
    \    prefix_string.erase(end, prefix_string.end());\n\n    // Append reverse of\
    \ prefix string before postfix\n    prefix_string.insert(prefix_string.begin(),\
    \ prefix_string.pop_back());\n\n    // Reverse postfix string and append it to\
    \ the end of supplied string\n    std::reverse(postfix.begin(), postfix.end());\n\
    \    return prefix_string + postfix;", "    string palindrome = string;\n    string\
    \ reverse = string;\n    reverse.reserve(palindrome.size());\n    reverse.push_back('\\\
    0');\n    for (int i = palindrome.size() - 1; i >= 0; i--) {\n        if (palindrome[i]\
    \ == reverse[i]) {\n            reverse.erase(reverse.begin() + i);\n        }\
    \ else {\n            reverse.insert(reverse.begin() + i, palindrome[i]);\n  \
    \          break;\n        }\n    }\n    reverse.erase(reverse.end() - 1);\n \
    \   return palindrome + reverse;", "    std::string result;\n    // Find the longest\
    \ postfix that is a palindrome.\n    int max_length = 0;\n    int index_start\
    \ = 0;\n    int index_end = 0;\n    int max_index = 0;\n    while (max_length\
    \ < string.length()) {\n        max_index = index_start;\n        // Find the\
    \ postfix with longest length.\n        for (; max_index != string.length() -\
    \ max_length; max_index++)\n            if (string[max_index] != string[max_index\
    \ + 1])\n                break;\n        // Append the suffix to the end of string.\n\
    \        result += string[max_index];\n        max_length = string.length() -\
    \ max_index;\n    }\n    return result;", "    std::string postfix = string;\n\
    \    std::string reverse_postfix = postfix;\n    int i = 0; // Index of postfix\
    \ substring\n    // Find the longest postfix substring that is palindromic.\n\
    \    while (i < postfix.length() - 1) {\n        int j = i + 1; // Index of next\
    \ character in reverse substring\n        std::string reverse_substr = reverse_postfix.substr(i,\
    \ j);\n        // Compare the substring with the original substring.\n       \
    \ if (string[i] == reverse_substr[0] && string[i] == reverse_substr[reverse_substr.size()\
    \ - 1]) {\n            postfix = postfix + reverse_substr;\n            i = j;\n\
    \        } else {\n            i++;\n        }\n    }\n    return postfix;", " \
    \   int size = string.size();\n    int i = 0, j = 0;\n    while (i < size) {\n\
    \        while (j >= size - i && string[i] == string[j]) {\n            j--;\n\
    \        }\n        if (j >= size - i) {\n            string += string[j] + i;\n\
    \            j = size;\n        }\n        i++;\n        j = 0;\n    }\n    return\
    \ string;", "\tstd::stack<char> stack;\n\tstd::stack<char> postfix_stack;\n\t\
    std::string palindrome;\n\n\tstd::string postfix = \"\";\n\tstd::string::size_type\
    \ pos;\n\tstd::string reverse = \"\";\n\n\tpos = 0;\n\twhile (pos < string.size())\
    \ {\n\t\tpostfix += string[pos++];\n\n\t\twhile (pos < string.size() && string[pos]\
    \ == string[string.size() - pos - 1]) {\n\t\t\treverse = reverse + string[pos++];\n\
    \t\t}\n\n\t\tif (reverse == postfix && stack.empty()) {\n\t\t\tpalindrome = postfix.substr(0,\
    \ pos);\n\t\t\tpostfix_stack.push(palindrome);\n\t\t\twhile (!postfix_stack.empty())\
    \ {\n\t\t\t\tpalindrome = postfix_stack.top();\n\t\t\t\tpostfix_stack.pop();\n\
    \t\t\t\tpostfix_stack.push(postfix + palindrome);\n\t\t\t}\n\t\t\tbreak;\n\t\t\
    }\n\n\t\tpostfix_stack.push(reverse);\n\t\treverse = \"\";\n\t\tpostfix = postfix_stack.top();\n\
    \t\tpostfix_stack.pop();\n\t}\n\n\treturn palindrome;", "  int n = string.length();\n\
    \  // Prefix and suffix of longest palindrome.\n  std::string prefix = std::string(\"\
    \ \");\n  std::string suffix = std::string(\" \");\n  // Loop through the string\
    \ and compare characters until the longest postfix is reached.\n  for (int i =\
    \ 0; i < n - 1; i++) {\n    // If character before is different than character\
    \ after, append them.\n    if (string[i] != string[n - i - 1]) {\n      prefix\
    \ += string[i];\n    }\n    else {\n      suffix += string[n - i - 1];\n     \
    \ break;\n    }\n  }\n  // Return the reversed prefix string and the reversed\
    \ suffix string.\n  return std::string(prefix.rbegin(), prefix.rend()) + std::string(suffix.rbegin(),\
    \ suffix.rend());", "\tstd::string longestPalindrome = \"\";\n\tlong long palindromicStringSize\
    \ = 0;\n\tlong long palindromicStringStart = 0;\n\tlong long palindromicStringEnd\
    \ = 0;\n\tlong long palindromicStringIndex = 0;\n\n\t// If string is empty then\
    \ return empty string\n\tif(string.empty()) {\n\t\treturn \"\";\n\t}\n\n\t// Find\
    \ longest postfix of string which is a palindrome by calculating the\n\t// length\
    \ of longest common prefix of string and reverse of string.\n\tpalindromicStringSize\
    \ = std::count(string.rbegin(), string.rend(), string[0]);\n\tpalindromicStringEnd\
    \ = (long long)(string.length() - 1);\n\tpalindromicStringStart = palindromicStringEnd\
    \ - palindromicStringSize;\n\tpalindromicStringIndex = 0;\n\n\t// Now append reverse\
    \ of the string prefix before palindromic suffix at the end of\n\t// the longest\
    \ palindrome\n\twhile(palindromicStringIndex < palindromicStringStart) {\n\t\t\
    longestPalindrome += string[palindromicStringIndex++];\n\t}\n\n\t// Now append\
    \ palindromic suffix and reverse of the string suffix after palindromic prefix\n\
    \tlongestPalindrome += string[palindromicStringIndex++];\n\twhile(palindromicStringIndex\
    \ < palindromicStringEnd) {\n\t\tlongestPalindrome += string[palindromicStringIndex++];\n\
    \t}\n\n\treturn longestPalindrome;", "    string longest = \"\";\n    string reverse_longest\
    \ = \"\";\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        string\
    \ postfix_with_postfix_of_i_postfix = string.substr(0, i) + string.substr(i, string.length());\n\
    \n        string prefix_of_postfix_of_i_postfix = reverse_longest;\n        reverse_longest\
    \ = \"\";\n\n        for (int j = 0; j < postfix_with_postfix_of_i_postfix.length();\
    \ ++j) {\n            if (postfix_with_postfix_of_i_postfix.at(j) != prefix_of_postfix_of_i_postfix.at(j))\
    \ {\n                reverse_longest = prefix_of_postfix_of_i_postfix;\n     \
    \       }\n            prefix_of_postfix_of_i_postfix = postfix_with_postfix_of_i_postfix.substr(0,\
    \ j) + postfix_with_postfix_of_i_postfix.substr(j, postfix_with_postfix_of_i_postfix.length());\n\
    \        }\n\n        string reverse_prefix_of_postfix_of_i_postfix = reverse_longest;\n\
    \        reverse_longest = \"\";\n\n        for (int j = 0; j < postfix_with_postfix_of_i_postfix.length();\
    \ ++j) {\n            if (postfix_with_postfix_of_i_postfix.at(j) != reverse_prefix_of_postfix_of_i_postfix.at(j))\
    \ {\n                reverse_longest = reverse_prefix_of_postfix_of_i_postfix;\n\
    \            }\n            reverse_prefix_of_postfix_of_i_postfix = postfix_with_postfix_of_i_postfix.substr(0,\
    \ j) + reverse_prefix_of_postfix_of_i_postfix.substr(j, postfix_with_postfix_of_i_postfix.length());\n\
    \        }\n\n        if (longest < reverse_longest) {\n            longest =\
    \ reverse_longest;\n        }\n    }\n\n    return longest;", "  assert(!string.empty());\n\
    \  assert(string.length() >= 2);\n\n  // Find the longest postfix that is a palindrome\n\
    \  int max_palindrome = string.length() - 1;\n  int i = 0;\n  while (i < string.length()\
    \ && max_palindrome > 0 && string[i] == string[max_palindrome]) {\n    max_palindrome--;\n\
    \    i++;\n  }\n  assert(i >= 0);\n\n  // Append the reverse of the prefix to\
    \ the suffix string\n  std::string suffix(string, i, string.length());\n  std::string\
    \ prefix = prefix.substr(0, max_palindrome);\n  std::string reverse = std::string(suffix.rbegin(),\
    \ suffix.rend());\n  return prefix + reverse;", "    int lst_len = string.length();\n\
    \    int max_len = lst_len;\n    int prefix_len = 0;\n    for (int i = 0; i <\
    \ lst_len; i++) {\n        int char_index = i;\n        char c = string[char_index];\n\
    \        if (c != string[lst_len - i - 1])\n            char_index = string[string.length()\
    \ - 1 - i];\n        int char_index_2 = string.length - 1 - i;\n        c = string[char_index_2];\n\
    \        if (c != string[string.length() - 1 - i - 1])\n            char_index_2\
    \ = string[string.length() - 1 - 1 - i];\n        char d = string[string.length\
    \ - 1 - i];\n        char e = string[string.length - 1 - i - 1];\n        string\
    \ pal_char = c * 10 + e * 10 + d;\n        if (pal_char.length() > max_len) {\n\
    \            max_len = pal_char.length();\n            prefix_len = i;\n     \
    \   }\n    }\n    std::string output = string.substr(0, prefix_len) + string.reverse_copy(0,\
    \ prefix_len, string.length() - 1 - prefix_len);\n    return output;", "  // Find\
    \ longest postfix that is palindrome.\n  // It can be done by reversing the postfix\
    \ and comparing with the original.\n  // This is O(n) but we can't do better than\
    \ O(n) because postfix string can be of any length.\n  std::string postfix = \"\
    \", reverse = \"\";\n  for (int i = 0; i < string.length(); i++) {\n    postfix\
    \ += string[i];\n    reverse += string[string.length() - i - 1];\n  }\n  return\
    \ postfix + reverse;", "    int n = string.length();\n    if (n == 0)\n      \
    \  return \"Empty string\";\n    std::string longest = palindrome(string);\n \
    \   string prefix;\n    for (int i = string.length() - 1; i >= 0; i--) {\n   \
    \     int index = string.find(longest, i);\n        if (index == -1)\n       \
    \     break;\n        prefix = string.substr(i, longest.length());\n        string\
    \ rev;\n        rev = revrint(prefix);\n        rev.insert(rev.begin(), prefix.length());\n\
    \        string = prefix + rev;\n    }\n    return string;", "    int n = string.length();\n\
    \    int m = 0;\n    std::string reverse_string = \"\";\n    std::string new_string\
    \ = \"\";\n\n    if (n <= 0) {\n        return reverse_string;\n    }\n    int\
    \ max_ind = (n - 1) / 2;\n    for (int i = 1; i < max_ind; i++) {\n        if\
    \ (string[i] == string[max_ind]) {\n            m += 1;\n        } else {\n  \
    \          break;\n        }\n    }\n    if (m == 1) {\n        new_string.append(&string[max_ind],\
    \ n - max_ind);\n        reverse_string.append(&string[1], max_ind);\n    } else\
    \ {\n        new_string.append(&string[max_ind], n - max_ind - 1);\n        reverse_string.append(&string[m\
    \ - 1], m);\n    }\n    return new_string + reverse_string;", "    // Find the\
    \ longest postfix that is a palindrome and append to beginning.\n    std::string\
    \ longest = string.substr(0, string.length() / 2);\n    std::string postfix =\
    \ string.substr(string.length() / 2);\n    std::string reversed_postfix = postfix.substr(0,\
    \ postfix.length()/2);\n    string result = prefix + reverse + longest;\n    return\
    \ result;", "    if (string == \"\\0\") return \"\";\n    if (string.length()\
    \ <= 1) return string;\n\n    // Find the longest palindrome\n    std::string\
    \ longest = \"\";\n    for (size_t i = 0; i < string.length(); ++i) {\n      \
    \  std::string p = string;\n        std::reverse(p, p + i + 1);\n        // if\
    \ the reversed suffix is different from the original palindrome\n        if (p\
    \ != string.substr(0, i)) continue;\n        if (p.length() > longest.length())\
    \ longest = p;\n    }\n    return longest;", "    std::string result = string;\n\
    \    // Find the longest postfix of supplied string that is a palindrome.\n  \
    \  size_t max = string.length();\n    for (size_t i = 1; i < max; ++i) {\n   \
    \     if (string[i] != string[max - i]) {\n            break;\n        }\n   \
    \ }\n    // Append the reverse of a string prefix that comes before the\n    //\
    \ palindromic suffix.\n    for (size_t i = max - i; i > 0; --i) {\n        result\
    \ += string[max - i];\n    }\n    return result;", "    std::string longestPalindrome\
    \ = \"\";\n    std::string lastPalindrome = string;\n    std::string firstPalindrome\
    \ = string;\n\n    while (!firstPalindrome.empty()) {\n        int currLength\
    \ = firstPalindrome.size();\n        firstPalindrome = firstPalindrome.substr(currLength\
    \ - 1);\n        lastPalindrome = lastPalindrome.substr(0, currLength - 1);\n\
    \        if (firstPalindrome == lastPalindrome) {\n            if (longestPalindrome.length()\
    \ <= currLength)\n                longestPalindrome = firstPalindrome;\n     \
    \       else\n                longestPalindrome += \" \" + firstPalindrome;\n\
    \        }\n        else\n            break;\n    }\n    return longestPalindrome;",
  "    // Find longest prefix of string that is palindrome.\n    int i = 0;\n    int\
    \ j = string.length() - 1;\n    while (i < j) {\n        if (string[i] != string[j])\
    \ {\n            int k = i;\n            int l = j;\n            if (string[i]\
    \ < string[j]) {\n                k = j;\n                l = i;\n           \
    \ }\n            while (k != l) {\n                swap(string[k], string[l]);\n\
    \                k++;\n                l--;\n            }\n            break;\n\
    \        }\n        i++;\n        j--;\n    }\n    return string;", "    string\
    \ prefix = string;\n    string palindrome = prefix;\n    string suffix = prefix;\n\
    \    string reverse = suffix;\n    int i = prefix.size();\n    while (i != 0)\
    \ {\n        std::swap(prefix[i], prefix[--i]);\n    }\n    i = reverse.size();\n\
    \    while (i != 0) {\n        std::swap(reverse[i], reverse[--i]);\n    }\n \
    \   i = prefix.size();\n    while (i != 0) {\n        if (prefix[i] != reverse[i])\
    \ {\n            reverse.insert(--i, prefix[i]);\n        }\n    }\n    return\
    \ palindrome + reverse + suffix;", "    std::string result;\n    int longest_postfix\
    \ = 0;\n    for (size_t i = 0; i < (string.length() - 1); i++) {\n        std::string\
    \ prefix = string.substr(0, i);\n        std::string postfix = string.substr(i);\n\
    \        std::string reversed_prefix = prefix.substr(0, longest_postfix);\n  \
    \      std::string reversed_postfix = postfix.substr(longest_postfix, postfix.length());\n\
    \        reversed_postfix = reversed_prefix + reversed_postfix;\n        if (reversed_prefix\
    \ == reversed_postfix) {\n            longest_postfix = i;\n            result\
    \ += prefix + \"#\" + postfix;\n        }\n    }\n    return result;", "  int\
    \ prefix_length = 0;\n  int max_suffix_length = 0;\n\n  for(int i = 0; i < string.size();\
    \ ++i) {\n    if(string[i] == string[string.size() - 1 - i]) {\n      prefix_length++;\n\
    \    } else {\n      max_suffix_length = std::max(max_suffix_length, prefix_length);\n\
    \      prefix_length = 0;\n    }\n  }\n\n  max_suffix_length = std::max(max_suffix_length,\
    \ prefix_length);\n\n  // If maximum suffix is not 1 then there is no palindrome.\n\
    \  if(max_suffix_length != 1) {\n    return \"\";\n  }\n\n  // Reverse the string\
    \ and add it back to the end.\n  std::string suffix = \"!\";\n  for(int i = 0;\
    \ i < max_suffix_length; ++i) {\n    suffix += string[max_suffix_length - 1 -\
    \ i];\n  }\n\n  return string + suffix;", "    std::string postfix_to_check =\
    \ \"\";\n    bool is_palindrome = true;\n    for (int i = 0; i <= string.length();\
    \ i++) {\n        postfix_to_check = string[string.length() - i - 1] + postfix_to_check;\n\
    \        if (string.compare(i - 1, string.length() - i - 1, postfix_to_check.begin(),\
    \ postfix_to_check.end()) == 0)\n            is_palindrome = false;\n    }\n \
    \   if (is_palindrome)\n        return string;\n    else\n        return \"\";",
  "    int n = string.size();\n    std::string result;\n    if (n == 0) {\n      \
    \  return string;\n    }\n    int max_length = 0;\n    int prefix_length = 0;\n\
    \    for (int i = 0; i < n; ++i) {\n        int length = (i < n - 1) ? i + 1 :\
    \ i;\n        std::string prefix = string.substr(0, length);\n        int prefix_length\
    \ = prefix.size();\n        std::string suffix = make_palindrome(string.substr(length));\n\
    \        int suffix_length = suffix.size();\n        std::string reverse_of_prefix\
    \ = make_palindrome(prefix.substr(0, prefix_length));\n        int reverse_of_prefix_length\
    \ = reverse_of_prefix.size();\n        std::string reverse_suffix = make_palindrome(suffix.substr(0,\
    \ suffix_length));\n        int reverse_suffix_length = reverse_suffix.size();\n\
    \        if (reverse_of_prefix_length >= suffix_length &&\n            prefix_length\
    \ + reverse_of_prefix_length >= suffix_length &&\n            prefix_length +\
    \ reverse_of_prefix_length + suffix_length >= suffix_length &&\n            reverse_of_prefix_length\
    \ + reverse_suffix_length >= suffix_length &&\n            prefix_length + reverse_of_prefix_length\
    \ + reverse_suffix_length == max_length) {\n            // found a palindrome\n\
    \            result = result + prefix + reverse_of_prefix + suffix;\n        \
    \    max_length = prefix_length + reverse_of_prefix_length + suffix_length;\n\
    \        }\n    }\n    return result;", "  if (string.length() <= 1) return string;\n\
    \  auto s = string; s += 'a' - 'A'; // Add lower case letter to make first letter\
    \ of string\n  size_t n = s.length();\n  std::string longest, shortest;\n  for\
    \ (size_t i = 1; i < n; ++i) {\n    size_t j = n - i; // The length of longest\
    \ palindromic suffix\n    while (j > 0 && s.at(j) != s.at(j - 1)) --j;\n    //\
    \ If the lengths are the same, the longest palindromic suffix is now in s.at(j)\n\
    \    if (j == i) longest = s.substr(i, j - i);\n    else shortest = s.substr(i,\
    \ j - i) + s.at(j);\n    s = shortest;\n  }\n  return longest;", "    if (string.length()\
    \ <= 1) return string;\n    string s = string;\n    string suffix = \"\";\n  \
    \  string postfix = \"\";\n    bool found = false;\n    for (unsigned int i =\
    \ 0; i < s.length(); i++) {\n        if (s[i] == string[s.length() - i - 1]) {\n\
    \            found = true;\n            break;\n        }\n    }\n    if (!found)\
    \ return string;\n    do {\n        postfix += string[i];\n    } while (++i <\
    \ s.length());\n    std::string result = postfix.append(suffix).append(postfix);\n\
    \    result.erase(result.find_first_not_of('0'), result.find_last_not_of('0'));\n\
    \    return result;", "    string reverse(string.rbegin(), string.rend());\n \
    \   string longest(string.substr(0, string.size() - 1));\n    longest.insert(0,\
    \ \"0\");\n    longest.append(reverse);\n    return longest;", "    std::string\
    \ palindrome = \"\";\n    int length = string.length();\n    int max_postfix =\
    \ 0;\n    int min_prefix = string.length() - 1;\n    for (int i = 0; i < length;\
    \ i++) {\n        max_postfix = std::max(max_postfix, i);\n        min_prefix\
    \ = std::min(min_prefix, i);\n    }\n    for (int i = 1; i < length; i++) {\n\
    \        if (max_postfix > i) {\n            int new_postfix = min_prefix + 1;\n\
    \            while (string[new_postfix] != string[i - 1])\n                new_postfix++;\n\
    \            std::string suffix = string.substr(new_postfix, i - new_postfix +\
    \ 1);\n            palindrome += suffix;\n        }\n    }\n    return palindrome;",
  "    std::string reverse = \"\";\n    int max_postfix_length = 0, postfix_length\
    \ = 0, prefix_length = 0;\n    \n    // Initialize string prefix and postfix to\
    \ longest postfix of supplied string.\n    for (std::string::size_type i = 0;\
    \ i < string.length(); ++i) {\n        if (string[i] == string[string.length()\
    \ - 1 - i]) {\n            ++postfix_length;\n            if (postfix_length >\
    \ max_postfix_length)\n                max_postfix_length = postfix_length;\n\
    \        }\n        else\n            postfix_length = 0;\n    }\n    \n    //\
    \ If there is less than one postfix of supplied string, return empty string.\n\
    \    if (postfix_length < 2)\n        return \"\";\n    \n    // Initialize string\
    \ prefix and postfix to longest postfix of supplied string.\n    for (std::string::size_type\
    \ i = 0; i < string.length(); ++i) {\n        if (string[i] == string[string.length()\
    \ - 1 - i]) {\n            ++prefix_length;\n            if (prefix_length > max_postfix_length)\n\
    \                max_postfix_length = prefix_length;\n        }\n        else\n\
    \            prefix_length = 0;\n    }\n    \n    // If there is less than one\
    \ postfix of supplied string, return empty string.\n    if (prefix_length < 2)\n\
    \        return \"\";\n    \n    // If string contains only 1 char or is empty\
    \ return empty string.\n    if (string.length() < 2)\n        return \"\";\n \
    \   \n    // Initialize prefix and postfix strings to first and last chars of\
    \ supplied string.\n    std::string prefix, postfix;\n    prefix = string.substr(0,\
    \ string.length() - 1);\n    postfix = string.substr(string.length() - 1, string.length());\n\
    \    \n    // Initialize new string to concatenate with reversed prefix.\n   \
    \ std::string reversed_prefix;\n    for (int i = 0; i < prefix_length; ++i) {\n\
    \        reversed_prefix += prefix[i];\n    }\n    \n    // Initialize new string\
    \ to concatenate with reversed postfix.\n    std::string reversed_postfix;\n \
    \   for (int i = 0; i < max_postfix_length; ++i) {\n        reversed_postfix +=\
    \ postfix[i];\n    }\n    \n    // Initialize new string with concatenation of\
    \ both reversed prefix and reversed postfix.\n    std::string concat = reversed_prefix\
    \ + reversed_postfix;\n    \n    // Return new string.\n    return concat;", " \
    \   std::string prefix;\n    std::string suffix;\n\n    // Step 1: Finding longest\
    \ possible prefix that is a palindrome\n    // Let's assume that string begins\
    \ with a longest palindromic prefix\n    // because all palindromic prefixes are\
    \ of length 1.\n    // It can be easily extended to cover all possibilities though.\n\
    \    prefix = string;\n    for (int i = 0; i < string.length() - 1; i++) {\n \
    \       prefix += string[i];\n        suffix += string[string.length() - i - 1];\n\
    \        if (is_palindrome(prefix)) {\n            break;\n        }\n    }\n\n\
    \    // Step 2: Finding longest possible suffix that is a palindrome\n    // We\
    \ now have a longest postfix that is a palindrome.\n    // Let's assume that string\
    \ ends with a longest palindromic suffix.\n    string reversed = get_reverse(prefix);\n\
    \    size_t start_pos = prefix.size();\n    for (size_t i = 0; i < reversed.length();\
    \ i++) {\n        string postfix = reversed.substr(0, i) + postfix;\n        std::string\
    \ current_prefix = prefix + reversed.substr(0, i);\n        if (is_palindrome(postfix))\
    \ {\n            // We have found a palindrome that starts with the reverse of\
    \ the longest postfix.\n            // Append to string\n            return prefix\
    \ + postfix + suffix;\n        }\n        start_pos = i;\n    }\n\n    // Nothing\
    \ found\n    return string;", "    std::string res = string;\n    int start =\
    \ 0, end = 0, len = string.size();\n    while (end < len) {\n        end = find_palindrome_end_index(string,\
    \ start, end);\n        if (end - start > 1) {\n            int start = end -\
    \ 1;\n            while (start > 0) {\n                res.insert(end - 1, string[--start]);\n\
    \            }\n        }\n    }\n    return res;", "    std::string postfix;\n\
    \    int longest = 0;\n    int l = 0;\n    int r = string.length();\n    while(l\
    \ < r) {\n        postfix.push_back(string[l]);\n        longest++;\n        if\
    \ (postfix.back() == string[r]) r--;\n        else if(postfix.back() != string[r])\
    \ break;\n        l++;\n    }\n    l = 0;\n    r = string.length();\n    while(l\
    \ < r) {\n        postfix.push_back(string[r]);\n        longest++;\n        if\
    \ (postfix.back() == string[l]) l++;\n        else if(postfix.back() != string[l])\
    \ break;\n        r--;\n    }\n    postfix.push_back('\\0');\n    return postfix.substr(0,\
    \ longest);", "    int n = string.length();\n    bool is_palindrome = true;\n\
    \    int i = 0;\n    int j = n - 1;\n\n    while ((i < j) && (is_palindrome))\
    \ {\n        if (string[i] != string[j]) {\n            is_palindrome = false;\n\
    \        }\n\n        i++;\n        j--;\n    }\n\n    if (is_palindrome) {\n\
    \        return string + std::to_string(j);\n    }\n\n    std::string result =\
    \ string;\n\n    while ((i > 0) || (j > 0)) {\n        std::string temp_postfix\
    \ = \"\";\n        std::string temp_prefix = \"\";\n\n        if (j > 0) {\n \
    \           temp_postfix = std::to_string(j);\n        }\n\n        if (i > 0)\
    \ {\n            temp_prefix = string.substr(0, i);\n        }\n\n        std::string\
    \ temp_postfix_reversed = temp_postfix.rbegin();\n        std::string temp_prefix_reversed\
    \ = temp_prefix.rend();\n\n        std::string temp_postfix_appended = temp_postfix_reversed\
    \ + temp_postfix;\n        std::string temp_prefix_appended = temp_prefix_reversed\
    \ + temp_prefix;\n\n        result = temp_postfix_appended + temp_prefix_appended;\n\
    \        i--;\n        j--;\n    }\n\n    return result;", "    std::string ans;\n\
    \    int max_len = string.length();\n    string reverse;\n    reverse.resize(max_len,\
    \ 0);\n    reverse[max_len - 1] = 1;\n    size_t i;\n    for (i = max_len - 1;\
    \ i >= 0; --i) {\n        reverse[max_len - 1 - i] = string[i];\n    }\n    for\
    \ (i = max_len - 1; i >= 0; --i) {\n        if ((string[i] != string[max_len -\
    \ 1 - i]) && reverse[max_len - 1 - i] != 0) {\n            ans = ans + string[i]\
    \ + reverse[max_len - 1 - i];\n        }\n    }\n    return ans;", "    std::string\
    \ result = string;\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    int length = 0;\n    int pos = string.size() - 1;\n    while\
    \ (pos >= 0) {\n        int cur_length = string[pos].size() + 1;\n        length\
    \ = (length < cur_length) ? length : cur_length;\n        pos--;\n    }\n    //\
    \ Reverse of the string prefix that comes before the palindromic suffix.\n   \
    \ std::string reverse_str = \"\";\n    for (int i = length - 1; i >= 0; i--) {\n\
    \        reverse_str += string[i];\n    }\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    for\
    \ (int i = 0; i < length / 2; i++) {\n        result += reverse_str;\n    }\n\
    \    return result;", "\tstd::string result;\n\tfor (int i = 0; i < string.length();\
    \ ++i) {\n\t\tstring += string[i];\n\t}\n\tstring += string[0];\n\tstring.resize(string.length()\
    \ - 1);\n\tstd::reverse(string);\n\tresult += string;\n\treturn result;", "  \
    \  // Return an empty string if supplied string is empty.\n    if (string.empty())\
    \ return \"\";\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    std::string longest = string;\n    std::string palindrome = string;\n   \
    \ for (size_t i = 0; i < string.length(); ++i) {\n        std::string prefix =\
    \ string;\n        // Find postfix of string that is a palindrome.\n        while\
    \ (prefix.size() > i && prefix[i] != longest[i])\n            prefix.erase(prefix.begin());\n\
    \        // Append reverse of string prefix that comes before the palindromic\
    \ suffix.\n        if (prefix.size() >= i)\n            std::reverse(prefix.begin(),\
    \ prefix.end());\n        palindrome = palindrome + prefix + longest[i];\n   \
    \ }\n    return palindrome;", "    // Initialize longest palindrome length with\
    \ length of supplied string.\n    int length = string.length();\n    // Initialize\
    \ longest palindrome length to zero.\n    int max_length = 0;\n    // Initialize\
    \ empty longest palindrome to an empty string.\n    std::string longest = \"\"\
    ;\n    // Initialize an empty string to append reverse of longest palindrome prefix.\n\
    \    std::string prefix = \"\";\n    // Initialize a temp string to append the\
    \ reverse of longest palindrome suffix.\n    std::string suffix = \"\";\n    //\
    \ Iterate over supplied string from beginning to end. \n    // For each character,\
    \ append the character to the prefix and suffix strings.\n    for (int i = 0;\
    \ i <= (length - 1); i++) {\n        prefix.append(string[i]);\n        suffix.append(string[length\
    \ - i - 1]);\n        // If length is equal to longest palindrome length then\
    \ update the longest palindrome.\n        if (length == max_length) {\n      \
    \      longest = prefix;\n            max_length = max_length - 1;\n        }\n\
    \        // If length is greater than longest palindrome length then update the\
    \ longest palindrome.\n        else if (length > max_length) {\n            longest\
    \ = prefix;\n            max_length = length;\n        }\n    }\n    // Append\
    \ the reverse of longest palindrome prefix to empty string.\n    prefix = reverse(strcpy(prefix.c_str(),\
    \ longest.c_str()));\n    // Append the reverse of longest palindrome suffix to\
    \ empty string.\n    suffix = reverse(strcpy(suffix.c_str(), longest.c_str()));\n\
    \    // Append the reverse of longest palindrome prefix to longest palindrome\
    \ suffix.\n    suffix = prefix + suffix;\n    // Return the longest palindrome\
    \ with the appended suffix and prefix.\n    return prefix + suffix;", "\tint n\
    \ = string.size();\n\t// Assume that we can solve this faster than O(n^2) time.\n\
    \tstd::string result;\n\t// Initialize result with an empty string.\n\tresult.reserve(string.size()\
    \ + 1);\n\t// Start with an empty string.\n\tstd::cout << string.size() << std::endl;\n\
    \tresult.append(string.begin(), string.end());\n\t// While there are still characters\
    \ in the string,\n\t// reverse the characters and append them to the result.\n\
    \twhile (n-- > 0)\n\t\tstd::reverse(result.begin(), result.end());\n\tstd::cout\
    \ << result.size() << std::endl;\n\treturn result;", "    \n    // Find the longest\
    \ postfix that is a palindrome.\n    int max_palindromic_length = 0;\n    int\
    \ length_of_longest = 0;\n    \n    for (int i=0; i < string.size(); i++) {\n\
    \        int palindromic_length = string[i] - '0';\n        int prefix_size =\
    \ string.size() - i;\n        \n        if (palindromic_length >= max_palindromic_length\
    \ || (palindromic_length == max_palindromic_length && prefix_size < length_of_longest))\
    \ {\n            length_of_longest = prefix_size;\n            max_palindromic_length\
    \ = palindromic_length;\n        }\n    }\n    \n    // Append reverse of string\
    \ prefix that comes before longest postfix to the end of the string.\n    std::string\
    \ palindrome = string;\n    for (int i=0; i < length_of_longest; i++) {\n    \
    \    palindrome = string(max_palindromic_length - i, palindrome) + palindrome;\n\
    \    }\n    \n    return palindrome;", "    std::string reverse;\n    size_t count\
    \ = 0;\n    for (auto it = string.begin(); it != string.end(); ++it) {\n     \
    \   if (*it == 'a' || *it == 'A')\n            reverse.push_back(*it);\n     \
    \   else\n            reverse.push_back(*it + count++);\n    }\n    string result;\n\
    \    std::reverse(string.begin(), string.end());\n    result += string;\n    reverse\
    \ = reverse + string;\n    reverse.erase(std::remove(reverse.begin(), reverse.end(),\
    \ 'a'), reverse.end());\n    result += reverse;\n    return result;", "    //\
    \ Find the longest postfix that is palindrome.\n    int length = string.length();\n\
    \    for (int i = 1; i < length; i++) {\n        if (string[i] == string[length\
    \ - 1 - i])\n            length--;\n        else\n            break;\n    }\n\
    \    // Append to the end of string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    std::string res = string(length, '\\0');\n    res[0]\
    \ = string[0];\n    for (int i = 1; i < length; i++) {\n        res[length - 1\
    \ - i] = string[i];\n    }\n    return res;", "    if(string.size() <= 1) return\
    \ string;\n    std::string prefix_reverse_string;\n    int i = 0;\n    for(; i\
    \ < string.size(); i++) {\n        prefix_reverse_string += string[i];\n    }\n\
    \    int prefix_reverse_string_size = prefix_reverse_string.size();\n    int suffix_size\
    \ = string[prefix_reverse_string_size-1];\n    prefix_reverse_string += string[prefix_reverse_string_size-1];\n\
    \    std::string palindrome = make_palindrome(prefix_reverse_string);\n    return\
    \ palindrome + suffix_size;", "    if (string.length() <= 1) return string;\n\
    \    std::string longest, prefix = string, suffix = \"\";\n    bool is_palindrome\
    \ = true;\n    while (!is_palindrome && string.length() > 0) {\n        int index\
    \ = string.length() - 1;\n        while (index >= 0 && string[index] != string[index\
    \ / 2]) {\n            index--;\n        }\n        if (index >= 0) {\n      \
    \      string[index] = '~';\n        }\n        is_palindrome = string.length()\
    \ > longest.length();\n    }\n    prefix = reverse(prefix.rbegin(), prefix.rend());\n\
    \    suffix = reverse(suffix.rbegin(), suffix.rend());\n    string result = prefix\
    \ + '~' + suffix;\n    return longest = std::min(longest, result);", "    int\
    \ n = string.size();\n    int max_length = 0;\n    int max_length_start = 0;\n\
    \    int max_length_end = -1;\n\n    for (int i = n-1; i >= 0; i--) {\n      \
    \  if (string[i] != string[n-i-1]) {\n            max_length = i;\n          \
    \  break;\n        }\n    }\n\n    for (int i = n-2; i >= 0; i--) {\n        if\
    \ (string[i] != string[n-(i+1)]) {\n            max_length = i;\n            max_length_start\
    \ = n-i;\n            max_length_end = n;\n            break;\n        }\n   \
    \ }\n\n    int new_length = max_length + 1;\n    std::string new_string;\n   \
    \ new_string.reserve(new_length);\n    new_string += string;\n    new_string.insert(new_length-1,\
    \ string[max_length_start], string[max_length_start+1]);\n    return new_string;",
  "    // Base case -- nothing to do.\n    if (string == \"0\") return string;\n \
    \   // Base case -- nothing to do.\n    if (string == \"1\") return string;\n\n\
    \    size_t length = string.length();\n    size_t longest = 0;\n    for (size_t\
    \ i = length-1; i >= 0; i--) {\n        string += string[i];\n        string +=\
    \ \"0\";\n        longest = i;\n        if (longest > string.length()) longest\
    \ = string.length();\n        if (longest > string.length()) longest = string.length();\n\
    \    }\n    string += \"0\";\n    string += make_palindrome(string.substr(0, longest));\n\
    \    return string;", "    // Store the string in a reverse order and check if\
    \ it is the same as the original.\n    std::string reversed = \"\";\n    std::string\
    \ prefix = string;\n    reversed = std::string(prefix.rbegin(), prefix.rend());\n\
    \    std::string palindrome = \"\";\n    // Find out where the palindromic suffix\
    \ begins\n    auto iter = reversed.rbegin();\n    // Append the postfix palindromic\
    \ suffix\n    while (iter != reversed.rend()) {\n        palindrome.push_back(*iter++);\n\
    \    }\n    palindrome.insert(palindrome.begin(), reversed.begin(), reversed.end());\n\
    \    // Return palindrome with the length of the original string appended to it\n\
    \    return palindrome + string.length();", "    // Convert to lower case\n  \
    \  string s = std::tolower(string);\n    size_t len = s.length();\n    string\
    \ pre, post;\n    // Find the longest postfix that is a palindrome\n    for (size_t\
    \ i = len - 1; i >= 0; i--) {\n        pre.push_back(s[i]);\n        if (s[i]\
    \ == s[len])\n            break;\n    }\n    for (size_t i = 0; i < len; i++)\
    \ {\n        post.push_back(s[i]);\n        if (s[i] == s[len])\n            break;\n\
    \    }\n    // Append the reverse of the string prefix that comes before palindromic\
    \ suffix.\n    post.append(pre.rbegin(), pre.rend());\n    return post;", "  assert(!string.empty()\
    \ && \"Empty string is not allowed for make_palindrome()\");\n  int n = string.length();\n\
    \  std::string suffix;\n  std::string postfix = \"\";\n  for (int i = 0; i < n;\
    \ i++) {\n    postfix += string[i];\n    std::string prefix = postfix.substr(0,\
    \ i);\n    suffix += prefix + std::string(suffix.rbegin(), suffix.rend());\n \
    \ }\n  std::string reversed = suffix;\n  std::reverse(postfix.begin(), postfix.end());\n\
    \  reversed.append(postfix);\n  return reversed;", "    std::string reversed =\
    \ \"\";\n    string prefix;\n    int max_length = 0;\n    int min_length = 0;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] != '/')\
    \ {\n            prefix = string;\n            break;\n        }\n    }\n    for\
    \ (int i = 1; i < string.length(); i++) {\n        if (string[i] == '/') {\n \
    \           prefix = string.substr(0, i - 1);\n            break;\n        }\n\
    \    }\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i]\
    \ != '/') {\n            max_length = i;\n            break;\n        }\n    }\n\
    \    for (int i = min_length + 1; i < string.length(); i++) {\n        if (string[i]\
    \ != '/') {\n            min_length = i;\n            break;\n        }\n    }\n\
    \    for (int i = min_length - 1; i >= 0; i--) {\n        if (string[i] != '/')\
    \ {\n            reversed = prefix + string[i];\n            break;\n        }\n\
    \    }\n    return prefix + reversed;", "    // Check if string is empty or null\n\
    \    if (string.empty() || string == NULL) return \"\";\n    // Find the longest\
    \ prefix that is a palindrome (assume there is only one such prefix).\n    std::string\
    \ longestPalindrome;\n    for (size_t i = 1; i < string.size(); i++) {\n     \
    \   std::string currPalindrome = string.substr(0, i);\n        // Check that this\
    \ is not a palindrome\n        if (currPalindrome != std::string(string.rbegin(),\
    \ string.rend())) {\n            // If so, update the longestPalindrome\n    \
    \        longestPalindrome = currPalindrome;\n            break;\n        }\n\
    \    }\n    // Append a reverse of the longest postfix to this string\n    return\
    \ longestPalindrome + std::string(string.rbegin(), string.rend());", "    std::string\
    \ result;\n    int length = string.length();\n    for (int i = 0; i < length;\
    \ i++) {\n        if (i < length - 1 && string[i] == string[length - 1 - i]) {\n\
    \            result += string[i];\n        } else {\n            result += string[i];\n\
    \        }\n    }\n    std::reverse(string);\n    result += string;\n    return\
    \ result;", "\tstring postfix_palindrome;\n\tstring prefix_palindrome;\n\tsize_t\
    \ n = string.size();\n\tif (n<=1){\n\t\treturn string;\n\t}\n\tpostfix_palindrome\
    \ = string.substr(0,n-1);\n\tprefix_palindrome = string.substr(0,n-1);\n\tstring\
    \ rev_postfix_palindrome = std::string(string).substr(n-1,string);\n\tstring rev_prefix_palindrome\
    \ = std::string(string).substr(n-1,string);\n\tassert(rev_prefix_palindrome ==\
    \ std::string(string).substr(0,n-1));\n\tassert(rev_postfix_palindrome == std::string(string).substr(n-1,string));\n\
    \tstring appended_postfix_palindrome = prefix_palindrome+rev_postfix_palindrome;\n\
    \treturn appended_postfix_palindrome;", "    // Find the longest postfix of the\
    \ string that is a palindrome.\n    int len = string.length();\n    int palindromic_suffix\
    \ = 0;\n    for (int i = 0; i < len; ++i) {\n        if (string[i] == string[len\
    \ - i - 1]) {\n            palindromic_suffix = i;\n        }\n    }\n    // Append\
    \ reverse of the string prefix that comes before palindromic suffix.\n    int\
    \ prefix_to_append = len - palindromic_suffix;\n    string reverse_prefix = string(palindromic_suffix,\
    \ prefix_to_append) + string;\n    return reverse_prefix;", "    if(string.length()\
    \ <= 1)\n        return string;\n\n    auto start = string.rfind(string[0]);\n\
    \    if(start == std::string::npos)\n        return string;\n\n    auto end =\
    \ string.find_first_of(string, start);\n    auto post_fix = string.substr(start,\
    \ end - start);\n    string reversed = post_fix;\n    std::reverse(reversed.begin(),\
    \ reversed.end());\n    reversed += string[end];\n\n    return string + post_fix\
    \ + reversed;", "  // Find the length of the longest postfix of string that is\
    \ a palindrome.\n  int max_len_postfix = 0, max_len_postfix2 = 0;\n  for (int\
    \ i = string.size() - 1; i >= 0; i--) {\n    if (string[i] == string[string.length()\
    \ - 1 - i]) {\n      max_len_postfix = i;\n      max_len_postfix2 = string.length\
    \ - 1 - i;\n      break;\n    }\n  }\n  // If the string is a palindrome append\
    \ its reverse.\n  if (max_len_postfix == string.length() - 1)\n    return string\
    \ + std::string(max_len_postfix, max_len_postfix2);\n  // Otherwise append the\
    \ longest postfix of string that is not a palindrome and append its reverse.\n\
    \  return string + std::string(max_len_postfix, max_len_postfix2) + make_palindrome(string);",
  "    // Find the longest postfix of supplied string that is a palindrome.\n    std::string\
    \ postfix = string;\n    std::string::reverse_iterator rit = std::find_if(postfix.rbegin(),\
    \ postfix.rend(), [](char c) {\n        return c == '1';\n    });\n    if (postfix.size()\
    \ % 2 == 1) {\n        // Not a palindrome.\n        return string;\n    }\n \
    \   // Get the postfix string's start index.\n    auto start = postfix.rbegin();\n\
    \    // Find the longest postfix string that comes after the prefix.\n    auto\
    \ it = std::find_if(start, postfix.rend(), [&](char c) {\n        postfix.push_back(c);\n\
    \        std::string palindrome = postfix.substr(0, postfix.size() / 2);\n   \
    \     postfix.erase(0, postfix.size() / 2);\n        if (palindrome == string)\
    \ {\n            return true;\n        }\n        return false;\n    });\n   \
    \ if (it != postfix.rend()) {\n        // Append reverse of the postfix string\
    \ prefix that comes before the palindromic suffix.\n        postfix.insert(it,\
    \ postfix.substr(start, it - start));\n    }\n    return postfix;", "  if (string.size()\
    \ < 2) return string;\n  std::string postfix = string;\n  std::reverse(postfix.begin(),\
    \ postfix.end());\n  std::string result = string;\n  result += postfix;\n  return\
    \ result;", "  int prefix_length = 0;\n  for (int i = 0; i < string.length();\
    \ ++i) {\n    if (string[i] >= 'A' && string[i] <= 'Z') {\n      prefix_length++;\n\
    \      if (string[i] < 'A' || string[i] > 'Z') {\n        break;\n      }\n  \
    \  }\n  }\n  std::string result = string;\n  if (prefix_length == string.length())\
    \ {\n    return result;\n  }\n  string postfix = \"\";\n  for (int i = string.length()\
    \ - 1; i >= 0; --i) {\n    char c = string[i];\n    postfix.append(1, c);\n  }\n\
    \  result = postfix.append(make_palindrome(postfix));\n  return result;", "  \
    \  std::stack<char> postfix;\n    postfix.push(string[0]);\n    std::string reverse_postfix;\n\
    \    while (!postfix.empty()) {\n        char temp = postfix.top();\n        reverse_postfix\
    \ += temp;\n        postfix.pop();\n    }\n    postfix.push(string[string.size()\
    \ - 1]);\n    reverse_postfix += postfix.top();\n    postfix.pop();\n    return\
    \ reverse_postfix;", "    int len = 0;\n    int max_length = 0;\n    std::string\
    \ ans;\n    for (int i = 0; i <= string.size(); i++) {\n        len += string[i];\n\
    \        if (len > max_length) {\n            max_length = len;\n            ans\
    \ = string.substr(0, i);\n        }\n    }\n\n    // If we have found a palindrome,\
    \ prepend the reverse of the ans string\n    ans.insert(0, reverse(ans));\n\n\
    \    return ans;", "    string reverse = \"\";\n    string postfix = \"\";\n \
    \   size_t longest_postfix_length = 0;\n    for (size_t i = 0; string[i]; ++i)\
    \ {\n        if (string[i] == string[i - 1])\n            continue;\n        postfix\
    \ += string[i];\n        longest_postfix_length = i;\n    }\n    // If the postfix\
    \ is longer than the longest postfix then add leading 'a' to make\n    // the\
    \ longest postfix be a palindrome.\n    if (postfix.size() > longest_postfix_length)\n\
    \        postfix.insert(0, \"a\");\n    postfix.append(reverse);\n    return postfix;",
  "    // Step 1. Find the longest palindrome in string.\n    int longest_palindrome\
    \ = 0;\n    int palindrome_start = 0;\n    int palindrome_end = 0;\n    for (int\
    \ i = 0; i < string.length(); ++i) {\n        bool found = false;\n        for\
    \ (int j = palindrome_end; j < string.length() && !found; ++j) {\n           \
    \ if (string[i] == string[j]) {\n                found = true;\n             \
    \   palindrome_start = i;\n                palindrome_end = j;\n            }\n\
    \        }\n        if (!found) {\n            palindrome_end = string.length();\n\
    \        }\n        longest_palindrome = palindrome_end - palindrome_start + 1;\n\
    \    }\n\n    // Step 2. Add string reversal of string prefix before longest palindrome\
    \ to it.\n    std::string palindrome = string; // Keep original string unchanged.\n\
    \    for (int i = 0; i < longest_palindrome; ++i) {\n        palindrome += string[palindrome_start\
    \ - i];\n        palindrome += string[palindrome_end - i];\n    }\n\n    // Step\
    \ 3. Return it.\n    return palindrome;", "    // Find length of longest postfix\
    \ that is a palindrome.\n    int palindromeLength = 0;\n    for(auto &i : string)\
    \ {\n        if(!i) return std::string{};\n        if(i == string[string.length()\
    \ - palindromeLength]) palindromeLength++;\n    }\n\n    // Find the first substring\
    \ that is a palindrome. \n    // Note that this is just an O(n) operation, so\
    \ it's fine if n is large.\n    int index = string.find_first_of('0', palindromeLength);\n\
    \    while(index != string::npos) {\n        if(index > palindromeLength) break;\n\
    \        std::string suffix;\n        for(int i = 0; i < index; i++) {\n     \
    \       suffix.push_back(string[i]);\n        }\n        string reverse = suffix;\n\
    \        reverse.assign(reverse.size(), 0);\n        for(int i = 0; i < reverse.length();\
    \ i++) {\n            reverse[reverse.length() - 1 - i] = reverse[i];\n      \
    \  }\n        string reversedPrefix = std::string(string.begin(), string.begin()\
    \ + index);\n        reversedPrefix += reverse;\n        index = string.find_first_of('0',\
    \ palindromeLength);\n    }\n    return string(reversedPrefix, 0, palindromeLength);",
  "    std::string rev;\n    for (size_t i = 0, len = string.length(); i < len / 2;\
    \ i++) {\n        rev.append(string[i]);\n        rev.append(string[len - i -\
    \ 1]);\n    }\n    return rev;", "    int start = 0;\n    int end = string.length()\
    \ - 1;\n    std::string answer = \"\";\n    while (start < end) {\n        int\
    \ mid = start + (end - start) / 2;\n        if (mid < 0 || mid >= string.length())\n\
    \            break;\n        if (string[mid] != string[string.length() - mid -\
    \ 1])\n            break;\n        end = mid;\n        answer += string[start];\n\
    \        start += 1;\n    }\n    answer += string[start];\n    return answer;",
  "\t// Find postfix of string that is a palindrome\n\tint max_postfix = 0;\n\tstd::string\
    \ postfix_palindrome;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ != string[string.length() - 1 - i]) {\n\t\t\tmax_postfix = i;\n\t\t}\n\t}\n\n\
    \t// Append to string reverse of string prefix that comes before postfix of string\
    \ that is a palindrome\n\tint max_prefix_len = max_postfix;\n\tstd::string prefix_palindrome;\n\
    \twhile (max_prefix_len >= 0) {\n\t\tfor (int i = 0; i < max_prefix_len; i++)\
    \ {\n\t\t\tprefix_palindrome.push_back(string[string.length() - 1 - i]);\n\t\t\
    }\n\t\tmax_prefix_len--;\n\t}\n\tprefix_palindrome.push_back(string[0]);\n\n\t\
    return prefix_palindrome + string[max_postfix - 1];", "  // Find the longest postfix\
    \ that is palindrome.\n  // For example given input of \"abba\"\n  // longest\
    \ postfix of \"abba\" is \"abb\" (length 3)\n  std::string::size_type longest_postfix_idx\
    \ = 0;\n  std::string::size_type longest_postfix = 0;\n  for (std::string::size_type\
    \ pos = string.size() - 1;\n       pos >= 0; --pos) {\n    if (string[pos] !=\
    \ string[string.size() - pos - 1]) {\n      ++longest_postfix;\n    }\n  }\n\n\
    \  // Find the longest prefix that comes before longest postfix.\n  // For example\
    \ given input of \"abba\"\n  // longest prefix of \"abba\" is \"abb\" (length\
    \ 3)\n  std::string::size_type longest_prefix_idx = 0;\n  for (std::string::size_type\
    \ pos = 0; pos < longest_postfix; ++pos) {\n    if (string[pos] != string[longest_prefix_idx\
    \ + pos]) {\n      ++longest_prefix_idx;\n    }\n  }\n\n  longest_postfix_idx\
    \ -= longest_prefix_idx;\n\n  // Append the reverse of the longest postfix to\
    \ the end of the supplied string.\n  std::string rev_postfix =\n      string[longest_postfix_idx\
    \ + longest_prefix_idx];\n  std::string rev_prefix = string[longest_prefix_idx];\n\
    \  rev_postfix.insert(rev_postfix.end(), rev_prefix.rbegin(), rev_prefix.rend());\n\
    \  string += rev_postfix;\n\n  return string;", "    string reversed_string;\n\
    \    string reverse_of_string(string.rbegin(), string.rend());\n    reverse_of_string\
    \ += string;\n    std::reverse(string.begin(), string.end());\n    string palindrome\
    \ = reverse_of_string + string;\n    return palindrome;", "    int length = string.length();\n\
    \    char letter;\n    std::string postfix = string;\n    int index = 0;\n   \
    \ bool done = false;\n    while (index < length / 2 && !done) {\n        letter\
    \ = string[index];\n        if (letter != string[length - 1 - index]) {\n    \
    \        postfix.append(1, letter);\n            postfix.append(length - 1 - index,\
    \ letter);\n            done = true;\n        }\n        index++;\n    }\n   \
    \ // If we have not yet encountered a palindrome suffix\n    // append the postfix\
    \ to end of the string reverse\n    // of this string prefix.\n    if (!done)\
    \ {\n        postfix.append(1, string[length - 1]);\n    }\n    return postfix;",
  "    std::string postfix = \"\";\n    // Get the length of original string\n   \
    \ int len = string.length();\n    // Find the longest postfix that can be made\n\
    \    for (int i = 0; i < len; i++) {\n        if (string[i] == '.') {\n      \
    \      break;\n        }\n        postfix += string[i];\n    }\n    // Find the\
    \ shortest prefix that comes before the postfix that is a palindrome.\n    for\
    \ (int i = 0; i < len; i++) {\n        // If string is longer than postfix we\
    \ cannot make a palindrome.\n        // And if string is longer than the postfix\
    \ we cannot make a palindrome.\n        if (i >= postfix.length() || string[i]\
    \ != postfix[i]) {\n            return \"\";\n        }\n    }\n    // Create\
    \ string with reversed postfix and postfix itself\n    std::string reverse = reverse(postfix);\n\
    \    return reverse + postfix;", "    std::string postfix = \"\";\n    std::string\
    \ prefix = \"\";\n    std::string::iterator it = string.begin();\n    while (it\
    \ != string.end()) {\n        if (*it == *(it + 1)) {\n            postfix +=\
    \ *it;\n            ++it;\n        }\n        else {\n            if (postfix.empty())\
    \ {\n                prefix = *it;\n            }\n            else {\n      \
    \          postfix += *it;\n                prefix = prefix;\n               \
    \ postfix = postfix.substr(0, postfix.size() - 1);\n            }\n          \
    \  it++;\n        }\n    }\n    std::string palindrome = prefix;\n    palindrome\
    \ += postfix;\n    return palindrome;", "\tstd::string suffix = string;\n\tsize_t\
    \ max_length = 0;\n\tauto it = suffix.begin();\n\tfor (size_t i = suffix.length()/2\
    \ ; i >= 0 ; --i) {\n\t\tassert(*it != 0);\n\t\t++it;\n\t\tassert(it != suffix.end());\n\
    \t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it\
    \ != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\
    \t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it !=\
    \ *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it\
    \ != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\
    \t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it\
    \ != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\
    \t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it !=\
    \ *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it\
    \ != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\
    \t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it\
    \ != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\
    \t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it !=\
    \ *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it\
    \ != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\
    \t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it\
    \ != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it != *suffix) break;\n\t\
    \t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it != 0);\n\t\tif (*it !=\
    \ *suffix) break;\n\t\t++it;\n\t\tassert(it != suffix.end());\n\t\tassert(*it\
    \ != 0);\n\t\tif (*it != *suffix) break;\n\t\t++it;\n\t\tassert(it ", "  std::reverse(string.begin(),\
    \ string.end());\n  std::string::size_type palindrome_start = string.size() -\
    \ 1;\n  std::string::size_type palindrome_length = 1;\n  while (string.size()\
    \ >= palindrome_start + 1) {\n    if (string[palindrome_start] != string[palindrome_start\
    \ + palindrome_length]) {\n      ++palindrome_length;\n      if (palindrome_length\
    \ > string.length() - 1) {\n        return string;\n      }\n    } else {\n  \
    \    palindrome_length = 1;\n      --palindrome_start;\n    }\n  }\n  return string;",
  "    std::vector<std::string> v;\n    std::string result = \"\";\n    for (size_t\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == string[string.length()\
    \ - i - 1]) {\n            v.push_back(string);\n        }\n        else {\n \
    \           if (v.size() == 0) {\n                v.push_back(string);\n     \
    \       }\n            else {\n                for (size_t j = 0; j < v.size();\
    \ j++) {\n                    result += v[j];\n                    v.erase(v.begin());\n\
    \                }\n            }\n            result = result + string[i];\n\
    \        }\n    }\n    return result;"]
stop_tokens:
- "\n}"
