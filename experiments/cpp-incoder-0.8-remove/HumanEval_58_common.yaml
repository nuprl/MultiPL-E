name: HumanEval_58_common
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common\
  \ elements for two lists.\nstd::vector<long> common(std::vector<long> l1, std::vector<long>\
  \ l2) {\n"
tests: "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5,\
  \ (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1,\
  \ (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3,\
  \ (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2,\
  \ (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2,\
  \ (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2,\
  \ (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3,\
  \ (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
completions: ["\tstd::vector<long> common;\n\tstd::sort(l1.begin(),l1.end());\n\t\
    std::sort(l2.begin(),l2.end());\n\tstd::vector<long>::iterator it1,it2;\n\tit1=l1.begin();\n\
    \tit2=l2.begin();\n\twhile(it1!=l1.end() && it2!=l2.end()){\n\t\tif(*it1==*it2)\n\
    \t\t{\n\t\t\tcommon.push_back(*it1);\n\t\t\t++it1;\n\t\t\t++it2;\n\t\t}\n\t\t\
    else\n\t\t{\n\t\t\twhile((it1!=l1.end()) && (*it1<*it2))\n\t\t\t{\n\t\t\t\t++it1;\n\
    \t\t\t}\n\t\t\twhile((it2!=l2.end()) && (*it2<*it1))\n\t\t\t{\n\t\t\t\t++it2;\n\
    \t\t\t}\n\t\t\tif(it1!=l1.end())\n\t\t\t{\n\t\t\t\tcommon.push_back(*it1);\n\t\
    \t\t\t++it1;\n\t\t\t}\n\t\t\tif(it2!=l2.end())\n\t\t\t{\n\t\t\t\tcommon.push_back(*it2);\n\
    \t\t\t\t++it2;\n\t\t\t}\n\t\t}\n\t}\n\twhile(it1!=l1.end())\n\t{\n\t\tcommon.push_back(*it1);\n\
    \t\t++it1;\n\t}\n\twhile(it2!=l2.end())\n\t{\n\t\tcommon.push_back(*it2);\n\t\t\
    ++it2;\n\t}\n\treturn common;", "    long temp;\n    // Compare and sort elements\
    \ of l1 and l2.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\
    \n    // If the length of lists is different, sort lists.\n    if (l1.size() !=\
    \ l2.size()) {\n        std::swap(l1, l2);\n        std::swap(temp, 0);\n    }\n\
    \n    // Iterate through the sorted lists, comparing elements.\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < l1.size(); i++)\n    {\n        if (l1[i]\
    \ == l2[i]) continue;\n        temp = l1[i];\n        l1[i] = l2[i];\n       \
    \ l2[i] = temp;\n        result.push_back(l1[i]);\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n\n    std::vector<long> res;\n    long\
    \ minv = l1[0], maxv = l2[0];\n    long ln = l1.size();\n    if (l2.size() ==\
    \ 0 || l2.size() > ln)\n        ln = l2.size();\n\n    for (long i = 0; i < ln;\
    \ ++i) {\n        if (l1[i] > maxv)\n            maxv = l1[i];\n        if (l2[i]\
    \ > maxv)\n            maxv = l2[i];\n    }\n\n    long mid = (maxv + minv) /\
    \ 2;\n    while (l1.size() <= l2 && l2.size() > ln) {\n        res.push_back(l1.back());\n\
    \        l1.pop_back();\n    }\n    while (l2.size() <= l1 && l1.size() > ln)\
    \ {\n        res.push_back(l2.back());\n        l2.pop_back();\n    }\n\n    while\
    \ (ln-- > 0) {\n        if (l1[ln] < mid) {\n            res.push_back(l1[ln]);\n\
    \            l1.erase(l1.begin() + ln);\n        } else if (l2[ln] < mid) {\n\
    \            res.push_back(l2[ln]);\n            l2.erase(l2.begin() + ln);\n\
    \        }\n    }\n    return res;", "    long x = 0;\n    // Initialize first\
    \ list to 0\n    for (long &a : l1)\n        a += x;\n    l1.clear();\n    //\
    \ Initialize second list to 0\n    for (long &b : l2)\n        b += x;\n    l2.clear();\n\
    \    // Sort lists and keep unique elements\n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    std::vector<long> s;\n    while (true)\
    \ {\n        if (l1.size() == 0 || l2.size() == 0)\n            break;\n     \
    \   if (l1[0] == l2[0])\n        {\n            s.push_back(l1.back());\n    \
    \        l1.pop_back();\n            l2.pop_back();\n        }\n        else if\
    \ (l1[0] < l2[0])\n            l1.pop_back();\n        else\n            l2.pop_back();\n\
    \    }\n    return s;", "        std::sort(l1.begin(), l1.end());\n        std::sort(l2.begin(),\
    \ l2.end());\n        std::vector<long> res(l1.size() + l2.size());\n        for\
    \ (size_t i = 0; i < l1.size(); ++i) res[i] = l1[i];\n        for (size_t i =\
    \ 0; i < l2.size(); ++i) res[i + l1.size()] = l2[i];\n        return res;", " \
    \   std::vector<long> res;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    \n    // Iterate from head to tail of one of the lists.\n  \
    \  for (long i : l1) {\n        // If element from other list is not there in\
    \ list then store in result list\n        if (std::find(l2.begin(), l2.end(),\
    \ i) == l2.end()) {\n            res.push_back(i);\n        }\n    }\n    return\
    \ res;", "    std::vector<long> ans;\n    if (l1.size() == 0 || l2.size() == 0)\
    \ {\n        return ans;\n    }\n    long first = *std::min_element(l1.begin(),\
    \ l1.end());\n    long last = *std::max_element(l2.begin(), l2.end());\n    ans.push_back(*std::min_element(l1.begin(),\
    \ l1.end()));\n    ans.push_back(*std::max_element(l2.begin(), l2.end()));\n \
    \   long mid = first;\n    while (first < last) {\n        if (l1[first] == l2[first])\
    \ {\n            ++first;\n        } else {\n            while (first < last &&\
    \ l1[first] == mid) {\n                ++first;\n                ans.push_back(mid);\n\
    \            }\n            ans.push_back(mid);\n            mid = l1[first];\n\
    \            first = first;\n        }\n    }\n    while (first < last) {\n  \
    \      while (first < last && l2[first] == mid) {\n            ++first;\n    \
    \        ans.push_back(mid);\n        }\n        ans.push_back(mid);\n       \
    \ mid = l2[first];\n        first = first;\n    }\n    return ans;", "    std::vector<long>\
    \ result;\n    for(auto &x:l1) \n        std::find(std::begin(l2), std::end(l2),\
    \ x) == std::end(l2) && result.push_back(x);\n    return result;", "    // Return\
    \ sorted unique common elements.\n    std::vector<long> res;\n    if (l1.size()\
    \ == l2.size()) {\n        std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(res));\n    } else {\n        // One list is longer.\n\
    \        assert(l1.size() > l2.size());\n        std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(res), [](long a, long b)\
    \ { return a < b; });\n        // Remove the duplicated elements.\n        std::sort(res.begin(),\
    \ res.end());\n        res.erase(std::unique(res.begin(), res.end()), res.end());\n\
    \    }\n    return res;", "    std::vector<long> v;\n    v.push_back(l1[0]);\n\
    \    v.push_back(l2[0]);\n    long common = l1.front() + l2.front();\n    for\
    \ (size_t i = 1; i < l1.size(); ++i) {\n        if (l1[i] != l2[i]) {\n      \
    \      v.push_back(common);\n            common = l1.front() + l2.front();\n \
    \       } else {\n            common += l1[i];\n        }\n    }\n    v.push_back(common);\n\
    \    return v;", "  \n  // Use to store sorted unique common elements\n  std::vector<long>\
    \ ret;\n  \n  // Sort the lists and initialize iterator for both\n  sort(l1.begin(),\
    \ l1.end());\n  sort(l2.begin(), l2.end());\n  \n  // Iterate through two lists\
    \ and compare elements\n  long c = 0;\n  for (int i = 0; i < min(l1.size(), l2.size());\
    \ i++) {\n    if (l1[i] == l2[i]) {\n      c++;\n    } else {\n      break;\n\
    \    }\n  }\n  \n  // Store common elements and return list\n  ret.push_back(l1[l1.size()\
    \ - c]);\n  ret.push_back(l2[l2.size() - c]);\n  \n  // Return sorted unique common\
    \ elements\n  std::sort(ret.begin(), ret.end());\n  return ret;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::vector<long> result(l1.size());\n\
    \    long i = 0; // index into result\n    long j = 0;\n    while (i<l1.size()\
    \ && j<l2.size()) {\n        if (l1[i]==l2[j]) {\n            result[i++] = l2[j];\n\
    \            ++j;\n        } else if (l1[i]<l2[j]) {\n            ++i;\n     \
    \   } else {\n            ++j;\n        }\n    }\n    std::reverse(l1.begin(),\
    \ l1.end()); // to reverse the order of the common elements\n    std::reverse(l2.begin(),\
    \ l2.end()); // to reverse the order of the common elements\n    return result;",
  "    std::vector<long> common;\n    std::set<long> s;\n    for (auto i: l1)\n  \
    \      s.insert(i);\n    for (auto i: l2)\n        if (s.find(i) == s.end())\n\
    \            common.push_back(i);\n    return common;", "        std::vector<long>\
    \ l;\n        std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(l));\n        return l;", "    std::vector<long> ucd;\n \
    \   // Use set_union to remove duplicates\n    std::set_union(l1.begin(), l1.end(),\n\
    \                  l2.begin(), l2.end(),\n                  std::back_inserter(ucd));\n\
    \    return ucd;", "    std::vector<long> result;\n    result.push_back(0);\n\
    \    // sort l1 as we require the first element to appear first in sorted output\n\
    \    auto l1_sorted = std::stable_sort(l1.begin(), l1.end());\n    // same for\
    \ l2\n    auto l2_sorted = std::stable_sort(l2.begin(), l2.end());\n    // iterate\
    \ through sorted lists, comparing elements\n    for (size_t i = 0; i < l1.size();\
    \ i++) {\n        for (size_t j = 0; j < l2.size(); j++) {\n            if (l1[i]\
    \ == l2[j]) {\n                result.push_back(l1[i]);\n                break;\n\
    \            }\n        }\n    }\n    std::sort(result.begin(), result.end());\n\
    \    return result;", "  std::vector<long> result;\n  long n1 = l1.size();\n \
    \ long n2 = l2.size();\n  long& elem = result.front();\n  // Sort\n  std::sort(l1.begin(),\
    \ l1.end());\n  std::sort(l2.begin(), l2.end());\n  // Search\n  for (long i =\
    \ 0; i < n1 && i < n2; i++)\n    if (l1[i] == l2[i]) elem = l1[i];\n  // Copy\
    \ result\n  for (long i = n1; i < n2; i++) result.push_back(elem);\n  return result;",
  "  std::vector<long> common;\n  if (l1.size() <= l2.size()) {\n    common.reserve(l1.size());\n\
    \    for (auto i : l1) {\n      if (l2.count(i) > 0) common.push_back(i);\n  \
    \  }\n  } else {\n    common.reserve(l2.size());\n    for (auto i : l2) {\n  \
    \    if (l1.count(i) > 0) common.push_back(i);\n    }\n  }\n  return common;",
  "        std::vector<long> common;\n        for (auto i : l1) {\n            for\
    \ (auto j : l2) {\n                if (i == j)\n                    common.push_back(i);\n\
    \            }\n        }\n        return common;\n    }\nint main()\n{\n    std::vector<long>\
    \ v1 = { 1, 2, 3, 1 };\n    std::vector<long> v2 = { 1, 2, 3, 1 };\n    std::vector<long>\
    \ v3 = { 1, 2, 3, 1 };\n    std::vector<long> v4 = { 1, 2, 3, 2 };\n    std::vector<long>\
    \ v5 = { 1, 2, 3, 2 };\n    std::vector<long> v6 = { 1, 2, 3, 2 };\n    std::vector<long>\
    \ v7 = { 1, 2, 3, 3 };\n    std::vector<long> v8 = { 1, 2, 3, 3 };\n    std::vector<long>\
    \ v9 = { 1, 2, 3, 3 };\n    std::vector<long> v10 = { 1, 2, 3, 4 };\n    std::vector<long>\
    \ v11 = { 1, 2, 3, 4 };\n    std::vector<long> v12 = { 1, 2, 3, 4 };\n    std::vector<long>\
    \ v13 = { 1, 2, 3, 5 };\n    std::vector<long> v14 = { 1, 2, 3, 5 };\n    std::vector<long>\
    \ v15 = { 1, 2, 3, 5 };\n    std::vector<long> v16 = { 1, 2, 3, 6 };\n    std::vector<long>\
    \ v17 = { 1, 2, 3, 6 };\n    std::vector<long> v18 = { 1, 2, 3, 6 };\n    std::vector<long>\
    \ v19 = { 1, 2, 3, 7 };\n    std::vector<long> v20 = { 1, 2, 3, 7 };\n    std::vector<long>\
    \ v21 = { 1, 2, 3, 7 };\n    std::vector<long> v22 = { 1, 2, 3, 8 };\n    std::vector<long>\
    \ v23 = { 1, 2, 3, 8 };\n    std::vector<long> v24 = { 1, 2, 3, 8 };\n    std::vector<long>\
    \ v25 = { 1, 2, 3, 9 };\n    std::vector<long> v26 = { 1, 2, 3, 9 };\n    std::vector<long>\
    \ v27 = { 1, 2, 3, 9 };\n    std::vector<long> v28 = { 1, 2, 3, 9 };\n    std::vector<long>\
    \ v29 = { 1, 2, 3, 10 };\n    std::vector<long> v30 = { 1, 2, 3, 10 };\n    std::vector<long>\
    \ v31 = { 1, 2, 3, 10 };\n    std::vector<long> v32 = { 1, 2, 3, 11 };\n    std::vector<long>\
    \ v33 = { 1, 2, 3, 11 };\n    std::vector<long> v34 = { 1, 2, 3, 11 };\n    std::vector<long>\
    \ v35 = { 1, 2, 3, 12 };\n    std::vector<long> v36 = { 1, 2, 3, 12 };\n    std::vector<long>\
    \ v37 = { 1, 2, 3, 12 };\n    ", "  assert(l1.size() == l2.size());\n  std::vector<long>\
    \ l3;\n  std::set<long> s1;\n  std::set<long> s2;\n  for (int i = 0; i < l1.size();\
    \ i++) {\n    s1.insert(l1[i]);\n  }\n  for (int i = 0; i < l2.size(); i++) {\n\
    \    s2.insert(l2[i]);\n  }\n  for (long l : s1) {\n    if (s2.find(l) != s2.end())\
    \ {\n      l3.push_back(l);\n    }\n  }\n  return l3;", "    std::vector<long>\
    \ l3;\n    for(int i=0; i<l1.size(); i++) {\n        l3.push_back(l1[i]);\n  \
    \  }\n    for(int i=0; i<l2.size(); i++) {\n        l3.push_back(l2[i]);\n   \
    \ }\n    std::sort(l3.begin(), l3.end());\n    return l3;", "    std::vector<long>\
    \ result;\n    std::vector<long>::iterator i1,i2;\n    long count1 = 0;\n    long\
    \ count2 = 0;\n    long size1 = l1.size();\n    long size2 = l2.size();\n    for\
    \ (i1=l1.begin();i1<l1.end();i1++) {\n        count1++;\n        for (count2=0;count2<size2;count2++)\
    \ {\n            long temp = *i1;\n            if (*i2 == temp) {\n          \
    \      result.push_back(temp);\n                i2 = l2.erase(i2);\n         \
    \       count2--;\n            }\n        }\n    }\n    for (i2=l2.begin();i2<l2.end();i2++)\
    \ {\n        count2++;\n        for (count1=0;count1<size1;count1++) {\n     \
    \       long temp = *i2;\n            if (*i1 == temp) {\n                result.push_back(temp);\n\
    \                i1 = l1.erase(i1);\n                count1--;\n            }\n\
    \        }\n    }\n    if (l1.size() ==0){\n        return result;\n    }\n  \
    \  if (l2.size() ==0) {\n        return result;\n    }\n    return result;", " \
    \   std::vector<long> c;\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(),\
    \ l2.end());\n    if (l1.size() < l2.size()) {\n        c.insert(std::end(c),\
    \ l1.begin(), l1.end());\n        for (long i : l2) {\n            if (c.find(i)\
    \ == c.end())\n                c.push_back(i);\n        }\n    }\n    else {\n\
    \        c.insert(std::end(c), l2.begin(), l2.end());\n        for (long i : l1)\
    \ {\n            if (c.find(i) == c.end())\n                c.push_back(i);\n\
    \        }\n    }\n    return c;", "    std::vector<long> lc;\n    for(long i=0;\
    \ i<l1.size() && i<l2.size(); i++)\n    {\n        if(l1[i]==l2[i])\n        \
    \    lc.push_back(l1[i]);\n    }\n    for(long i=0; i<l1.size() && i<l2.size();\
    \ i++)\n    {\n        for(long j=i+1; j<l1.size() && j<l2.size(); j++)\n    \
    \    {\n            if((l1[i]==l2[j]) && (l1[i]!=lc[0]))\n            {\n    \
    \            lc.push_back(l1[i]);\n                break;\n            }\n   \
    \     }\n    }\n    return lc;", "    std::vector<long> res(l1.size() + 1);\n\
    \    for (size_t i = 0; i < l1.size(); i++)\n        res[i] = l1[i];\n    for\
    \ (size_t i = l1.size(); i < res.size(); i++)\n        res[i] = l2[i];\n    std::sort(res.begin(),\
    \ res.end());\n    return res;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::vector<long> result;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                         std::back_inserter(result));\n\
    \    return result;", "  std::vector<long> ans;\n  for (long x: l1) if (std::find(l2.begin(),\
    \ l2.end(), x) == l2.end()) ans.push_back(x);\n  return ans;", "    if (l1.size()\
    \ > l2.size()) {\n        std::vector<long> temp(l2);\n        std::swap(temp,\
    \ l1);\n        l1 = temp;\n    }\n    std::vector<long> temp(l1);\n    std::sort(temp.begin(),\
    \ temp.end());\n    std::vector<long> ans(l1.size());\n    for (size_t i = 0;\
    \ i < l1.size(); ++i) {\n        for (size_t j = i + 1; j < l1.size(); ++j) {\n\
    \            if (l1[i] == l2[j])\n                ans.push_back(l1[i]);\n    \
    \    }\n    }\n    return ans;", "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(),\
    \ l2.end());\n  \n  std::vector<long> result;\n  result.clear();\n  for (long\
    \ i : l1) \n    if (std::find(l2.begin(), l2.end(), i) != l2.end())\n      result.push_back(i);\n\
    \  \n  return result;", "    std::vector<long> l3;\n    l3.reserve(l1.size() +\
    \ l2.size());\n    for (int i = 0; i < l1.size(); i++) {\n        if (std::find(l2.begin(),\
    \ l2.end(), l1[i]) == l2.end()) {\n            l3.push_back(l1[i]);\n        }\n\
    \    }\n    return l3;", "    std::vector<long> l3;\n    int n = l1.size();\n\
    \    for(int i = 0; i < n; i++) {\n        l3.push_back(l1[i]);\n    }\n    int\
    \ m = l2.size();\n    for(int j = 0; j < m; j++) {\n        l3.push_back(l2[j]);\n\
    \    }\n    std::sort(l3.begin(), l3.end());\n    int l4 = 1;\n    for(int i =\
    \ 2; i <= l3.size(); i++) {\n        if(l4 == l3.size() || l1[i-1] != l2[j-1])\
    \ l4++;\n        else l3[i-1]++;\n    }\n    return l3;", "    std::vector<long>\
    \ common;\n    // Sort the lists.\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(),\
    \ l2.end());\n\n    // Find common elements.\n    int i = 0;\n    while (i < l1.size()\
    \ && i < l2.size()) {\n        if (l1[i] == l2[i]) {\n            common.push_back(l1[i]);\n\
    \            i++;\n        } else if (l1[i] < l2[i]) {\n            i++;\n   \
    \     } else {\n            i++;\n        }\n    }\n\n    return common;", " \
    \   std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n\
    \    std::vector<long> result;\n    long long i = 0;\n    while (l1.size() > 0\
    \ && l2.size() > 0 && l1.front() == l2.front()) {\n        l1.pop_front();\n \
    \       l2.pop_front();\n        i++;\n    }\n    std::copy(l1.begin(), l1.end(),\
    \ std::back_inserter(result));\n    std::copy(l2.begin(), l2.end(), std::back_inserter(result));\n\
    \    return result;", "    // Create a vector of common elements of both lists\n\
    \    std::vector<long> common;\n    std::set_intersection(l1.begin(), l1.end(),\n\
    \                         l2.begin(), l2.end(),\n                         std::back_inserter(common));\n\
    \    return common;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    auto u1 = std::unique(std::begin(l1), std::end(l1));\n    auto\
    \ u2 = std::unique(std::begin(l2), std::end(l2));\n    std::vector<long> result(u1.size()\
    \ +u2.size());\n    std::copy(std::begin(u1), std::end(u1), std::back_inserter(result));\n\
    \    std::copy(std::begin(u2), std::end(u2), std::back_inserter(result));\n  \
    \  return result;", "    auto it = std::set_intersection(l1.begin(), l1.end(),\n\
    \                                   l2.begin(), l2.end(),\n                  \
    \                 std::back_inserter(std::vector(l1)));\n    return l1;", "  //\
    \ Creating vector of size length of shortest list.\n  std::vector<long> s1(l1.size());\n\
    \  std::vector<long> s2(l2.size());\n  // Copying elements of shortest list to\
    \ vector s1\n  // and elements of longest list to vector s2\n  s1.assign(l1.begin(),\
    \ l1.end());\n  s2.assign(l2.begin(), l2.end());\n  // Sorting vector s1 and vector\
    \ s2\n  std::sort(s1.begin(), s1.end());\n  std::sort(s2.begin(), s2.end());\n\
    \  // Iterating through elements of s1 and s2 and\n  // storing unique elements\
    \ in a vector s3\n  std::vector<long> s3(s2.size());\n  int i1 = 0;\n  int i2\
    \ = 0;\n  // Iterating through elements of s1 and s2 and\n  // storing unique\
    \ elements in a vector s3\n  for (int i = 0; i < s1.size(); i++) {\n    // Comparing\
    \ s1 to s2 elements\n    while (i2 < s2.size() && s2[i2] <= s1[i]) {\n      s3[i2++]\
    \ = s2[i2++];\n    }\n    // Comparing s2 to s1 elements\n    while (i1 < s1.size()\
    \ && s1[i1] <= s2[i]) {\n      s3[i1++] = s1[i1++];\n    }\n  }\n  return s3;",
  "   std::vector<long> result;\n   std::sort(l1.begin(), l1.end());\n   std::sort(l2.begin(),\
    \ l2.end());\n   std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n\
    \                         std::back_inserter(result));\n   return result;", " \
    \   int l_size = l1.size();\n    int r_size = l2.size();\n    std::vector<long>\
    \ common_elements;\n    std::vector<bool> is_unique(l_size + r_size);\n    for(int\
    \ i = 0; i < l_size; ++i)\n        is_unique[i] = true;\n    for(int i = 0; i\
    \ < r_size; ++i)\n        is_unique[i + l_size] = true;\n    for(int i = 0; i\
    \ < l_size + r_size; ++i) {\n        if(!is_unique[i] && !is_unique[i + l_size])\
    \ {\n            common_elements.push_back(l1[i]);\n        }\n    }\n    std::sort(common_elements.begin(),\
    \ common_elements.end());\n    return common_elements;", "    std::vector<long>\
    \ v;\n    std::vector<long>::iterator it1 = l1.begin();\n    std::vector<long>::iterator\
    \ it2 = l2.begin();\n    while (it1 != l1.end() && it2 != l2.end()) {\n      \
    \  if (*it1 == *it2) {\n            v.push_back(*it1);\n            it1++;\n \
    \           it2++;\n        } else {\n            if (it1 != l1.end()) {\n   \
    \             it1++;\n            } else {\n                it2++;\n         \
    \   }\n        }\n    }\n    if (it1 != l1.end()) {\n        v.insert(v.end(),\
    \ it1, l1.end());\n    }\n    if (it2 != l2.end()) {\n        v.insert(v.end(),\
    \ it2, l2.end());\n    }\n    std::sort(v.begin(), v.end());\n    return v;",
  "  std::vector<long> res;\n  for (long &i: l1) {\n    for (long &j: l2) {\n    \
    \  if (i == j) {\n        res.push_back(i);\n      }\n    }\n  }\n  return res;",
  "  sort(l1.begin(), l1.end());\n  sort(l2.begin(), l2.end());\n  std::vector<long>\
    \ v;\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(v));\n\
    \  return v;", "\tstd::vector<long> ucl;\n\tfor (long i = 0; i < min(l1.size(),\
    \ l2.size()); ++i) {\n\t\tif (l1.at(i) == l2.at(i)) continue;\n\t\tif (l1.at(i)\
    \ < 0) l1.push_back(l1.at(i));\n\t\telse if (l2.at(i) < 0) l2.push_back(l2.at(i));\n\
    \t\telse ucl.push_back(l1.at(i));\n\t}\n\treturn ucl;", "  std::vector<long> res;\n\
    \  std::set_intersection(l1.begin(), l1.end(),\n                        l2.begin(),\
    \ l2.end(),\n                        std::back_inserter(res));\n  return res;",
  "  std::vector<long> common;\n  std::set_union(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), back_inserter(common));\n  return common;", "  std::vector<long> l3;\n\
    \  l3.reserve(l1.size() + l2.size());\n  l3.insert(l3.end(), l1.begin(), l1.end());\n\
    \  l3.insert(l3.end(), l2.begin(), l2.end());\n  std::sort(l3.begin(), l3.end());\n\
    \  return l3;", "    std::vector<long> ret;\n    // Create a map from l1 to an\
    \ index we can easily look up later.\n    // This makes the code a little simpler,\
    \ and gives us O(n) lookup time.\n    std::unordered_map<long, std::size_t> lmap;\n\
    \    for (std::size_t i = 0; i < l1.size(); ++i)\n        lmap[l1[i]] = i;\n \
    \   for (std::size_t i = 0; i < l2.size(); ++i)\n        lmap[l2[i]] = i;\n  \
    \  // Iterate over the elements of l1, and add them to our result if they\n  \
    \  // are found in l2.\n    for (auto i : l1)\n        if (lmap.count(i)) {\n\
    \            ret.push_back(i);\n            lmap.erase(i);\n        }\n    return\
    \ ret;", "  std::vector<long> s;\n  if (l1.size() < l2.size()) {\n    std::vector<long>\
    \ u(l2.begin(), l2.end());\n    sort(u.begin(), u.end());\n    for (long i : l1)\n\
    \      if (find(u.begin(), u.end(), i) == u.end())\n        s.push_back(i);\n\
    \  } else {\n    std::vector<long> u(l1.begin(), l1.end());\n    sort(u.begin(),\
    \ u.end());\n    for (long i : l2)\n      if (find(u.begin(), u.end(), i) == u.end())\n\
    \        s.push_back(i);\n  }\n  return s;", "    std::vector<long> v1;\n    std::vector<long>\
    \ v2;\n    l1.erase(std::remove(l1.begin(), l1.end(), 0), l1.end());\n    l2.erase(std::remove(l2.begin(),\
    \ l2.end(), 0), l2.end());\n    for(long i : l1) {\n        v1.push_back(i);\n\
    \    }\n    for(long i : l2) {\n        v2.push_back(i);\n    }\n    std::sort(v1.begin(),\
    \ v1.end());\n    std::sort(v2.begin(), v2.end());\n    std::vector<long> v;\n\
    \    v.reserve(v1.size() + v2.size());\n    std::vector<long>::iterator it;\n\
    \    it = std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v.begin());\n\
    \    v.erase(v.begin(), it);\n    return v;", "    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    std::vector<long> ans;\n    auto it\
    \ = std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(ans));\n\
    \    ans.erase(ans.begin(), ans.begin()+1);\n    return ans;", "  // Use insertion\
    \ sort for O(n) running time\n  // and merge sort for O(n log n) running time.\n\
    \  std::vector<long> result;\n  int l1_size = l1.size();\n  int l2_size = l2.size();\n\
    \  if (l1_size > l2_size) {\n    std::merge(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(result));\n  } else {\n    std::merge(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  }\n  std::sort(result.begin(),\
    \ result.end());\n  return result;", "  std::vector<long> res;\n  for (int i =\
    \ 0; i < l1.size(); i++) {\n    for (int j = 0; j < l2.size(); j++) {\n      if\
    \ (l1[i] == l2[j])\n        res.push_back(l1[i]);\n    }\n  }\n  return res;",
  "    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n\
    \                         std::back_inserter(result));\n    return result;", " \
    \ std::vector<long> result;\n  long count = 0;\n  for (long i = 0; i < l1.size();\
    \ i++) {\n    for (long j = 0; j < l2.size(); j++) {\n      if (l1[i] == l2[j])\
    \ {\n        count++;\n        if (count == 1) {\n          result.push_back(l1[i]);\n\
    \        }\n      }\n    }\n  }\n  return result;", "    // Find out how many\
    \ elements there are\n    int n = l1.size() + l2.size();\n    std::vector<long>\
    \ v(n);\n    // Make an array of indexes\n    int j = 0;\n    // Use the same\
    \ index to store the elements\n    int idx = 0;\n    // Store the common element\
    \ at the right position\n    long common_element = 0;\n    // Store the element\
    \ that occurred more often than others\n    long max_element = 0;\n    // Scan\
    \ the two lists to store the elements\n    for (int i = 0; i < l1.size(); i++)\
    \ {\n        long temp = l1[i];\n        for (int k = 0; k < l2.size(); k++) {\n\
    \            if (l2[k] == temp) {\n                // Found a common element\n\
    \                v[idx] = temp;\n                idx++;\n                if (idx\
    \ == n) {\n                    break;\n                }\n            } else {\n\
    \                // Found the element that occurred more frequently\n        \
    \        idx = n;\n            }\n        }\n    }\n    // Scan the vector and\
    \ store the maximum element\n    for (int k = 0; k < n; k++) {\n        if (v[k]\
    \ > max_element) {\n            max_element = v[k];\n            common_element\
    \ = v[k];\n        }\n    }\n    // Return the common elements\n    return std::vector<long>{common_element};",
  "    // Use set data structure to store the unique elements.\n    std::vector<long>\
    \ unique_elements(std::begin(l1), std::end(l1));\n    std::sort(std::begin(unique_elements),\
    \ std::end(unique_elements));\n    // Find the elements that are common to both\
    \ lists.\n    std::vector<long> common_elements;\n    for (auto it1 = std::begin(l1),\
    \ it2 = std::begin(l2); it1 != std::end(l1) && it2 != std::end(l2);) {\n     \
    \   if (*it1 < *it2) ++it1;\n        else if (*it2 < *it1) ++it2;\n        else\
    \ common_elements.push_back(*it1++);\n    }\n    // Find unique elements that\
    \ are common to both lists.\n    std::vector<long> common_unique = common_elements;\n\
    \    std::sort(std::begin(common_unique), std::end(common_unique));\n    unique_elements\
    \ = common_unique;\n    // Return the sorted unique common elements.\n    return\
    \ unique_elements;", "    std::vector<long> result;\n    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    long firstI=0;\n    long\
    \ secondI=0;\n    long intersection=0;\n    for (long i=0;i<l1.size();i++) {\n\
    \        intersection=0;\n        for (long j=0;j<l2.size();j++) {\n         \
    \   if (l1[i]==l2[j]) {\n                intersection++;\n            }\n    \
    \    }\n        if (intersection==1) {\n            std::swap(l1[firstI],l1[i]);\n\
    \            firstI++;\n        }\n    }\n    for (long i=0;i<l2.size();i++) {\n\
    \        intersection=0;\n        for (long j=0;j<l1.size();j++) {\n         \
    \   if (l2[i]==l1[j]) {\n                intersection++;\n            }\n    \
    \    }\n        if (intersection==1) {\n            std::swap(l2[secondI],l2[i]);\n\
    \            secondI++;\n        }\n    }\n    while ((firstI<l1.size()) && (secondI<l2.size()))\
    \ {\n        if (l1[firstI]==l2[secondI]) {\n            result.push_back(l1[firstI]);\n\
    \            firstI++;\n            secondI++;\n        }\n        else if (l1[firstI]<l2[secondI])\
    \ {\n            firstI++;\n        }\n        else {\n            secondI++;\n\
    \        }\n    }\n    while ((firstI<l1.size()) && (secondI<l2.size())) {\n \
    \       if (l2[secondI]<l1[firstI]) {\n            result.push_back(l2[secondI]);\n\
    \            secondI++;\n        }\n        else if (l2[secondI]>l1[firstI]) {\n\
    \            secondI++;\n        }\n        else {\n            std::swap(l1[firstI],l2[secondI]);\n\
    \            firstI++;\n            secondI++;\n        }\n    }\n    while (firstI<l1.size())\
    \ {\n        result.push_back(l1[firstI]);\n        firstI++;\n    }\n    while\
    \ (secondI<l2.size()) {\n        result.push_back(l2[secondI]);\n        secondI++;\n\
    \    }\n    return result;", "  assert(l1.size() == l2.size());\n\n  // Create\
    \ a sorted map of elements to count of occurrence.\n  // std::map<long, int> map;\n\
    \  // for (long el : l1)\n  // if (map.find(el) == map.end())\n  // map[el] =\
    \ 1;\n  // else\n  // map[el] += 1;\n\n  // Return sorted unique elements.\n \
    \ std::vector<long> result;\n\n  long last_element = l1.front();\n  while (l1.size())\
    \ {\n    long current_element = l1.front();\n    l1.pop_front();\n    if (current_element\
    \ == last_element) {\n      result.push_back(current_element);\n    } else {\n\
    \      if (l2.empty()) {\n        break;\n      }\n      current_element = l2.front();\n\
    \      l2.pop_front();\n      if (current_element == last_element) {\n       \
    \ result.push_back(current_element);\n      }\n    }\n  }\n\n  return result;",
  "  std::vector<long> result;\n  long count = 0;\n  while (l1.size() > 0) {\n   \
    \ long value = l1.back();\n    l1.pop_back();\n    long value2 = l2.back();\n\
    \    l2.pop_back();\n    count += 1;\n    if (value == value2) {\n      result.push_back(value);\n\
    \    }\n  }\n  while (l2.size() > 0) {\n    long value = l2.back();\n    l2.pop_back();\n\
    \    result.push_back(value);\n  }\n  return result;", "    std::vector<long>\
    \ retval;\n    retval.reserve(l1.size() + l2.size());\n    for (auto it1 = l1.begin();\
    \ it1 != l1.end(); ++it1) {\n        for (auto it2 = l2.begin(); it2 != l2.end();\
    \ ++it2) {\n            if (*it1 < *it2) {\n                retval.push_back(*it1);\n\
    \            }\n        }\n    }\n    return retval;", "    std::vector<long>\
    \ result;\n    result.push_back(l1[0]);\n    result.push_back(l1[1]);\n    result.push_back(l2[0]);\n\
    \    result.push_back(l2[1]);\n    sort(result.begin(), result.end());\n    result.erase(unique(result.begin(),\
    \ result.end()), result.end());\n    return result;", "    // Number of elements\
    \ in both the list.\n    long common_size = std::count(l1.begin(), l1.end(), l2.begin());\n\
    \    std::vector<long> common_elements(common_size);\n    // Iterate through both\
    \ the list and find common element.\n    std::set_intersection(l1.begin(), l1.end(),\n\
    \                         l2.begin(), l2.end(),\n                         common_elements.begin());\n\
    \    return common_elements;", "    std::vector<long> common_elements;\n    long\
    \ size = std::max(l1.size(), l2.size());\n    if (size == 0)\n        return common_elements;\n\
    \    // Traverse in ascending order.\n    auto comp = [](const long a, const long\
    \ b) { return a < b; };\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(),\n        std::back_inserter(common_elements), comp);\n    return common_elements;",
  "  std::vector<long> u_c;\n  for (auto x: l1) {\n    auto it = std::find(l2.begin(),\
    \ l2.end(), x);\n    if (it != l2.end()) l2.erase(it);\n  }\n  for (auto x: l2)\
    \ {\n    auto it = std::find(l1.begin(), l1.end(), x);\n    if (it != l1.end())\
    \ l1.erase(it);\n  }\n  for (auto x: l1) u_c.push_back(x);\n  return u_c;", " \
    \ // Store the elements in sorted order in l1 and l2.\n  sort(l1.begin(), l1.end());\n\
    \  sort(l2.begin(), l2.end());\n  \n  // Iterate through the sorted lists.\n \
    \ long k = 0;\n  std::vector<long> res;\n  while (k<l1.size() && k<l2.size())\
    \ {\n    if (l1[k]==l2[k]) {\n      res.push_back(l1[k]);\n      k++;\n    } else\
    \ {\n      k++;\n    }\n  }\n  \n  return res;", "    std::vector<long> result;\n\
    \    result.insert(result.end(), l1.begin(), l1.end());\n    result.insert(result.end(),\
    \ l2.begin(), l2.end());\n    std::sort(result.begin(), result.end());\n    result\
    \ = std::unique(result.begin(), result.end()); // sort unique elements\n    return\
    \ result;", "    std::vector<long> l3; // l3 will contain the unique elements\n\
    \    std::vector<long> l4; // l4 will contain the duplicate elements\n    // Check\
    \ all elements of l1 are present in l2 if not, add it in l4\n    for (long i =\
    \ 0; i < l1.size(); ++i) {\n        bool found = false;\n        for (long j =\
    \ 0; j < l2.size(); ++j) {\n            if (l1[i] == l2[j]) {\n              \
    \  found = true;\n                break;\n            }\n        }\n        if\
    \ (!found) {\n            l4.push_back(l1[i]);\n        }\n    }\n    // Now that\
    \ l4 is populated, compare all elements of l2 with l4\n    // if they exist in\
    \ l4, add it in l3\n    for (long i = 0; i < l2.size(); ++i) {\n        bool found\
    \ = false;\n        for (long j = 0; j < l4.size(); ++j) {\n            if (l2[i]\
    \ == l4[j]) {\n                found = true;\n                break;\n       \
    \     }\n        }\n        if (!found) {\n            l3.push_back(l2[i]);\n\
    \        }\n    }\n    return l3;", "    std::vector<long> v;\n    for (long x\
    \ : l1) {\n        if (std::find(l2.begin(), l2.end(), x) == l2.end()) {\n   \
    \         v.push_back(x);\n        }\n    }\n    return v;", "    std::vector<long>\
    \ res;\n    long i1 = 0, i2 = 0;\n    while(i1 < l1.size() && i2 < l2.size())\
    \ {\n        if(l1[i1] == l2[i2]) {\n            res.push_back(l1[i1]);\n    \
    \        i1++;\n            i2++;\n        }\n        else {\n            if(i1\
    \ < l1.size()) i1++;\n            if(i2 < l2.size()) i2++;\n        }\n    }\n\
    \    return res;", "    std::vector<long> l3;\n    long n1 = l1.size();\n    long\
    \ n2 = l2.size();\n    for (int i = 0; i < n1; i++) {\n        long j = i;\n \
    \       while (j < n2 && l2[j] == l1[i]) j++;\n        for (int k = j; k < n2;\
    \ k++) {\n            if (l2[k] != l1[i]) {\n                l3.push_back(l1[i]);\n\
    \                l3.push_back(l2[k]);\n                break;\n            }\n\
    \        }\n    }\n    return l3;", "    std::vector<long> res;\n    // Compare\
    \ elements in l1 with elements in l2.\n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    auto it = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                                   std::back_inserter(res));\n\
    \    std::vector<long> sorted_res(std::begin(res), std::end(res));\n    std::sort(sorted_res.begin(),\
    \ sorted_res.end());\n    return res;", "    std::vector<long> result;\n    l1.insert(l1.end(),\
    \ l2.begin(), l2.end());\n    std::sort(l1.begin(), l1.end());\n    for (std::size_t\
    \ i = 0; i < l1.size(); ++i) {\n        std::size_t j = i + 1;\n        for (;\
    \ j < l1.size(); ++j) {\n            if (l1[i] == l2[j])\n                break;\n\
    \        }\n        result.push_back(l1[i]);\n        l1.erase(l1.begin() + j);\n\
    \    }\n    return result;", "    std::vector<long> l;\n    auto it1 = l1.begin();\n\
    \    auto it2 = l2.begin();\n    for (; it1 != l1.end(); ++it1, ++it2) {\n   \
    \     l.push_back(*it1);\n    }\n    for (; it2 != l2.end(); ++it2) {\n      \
    \  l.push_back(*it2);\n    }\n    std::sort(l.begin(), l.end());\n    return l;",
  "    std::set<long> s;\n    for(long x : l1)\n        s.insert(x);\n    for(long\
    \ x : l2)\n        s.insert(x);\n    return std::vector<long>(s.begin(), s.end());",
  "    std::vector<long> result;\n    if (l1.size() == 0)\n        return l2;\n  \
    \  if (l2.size() == 0)\n        return l1;\n    long first = *(l1.begin());\n\
    \    long last = *(l1.end());\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\
    \    auto it3 = result.begin();\n    long first = *(l1.begin());\n    long last\
    \ = *(l1.end());\n    while (true) {\n        while (it1 != l1.end() && it2 !=\
    \ l2.end() && first == *(it1) && last == *(it2)) {\n            it2++;\n     \
    \       it3++;\n        }\n        if (it1 != l1.end() && it2 != l2.end())\n \
    \           return result;\n        if (it1 == l1.end() && it2 == l2.end())\n\
    \            return result;\n        if (it1 == l1.end())\n            first =\
    \ *(++it2);\n        else\n            last = *(--it2);\n        it2 = l2.begin();\n\
    \        it3 = result.begin();\n        while (it1 != l1.end() && it2 != l2.end()\
    \ && first == *(it1) && last == *(it2)) {\n            it2++;\n            it3++;\n\
    \        }\n        result.push_back(first);\n    }", "    std::vector<long> l;\n\
    \    for(auto i1=0;i1<l1.size();i1++){\n        for(auto i2=0;i2<l2.size();i2++){\n\
    \            if(l1[i1]==l2[i2]){\n                l.push_back(l1[i1]);\n     \
    \           l1.erase(l1.begin()+i1);\n                l2.erase(l2.begin()+i2);\n\
    \                i1--;i2--;\n            }\n        }\n    }\n    return l;",
  "  std::vector<long> v;\n  v.reserve(l1.size() + l2.size());\n  for (size_t i =\
    \ 0; i < l1.size(); ++i) v.push_back(l1[i]);\n  for (size_t i = 0; i < l2.size();\
    \ ++i) v.push_back(l2[i]);\n  std::sort(v.begin(), v.end());\n  return v;", " \
    \   std::vector<long> res;\n    res.reserve(l1.size() + l2.size());\n    std::set_union(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(res));\n    return res;",
  "    // Sorting elements for both lists l1 and l2 \n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    // Creating vector with common elements\n\
    \    std::vector<long> common_elems;\n    // checking common element with both\
    \ lists\n    for (long i : l1) {\n        for (long j : l2) {\n            if\
    \ (i == j) {\n                common_elems.push_back(i);\n            }\n    \
    \    }\n    }\n    return common_elems;", "    std::vector<long> common;\n   \
    \ std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n   \
    \ common.reserve(l1.size() + l2.size());\n    common.reserve(l1.size() + l2.size());\n\
    \    for (long i : l1) {\n        if (std::find(l2.begin(), l2.end(), i) == l2.end())\
    \ common.push_back(i);\n    }\n    return common;", "    std::vector<long> result;\n\
    \    l1.insert(l1.begin(), 0); // add 0 to every elements of l1.\n    l2.insert(l2.begin(),\
    \ 0); // add 0 to every elements of l2.\n    l1.insert(l1.end(), 0); // add 0\
    \ to every elements of l1.\n    l2.insert(l2.end(), 0); // add 0 to every elements\
    \ of l2.\n    for (long i = 1; i < min(l1.size(), l2.size()); ++i) {\n       \
    \ if (l1[i] != l2[i]) result.push_back(l1[i]);\n    }\n    return std::move(result);\
    \ // move result to return it.", "  std::vector<long> common;\n  long* l1_ptr\
    \ = l1.data();\n  long* l2_ptr = l2.data();\n  long* comm_ptr = common.data();\n\
    \  long temp = 0;\n  size_t i = 0;\n  size_t j = 0;\n  size_t size = 0;\n  for\
    \ (; i < l1.size(); ++i) {\n    size++;\n  }\n  for (; j < l2.size(); ++j) {\n\
    \    size++;\n  }\n\n  while ((size != 0) && (size > 0)) {\n    if (*l1_ptr ==\
    \ *l2_ptr) {\n      temp += *l1_ptr;\n      comm_ptr[size++] = temp;\n      ++l1_ptr;\n\
    \      ++l2_ptr;\n    } else if (*l1_ptr < *l2_ptr) {\n      temp += *l1_ptr;\n\
    \      comm_ptr[size++] = temp;\n      ++l1_ptr;\n    } else {\n      temp +=\
    \ *l2_ptr;\n      comm_ptr[size++] = temp;\n      ++l2_ptr;\n    }\n  }\n  return\
    \ common;", "    // write your code here\n    std::vector<long> result;\n    for(long\
    \ i = 0; i < (long)l1.size() && ((i < l2.size()) && (l1[i] == l2[i])); i++){\n\
    \        result.push_back(l1[i]);\n    }\n    std::sort(result.begin(), result.end());\n\
    \    return std::unique(result.begin(), result.end()); // Return unique common\
    \ elements.", "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n\
    \n  std::vector<long> result;\n\n  for (long i1 = 0, i2 = 0; i1 < l1.size() &&\
    \ i2 < l2.size();) {\n    if (l1[i1] == l2[i2]) {\n      result.push_back(l1[i1]);\n\
    \      ++i1;\n      ++i2;\n    } else if (l1[i1] < l2[i2]) {\n      ++i1;\n  \
    \  } else {\n      ++i2;\n    }\n  }\n\n  return result;", "    std::vector<long>\
    \ v1;\n    std::vector<long> v2;\n    // Copy lists into vectors.\n    v1.reserve(l1.size());\n\
    \    v2.reserve(l2.size());\n    v1.insert(v1.end(), l1.begin(), l1.end());\n\
    \    v2.insert(v2.end(), l2.begin(), l2.end());\n    std::vector<long> v3;\n \
    \   long i = 0;\n    long j = 0;\n    // Sort the common elements.\n    sort(v1.begin(),\
    \ v1.end());\n    sort(v2.begin(), v2.end());\n    for (long k = 0; k < v1.size();\
    \ k++) {\n        if (v1[k] == v2[k]) {\n            v3.push_back(v1[k]);\n  \
    \          i++;\n            j++;\n        } else {\n            // We should\
    \ never reach here. Check our assumptions.\n            if (i < j) {\n       \
    \         v3.push_back(v2[k]);\n            } else {\n                v3.push_back(v1[k]);\n\
    \            }\n        }\n    }\n    return v3;", "    std::vector<long> result;\n\
    \    std::vector<long>::iterator itr;\n    // Get iterator to l1 first, to maintain\
    \ order of elements in l1 and l2.\n    for (itr = l1.begin(); itr != l1.end();\
    \ ++itr) {\n        result.push_back(*itr);\n    }\n    // Get iterator to l2\
    \ first, to maintain order of elements in l1 and l2.\n    for (itr = l2.begin();\
    \ itr != l2.end(); ++itr) {\n        result.push_back(*itr);\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "    std::vector<long> v;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(v));\n    return v;", " \
    \ std::vector<long> res;\n  auto it = std::set_intersection(l1.begin(), l1.end(),\
    \ l2.begin(), l2.end(),\n                                 std::back_inserter(res));\n\
    \  return res;", "    // Complete this method\n    std::vector<long> res;\n  \
    \  for (long i : l1) {\n        for (long j : l2) {\n            if(i==j) continue;\n\
    \            else\n                res.push_back(i);\n        }\n    }\n    return\
    \ res;", "    std::vector<long> ret;\n    long maxval = 0;\n    for (long val\
    \ : l1) {\n        if (val > maxval) maxval = val;\n    }\n    for (long val :\
    \ l2) {\n        if (val > maxval) maxval = val;\n    }\n    long mid = maxval\
    \ / 2;\n    for (long val : l1) {\n        if (val >= mid) ret.push_back(val);\n\
    \    }\n    for (long val : l2) {\n        if (val <= mid) ret.push_back(val);\n\
    \    }\n    std::sort(ret.begin(), ret.end());\n    return ret;", "    std::vector<long>\
    \ result;\n    auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), back_inserter(result));\n    if (it != l1.end() && it != l2.end())\n\
    \        result.erase(it);\n    return result;", "  // Create map of l2 elements.\n\
    \  std::unordered_map<long, bool> mp;\n  for (int i = 0; i < l2.size(); i++) {\n\
    \    mp[l2[i]] = true;\n  }\n\n  // Create vector of common elements.\n  std::vector<long>\
    \ res;\n  for (int i = 0; i < l1.size(); i++) {\n    if (mp[l1[i]]) {\n      res.push_back(l1[i]);\n\
    \    }\n  }\n  return res;", "  std::vector<long> result;\n  result.push_back(0);\n\
    \  for (long i = 0; i < l1.size(); i++) {\n    long j = i;\n    for (j = i + 1;\
    \ j < l2.size(); j++) {\n      if (l1[i] == l2[j]) {\n        result.push_back(l1[i]);\n\
    \        break;\n      }\n    }\n  }\n  return result;", "    // Create a vector\
    \ of pairs of elements from the lists.\n    std::vector<std::pair<long, long>\
    \ > v;\n    for (long x : l1) {\n        v.push_back(std::make_pair(x, 0));\n\
    \    }\n    for (long x : l2) {\n        v.push_back(std::make_pair(x, 0));\n\
    \    }\n    // Sort the vector in descending order by second element.\n    std::sort(v.begin(),\
    \ v.end(), [](std::pair<long, long> a, std::pair<long, long> b) { return a.second\
    \ < b.second; });\n    // Return the unique elements.\n    std::vector<long> ret;\n\
    \    for (std::pair<long, long> p : v) {\n        ret.push_back(p.first);\n  \
    \  }\n    return ret;", "    std::vector<long> uc(std::min(l1.size(), l2.size()));\n\
    \    for (long i = 0; i < uc.size(); i++) {\n        std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(uc));\n    }\n    return\
    \ uc;", "    std::vector<long> v1(l1.size());\n    std::vector<long> v2(l2.size());\n\
    \    for (long i = 0; i < l1.size(); i++)\n        v1[i] = l1[i];\n    for (long\
    \ i = 0; i < l2.size(); i++)\n        v2[i] = l2[i];\n    std::sort(v1.begin(),\
    \ v1.end());\n    std::sort(v2.begin(), v2.end());\n    std::vector<long> res(v1.size());\n\
    \    for (long i = 0; i < v1.size(); i++) {\n        while (std::find(v2.begin(),\
    \ v2.end(), v1[i]) != v2.end())\n            v2.erase(std::find(v2.begin(), v2.end(),\
    \ v1[i]));\n        res[i] = v1[i];\n    }\n    return res;", "    std::vector<long>\
    \ u(l1.size()+l2.size());\n    long long ret = 0;\n    int j = 0;\n    for(long\
    \ i = 0; i<l1.size(); i++)\n        for(long k = 0; k<l2.size(); k++) {\n    \
    \        if(l1[i] == l2[k])\n                u[j++] = l1[i];\n        }\n    for(long\
    \ k = 0; k<u.size(); k++){\n        if(ret > u[k]) ret = u[k];\n    }\n    return\
    \ u;", "    if (l1.size() <= l2.size()) {\n        std::sort(l1.begin(), l1.end());\n\
    \        std::sort(l2.begin(), l2.end());\n        std::vector<long> res;\n  \
    \      int i = 0, j = 0, k = 0;\n        while (i < l1.size() && j < l2.size())\
    \ {\n            if (l1[i] == l2[j]) {\n                res.push_back(l1[i]);\n\
    \                i++;\n                j++;\n            } else if (l1[i] > l2[j])\
    \ {\n                j++;\n            } else {\n                i++;\n      \
    \      }\n        }\n        return res;\n    } else {\n        std::sort(l2.begin(),\
    \ l2.end());\n        std::vector<long> res;\n        int i = 0, j = 0, k = 0;\n\
    \        while (i < l1.size() && j < l2.size()) {\n            if (l1[i] == l2[j])\
    \ {\n                res.push_back(l1[i]);\n                i++;\n           \
    \     j++;\n            } else if (l1[i] > l2[j]) {\n                j++;\n  \
    \          } else {\n                i++;\n            }\n        }\n        return\
    \ res;\n    }", "    std::vector<long> result(l1.size());\n    long common_count\
    \ = 0;\n    for (auto it = l1.begin(); it != l1.end(); ++it)\n        common_count\
    \ = std::max(common_count, std::count(l2.begin(), l2.end(), *it));\n    for (auto\
    \ it = l2.begin(); it != l2.end(); ++it)\n        common_count = std::max(common_count,\
    \ std::count(l1.begin(), l1.end(), *it));\n    for (auto it = l1.begin(); it !=\
    \ l1.end(); ++it)\n        common_count = std::max(common_count, std::count(l2.begin(),\
    \ l2.end(), *it));\n    for (auto it = l2.begin(); it != l2.end(); ++it)\n   \
    \     common_count = std::max(common_count, std::count(l1.begin(), l1.end(), *it));\n\
    \    for (auto it = l1.begin(); it != l1.end(); ++it)\n        common_count =\
    \ std::max(common_count, std::count(l2.begin(), l2.end(), *it));\n    for (auto\
    \ it = l2.begin(); it != l2.end(); ++it)\n        common_count = std::max(common_count,\
    \ std::count(l1.begin(), l1.end(), *it));\n    for (auto it = l1.begin(); it !=\
    \ l1.end(); ++it)\n        common_count = std::max(common_count, std::count(l2.begin(),\
    \ l2.end(), *it));\n    for (auto it = l2.begin(); it != l2.end(); ++it)\n   \
    \     common_count = std::max(common_count, std::count(l1.begin(), l1.end(), *it));\n\
    \    for (auto it = l1.begin(); it != l1.end(); ++it)\n        common_count =\
    \ std::max(common_count, std::count(l2.begin(), l2.end(), *it));\n    for (auto\
    \ it = l2.begin(); it != l2.end(); ++it)\n        common_count = std::max(common_count,\
    \ std::count(l1.begin(), l1.end(), *it));\n    for (auto it = l1.begin(); it !=\
    \ l1.end(); ++it)\n        common_count = std::max(common_count, std::count(l2.begin(),\
    \ l2.end(), *it));\n    for (auto it = l2.begin(); it != l2.end(); ++it)\n   \
    \     common_count = std::max(common_count, std::count(l1.begin(), l1.end(), *it));\n\
    \    for (auto it = l1.begin(); it != l1.end(); ++it)\n        common_count =\
    \ std::max(common_count, std::count(l2.begin(), l2.end(), *it));\n    for (auto ",
  "    std::vector<long> result;\n    if (l1.size() == 0 || l2.size() == 0) {\n  \
    \      return result;\n    }\n    auto it = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                                   std::back_inserter(result));\n\
    \    l1.erase(it, l1.end());\n    l2.erase(it, l2.end());\n    return l1;", " \
    \       std::sort(l1.begin(), l1.end());\n        std::sort(l2.begin(), l2.end());\n\
    \        std::vector<long> res;\n        // Set a variable for duplicate elements\
    \ found\n        bool found = false;\n        // Use iterator to traverse two\
    \ lists.\n        // Compare elements one by one and keep track of duplicates\n\
    \        for (std::vector<long>::iterator it = l1.begin(); it != l1.end(); ++it)\
    \ {\n                if (it == l2.end())\n                        break;\n   \
    \             if (*it == *it)\n                        found = true;\n       \
    \         else\n                        found = false;\n        }\n        //\
    \ If no duplicates are found, return sorted unique elements.\n        if (!found)\n\
    \                return res;\n        // Else remove duplicates and sort unique\
    \ elements.\n        do {\n                res.push_back(*it);\n        } while\
    \ (*(it++) != *it && it != l1.end());\n        std::sort(res.begin(), res.end());\n\
    \        return res;", "  // Create a vector to store the result.\n  std::vector<long>\
    \ common(l1.size());\n  \n  // Return sorted unique common elements for two lists.\n\
    \  int i = 0, j = 0;\n  while (i < l1.size() && j < l2.size()) {\n    if (l1[i]\
    \ == l2[j]) {\n      common[i] = l1[i];\n      ++i;\n      ++j;\n    } else if\
    \ (l1[i] < l2[j]) {\n      ++i;\n    } else if (l1[i] > l2[j]) {\n      ++j;\n\
    \    }\n  }\n\n  // Return result.\n  return common;", "    // Sort the lists\
    \ in descending order with unique elements.\n    sort(l1.begin(), l1.end());\n\
    \    sort(l2.begin(), l2.end());\n    // Set the index pointers to both lists.\n\
    \    auto ip1 = l1.begin();\n    auto ip2 = l2.begin();\n    // Initialize a vector\
    \ to store unique elements.\n    std::vector<long> u_list;\n    // Compare the\
    \ first elements and store the unique elements in vector. \n    while (ip1 !=\
    \ l1.end() && ip2 != l2.end()) {\n        if (*ip1 == *ip2) {\n            u_list.push_back(*ip1);\n\
    \            ip1++;\n            ip2++;\n        } else if (*ip1 < *ip2) {\n \
    \           ip1++;\n        } else {\n            ip2++;\n        }\n    }\n \
    \   return u_list;", "    std::vector<long> res;\n    auto it = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                                   std::back_inserter(res));\n\
    \    return res;", "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(),\
    \ l2.end());\n  std::vector<long> res;\n  for (long i = 0; i < (l1.size() <= l2.size()\
    \ ? l1.size() : l2.size()); i++) {\n    if (l1.size() <= l2.size() && i == l1.size())\
    \ {\n      res.push_back(l1[i]);\n    } else if (l1.size() > l2.size() && i ==\
    \ l2.size()) {\n      res.push_back(l2[i]);\n    } else if (l1[i] == l2[i]) {\n\
    \      res.push_back(l1[i]);\n    } else if (l1[i] < l2[i]) {\n      res.push_back(l1[i]);\n\
    \    } else {\n      res.push_back(l2[i]);\n    }\n  }\n  return res;", "    std::vector<long>\
    \ ret;\n    std::set<long> s1;\n    std::set<long> s2;\n    // Iterate and collect\
    \ unique elements from the two lists.\n    for(long i : l1)\n        s1.insert(i);\n\
    \    for(long i : l2)\n        s2.insert(i);\n    // Iterate and collect common\
    \ elements from both the sets.\n    for(long i : s1)\n        if(s2.find(i) !=\
    \ s2.end())\n            ret.push_back(i);\n    return ret;", "    // TODO\n \
    \   return {};", "    std::vector<long> v1(l1);\n    std::vector<long> v2(l2);\n\
    \    v1.erase(std::unique(std::begin(v1), std::end(v1)), std::end(v1));\n    v2.erase(std::unique(std::begin(v2),\
    \ std::end(v2)), std::end(v2));\n    return v1;", "  // Find common elements.\n\
    \  std::vector<long> s;\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(),\n                        std::back_inserter(s));\n  // Return sorted\
    \ unique common elements.\n  std::vector<long> result(s.size());\n  std::transform(s.begin(),\
    \ s.end(), result.begin(), std::inserter(result,\n                           \
    \                                               result.end()));\n  return result;",
  "  std::vector<long> l;\n  l.push_back(l1[0]);\n  for(long i = 1; i < l1.size();\
    \ i++) {\n    if(l1[i - 1] == l2[i]) {\n      continue;\n    }\n    l.push_back(l1[i]);\n\
    \  }\n  return l;", "  std::vector<long> result;\n  for (long x : l1) std::find(l2.begin(),\
    \ l2.end(), x) != l2.end()\n    ? result.push_back(x) : std::find(l1.begin(),\
    \ l1.end(), x) != l1.end();\n  return result;", "    long m = max(l1.size(), l2.size());\n\
    \    std::vector<long> result(m, std::nullopt);\n    for (size_t i = 0; i < m;\
    \ ++i) {\n        std::tie(result[i]) = std::minmax(std::min(l1[i], l2[i]), std::max(l1[i],\
    \ l2[i]));\n    }\n    return result;", "    std::vector<long> u1, u2;\n    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(u1));\n    std::set_intersection(l2.begin(),\
    \ l2.end(), l1.begin(), l1.end(), std::back_inserter(u2));\n    return std::unique(u1.begin(),\
    \ u1.end(), u2.begin(), u2.end());", "    std::vector<long> res;\n    if(l1.size()\
    \ == 0)\n        return res;\n    if(l2.size() == 0)\n        return l1;\n   \
    \ \n    auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(res));\n    res.erase(std::unique(it.begin(), it.end()),\
    \ it.end());\n    return res;", "    // Your code here\n    std::set<long> s1;\n\
    \    for(auto &i:l1)\n        s1.insert(i);\n    std::set<long> s2;\n    for(auto\
    \ &i:l2)\n        s2.insert(i);\n    auto it1=s1.begin();\n    auto it2=s2.begin();\n\
    \    std::vector<long> res;\n    for(;it1!=s1.end();it1++,it2++){\n        if((*it1)==(*it2)){\n\
    \            res.push_back(*it1);\n        }\n    }\n    return res;", "    std::vector<long>\
    \ res;\n    if (l1.size() == 0 || l2.size() == 0) {\n        return res;\n   \
    \ }\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    if (l1[l1.size() - 1] == l2[l2.size() - 1]) {\n        if (l1.size() == 1\
    \ && l2.size() == 1) {\n            res.push_back(l1[0]);\n        } else {\n\
    \            res.push_back(l1[l1.size() - 1]);\n        }\n        return res;\n\
    \    }\n    // compare first and last elements\n    if (l1[l1.size() - 1] > l2[l2.size()\
    \ - 1]) {\n        return common(l1, l2);\n    }\n    return common(l2, l1);",
  "        std::set<long> l3;\n        for (long elem : l1) {\n                l3.insert(elem);\n\
    \        }\n        for (long elem : l2) {\n                l3.insert(elem);\n\
    \        }\n        std::vector<long> l4;\n        l4.reserve(l1.size() + l2.size());\n\
    \        for (auto elem : l3) {\n                l4.push_back(elem);\n       \
    \ }\n        return l4;", "    std::vector<long> result;\n    long temp = 0;\n\
    \    int len = l1.size();\n    if (len == l2.size()) {\n        for (long i =\
    \ 0; i < len; i++) if (l1[i] == l2[i]) {\n            result.push_back(l1[i]);\n\
    \            result.push_back(l2[i]);\n        }\n        return result;\n   \
    \ }\n    \n    int mid = len / 2;\n    \n    for (int i = 0; i < mid; i++) {\n\
    \        temp = l1[i];\n        result.push_back(l2[i]);\n        result.push_back(temp);\n\
    \    }\n    \n    for (int i = mid; i < len; i++) {\n        temp = l1[i];\n \
    \       result.push_back(temp);\n        result.push_back(l2[i]);\n    }\n   \
    \ \n    return result;", "    // TODO: Implement me\n    return l1;", "  std::vector<long>\
    \ unique;\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(unique));\n  return unique;", "    // Your code here\n  \
    \  std::vector<long> common;\n    l1.insert(l1.end(), l2.begin(), l2.end());\n\
    \    std::vector<long> vec(l1.size());\n    std::iota(vec.begin(), vec.end(),\
    \ 0);\n    std::sort(vec.begin(), vec.end(), [&](long a, long b){return (l1[a]\
    \ > l1[b]) ? true : (l1[a] < l1[b]) ? false : (l1[a] == l1[b]);});\n    l1.erase(std::unique(l1.begin(),\
    \ l1.end(), [&](long a, long b)->bool{return (a == 0 || a == b) ? true : (l1[a]\
    \ > l1[b]) ? true : (l1[a] < l1[b]) ? false : (l1[a] == l1[b]);}), l1.end());\n\
    \    std::vector<long>::iterator it;\n    for (it = l1.begin(); it != l1.end();\
    \ it++)\n    {\n        common.push_back(*it);\n    }\n    return common;", " \
    \ // Declare and initialize a vector to store common elements.\n  std::vector<long>\
    \ common;\n  // Declare and initialize a vector to store the elements not found\
    \ in both lists.\n  std::vector<long> not_found;\n  // Declare and initialize\
    \ a vector to store the elements found in both lists.\n  std::vector<long> found;\n\
    \  // Iterate through l1 first and check for common elements.\n  for (int i =\
    \ 0; i < l1.size(); i++) {\n    if (l1.at(i) == l2.at(i)) {\n      found.push_back(l1.at(i));\n\
    \    } else {\n      not_found.push_back(l1.at(i));\n    }\n  }\n  // Iterate\
    \ through l2 first and check for common elements.\n  for (int i = 0; i < l2.size();\
    \ i++) {\n    if (l2.at(i) == l1.at(i)) {\n      found.push_back(l2.at(i));\n\
    \    } else {\n      not_found.push_back(l2.at(i));\n    }\n  }\n  // Iterate\
    \ through l1 and l2 simultaneously to find common elements.\n  for (int i = 0;\
    \ i < l1.size(); i++) {\n    for (int j = 0; j < l2.size(); j++) {\n      if (l1.at(i)\
    \ == l2.at(j)) {\n        common.push_back(l1.at(i));\n      }\n    }\n  }\n \
    \ return common;", "    // Your code goes here\n    std::vector<long> ret;\n \
    \   std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(ret));\n\
    \    return ret;", "    std::vector<long> common;\n    common.reserve(l1.size());\n\
    \    for(auto el : l1) {\n        for(auto el2 : l2) {\n            if(el == el2)\n\
    \                common.push_back(el);\n        }\n    }\n    return common;",
  "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::vector<long>\
    \ u;\n  for (size_t i = 0; i < l1.size(); ++i) {\n    if (l1.at(i) == l2.at(i))\n\
    \      continue;\n    u.push_back(l1.at(i));\n  }\n  return u;", "    std::vector<long>\
    \ common;\n    long& first = *(common.end());\n    if (l1.size() > l2.size())\
    \ {\n        first = *(common.begin());\n        std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                            std::back_inserter(common));\n\
    \    } else {\n        first = *(common.begin());\n        std::set_intersection(l2.begin(),\
    \ l2.end(), l1.begin(), l1.end(),\n                            std::back_inserter(common));\n\
    \    }\n    return common;", "    std::vector<long> u;\n    for(long i = 0; i\
    \ < l1.size(); i++) if(l1.find(l2[i]) == l1.end()) u.push_back(l1[i]);\n    return\
    \ u;", "    std::vector<long> ret(l1.size());\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                         std::back_inserter(ret));\n\
    \    return ret;", "    std::vector<long> retval;\n    for(long i : l1) retval.push_back(i);\n\
    \    for(long i : l2) retval.push_back(i);\n    sort(retval.begin(), retval.end());\n\
    \    std::vector<long>::iterator it;\n    for(it = retval.begin(), retval.end();\
    \ it != retval.end(); ++it) {\n        while(it != retval.end() && retval[*it]\
    \ == *--it);\n        if(it != retval.end()) retval[*it] = -1;\n    }\n    return\
    \ retval;", "    std::vector<long> result;\n    for(long i : l1) {\n        int\
    \ found = 0;\n        for(long j : l2) {\n            if(j == i)\n           \
    \     found++;\n        }\n        if(found == 1)\n            result.push_back(i);\n\
    \    }\n    return result;", "  std::vector<long> common;\n  std::set_intersection(l1.begin(),\
    \ l1.end(),\n                       l2.begin(), l2.end(),\n                  \
    \     std::back_inserter(common));\n  return common;", "  assert(l1.size() ==\
    \ l2.size());\n  std::vector<long> common(std::min(l1.size(), l2.size()), 0);\n\
    \  for (size_t i = 0; i < common.size(); i++) {\n    if (l1[i] == l2[i]) {\n \
    \     continue;\n    }\n    std::swap(common[i], common[l1[i] - l2[i]]);\n  }\n\
    \  return common;", "  long common[20];\n  for (int i = 0; i < 20; i++) common[i]\
    \ = 0;\n  for (int i = 0; i < 20; i++) {\n    if (common[i] == 0 && l1[i] == 0\
    \ && l2[i] == 0) continue;\n    if (l1[i] != l2[i]) common[i]++;\n  }\n  std::vector<long>\
    \ res;\n  for (int i = 0; i < 20; i++) if (common[i]) res.push_back(common[i]);\n\
    \  return res;", "    std::vector<long> res;\n    res.push_back(l1[0]);\n    res.push_back(l2[0]);\n\
    \    // For every element in l1 find its index in l2, if it is found then swap\
    \ them.\n    for (long i = 1; i < l1[0]; i++) {\n        int index = -1;\n   \
    \     for (long j = 0; j < l2[0]; j++) {\n            if (l1[i] == l2[j]) {\n\
    \                index = j;\n                break;\n            }\n        }\n\
    \        if (index != -1) {\n            std::swap(res[index], res[i - 1]);\n\
    \        }\n    }\n    return res;", "    auto it = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), \n                                    std::back_inserter(temp));\n\
    \    temp = std::vector<long>(it, l1.end());\n    return temp;", "  std::set<long>\
    \ common;\n  for(long l: l1) common.insert(l);\n  for(long l: l2) common.insert(l);\n\
    \n  std::vector<long> ret;\n  for(std::set<long>::iterator it = common.begin();\n\
    \      it != common.end();\n      ++it) {\n    ret.push_back(*it);\n  }\n\n  return\
    \ ret;", "  std::vector<long> c1;\n  std::vector<long> c2;\n  for (int i = 0;\
    \ i < l1.size(); i++) {\n    c1.push_back(l1[i]);\n  }\n  for (int i = 0; i <\
    \ l2.size(); i++) {\n    c2.push_back(l2[i]);\n  }\n  sort(c1.begin(), c1.end());\n\
    \  sort(c2.begin(), c2.end());\n  c1.erase(unique(std::begin(c1), std::end(c1)));\n\
    \  c2.erase(unique(std::begin(c2), std::end(c2)));\n  return c1;", "  std::vector<long>\
    \ c;\n  c.reserve(l1.size());\n  for (long i : l1) {\n    std::find(l2.begin(),\
    \ l2.end(), i) == l2.end() ? c.push_back(i) : ;\n  }\n  return c;", "    // Your\
    \ code goes here\n    // std::sort(l1.begin(), l1.end());\n    // std::sort(l2.begin(),\
    \ l2.end());\n    // std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(v));\n    // return v;", "  std::vector<long> common_elements(l1.size()\
    \ + l2.size());\n  long i = 0, j = 0;\n  while (i < l1.size() && j < l2.size())\
    \ {\n    if (l1[i] == l2[j]) common_elements[j++] = i;\n    i++;\n  }\n  while\
    \ (i < l1.size()) common_elements[j++] = i;\n  while (j < l2.size()) common_elements[i]\
    \ = j++;\n  return common_elements;", "    std::vector<long> temp;\n    for (long\
    \ i=0; i<l1.size() && i<l2.size(); i++) {\n        if (l1[i] == l2[i])\n     \
    \       continue;\n        if (l1[i] > l2[i])\n            temp[l2.size()] = l1[i];\n\
    \        else\n            temp[l1.size()] = l2[i];\n        l1.erase(l1.begin()\
    \ + i);\n        l2.erase(l2.begin() + i);\n    }\n    return temp;", "    std::vector<long>\
    \ l3;\n    l3.reserve(l1.size() + l2.size());\n    long i = 0;\n    for (long\
    \ & val : l1)\n        l3.push_back(val);\n    for (long & val : l2)\n       \
    \ l3.push_back(val);\n    // Sort the list\n    std::sort(l3.begin(), l3.end());\n\
    \    // Return sorted unique common elements\n    l3.erase(std::unique(l3.begin(),\
    \ l3.end()), l3.end());\n    return l3;", "    std::vector<long> res;\n    auto\
    \ it = l1.begin();\n    auto it2 = l2.begin();\n    if (it != l1.end() && it2\
    \ != l2.end()) {\n        if (*it < *it2) {\n            res.push_back(*it);\n\
    \            ++it;\n        } else {\n            res.push_back(*it2);\n     \
    \       ++it2;\n        }\n        while(it != l1.end() && it2 != l2.end() &&\
    \ *it < *it2) {\n            ++it;\n            ++it2;\n        }\n    }\n   \
    \ return res;", "    std::set<long> s1;\n    std::set<long> s2;\n\n    for (long\
    \ i = 0; i <l1.size() && i < l2.size(); ++i)\n        s1.insert(l1[i]);\n    for\
    \ (long i = 0; i <l2.size() && i < l1.size(); ++i)\n        s2.insert(l2[i]);\n\
    \    return s1.size() == s2.size() ? s1 : s2;", "    // Your code goes here\n\
    \    int m = l1.size();\n    int n = l2.size();\n    std::vector<long> res;\n\
    \    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if((l1[i]==l2[j])){\n\
    \                res.push_back(l1[i]);\n            }\n        }\n    }\n    return\
    \ res;", "    // Your code goes here\n    std::sort(l1.begin(),l1.end());\n  \
    \  std::sort(l2.begin(),l2.end());\n    std::vector<long> result;\n    for(size_t\
    \ i = 0; i < min(l1.size(),l2.size()); i++) {\n        if(l1[i] == l2[i])\n  \
    \          result.push_back(l1[i]);\n    }\n    return result;", "    std::vector<long>\
    \ res;\n    for (auto x : l1) {\n        for (auto y : l2) {\n            if (x\
    \ == y)\n                break;\n        }\n        if (l2.size())\n         \
    \   break;\n        res.push_back(x);\n    }\n    return res;", "    std::vector<long>\
    \ res;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    for(long i=0;i<l1.size()&&i<l2.size();i++) {\n        if(l1[i]==l2[i]) {\n\
    \            res.push_back(l1[i]);\n        }\n    }\n    return res;", "    //\
    \ Initialize hashmap with number of occurrences for each element.\n    std::unordered_map<long,\
    \ int> hashMap;\n    for (long elem : l1) hashMap[elem]++;\n    for (long elem\
    \ : l2) hashMap[elem]++;\n    // Initialize array for the results.\n    std::vector<long>\
    \ result;\n    // Add all elements that are present in both input lists.\n   \
    \ for (long elem : hashMap) {\n        if (l1.size() == hashMap.size() && l2.size()\
    \ == hashMap.size()) {\n            if (hashMap[elem] == l1.size() && hashMap[elem]\
    \ == l2.size()) {\n                // Found unique element.\n                result.push_back(elem);\n\
    \            }\n        }\n    }\n    return result;", "    auto it1 = l1.begin(),\
    \ it2 = l2.begin();\n    auto it1a = it1, it1b = it1, it2a = it2, it2b = it2;\n\
    \    while (true) {\n        while (it1a == it1 && it1b == it1) ++it1a, ++it1b;\n\
    \        while (it2a == it2 && it2b == it2) ++it2a, ++it2b;\n        if (it1a\
    \ == it1b || it2a == it2b)\n            return std::vector<long>(it1, it1 + std::min(it1a,\
    \ it2a + 1));\n        if (*it1a < *it2a)\n            ++it1a, ++it2a;\n     \
    \   else\n            ++it2a, ++it2b;\n    }", "    // Create empty vector to\
    \ store unique common elements.\n    std::vector<long> common_elements;\n    //\
    \ Iterate through each element of l1.\n    for (long i : l1) {\n        // Iterate\
    \ through each element of l2.\n        for (long j : l2) {\n            // If\
    \ an element of l1 is in l2, then add it to common_elements.\n            if (i\
    \ == j) {\n                common_elements.push_back(i);\n            }\n    \
    \    }\n    }\n    return common_elements;", "  std::vector<long> c;\n  c.reserve(l1.size()\
    \ + l2.size());\n  std::set_union(l1.begin(), l1.end(), l2.begin(), l2.end(),\n\
    \      [&c](long x) {\n        if (c.find(x) == c.end())\n          c.push_back(x);\n\
    \      });\n  return c;", "  std::vector<long> result;\n  // Sort the two lists.\n\
    \  auto compare = [](const long& l, const long& r) { return l < r; };\n  std::sort(l1.begin(),\
    \ l1.end(), compare);\n  std::sort(l2.begin(), l2.end(), compare);\n  // Find\
    \ common elements.\n  auto i1 = 0; auto i2 = 0; auto j = l1.size() - 1;\n  for\
    \ (; i1 < l1.size() && i2 < l2.size() && l1[i1] == l2[i2]; i1++, i2++, j--)\n\
    \    ;\n  // If i1 == l1.size() then l1 == l2.\n  if (i1 < l1.size() && i2 ==\
    \ l2.size())\n    result.push_back(l1[i1]);\n  // If i1 < l1.size() then l1.\n\
    \  else if (i1 < l1.size()) {\n    for (; i2 < l2.size() && i1 == l1.size(); i2++,\
    \ j--)\n      ;\n    // If i2 == l2.size() then l2 == l1.\n    if (i2 < l2.size()\
    \ && i1 == l1.size()) {\n      result.push_back(l1[i1]);\n    } else {\n     \
    \ // Continue the search in l1.\n      j++;\n      result.push_back(l1[i1]);\n\
    \    }\n  }\n  // If i2 < l2.size() then l2.\n  else if (i2 < l2.size()) {\n \
    \   for (; i1 < l1.size() && i2 == l2.size(); i1++, j--)\n      ;\n    // If i1\
    \ == l1.size() then l1 == l2.\n    if (i1 < l1.size() && i2 == l2.size()) {\n\
    \      result.push_back(l1[i1]);\n    } else {\n      // Continue the search in\
    \ l2.\n      j++;\n      result.push_back(l2[i2]);\n    }\n  }\n  // Return sorted\
    \ common elements.\n  return result;", "   std::vector<long> result;\n   std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n   return result;",
  "    std::vector<long> ret;\n    ret.push_back(l1[0]);\n    ret.push_back(l1[1]);\n\
    \    ret.push_back(l2[0]);\n    ret.push_back(l2[1]);\n    ret.push_back(l1[2]);\n\
    \    ret.push_back(l2[2]);\n    ret.push_back(l1[3]);\n    ret.push_back(l2[3]);\n\
    \    ret.push_back(l1[4]);\n    ret.push_back(l2[4]);\n    ret.push_back(l1[5]);\n\
    \    ret.push_back(l2[5]);\n    ret.push_back(l1[6]);\n    ret.push_back(l2[6]);\n\
    \    ret.push_back(l1[7]);\n    ret.push_back(l2[7]);\n    ret.push_back(l1[8]);\n\
    \    ret.push_back(l2[8]);\n    ret.push_back(l1[9]);\n    ret.push_back(l2[9]);\n\
    \    ret.push_back(l1[10]);\n    ret.push_back(l2[10]);\n    ret.push_back(l1[11]);\n\
    \    ret.push_back(l2[11]);\n    ret.push_back(l1[12]);\n    ret.push_back(l2[12]);\n\
    \    ret.push_back(l1[13]);\n    ret.push_back(l2[13]);\n    ret.push_back(l1[14]);\n\
    \    ret.push_back(l2[14]);\n    ret.push_back(l1[15]);\n    ret.push_back(l2[15]);\n\
    \    ret.push_back(l1[16]);\n    ret.push_back(l2[16]);\n    ret.push_back(l1[17]);\n\
    \    ret.push_back(l2[17]);\n    ret.push_back(l1[18]);\n    ret.push_back(l2[18]);\n\
    \    ret.push_back(l1[19]);\n    ret.push_back(l2[19]);\n    ret.push_back(l1[20]);\n\
    \    ret.push_back(l2[20]);\n    ret.push_back(l1[21]);\n    ret.push_back(l2[21]);\n\
    \    ret.push_back(l1[22]);\n    ret.push_back(l2[22]);\n    ret.push_back(l1[23]);\n\
    \    ret.push_back(l2[23]);\n    ret.push_back(l1[24]);\n    ret.push_back(l2[24]);\n\
    \    ret.push_back(l1[25]);\n    ret.push_back(l2[25]);\n    ret.push_back(l1[26]);\n\
    \    ret.push_back(l2[26]);\n    ret.push_back(l1[27]);\n    ret.push_back(l2[27]);\n\
    \    ret.push_back(l1[28]);\n    ret.push_back(l2[28]);\n    ret.push_back(l1[29]);\n\
    \    ret.push_back(l2[29]);\n    ret.push_back(l1[30]);\n    ret.push_back(l2[30]);\n\
    \    ret.push_back(l1[31]);\n    ", "    std::vector<long> result;\n    result.push_back(l1[0]);\n\
    \    long n = l1.size();\n    long m = l2.size();\n    long i = 1;\n    while\
    \ (i <= n && i <= m) {\n        if (l1[i - 1] == l2[i]) {\n            result.push_back(l1[i\
    \ - 1]);\n            i++;\n        } else if (l1[i - 1] > l2[i]) {\n        \
    \    break;\n        } else {\n            result.push_back(l2[i]);\n        \
    \    m--;\n        }\n    }\n    while (i <= n) {\n        result.push_back(l1[i\
    \ - 1]);\n        i++;\n    }\n    while (i <= m) {\n        result.push_back(l2[i]);\n\
    \        i++;\n    }\n    return result;", "    // Write your code here.\n   \
    \ l1.insert(std::end(l1), std::begin(l2), std::end(l2));\n    std::sort(std::begin(l1),\
    \ std::end(l1));\n    std::sort(std::begin(l2), std::end(l2));\n    return l1;",
  "    // Use map and set instead of unordered_map and unordered_set\n    // because\
    \ unordered_set needs O(n*log(n)) time but unordered_map \n    // needs O(n) time\n\
    \    std::map<long, bool> mp;\n    std::set<long> s;\n    // If two elements are\
    \ equal, then the one with smaller index\n    // will be in the set so this loop\
    \ executes n times at worst\n    for (int i = 0; i < l1.size(); i++) {\n     \
    \   if (!mp[l1[i]]) {\n            mp[l1[i]] = true;\n            s.insert(l1[i]);\n\
    \        }\n    }\n\n    for (int i = 0; i < l2.size(); i++) {\n        if (!mp[l2[i]])\
    \ {\n            mp[l2[i]] = true;\n            s.insert(l2[i]);\n        }\n\
    \    }\n\n    // Get the size to return\n    int n = s.size();\n    std::vector<long>\
    \ res(n);\n\n    // Sort the array based on the index\n    // If the order is\
    \ preserved, then the last element will be \n    // the one with larger index\n\
    \    std::sort(s.begin(), s.end(), [&](long l, long r) {\n        return l < r;\n\
    \    });\n\n    // Populate the array\n    for (int i = 0; i < n; i++)\n     \
    \   res[i] = s.at(i);\n\n    return res;", "    std::vector<long> result;\n  \
    \  std::set<long> l3; l3.insert(l1.begin(), l1.end()); // Add all elements of\
    \ l1 to set.\n    l3.insert(l2.begin(), l2.end()); // Add all elements of l2 to\
    \ set.\n    // Loop over all elements of l3, compare with set l2.\n    for (auto\
    \ i : l3) {\n        auto it = l2.find(i);\n        if (it != l2.end()) {\n  \
    \          auto it = result.find(i);\n            if (it == result.end()) result.push_back(i);\n\
    \        }\n    }\n    return std::move(result);", "    long s = 0;\n    for (long\
    \ i = 0; i < l1.size(); ++i) {\n        for (long j = 0; j < l2.size(); ++j) {\n\
    \            if (l1[i] == l2[j]) {\n                s += 1;\n            }\n \
    \       }\n    }\n    std::vector<long> ans;\n    for (long i = 0; i < l1.size();\
    \ ++i) {\n        if (s == l1.size()) {\n            ans.push_back(l1[i]);\n \
    \       }\n    }\n    for (long i = 0; i < l2.size(); ++i) {\n        if (s ==\
    \ l2.size()) {\n            ans.push_back(l2[i]);\n        }\n    }\n    return\
    \ ans;", "    std::vector<long> result;\n    for(long i = 0; i < l1.size(); i++)\
    \ {\n        for(long j = 0; j < l2.size(); j++) {\n            if(l1[i] == l2[j])\
    \ {\n                result.push_back(l1[i]);\n                break;\n      \
    \      }\n        }\n    }\n    return result;", "    std::vector<long> common;\n\
    \    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    for(long i : l1) std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(common));\n    return common;", "    std::vector<long>\
    \ u;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \n    std::vector<long>::iterator itr;\n    for(itr = l1.begin(); itr != l1.end();\
    \ ++itr) {\n        u.push_back(*itr);\n        for(long jtr = l2.begin(); jtr\
    \ != l2.end(); ++jtr) {\n            if(*itr == *jtr) {\n                u.push_back(*jtr);\n\
    \                break;\n            }\n        }\n    }\n    return u;", "  \
    \  std::vector<long> u;\n    for(auto x:l1){\n        std::find(l2.begin(), l2.end(),\
    \ x) != l2.end()?u.push_back(x):;\n    }\n    return u;", "    std::vector<long>\
    \ a(l1);\n    std::set_intersection(a.begin(), a.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(a));\n    return a;", "    long n = l1.size();\n    long\
    \ m = l2.size();\n    std::vector<long> result(l1.size());\n    \n    std::vector<long>::iterator\
    \ it1 = l1.begin();\n    std::vector<long>::iterator it2 = l2.begin();\n    \n\
    \    for (long i = 0; i <= n; i++) {\n        for (long j = 0; j <= m; j++) {\n\
    \            if (i == j) continue;\n            if (it1 == l1.end() && it2 ==\
    \ l2.end()) {\n                result[i] = j;\n                continue;\n   \
    \         }\n            if (it1 == l1.end() && it2 != l2.end()) {\n         \
    \       result[i] = it2[j];\n                continue;\n            }\n      \
    \      if (it1 != l1.end() && it2 == l2.end()) {\n                result[i] =\
    \ it1[j];\n                continue;\n            }\n            if (it1 != l1.end()\
    \ && it2 != l2.end()) {\n                if (it1[i] == it2[j]) {\n           \
    \         result[i] = it1[j];\n                    continue;\n               \
    \ }\n                else {\n                    if (it1[i] < it2[j]) result[i]\
    \ = it1[j];\n                    else result[i] = it2[j];\n                }\n\
    \            }\n        }\n    }\n    \n    return result;", "  std::vector<long>\
    \ common;\n  auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(),\n                                 std::back_inserter(common));\n \
    \ return common;", "  std::set<long> s;\n  std::vector<long> res;\n  for (long\
    \ i : l1) s.insert(i);\n  for (long i : l2) s.insert(i);\n  std::set_intersection(s.begin(),\
    \ s.end(), l1.begin(), l1.end(), res.begin());\n  return res;", "    std::vector<long>\
    \ ret;\n    std::set_intersection(l1.begin(), l1.end(),\n                    \
    \      l2.begin(), l2.end(),\n                          std::back_inserter(ret));\n\
    \    return ret;", "    std::vector<long> res;\n    res.reserve(l1.size() + l2.size());\n\
    \    for (long i : l1) {\n        for (long j : l2) {\n            if (i == j)\
    \ continue;\n            if (res.find(j) == res.end()) {\n                res.push_back(i);\n\
    \                break;\n            }\n        }\n    }\n    return res;", " \
    \ std::vector<long> result;\n  \n  // Sort lists once\n  std::sort(l1.begin(),\
    \ l1.end());\n  std::sort(l2.begin(), l2.end());\n  \n  // Compare lists\n  while\
    \ (l1.size() != 0 && l2.size() != 0) {\n    if (l1[0] != l2[0]) {\n      break;\n\
    \    }\n    \n    result.push_back(l1[0]);\n    l1.erase(l1.begin());\n    l2.erase(l2.begin());\n\
    \  }\n\n  // If one list has more elements than another\n  if (l1.size() != 0)\
    \ {\n    result = result;\n  }\n  \n  return result;", "    std::vector<long>\
    \ result;\n    long s = 0;\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    for (long i : result) s = s * i;\n    return result;", "    std::vector<long>\
    \ a(l1.begin(), l1.end());\n    std::vector<long> b(l2.begin(), l2.end());\n \
    \   std::vector<long> c;\n    std::set_intersection(a.begin(), a.end(), b.begin(),\
    \ b.end(), std::back_inserter(c));\n    return c;", "    std::vector<long> out;\n\
    \    out.push_back(0);\n    std::set<long> common;\n    for (int i = 0; i < l1.size();\
    \ i++) {\n        common.insert(l1[i]);\n    }\n    for (int i = 0; i < l2.size();\
    \ i++) {\n        if (common.find(l2[i]) == common.end()) {\n            out.push_back(l2[i]);\n\
    \            common.insert(l2[i]);\n        }\n    }\n    return out;", "    std::vector<long>\
    \ retval;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    for (size_t i = 0; i < min(l1.size(), l2.size()); ++i)\n        if (l1[i]\
    \ == l2[i])\n            retval.push_back(l1[i]);\n        else\n            break;\n\
    \    return retval;", "    if (l1.size() != l2.size())\n        return {};\n \
    \   std::vector<long> result;\n    // Two pointers, each points to the first element\
    \ of a list of\n    // unique elements.\n    auto iter1 = l1.begin();\n    auto\
    \ iter2 = l2.begin();\n    auto iter1_end = l1.end();\n    auto iter2_end = l2.end();\n\
    \n    while (iter1 != iter1_end && iter2 != iter2_end) {\n        if (*iter1 !=\
    \ *iter2)\n            ++iter1;\n        ++iter2;\n    }\n    result.insert(result.end(),\
    \ iter1, iter1_end);\n    if (iter1 == iter1_end) {\n        result.insert(result.end(),\
    \ iter2, iter2_end);\n    }\n    return result;", "    std::vector<long> v;\n\
    \    for(long i = 0; i < l1.size() || i < l2.size(); i++) {\n        v.push_back(l1[i]\
    \ < l2[i] ? l1[i] : l2[i]);\n    }\n    std::sort(v.begin(), v.end());\n    return\
    \ v;", "    std::vector<long> v;\n    for (long i: l1)\n        for (long j: l2)\n\
    \            if (i==j) continue;\n                v.push_back(i);\n    for (long\
    \ i: l2) v.push_back(i);\n    std::sort(v.begin(), v.end());\n    return v;",
  "    std::vector<long> result;\n    for (long i = 0; i < l1.size(); i++) {\n   \
    \     for (long j = 0; j < l2.size(); j++) {\n            if (l1[i] == l2[j])\
    \ {\n                result.push_back(l1[i]);\n                break;\n      \
    \      }\n        }\n    }\n    std::sort(result.begin(), result.end());\n   \
    \ return result;", "  std::vector<long> vResult;\n  vResult.reserve(l1.size()\
    \ + l2.size());\n  for (size_t i = 0; i < (l1.size() + l2.size()); i++) {\n  \
    \  if (i > 0)\n      vResult.push_back(vResult[(i - 1) / 2]);\n    if (i >= l1.size()\
    \ || i >= l2.size())\n      vResult.push_back(i);\n  }\n  std::sort(vResult.begin(),\
    \ vResult.end());\n  return vResult;", "  // O(n * lgn) where n = min(l1.size(),\
    \ l2.size())\n  std::vector<long> res(l1.size());\n  std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n      std::back_inserter(res));\n  return res;",
  "   auto u = std::set_intersection(l1.begin(), l1.end(),\n                     \
    \            l2.begin(), l2.end(),\n                                 std::back_inserter(std::vector()));\n\
    \   return std::vector<long>(u.begin(), u.end());", "    // Write your code here.\n\
    \    std::vector<long> v;\n    for(long i = 0 ; i< l1.size() && i<l2.size(); i++){\n\
    \        if(l1[i] == l2[i]){\n            v.push_back(l1[i]);\n        }\n   \
    \ }\n    for(long i = 0; i< l1.size() && i<l2.size(); i++){\n        if(l1[i]\
    \ != l2[i]){\n            v.push_back(l1[i]);\n        }\n    }\n    for(long\
    \ i = 0; i< l1.size() && i<l2.size(); i++){\n        if(l1[i] == l2[i]){\n   \
    \         v.push_back(l2[i]);\n        }\n    }\n    return v;", "  std::vector<long>\
    \ res;\n  if (l1.size() > l2.size()) {\n    l2 = l2.substr(0, l1.size());\n  }\n\
    \  for (long i = 0; i < l1.size(); i++) {\n    if (find(l2.begin(), l2.end(),\
    \ l1[i]) != l2.end()) {\n      res.push_back(l1[i]);\n    }\n  }\n  return res;",
  "    long m = l1[0], n = l2[0];\n    std::vector<long> ms(n);\n    for(long i =\
    \ 1; i < n; i++) {\n        if( m != l2[i] ) { ms[i] = 1; }\n        else { ms[i]\
    \ = 0; }\n        m = m1[i];\n    }\n    return ms.begin();", "    std::vector<long>\
    \ result;\n    for(long i = 0; i < std::min(l1.size(), l2.size()); i++) {\n  \
    \      if(l1[i] == l2[i])\n            continue;\n        if(l1[i] < l2[i])\n\
    \            result.push_back(l1[i]);\n        else\n            result.push_back(l2[i]);\n\
    \    }\n    return result;", "    std::vector<long> res;\n    for (long i : l1)\
    \ res.push_back(i);\n    for (long i : l2) res.push_back(i);\n    std::sort(res.begin(),\
    \ res.end());\n    return res;", "    std::vector<long> l3;\n    l3.reserve(l1.size());\n\
    \    long commonVal = std::min(l1[0], l2[0]);\n    for (long i = 1; i < l1.size();\
    \ i++)\n        if (l1[i] == commonVal) \n            continue;\n        else\
    \ if (l2[i] == commonVal)\n            return l3;\n        else\n            l3.push_back(commonVal);\n\
    \    l3.push_back(commonVal);\n    return l3;", "  long size = l1.size();\n  std::vector<long>\
    \ res;\n  for (size_t i = 0; i < size; i++) {\n    if (l1.find(l2[i]) != l1.end())\
    \ {\n      res.push_back(l2[i]);\n    }\n  }\n  return res;", "  long i = 0, j\
    \ = 0;\n  std::vector<long> v;\n  while (i < l1.size() && j < l2.size()) {\n \
    \   if (l1[i] == l2[j])\n      v.push_back(l1[i]);\n    else if (l1[i] < l2[j])\n\
    \      i++;\n    else\n      j++;\n  }\n  while (i < l1.size())\n    v.push_back(l1[i]);\n\
    \  while (j < l2.size())\n    v.push_back(l2[j]);\n  return v;", "    std::vector<long>\
    \ vec;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    if (l1.size() == l2.size()) \n        std::set_intersection(l1.begin(), l1.end(),\
    \ l2.begin(), l2.end(), std::back_inserter(vec));\n    return vec;", "       \
    \ std::vector<long> res;\n        std::sort(l1.begin(), l1.end());\n        std::sort(l2.begin(),\
    \ l2.end());\n        std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(res));\n        return res;", "\tstd::vector<long>\
    \ res;\n\tres.push_back(l1[0]);\n\tres.push_back(l1[1]);\n\tfor (long i = 2; i\
    \ < l1.size(); ++i) {\n\t\tif (l1[i] == l2[i]) {\n\t\t\tres.push_back(l1[i]);\n\
    \t\t}\n\t}\n\treturn res;", "    std::set<long> common;\n    for (long i: l1)\
    \ {\n        auto it = std::find(l2.begin(), l2.end(), i);\n        if (it !=\
    \ l2.end()) {\n            common.insert(it);\n            l1.erase(it);\n   \
    \     }\n    }\n    return std::vector<long>(common.begin(), common.end());",
  "  long n1, n2, nm, i, j, m;\n  std::vector<long> v;\n  n1 = l1.size();\n  n2 =\
    \ l2.size();\n  nm = n1 + n2;\n  for (i = 0; i < n1; ++i)\n    for (j = 0; j <\
    \ n2; ++j) {\n      if (l1[i] != l2[j])\n        v.push_back(l1[i]);\n    }\n\
    \  return v;", "    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n    std::vector<long>\
    \ v1;\n    std::vector<long> v2;\n    while (it1 != l1.end() && it2 != l2.end())\
    \ {\n        if (*it1 == *it2) {\n            v1.push_back(*it1);\n          \
    \  ++it1;\n            ++it2;\n        } else if (*it1 < *it2) {\n           \
    \ v1.push_back(*it1);\n            ++it1;\n        } else {\n            v2.push_back(*it2);\n\
    \            ++it2;\n        }\n    }\n    while (v1.size() > 0 && v2.size() >\
    \ 0) {\n        v1.erase(v1.begin());\n        v2.erase(v2.begin());\n    }\n\
    \    while (v1.size() > 0) {\n        v1.push_back(v2[0]);\n        v2.erase(v2.begin());\n\
    \    }\n    while (v2.size() > 0) {\n        v1.push_back(v2[0]);\n        v2.erase(v2.begin());\n\
    \    }\n    return v1;", "    std::vector<long> vs;\n    vs.reserve(l1.size()\
    \ + l2.size());\n    std::vector<bool> visited(l1.size(), false);\n    std::vector<long>\
    \ result(l1.size(), 0);\n    for (size_t i = 0; i < l1.size(); i++) {\n      \
    \  if (!visited[i]) {\n            while (i < l1.size() && !visited[i])\n    \
    \            i++;\n            while (i < l1.size() && visited[i])\n         \
    \       ++i;\n            while (i < l1.size() && !visited[i])\n             \
    \   i++;\n            while (i < l1.size() && visited[i])\n                visited[i]\
    \ = false;\n            vs.push_back(l1[i]);\n            vs.push_back(l2[i]);\n\
    \            if (i == l1.size() || i == l2.size()) {\n                if (!visited[l1.size()\
    \ - 1])\n                    vs.push_back(l1[l1.size() - 1]);\n              \
    \  if (!visited[l2.size() - 1])\n                    vs.push_back(l2[l2.size()\
    \ - 1]);\n            }\n        }\n    }\n    std::sort(vs.begin(), vs.end());\n\
    \    for (size_t i = 0; i < vs.size(); i++)\n        if (vs[i] != 0)\n       \
    \     result.push_back(vs[i]);\n    return result;", "    assert(l1.size() ==\
    \ l2.size());\n    std::vector<long> l3;\n    long max_num = max(l1.size(), l2.size());\n\
    \    for (long i = 0; i < max_num; i++) {\n        long cur = l1.size() <= i ?\
    \ 0 : l1[i];\n        long next = l2.size() <= i ? 0 : l2[i];\n        l3.push_back(cur);\n\
    \        l3.push_back(next);\n    }\n    std::sort(l3.begin(), l3.end());\n  \
    \  return l3;", "    std::vector<long> res;\n    for (long i : l1) res.push_back(i);\
    \ // adding first set elements to the res vector\n    for (long i : l2) res.push_back(i);\
    \ // adding second set elements to the res vector\n    std::vector<long> res1(res);\
    \ // copy the res to res1 vector\n    std::sort(res1.begin(), res1.end()); //\
    \ sort the res1 vector\n    for (long i = 0; i < res.size(); i++) {\n        while\
    \ (i < res1.size() && !res1[i] == res[i]) i++; // find common elements between\
    \ res1 vector and res vector\n        if (i == res1.size()) return res; // if\
    \ all the elements in res are in res1 vector, then return res\n        std::swap(res1[i],\
    \ res[i]); // swap res1[i] and res[i]\n    }\n    return res1;", "    // sort\
    \ l1 and l2\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    \n    // get the size of l1 and l2\n    size_t n = std::min(l1.size(), l2.size());\n\
    \    \n    // initialize and sort a container for result \n    std::vector<long>\
    \ result(l1.size());\n    std::iota(result.begin(), result.end(), 0);\n    std::sort(result.begin(),\
    \ result.end(), [&l1, &l2](long i, long j) {\n        return std::find(l1.begin(),\
    \ l1.end(), i) == l1.end() ||\n               std::find(l2.begin(), l2.end(),\
    \ i) == l2.end();\n    });\n    \n    // remove duplicates\n    for (auto it =\
    \ result.begin(); it != result.end(); it++)\n        if (l1[*it] == l2[*it])\n\
    \            result.erase(it);\n            \n    // return the result\n    return\
    \ std::vector<long>(std::begin(result), std::end(result));"]
stop_tokens:
- "\n}"
