language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels;\n    for(int i = word.size(); i >= 0; i--)\
    \ {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            vowels.insert(vowels.begin(), word[i]);\n\
    \        }\n    }\n    for(int i = vowels.size(); i >= 0; i--) {\n        if(word[word.size()\
    \ - i] != 'a' && word[word.size() - i] != 'e' && word[word.size() - i] != 'i'\
    \ && word[word.size() - i] != 'o' && word[word.size() - i] != 'u') {\n       \
    \     break;\n        }\n    }\n    return vowels;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwec80whm: /tmp/tmpwec80whm.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120389
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels;\n    for (char ch : word) {\n       \
    \ if (isalpha(ch)) {\n            vowels.push_back(tolower(ch));\n        }\n\
    \    }\n    std::string vowel_string;\n    vowel_string.reserve(vowels.size());\n\
    \    for (char ch : vowels) {\n        if (ch == 'a' || ch == 'e' || ch == 'i'\
    \ || ch == 'o' || ch == 'u') {\n            vowel_string += ch;\n        }\n \
    \   }\n    int vowel_start = word.find_last_not_of(vowel_string);\n    int vowel_end\
    \ = word.find_last_of(vowel_string);\n    if (vowel_start == std::string::npos\
    \ || vowel_end == std::string::npos) {\n        return \"\";\n    }\n    return\
    \ word.substr(vowel_end + 1, vowel_start - vowel_end + 1);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpoyn0l3g3: /tmp/tmpoyn0l3g3.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    for(int i = word.length(); i>0; i--) {\n        if(word[i] >= 'a'\
    \ && word[i] <= 'z') {\n            for(int j = i; j < word.length(); j++) {\n\
    \                if(word[j] >= 'a' && word[j] <= 'z') {\n                    if(word[i]\
    \ < word[j]) {\n                        if(word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n                    \
    \        return word;\n                        }\n                        else\
    \ {\n                            return \"\";\n                        }\n   \
    \                 }\n                    else {\n                        if(word[j]\
    \ == word[i]) {\n                            return word;\n                  \
    \      }\n                        else {\n                            return \"\
    \";\n                        }\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo96mmes6: /tmp/tmpo96mmes6.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120389
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::stack<char> vowels;\n    std::stack<int> vcnt;\n    vowels.push(word[0]);\n\
    \    vcnt.push(0);\n    for(int i=1;i<word.size();++i) {\n        if(vowels.top()\
    \ == 'a') {\n            if(word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u') {\n                vowels.pop();\n                vcnt.pop();\n\
    \                vcnt.push(1);\n            } else {\n                vowels.push(word[i]);\n\
    \                vcnt.push(0);\n            }\n        }\n        else if(vowels.top()\
    \ == 'e') {\n            if(word[i] == 'a' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u') {\n                vowels.pop();\n                vcnt.pop();\n\
    \                vcnt.push(1);\n            } else {\n                vowels.push(word[i]);\n\
    \                vcnt.push(0);\n            }\n        }\n        else if(vowels.top()\
    \ == 'i') {\n            if(word[i] == 'a' || word[i] == 'e' || word[i] == 'o'\
    \ || word[i] == 'u') {\n                vowels.pop();\n                vcnt.pop();\n\
    \                vcnt.push(1);\n            } else {\n                vowels.push(word[i]);\n\
    \                vcnt.push(0);\n            }\n        }\n        else if(vowels.top()\
    \ == 'o') {\n            if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'u') {\n                vowels.pop();\n                vcnt.pop();\n\
    \                vcnt.push(1);\n            } else {\n                vowels.push(word[i]);\n\
    \                vcnt.push(0);\n            }\n        }\n        else if(vowels.top()\
    \ == 'u') {\n            if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o') {\n                vowels.pop();\n                vcnt.pop();\n\
    \                vcnt.push(1);\n            } else {\n                vowels.push(word[i]);\n\
    \                vcnt.push(0);\n            }\n        }\n        else {\n   \
    \         if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n                vowels.pop();\n                vcnt.pop();\n\
    \                vcnt.push(1);\n            } else {\n                vowels.push(word[i]);\n\
    \                vcnt.push(0);\n            }\n        }\n    }\n    if(vowels.top()\
    \ != 'a' || vowels.top() != 'e' || vowels.top() != 'i' || vowels.top() != 'o'\
    \ || vowels.top() != 'u') {\n        return \"\";\n    }\n    return word[vcnt.top()].to_string();\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp08t94w9y.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp08t94w9y.cpp:79:29: error: request for member \u2018to_string\u2019\
    \ in \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)vcnt.std::stack<int>::top()))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   79 |     return word[vcnt.top()].to_string();\n\
    \      |                             ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int lenght = word.size();\n    for(int i=lenght-1;i>0;--i){\n \
    \       if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n\
    \            std::string new_word = word;\n            new_word.erase(i,1);\n\
    \            int j = i+1;\n            while(j<lenght){\n                if(word[j]=='a'\
    \ || word[j]=='e' || word[j]=='i' || word[j]=='o' || word[j]=='u'){\n        \
    \            new_word+=word[j];\n                    break;\n                }\n\
    \                ++j;\n            }\n            return new_word;\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp33tei_op: /tmp/tmp33tei_op.cpp:30: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120389
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    int n = 0;\n    int left_cons = 0, right_cons = 0;\n    std::string\
    \ res;\n    \n    for (size_t i = 0; i < word.size(); ++i)\n    {\n        if\
    \ (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u')\n        {\n            n = i;\n            left_cons = i - 1;\n   \
    \     }\n    }\n    \n    for (size_t i = word.size(); i > 0; --i)\n    {\n  \
    \      if (word[i - 1] == 'a' || word[i - 1] == 'e' || word[i - 1] == 'i' || word[i\
    \ - 1] == 'o' || word[i - 1] == 'u')\n        {\n            n = i;\n        \
    \    right_cons = i;\n        }\n    }\n    \n    for (int i = n; i <= right_cons\
    \ - 1; ++i)\n    {\n        if (word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            return res;\n\
    \        }\n    }\n    \n    for (int i = n; i > 0; --i)\n    {\n        if (word[i\
    \ - 1] == 'a' || word[i - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o'\
    \ || word[i - 1] == 'u')\n        {\n            return res;\n        }\n    }\n\
    \    \n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzmqnkib_: /tmp/tmpzmqnkib_.cpp:53: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120389
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    for(auto it = word.cbegin() ; it != word.cend() ; ++it) {\n   \
    \     if(*it == 'a' || *it == 'A' || it == 'e' || *it == 'E' || *it == 'i' ||\
    \ *it == 'I'\n           || *it == 'o' || *it == 'O' || it == 'u' || *it == 'U')\n\
    \            return \"\";\n    }\n    return word;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm432y0dt.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpm432y0dt.cpp:11:43: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018char\u2019)\n   11 |         if(*it == 'a' || *it == 'A' ||\
    \ it == 'e' || *it == 'E' || *it == 'i' || *it == 'I'\n      |               \
    \                         ~~ ^~ ~~~\n      |                                 \
    \       |     |\n      |                                        |     char\n \
    \     |                                        __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpm432y0dt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm432y0dt.cpp:11:46: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorR, _Container>\u2019\
    \ and \u2018char\u2019\n   11 |         if(*it == 'a' || *it == 'A' || it == 'e'\
    \ || *it == 'E' || *it == 'i' || *it == 'I'\n      |                         \
    \                     ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpm432y0dt.cpp:2:\n/usr/include/c+"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n   \
    \ for (int i = 0; word[i] != '\\0'; i++) {\n        if (word[i] == word[i + 1])\n\
    \            return \"\";\n    }\n    for (size_t i = 0; i < vowels.size(); i++)\
    \ {\n        if (word.find(vowels[i]) != std::string::npos)\n            return\
    \ word;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpicodznr7.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpicodznr7.cpp:10:50: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   10 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n     \
    \ |                                                  ^\n      |              \
    \                                    |\n      |                              \
    \                    <brace-enclosed initializer list>\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowel = \"aeiouAEIOU\";\n  auto vowel_count = vowel.begin(),\
    \ vowel_end = vowel.end();\n  for (auto it  = word.rbegin(), it_end = word.rend();\n\
    \       it != it_end ;\n       it = std::next(it, vowel_count))\n  {\n    if (std::find(vowel_count.base(),\
    \ vowel_end.base(), *it) != vowel_end.base())\n    {\n      vowel_count += 1;\n\
    \    }\n  }\n  if (vowel_count == vowel.size()) return std::string{};\n  else\
    \ return word.substr(vowel_count, word.size() - vowel_count);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoza67nvr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpoza67nvr.cpp:14:27: error: cannot convert \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__iterator_traits<std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >, void>::difference_type\u2019 {aka \u2018\
    long int\u2019}\n   14 |        it = std::next(it, vowel_count))\n      |    \
    \                       ^~~~~~~~~~~\n      |                           |\n   \
    \   |                           __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:66,\n      \
    \           from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpoza67nvr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator_base_funcs.h:214:52:\
    \ note:   initializing argument 2 of \u2018constexpr _InputIterator std::next(_InputIterator,\
    \ typename std::iterator_traits<_Iter>::difference_type) [with _InputIterator\
    \ = std::reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > >; typename std::iterator_traits<_Iter>::difference_type = long int]\u2019\
    \n  213 |     next(_InputIterator __x, typename\n      |                     \
    \         ~~~~~~~~               \n  214 |   iterator_traits<_InputIterator>::difference_type\
    \ __n = 1)\n      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpoza67nvr.cpp:21:19: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019})\n   21 |   if (vowel_count == vowel.size()) return std::string{};\n\
    \      |       ~~~~~~~~~~~ ^~ ~~~~~~~~~~~~\n      |       |                  \
    \      |\n      |       |                        std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned in"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    int i = 0;\n    int j\
    \ = word.size() - 1;\n    while (i <= j) {\n        if (std::find(vowels.begin(),\
    \ vowels.end(), word[i]) != vowels.end()) {\n            return word[i];\n   \
    \     }\n        i++;\n        j--;\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvjs_zoc_.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpvjs_zoc_.cpp:15:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   15 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.length();\n    for(int i= word.length()-1;i>=0; i--){\n\
    \        if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n\
    \            return word[i];\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3z0xgtjj.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp3z0xgtjj.cpp:13:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   13 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int rightmost = word.size() - 1;\n  int index = 0;\n  int min = 0;\n\
    \  std::string res;\n\n  assert(!word.empty());\n\n  while (index != rightmost)\
    \ {\n    if (word[index] == 'a' || word[index] == 'e' || word[index] == 'i' ||\
    \ word[index] == 'o' || word[index] == 'u') {\n      min = (min == 0 ? right :\
    \ min);\n      right = (index == (rightmost - 1) ? index : right);\n    }\n  \
    \  index++;\n  }\n\n  assert(min != right);\n  res = word.substr(min, right -\
    \ min);\n  assert(res.size() == 0);\n  return res;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjm1wkn8c.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpjm1wkn8c.cpp:19:25: error: \u2018right\u2019 was not declared in this\
    \ scope; did you mean \u2018std::right\u2019?\n   19 |       min = (min == 0 ?\
    \ right : min);\n      |                         ^~~~~\n      |              \
    \           std::right\nIn file included from /usr/include/c++/9/ios:42,\n   \
    \              from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpjm1wkn8c.cpp:2:\n/usr/include/c++/9/bits/ios_base.h:1019:3:\
    \ note: \u2018std::right\u2019 declared here\n 1019 |   right(ios_base& __base)\n\
    \      |   ^~~~~\nIn file included from /usr/include/c++/9/cassert:44,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n    \
    \             from /tmp/tmpjm1wkn8c.cpp:2:\n/tmp/tmpjm1wkn8c.cpp:25:17: error:\
    \ \u2018right\u2019 was not declared in this scope; did you mean \u2018std::right\u2019\
    ?\n   25 |   assert(min != right);\n      |                 ^~~~~\nIn file included\
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpjm1wkn8c.cpp:2:\n/usr/include/c++/9/bits/ios_base.h:1019:3: note: \u2018\
    std::right\u2019 declared here\n 1019 |   right(ios_base& __base)\n      |   ^~~~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"AEIOUaeiou\";\n\tstd::sort(word.begin(), word.end(),\
    \ [] (char a, char b) -> bool {\n\t\treturn vowels.find(a) < vowels.find(b);\n\
    \t});\n\tstd::reverse(word.begin(), word.end());\n\treturn word;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbx75bptd.cpp: In lambda function:\n/tmp/tmpbx75bptd.cpp:12:10:\
    \ error: \u2018vowels\u2019 is not captured\n   12 |   return vowels.find(a) <\
    \ vowels.find(b);\n      |          ^~~~~~\n/tmp/tmpbx75bptd.cpp:11:39: note:\
    \ the lambda has no capture-default\n   11 |  std::sort(word.begin(), word.end(),\
    \ [] (char a, char b) -> bool {\n      |                                     \
    \  ^\n/tmp/tmpbx75bptd.cpp:10:14: note: \u2018std::string vowels\u2019 declared\
    \ here\n   10 |  std::string vowels = \"AEIOUaeiou\";\n      |              ^~~~~~\n\
    /tmp/tmpbx75bptd.cpp:12:27: error: \u2018vowels\u2019 is not captured\n   12 |\
    \   return vowels.find(a) < vowels.find(b);\n      |                         \
    \  ^~~~~~\n/tmp/tmpbx75bptd.cpp:11:39: note: the lambda has no capture-default\n\
    \   11 |  std::sort(word.begin(), word.end(), [] (char a, char b) -> bool {\n\
    \      |                                       ^\n/tmp/tmpbx75bptd.cpp:10:14:\
    \ note: \u2018std::string vowels\u2019 declared here\n   10 |  std::string vowels\
    \ = \"AEIOUaeiou\";\n      |              ^~~~~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::stack<char> vowel;\n    for(size_t i = word.size(); i>0; --i)\
    \ {\n        if(word[i] == 'a') vowel.push('a');\n        else if(word[i] == 'e')\
    \ vowel.push('e');\n        else if(word[i] == 'i') vowel.push('i');\n       \
    \ else if(word[i] == 'o') vowel.push('o');\n        else if(word[i] == 'u') vowel.push('u');\n\
    \        else break;\n    }\n    if(vowel.size() == 0) return \"\";\n    std::string\
    \ temp = \"\", temp2 = \"\";\n    for(size_t i = word.size()-1; i>0; --i) {\n\
    \        if(word[i] == 'a') temp += 'a';\n        else if(word[i] == 'e') temp\
    \ += 'e';\n        else if(word[i] == 'i') temp += 'i';\n        else if(word[i]\
    \ == 'o') temp += 'o';\n        else if(word[i] == 'u') temp += 'u';\n       \
    \ else {\n            temp2 += word[i];\n            break;\n        }\n    }\n\
    \    if(temp == temp2) return \"\";\n    else return temp2;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfwigzgc: /tmp/tmpjfwigzgc.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(!word.empty());\n  std::string vowels = {\"a\", \"e\", \"\
    i\", \"o\", \"u\"};\n  std::string vowels_to_check;\n  for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n    // if the i-th letter is a vowel, add that letter to\
    \ vowels_to_check\n    if (vowels.find(word[i]) != std::string::npos) {\n    \
    \  vowels_to_check = vowels_to_check + word[i];\n      continue;\n    }\n    //\
    \ if the i-th letter is not a vowel, check each possible vowel \n    // and find\
    \ the smallest one that is between a consonant and right side of the word.\n \
    \   // If two or more vowels have the same distance, return empty string.\n  \
    \  for (int j = word.length() - 1; j >= 0; j--) {\n      if (j + 1 < word.length()\
    \ && word[j + 1] == word[j]) {\n        continue;\n      }\n      if (j + 1 <\
    \ word.length() && vowels.find(word[j]) == std::string::npos) {\n        break;\n\
    \      }\n      if (vowels_to_check.size() == 0) {\n        vowels_to_check =\
    \ word[j + 1];\n      }\n      // if the distance between consonant and right\
    \ side of the word is the same as the first one,\n      // return an empty string.\n\
    \      if (vowels_to_check == word[j + 1]) {\n        return \"\";\n      }\n\
    \      // if the distance between consonant and right side of the word is less\
    \ than the first one,\n      // store the smallest vowel and add that vowel to\
    \ vowels_to_check\n      else if (std::distance(vowels_to_check.begin(), vowels_to_check.end())\
    \ < std::distance(word[j + 1].begin(), word[j + 1].end())) {\n        vowels_to_check\
    \ = word[j + 1];\n      }\n    }\n  }\n  return vowels_to_check;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe3s8k4z_.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpe3s8k4z_.cpp:11:48: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   11 |   std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n      |\
    \                                                ^\n      |                  \
    \                              |\n      |                                    \
    \            <brace-enclosed initializer list>\n/tmp/tmpe3s8k4z_.cpp:34:27: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019})\n   34 |       if (vowels_to_check\
    \ == word[j + 1]) {\nIn file included from /usr/include/c++/9/regex:62,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n  \
    \               from /tmp/tmpe3s8k4z_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpe3s8k4z_.cpp:34:40:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   34\
    \ |       if (vowels_to_check == word[j + 1]) {\n      |                     \
    \                   ^\nIn file included from /usr/include/c++/9/regex:62,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe3s8k4z_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _C"
  stdout: ''
  timestamp: 1660120387
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    int size = word.size();\n    int left = 0;\n    int right\
    \ = 0;\n    int min;\n    int min = size;\n    \n    //Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    //find any\
    \ vowel met the above condition.\n    for (int i = 0; i < size; i++) {\n     \
    \   if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u'){\n            left++;\n        }\n        else{\n          \
    \  right++;\n        }\n        if(right == left){\n            min = 1;\n   \
    \     }\n        else if(right < left){\n            min = right;\n        }\n\
    \        else{\n            min = left;\n        }\n        if(min == 1){\n  \
    \          break;\n        }\n    }\n    \n    int cons_size = size - min;\n \
    \   std::string s = word;\n    \n    for (int i = 0; i < cons_size; i++) {\n \
    \       std::string tmp;\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u'){\n            tmp = word;\n        }\n      \
    \  else{\n            tmp = word;\n            std::reverse(word.begin(), word.end());\
    \ \n            tmp = tmp + s[i];\n        }\n        \n        int new_size =\
    \ tmp.size(); \n        if (new_size < size && s[i + min] == 'a' || s[i + min]\
    \ == 'e' || s[i + min] == 'i' || s[i + min] == 'o' || s[i + min] == 'u'){\n  \
    \          s = tmp;\n            size = new_size;\n        }\n        else{\n\
    \            break;\n        }\n        \n    }\n    \n    \n    \n    return\
    \ s;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphtjf4_p5.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmphtjf4_p5.cpp:15:9: error: redeclaration of \u2018int min\u2019\n  \
    \ 15 |     int min = size;\n      |         ^~~\n/tmp/tmphtjf4_p5.cpp:14:9: note:\
    \ \u2018int min\u2019 previously declared here\n   14 |     int min;\n      |\
    \         ^~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::cout<<\"Enter a word \"<<std::endl;\n  std::cin>>word;\n  int\
    \ len = word.length();\n  std::string vowels = {\"a\",\"e\",\"i\",\"o\",\"u\"\
    ,\"A\",\"E\",\"I\",\"O\",\"U\"};\n  std::string res = \"\";\n  std::map<int,int>\
    \ m; \n  for(int i=0;i<len;i++){\n    if(m.find(i)==m.end()){\n      m[i] = 0;\n\
    \    }\n    m[i]++;\n  }\n  // print map\n  for(auto it=m.begin();it!=m.end();it++){\n\
    \    std::cout<<it->second<<\"  \";\n  }\n  std::cout<<std::endl;\n  for(auto\
    \ it=m.rbegin();it!=m.rend();it++){\n    if(it->second==3){\n      if(it->first<len-1){\n\
    \        int x = word[it->first];\n        int y = word[it->first+1];\n      \
    \  std::cout<<x<<\" \"<<y<<std::endl;\n        if(vowels.find(x)!=vowels.end()\
    \ && vowels.find(y)!=vowels.end()){\n          res=x+y;\n          return res;\n\
    \        }\n      }\n    }\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5dhkgiy6.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp5dhkgiy6.cpp:13:64: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\u2019 from \u2018<brace-enclosed\
    \ initializer list>\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   13 |   std::string vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"\
    I\",\"O\",\"U\"};\n      |                                                   \
    \             ^\n      |                                                     \
    \           |\n      |                                                       \
    \         <brace-enclosed initializer list>\n/tmp/tmp5dhkgiy6.cpp:33:26: error:\
    \ no match for \u2018operator!=\u2019 (operand types are \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   33 |         if(vowels.find(x)!=vowels.end() && vowels.find(y)!=vowels.end()){\n\
    \      |            ~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                    \
    \   |              |\n      |                       |              std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    \      |                       std::__cxx11::basic_string<char>::size_type {aka\
    \ long unsigned int}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5dhkgiy6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int vowels = 0;\n    for (int i = 0;\
    \ i <= n - 1; i++) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            vowels++;\n     \
    \   }\n    }\n    int cons = 0;\n    for (int i = n - 2; i >= 0; i--) {\n    \
    \    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u') {\n            cons++;\n        }\n    }\n    int diff =\
    \ vowels - cons;\n    int min = abs(diff);\n    if (diff < 0) {\n        min =\
    \ -min;\n    }\n    if (vowels == 0) {\n        return \"\";\n    }\n    for (int\
    \ i = n - 2; i >= 0; i--) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            if (diff < 0) {\n\
    \                min = abs(diff);\n            }\n            diff = abs(diff)\
    \ - 1;\n        }\n    }\n    if (diff >= 0) {\n        min = diff + 1;\n    }\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < min; i++) {\n        ans\
    \ += \"a\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptokscw1b: /tmp/tmptokscw1b.cpp:50: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120389
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int len = word.size();\n  for (int i = len - 1; i >= 0; i--) {\n\
    \    if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u') {\n      return word;\n    }\n  }\n  return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp80a5e8n8: /tmp/tmp80a5e8n8.cpp:20: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n     assert(word == \"abrakadabra\");\n     assert(find_closest_vowel(\"\
    abrakadaabra\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrax\")\
    \ == \"ra\");\n     assert(find_closest_vowel(\"abrakadabray\") == \"ra\");\n\
    \     assert(find_closest_vowel(\"abrakadabraz\") == \"ra\");\n     assert(find_closest_vowel(\"\
    abrakadabrak\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabraka\"\
    ) == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakbh\") == \"ra\");\n\
    \     assert(find_closest_vowel(\"abrakadabrakby\") == \"ra\");\n     assert(find_closest_vowel(\"\
    abrakadabrakcz\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakda\"\
    ) == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdb\") == \"ra\");\n\
    \     assert(find_closest_vowel(\"abrakadabrakdch\") == \"ra\");\n     assert(find_closest_vowel(\"\
    abrakadabrakdby\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdcy\"\
    ) == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdda\") == \"ra\");\n\
    \     assert(find_closest_vowel(\"abrakadabrakddb\") == \"ra\");\n     assert(find_closest_vowel(\"\
    abrakadabrakdchh\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdbzh\"\
    ) == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdchy\") == \"ra\"\
    );\n     assert(find_closest_vowel(\"abrakadabrakdcyz\") == \"ra\");\n     assert(find_closest_vowel(\"\
    abrakadabrakddaz\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdbcz\"\
    ) == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakdchz\") == \"ra\"\
    );\n     assert(find_closest_vowel(\"abrakadabrakdbcy\") == \"ra\");\n     assert(find_closest_vowel(\"\
    abrakadabrakdcyz\") == \"ra\");\n     assert(find_closest_vowel(\"abrakadabrakddazy\"\
    \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx9lf_szr.cpp:53: error: unterminated argument list invoking macro\
    \ \"assert\"\n   53 | }\n      | \nIn file included from /usr/include/c++/9/cassert:44,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx9lf_szr.cpp:2:\n/tmp/tmpx9lf_szr.cpp: In function\
    \ \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpx9lf_szr.cpp:11:13:\
    \ error: \u2018find_closest_vowel\u2019 was not declared in this scope; did you\
    \ mean \u2018get_closest_vowel\u2019?\n   11 |      assert(find_closest_vowel(\"\
    abrakadaabra\") == \"ra\");\n      |             ^~~~~~~~~~~~~~~~~~\n/tmp/tmpx9lf_szr.cpp:36:6:\
    \ error: \u2018assert\u2019 was not declared in this scope\n   36 |      assert(find_closest_vowel(\"\
    abrakadabrakddazy\"\n      |      ^~~~~~\n/tmp/tmpx9lf_szr.cpp:3:1: note: \u2018\
    assert\u2019 is defined in header \u2018<cassert>\u2019; did you forget to \u2018\
    #include <cassert>\u2019?\n    2 | #include<bits/stdc++.h>\n  +++ |+#include <cassert>\n\
    \    3 | // You are given a word. Your task is to find the closest vowel that\
    \ stands between\n/tmp/tmpx9lf_szr.cpp:36:6: error: expected \u2018}\u2019 at\
    \ end of input\n   36 |      assert(find_closest_vowel(\"abrakadabrakddazy\"\n\
    \      |      ^~~~~~\n/tmp/tmpx9lf_szr.cpp:9:49: note: to match this \u2018{\u2019\
    \n    9 | std::string get_closest_vowel(std::string word) {\n      |         \
    \                                        ^\n/tmp/tmpx9lf_szr.cpp:36:6: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n   36 |      assert(find_closest_vowel(\"\
    abrakadabrakddazy\"\n      |      ^~~~~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i;\n    std::string vowels[] = { \"a\", \"e\", \"i\", \"o\"\
    , \"u\" };\n    std::string result=\"\";\n    for(i=word.length(); i>=0; i--){\n\
    \        if (word[i]>=65 && word[i]<=90) result+=vowels[word[i]-65];\n       \
    \ if (word[i]>=97 && word[i]<=122) result+=vowels[word[i]-97];\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::bad_alloc'\n  what():\
    \  std::bad_alloc\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(word.size()>=2);\n  int l = word.length()-1;\n  std::string\
    \ vowels = \"aeiouAEIOU\";\n  int start = std::distance(word.begin(), word.rfind(vowels));\n\
    \  int end = std::distance(word.rfind(vowels), word.end());\n  \n  if(l<1)\n \
    \   return \"\";\n  \n  if(word[l]==vowels[start])\n    return word.substr(start,\
    \ l);\n  \n  if(word[l]==vowels[end])\n    return word.substr(end+1);\n  \n  return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg5a6hfgd.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpg5a6hfgd.cpp:13:61: error: no matching function for call to \u2018\
    distance(std::__cxx11::basic_string<char>::iterator, std::__cxx11::basic_string<char>::size_type)\u2019\
    \n   13 |   int start = std::distance(word.begin(), word.rfind(vowels));\n   \
    \   |                                                             ^\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:66,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpg5a6hfgd.cpp:2:\n/usr/include/c++/9/bits/stl_iterator_base_funcs.h:138:5:\
    \ note: candidate: \u2018template<class _InputIterator> constexpr typename std::iterator_traits<_Iterator>::difference_type\
    \ std::distance(_InputIterator, _InputIterator)\u2019\n  138 |     distance(_InputIterator\
    \ __first, _InputIterator __last)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator_base_funcs.h:138:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpg5a6hfgd.cpp:13:61:\
    \ note:   deduced conflicting types for parameter \u2018_InputIterator\u2019 (\u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019 and\
    \ \u2018long unsigned int\u2019)\n   13 |   int start = std::distance(word.begin(),\
    \ word.rfind(vowels));\n      |                                              \
    \               ^\nIn file included from /usr/include/c++/9/filesystem:37,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmpg5a6hfgd.cpp:2:\n/usr/include/c++/9/bits/fs_path.h:1274:1:\
    \ note: candidate: \u2018std::ptrdiff_t std::distance(std::filesystem::__cxx11::path::iterator,\
    \ std::filesystem::__cxx11::path::iterator)\u2019\n 1274 | distance(filesystem::path::iterator\
    \ __first, filesystem::path::iterator __last)\n      | ^~~~~~~~\n/usr/include/c++/9/bits/fs_path.h:1274:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_st"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ret = \"\";\n    int len = word.length();\n    for\
    \ (int i = len-1; i >= 0; i--) {\n        if (word.at(i) == 'a' || word.at(i)\
    \ == 'e' || word.at(i) == 'i' || word.at(i) == 'o' || word.at(i) == 'u') {\n \
    \           ret = word.substr(0,i) + word.at(i);\n            break;\n       \
    \ }\n    }\n    return ret;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpu7v3sww8: /tmp/tmpu7v3sww8.cpp:22: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120389
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowel_count = find_closest_vowel(word.rbegin(), word.rend());\n\
    \    int consonant_count = find_closest_consonant(word.rbegin(), word.rend());\n\
    \    return consonant_count <= vowel_count ? \"vowel\" : \"consonant\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmples9s0dd.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmples9s0dd.cpp:10:23: error: \u2018find_closest_vowel\u2019 was not declared\
    \ in this scope; did you mean \u2018get_closest_vowel\u2019?\n   10 |     int\
    \ vowel_count = find_closest_vowel(word.rbegin(), word.rend());\n      |     \
    \                  ^~~~~~~~~~~~~~~~~~\n      |                       get_closest_vowel\n\
    /tmp/tmples9s0dd.cpp:11:27: error: \u2018find_closest_consonant\u2019 was not\
    \ declared in this scope\n   11 |     int consonant_count = find_closest_consonant(word.rbegin(),\
    \ word.rend());\n      |                           ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // code goes here\n  assert(word.length() >= 2);\n  bool consonants[26]\
    \ = {0};\n  for(unsigned int i = 0; i < word.length(); i++) {\n    if(!consonants[word[i]\
    \ - 'a']) {\n      consonants[word[i] - 'a'] = true;\n    }\n  }\n  for(unsigned\
    \ int i = 0; i <= word.length(); i++) {\n    if(consonants[i]) {\n      return\
    \ std::string(i, 1);\n    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp4dwf1pir: /tmp/tmp4dwf1pir.cpp:27: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> vowels = { \"aeiouAEIOU\", \"AEIOUaeiou\"\
    \ };\n    for (int i = word.length() - 1; i >= 0; i--) {\n        int j = word.find_last_of(vowels[i]);\n\
    \        if (j >= 0 && j != word.length() - 1) {\n            return word[j +\
    \ 1];\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpylhgae7l.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpylhgae7l.cpp:14:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(j\
    \ + 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   14 |             return word[j + 1];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    std::string vowels;\n    std::string tempWord;\n    int start\
    \ = 0;\n    int end = 0;\n    \n    for(int i = 0; i < word.length(); ++i) {\n\
    \        \n        // Check for vowels\n        if(word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            \n\
    \            vowels = word[i];\n            start = i;\n            \n       \
    \ }\n        \n        // Check for consonants\n        else if(word[i] == 'b'\
    \ || word[i] == 'c' || word[i] == 'd' || word[i] == 'f' || word[i] == 'g' || word[i]\
    \ == 'h' || word[i] == 'j' || word[i] == 'k' || word[i] == 'l' || word[i] == 'm'\
    \ || word[i] == 'n' || word[i] == 'p' || word[i] == 'q' || word[i] == 'r' || word[i]\
    \ == 's' || word[i] == 't' || word[i] == 'v' || word[i] == 'w' || word[i] == 'x'\
    \ || word[i] == 'y' || word[i] == 'z') {\n            \n            end = (i -\
    \ 1);\n            \n        }\n        \n    }\n    \n    // If there are no\
    \ vowels\n    if(vowels.size() <= 0) {\n        \n        // Return empty string\n\
    \        return \"\";\n        \n    }\n    \n    // If there are no consonants\n\
    \    if(end <= 0) {\n        \n        // Return empty string\n        return\
    \ \"\";\n        \n    }\n    \n    // Find the nearest vowel between start and\
    \ end\n    for(int i = start; i < end; i++) {\n        \n        // Store the\
    \ nearest vowel position\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            \n            tempWord\
    \ = word;\n            tempWord.erase(tempWord.begin(), tempWord.begin() + i);\n\
    \            \n            // Return the nearest vowel\n            return tempWord;\n\
    \            \n        }\n        \n        // Store the nearest vowel position\n\
    \        else if(word[i] == 'b' || word[i] == 'c' || word[i] == 'd' || word[i]\
    \ == 'f' || word[i] == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k'\
    \ || word[i] == 'l' || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i]\
    \ == 'q' || word[i] == 'r' || word[i] == 's' || word[i] == 't' || word[i] == 'v'\
    \ || word[i] == 'w' || word[i] == 'x' || word[i] == 'y' || word[i] == 'z') {\n\
    \            \n            tempWord = word;\n            tempWord.erase(tempWord.begin(),\
    \ tempWord.begin() + i);\n            \n\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3r1p7a1i.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp3r1p7a1i.cpp:73:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmp3r1p7a1i.cpp:88:1:\
    \ error: expected \u2018}\u2019 at end of input\n   88 | }\n      | ^\n/tmp/tmp3r1p7a1i.cpp:52:38:\
    \ note: to match this \u2018{\u2019\n   52 |     for(int i = start; i < end; i++)\
    \ {\n      |                                      ^\n/tmp/tmp3r1p7a1i.cpp:88:1:\
    \ error: expected \u2018}\u2019 at end of input\n   88 | }\n      | ^\n/tmp/tmp3r1p7a1i.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmp3r1p7a1i.cpp:88:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   88 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if(word.length()<3) return word;\n    std::string vowel{\"aeiou\"\
    }; \n    std::string vowel_rest{\"AEIOU\"}; \n    std::string result; \n    for(size_t\
    \ i=0; i<word.length()-2; i++) { \n        size_t start; \n        size_t end\
    \ = word.length()-1; \n        for(; end >= i; end--) { \n            std::string\
    \ str = word.substr(start,end); \n            if(str.find(vowel)!=std::string::npos)\
    \ break; \n        }\n        for(; start < end; start++) { \n            std::string\
    \ str = word.substr(start,end); \n            if(str.find(vowel_rest)!=std::string::npos)\
    \ break; \n        } \n        if(start < end) { \n            std::string str\
    \ = word.substr(start,end); \n            if(str.find(vowel)!=std::string::npos)\
    \ \n                result+=vowel; \n            if(str.find(vowel_rest)!=std::string::npos)\
    \ \n                result+=vowel_rest; \n        } \n    }\n    return result\
    \ ; \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 140728461271728) > this->size() (which\
    \ is 6)\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels[] = {\n        \"a\", \"e\", \"i\", \"o\", \"\
    u\", \"A\", \"E\", \"I\", \"O\", \"U\",\n    };\n    std::sort(vowels.begin(),\
    \ vowels.end());\n    // Find the word length. \n    int word_length = word.length();\n\
    \    // If the word length is less than 2, return an empty string\n    if (word_length\
    \ < 2) {\n        return \"\";\n    }\n    // If word's first and last letters\
    \ are vowels, return an empty string\n    if (vowels.find(word.at(0) + word.at(word_length\
    \ - 1)) == std::string::npos) {\n        return \"\";\n    }\n    // If the word's\
    \ first letter is not a vowel, return an empty string\n    if (vowels.find(word.at(0))\
    \ == std::string::npos) {\n        return \"\";\n    }\n    // If the word's last\
    \ letter is not a vowel, return an empty string\n    if (vowels.find(word.at(word_length\
    \ - 1)) == std::string::npos) {\n        return \"\";\n    }\n    int index =\
    \ word_length - 1;\n    // If the word length is odd, return an empty string\n\
    \    if (word_length % 2 != 0) {\n        return \"\";\n    }\n    // If the word's\
    \ last letter is consonant, return the previous vowel\n    if (vowels.find(word.at(index\
    \ - 1)) == std::string::npos) {\n        return \"\";\n    }\n    // If the word's\
    \ first and last letters are consonants, return the next vowel\n    if (vowels.find(word.at(index)\
    \ + word.at(word_length - 1)) == std::string::npos) {\n        return \"\";\n\
    \    }\n    // If the word's first and last letters are consonants, return the\
    \ next vowel\n    return word.at(index - 1) + word.at(index);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7iii4kvx.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp7iii4kvx.cpp:13:22: error: request for member \u2018begin\u2019 in\
    \ \u2018vowels\u2019, which is of non-class type \u2018std::string [10]\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char> [10]\u2019}\n   13 |     std::sort(vowels.begin(),\
    \ vowels.end());\n      |                      ^~~~~\n/tmp/tmp7iii4kvx.cpp:13:38:\
    \ error: request for member \u2018end\u2019 in \u2018vowels\u2019, which is of\
    \ non-class type \u2018std::string [10]\u2019 {aka \u2018std::__cxx11::basic_string<char>\
    \ [10]\u2019}\n   13 |     std::sort(vowels.begin(), vowels.end());\n      | \
    \                                     ^~~\n/tmp/tmp7iii4kvx.cpp:21:16: error:\
    \ request for member \u2018find\u2019 in \u2018vowels\u2019, which is of non-class\
    \ type \u2018std::string [10]\u2019 {aka \u2018std::__cxx11::basic_string<char>\
    \ [10]\u2019}\n   21 |     if (vowels.find(word.at(0) + word.at(word_length -\
    \ 1)) == std::string::npos) {\n      |                ^~~~\n/tmp/tmp7iii4kvx.cpp:25:16:\
    \ error: request for member \u2018find\u2019 in \u2018vowels\u2019, which is of\
    \ non-class type \u2018std::string [10]\u2019 {aka \u2018std::__cxx11::basic_string<char>\
    \ [10]\u2019}\n   25 |     if (vowels.find(word.at(0)) == std::string::npos) {\n\
    \      |                ^~~~\n/tmp/tmp7iii4kvx.cpp:29:16: error: request for member\
    \ \u2018find\u2019 in \u2018vowels\u2019, which is of non-class type \u2018std::string\
    \ [10]\u2019 {aka \u2018std::__cxx11::basic_string<char> [10]\u2019}\n   29 |\
    \     if (vowels.find(word.at(word_length - 1)) == std::string::npos) {\n    \
    \  |                ^~~~\n/tmp/tmp7iii4kvx.cpp:38:16: error: request for member\
    \ \u2018find\u2019 in \u2018vowels\u2019, which is of non-class type \u2018std::string\
    \ [10]\u2019 {aka \u2018std::__cxx11::basic_string<char> [10]\u2019}\n   38 |\
    \     if (vowels.find(word.at(index - 1)) == std::string::npos) {\n      |   \
    \             ^~~~\n/tmp/tmp7iii4kvx.cpp:42:16: error: request for member \u2018\
    find\u2019 in \u2018vowels\u2019, which is of non-class type \u2018std::string\
    \ [10]\u2019 {aka \u2018std::__cxx11::basic_string<char> [10]\u2019}\n   42 |\
    \     if (vowels.find(word.at(index) + word.at(word_length - 1)) == std::stri"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> vowels = {\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"};\n    std::string ret = word;\n    int n = word.size();\n    // If there's\
    \ only one vowel, just return word\n    if (vowels.empty())\n        return ret;\n\
    \    int i = 0;\n    while (i < n) {\n        auto curr = word.find(vowels[i],\
    \ i);\n        if (curr != std::string::npos)\n            i = curr + 1;\n   \
    \     else \n            i = n;\n    }\n    return ret;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0uwtqlbt: /tmp/tmp0uwtqlbt.cpp:28: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    \n    for(int i=word.length()-1;i>=0;i--){\n\
    \        if(word[i]=='a' || word[i]=='e' || word[i]=='i'|| word[i]=='o' || word[i]=='u'){\n\
    \            return word;\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpnr75ig_n: /tmp/tmpnr75ig_n.cpp:21: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n}\nint main() {\n    auto candidate = get_closest_vowel;\n  \
    \  assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120389
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    // Find index of first consonant\
    \ from the right\n    int idx = len-1;\n    while(idx >= 0){\n        if(word[idx]\
    \ >= 'a' && word[idx] <= 'z'){\n            break;\n        }\n        idx--;\n\
    \    }\n    // Find index of second consonant from the right\n    idx++;\n   \
    \ while(idx < len){\n        if(word[idx] >= 'a' && word[idx] <= 'z'){\n     \
    \       break;\n        }\n        idx++;\n    }\n    std::string vowels = \"\"\
    ;\n    // Check if both index is different\n    if(idx != len-1){\n        vowels.insert(vowels.end(),word[idx],word[idx+1]);\n\
    \    }\n    return vowels;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7j2n1yr3: /tmp/tmp7j2n1yr3.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    // Your code goes here\n    std::string temp;\n    for (int\
    \ i = 0; i < word.length(); i++) {\n        if (word[i] >= 'a' && word[i] <= 'z')\
    \ {\n            temp += word[i];\n        }\n        else if (word[i] >= 'A'\
    \ && word[i] <= 'Z') {\n            temp += word[i];\n        }\n    }\n    return\
    \ temp;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9ai0avpd: /tmp/tmp9ai0avpd.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int vowel_index;\n  \
    \  for (int i = 0; i < word.size() - 1; i++) {\n        for (int j = i; j < word.size()\
    \ - 1; j++) {\n            if (word[i] == 'a' && word[i + 1] == 'e' &&\n     \
    \           word[i + 2] == 'i' && word[i + 3] == 'o' &&\n                word[i\
    \ + 4] == 'u') {\n                vowel_index = i;\n                break;\n \
    \           } else if (word[i] == 'e' && word[i + 1] == 'i' &&\n             \
    \   word[i + 2] == 'o' && word[i + 3] == 'u' &&\n                word[i + 4] ==\
    \ 'u') {\n                vowel_index = i;\n                break;\n         \
    \   } else if (word[i] == 'i' && word[i + 1] == 'o' &&\n                word[i\
    \ + 2] == 'u' && word[i + 3] == 'u') {\n                vowel_index = i;\n   \
    \             break;\n            } else if (word[i] == 'o' && word[i + 1] ==\
    \ 'u' &&\n                word[i + 2] == 'u') {\n                vowel_index =\
    \ i;\n                break;\n            } else if (word[i] == 'u' && word[i\
    \ + 1] == 'u') {\n                vowel_index = i;\n                break;\n \
    \           }\n        }\n    }\n    return vowels.substr(vowel_index + 1, vowels.size());\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 21980) > this->size() (which is 10)\n"
  stdout: ''
  timestamp: 1660120389
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    // Write your code here\n    for(int i=word.size()-1;i>=0;i--){\n\
    \        if(word[i]!='a' && word[i]!='e' && word[i]!='i' && word[i]!='o' && word[i]!='u'){\n\
    \            return \"\";\n        }\n        if(word[i]=='a' || word[i]=='e'\
    \ || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n            if(i<word.size()-3){\n\
    \                if(word[i+1]!='a' && word[i+1]!='e' && word[i+1]!='i' && word[i+1]!='o'\
    \ && word[i+1]!='u'){\n                    return \"\";\n                }\n \
    \               if(word[i+2]!='a' && word[i+2]!='e' && word[i+2]!='i' && word[i+2]!='o'\
    \ && word[i+2]!='u'){\n                    return \"\";\n                }\n \
    \           }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpn_hw5g7m: /tmp/tmpn_hw5g7m.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    std::string s = word;\n    \n    int vowel_counter = 0;\n\
    \    \n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n           \
    \ vowel_counter++;\n        }\n    }\n    \n    int consonant_counter = 0;\n \
    \   \n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n           \
    \ consonant_counter++;\n        }\n        else if (s[i] != 'a' && s[i] != 'e'\
    \ && s[i] != 'i' && s[i] != 'o' && s[i] != 'u') {\n            consonant_counter++;\n\
    \        }\n    }\n    \n    for (int i = s.length() - 1; i >= 0; i--) {\n   \
    \     if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] ==\
    \ 'u') {\n            if (vowel_counter < consonant_counter) {\n             \
    \   return s.substr(0, i + 1);\n            }\n        }\n        else if (s[i]\
    \ != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' && s[i] != 'u') {\n    \
    \        if (vowel_counter > consonant_counter) {\n                return s.substr(0,\
    \ i + 1);\n            }\n        }\n    }\n    \n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprw16eizf: /tmp/tmprw16eizf.cpp:49: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.size() >= 2);\n    std::string vowels = \"aeiou\";\n\
    \    std::string res;\n    int left = word.size() - 1;\n    int right = word.size()\
    \ - 2;\n    int cons = 0;\n    while (left >= 0 && right >= 0) {\n        if (word[left]\
    \ == word[right]) {\n            res[cons] = word[left];\n            cons +=\
    \ 1;\n            left -= 1;\n            right -= 1;\n        } else if (word[left]\
    \ == vowels[0] && word[right] == vowels[0]) {\n            res[cons] = word[left];\n\
    \            cons += 1;\n            left -= 1;\n            right -= 1;\n   \
    \     } else if (word[left] == vowels[vowels.size() - 1]) {\n            res[cons]\
    \ = word[left];\n            cons += 1;\n            left -= 1;\n        } else\
    \ if (word[right] == vowels[0] && word[right] == vowels[0]) {\n            res[cons]\
    \ = word[right];\n            cons += 1;\n            right -= 1;\n        } else\
    \ if (word[left] == vowels[0] && word[right] == vowels[vowels.size() - 1]) {\n\
    \            res[cons] = word[right];\n            cons += 1;\n            left\
    \ -= 1;\n        } else {\n            left -= 1;\n            right -= 1;\n \
    \       }\n    }\n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpft6axgmd: /tmp/tmpft6axgmd.cpp:48: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n\
    \    std::vector<bool> isvowel;\n    for(int i=0;i<n;i++) {\n        int j = i-1;\n\
    \        isvowel[i] = vowels.find(word[i]) != std::string::npos;\n        if(isvowel[i])\
    \ {\n            while(j>0 && !isvowel[j]) {\n                j--;\n         \
    \   }\n            while(j<n && !isvowel[j]) {\n                j++;\n       \
    \     }\n            isvowel[j] = isvowel[i];\n        }\n    }\n    std::string\
    \ result;\n    int cnt = 0;\n    for(int i=n-2;i>=0;i--) {\n        if(isvowel[i])\
    \ {\n            cnt++;\n        }\n        if(cnt==2) {\n            result =\
    \ vowels[i];\n            break;\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    auto vowels = \"AEIOUaeiouAEIOU\";\n    int i = 0;\n    int j =\
    \ 0;\n    int vowelCount = 0;\n    int consonantCount = word.length()-1;\n\n \
    \   while(i < word.length() && j < word.length()) {\n        if(vowels.find(word[i])\
    \ != std::string::npos)\n            vowelCount++;\n        if(vowels.find(word[j])\
    \ != std::string::npos)\n            vowelCount++;\n        i++;\n        j++;\n\
    \    }\n    if(vowelCount > consonantCount) {\n        return \"\";\n    }\n \
    \   auto lastVowelIndex = vowels.find(\"AEIOU\");\n    return word.substr(lastVowelIndex+1,\
    \ word.length());\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk6_mixop.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpk6_mixop.cpp:17:19: error: request for member \u2018find\u2019 in \u2018\
    vowels\u2019, which is of non-class type \u2018const char*\u2019\n   17 |    \
    \     if(vowels.find(word[i]) != std::string::npos)\n      |                 \
    \  ^~~~\n/tmp/tmpk6_mixop.cpp:19:19: error: request for member \u2018find\u2019\
    \ in \u2018vowels\u2019, which is of non-class type \u2018const char*\u2019\n\
    \   19 |         if(vowels.find(word[j]) != std::string::npos)\n      |      \
    \             ^~~~\n/tmp/tmpk6_mixop.cpp:27:34: error: request for member \u2018\
    find\u2019 in \u2018vowels\u2019, which is of non-class type \u2018const char*\u2019\
    \n   27 |     auto lastVowelIndex = vowels.find(\"AEIOU\");\n      |         \
    \                         ^~~~\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> v;\n    for (auto &c: word) {\n      \
    \  // if the character is between 'a' and 'e' then\n        // append it to 'v'\
    \ vector\n        if (c>='a' && c<='e') {\n            v.push_back(c);\n     \
    \   }\n        // if the character is between 'i' and 'o' then\n        // append\
    \ it to 'v' vector\n        else if (c>='i' && c<='o') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'u' and 'u' then\n        //\
    \ append it to 'v' vector\n        else if (c>='u' && c<='u') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'A' and 'E' then\n        //\
    \ append it to 'v' vector\n        else if (c>='A' && c<='E') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'I' and 'O' then\n        //\
    \ append it to 'v' vector\n        else if (c>='I' && c<='O') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'U' and 'U' then\n        //\
    \ append it to 'v' vector\n        else if (c>='U' && c<='U') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between '0' and '9' then\n        //\
    \ append it to 'v' vector\n        else if (c>='0' && c<='9') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'a' and 'i' then\n        //\
    \ append it to 'v' vector\n        else if (c>='a' && c<='i') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'A' and 'I' then\n        //\
    \ append it to 'v' vector\n        else if (c>='A' && c<='I') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between '0' and '9' then\n        //\
    \ append it to 'v' vector\n        else if (c>='0' && c<='9') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'z' and 'a' then\n        //\
    \ append it to 'v' vector\n        else if (c>='z' && c<='a') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between 'Z' and 'A' then\n        //\
    \ append it to 'v' vector\n        else if (c>='Z' && c<='A') {\n            v.push_back(c);\n\
    \        }\n        // if the character is between '0' and '9' then\n        //\
    \ append it to 'v' vector\n        else if (c>='0' && c<='9') {\n            v.push_back\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp34swr9w4.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp34swr9w4.cpp:15:26: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   15\
    \ |             v.push_back(c);\n      |                          ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp34swr9w4.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n\
    /tmp/tmp34swr9w4.cpp:20:26: error: no match"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if (word.empty()) return \"\";\n    \n    for(int i = 1; i < word.length();\
    \ i++) {\n        if(word[i] == word[word.length() - i])\n            return word[i];\n\
    \    }\n    \n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5lm2ojcg.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp5lm2ojcg.cpp:14:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   14 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = {\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"y\"}; // vowels are vowels only\n    int counter = 0;\
    \ // counter for current vowel index\n    \n    for (int i=word.length()-1; i>0;\
    \ i--) {\n        counter = 0; // reset counter for every vowel searched\n   \
    \     // check from right to left\n        for (int j=word.length()-1; j>i; j--)\
    \ {\n            // check for consonants\n            if (word[j] != word[i])\
    \ { // check for consonants\n                counter++; // increment counter for\
    \ current consonant searched\n                break;\n            }\n        }\n\
    \        // check if we found vowels\n        if (counter >= vowels.size()){\n\
    \            return vowels.at(counter);\n        }\n    }\n    return \"\"; //\
    \ return empty string if there are no vowels\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz0c62_uq.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpz0c62_uq.cpp:11:55: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"y\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019\
    \ to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   11 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    }; // vowels are vowels only\n      |                                        \
    \               ^\n      |                                                   \
    \    |\n      |                                                       <brace-enclosed\
    \ initializer list>\n/tmp/tmpz0c62_uq.cpp:26:29: error: could not convert \u2018\
    vowels.std::__cxx11::basic_string<char>::at(((std::__cxx11::basic_string<char>::size_type)counter))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   26 |             return vowels.at(counter);\n      |                   \
    \ ~~~~~~~~~^~~~~~~~~\n      |                             |\n      |         \
    \                    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint vowelIndex=-1;\n\tstd::string closest=\"\";\n\tfor (int i= word.size()-1;\
    \ i>=0; i--){\n\t\tif (word.at(i)=='a' || word.at(i)=='e' || word.at(i)=='i' ||\
    \ word.at(i)=='o' || word.at(i)=='u'){\n\t\t\tvowelIndex=i;\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\tif (vowelIndex == -1)\n\t\treturn \"\";\n\tint closestRight = word.size()\
    \ -1 ;\n\tint closestLeft = 0;\n\twhile (closestRight >= 0 && closestLeft <= closestRight){\n\
    \t\tint closestRightIndex = word.size() - 1;\n\t\tint closestLeftIndex = -1;\n\
    \t\twhile (closestRightIndex >= 0 && closestLeftIndex <= closestRightIndex){\n\
    \t\t\tif (word.at(closestLeftIndex) >= 'a' && word.at(closestLeftIndex) <= 'z'){\n\
    \t\t\t\tif (word.at(closestLeftIndex) == word.at(closestRightIndex)){\n\t\t\t\t\
    \tclosestRight =closestRightIndex;\n\t\t\t\t\tclosestLeftIndex++;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t\telse if (word.at(closestLeftIndex) >= 'A' && word.at(closestLeftIndex)\
    \ <= 'Z'){\n\t\t\t\tif (word.at(closestLeftIndex) == word.at(closestRightIndex)){\n\
    \t\t\t\t\tclosestRight =closestRightIndex;\n\t\t\t\t\tclosestLeftIndex++;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tclosestRight =closestRightIndex;\n\
    \t\t\t\tclosestLeftIndex++;\n\t\t\t}\n\t\t}\n\t}\n\tif (closestRight < closestLeft)\n\
    \t\treturn \"\";\n\telse\n\t{\n\t\twhile (closestRight < closestLeft){\n\t\t\t\
    closest+=word.at(closestRight++);\n\t\t}\n\t\treturn closest;\n\t}\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::at: __n (which is 18446744073709551615) >= this->size() (which\
    \ is 6)\n"
  stdout: ''
  timestamp: 1660120388
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    std::string res = \"\";\n    \n \
    \   for(int i = len-1; i > 0; i--) {\n        \n        for(int j = len-1; j >\
    \ 0; j--) {\n            \n            if(word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n                if(j\
    \ != len-1){\n                    res += word[j];\n                    if(j !=\
    \ len-1){\n                        res += word[j+1];\n                    }\n\
    \                }\n            }\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkd3fo6ft: /tmp/tmpkd3fo6ft.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120388
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    bool found = word.size()\
    \ > 0 && word[0] == vowels.at(0) && word[word.size() - 1] == vowels.at(word.size()\
    \ - 1);\n\n    if (!found) {\n        return \"\";\n    }\n    for (int i = 1;\
    \ i < word.size() - 1; i++) {\n        if (word[i] == vowels.at(i)) {\n      \
    \      return word[i - 1];\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkcfim3zh.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpkcfim3zh.cpp:18:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(i\
    \ - 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   18 |             return word[i - 1];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660120387
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    std::string vowels[3] = {\"a\", \"\
    e\", \"i\", \"o\", \"u\"};\n    int lenght = word.size();\n    int count = 0;\n\
    \    bool flag = false;\n    for (int i = 0; i < lenght; i++) {\n        if (word[lenght\
    \ - i - 1] >= 'a' && word[lenght - i - 1] <= 'z') {\n            flag = true;\n\
    \        }\n        if (flag) {\n            count = i;\n            break;\n\
    \        }\n    }\n    for (int j = count; j <= lenght - 1; j++) {\n        if\
    \ (word[j] > 'z' || word[j] < 'a') {\n            flag = false;\n        }\n \
    \       if (flag) {\n            count = 0;\n            break;\n        }\n \
    \   }\n    for (int k = count; k <= lenght; k++) {\n        if (word[k] >= 'a'\
    \ && word[k] <= 'z') {\n            return vowels[k];\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9dc07iy3.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp9dc07iy3.cpp:11:53: error: too many initializers for \u2018std::string\
    \ [3]\u2019 {aka \u2018std::__cxx11::basic_string<char> [3]\u2019}\n   11 |  \
    \   std::string vowels[3] = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n      |    \
    \                                                 ^\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::map<char,int> vowels;\n    // Initialize map with vowels and\
    \ increment count of them\n    for(char i ='a'; i<= 'z'; i++){\n        vowels[i]\
    \ = 1;\n    }\n    for(char i ='A'; i<= 'Z'; i++){\n        vowels[i] = 1;\n \
    \   }\n    // Iterate from right side of the string\n    for(int i = word.size()-1;\
    \ i>=0; i--){\n        if(vowels[word[i]]==1){\n            // Found vowel, update\
    \ it's count by 1\n            vowels[word[i]]+=1;\n        } else {\n       \
    \     // Didn't find vowel, return empty string\n            std::map<char,int>::iterator\
    \ it;\n            it=vowels.find(word[i]);\n            if (it == vowels.end()){\n\
    \                return \"\";\n            }\n            // Found vowel, update\
    \ it's count by 1\n            vowels[word[i]]+=1;\n        }\n    }\n    // Iterate\
    \ through map to find largest vowel\n    char largest=-1;\n    for(std::map<char,int>::iterator\
    \ it = vowels.begin(); it!=vowels.end(); it++){\n        if(it->second >= largest){\n\
    \            largest = it->second;\n        }\n    }\n    std::string ans=\"\"\
    ;\n    // Iterate through the map and add only those values that are greater than\
    \ or equal to 2\n    // to answer\n    for(std::map<char,int>::iterator it = vowels.begin();\
    \ it!=vowels.end(); it++){\n        if(it->second >= 2){\n            ans+= it->first;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7cep1vkc: /tmp/tmp7cep1vkc.cpp:53: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    char ch = 'a';\n    std::string vowels = \"\";\n    int ln = word.size();\n\
    \    // find the vowels before the beginning of word\n    for (int i = 0; i <\
    \ ln; i++) {\n        ch = word[i];\n        if (ch == 'a' || ch == 'e' || ch\
    \ == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch\
    \ == 'O' || ch == 'U') {\n            vowels = vowels + ch;\n        }\n    }\n\
    \    // find the vowels after the end of word\n    for (int i = ln; i < word.size();\
    \ i++) {\n        ch = word[i];\n        if (ch == 'a' || ch == 'e' || ch == 'i'\
    \ || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O'\
    \ || ch == 'U') {\n            vowels = vowels + ch;\n        }\n    }\n    //\
    \ return empty string if we didn't find any vowels\n    if (vowels == \"\") {\n\
    \        return \"\";\n    }\n    // find the vowels between two consonants from\
    \ right side\n    for (int i = word.size()-2; i >= 0; i--) {\n        ch = word[i];\n\
    \        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||\
    \ ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n         \
    \   vowels = vowels + ch;\n        }\n    }\n    return vowels;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgugnchbw: /tmp/tmpgugnchbw.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(word.size() > 1);\n  int vowels[26] = {\n    a,\n    e,\n\
    \    i,\n    o,\n    u\n  };\n  for (int i = 0; i < word.size() - 1; i++) {\n\
    \    if (word[i] == word[i+1] && word[i] != ' ') {\n      i += 2;\n      if (word[i]\
    \ >= 'a' && word[i] <= 'z') {\n        return word[i];\n      }\n      else if\
    \ (word[i] == ' ') {\n        return \"\";\n      }\n    }\n  }\n  return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps0u0le6z.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmps0u0le6z.cpp:12:5: error: \u2018a\u2019 was not declared in this scope\n\
    \   12 |     a,\n      |     ^\n/tmp/tmps0u0le6z.cpp:13:5: error: \u2018e\u2019\
    \ was not declared in this scope\n   13 |     e,\n      |     ^\n/tmp/tmps0u0le6z.cpp:14:5:\
    \ error: \u2018i\u2019 was not declared in this scope\n   14 |     i,\n      |\
    \     ^\n/tmp/tmps0u0le6z.cpp:15:5: error: \u2018o\u2019 was not declared in this\
    \ scope\n   15 |     o,\n      |     ^\n/tmp/tmps0u0le6z.cpp:16:5: error: \u2018\
    u\u2019 was not declared in this scope\n   16 |     u\n      |     ^\n/tmp/tmps0u0le6z.cpp:22:22:\
    \ error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   22 |         return word[i];\n      |                      ^\n      |  \
    \                    |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    std::string temp(word);\n    temp\
    \ = temp[::-1];\n    std::string temp1;\n    for (int i = 0; i < temp.size() -\
    \ 1; i++)\n    {\n        if (temp[i] == 'a' || temp[i] == 'e' || temp[i] == 'i'\
    \ || temp[i] == 'o' || temp[i] == 'u')\n        {\n            temp1 += temp[i];\n\
    \        }\n    }\n    temp = temp1[::-1];\n    std::string temp2 = temp;\n  \
    \  for (int i = 0; i < temp2.size(); i++)\n    {\n        if (temp2[i] == 'a'\
    \ || temp2[i] == 'e' || temp2[i] == 'i' || temp2[i] == 'o' || temp2[i] == 'u')\n\
    \        {\n            temp2 += temp2[i];\n        }\n    }\n    temp = temp2;\n\
    \    return temp;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpji1mau8e.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpji1mau8e.cpp:12:19: error: expected id-expression before \u2018-\u2019\
    \ token\n   12 |     temp = temp[::-1];\n      |                   ^\n/tmp/tmpji1mau8e.cpp:21:20:\
    \ error: expected id-expression before \u2018-\u2019 token\n   21 |     temp =\
    \ temp1[::-1];\n      |                    ^\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.size() > 0);\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowel_start_pos = \"\";\n    std::string vowel_end_pos = \"\
    \";\n    std::string vowel_center = \"\";\n    for (int i = 0; i != word.size();\
    \ i++) {\n        if (word[i] == vowels[vowels.size() / 2]) {\n            vowel_start_pos\
    \ = word[i];\n        } else {\n            if (i == word.size() - 1 || vowels[vowels.size()\
    \ / 2] != word[i + 1]) {\n                break;\n            }\n        }\n \
    \   }\n    for (int i = word.size() - 1; i != 0; i--) {\n        if (word[i] ==\
    \ vowels[vowels.size() / 2]) {\n            vowel_end_pos = word[i];\n       \
    \ } else {\n            if (i == 0 || vowels[vowels.size() / 2] != word[i - 1])\
    \ {\n                break;\n            }\n        }\n    }\n    std::string\
    \ result = \"\";\n    if (vowel_start_pos.size() != 0 && vowel_end_pos.size()\
    \ != 0) {\n        for (int i = 0; i != word.size(); i++) {\n            if (word[i]\
    \ == vowel_start_pos || (i == word.size() - 1 && word[i] == vowel_end_pos)) {\n\
    \                result += word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc6iaeks8.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpc6iaeks8.cpp:36:25: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   36 |             if (word[i] == vowel_start_pos || (i == word.size() -\
    \ 1 && word[i] == vowel_end_pos)) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpc6iaeks8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpc6iaeks8.cpp:36:28:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   36 |             if (word[i] == vowel_start_pos ||\
    \ (i == word.size() - 1 && word[i] == vowel_end_pos)) {\n      |             \
    \               ^~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpc6iaeks8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpc6iaeks8.cpp:36:28: note:   mismat"
  stdout: ''
  timestamp: 1660120390
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n \n assert(word.length()<=150);\n \n int len = word.length();\n \n\
    \ int i=0, l=0, h=len-1;\n char first,second;\n \n while(i<h) {\n    first = word[i];\n\
    \    second = word[i+1];\n    if(isalpha(first) && isalpha(second) && first <=\
    \ 'z' && second <= 'z') {\n        if('a'<=first && first<='z') {\n          \
    \  if('a'<=second && second<='z') {\n                return word.substr(l,h);\n\
    \            }\n        }\n        if('e'<=first && first<='z') {\n          \
    \  if('e'<=second && second<='z') {\n                return word.substr(l,h);\n\
    \            }\n        }\n        if('i'<=first && first<='z') {\n          \
    \  if('i'<=second && second<='z') {\n                return word.substr(l,h);\n\
    \            }\n        }\n        if('o'<=first && first<='z') {\n          \
    \  if('o'<=second && second<='z') {\n                return word.substr(l,h);\n\
    \            }\n        }\n        if('u'<=first && first<='z') {\n          \
    \  if('u'<=second && second<='z') {\n                return word.substr(l,h);\n\
    \            }\n        }\n    }\n    i++;\n }\n return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzd9nppv2: /tmp/tmpzd9nppv2.cpp:54: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint left_con = -1;\n\tint right_con = -1;\n\tfor (int i = word.length()\
    \ - 1; i >= 0; i--) {\n\t\tint lc = word[i] == 'a' ? 0 : (word[i] == 'e' ? 1 :\
    \ 2);\n\t\tint rc = word[i] == 'o' ? 0 : (word[i] == 'i' ? 1 : 2);\n\t\tint wc\
    \ = word[i] == 'u' ? 0 : (word[i] == 'i' ? 1 : 2);\n\t\tint cc = word[i] == 'e'\
    \ ? 0 : (word[i] == 'a' ? 1 : 2);\n\t\tint cg = word[i] == 'o' ? 0 : (word[i]\
    \ == 'u' ? 1 : 2);\n\t\tif (lc > left_con) {\n\t\t\tleft_con = lc;\n\t\t}\n\t\t\
    if (rc > right_con) {\n\t\t\tright_con = rc;\n\t\t}\n\t\tif (wc > left_con ||\
    \ wc < right_con || cc > left_con || cc < right_con || cg > left_con || cg < right_con)\
    \ {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\treturn word[left_con - 1];\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl41c0f2z.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpl41c0f2z.cpp:28:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(left_con\
    \ - 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   28 |  return word[left_con - 1];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n        std::map<char, int> vowel_map;\n        std::map<char, int>\
    \ consonant_map;\n        for (int i = 0; i < word.length(); ++i) {\n        \
    \        char current_char = word[i];\n                if (vowel_map[current_char])\
    \ {\n                        vowel_map[current_char]++;\n                } else\
    \ {\n                        consonant_map[current_char]++;\n                }\n\
    \        }\n        char closest_vowel = 'a';\n        char closest_consonant\
    \ = 'a';\n        for (int i = word.size() - 1; i >= 0; --i) {\n             \
    \   char current_char = word[i];\n                if (vowel_map[current_char])\
    \ {\n                        if (vowel_map[current_char] < consonant_map[closest_consonant])\
    \ {\n                                closest_consonant = current_char;\n     \
    \                           closest_vowel = current_char;\n                  \
    \              vowel_map[current_char] -= 1;\n                        }\n    \
    \            } else {\n                        vowel_map[current_char] -= 1;\n\
    \                }\n        }\n        return closest_vowel;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsrv4g_fd.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpsrv4g_fd.cpp:34:16: error: could not convert \u2018closest_vowel\u2019\
    \ from \u2018char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   34 |         return closest_vowel;\n      |                ^~~~~~~~~~~~~\n\
    \      |                |\n      |                char\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    std::string vowel{\"aeiou\"}; // vowel\
    \ string must be in lower case\n    std::string ret{\"\"};\n    for (size_t i\
    \ = 1; i < word.length(); i++) {\n        for (auto &e : vowel) {\n          \
    \  int loc = word.find(e, i); // find the vowel index\n            if (loc !=\
    \ -1 && loc < i) {\n                ret += word[loc + 1]; // if found append to\
    \ ret\n                i = loc; // move to the right position to search next one\n\
    \                break;\n            }\n        }\n    }\n    return ret;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgoqdbxhz: /tmp/tmpgoqdbxhz.cpp:27: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here.\n    std::vector<int> freq;\n    for (auto\
    \ &it : word)\n        freq.push_back(std::tolower(it) - 'a');\n    int min =\
    \ std::distance(freq.rbegin(), std::upper_bound(freq.rbegin(), freq.rend(), freq.back()));\n\
    \    if (min == 0)\n        return \"\";\n    int pos = freq.back() - min;\n \
    \   char ans = word[pos + min];\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj34cm520.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpj34cm520.cpp:19:12: error: could not convert \u2018ans\u2019 from \u2018\
    char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   19 |     return ans;\n      |            ^~~\n      |            |\n   \
    \   |            char\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Complete this function\n    \n    // assert(word.size() == 5);\n\
    \    std::string vowels = \"aeiouAEIOU\";\n    \n    for (int i = 0; i <= word.size()\
    \ - 2; i++) {\n        std::string vowel = word.substr(i);\n        if (vowels.find(vowel)\
    \ != std::string::npos) {\n            return word;\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7bsrg7n7: /tmp/tmp7bsrg7n7.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // code here\n    std::vector<std::string> vowels = {\"a\", \"\
    e\", \"i\", \"o\", \"u\", \"y\" };\n    std::string s;\n    for(auto itr = vowels.begin();\
    \ itr != vowels.end(); ++itr) {\n        if(word.end() != word.rfind(*itr)) {\n\
    \            int start = word.rfind(*itr) + 1;\n            int end = word.find(*itr);\n\
    \            s = word.substr(start, end - start);\n            break;\n      \
    \  }\n    }\n    if(s.empty())\n        std::cout << \"No vowel found\\n\";\n\
    \    return s;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7em93bxu.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp7em93bxu.cpp:14:23: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019}\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   14 |         if(word.end() != word.rfind(*itr)) {\n\
    \      |            ~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~\n      |                  \
    \  |               |\n      |                    |               std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\n      |                    std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp7em93bxu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp7em93bxu.cpp:14:41: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorR, _Container>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   14 |         if(word.end() != word.rfind(*itr)) {\n\
    \      |                                         ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cm"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// Write your code here\n\tstd::string vowels = \"aeiou\";\n\tstd::map<char,int>\
    \ m;\n\tfor(int i=0;i<word.size();i++) {\n\t\tchar c = word[i];\n\t\tif((i>0&&i<word.length()-1)&&(i!=0&&i!=word.length()-1))\
    \ {\n\t\t\tif (std::binary_search(vowels.begin(), vowels.end(), c)) {\n\t\t\t\t\
    int x = m[c];\n\t\t\t\tif(x>i) {\n\t\t\t\t\ti = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\tm[word[i]]=i;\n\t}\n\tstd::string ret = \"\";\n\tif(!m.empty()) {\n\t\tstd::map<int,char>::iterator\
    \ itr = m.begin();\n\t\twhile(itr != m.end()) {\n\t\t\tif(itr->first == i) {\n\
    \t\t\t\tret = itr->second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titr++;\n\t\t}\n\t}\n\
    \treturn ret;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoxzxvvsx.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpoxzxvvsx.cpp:27:45: error: conversion from \u2018_Rb_tree_iterator<pair<const\
    \ char,int>>\u2019 to non-scalar type \u2018_Rb_tree_iterator<pair<const int,char>>\u2019\
    \ requested\n   27 |   std::map<int,char>::iterator itr = m.begin();\n      |\
    \                                      ~~~~~~~^~\n/tmp/tmpoxzxvvsx.cpp:28:13:\
    \ error: no match for \u2018operator!=\u2019 (operand types are \u2018std::map<int,\
    \ char>::iterator\u2019 {aka \u2018std::_Rb_tree_iterator<std::pair<const int,\
    \ char> >\u2019} and \u2018std::map<char, int>::iterator\u2019 {aka \u2018std::_Rb_tree_iterator<std::pair<const\
    \ char, int> >\u2019})\n   28 |   while(itr != m.end()) {\n      |         ~~~\
    \ ^~ ~~~~~~~\n      |         |           |\n      |         |           _Rb_tree_iterator<pair<const\
    \ char,int>>\n      |         _Rb_tree_iterator<pair<const int,char>>\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpoxzxvvsx.cpp:2:\n/usr/include/c++/9/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1037:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpoxzxvvsx.cpp:28:22:\
    \ note:   \u2018std::map<int, char>::iterator\u2019 {aka \u2018std::_Rb_tree_iterator<std::pair<const\
    \ int, char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   28 |   while(itr != m.end()) {\n      |                      ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpoxzxvvsx.cpp:2:\n/usr/include/c++/9/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(std"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels[] = {\"a\",\"e\",\"i\",\"o\",\"u\"};\n    int\
    \ vowels_count = sizeof(vowels)/sizeof(vowels[0]);\n    int start = 0;\n    int\
    \ end = word.length()-1;\n    while(start <= end){\n        int mid = (start +\
    \ end)/2;\n        if(word[mid] in vowels){\n            if(mid > 0 && word[mid-1]\
    \ in vowels){\n                end--;\n            }else{\n                start++;\n\
    \            }\n        }else if(word[mid] in vowels){\n            if(mid < word.length()-1\
    \ && word[mid+1] in vowels){\n                start++;\n            }else{\n \
    \               end--;\n            }\n        }else if(word[mid] in vowels){\n\
    \            start++;\n        }else if(word[mid] in vowels){\n            end--;\n\
    \        }\n    }\n    if(start < word.length()-1){\n        start = word.length()\
    \ - 1;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc80xr4i9.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpc80xr4i9.cpp:16:21: error: expected \u2018)\u2019 before \u2018in\u2019\
    \n   16 |         if(word[mid] in vowels){\n      |           ~         ^~~\n\
    \      |                     )\n/tmp/tmpc80xr4i9.cpp:17:38: error: expected \u2018\
    )\u2019 before \u2018in\u2019\n   17 |             if(mid > 0 && word[mid-1] in\
    \ vowels){\n      |               ~                      ^~~\n      |        \
    \                              )\n/tmp/tmpc80xr4i9.cpp:22:27: error: expected\
    \ \u2018)\u2019 before \u2018in\u2019\n   22 |         }else if(word[mid] in vowels){\n\
    \      |                 ~         ^~~\n      |                           )\n\
    /tmp/tmpc80xr4i9.cpp:23:52: error: expected \u2018)\u2019 before \u2018in\u2019\
    \n   23 |             if(mid < word.length()-1 && word[mid+1] in vowels){\n  \
    \    |               ~                                    ^~~\n      |       \
    \                                             )\n/tmp/tmpc80xr4i9.cpp:28:27: error:\
    \ expected \u2018)\u2019 before \u2018in\u2019\n   28 |         }else if(word[mid]\
    \ in vowels){\n      |                 ~         ^~~\n      |                \
    \           )\n/tmp/tmpc80xr4i9.cpp:30:27: error: expected \u2018)\u2019 before\
    \ \u2018in\u2019\n   30 |         }else if(word[mid] in vowels){\n      |    \
    \             ~         ^~~\n      |                           )\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowel = \"aeiouy\";\n    int size = word.length();\n\
    \    std::string ans;\n    int flag = 0;\n    std::string ans_temp = word;\n \
    \   for (int i = size - 1; i >= 0; i--) {\n        for (int j = 0; j < vowel.length();\
    \ j++) {\n            ans = ans_temp;\n            if (word[i] == vowel[j]) {\n\
    \                if (i == 0) {\n                    flag = 1;\n              \
    \      ans_temp = ans + word[i];\n                }\n                if (i ==\
    \ size - 1) {\n                    flag = 2;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j == 0) {\n                    flag = 3;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 4;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 5;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 6;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 7;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 8;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 9;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 10;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 11;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 12;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 13;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 14;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 15;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 16;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 17;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ j != 0) {\n                    flag = 18;\n                    ans_temp = ans\
    \ + word[i];\n                }\n                if (i != 0 && i != size - 1 &&\
    \ \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0093kvf1.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp0093kvf1.cpp:92:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   92 | }\n      | ^\n/tmp/tmp0093kvf1.cpp:91:47: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   91 |                 if (i != 0\
    \ && i != size - 1 &&\n      |                    ~                          ^\n\
    \      |                                               )\n   92 | }\n      | ~\
    \                                              \n/tmp/tmp0093kvf1.cpp:92:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   92 | }\n      | ^\n\
    /tmp/tmp0093kvf1.cpp:93:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   93 | int main() {\n      |            ^\n/tmp/tmp0093kvf1.cpp:108:1:\
    \ error: expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmp0093kvf1.cpp:16:50:\
    \ note: to match this \u2018{\u2019\n   16 |         for (int j = 0; j < vowel.length();\
    \ j++) {\n      |                                                  ^\n/tmp/tmp0093kvf1.cpp:108:1:\
    \ error: expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmp0093kvf1.cpp:15:41:\
    \ note: to match this \u2018{\u2019\n   15 |     for (int i = size - 1; i >= 0;\
    \ i--) {\n      |                                         ^\n/tmp/tmp0093kvf1.cpp:108:1:\
    \ error: expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmp0093kvf1.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmp0093kvf1.cpp:108:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  108 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\"\
    ,\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"};\n    std::string consonants\
    \ = {\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"\
    q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"z\"};\n    int n1 = 0, n2 = 0, lenght\
    \ = word.size(), found = false;\n    while (n1 < lenght || n2 < lenght) {\n  \
    \      if (n1 < lenght && !found) {\n            if (vowels.find(word[n1]) !=\
    \ std::string::npos)\n                found = true;\n            n1++;\n     \
    \   }\n        if (n2 < lenght && !found) {\n            if (consonants.find(word[n2])\
    \ != std::string::npos)\n                found = true;\n            n2++;\n  \
    \      }\n    }\n    if (!found)\n        return \"\";\n    std::string answer\
    \ = word;\n    if (n1 == lenght && n2 == lenght)\n        return answer;\n   \
    \ if (n2 < n1) {\n        answer = word;\n        n2 = n1;\n    }\n    if (n1\
    \ < n2) {\n        answer = word;\n        n1 = n2;\n    }\n    std::string left,\
    \ right;\n    left = word;\n    right = answer;\n    std::string mid;\n    while\
    \ (left != left && right != right) {\n        mid = word[lenght/2];\n        if\
    \ (left.find(mid) != std::string::npos)\n            left = left.substr(0,left.find(mid));\n\
    \        else if (right.find(mid) != std::string::npos)\n            right = right.substr(0,right.find(mid));\n\
    \        else\n            mid = \"\";\n    }\n    answer = word;\n    mid = word[lenght/2];\n\
    \    answer = answer.substr(0,answer.find(mid));\n    return answer;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_t_icfhp.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp_t_icfhp.cpp:10:86: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"\
    o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to \u2018\
    std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   10 |\
    \     std::string vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"\
    O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"};\n      |                           \
    \                                                           ^\n      |       \
    \                                                                            \
    \   |\n      |                                                               \
    \                       <brace-enclosed initializer list>\n/tmp/tmp_t_icfhp.cpp:11:110:\
    \ error: could not convert \u2018{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"z\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   11 |     std::string consonants = {\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"\
    j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"\
    z\"};\n      |                                                               \
    \                                               ^\n      |                   \
    \                                                                            \
    \               |\n      |                                                   \
    \                                                           <brace-enclosed initializer\
    \ list>\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels[] = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\"};\n    int n = word.size();\n    for(int i = 0; i\
    \ < n; i++) {\n        if(word[i] >= 'A' && word[i] <= 'Z') \n            return\
    \ word[i] + get_closest_vowel(word.substr(i+1, n));\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptl2egm6d: /tmp/tmptl2egm6d.cpp:20: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i <= word.length()-1;\
    \ i++){\n        if(std::tolower(word[i]) == 'a' \n            || std::tolower(word[i])\
    \ == 'e' \n            || std::tolower(word[i]) == 'i' \n            || std::tolower(word[i])\
    \ == 'o' \n            || std::tolower(word[i]) == 'u'\n            || std::tolower(word[i])\
    \ == 'y'){\n            return word;\n        }\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpj1n2o07f: /tmp/tmpj1n2o07f.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::stack<char> vowels;\n    for (char c : word) {\n        if\
    \ (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            vowels.push(c);\n\
    \        }\n    }\n    std::string vowel_string;\n    while (!vowels.empty())\
    \ {\n        char vowel = vowels.top();\n        vowels.pop();\n        vowel_string.append(vowel);\n\
    \    }\n    return vowel_string;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdrd9iun9.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpdrd9iun9.cpp:20:34: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(char&)\u2019\n   20 |         vowel_string.append(vowel);\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdrd9iun9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1267:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1267 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:1267:7: note:   conversion of argument\
    \ 1 would be ill-formed:\n/tmp/tmpdrd9iun9.cpp:20:29: error: invalid conversion\
    \ from \u2018char\u2019 to \u2018const char*\u2019 [-fpermissive]\n   20 |   \
    \      vowel_string.append(vowel);\n      |                             ^~~~~\n\
    \      |                             |\n      |                             char\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 fr"
  stdout: ''
  timestamp: 1660120390
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n// Write your code here\n    for(int i=0;i<word.size();i++){\n    \
    \    if(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u'){\n\
    \            if(i+1<word.size()){\n                if(word[i+1]=='a' || word[i+1]=='e'\
    \ || word[i+1]=='i' || word[i+1]=='o' || word[i+1]=='u')\n                return\
    \ word;\n            }\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpni6uvewg: /tmp/tmpni6uvewg.cpp:23: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = 0;\n    int j = word.length();\n    std::string vowels\
    \ = \"AEIOUaeiou\";\n    std::string temp;\n    \n    while(i < word.length()\
    \ && i < j){\n        if(word[i] == 'A' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u'){\n            temp = word;\n            word\
    \ = temp.substr(0,i);\n            temp.erase(temp.end()-1);\n            j =\
    \ temp.find(word);\n        }\n        i++;\n        j--;\n    }\n    \n    \n\
    \    while(i < word.length() && i < j){\n        if(word[i] == 'A' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'){\n           \
    \ temp = word;\n            word = temp.substr(i+1);\n            temp.erase(temp.end()-1);\n\
    \            j = temp.find(word);\n        }\n        i++;\n        j--;\n   \
    \ }\n    return temp;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpug_ecci_: /tmp/tmpug_ecci_.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.length() > 1);\n    auto it = word.rbegin();\n    for\
    \ (size_t i = 0; i < word.length(); i++) {\n        it = word.find_first_not_of(word[i]\
    \ + 'a', it + 1);\n        if (it != word.rend())\n            return std::string(it,word.size());\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvxi4sf_0.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpvxi4sf_0.cpp:13:58: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::find_first_not_of(int, std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >)\u2019\n   13 |         it = word.find_first_not_of(word[i]\
    \ + 'a', it + 1);\n      |                                                   \
    \       ^\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvxi4sf_0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2673:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2673 |       find_first_not_of(const basic_string&\
    \ __str, size_type __pos = 0) const\n      |       ^~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2673:45:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const\
    \ std::__cxx11::basic_string<char>&\u2019\n 2673 |       find_first_not_of(const\
    \ basic_string& __str, size_type __pos = 0) const\n      |                   \
    \      ~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/basic_string.h:2687:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_Ch"
  stdout: ''
  timestamp: 1660120390
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.length() > 0);\n    std::string vowel;\n    for (unsigned\
    \ int i = 0; i < word.length() - 1; i++) {\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n            break;\n\
    \    }\n    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u')\n        return word;\n    int start = 0;\n    int\
    \ end = 0;\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            if (i != end)\n                vowel += word[start++];\n    \
    \        end = i + 1;\n        }\n        if (word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            if (i\
    \ != start)\n                vowel += word[end--];\n            start = i + 1;\n\
    \        }\n    }\n    return vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzc6dz83p.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpzc6dz83p.cpp:16:14: error: \u2018i\u2019 was not declared in this scope\n\
    \   16 |     if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u')\n      |              ^\n"
  stdout: ''
  timestamp: 1660120390
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int k = word[n - 1] - 'a' + 1;\n    int\
    \ x = k / 5;\n    int y = k % 5;\n    if (x > y) {\n        return \"\";\n   \
    \ }\n    int c = 0;\n    for (int i = 0; i < n; i++) {\n        if ((word[i] ==\
    \ 'a') || (word[i] == 'e') || (word[i] == 'i') || (word[i] == 'o')\n         \
    \   || (word[i] == 'u')) {\n            c++;\n        } else {\n            if\
    \ (c == x - 1) {\n                return word[i];\n            }\n           \
    \ c = 0;\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt8hvctur.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpt8hvctur.cpp:24:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   24 |                 return word[i];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n// Write your code here\nint size=word.size();\nif(word.find(\"A\"\
    )==word.length()-1)\nreturn word;\nelse if(word.find(\"a\")==word.length()-1)\n\
    return word;\nelse if(word.find(\"E\")==word.length()-1)\nreturn word;\nelse if(word.find(\"\
    e\")==word.length()-1)\nreturn word;\nelse if(word.find(\"I\")==word.length()-1)\n\
    return word;\nelse if(word.find(\"i\")==word.length()-1)\nreturn word;\nelse if(word.find(\"\
    O\")==word.length()-1)\nreturn word;\nelse if(word.find(\"o\")==word.length()-1)\n\
    return word;\nelse if(word.find(\"U\")==word.length()-1)\nreturn word;\nelse if(word.find(\"\
    u\")==word.length()-1)\nreturn word;\nelse if(word.find(\"a\")==word.length()-2)\n\
    return word;\nelse if(word.find(\"e\")==word.length()-2)\nreturn word;\nelse if(word.find(\"\
    i\")==word.length()-2)\nreturn word;\nelse if(word.find(\"o\")==word.length()-2)\n\
    return word;\nelse if(word.find(\"u\")==word.length()-2)\nreturn word;\nelse if(word.find(\"\
    A\")==word.length()-3)\nreturn word;\nelse if(word.find(\"a\")==word.length()-3)\n\
    return word;\nelse if(word.find(\"E\")==word.length()-3)\nreturn word;\nelse if(word.find(\"\
    e\")==word.length()-3)\nreturn word;\nelse if(word.find(\"I\")==word.length()-3)\n\
    return word;\nelse if(word.find(\"i\")==word.length()-3)\nreturn word;\nelse if(word.find(\"\
    O\")==word.length()-3)\nreturn word;\nelse if(word.find(\"o\")==word.length()-3)\n\
    return word;\nelse if(word.find(\"U\")==word.length()-3)\nreturn word;\nelse if(word.find(\"\
    u\")==word.length()-3)\nreturn word;\nelse if(word.find(\"A\")==word.length()-4)\n\
    return word;\nelse if(word.find(\"a\")==word.length()-4)\nreturn word;\nelse if(word.find(\"\
    E\")==word.length()-4)\nreturn word;\nelse if(word.find(\"e\")==word.length()-4)\n\
    return word;\nelse if(word.find(\"I\")==word.length()-4)\nreturn word;\nelse if(word.find(\"\
    i\")==word.length()-4)\nreturn word;\nelse if(word.find(\"O\")==word.length()-4)\n\
    return word;\nelse if(word.find(\"\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxraf__c5.cpp:76:19: warning: missing terminating \" character\n\
    \   76 | else if(word.find(\"\n      |                   ^\n/tmp/tmpxraf__c5.cpp:76:19:\
    \ error: missing terminating \" character\n/tmp/tmpxraf__c5.cpp: In function \u2018\
    std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmpxraf__c5.cpp:77:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   77 | }\n \
    \     | ^\n/tmp/tmpxraf__c5.cpp:76:19: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   76 | else if(word.find(\"\n      |        ~          ^\n   \
    \   |                   )\n   77 | }\n      | ~                  \n/tmp/tmpxraf__c5.cpp:77:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   77 | }\n \
    \     | ^\n/tmp/tmpxraf__c5.cpp:77:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   77 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    std::string vowel(\"aeiouAEIOU\");\n\
    \    std::string vowel_first(\"a\");\n    std::string vowel_last(\"e\");\n   \
    \ for (int i = 0; i <= word.size() - 1; i++) {\n        if (vowel.find(word[word.size()\
    \ - i - 1]) != std::string::npos) {\n            if (word[word.size() - i - 1]\
    \ == vowel_first) {\n                return word;\n            } else if (word[word.size()\
    \ - i - 1] == vowel_last) {\n                return word;\n            }\n   \
    \     }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppsw5lfmu.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmppsw5lfmu.cpp:16:43: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   16 |             if (word[word.size() - i - 1] == vowel_first) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppsw5lfmu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmppsw5lfmu.cpp:16:46:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   16 |             if (word[word.size() - i - 1] ==\
    \ vowel_first) {\n      |                                              ^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppsw5lfmu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmppsw5lfmu.cpp:16:46: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_trait"
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    return \"\";\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpncnza2qf: /tmp/tmpncnza2qf.cpp:15: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.length();\n    std::string res=\"\";\n    for(int\
    \ i=n-1;i>=0;i--){\n        if(isalpha(word[i])&& word[i]!='.' && word[i]!=':'\
    \ && word[i]!=';'){\n            int j=i;\n            while(j>0 && isalpha(word[j])){\n\
    \                j--;\n            }\n            if((isalpha(word[i]) && j>0)||\
    \ word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n\
    \                int flag=0;\n                int k=j;\n                while(j<n\
    \ && isalpha(word[j])){\n                    j++;\n                }\n       \
    \         if(j<n){\n                    int temp=j;\n                    while(temp>0\
    \ && isalpha(word[temp-1])){\n                        temp--;\n              \
    \      }\n                    if(temp==0 || ((word[temp-1]!='a' && word[temp-1]!='e'\
    \ && word[temp-1]!='i' && word[temp-1]!='o' && word[temp-1]!='u')&& (word[temp]!='a'\
    \ && word[temp]!='e' && word[temp]!='i' && word[temp]!='o' && word[temp]!='u'))){\n\
    \                        flag=1;\n                        break;\n           \
    \         }\n                }\n                if(flag==1){\n               \
    \     res=word[i];\n                    j=i;\n                    while(j>0 &&\
    \ isalpha(word[j])){\n                        j--;\n                    }\n  \
    \                  if(j<n){\n                        int temp=j;\n           \
    \             while(temp>0 && isalpha(word[temp-1])){\n                      \
    \      temp--;\n                        }\n                        if(temp==0\
    \ || ((word[temp-1]!='a' && word[temp-1]!='e' && word[temp-1]!='i' && word[temp-1]!='o'\
    \ && word[temp-1]!='u')&& (word[temp]!='a' && word[temp]!='e' && word[temp]!='i'\
    \ && word[temp]!='o' && word[temp]!='u'))){\n                            break;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpdmxtm7qs: /tmp/tmpdmxtm7qs.cpp:57: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    char leftVowel = 'a';\n    char rightVowel\
    \ = 'z';\n    int leftPos = 0;\n    int rightPos = len;\n\n    while (leftPos\
    \ < rightPos) {\n        // if left position was a vowel\n        if (word[leftPos]\
    \ >= 'a' && word[leftPos] <= 'z') {\n            leftPos++;\n            continue;\n\
    \        }\n\n        // if right position was a vowel\n        if (word[rightPos]\
    \ >= 'a' && word[rightPos] <= 'z') {\n            rightPos--;\n            continue;\n\
    \        }\n\n        // else return empty\n        return \"\";\n    }\n    if\
    \ (leftPos > rightPos) {\n        // if we are at the beginning, return the leftVowel\n\
    \        return leftVowel;\n    } else {\n        // if we are at the end, return\
    \ the rightVowel\n        return rightVowel;\n    }\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzxfnta8m.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpzxfnta8m.cpp:34:16: error: could not convert \u2018leftVowel\u2019\
    \ from \u2018char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   34 |         return leftVowel;\n      |                ^~~~~~~~~\n     \
    \ |                |\n      |                char\n/tmp/tmpzxfnta8m.cpp:37:16:\
    \ error: could not convert \u2018rightVowel\u2019 from \u2018char\u2019 to \u2018\
    std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   37 |\
    \         return rightVowel;\n      |                ^~~~~~~~~~\n      |     \
    \           |\n      |                char\n"
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    auto it = std::find(word.begin(),\
    \ word.end(), vowels.begin());\n    if (it == word.end() || *it != vowels.end())\
    \ return \"\";\n\n    auto last_vowel = word.back();\n    auto last_vowel_pos\
    \ = std::distance(word.begin(), it);\n    auto last_vowel_pos = std::distance(word.end(),\
    \ it);\n\n    for (auto it = it; it != word.end(); ++it) {\n        if (*it ==\
    \ vowels.back()) {\n            auto pos_left = std::distance(word.begin(), it);\n\
    \            auto pos_right = std::distance(word.end(), it);\n            auto\
    \ pos_left = std::distance(word.begin(), it);\n            return word.substr(pos_left\
    \ + 1, pos_right - pos_left - 1);\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpabuj_cmc.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpabuj_cmc.cpp:12:33: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018char\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   12 |     if (it == word.end() || *it != vowels.end()) return \"\
    \";\n      |                             ~~~ ^~ ~~~~~~~~~~~~\n      |        \
    \                     |                |\n      |                            \
    \ char             std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpabuj_cmc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpabuj_cmc.cpp:12:47: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n   12 |     if (it == word.end() || *it != vowels.end())\
    \ return \"\";\n      |                                               ^\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpabuj_cmc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:"
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    std::unordered_set<char> vowels;\n\
    \    for(char c: word){\n        vowels.insert(c); \n    }\n    std::vector<char>\
    \ vowel_vec;\n    vowel_vec.push_back('a');\n    vowel_vec.push_back('e');\n \
    \   vowel_vec.push_back('i');\n    vowel_vec.push_back('o');\n    vowel_vec.push_back('u');\n\
    \    vowel_vec.push_back('y');\n    std::vector<char> consonants = {'b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x'};\n    for(char c : word){\n        for(char c : consonants){\n        \
    \    if(c < word.size()){\n                if(word[c] >= 'a' && word[c] <= 'z'){\n\
    \                    if(vowels.count(word[c + 1]) > 0){\n                    \
    \    vowel_vec.push_back(word[c]);\n                    }\n                }\n\
    \            }\n        }\n    }\n    for(int i = 0; i < (vowel_vec.size() - 1);\
    \ i++){\n        if(vowel_vec[i] == 'a' || vowel_vec[i] == 'e' || vowel_vec[i]\
    \ == 'i' || vowel_vec[i] == 'o' || vowel_vec[i] == 'u' || vowel_vec[i] == 'y'){\n\
    \            vowel_vec.pop_back();\n        }\n    }\n    std::string vowel_string\
    \ = std::to_string(vowel_vec.size());\n    vowel_string += vowel_vec.back();\n\
    \    return vowel_string;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpiijgue_w: /tmp/tmpiijgue_w.cpp:45: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120392
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n// Your code here\nreturn \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8cdvcx06: /tmp/tmp8cdvcx06.cpp:15: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// Do not print anything if word is empty\n\tif (word.empty())\n\t\
    \treturn \"\";\n\t// Do not print anything if there are no vowel in the given\
    \ word\n\tsize_t vowel_count = word.length() - 1;\n\tif (vowel_count <= 0)\n\t\
    \treturn \"\";\n\n\t// Initialize two iterators first\n\tauto first = word.begin();\n\
    \tauto second = word.end() - 1;\n\n\tbool found = false;\n\t// Search for the\
    \ nearest vowel from the right side of the word from the first \n\t// iterator\n\
    \twhile (first != second && !found) {\n\t\t// If found the first vowel from the\
    \ right side of the word, break \n\t\t// out from the loop.\n\t\tif (*first ==\
    \ 'a' || *first == 'e' || *first == 'i' || *first == 'o' || *first == 'u') {\n\
    \t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tfirst--;\n\t}\n\t// If found the\
    \ first vowel from the right side of the word, \n\t// continue to search the second\
    \ iterator. \n\tif (found)\n\t\tsecond--;\n\n\t// Search for the nearest vowel\
    \ from the right side of the word from the second \n\t// iterator\n\twhile (first\
    \ != second && !found) {\n\t\t// If found the second vowel from the right side\
    \ of the word, \n\t\t// break out from the loop.\n\t\tif (*second == 'a' || *second\
    \ == 'e' || *second == 'i' || *second == 'o' || *second == 'u') {\n\t\t\tfound\
    \ = true;\n\t\t\tbreak;\n\t\t}\n\t\tsecond--;\n\t}\n\t// If found the second vowel\
    \ from the right side of the word, continue \n\t// to search the first iterator.\
    \ \n\tif (found)\n\t\tfirst--;\n\n\t// If found all the vowel from the right side\
    \ of the word. \n\tif (found == true) {\n\t\t// Return an empty string if you\
    \ can't find any vowel from the right side\n\t\t// of the word.\n\t\tif (second\
    \ - first > 0)\n\t\t\treturn \"\";\n\t\t// If the first vowel and the last vowel\
    \ are the same character,\n\t\t// return the first vowel.\n\t\tif (*first == *second)\
    \ {\n\t\t\treturn word[first + 1];\n\t\t}\n\t\t// If the first vowel is different\
    \ than the second vowel, return the \n\t\t// second vowel.\n\t\tif (*first !=\
    \ *second) {\n\t\t\treturn word[second + 1];\n\t\t}\n\t\t// If the first vowel\
    \ is different than the second vowel but the first is \n\t\t// a vowel, return\
    \ the last vowel.\n\t\tif (*first == 'a' && *second == 'a') {\n\t\t\treturn word[vowel_count\
    \ - 1];\n\t\t}\n\t\t// If the first vowel is different than the second vowel but\
    \ the second \n\t\t// is a vowel, return the first vowel.\n\t\tif (*first == 'e'\
    \ && *second == 'e') {\n\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe1c2n6xr.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpe1c2n6xr.cpp:64:15: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019)\n   64 |    return word[first + 1];\n      |               ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpe1c2n6xr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1050:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator[](std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ = const char&; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1050 |       operator[] (size_type __pos) const\
    \ _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1050:29:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 1050 |       operator[] (size_type __pos)\
    \ const _GLIBCXX_NOEXCEPT\n      |                   ~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/basic_string.h:1067:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference "
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string reversed_word\
    \ = std::string(word.size(), '\\0');\n    std::copy(word.begin(), word.end(),\
    \ reversed_word.begin());\n    reverse(reversed_word.begin(), reversed_word.end());\n\
    \    bool found = false;\n    for (size_t i = 0; i < vowels.size(); i++) {\n \
    \       std::string current_vowel = std::string(vowels.at(i), '\\0');\n      \
    \  if (reversed_word[reversed_word.size() - 1 - current_vowel.size()] == '\\0')\
    \ {\n            return current_vowel;\n        }\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpx23y5pra: /tmp/tmpx23y5pra.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n}\nint main() {\n    auto candidate = get_closest_vowel;\n  \
    \  assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120389
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowel_start = word.find_first_of(\"aeiou\");\n    int vowel_end\
    \ = word.find_first_of(\"aeiou\", word.length() - 1);\n    if (vowel_start ==\
    \ -1 || vowel_end == -1) {\n        return \"\";\n    }\n    int vowel_middle\
    \ = (vowel_end + vowel_start) / 2;\n    int vowel_middle_upper = vowel_middle\
    \ + 1;\n    if (vowel_middle_upper == word.size()) {\n        return \"\";\n \
    \   }\n    if (word[vowel_middle_upper] == 'A') {\n        return word.substr(0,\
    \ vowel_middle);\n    }\n    if (word[vowel_middle_upper] == 'E') {\n        return\
    \ word.substr(vowel_middle, vowel_middle + 2);\n    }\n    if (word[vowel_middle_upper]\
    \ == 'I') {\n        return word.substr(vowel_middle, vowel_middle + 1);\n   \
    \ }\n    if (word[vowel_middle_upper] == 'O') {\n        return word.substr(vowel_middle,\
    \ vowel_middle + 1);\n    }\n    if (word[vowel_middle_upper] == 'U') {\n    \
    \    return word.substr(vowel_middle, vowel_middle + 1);\n    }\n    if (word[vowel_middle_upper]\
    \ == 'a') {\n        return word.substr(0, vowel_middle);\n    }\n    if (word[vowel_middle_upper]\
    \ == 'e') {\n        return word.substr(vowel_middle, vowel_middle + 2);\n   \
    \ }\n    if (word[vowel_middle_upper] == 'i') {\n        return word.substr(vowel_middle,\
    \ vowel_middle + 1);\n    }\n    if (word[vowel_middle_upper] == 'o') {\n    \
    \    return word.substr(vowel_middle, vowel_middle + 1);\n    }\n    if (word[vowel_middle_upper]\
    \ == 'u') {\n        return word.substr(vowel_middle, vowel_middle + 1);\n   \
    \ }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpie6_1uj1: /tmp/tmpie6_1uj1.cpp:54: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code goes here\n    std::string vowel = \"AEIOUaeiou\"\
    ;\n    std::string ans = \"\";\n    // if word length is 1 \n    if (word.length()\
    \ == 1) {\n        // if current character is not a vowel then return empty string\n\
    \        if (!std::isalpha(word[0])) return ans;\n        // if current character\
    \ is a vowel then return empty string\n        if (std::find(vowel.begin(), vowel.end(),\
    \ word[0]) != vowel.end()) return ans;\n        // else return current character\n\
    \        return word[0];\n    }\n    // if word length is 2\n    if (word.length()\
    \ == 2) {\n        // if current character is not a vowel then return empty string\n\
    \        if (!std::isalpha(word[0]) && !std::isalpha(word[1])) return ans;\n \
    \       // if current character is a vowel then return empty string\n        if\
    \ (std::find(vowel.begin(), vowel.end(), word[0]) != vowel.end()) return ans;\n\
    \        if (std::find(vowel.begin(), vowel.end(), word[1]) != vowel.end()) return\
    \ ans;\n        // else return current character\n        return word[0];\n  \
    \  }\n    // if word length is 3\n    if (word.length() == 3) {\n        // if\
    \ current character is not a vowel then return empty string\n        if (!std::isalpha(word[0])\
    \ && !std::isalpha(word[1]) && !std::isalpha(word[2])) return ans;\n        //\
    \ if current character is a vowel then return empty string\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[0]) != vowel.end()) return ans;\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[1]) != vowel.end()) return ans;\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[2]) != vowel.end()) return ans;\n        // else return current\
    \ character\n        return word[0];\n    }\n    // if word length is 4\n    if\
    \ (word.length() == 4) {\n        // if current character is not a vowel then\
    \ return empty string\n        if (!std::isalpha(word[0]) && !std::isalpha(word[1])\
    \ && !std::isalpha(word[2]) && !std::isalpha(word[3])) return ans;\n        //\
    \ if current character is a vowel then return empty string\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[0]) != vowel.end()) return ans;\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[1]) != vowel.end()) return ans;\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[2]) != vowel.end()) return ans;\n        if (std::find(vowel.begin(),\
    \ vowel.end(), word[3]) != vowel.end()) return ans;\n        // else return current\
    \ character\n        return word[0];\n    }\n    // \n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsic2y8pj.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpsic2y8pj.cpp:20:22: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](0)\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   20 |         return word[0];\n      |                      ^\n      |  \
    \                    |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n/tmp/tmpsic2y8pj.cpp:30:22: error: could not convert\
    \ \u2018word.std::__cxx11::basic_string<char>::operator[](0)\u2019 from \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   30 |         return word[0];\n      |                      ^\n      |  \
    \                    |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n/tmp/tmpsic2y8pj.cpp:41:22: error: could not convert\
    \ \u2018word.std::__cxx11::basic_string<char>::operator[](0)\u2019 from \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   41 |         return word[0];\n      |                      ^\n      |  \
    \                    |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n/tmp/tmpsic2y8pj.cpp:53:22: error: could not convert\
    \ \u2018word.std::__cxx11::basic_string<char>::operator[](0)\u2019 from \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   53 |         return word[0];\n      |                      ^\n      |  \
    \                    |\n      |                      __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.size()>0);\n    int i=0;\n    int j=0;\n    while(word[i]!='\\\
    0'){\n        for(int j=0;j<word.size();j++){\n            if((word[j]==\"a\"\
    ||word[j]==\"e\"||word[j]==\"i\"||word[j]==\"o\"||word[j]==\"u\")&&(i!=j)){\n\
    \                i=j;\n            }\n        }\n    }\n    return \"\";\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4mwu66ao.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp4mwu66ao.cpp:15:26: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n   15 |             if((word[j]==\"a\"||word[j]==\"\
    e\"||word[j]==\"i\"||word[j]==\"o\"||word[j]==\"u\")&&(i!=j)){\n      |      \
    \                    ^~~\n/tmp/tmp4mwu66ao.cpp:15:40: error: ISO C++ forbids comparison\
    \ between pointer and integer [-fpermissive]\n   15 |             if((word[j]==\"\
    a\"||word[j]==\"e\"||word[j]==\"i\"||word[j]==\"o\"||word[j]==\"u\")&&(i!=j)){\n\
    \      |                                        ^~~\n/tmp/tmp4mwu66ao.cpp:15:54:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   15 |             if((word[j]==\"a\"||word[j]==\"e\"||word[j]==\"i\"||word[j]==\"\
    o\"||word[j]==\"u\")&&(i!=j)){\n      |                                      \
    \                ^~~\n/tmp/tmp4mwu66ao.cpp:15:68: error: ISO C++ forbids comparison\
    \ between pointer and integer [-fpermissive]\n   15 |             if((word[j]==\"\
    a\"||word[j]==\"e\"||word[j]==\"i\"||word[j]==\"o\"||word[j]==\"u\")&&(i!=j)){\n\
    \      |                                                                    ^~~\n\
    /tmp/tmp4mwu66ao.cpp:15:82: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n   15 |             if((word[j]==\"a\"||word[j]==\"\
    e\"||word[j]==\"i\"||word[j]==\"o\"||word[j]==\"u\")&&(i!=j)){\n      |      \
    \                                                                            ^~~\n"
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = 0;\n    int cnt = 0;\n    int left = 0;\n    int right\
    \ = 0;\n    int mid = 0;\n    char ch = 'a';\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i]\
    \ != 'o' && word[i] != 'u') {\n            len += 1;\n            cnt += 1;\n\
    \            ch = (word[i] + ch);\n        }\n    }\n    left = word.length()\
    \ - len;\n    right = word.length() - cnt;\n    mid = right + left;\n    while\
    \ (word[mid] == 'a' || word[mid] == 'e' || word[mid] == 'i' || word[mid] == 'o'\
    \ || word[mid] == 'u' || word[mid] == 'y') {\n        mid -= 1;\n    }\n    return\
    \ word[mid];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2zpdgxcs.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp2zpdgxcs.cpp:29:20: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)mid))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   29 |     return word[mid];\n      |                    ^\n      |      \
    \              |\n      |                    __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120391
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = 0;\n    int j = word.size() - 1;\n    int temp = 0;\n \
    \   while (i <= j) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n            temp += 1;\n      \
    \  else if (word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O'\
    \ || word[i] == 'U')\n            temp -= 1;\n        i++;\n        j--;\n   \
    \ }\n    if (temp == 0)\n        return \"\";\n    std::string result = \"\";\n\
    \    while (i + temp <= j) {\n        result += word[i + temp];\n        i++;\n\
    \    }\n    while (i - temp >= 0) {\n        result += word[i - temp];\n     \
    \   i--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp838o5beg: /tmp/tmp838o5beg.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120392
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels;\n    std::string result=\"\";\n    int len=word.length();\n\
    \    for (int i=len-1; i>=0; i--)\n    {\n        if (word.at(i)=='a' || word.at(i)=='e'\
    \ || word.at(i)=='i' || word.at(i)=='o' || word.at(i)=='u') \n        {\n    \
    \        result+=word.at(i);\n            if (word.at(i)=='a' || word.at(i)=='e'\
    \ || word.at(i)=='i' || word.at(i)=='o' || word.at(i)=='u') \n            {\n\
    \                vowels+=word.at(i);\n            }\n        }\n    }\n    if\
    \ (vowels.empty())\n        result=vowels;\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpe3zqvrrb: /tmp/tmpe3zqvrrb.cpp:30: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120392
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // code goes here\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120392
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Complete this function\n    \n    // Do not print the output\
    \ in get_closest_vowel function.\n    \n    // You are expected to return the\
    \ closest vowel as a string in any case. \n    // Note that vowel can be an English\
    \ letter or an other unicode character.\n    // vowels can be a, e, i, o, or u\n\
    \n    int vowel = 0;\n    int con = 0;\n    std::string closestvowel = \"\";\n\
    \n    for(int i = word.length() - 1; i >= 0; --i) {\n        if(word[i] == 'a'||word[i]\
    \ == 'e'||word[i] == 'i'||word[i] == 'o'||word[i] == 'u') {\n            vowel++;\n\
    \        }\n        if(word[i] == word[i+1]) {\n            con++;\n        }\n\
    \    }\n    \n    if(con == 0) {\n        closestvowel = \"\";\n    } else {\n\
    \        if(vowel < con) {\n            closestvowel = \"\";\n        } else {\n\
    \            closestvowel = word[word.length() - 1] + word[word.length() - 2];\n\
    \        }\n    }\n    \n    return closestvowel;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_uquje38: /tmp/tmp_uquje38.cpp:45: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120392
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int left = 0, right = word.size(), mid;\n  while(left < right) {\n\
    \    mid = (left + right) / 2;\n    if(word[mid] >= 'A' && word[mid] <= 'Z') {\n\
    \      if(word[mid+1] >= 'a' && word[mid+1] <= 'z')\n        return word;\n  \
    \    else\n        right = mid;\n    } else {\n      if(word[mid+1] >= 'a' &&\
    \ word[mid+1] <= 'z')\n        left = mid+1;\n      else\n        left = mid;\n\
    \    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    std::string result =\
    \ \"\";\n    int n = word.length();\n    for(int i = n-1; i >= 0; i--){\n    \
    \    auto it=vowels.find(word[i]);\n        if(it != vowels.end()) result = word[i];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfdyyisb8.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpfdyyisb8.cpp:15:15: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018long unsigned int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   15 |         if(it != vowels.end()) result = word[i];\n      |\
    \            ~~ ^~ ~~~~~~~~~~~~\n      |            |               |\n      |\
    \            |               std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\n      |            long unsigned int\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpfdyyisb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpfdyyisb8.cpp:15:29: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018long unsigned int\u2019\n   15 |         if(it != vowels.end()) result\
    \ = word[i];\n      |                             ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpfdyyisb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:904:5:\
    \ note: candidate: \u2018temp"
  stdout: ''
  timestamp: 1660120391
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int low = 0;\n    int high = word.length() - 1;\n    while(low\
    \ < high) {\n        int middle = (low + high)/2;\n        int cons = word[middle].size()\
    \ - 1;\n        int vowel_start = middle + cons/2;\n        int vowel_end = vowel_start\
    \ + cons;\n        if(word[vowel_start] == word[vowel_end]) {\n            return\
    \ word.substr(vowel_start);\n        }\n        if(word[vowel_start] == 'a' &&\
    \ word[vowel_end] == 'e') {\n            low = middle + 1;\n        }\n      \
    \  else if(word[vowel_start] == 'e' && word[vowel_end] == 'i') {\n           \
    \ high = middle - 1;\n        }\n        else if(word[vowel_start] == 'i' && word[vowel_end]\
    \ == 'o') {\n            low = vowel_start - 1;\n        }\n        else if(word[vowel_start]\
    \ == 'o' && word[vowel_end] == 'u') {\n            high = vowel_end + 1;\n   \
    \     }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1h20vpz8.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp1h20vpz8.cpp:14:33: error: request for member \u2018size\u2019 in \u2018\
    word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)middle))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   14 |         int cons = word[middle].size()\
    \ - 1;\n      |                                 ^~~~\n"
  stdout: ''
  timestamp: 1660120392
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n   assert(word.size()>=2);\n   char endVowel = 'a';\n   char beginVowel\
    \ = 'a';\n   for(size_t i=word.size() - 2; i >= 0; --i)\n   {\n       if(endVowel\
    \ == word[i] || beginVowel == word[i])\n           continue;\n       int posBeginVowel\
    \ = word[i] - 'a';\n       int posEndVowel = word[i+1] - 'a';\n       int posEndVowel2\
    \ = word[i+2] - 'a';\n       if(posEndVowel > posEndVowel2)\n       {\n      \
    \     endVowel = word[i];\n       }\n       else\n       {\n           beginVowel\
    \ = word[i];\n       }\n       \n   }\n   return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels;\n    vowels.push_back('a');\n    vowels.push_back('e');\n\
    \    vowels.push_back('i');\n    vowels.push_back('o');\n    vowels.push_back('u');\n\
    \    vowels.push_back('y');\n    for (auto i=vowels.size()-1; i>=0; i--) {\n \
    \       if (word.rfind(vowels[i]) != std::string::npos) {\n            return\
    \ vowels[i];\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9ivl4alw.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp9ivl4alw.cpp:19:28: error: could not convert \u2018vowels.std::__cxx11::basic_string<char>::operator[](i)\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   19 |             return vowels[i];\n      |                            ^\n\
    \      |                            |\n      |                            __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120392
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"AEIOUaeiou\";\n  \n  for (auto it = word.rbegin();\
    \ it != word.rend(); it++)\n  {\n    const char c = *it;\n    if (std::find(vowels.begin(),\
    \ vowels.end(), c) != vowels.end())\n    {\n      std::cout << \"vowel \" << c\
    \ << \" found in it\" << std::endl;\n      \n      // TODO: find the closest vowel\
    \ met condition and return it\n    }\n    else\n    {\n      std::cout << \"vowel\
    \ not found\" << std::endl;\n    }\n  }\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: 'vowel not found

    vowel not found

    vowel u found in it

    vowel not found

    vowel o found in it

    vowel not found

    '
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint l = word.length();\n\tint n = l;\n\tint k = 0;\n\tstd::string\
    \ temp;\n\tstd::stack <char> vowel;\n\twhile (k != n) {\n\t\tif (word[k] == word[n-1])\n\
    \t\t\ttemp = word[k];\n\t\telse \n\t\t\ttemp = word[k] + word[n-1];\n\t\tif (temp.find(\"\
    AEIOUaeiou\")!= std::string::npos)\n\t\t\tbreak;\n\t\telse \n\t\t\tvowel.push(temp);\n\
    \t\tn--;\n\t}\n\tif (temp == word[n-1])\n\t\treturn \"\";\n\telse\n\t\treturn\
    \ vowel.top();\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3tkl_ge.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmph3tkl_ge.cpp:23:19: error: no matching function for call to \u2018\
    std::stack<char>::push(std::string&)\u2019\n   23 |    vowel.push(temp);\n   \
    \   |                   ^\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmph3tkl_ge.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = char; _Sequence = std::deque<char, std::allocator<char> >; std::stack<_Tp,\
    \ _Sequence>::value_type = char]\u2019\n  233 |       push(const value_type& __x)\n\
    \      |       ^~~~\n/usr/include/c++/9/bits/stl_stack.h:233:30: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const value_type&\u2019 {aka \u2018const char&\u2019}\n  233 |    \
    \   push(const value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_stack.h:238:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp,\
    \ _Sequence>::value_type&&) [with _Tp = char; _Sequence = std::deque<char, std::allocator<char>\
    \ >; std::stack<_Tp, _Sequence>::value_type = char]\u2019\n  238 |       push(value_type&&\
    \ __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_stack.h:238:25: note:\
    \   no known conversion for argument 1 from \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} to \u2018std::stack<char>::value_type&&\u2019\
    \ {aka \u2018char&&\u2019}\n  238 |       push(value_type&& __x)\n      |    \
    \        ~~~~~~~~~~~~~^~~\n/tmp/tmph3tkl_ge.cpp:26:11: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   26 |  if (temp == word[n-1])\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /t"
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    // If no vowel found\n    if(word.find_first_not_of(\"aeiou\"\
    ) == word.size()-1){\n        return \"\";\n    }\n    \n    \n    // If string\
    \ contains two consonants\n    if(word.length() == 2){\n        \n        std::string\
    \ vowels = {\"a\",\"e\",\"i\",\"o\",\"u\"};\n        \n        // Find the first\
    \ vowel from the right\n        int vowel_pos = word.find_last_of(\"aeiou\");\n\
    \        \n        // If no vowel found\n        if(vowel_pos == std::string::npos){\n\
    \            return \"\";\n        }\n        \n        // Find the index of first\
    \ vowel from the right\n        int vow_pos_1 = vowel_pos + 2;\n        int vow_pos_2\
    \ = word.length();\n        int min_pos = vow_pos_1;\n        \n        // Find\
    \ the min vowel position\n        while(vow_pos_1 < vow_pos_2){\n            if(vowels[vow_pos_1]\
    \ < vowels[vow_pos_2]){\n                min_pos = vow_pos_1;\n            }\n\
    \            else if(vowels[vow_pos_1] > vowels[vow_pos_2]){\n               \
    \ min_pos = vow_pos_2;\n            }\n            vow_pos_1++;\n            vow_pos_2--;\n\
    \        }\n        \n        // Find the first vowel from the right that surround\
    \ min_pos\n        int first_consonant_pos = word.length()-1;\n        int last_consonant_pos\
    \ = 0;\n        while(vow_pos_1 < vow_pos_2){\n            if(vowels[vow_pos_1]\
    \ == vowels[vow_pos_2]){\n                first_consonant_pos = vow_pos_1;\n \
    \               break;\n            }\n            else if(vowels[vow_pos_1] <\
    \ vowels[vow_pos_2]){\n                last_consonant_pos = vow_pos_1;\n     \
    \           vow_pos_1++;\n            }\n            else{\n                last_consonant_pos\
    \ = vow_pos_2;\n                vow_pos_2--;\n            }\n        }\n     \
    \   \n        // Check if the right consonant is between first and last vowel\n\
    \        if(word[first_consonant_pos] >= vowels[min_pos] && word[first_consonant_pos]\
    \ <= vowels[last_consonant_pos]){\n            // If right consonant is between\
    \ first and last vowel\n            std::string vowel = word.substr(first_consonant_pos+1,\
    \ last_consonant_pos-first_consonant_pos-1);\n            return vowel;\n    \
    \    }\n    }\n    \n    // If string contains three consonants\n    if(word.length()\
    \ == 3){\n        \n        // Find the first vowel from the right\n        int\
    \ vowel_pos = word.find_last_of\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbw4gds39.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpbw4gds39.cpp:20:50: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   20 |         std::string vowels = {\"a\",\"e\",\"i\",\"o\",\"u\"};\n     \
    \ |                                                  ^\n      |              \
    \                                    |\n      |                              \
    \                    <brace-enclosed initializer list>\n/tmp/tmpbw4gds39.cpp:77:30:\
    \ error: cannot resolve overloaded function \u2018find_last_of\u2019 based on\
    \ conversion to type \u2018int\u2019\n   77 |         int vowel_pos = word.find_last_of\n\
    \      |                              ^~~~~~~~~~~~\n/tmp/tmpbw4gds39.cpp:79:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   79 | int main() {\n      |            ^\n/tmp/tmpbw4gds39.cpp:94:1: error:\
    \ expected \u2018}\u2019 at end of input\n   94 | }\n      | ^\n/tmp/tmpbw4gds39.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpbw4gds39.cpp:94:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   94 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n\
    \    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            count++;\n        }\n    }\n    int j = 0;\n    for (int i =\
    \ n-1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            count++;\n      \
    \      j++;\n        }\n        else if (word[i] == vowels[j] && count > 1 &&\
    \ count != n) {\n            return word[i];\n        }\n        else if (word[i]\
    \ == vowels[j]) {\n            return \"\";\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuze4s4t8.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpuze4s4t8.cpp:25:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   25 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n// TODO: Write your code here\n   return \"\";\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcimme959: /tmp/tmpcimme959.cpp:15: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(word.size() >= 2);\n  bool flag = false;\n  for (int i = word.size()-2;\
    \ i >= 0; i--) {\n    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u') {\n      flag = true;\n      break;\n    }\n\
    \  }\n  if (flag == false) {\n    return \"\";\n  }\n  else {\n    for (int i\
    \ = word.size()-2; i >= 0; i--) {\n      if (word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n        break;\n \
    \     }\n    }\n    return word.substr(0, i+1);\n  }\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuunrvh55.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpuunrvh55.cpp:27:27: error: \u2018i\u2019 was not declared in this scope\n\
    \   27 |     return word.substr(0, i+1);\n      |                           ^\n"
  stdout: ''
  timestamp: 1660120392
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    \n    std::string vowels = {\"a\"\
    , \"e\", \"i\", \"o\", \"u\"};\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[word.size() - i - 1])!=std::string::npos){\n   \
    \         std::string temp = word.substr(0, word.size() - i);\n            return\
    \ temp;\n        }\n    }\n    \n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfofaa04g.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpfofaa04g.cpp:12:50: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   12 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n     \
    \ |                                                  ^\n      |              \
    \                                    |\n      |                              \
    \                    <brace-enclosed initializer list>\n"
  stdout: ''
  timestamp: 1660120392
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code goes here\n    std::map<char, int> vowel_map;\n  \
    \  for (auto c : word) {\n        vowel_map[c]++;\n    }\n    int vowel_sum =\
    \ std::accumulate(vowel_map.cbegin(), vowel_map.cend(), 0);\n    char vowel_count\
    \ = vowel_map.begin()->first;\n    int vowel_dist = vowel_sum - vowel_map.size()\
    \ - 1;\n    if (vowel_dist < 0 || vowel_dist > word.size() - 1) {\n        return\
    \ {};\n    }\n    char closest_vowel = word[word.size() - 1];\n    int closest_dist\
    \ = 0;\n    for (auto c : word) {\n        if (vowel_map[c] <= closest_dist) {\n\
    \            closest_dist = vowel_map[c];\n            closest_vowel = c;\n  \
    \      }\n        vowel_map[c]--;\n    }\n    return std::to_string(closest_dist)\
    \ + closest_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/numeric:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:84,\n               \
    \  from /tmp/tmp6rab1k39.cpp:2:\n/usr/include/c++/9/bits/stl_numeric.h: In instantiation\
    \ of \u2018_Tp std::accumulate(_InputIterator, _InputIterator, _Tp) [with _InputIterator\
    \ = std::_Rb_tree_const_iterator<std::pair<const char, int> >; _Tp = int]\u2019\
    :\n/tmp/tmp6rab1k39.cpp:15:76:   required from here\n/usr/include/c++/9/bits/stl_numeric.h:139:39:\
    \ error: no match for \u2018operator+\u2019 (operand types are \u2018int\u2019\
    \ and \u2018const std::pair<const char, int>\u2019)\n  139 |  __init = _GLIBCXX_MOVE_IF_20(__init)\
    \ + *__first;\n      |                                       ^\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp6rab1k39.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/numeric:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:84,\n\
    \                 from /tmp/tmp6rab1k39.cpp:2:\n/usr/include/c++/9/bits/stl_numeric.h:139:39:\
    \ note:   \u2018const std::pair<const char, int>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n  139 |  __init = _GLIBCXX_MOVE_IF_20(__init)\
    \ + *__first;\n      |                                       ^\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /u"
  stdout: ''
  timestamp: 1660120392
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n   assert(word.length()==26);\n   //code here\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprwp5jeug: /tmp/tmprwp5jeug.cpp:10: std::string get_closest_vowel(std::string):
    Assertion `word.length()==26'' failed.

    '
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    bool check = false;\n    for (int i = word.length() - 1; i >= 0;\
    \ i--) {\n        if (!check && word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u') {\n            check = true;\n    \
    \    }\n        else if (check == true && word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            return word;\n\
    \        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp7jtzojqm: /tmp/tmp7jtzojqm.cpp:23: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n   \
    \ std::string vowel_left = \"eiou\";\n    std::string vowel_right = \"aieou\"\
    ;\n    // Find all consonants \n    std::vector<int> consonant_nums;\n    for\
    \ (auto i = word.size(); i >= 0; i--) {\n        if (word[i] >= 'a' && word[i]\
    \ <= 'z') {\n            consonant_nums.push_back(word[i]);\n        }\n    }\n\
    \    // find right edge and left edge of string\n    auto right_edge = consonant_nums.rbegin();\n\
    \    auto left_edge = consonant_nums.begin() + consonant_nums.size() / 2;\n  \
    \  // Check left and right edge (make sure they are in consonant range)\n    if\
    \ (right_edge == left_edge) {\n        return \"\";\n    }\n    // Find closest\
    \ vowel for left and right edge\n    auto left_vowel = std::find(vowels.begin(),\
    \ vowels.end(), \n            static_cast<char>(std::distance(left_edge, right_edge)\
    \ - 1));\n    auto right_vowel = std::find(vowels.begin(), vowels.end(), \n  \
    \          static_cast<char>(std::distance(right_edge, left_edge) + 1));\n   \
    \ // Check if we have found any vowel, if not return empty string\n    if (left_vowel\
    \ == vowels.end() && right_vowel == vowels.end()) {\n        return \"\";\n  \
    \  }\n    // Check if we found two vowel, if it is not return empty string\n \
    \   if (left_vowel != vowels.end() && right_vowel != vowels.end()) {\n       \
    \ std::string vowel_left_right = std::to_string(vowel_left) + \n            std::to_string(vowel_right);\n\
    \        // Check left and right edge (make sure they are in consonant range)\n\
    \        if (right_edge == left_edge) {\n            return \"\";\n        }\n\
    \        // Find closest vowel for left and right edge\n        auto left_vowel_right\
    \ = std::find(vowels.begin(), vowels.end(), \n            static_cast<char>(std::distance(left_edge,\
    \ right_edge) - 1));\n        auto right_vowel_right = std::find(vowels.begin(),\
    \ vowels.end(), \n            static_cast<char>(std::distance(right_edge, left_edge)\
    \ + 1));\n        // Check if we have found any vowel, if not return empty string\n\
    \        if (left_vowel_right == vowels.end() && right_vowel_right == vowels.end())\
    \ {\n            return \"\";\n        }\n        // Check if we found two vowel,\
    \ if it is not return empty string\n        if (left_vowel_right != vowels.end()\
    \ && right_vowel_right != vowels.end()) {\n            if (left_vowel == left_vowel_right)\
    \ {\n                return vowel_left;\n            }\n            if (right_vowel\
    \ == right_vowel_right\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmsr4rhl9.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpmsr4rhl9.cpp:10:50: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   10 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n     \
    \ |                                                  ^\n      |              \
    \                                    |\n      |                              \
    \                    <brace-enclosed initializer list>\n/tmp/tmpmsr4rhl9.cpp:24:20:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<int*,\
    \ std::vector<int> > >\u2019 and \u2018__gnu_cxx::__normal_iterator<int*, std::vector<int>\
    \ >\u2019)\n   24 |     if (right_edge == left_edge) {\n      |         ~~~~~~~~~~\
    \ ^~ ~~~~~~~~~\n      |         |             |\n      |         |           \
    \  __gnu_cxx::__normal_iterator<int*, std::vector<int> >\n      |         std::reverse_iterator<__gnu_cxx::__normal_iterator<int*,\
    \ std::vector<int> > >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmsr4rhl9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpmsr4rhl9.cpp:24:23: note: \
    \  \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<int*, std::vector<int>\
    \ > >\u2019 is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL,"
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    \n    std::string vowel = \"AEIOUaeiou\"\
    ;\n    size_t vowel_pos = 0;\n    size_t pos = 0;\n    \n    for (size_t i = 0;\
    \ i < word.size() - 1; i++)\n    {\n        if (vowel.find(word[i]) != std::string::npos)\n\
    \        {\n            vowel_pos = i;\n            break;\n        }\n    }\n\
    \    \n    for (size_t i = word.size() - 1; i > word.size() - 1; i--)\n    {\n\
    \        if (vowel.find(word[i]) != std::string::npos)\n        {\n          \
    \  pos = i;\n            break;\n        }\n    }\n    \n    return word.substr(vowel_pos\
    \ + 1, pos - vowel_pos);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo_51vfcr: /tmp/tmpo_51vfcr.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string result = \"\";\n    int length = word.length();\n \
    \   // The left side of word.\n    std::string left_side = word;\n    // The right\
    \ side of word.\n    std::string right_side = word;\n    // Get the index of 'a'\
    \ character in the word.\n    int left_side_index = 0;\n    while (left_side_index\
    \ < length && left_side[left_side_index] != 'a')\n        left_side_index++;\n\
    \    int right_side_index = left_side_index;\n    while (right_side_index < length\
    \ && right_side[right_side_index] != 'a')\n        right_side_index++;\n    int\
    \ left_side_length = right_side_index - left_side_index;\n    // Get the count\
    \ of vowels in the left side.\n    int left_side_vowel_count = 0;\n    for (int\
    \ i = 0; i < left_side_length; i++) {\n        if (left_side[left_side_index +\
    \ i] != 'a' && left_side[left_side_index + i] != 'e' && left_side[left_side_index\
    \ + i] != 'i' && left_side[left_side_index + i] != 'o' && left_side[left_side_index\
    \ + i] != 'u')\n            left_side_vowel_count++;\n    }\n    int right_side_vowel_count\
    \ = 0;\n    for (int i = 0; i < right_side_length; i++) {\n        if (right_side[right_side_index\
    \ - i] != 'a' && right_side[right_side_index - i] != 'e' && right_side[right_side_index\
    \ - i] != 'i' && right_side[right_side_index - i] != 'o' && right_side[right_side_index\
    \ - i] != 'u')\n            right_side_vowel_count++;\n    }\n    if (left_side_vowel_count\
    \ == right_side_vowel_count)\n        return \"\";\n    if (left_side_vowel_count\
    \ > right_side_vowel_count)\n        return right_side;\n    return left_side;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpth6xbm0b.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpth6xbm0b.cpp:31:25: error: \u2018right_side_length\u2019 was not declared\
    \ in this scope; did you mean \u2018left_side_length\u2019?\n   31 |     for (int\
    \ i = 0; i < right_side_length; i++) {\n      |                         ^~~~~~~~~~~~~~~~~\n\
    \      |                         left_side_length\n"
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n        std::string vowels = \"aeiouAEIOU\";\n        bool check =\
    \ false;\n        auto it = word.rbegin();\n        while ((it != word.rend())\
    \ && !check) {\n            if (it != word.rend()) {\n                auto index\
    \ = it - word.begin() + 1;\n                bool found = false;\n            \
    \    for (auto j = 0; j < vowels.size(); j++) {\n                    if (index\
    \ > vowels.size() - j && index < (vowels.size() + j)) {\n                    \
    \    found = true;\n                    }\n                }\n               \
    \ if (found) {\n                    check = true;\n                }\n       \
    \     }\n        }\n        return \"\";\n    }\nint main() {\n    std::string\
    \ word = get_string(\"Enter a word: \");\n    std::string result = get_closest_vowel(word);\n\
    \    cout << result << endl;\n    return 0;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp45qcgj44.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp45qcgj44.cpp:15:33: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > >\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019})\n\
    \   15 |                 auto index = it - word.begin() + 1;\n      |        \
    \                      ~~ ^ ~~~~~~~~~~~~\n      |                            \
    \  |              |\n      |                              |              std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    \      |                              std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp45qcgj44.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:276:7:\
    \ note: candidate: \u2018constexpr std::reverse_iterator<_Iterator> std::reverse_iterator<_Iterator>::operator-(std::reverse_iterator<_Iterator>::difference_type)\
    \ const [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; std::reverse_iterator<_Iterator>::difference_type = long int]\u2019\n  276\
    \ |       operator-(difference_type __n) const\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:276:33:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >::difference_type\u2019 {aka \u2018long\
    \ int\u2019}\n  276 |       operator-(difference_type __n) const\n      |    "
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.size()>2);\n    int left = word.size();\n    while(\
    \ left > 1 ) {\n        left -= 2;\n        if( isupper(word[left-1]) && isupper(word[left])\
    \ ) {\n            if( islower(word[left-1]) && isupper(word[left+1]) ) {\n  \
    \              return word;\n            }\n        }\n    }\n    return \"\"\
    ; // not found\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp57r8u9i4: /tmp/tmp57r8u9i4.cpp:24: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowel{\"aeiou\"};\n    std::string::size_type vowel_pos\
    \ = std::find(word.rbegin(), word.rend(), vowel);\n    if (vowel_pos == word.rend())\
    \ {\n        return \"\";\n    }\n    std::string::size_type vowel_pos2 = std::find(word.rbegin(),\
    \ word.rend(), vowel.substr(1));\n    if (vowel_pos2 == word.rend()) {\n     \
    \   return \"\";\n    }\n    std::string::size_type vowel_pos3 = std::find(word.rbegin(),\
    \ word.rend(), vowel.substr(2));\n    if (vowel_pos3 == word.rend()) {\n     \
    \   return \"\";\n    }\n    if (vowel_pos - 2 > vowel_pos2 || vowel_pos - 2 >\
    \ vowel_pos3) {\n        return \"\";\n    }\n    if (vowel_pos + 2 >= word.rend())\
    \ {\n        return \"\";\n    }\n    if (vowel_pos2 + 2 >= word.rend()) {\n \
    \       return \"\";\n    }\n    if (vowel_pos3 + 2 >= word.rend()) {\n      \
    \  return \"\";\n    }\n    return word.substr(vowel_pos - 2, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa1yg9t8_.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpa1yg9t8_.cpp:11:49: error: cannot convert \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} in initialization\n   11 |     std::string::size_type\
    \ vowel_pos = std::find(word.rbegin(), word.rend(), vowel);\n      |         \
    \                               ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                 |\n      |          \
    \                                       std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\n/tmp/tmpa1yg9t8_.cpp:12:19: error: no\
    \ match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} and \u2018std::__cxx11::basic_string<char>::reverse_iterator\u2019\
    \ {aka \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > >\u2019})\n   12 |     if (vowel_pos == word.rend()) {\n      |         ~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~\n      |         |                     |\n      |         | \
    \                    std::__cxx11::basic_string<char>::reverse_iterator {aka std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >}\n      |         std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpa1yg9t8_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/t"
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_start\
    \ = vowels;\n    std::string vowels_end = vowels;\n    std::string vowels_both\
    \ = vowels_start + \"Y\" + vowels_end;\n    int vowels_len = vowels_both.length();\n\
    \    for (int i = 0; i < word.length(); i++) {\n        int idx = vowels_both.find(word[i]);\n\
    \        if (idx != -1) {\n            if (i - idx >= 0) {\n                int\
    \ vowels_diff = abs(i - idx);\n                if (vowels_diff < vowels_len) {\n\
    \                    vowels_both = vowels_both.substr(0, idx);\n             \
    \   }\n            }\n        }\n    }\n    return vowels_both;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpe3a1lngh: /tmp/tmpe3a1lngh.cpp:30: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if(word.length() < 3) return \"\";\n    std::string vowels = {\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"e\", \"a\", \"e\", \"o\", \"u\", \"\
    e\", \"i\", \"i\", \"i\", \"i\", \"o\", \"o\", \"o\", \"o\", \"o\", \"e\", \"\
    a\", \"a\", \"a\", \"e\", \"e\", \"e\", \"e\", \"i\", \"i\", \"i\", \"i\", \"\
    i\", \"e\", \"e\", \"e\", \"e\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"\
    o\", \"o\", \"o\", \"o\", \"o\", \"o\", \"u\", \"o\", \"u\"};\n    int m = word.length();\n\
    \    bool flag = false;\n    for(int i = 0; i < m; i++){\n        if(vowels.find(word[m\
    \ - i-1]) != string::npos){\n            flag = true;\n            break;\n  \
    \      }\n    }\n    if(flag){\n        return word;\n    }\n    std::string result\
    \ = \"\";\n    int l = word.length();\n    int n = word.length()-1;\n    for(int\
    \ i = 0; i < l; i++){\n        if(vowels.find(word[n - i]) != string::npos){\n\
    \            break;\n        }\n    }\n    for(int i = 0; i < l; i++){\n     \
    \   if(vowels.find(word[n + i]) != string::npos){\n            result = word;\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqu5p6yec.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpqu5p6yec.cpp:11:290: error: could not convert \u2018{\"a\", \"e\",\
    \ \"i\", \"o\", \"u\", \"y\", \"e\", \"a\", \"e\", \"o\", \"u\", \"e\", \"i\"\
    , \"i\", \"i\", \"i\", \"o\", \"o\", \"o\", \"o\", \"o\", \"e\", \"a\", \"a\"\
    , \"a\", \"e\", \"e\", \"e\", \"e\", \"i\", \"i\", \"i\", \"i\", \"i\", \"e\"\
    , \"e\", \"e\", \"e\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"o\", \"o\"\
    , \"o\", \"o\", \"o\", \"o\", \"u\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed\
    \ initializer list>\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   11 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    , \"e\", \"a\", \"e\", \"o\", \"u\", \"e\", \"i\", \"i\", \"i\", \"i\", \"o\"\
    , \"o\", \"o\", \"o\", \"o\", \"e\", \"a\", \"a\", \"a\", \"e\", \"e\", \"e\"\
    , \"e\", \"i\", \"i\", \"i\", \"i\", \"i\", \"e\", \"e\", \"e\", \"e\", \"i\"\
    , \"i\", \"i\", \"i\", \"i\", \"i\", \"o\", \"o\", \"o\", \"o\", \"o\", \"o\"\
    , \"u\", \"o\", \"u\"};\n      |                                             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                 ^\n      |                                                 \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \             |\n      |                                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \         <brace-enclosed initializer list>\n/tmp/tmpqu5p6yec.cpp:15:42: error:\
    \ \u2018string\u2019 has not been declared\n   15 |         if(vowels.find(word[m\
    \ - i-1]) != string::npos){\n      |                                         \
    \ ^~~~~~\n/tmp/tmpqu5p6yec.cpp:27:40: error: \u2018string\u2019 has not been declared\n\
    \   27 |         if(vowels.find(word[n "
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    if (word.empty()) return \"\";\n    int len = word.size();\n  \
    \  if (len <= 1) return \"\";\n    bool vowel[26] = {false};\n    for (int i =\
    \ 0; i < len - 1; i++) {\n        if (word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') vowel[tolower(word[i])] = true;\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') vowel[tolower(word[i])] = true;\n        if (word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\
    \ vowel[tolower(word[i])] = true;\n    }\n    char consonants[len];\n    for (int\
    \ i = 0; i < len; i++) {\n        consonants[i] = tolower(word[i]);\n    }\n \
    \   for (int i = 1; i < len; i++) {\n        if (vowel[consonants[i]]) {\n   \
    \         if (word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1]\
    \ == 'o' || word[i-1] == 'u') return word[i-1];\n            if (word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') return\
    \ word[i];\n            if (word[i+1] == 'a' || word[i+1] == 'e' || word[i+1]\
    \ == 'i' || word[i+1] == 'o' || word[i+1] == 'u') return word[i+1];\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr0kclpol.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpr0kclpol.cpp:25:130: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)(i\
    \ - 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   25 |             if (word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] ==\
    \ 'i' || word[i-1] == 'o' || word[i-1] == 'u') return word[i-1];\n      |    \
    \                                                                            \
    \                                                  ^\n      |                \
    \                                                                            \
    \                                      |\n      |                            \
    \                                                                            \
    \                          __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}\n/tmp/tmpr0kclpol.cpp:26:118: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   26 |             if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u') return word[i];\n      |              \
    \                                                                            \
    \                            ^\n      |                                      \
    \                                                                            \
    \    |\n      |                                                              \
    \                                                        __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n/tmp/tmpr0kclpol.cpp:27:130: error: could not\
    \ convert \u2018word.std::__cxx11::basic_string<char>::operat"
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowel;\n\tint start=0, end=word.length();\n\tbool flag=false;\n\
    \twhile(start<end) {\n\t\tchar ch = word[start];\n\t\tif (ch == 'a' || ch == 'e'\
    \ || ch == 'i' || ch == 'o' || ch == 'u') {\n\t\t\tflag = true;\n\t\t\tbreak;\n\
    \t\t}\n\t\tstart++;\n\t}\n\tif (!flag)\n\t\treturn \"\";\n\tstart = 0;\n\tend=\
    \ word.length();\n\twhile(start<end) {\n\t\tchar ch = word[end];\n\t\tif (ch ==\
    \ 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n\t\t\tflag = true;\n\
    \t\t\tbreak;\n\t\t}\n\t\tend--;\n\t}\n\tif (!flag)\n\t\treturn \"\";\n\tif (start\
    \ >= end)\n\t\treturn \"\";\n\tint mid_pos = word.length()/2;\n\tchar mid_ch =\
    \ word[mid_pos];\n\tstd::string temp;\n\tif (mid_ch == 'a' || mid_ch == 'e' ||\
    \ mid_ch == 'i' || mid_ch == 'o' || mid_ch == 'u') {\n\t\ttemp = word.substr(0,\
    \ mid_pos);\n\t} else {\n\t\ttemp = word.substr(mid_pos, word.length()-mid_pos);\n\
    \t}\n\tfor (int i=0; i<temp.length(); i++) {\n\t\tchar ch = temp[i];\n\t\tif (ch\
    \ == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n\t\t\treturn\
    \ temp;\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpqlp_jgkp: /tmp/tmpqlp_jgkp.cpp:55: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    size_t pos = word.size() - 1;\n  \
    \  int count = 0;\n    while (pos >= 0 && word[pos] != 'e' && word[pos] != 'i'\
    \ && word[pos] != 'o'\n        && word[pos] != 'u') {\n        pos--;\n      \
    \  count++;\n    }\n    if (pos < 0 && count > 0)\n        return \"\";\n    std::string\
    \ vowels = \"aeiouAEIOU\";\n    int index = std::distance(vowels.begin(), std::find(vowels.begin(),\
    \ vowels.end(), word[pos]));\n    while (index > 0) {\n        if (index > pos\
    \ - 1 && word[pos - 1] == word[index])\n            index--;\n        if (index\
    \ < pos + 1 && word[pos + 1] == word[index])\n            index++;\n    }\n  \
    \  return word[pos];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpapdbo4ai.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpapdbo4ai.cpp:28:20: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](pos)\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   28 |     return word[pos];\n      |                    ^\n      |      \
    \              |\n      |                    __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120393
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint left = 0, right = 0;\n\tstd::string vowels = \"\";\n\t\n\twhile(left\
    \ < word.length() && right < word.length()) {\n\t\tif(word[left] == 'a' || word[left]\
    \ == 'e' || word[left] == 'i'\n\t\t\t\t|| word[left] == 'o' || word[left] == 'u')\
    \ {\n\t\t\tleft += 1;\n\t\t\tvowels += word[left];\n\t\t}\n\t\tif(word[right]\
    \ == 'a' || word[right] == 'e' || word[right] == 'i'\n\t\t\t\t|| word[right] ==\
    \ 'o' || word[right] == 'u') {\n\t\t\tright += 1;\n\t\t\tvowels += word[right];\n\
    \t\t}\n\t}\n\t\n\tif(vowels.empty()) {\n\t\treturn \"\";\n\t}\n\t\n\treturn vowels;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660120398
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> vowels = { \"a\",\"e\",\"i\",\"o\",\"\
    u\",\"y\" };\n    std::string vowels_str = std::accumulate(vowels.begin(), vowels.end(),\
    \ \"a\");\n    std::string vowels_str_back = std::string(vowels_str.rbegin(),\
    \ vowels_str.rend());\n    std::transform(vowels_str.rbegin(), vowels_str.rend(),\
    \ vowels_str.rbegin(), ::tolower);\n    if (vowels_str == word) {\n        vowels_str\
    \ = vowels_str_back;\n    }\n    std::string vowel_str = std::accumulate(vowels.begin(),\
    \ vowels.end(), vowels_str, ::tolower);\n    std::transform(vowels.begin(), vowels.end(),\
    \ vowels.begin(), ::tolower);\n    if (vowel_str == word) {\n        vowel_str\
    \ = vowels_str;\n    }\n    std::string vowel_str_back = std::string(vowel_str.rbegin(),\
    \ vowel_str.rend());\n    std::transform(vowel_str.rbegin(), vowel_str.rend(),\
    \ vowel_str.rbegin(), ::tolower);\n    if (vowel_str == word) {\n        vowel_str\
    \ = vowel_str_back;\n    }\n    std::string vowel_str_back2 = std::string(vowel_str.rbegin(),\
    \ vowel_str.rend());\n    std::transform(vowel_str.rbegin(), vowel_str.rend(),\
    \ vowel_str.rbegin(), ::tolower);\n    if (vowel_str == word) {\n        vowel_str\
    \ = vowel_str_back2;\n    }\n    \n    std::string vowel_str_back3 = std::string(vowel_str.rbegin(),\
    \ vowel_str.rend());\n    std::transform(vowel_str.rbegin(), vowel_str.rend(),\
    \ vowel_str.rbegin(), ::tolower);\n    if (vowel_str == word) {\n        vowel_str\
    \ = vowel_str_back3;\n    }\n    \n    std::string vowel_str_back4 = std::string(vowel_str.rbegin(),\
    \ vowel_str.rend());\n    std::transform(vowel_str.rbegin(), vowel_str.rend(),\
    \ vowel_str.rbegin(), ::tolower);\n    if (vowel_str == word) {\n        vowel_str\
    \ = vowel_str_back4;\n    }\n    \n    std::string vowel_str_back5 = std::string(vowel_str.rbegin(),\
    \ vowel_str.rend());\n    std::transform(vowel_str.rbegin(), vowel_str.rend(),\
    \ vowel_str.rbegin(), ::tolower);\n    if (vowel_str == word) {\n        vowel_str\
    \ = vowel_str_back5;\n    }\n    \n    std::string vowel_str_back6 = std::string(vowel_str.rbegin\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1wcel3pf.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp1wcel3pf.cpp:51:46: error: expected primary-expression before \u2018\
    (\u2019 token\n   51 |     std::string vowel_str_back6 = std::string(vowel_str.rbegin\n\
    \      |                                              ^\n/tmp/tmp1wcel3pf.cpp:51:63:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   51 |     std::string\
    \ vowel_str_back6 = std::string(vowel_str.rbegin\n      |                    \
    \                          ~                ^\n      |                       \
    \                                        )\n   52 | }\n      | ~             \
    \                                                 \n/tmp/tmp1wcel3pf.cpp:52:1:\
    \ error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n\
    \   52 | }\n      | ^\n/tmp/tmp1wcel3pf.cpp:52:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\nIn file included from /usr/include/c++/9/numeric:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:84,\n\
    \                 from /tmp/tmp1wcel3pf.cpp:2:\n/usr/include/c++/9/bits/stl_numeric.h:\
    \ In instantiation of \u2018_Tp std::accumulate(_InputIterator, _InputIterator,\
    \ _Tp) [with _InputIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Tp = const char*]\u2019:\n\
    /tmp/tmp1wcel3pf.cpp:11:79:   required from here\n/usr/include/c++/9/bits/stl_numeric.h:139:9:\
    \ error: cannot convert \u2018std::__cxx11::basic_string<char>\u2019 to \u2018\
    const char*\u2019 in assignment\n  139 |  __init = _GLIBCXX_MOVE_IF_20(__init)\
    \ + *__first;\n      |  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_numeric.h:\
    \ In instantiation of \u2018_Tp std::accumulate(_InputIterator, _InputIterator,\
    \ _Tp, _BinaryOperation) [with _InputIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Tp = std::__cxx11::basic_string<char>;\
    \ _BinaryOperation = int (*)(int) noexcept]\u2019:\n/tmp/tmp1wcel3pf.cpp:17:96:\
    \   required from here\n/usr/inclu"
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n   \
    \ int leftConsonant = word.find_first_not_of(\"bcdfghjklmnopqrstuvwxyz\");\n \
    \   int rightConsonant = word.find_last_not_of(\"bcdfghjklmnopqrstuvwxyz\");\n\
    \    std::string retVal;\n    for(int i = rightConsonant; i >= leftConsonant &&\
    \ i >= 0; i--) {\n        if(std::find(vowels.begin(), vowels.end(), word[i])\
    \ != vowels.end())\n            retVal = word[i];\n    }\n    return retVal;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc3q5bw_a.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpc3q5bw_a.cpp:10:50: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   10 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n     \
    \ |                                                  ^\n      |              \
    \                                    |\n      |                              \
    \                    <brace-enclosed initializer list>\n"
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(word.size()%2 == 0);\n  int size = word.size();\n  std::string\
    \ res;\n  int start = 0;\n  while(start < size - 1) {\n    int end = size - 1;\n\
    \    if(end < start) {\n      end = start;\n    }\n    // Your code goes here.\
    \ \n    while(end > start) {\n      if(word[end-1] == 'a' || word[end-1] == 'e'\
    \ || word[end-1] == 'i' || word[end-1] == 'o' || word[end-1] == 'u') {\n     \
    \   return word;\n      }\n      end--;\n    }\n    start++;\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcmkbp6vr: /tmp/tmpcmkbp6vr.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n   assert(word == \"A\" ||\n           word == \"E\" ||\n         \
    \  word == \"I\" ||\n           word == \"O\" ||\n           word == \"U\");\n\
    \   \n   std::string::size_type pos = 0;\n   \n   std::string vowel(\"aeiouAEIOU\"\
    );\n   \n   while (pos < word.length() - 1) {\n       if (vowel.find(word.substr(pos\
    \ + 1)) != std::string::npos) {\n           pos += 2;\n       }\n       else {\n\
    \           pos += 1;\n       }\n   \n   }\n   return std::string(word.rbegin(),\
    \ word.rend() + pos + 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd_3vw3th: /tmp/tmpd_3vw3th.cpp:10: std::string get_closest_vowel(std::string):
    Assertion `word == "A" || word == "E" || word == "I" || word == "O" || word ==
    "U"'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    int n = word.size();\n    std::string\
    \ vowel;\n    std::string result = \"\";\n    int begin = 0, end = 0;\n    for\
    \ (int i = 0; i < n; ++i) {\n        char ch = word[i];\n        if (ch == 'a'\
    \ || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'y') {\n      \
    \      begin = i;\n        }\n        if (ch == 'A' || ch == 'E' || ch == 'I'\
    \ || ch == 'O' || ch == 'U' || ch == 'Y') {\n            end = i;\n        }\n\
    \    }\n\n    for (int i = end; i >= begin; --i) {\n        char ch = word[i];\n\
    \        if (ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' &&\
    \ ch != 'y') {\n            vowel += ch;\n        }\n    }\n\n    int a = vowel.size();\n\
    \    if (a >= 2) {\n        return vowel;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxc8f9b_0: /tmp/tmpxc8f9b_0.cpp:40: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    char consonants[] = {'a', 'e', 'i', 'o', 'u', 'y', 'k', 'h', 'b',\
    \ 'r', 'd', 'f', 'p', 'q', 'j', 'm', 't', 'l', 's', 'y', 'v', 'c', 'w'};\n   \
    \ char vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };\n    int n = word.size();\n\
    \    int ls = 0, rs = 0;\n    for (int i = 0; i < n; i++) {\n        if (word[i]\
    \ == consonants[ls]) {\n            ls = ls + 1;\n        } else if (word[i] ==\
    \ consonants[rs]) {\n            rs = rs + 1;\n        } else {\n            int\
    \ d = (rs - ls + 1);\n            int min = d;\n            for (int j = 0; j\
    \ < d; j++) {\n                if (word[i] == vowels[j]) {\n                 \
    \   if (d < min) {\n                        min = d;\n                       \
    \ break;\n                    }\n                }\n            }\n          \
    \  if (d == min) {\n                return word;\n            } else {\n     \
    \           ls = 0;\n                rs = 0;\n            }\n        }\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6dosrxw4: /tmp/tmp6dosrxw4.cpp:42: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::stack<char> vowels;\n    for(int i=word.length()-1; i>=0;\
    \ --i) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' ) {\n            vowels.push(word[i]);\n        }\n\
    \    }\n    while(vowels.size() > 1) {\n        char c = vowels.top();\n     \
    \   vowels.pop();\n        char d = vowels.top();\n        vowels.pop();\n   \
    \     if(c != d) {\n            return c;\n        }\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgtn_fza4.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpgtn_fza4.cpp:22:20: error: could not convert \u2018c\u2019 from \u2018\
    char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   22 |             return c;\n      |                    ^\n      |      \
    \              |\n      |                    char\n"
  stdout: ''
  timestamp: 1660120393
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // You can do your work here\n  assert(word.size() > 0);\n  std::string\
    \ vowel{\"aeiouAEIOU\"};\n  std::vector<std::string> vowels{vowel.begin(), vowel.end()};\n\
    \  for (int i = word.size()-1; i >= 0; --i) {\n    int j = 0;\n    while (vowels[j]\
    \ < word[i]) {\n      ++j;\n    }\n    if (j >= vowels.size()) return \"\";\n\
    \    if (word[i] == vowels[j]) {\n      if (i == 0 || i == word.size() || word[i-1]\
    \ == word[i]) break;\n      j = vowels.size() - 1;\n    }\n  }\n  return vowel.substr(j+1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfdt_s_vv.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpfdt_s_vv.cpp:16:22: error: no match for \u2018operator<\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   16 |     while (vowels[j] < word[i]) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfdt_s_vv.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpfdt_s_vv.cpp:16:30:\
    \ note:   \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |     while (vowels[j] < word[i]) {\n      |                              ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfdt_s_vv.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ fa"
  stdout: ''
  timestamp: 1660120393
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\nassert(word.size() == 12); // English letters only\n    for(int i=12;i>=0;i--)\n\
    \    {\n        if(word[i] == 'A' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u')\n        {\n            for(int j=i;j<12;j++)\n  \
    \          {\n                word[j]=word[j+1];\n            }\n            for(int\
    \ k=0; k<word.length()-1;k++)\n            {\n                if(word[k] == word[k+1]\
    \ && word[k+1] != word[k+2])\n                {\n                    return word;\n\
    \                }\n            }\n        }\n    }\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprfvmjsw3: /tmp/tmprfvmjsw3.cpp:10: std::string get_closest_vowel(std::string):
    Assertion `word.size() == 12'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    std::string vowels = \"AEIOUaeiou\";\n    std::unordered_map<char,\
    \ int> counts; \n    for (auto c : word) {\n        int count = counts[c]++;\n\
    \        \n    }\n    int left = 0, right = (int)word.size();\n    while (left\
    \ < right) {\n        int mid = (left + right) / 2;\n        \n        if (counts[word[mid]]\
    \ == 1) {\n            left = mid;\n        } else if (counts[word[mid]] == 0)\
    \ {\n            right = mid;\n        } else {\n            char closest_vowel\
    \ = word[mid];\n            int current_dist = abs((int)closest_vowel - 97);\n\
    \            while (current_dist < abs((int)word[mid] - closest_vowel)) {\n  \
    \              closest_vowel = word[mid];\n                current_dist = abs((int)closest_vowel\
    \ - 97);\n                mid = (mid + 1 + right) / 2;\n            }\n      \
    \      return closest_vowel;\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuebkvidb.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpuebkvidb.cpp:33:20: error: could not convert \u2018closest_vowel\u2019\
    \ from \u2018char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   33 |             return closest_vowel;\n      |                    ^~~~~~~~~~~~~\n\
    \      |                    |\n      |                    char\n"
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int size = word.length();\n    bool flag = false;\n    int begin\
    \ = -1, end = -1;\n    int cnt = 0;\n    \n    //  Find the first consonant from\
    \ the right side.\n    for (int i = size - 1; i >= 0; --i) {\n        flag = false;\n\
    \        char c = word[i];\n        if (c == 'z')\n            continue;\n   \
    \     if (word[i] >= 'a' && word[i] <= 'z')\n            begin = i;\n        else\n\
    \            end = i;\n        break;\n    }\n\n    if (begin == -1) {\n     \
    \   return \"Not found\";\n    }\n\n    //  Find the vowel before the begin.\n\
    \    for (int i = begin + 1; i < size; ++i) {\n        flag = false;\n       \
    \ char c = word[i];\n        if (c == 'z')\n            continue;\n        if\
    \ (word[i] >= 'a' && word[i] <= 'z')\n            end = i;\n        else\n   \
    \         begin = i;\n        break;\n    }\n\n    //  Find the vowel after the\
    \ end.\n    for (int i = end + 1; i < size; ++i) {\n        flag = false;\n  \
    \      char c = word[i];\n        if (c == 'z')\n            continue;\n     \
    \   if (word[i] >= 'a' && word[i] <= 'z')\n            begin = i;\n        else\n\
    \            end = i;\n        break;\n    }\n\n    //  Find the closest vowel.\n\
    \    for (int i = begin; i <= end; ++i) {\n        flag = false;\n        char\
    \ c = word[i];\n        if (c == 'z')\n            continue;\n        if (word[i]\
    \ >= 'a' && word[i] <= 'z')\n            cnt = i;\n        else\n            break;\n\
    \    }\n\n    if (cnt == begin)\n        return \"\";\n    else if (cnt == end)\n\
    \        return word;\n    else\n        return word.substr(cnt, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_4uxcsdv: /tmp/tmp_4uxcsdv.cpp:79: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Complete the function here\n   if(word.length()==0)\n      \
    \  return \"\";\n    for(int i=0;i<word.length();i++){\n        if(word[i]==='a'||word[i]==='e'||word[i]==='i'||word[i]==='o'||word[i]==='u'){\n\
    \            for(int j=i;j<word.length();j++){\n                if(word[j]==='a'||word[j]==='e'||word[j]==='i'||word[j]==='o'||word[j]==='u')\n\
    \                    return word[j];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpknsjqpvc.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpknsjqpvc.cpp:14:21: error: expected primary-expression before \u2018\
    =\u2019 token\n   14 |         if(word[i]==='a'||word[i]==='e'||word[i]==='i'||word[i]==='o'||word[i]==='u'){\n\
    \      |                     ^\n/tmp/tmpknsjqpvc.cpp:14:36: error: expected primary-expression\
    \ before \u2018=\u2019 token\n   14 |         if(word[i]==='a'||word[i]==='e'||word[i]==='i'||word[i]==='o'||word[i]==='u'){\n\
    \      |                                    ^\n/tmp/tmpknsjqpvc.cpp:14:51: error:\
    \ expected primary-expression before \u2018=\u2019 token\n   14 |         if(word[i]==='a'||word[i]==='e'||word[i]==='i'||word[i]==='o'||word[i]==='u'){\n\
    \      |                                                   ^\n/tmp/tmpknsjqpvc.cpp:14:66:\
    \ error: expected primary-expression before \u2018=\u2019 token\n   14 |     \
    \    if(word[i]==='a'||word[i]==='e'||word[i]==='i'||word[i]==='o'||word[i]==='u'){\n\
    \      |                                                                  ^\n\
    /tmp/tmpknsjqpvc.cpp:14:81: error: expected primary-expression before \u2018=\u2019\
    \ token\n   14 |         if(word[i]==='a'||word[i]==='e'||word[i]==='i'||word[i]==='o'||word[i]==='u'){\n\
    \      |                                                                     \
    \            ^\n/tmp/tmpknsjqpvc.cpp:16:29: error: expected primary-expression\
    \ before \u2018=\u2019 token\n   16 |                 if(word[j]==='a'||word[j]==='e'||word[j]==='i'||word[j]==='o'||word[j]==='u')\n\
    \      |                             ^\n/tmp/tmpknsjqpvc.cpp:16:44: error: expected\
    \ primary-expression before \u2018=\u2019 token\n   16 |                 if(word[j]==='a'||word[j]==='e'||word[j]==='i'||word[j]==='o'||word[j]==='u')\n\
    \      |                                            ^\n/tmp/tmpknsjqpvc.cpp:16:59:\
    \ error: expected primary-expression before \u2018=\u2019 token\n   16 |     \
    \            if(word[j]==='a'||word[j]==='e'||word[j]==='i'||word[j]==='o'||word[j]==='u')\n\
    \      |                                                           ^\n/tmp/tmpknsjqpvc.cpp:16:74:\
    \ error: expected primary-"
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<std::string> vowels = { 'a', 'e', 'i', 'o', 'u' };\n\
    \    auto it = std::search(std::begin(word), std::end(word), std::begin(vowels),\
    \ std::end(vowels));\n    if (it != std::end(word)) {\n        auto i1 = std::find(std::begin(word),\
    \ std::end(word), '.');\n        if (i1 != std::end(word)) {\n            auto\
    \ i2 = std::find(i1, std::end(word), '.');\n            if (i2 != std::end(word))\
    \ {\n                return word;\n            }\n        }\n    }\n    return\
    \ std::string();\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_fyj_yzu.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp_fyj_yzu.cpp:10:65: error: could not convert \u2018{'a', 'e', 'i',\
    \ 'o', 'u'}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to \u2018\
    std::vector<std::__cxx11::basic_string<char> >\u2019\n   10 |     std::vector<std::string>\
    \ vowels = { 'a', 'e', 'i', 'o', 'u' };\n      |                             \
    \                                    ^\n      |                              \
    \                                   |\n      |                               \
    \                                  <brace-enclosed initializer list>\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp_fyj_yzu.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equal_to_iter::operator()(_Iterator1,\
    \ _Iterator2) const [with _Iterator1 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Iterator2 = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:237:22:\
    \   required from \u2018_ForwardIterator1 std::__search(_ForwardIterator1, _ForwardIterator1,\
    \ _ForwardIterator2, _ForwardIterator2, _BinaryPredicate) [with _ForwardIterator1\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _ForwardIterator2\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _BinaryPredicate = __gnu_cxx::__ops::_Iter_equal_to_iter]\u2019\n/usr/include/c++/9/bits/stl_algo.h:4188:27:\
    \   required from \u2018_FIter1 std::search(_FIter1, _FIter1, _FIter2, _FIter2)\
    \ [with _FIter1 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _FIter2 = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std"
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels(\"aeiouAEIOU\");\n    std::string ans = word;\n\
    \    auto vowels_found = std::find(vowels.begin(), vowels.end(), word[0]);\n \
    \   if (vowels_found != vowels.end()) {\n        ans[0] = vowels[vowels_found];\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_u2r9kth.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp_u2r9kth.cpp:14:24: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019)\n   14 |         ans[0] = vowels[vowels_found];\n      |          \
    \              ^\nIn file included from /usr/include/c++/9/string:55,\n      \
    \           from /usr/include/c++/9/bits/locale_classes.h:40,\n              \
    \   from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_u2r9kth.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1050:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator[](std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ = const char&; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1050 |       operator[] (size_type __pos) const\
    \ _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1050:29:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 1050 |       operator[] (size_type __pos)\
    \ const _GLIBCXX_NOEXCEPT\n      |                   ~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/basic_string.h:1067:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits"
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int left = 0, right = word.length(), mid;\n    std::string result\
    \ = \"\";\n    while (left <= right) {\n        mid = left + (right - left) /\
    \ 2;\n        if (word[mid] in {\"a\", \"e\", \"i\", \"o\", \"u\"}) {\n      \
    \      result = word[mid];\n            right = mid - 1;\n        } else {\n \
    \           left = mid + 1;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0drw8mlv.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp0drw8mlv.cpp:14:22: error: expected \u2018)\u2019 before \u2018in\u2019\
    \n   14 |         if (word[mid] in {\"a\", \"e\", \"i\", \"o\", \"u\"}) {\n  \
    \    |            ~         ^~~\n      |                      )\n"
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // your code goes here\n  if(word.length()<3)\n    return \"\";\n\
    \  \n  assert(word.length()>0);\n  assert(word[0]!='a' && word[0]!='e' && word[0]!='i'\
    \ && word[0]!='o' &&\n          word[0]!='u' && word[0]!='A' && word[0]!='E' &&\
    \ word[0]!='I' &&\n          word[0]!='O' && word[0]!='U');\n  \n  if(word[word.length()-1]=='a'\
    \ || word[word.length()-1]=='e' ||\n     word[word.length()-1]=='i' || word[word.length()-1]=='o'\
    \ ||\n     word[word.length()-1]=='u' || word[word.length()-1]=='A' ||\n     word[word.length()-1]=='E'\
    \ || word[word.length()-1]=='I' ||\n     word[word.length()-1]=='O' || word[word.length()-1]=='U')\n\
    \    return \"\";\n  \n  for(int i=word.length()-2; i>0; i-=2)\n  {\n    if(word[i]=='a'\
    \ || word[i]=='e' || word[i]=='i' || word[i]=='o' ||\n       word[i]=='u' || word[i]=='A'\
    \ || word[i]=='E' || word[i]=='I' ||\n       word[i]=='O' || word[i]=='U')\n \
    \     return word+\".\";\n  }\n  \n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8p88u3ur: /tmp/tmp8p88u3ur.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowel_counter = 0;\n    for (int i = word.length() - 1; i >=\
    \ 0; i--) {\n        if (std::isalpha(word[i]) && std::toupper(word[i]) == 'A')\
    \ {\n            vowel_counter++;\n        }\n    }\n    int vowel_counter_right\
    \ = vowel_counter;\n    for (int i = 1; i < word.length(); i++) {\n        if\
    \ (std::isalpha(word[i]) && std::toupper(word[i]) == 'A') {\n            vowel_counter_right--;\n\
    \        }\n    }\n    if (vowel_counter_right == 0) {\n        return word;\n\
    \    }\n    int vowel_counter_left = vowel_counter;\n    for (int i = word.length()\
    \ - 2; i >= 0; i--) {\n        if (std::isalpha(word[i]) && std::toupper(word[i])\
    \ == 'A') {\n            vowel_counter_left++;\n        }\n    }\n    if (vowel_counter_left\
    \ == 0) {\n        return word;\n    }\n    int vowel_counter_left_right = vowel_counter;\n\
    \    for (int i = 1; i < word.length(); i++) {\n        if (std::isalpha(word[i])\
    \ && std::toupper(word[i]) == 'A') {\n            vowel_counter_left_right--;\n\
    \        }\n    }\n    if (vowel_counter_left_right == 0) {\n        return word;\n\
    \    }\n    int vowel_counter_lbound = 0;\n    for (int i = 1; i < word.length();\
    \ i++) {\n        if (std::isalpha(word[i]) && std::toupper(word[i]) == 'A') {\n\
    \            vowel_counter_lbound++;\n        }\n    }\n    if (vowel_counter_lbound\
    \ == 0) {\n        return word;\n    }\n    int vowel_counter_rbound = 0;\n  \
    \  for (int i = word.length() - 1; i >= 0; i--) {\n        if (std::isalpha(word[i])\
    \ && std::toupper(word[i]) == 'A') {\n            vowel_counter_rbound++;\n  \
    \      }\n    }\n    if (vowel_counter_rbound == 0) {\n        return word;\n\
    \    }\n    int consonant_counter = 0;\n    for (int i = word.length() - 1; i\
    \ >= 0; i--) {\n        if (std::isalpha(word[i]) && std::toupper(word[i]) ==\
    \ 'Z') {\n            consonant_counter++;\n        }\n    }\n    if (consonant_counter\
    \ == 0) {\n        return word;\n    }\n    int consonant_counter_right = consonant_counter;\n\
    \    for (int i = 1; i < word.length(); i++) {\n        if (std::isalpha(word[i])\
    \ && std::toupper(word[i]) == 'Z') {\n            consonant_counter_right--;\n\
    \        }\n    }\n    if (consonant_counter_right == 0) {\n        return word;\n\
    \    }\n    int consonant_counter_left = consonant_counter;\n    for (int i =\
    \ word.length() - 2; i >= \n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv4phnob9.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpv4phnob9.cpp:81:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   81 | }\n      | ^\n/tmp/tmpv4phnob9.cpp:80:41: error: expected\
    \ \u2018;\u2019 before \u2018}\u2019 token\n   80 |     for (int i = word.length()\
    \ - 2; i >=\n      |                                         ^\n      |      \
    \                                   ;\n   81 | }\n      | ~                  \
    \                      \n/tmp/tmpv4phnob9.cpp:81:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   81 | }\n      | ^\n/tmp/tmpv4phnob9.cpp:80:41:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   80 |     for (int\
    \ i = word.length() - 2; i >=\n      |         ~                             \
    \  ^\n      |                                         )\n   81 | }\n      | ~\
    \                                        \n/tmp/tmpv4phnob9.cpp:81:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   81 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string vowel_letter\
    \ = \"\";\n  // find vowel letter between the first and last consonant\n  int\
    \ index = word.find_first_not_of(vowels, 0);\n  int index_last = word.find_last_not_of(vowels,\
    \ 0);\n  if(index != -1 && index_last != -1){\n    // move right by one consonant\n\
    \    word = word.substr(index + 1, index_last - index - 1);\n    // find vowel\
    \ letter between the first and last consonant\n    index = word.find_first_not_of(vowels,\
    \ 0);\n    index_last = word.find_last_not_of(vowels, 0);\n    // search again\
    \ from index last + 1 till the first vowel letter\n    while(index != -1 && index_last\
    \ != -1){\n      // if the first vowel letter before the found consonant is different\
    \ from the vowel letter before the found consonant,\n      // then store the vowel\
    \ letter as the closest vowel\n      if(vowels[index] != vowels[index_last]){\n\
    \        vowel_letter = vowels[index];\n      }\n      // move right by one consonant\n\
    \      word = word.substr(index + 1, index_last - index - 1);\n      // find vowel\
    \ letter between the first and last consonant\n      index = word.find_first_not_of(vowels,\
    \ 0);\n      index_last = word.find_last_not_of(vowels, 0);\n    }\n  }\n  return\
    \ vowel_letter;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n  \
    \  assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpm2ryqcvq: /tmp/tmpm2ryqcvq.cpp:39: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120395
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    return \"\";\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssug5_n6: /tmp/tmpssug5_n6.cpp:15: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\"};\n    \n    int len = word.length();\n    \n   \
    \ int i = len - 1;\n    int j = len - 1;\n    int min_diff = INT_MAX;\n    std::string\
    \ res;\n    \n    // Find the minimum diff between 2 consonants\n    while (i\
    \ >= 0 && j >= 0) {\n        if (word[i] == word[j]) {\n            int diff =\
    \ abs(i - j);\n            if (diff < min_diff) {\n                res = word[j];\n\
    \                min_diff = diff;\n            }\n            \n            i--;\n\
    \            j--;\n        } else if (word[i] != word[j]) {\n            j = i\
    \ - 1;\n        }\n    }\n    \n    if (min_diff == 0) {\n        res = \"\";\n\
    \    }\n    \n    return res;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9qia3kfb.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp9qia3kfb.cpp:10:75: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\u2019 from \u2018<brace-enclosed\
    \ initializer list>\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   10 |     std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\"};\n      |                                      \
    \                                     ^\n      |                             \
    \                                              |\n      |                    \
    \                                                       <brace-enclosed initializer\
    \ list>\n"
  stdout: ''
  timestamp: 1660120394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(word.size() >= 2);\n  \n  //initialize a vector to store all\
    \ vowels found\n  std::vector<int> vowels;\n  int vowel;\n  \n  //add all vowels\
    \ found in word to vector\n  for (int i = 0; i < (int)word.size() - 1; ++i) {\n\
    \    //find the vowel\n    vowel = static_cast<int>(word[i]);\n    if (vowel >=\
    \ 'a' && vowel <= 'z') {\n      vowels.push_back(vowel);\n    }\n  }\n  \n  //remove\
    \ all vowels from the vector except the first\n  vowels.erase(vowels.begin() +\
    \ 1);\n  \n  //return the closest vowel\n  return std::to_string(vowels[vowels.size()\
    \ / 2]);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpfztumrq1: /tmp/tmpfztumrq1.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n//your code goes here\nassert(word.size()==5);\nassert(word[0]=='a');\n\
    assert(word[1]=='e');\nassert(word[2]=='i');\nassert(word[3]=='o');\nassert(word[4]=='u');\n\
    int cnt = 0;\nfor (int i=5;i>0;i--){\n    if(word[i]>word[i-1] && word[i]>word[i+1]){\n\
    \        cnt+=1;\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1lsjqah6.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp1lsjqah6.cpp:23:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   23 | int main() {\n      |            ^\n/tmp/tmp1lsjqah6.cpp:38:1:\
    \ error: expected \u2018}\u2019 at end of input\n   38 | }\n      | ^\n/tmp/tmp1lsjqah6.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmp1lsjqah6.cpp:38:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   38 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n \n    for(int i = 1; i < word.length(); i++) {\n        char a = word[i\
    \ - 1];\n        char b = word[i];\n        if (a >= 'a' && a <= 'z' || a >= 'A'\
    \ && a <= 'Z' || b >= 'a' && b <= 'z' || b >= 'A' && b <= 'Z') {\n           \
    \ return word;\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5qlehm1y: /tmp/tmp5qlehm1y.cpp:22: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouyAEIOUY\";\n    std::string new_vowels\
    \ = \"\";\n    int count = 0;\n    // Find the right side of word\n    for (int\
    \ i = word.length() - 1; i >= 0; i--) {\n        if (word[i] == word[i][0]) {\n\
    \            count++;\n            if (count == 2) {\n                new_vowels\
    \ += word[i];\n            }\n        } else if (count == 0 && word[i] != word[i][0])\
    \ {\n            count++;\n        }\n    }\n    // Find the vowel that is closest\
    \ to the left side of word\n    // Vowels inside the word count as 1, vowels outside\
    \ as -1\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (word[i]\
    \ == word[i][0]) {\n            if (count >= 1) {\n                new_vowels\
    \ += word[i];\n            }\n        } else if (count < -1) {\n            if\
    \ (word[i] != word[i][0]) {\n                new_vowels += word[i];\n        \
    \    }\n        }\n    }\n    // Return the closest vowel\n    return new_vowels;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptrf8qmr3.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmptrf8qmr3.cpp:15:33: error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}[int]\u2019 for array subscript\n   15 |       \
    \  if (word[i] == word[i][0]) {\n      |                                 ^\n/tmp/tmptrf8qmr3.cpp:20:54:\
    \ error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}[int]\u2019 for array subscript\n   20 |         } else if (count\
    \ == 0 && word[i] != word[i][0]) {\n      |                                  \
    \                    ^\n/tmp/tmptrf8qmr3.cpp:27:33: error: invalid types \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}[int]\u2019\
    \ for array subscript\n   27 |         if (word[i] == word[i][0]) {\n      | \
    \                                ^\n/tmp/tmptrf8qmr3.cpp:32:37: error: invalid\
    \ types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}[int]\u2019 for array subscript\n   32 |             if (word[i] !=\
    \ word[i][0]) {\n      |                                     ^\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::unordered_map<int, std::string>\
    \ m;\n    int index = 0;\n    for (int i = word.length()-1;i>=1;i--) {\n     \
    \   if(m.find(index)!=m.end()){\n            return m.at(index);\n        }\n\
    \        char c = word[i];\n        index = std::distance(word.begin(),std::find(word.begin(),\
    \ word.end(), c));\n        m[index] = c;\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgk9gcktt: /tmp/tmpgk9gcktt.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120395
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    size_t pos1 = 0, pos2\
    \ = 0;\n    size_t vowel_start = 0, vowel_end = 0;\n    std::string ans = \"\"\
    ;\n    for (auto ch : word) {\n        if (vowels.find(ch) != std::string::npos)\
    \ {\n            vowel_start = pos2;\n            vowel_end = pos1;\n        }\n\
    \        pos2 = pos1 + 1;\n        pos1 = pos2;\n    }\n    if (vowel_start !=\
    \ 0) {\n        ans = word.substr(vowel_start, vowel_end - vowel_start + 1);\n\
    \    } else {\n        ans = word;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwlg0sgr1: /tmp/tmpwlg0sgr1.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ans = \"VOWEL_NOT_FOUND\";\n    int len = word.length();\n\
    \    if(len>3 && word[0]=='A' && word[len-1]=='O' && word[len-2]=='O') { // vowel\
    \ stands right between two consonants\n        for(int i=len-1; i>0; i--) {\n\
    \            if(word[i]=='A' || word[i]=='E' || word[i]=='I' || word[i]=='O' ||\
    \ word[i]=='U' || word[i]=='Y') {\n                ans = word[i];\n          \
    \      break;\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp70aq5c8u: /tmp/tmp70aq5c8u.cpp:24: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120395
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  int len = word.length();\n  int vowel_count = 0;\n  std::string vowels\
    \ = \"aeiou\";\n  for (int i = (len - 1); i >= 0; i--) {\n    if (vowels.find(word[i])\
    \ != std::string::npos) {\n      vowel_count++;\n    }\n  }\n  if (vowel_count\
    \ == 0) {\n    return \"\";\n  }\n  int i = 0;\n  int j = (len - vowel_count +\
    \ 1);\n  int k;\n  std::string closest_vowel = \"\";\n  while (i<j) {\n    for\
    \ (k = i; k < j; k++) {\n      if (word[k] == 'a' || word[k] == 'e' || word[k]\
    \ == 'i' || word[k] == 'o' || word[k] == 'u')\n        j--;\n    }\n    closest_vowel.push_back(word[i]);\n\
    \    i++;\n  }\n  return closest_vowel;\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8ayve3zb: /tmp/tmp8ayve3zb.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  for(int i=word.size()-1;i>=2;i--)\n  {\n    if(word[i]==\"a\" ||\
    \ word[i]==\"e\" || word[i]==\"i\" || word[i]==\"o\" || word[i]==\"u\")\n    {\n\
    \      return word;\n    }\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp23d3ox1q.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp23d3ox1q.cpp:12:17: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n   12 |     if(word[i]==\"a\" || word[i]==\"e\"\
    \ || word[i]==\"i\" || word[i]==\"o\" || word[i]==\"u\")\n      |            \
    \     ^~~\n/tmp/tmp23d3ox1q.cpp:12:33: error: ISO C++ forbids comparison between\
    \ pointer and integer [-fpermissive]\n   12 |     if(word[i]==\"a\" || word[i]==\"\
    e\" || word[i]==\"i\" || word[i]==\"o\" || word[i]==\"u\")\n      |          \
    \                       ^~~\n/tmp/tmp23d3ox1q.cpp:12:49: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   12 |     if(word[i]==\"\
    a\" || word[i]==\"e\" || word[i]==\"i\" || word[i]==\"o\" || word[i]==\"u\")\n\
    \      |                                                 ^~~\n/tmp/tmp23d3ox1q.cpp:12:65:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   12 |     if(word[i]==\"a\" || word[i]==\"e\" || word[i]==\"i\" || word[i]==\"\
    o\" || word[i]==\"u\")\n      |                                              \
    \                   ^~~\n/tmp/tmp23d3ox1q.cpp:12:81: error: ISO C++ forbids comparison\
    \ between pointer and integer [-fpermissive]\n   12 |     if(word[i]==\"a\" ||\
    \ word[i]==\"e\" || word[i]==\"i\" || word[i]==\"o\" || word[i]==\"u\")\n    \
    \  |                                                                         \
    \        ^~~\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::vector<char> vowels;\n    vowels.push_back('a');\n    vowels.push_back('e');\n\
    \    vowels.push_back('i');\n    vowels.push_back('o');\n    vowels.push_back('u');\n\
    \n    for(auto c : word)\n    {\n        if(std::find(vowels.begin(), vowels.end(),\
    \ c) != vowels.end())\n        {\n            return c;\n        }\n    }\n\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp9qxui86.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpp9qxui86.cpp:21:20: error: could not convert \u2018c\u2019 from \u2018\
    char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   21 |             return c;\n      |                    ^\n      |      \
    \              |\n      |                    char\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ans = \"\";\n    int start = 0;\n    int end = word.size()\
    \ - 1;\n    while (start <= end) {\n        std::string vowel = \"aeiou\";\n \
    \       for (int i = 0; i < vowel.size(); i++) {\n            int index = word[start\
    \ + i] - 'a';\n            if (index >= 0 && index <= 2 && index != 3) {\n   \
    \             ans = vowel[i];\n                break;\n            }\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660120400
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    bool found_vowel = false;\n    std::string\
    \ vowel = \"AEIOUaeiou\";\n    int pos = 0;\n    std::string vowel_candidate =\
    \ \"\";\n    for(auto i : word) {\n        pos = word.rfind(vowel, pos);\n   \
    \     if(pos > 0) {\n            found_vowel = true;\n        }\n        if(pos\
    \ < 0) {\n            pos = 0;\n        }\n        pos += vowel.size();\n    }\n\
    \    if(found_vowel) {\n        vowel_candidate = word;\n        word = word.substr(pos);\n\
    \    }\n    return word;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd1tyrulz: /tmp/tmpd1tyrulz.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    for(int i=word.size();i>0;i--){\n        if(word[i] == 'a'||word[i]\
    \ == 'e'||word[i] == 'i'||word[i] == 'o'||word[i] == 'u'){\n            for(int\
    \ j=i;j<word.size();j++){\n                if(word[j] == 'a'||word[j] == 'e'||word[j]\
    \ == 'i'||word[j] == 'o'||word[j] == 'u'){\n                    word[j+1] = word[j];\n\
    \                }\n            }\n        }\n    }\n    std::string vowels =\
    \ \"\";\n    for(int i=word.size();i>0;i--){\n        if(word[i] == 'a'||word[i]\
    \ == 'e'||word[i] == 'i'||word[i] == 'o'||word[i] == 'u'){\n            vowels\
    \ += word[i];\n            word = word.substr(0,i)+word.substr(i+1);\n       \
    \ }\n    }\n    return vowels;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 7) > this->size() (which is 6)\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = { \"a\",\"e\",\"i\",\"o\",\"u\" };\n    std::string\
    \ result; \n    for(int i = word.size() - 1; i >= 0; i--) {\n        int count\
    \ = 0;\n        for(int j = 0; j < vowels.size(); j++) {\n            if(word[i]\
    \ == vowels[j]) {\n                count++;\n            }\n        }\n      \
    \  if(count == 0) {\n            continue;\n        }\n        if(count > 1) {\n\
    \            continue;\n        }\n        for(int j = 0; j < word.size(); j++)\
    \ {\n            if(word[i] == word[j]) {\n                break;\n          \
    \  }\n        }\n        int dist = abs(i - j);\n        if(dist < result.size())\
    \ {\n            std::string temp = result;\n            result = word;\n    \
    \        result = temp;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiu52e3d7.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpiu52e3d7.cpp:10:48: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\u2019 from \u2018<brace-enclosed initializer list>\u2019 to\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n\
    \   10 |     std::string vowels = { \"a\",\"e\",\"i\",\"o\",\"u\" };\n      |\
    \                                                ^\n      |                  \
    \                              |\n      |                                    \
    \            <brace-enclosed initializer list>\n/tmp/tmpiu52e3d7.cpp:30:28: error:\
    \ \u2018j\u2019 was not declared in this scope\n   30 |         int dist = abs(i\
    \ - j);\n      |                            ^\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::map<char,int> vowels;\n    for(int i=word.length()-1;i>0;i--){\n\
    \        if(std::tolower(word[i])==='a'||std::tolower(word[i])==='e'||std::tolower(word[i])==='i'||std::tolower(word[i])==='o'||std::tolower(word[i])==='u'){\n\
    \            vowels[word[i]]=vowels[word[i]]+1;\n        }\n    }\n    std::map<char,int>::iterator\
    \ it=vowels.begin();\n    std::string vowel_string=\"\";\n    if(word.length()>0){\n\
    \        while(it!=vowels.end()){\n            if((it->second-word.length())<2){\n\
    \                it=vowels.erase(it);\n            }\n            else{\n    \
    \            vowel_string+=it->first;\n                it++;\n            }\n\
    \        }\n    }\n    return vowel_string;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpduhngwdm.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpduhngwdm.cpp:12:35: error: expected primary-expression before \u2018\
    =\u2019 token\n   12 |         if(std::tolower(word[i])==='a'||std::tolower(word[i])==='e'||std::tolower(word[i])==='i'||std::tolower(word[i])==='o'||std::tolower(word[i])==='u'){\n\
    \      |                                   ^\n/tmp/tmpduhngwdm.cpp:12:64: error:\
    \ expected primary-expression before \u2018=\u2019 token\n   12 |         if(std::tolower(word[i])==='a'||std::tolower(word[i])==='e'||std::tolower(word[i])==='i'||std::tolower(word[i])==='o'||std::tolower(word[i])==='u'){\n\
    \      |                                                                ^\n/tmp/tmpduhngwdm.cpp:12:93:\
    \ error: expected primary-expression before \u2018=\u2019 token\n   12 |     \
    \    if(std::tolower(word[i])==='a'||std::tolower(word[i])==='e'||std::tolower(word[i])==='i'||std::tolower(word[i])==='o'||std::tolower(word[i])==='u'){\n\
    \      |                                                                     \
    \                        ^\n/tmp/tmpduhngwdm.cpp:12:122: error: expected primary-expression\
    \ before \u2018=\u2019 token\n   12 |         if(std::tolower(word[i])==='a'||std::tolower(word[i])==='e'||std::tolower(word[i])==='i'||std::tolower(word[i])==='o'||std::tolower(word[i])==='u'){\n\
    \      |                                                                     \
    \                                                     ^\n/tmp/tmpduhngwdm.cpp:12:151:\
    \ error: expected primary-expression before \u2018=\u2019 token\n   12 |     \
    \    if(std::tolower(word[i])==='a'||std::tolower(word[i])==='e'||std::tolower(word[i])==='i'||std::tolower(word[i])==='o'||std::tolower(word[i])==='u'){\n\
    \      |                                                                     \
    \                                                                            \
    \      ^\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ans = \"\";\n    size_t start = 0;\n    size_t end\
    \ = 0;\n    \n    end = word.size();\n    while (start < end) {\n        start\
    \ = end;\n        end = word.find_first_not_of(std::string{\"a\", \"e\", \"i\"\
    , \"o\", \"u\", \"y\"}, end);\n        if (start < end) {\n            std::string\
    \ temp = \"\";\n            temp = word.substr(start, end - start);\n        \
    \    if (temp == \"a\" || temp == \"e\" || temp == \"i\" || temp == \"o\" || temp\
    \ == \"u\" || temp == \"y\") {\n                ans = temp;\n                break;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoq1ynotg.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpoq1ynotg.cpp:17:78: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::basic_string(<brace-enclosed initializer list>)\u2019\
    \n   17 |         end = word.find_first_not_of(std::string{\"a\", \"e\", \"i\"\
    , \"o\", \"u\", \"y\"}, end);\n      |                                       \
    \                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpoq1ynotg.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpoq1ynotg.cpp:17:78:\
    \ note:   candidate expects 2 arguments, 6 provided\n   17 |         end = word.find_first_not_of(std::string{\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\"}, end);\n      |                      \
    \                                                        ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include"
  stdout: ''
  timestamp: 1660120395
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ans = \"\";\n    for(auto iter = word.rbegin(); iter\
    \ != word.rend(); ++iter) {\n        if(*iter == 'a' || *iter == 'e' || *iter\
    \ == 'i' || *iter == 'o' || *iter == 'u') {\n            // found vowel between\
    \ left and right consonants\n            ans += *iter;\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpersyef30: /tmp/tmpersyef30.cpp:21: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::sort(word.rbegin(), word.rend());\n  auto itr = std::find_if(word.rbegin(),\
    \ word.rend(),\n    [&](char c) {\n      auto itr = word.find_first_of(\"aeiou\"\
    , word.length() - 2);\n      if (itr != word.end())\n        return std::find_if(word.begin(),\
    \ itr,\n          [&](char c_) {\n            return std::toupper(c) == std::toupper(c_);\n\
    \          }) != itr;\n      return false;\n    });\n  if (itr != word.end())\n\
    \    return std::string(word.begin(), itr);\n  else\n    return \"\";\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv1g4rinn.cpp: In lambda function:\n/tmp/tmpv1g4rinn.cpp:14:15:\
    \ error: no match for \u2018operator!=\u2019 (operand types are \u2018long unsigned\
    \ int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019})\n\
    \   14 |       if (itr != word.end())\n      |           ~~~ ^~ ~~~~~~~~~~\n \
    \     |           |              |\n      |           |              std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    \      |           long unsigned int\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpv1g4rinn.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpv1g4rinn.cpp:14:27: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018long unsigned int\u2019\n   14 |       if (itr != word.end())\n  \
    \    |                           ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpv1g4rinn.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:904:5:\
    \ note: candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator!=(const\
    \ __gnu_cxx::__norma"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Write your code here\n    for(int i = 0; i <= word.size(); i++)\
    \ {\n        if( word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' ){\n            break;\n        }\n    }\n    if(i\
    \ == word.size())\n        return \"\";\n    std::string vowel;\n    for(; word[i]\
    \ != 'a'; i--)\n        vowel += word[i];\n    for(; word[i] != 'a'; i--)\n  \
    \      vowel += word[i];\n    return vowel;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpprbh23mb.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpprbh23mb.cpp:16:8: error: \u2018i\u2019 was not declared in this scope\n\
    \   16 |     if(i == word.size())\n      |        ^\n/tmp/tmpprbh23mb.cpp:19:16:\
    \ error: \u2018i\u2019 was not declared in this scope\n   19 |     for(; word[i]\
    \ != 'a'; i--)\n      |                ^\n/tmp/tmpprbh23mb.cpp:21:16: error: \u2018\
    i\u2019 was not declared in this scope\n   21 |     for(; word[i] != 'a'; i--)\n\
    \      |                ^\n"
  stdout: ''
  timestamp: 1660120395
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string result = \"\";\n    bool flag\
    \ = false;\n    for(int i = 0; i < word.length(); i++){\n        if(word[i] >=\
    \ 'a' && word[i] <= 'z'){\n            flag = true;\n            break;\n    \
    \    }\n        else if(word[i] >= 'A' && word[i] <= 'Z'){\n            flag =\
    \ true;\n            break;\n        }\n    }\n    if(flag == false){\n      \
    \  result = \"\";\n    }\n    for(int i = word.length()-1; i >= 0; i--){\n   \
    \     if(word[i] >= 'a' && word[i] <= 'z'){\n            flag = true;\n      \
    \      break;\n        }\n        else if(word[i] >= 'A' && word[i] <= 'Z'){\n\
    \            flag = true;\n            break;\n        }\n    }\n    if(flag ==\
    \ false){\n        result = \"\";\n    }\n    for(int i = word.length()-1; i >=\
    \ 0; i--){\n        if(word[i] >= 'a' && word[i] <= 'z' || word[i] >= 'A' && word[i]\
    \ <= 'Z'){\n            flag = true;\n            break;\n        }\n        else{\n\
    \            flag = false;\n        }\n    }\n    if(flag == false){\n       \
    \ result = \"\";\n    }\n    for(int i = word.length()-1; i >= 0; i--){\n    \
    \    if(word[i] >= 'a' && word[i] <= 'z' || word[i] >= 'A' && word[i] <= 'Z'){\n\
    \            flag = true;\n            break;\n        }\n    }\n    if(flag ==\
    \ false){\n        result = \"\";\n    }\n    for(int i = 0; i < word.length();\
    \ i++){\n        if(word[i] >= 'a' && word[i] <= 'z'){\n            flag = true;\n\
    \            break;\n        }\n        else if(word[i] >= 'A' && word[i] <= 'Z'){\n\
    \            flag = true;\n            break;\n        }\n    }\n    if(flag ==\
    \ false){\n        result = \"\";\n    }\n    for(int i = 0; i < word.length();\
    \ i++){\n        if(word[i] >= 'a' && word[i] <= 'z' || word[i] >= 'A' && word[i]\
    \ <= 'Z'){\n            flag = true;\n            break;\n        }\n    }\n \
    \   if(flag == false){\n        result = \"\";\n    }\n    for(int i = 0; i <\
    \ word.length(); i++){\n        if(word[i] >= 'a' && word[i] <= 'z' || word[i]\
    \ >= 'A' && word[i] <= 'Z'){\n            flag = true;\n            break;\n \
    \       }\n    }\n    if(flag == false){\n        result = \"\";\n    }\n    for(int\
    \ i = 0; i < word.length(); i++){\n        if(word[i] >= 'a' && word[i] <= 'z'){\n\
    \            flag = true;\n            break;\n        }\n        else if(word[i]\
    \ >= '\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0wudzpvf.cpp:96:28: warning: missing terminating ' character\n\
    \   96 |         else if(word[i] >= '\n      |                            ^\n\
    /tmp/tmp0wudzpvf.cpp:96:28: error: missing terminating ' character\n/tmp/tmp0wudzpvf.cpp:\
    \ In function \u2018std::string get_closest_vowel(std::string)\u2019:\n/tmp/tmp0wudzpvf.cpp:97:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   97 | }\n \
    \     | ^\n/tmp/tmp0wudzpvf.cpp:96:27: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   96 |         else if(word[i] >= '\n      |                ~\
    \          ^\n      |                           )\n   97 | }\n      | ~      \
    \                    \n/tmp/tmp0wudzpvf.cpp:97:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   97 | }\n      | ^\n/tmp/tmp0wudzpvf.cpp:98:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   98 | int main() {\n      |            ^\n/tmp/tmp0wudzpvf.cpp:113:1: error:\
    \ expected \u2018}\u2019 at end of input\n  113 | }\n      | ^\n/tmp/tmp0wudzpvf.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmp0wudzpvf.cpp:113:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  113 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Code goes here\n    for(int i=word.length()-1;i>=0;i--){\n \
    \       if(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u'){\n\
    \            return word.substr(0,i+1);\n        }\n    }\n    return \"\";\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpzpibi35l: /tmp/tmpzpibi35l.cpp:20: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string closest;\n    for(int i = 1; i < word.length() - 1;\
    \ ++i){\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I'\
    \ || word[i] == 'O' || word[i] == 'U')\n        {\n            if(closest.length()\
    \ <= 1)\n            {\n                closest = word;\n            }\n     \
    \       else{\n                size_t a = closest.rfind('a', 0, i) + 1;\n    \
    \            size_t e = closest.rfind('e', 0, i) + 1;\n                size_t\
    \ i = closest.rfind('i', 0, i) + 1;\n                size_t o = closest.rfind('o',\
    \ 0, i) + 1;\n                size_t u = closest.rfind('u', 0, i) + 1;\n     \
    \           size_t j = closest.rfind('j', 0, i) + 1;\n                size_t k\
    \ = closest.rfind('k', 0, i) + 1;\n                size_t l = closest.rfind('l',\
    \ 0, i) + 1;\n                size_t m = closest.rfind('m', 0, i) + 1;\n     \
    \           size_t n = closest.rfind('n', 0, i) + 1;\n                size_t p\
    \ = closest.rfind('p', 0, i) + 1;\n                size_t q = closest.rfind('q',\
    \ 0, i) + 1;\n                size_t r = closest.rfind('r', 0, i) + 1;\n     \
    \           size_t s = closest.rfind('s', 0, i) + 1;\n                size_t t\
    \ = closest.rfind('t', 0, i) + 1;\n                size_t y = closest.rfind('y',\
    \ 0, i) + 1;\n                size_t z = closest.rfind('z', 0, i) + 1;\n     \
    \           size_t A = closest.rfind('A', 0, i) + 1;\n                size_t E\
    \ = closest.rfind('E', 0, i) + 1;\n                size_t I = closest.rfind('I',\
    \ 0, i) + 1;\n                size_t O = closest.rfind('O', 0, i) + 1;\n     \
    \           size_t U = closest.rfind('U', 0, i) + 1;\n                size_t a\
    \ = closest.rfind('a', 0, i) + 1;\n                size_t e = closest.rfind('e',\
    \ 0, i) + 1;\n                size_t i = closest.rfind('i', 0, i) + 1;\n     \
    \           size_t o = closest.rfind('o', 0, i) + 1;\n                size_t u\
    \ = closest.rfind('u', 0, i) + 1;\n                size_t j = closest.rfind('j',\
    \ 0, i) + 1;\n                size_t k = closest.rfind('k', 0, i) + 1;\n     \
    \           size_t l = closest.rfind('l', 0, i) + 1;\n                size_t m\
    \ = close\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplx3fy7yp.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmplx3fy7yp.cpp:19:51: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::rfind(char, int, int&)\u2019\n   19 |      \
    \           size_t a = closest.rfind('a', 0, i) + 1;\n      |                \
    \                                   ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmplx3fy7yp.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2427:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::rfind(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2427 |       rfind(const basic_string& __str, size_type __pos =\
    \ npos) const\n      |       ^~~~~\n/usr/include/c++/9/bits/basic_string.h:2427:7:\
    \ note:   candidate expects 2 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2440:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::size_type>\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::rfind(const _Tp&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    , \"a\", \"e\", \"i\", \"o\", \"u\", \"y\"};\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (!std::isalpha(word[i])) {\n            return \"\";\n  \
    \      }\n    }\n    for (int i = word.length(); i > 0; i--) {\n        if (!std::isalpha(word[i]))\
    \ {\n            return \"\";\n        }\n    }\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (!std::isalpha(word[i])) {\n            return \"\";\n  \
    \      }\n    }\n    for (int i = word.length(); i > 0; i--) {\n        if (!std::isalpha(word[i]))\
    \ {\n            return \"\";\n        }\n    }\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (std::find(vowels.begin(), vowels.end(), word[i])\
    \ == vowels.end()) {\n            return \"\";\n        }\n    }\n    return word;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgw3gld7c.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpgw3gld7c.cpp:10:85: error: could not convert \u2018{\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"y\", \"a\", \"e\", \"i\", \"o\", \"u\", \"y\"}\u2019 from\
    \ \u2018<brace-enclosed initializer list>\u2019 to \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019}\n   10 |     std::string vowels\
    \ = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"a\", \"e\", \"i\", \"o\", \"\
    u\", \"y\"};\n      |                                                        \
    \                             ^\n      |                                     \
    \                                                |\n      |                  \
    \                                                                   <brace-enclosed\
    \ initializer list>\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int start = word.length()-1;\n  \
    \  int end = 0;\n    while(start>=0){\n        if(word[start]=='a' || word[start]=='e'\
    \ || word[start]=='i' || word[start]=='o' || word[start]=='u'){\n            start--;\n\
    \        }\n        else{\n            start--;\n        }\n    }\n    end++;\n\
    \    while(end<=len){\n        if(word[end]=='a' || word[end]=='e' || word[end]=='i'\
    \ || word[end]=='o' || word[end]=='u'){\n            end++;\n        }\n     \
    \   else{\n            end++;\n        }\n    }\n    int middle = (end-start)/2;\n\
    \    int a = middle+1;\n    int b = end-start;\n    int d = a+b;\n    int v =\
    \ 0;\n    int z = 0;\n    int k = 0;\n    for(int i=start; i<end; i++){\n    \
    \    if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n\
    \            v++;\n        }\n        if(word[i]=='y' || word[i]=='e' || word[i]=='i'\
    \ || word[i]=='o' || word[i]=='u'){\n            v++;\n        }\n        if(word[i]=='y'\
    \ || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n            v++;\n      \
    \  }\n        if(word[i]=='i' || word[i]=='o' || word[i]=='u'){\n            v++;\n\
    \        }\n        if(word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n\
    \            v++;\n        }\n    }\n    while(d>v){\n        k++;\n        d\
    \ -= k;\n        z = k;\n    }\n    for(int i=start; i<end; i++){\n        if(word[i]=='y'\
    \ || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n        \
    \    v++;\n        }\n        if(word[i]=='y' || word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u'){\n            v++;\n        }\n        if(word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u'){\n            v++;\n        }\n        if(word[i]=='e' || word[i]=='i'\
    \ || word[i]=='o' || word[i]=='u'){\n            v++;\n        }\n    }\n    while(b>v){\n\
    \        k++;\n        b -= k;\n        z = k;\n    }\n    if(v==z){\n       \
    \ std::string temp = \"\";\n        return temp;\n    }\n    else{\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmploifd8oz.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmploifd8oz.cpp:84:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   84 | int main() {\n      |            ^\n/tmp/tmploifd8oz.cpp:99:1:\
    \ error: expected \u2018}\u2019 at end of input\n   99 | }\n      | ^\n/tmp/tmploifd8oz.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmploifd8oz.cpp:99:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   99 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // code here\n    std::map<char,int> vowels;\n    for(int i=0;i<word.size();i++)\n\
    \    {\n        char c=word[i];\n        if(c>=65 && c<=90)\n        {\n     \
    \       if(c!=32)\n            {\n                vowels[c]+=1;\n            }\n\
    \        }\n    }\n    char cur;\n    int max_vowel=0;\n    for(auto x:vowels)\n\
    \    {\n        if(x>max_vowel)\n        {\n            max_vowel=x;\n       \
    \     cur=x.first;\n        }\n    }\n    int start_index=std::count(word.begin(),word.end(),cur);\n\
    \    std::string ans=\"\";\n    if(start_index>=2 && start_index<=word.size())\n\
    \    {\n        int left_index=std::count(word.begin(),word.begin()-start_index-1,cur);\n\
    \        int right_index=std::count(word.begin()-start_index,word.end(),cur);\n\
    \        if(left_index>right_index)\n        {\n            ans=word[start_index];\n\
    \        }\n        else\n        {\n            ans=word[start_index+1];\n  \
    \      }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzrdhkxvn.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpzrdhkxvn.cpp:27:13: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018std::pair<const char, int>\u2019 and \u2018int\u2019)\n   27\
    \ |         if(x>max_vowel)\n      |            ~^~~~~~~~~~\n      |         \
    \   | |\n      |            | int\n      |            std::pair<const char, int>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzrdhkxvn.cpp:2:\n/usr/include/c++/9/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1081:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpzrdhkxvn.cpp:27:14:\
    \ note:   \u2018std::pair<const char, int>\u2019 is not derived from \u2018const\
    \ std::__cxx11::sub_match<_BiIter>\u2019\n   27 |         if(x>max_vowel)\n  \
    \    |              ^~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzrdhkxvn.cpp:2:\n/usr/include/c++/9/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpzrdhkxvn.cpp:27:14: note:   \u2018std::pair<const char, int>\u2019\
    \ is not derived from \u2018std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>\u2019\n   27 |         if(x>max_vowel)\n      |              ^~~~~~~~~\n\
    In file included from /usr/include/c"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    // Your code here\n    int\
    \ n = word.size()-1;\n    for(int i=0; i<=n;i++)\n    {\n        if(word[i]==word[i+1]\
    \ && vowels.find(word[i+1])!=std::string::npos)\n            return word[i];\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx_mvu5b7.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpx_mvu5b7.cpp:16:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   16 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int start = 0;\n    int end = 0;\n\
    \    while (start < len && word[start] != '\\0') {\n        start = start + 1;\n\
    \    }\n    while (end < len && word[end] != '\\0') {\n        end = end - 1;\n\
    \    }\n    if (start > end) {\n        return \"\";\n    }\n    int count = 0;\n\
    \    int idx = 0;\n    while (idx < end - start) {\n        if (word[start + idx]\
    \ == 'a' || word[start + idx] == 'e' || word[start + idx] == 'i' || word[start\
    \ + idx] == 'o' || word[start + idx] == 'u' || word[start + idx] == 'A' || word[start\
    \ + idx] == 'E' || word[start + idx] == 'I' || word[start + idx] == 'O' || word[start\
    \ + idx] == 'U') {\n            count = count + 1;\n            idx = idx + 1;\n\
    \        } else {\n            idx = idx + 1;\n        }\n    }\n    if (count\
    \ == 0) {\n        return \"\";\n    }\n    std::string s = word;\n    for (int\
    \ i = start; i <= end - start; i++) {\n        s = s.replace(word[i], \"\");\n\
    \    }\n    return s;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdq4vv9y0.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpdq4vv9y0.cpp:37:34: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::replace(__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type&, const char [1])\u2019\n   37 |         s = s.replace(word[i],\
    \ \"\");\n      |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdq4vv9y0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type = long unsigned int]\u2019\n 1893 |       replace(size_type\
    \ __pos, size_type __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, st"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels[] = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    };\n    int left_pos = 0, right_pos = 0, left_len = 0, right_len = 0;\n    int\
    \ word_len = word.size();\n    left_len = word_len - 1;\n    right_len = word_len\
    \ - 1;\n    \n    for(int i=0;i<word_len;i++) {\n        if(word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i]\
    \ == 'y') {\n            right_pos = i;\n            right_len = word_len - 1;\n\
    \        }\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' || word[i] == 'y') {\n            left_pos = i;\n \
    \           left_len = word_len - 1;\n        }\n        if(left_pos != right_pos\
    \ && (word[left_pos + 1] == vowels[left_pos] || word[right_pos + 1] == vowels[right_pos]))\
    \ {\n            return word;\n        }\n        left_pos++;\n        right_pos--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptsjpw3eo.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmptsjpw3eo.cpp:25:57: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   25 |         if(left_pos != right_pos && (word[left_pos + 1] == vowels[left_pos]\
    \ || word[right_pos + 1] == vowels[right_pos])) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptsjpw3eo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptsjpw3eo.cpp:25:75:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |         if(left_pos != right_pos && (word[left_pos\
    \ + 1] == vowels[left_pos] || word[right_pos + 1] == vowels[right_pos])) {\n \
    \     |                                                                      \
    \     ^\nIn file included from /usr/include/c++/9/regex:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n              \
    \   from /tmp/tmptsjpw3eo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template a"
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowel = \"aeiou\";\n\tstd::string first_cons = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n\tstd::string second_cons = \"bcdfghjklmnpqrstvwxyz\";\n\tfor (int i = 0; i\
    \ < word.length() - 1; i++) {\n\t\tif (word[i] == vowel[0] && word[i + 1] == vowel[1])\
    \ {\n\t\t\treturn word;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < word.length() -\
    \ 1; i++) {\n\t\tif (word[i] == first_cons[0] && word[i + 1] == first_cons[1])\
    \ {\n\t\t\treturn word;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < word.length() -\
    \ 1; i++) {\n\t\tif (word[i] == second_cons[0] && word[i + 1] == second_cons[1])\
    \ {\n\t\t\treturn word;\n\t\t}\n\t}\n\treturn \"\";\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbttfhnmu: /tmp/tmpbttfhnmu.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n   assert(word.size() > 0);\n   \n   int left_index = 0, right_index\
    \ = word.size() - 1;\n   std::string vowel;\n   while (left_index < right_index)\
    \ {\n      char current_char = word[left_index];\n      char next_char = word[right_index];\n\
    \      \n      if (current_char == 'a' || current_char == 'e' || current_char\
    \ == 'i' || current_char == 'o' || current_char == 'u') {\n         // Go to next\
    \ letter\n         ++right_index;\n      } else if (current_char == 'y') {\n \
    \        // Go to next letter\n         ++right_index;\n         ++left_index;\n\
    \         ++right_index;\n      } else {\n         // Go to next letter\n    \
    \     ++left_index;\n         ++right_index;\n      }\n   }\n   return vowel;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tint vowel_positions[26] = {0};\n\tchar vowels[] = \"aeiou\";\n\t\
    int i = 0;\n\t\n\tassert(word.length() != 0);\n\t\n\t// Get the length of the\
    \ given word\n\tint word_length = word.length();\n\t\n\t// Initialize the array\
    \ to -1\n\tfor (int i = 0; i < 26; i++) {\n\t\tvowel_positions[i] = -1;\n\t}\n\
    \t\n\tfor (int i = 1; i < word_length; i++) {\n\t\tif (isalpha(word[i])) {\n\t\
    \t\t// Get the character at i position\n\t\t\tchar c = word[i];\n\t\t\t\n\t\t\t\
    // Check if the current character is a vowel\n\t\t\tif (std::find(std::begin(vowels),\
    \ std::end(vowels), c) != std::end(vowels)) {\n\t\t\t\t// If so, store the index\n\
    \t\t\t\tvowel_positions[c - 'a'] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint min_dist\
    \ = word_length + 1;\n\tint current_dist = 0;\n\t\n\tfor (int i = 1; i < 26; i++)\
    \ {\n\t\tcurrent_dist = i - 'a';\n\t\t\n\t\tif (vowel_positions[current_dist]\
    \ == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint left = vowel_positions[current_dist]\
    \ - 1;\n\t\tint right = vowel_positions[current_dist] - 1;\n\t\t\n\t\tif (left\
    \ < 0 || right < 0 || left >= right || word[left] != 'a' || word[right] != 'a')\
    \ {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint dist = std::abs(left + 1);\n\t\t\n\t\
    \tif (min_dist > dist) {\n\t\t\tmin_dist = dist;\n\t\t}\n\t}\n\t\n\treturn (min_dist\
    \ != word_length) ? std::string(\"\") : word;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphcy79n8x: /tmp/tmphcy79n8x.cpp:65: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int length = word.length();\n\
    \    int start = 0;\n    int end = length - 1;\n    int cnt = 0;\n    for (int\
    \ i = 0; i < length; i++) {\n        cnt = 0;\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            cnt = 1;\n        }\n        if (cnt ==\
    \ 0) {\n            continue;\n        }\n        if (word[i] == word[end]) {\n\
    \            if (i != end) {\n                cnt = 0;\n            }\n      \
    \  }\n        if (i != end) {\n            if (word[i] != word[end]) {\n     \
    \           cnt = 0;\n            }\n        }\n        if (cnt == 0) {\n    \
    \        continue;\n        }\n        if (word[start] == word[i]) {\n       \
    \     if (i != start) {\n                cnt = 0;\n            }\n        }\n\
    \        if (i != start) {\n            if (word[i] != word[start]) {\n      \
    \          cnt = 0;\n            }\n        }\n        if (cnt == 0) {\n     \
    \       continue;\n        }\n        if (word[end] == word[i]) {\n          \
    \  if (i != end) {\n                cnt = 0;\n            }\n        }\n     \
    \   if (i != end) {\n            if (word[i] != word[end]) {\n               \
    \ cnt = 0;\n            }\n        }\n        if (cnt == 0) {\n            continue;\n\
    \        }\n        start = i;\n        end = length - 1;\n    }\n    return word;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_3xvrkip: /tmp/tmp_3xvrkip.cpp:69: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::stack<char> s;\n    for (size_t i = 0; i < word.length();\
    \ i++) {\n        std::cout << s.top() << \" \";\n        if (word[i] != word[i-1]\
    \ && word[i] != word[i+1] && word[i] != 'i' \n            && word[i] != 'e' &&\
    \ word[i] != 'o' && word[i] != 'u') {\n            s.push( word[i] );\n      \
    \  }\n    }\n    return s.empty() ? \"\" : s.top();\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpymctcjcs.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpymctcjcs.cpp:18:22: error: operands to ?: have different types \u2018\
    const char*\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   18 |     return s.empty() ? \"\" : s.top();\n   \
    \   |            ~~~~~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\t// Your code goes here\n\tassert(word.length()>3);\n\tstd::string\
    \ vowel;\n\tint i=word.size()-1;\n\tfor(;i>=0;i--){\n\t\tif(word[i]=='a' || word[i]=='e'\
    \ || word[i]=='i'|| word[i]=='o' || word[i]=='u'){\n\t\t\tvowel+=word[i];\n\t\t\
    \ti++;\n\t\t}\n\t}\n\tstd::string first_vowel=vowel.substr(0,vowel.size()-1);\n\
    \treturn first_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660120401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n   assert(word.size()>0);\n   std::stack<char> vowels;\n   std::stack<char>::iterator\
    \ it = vowels.top();\n   bool vowelFound = false;\n   int vowelCount = 0;\n  \
    \ for (char c:word) {\n      if(std::toupper(c)=='A'||std::toupper(c)=='E'||std::toupper(c)=='I'||std::toupper(c)=='O'||std::toupper(c)=='U'){\n\
    \         vowelFound = true;\n         vowelCount = 1;\n         vowels.push(c);\n\
    \         break;\n      }\n      else if(std::toupper(c)=='A'&&vowelFound==true){\n\
    \         vowelCount = 1;\n         vowels.push(c);\n      }\n      else if(std::toupper(c)=='E'&&vowelFound==true){\n\
    \         vowelCount = 2;\n         vowels.push(c);\n      }\n      else if(std::toupper(c)=='I'&&vowelFound==true){\n\
    \         vowelCount = 3;\n         vowels.push(c);\n      }\n      else if(std::toupper(c)=='O'&&vowelFound==true){\n\
    \         vowelCount = 4;\n         vowels.push(c);\n      }\n      else if(std::toupper(c)=='U'&&vowelFound==true){\n\
    \         vowelCount = 5;\n         vowels.push(c);\n      }\n      else if(std::tolower(c)=='a'&&vowelFound==true){\n\
    \         vowelCount = 1;\n         vowels.push(c);\n      }\n      else if(std::tolower(c)=='e'&&vowelFound==true){\n\
    \         vowelCount = 2;\n         vowels.push(c);\n      }\n      else if(std::tolower(c)=='i'&&vowelFound==true){\n\
    \         vowelCount = 3;\n         vowels.push(c);\n      }\n      else if(std::tolower(c)=='o'&&vowelFound==true){\n\
    \         vowelCount = 4;\n         vowels.push(c);\n      }\n      else if(std::tolower(c)=='u'&&vowelFound==true){\n\
    \         vowelCount = 5;\n         vowels.push(c);\n      }\n      else{\n  \
    \       if(std::toupper(c)=='A'||std::toupper(c)=='E'||std::toupper(c)=='I'||std::toupper(c)=='O'||std::toupper(c)=='U'){\n\
    \            vowelFound = true;\n            vowelCount = 1;\n            vowels.push(c);\n\
    \         }\n         else if(std::toupper(c)=='A'&&vowelFound==true){\n     \
    \       vowelCount = 1;\n            vowels.push(c);\n         }\n         else\
    \ if(std::toupper(c)=='E'&&vowelFound==true){\n            vowelCount = 2;\n \
    \           vowels.push(c);\n         }\n         else if(std::toupper(c)=='I'\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa180wk3c.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpa180wk3c.cpp:12:22: error: \u2018iterator\u2019 is not a member of\
    \ \u2018std::stack<char>\u2019\n   12 |    std::stack<char>::iterator it = vowels.top();\n\
    \      |                      ^~~~~~~~\n/tmp/tmpa180wk3c.cpp:76:38: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   76 |          else if(std::toupper(c)=='I'\n\
    \      |                 ~                    ^\n      |                     \
    \                 )\n   77 | }\n      | ~                                    \
    \ \n/tmp/tmpa180wk3c.cpp:77:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   77 | }\n      | ^\n/tmp/tmpa180wk3c.cpp:78:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   78 | int main() {\n     \
    \ |            ^\n/tmp/tmpa180wk3c.cpp:93:1: error: expected \u2018}\u2019 at\
    \ end of input\n   93 | }\n      | ^\n/tmp/tmpa180wk3c.cpp:15:22: note: to match\
    \ this \u2018{\u2019\n   15 |    for (char c:word) {\n      |                \
    \      ^\n/tmp/tmpa180wk3c.cpp:93:1: error: expected \u2018}\u2019 at end of input\n\
    \   93 | }\n      | ^\n/tmp/tmpa180wk3c.cpp:9:49: note: to match this \u2018{\u2019\
    \n    9 | std::string get_closest_vowel(std::string word) {\n      |         \
    \                                        ^\n/tmp/tmpa180wk3c.cpp:93:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n   93 | }\n      |\
    \ ^\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string first_vowel = \"\"\
    ;\n  std::string last_vowel = \"\";\n  int vowel_index = 0;\n  for (int i = 0;\
    \ i < (word.length()); i++) {\n    if ((word[i] == 'a') || (word[i] == 'e') ||\
    \ (word[i] == 'i') || (word[i] == 'o') || (word[i] == 'u'))\n      first_vowel\
    \ = word[i];\n    if ((word[i] == 'A') || (word[i] == 'E') || (word[i] == 'I')\
    \ || (word[i] == 'O') || (word[i] == 'U'))\n      last_vowel = word[i];\n  }\n\
    \  if (last_vowel != first_vowel) {\n    for (int i = 0; i < (word.length());\
    \ i++) {\n      if ((word[i] == first_vowel) || (word[i] == last_vowel))\n   \
    \     vowel_index = i;\n    }\n  }\n  std::string result = \"\";\n  char current_char\
    \ = word[vowel_index];\n  for (int i = (vowel_index - 1); i < (word.length());\
    \ i++) {\n    if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n      result = word[i];\n      break;\n    }\n\
    \    if ((word[i] == current_char) && (word[i - 1] == 'a' || word[i - 1] == 'e'\
    \ || word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u'))\n      result\
    \ = word[i];\n  }\n  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpopxc1tjb.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpopxc1tjb.cpp:22:20: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   22 |       if ((word[i] == first_vowel) || (word[i] == last_vowel))\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpopxc1tjb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpopxc1tjb.cpp:22:23:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   22 |       if ((word[i] == first_vowel) || (word[i]\
    \ == last_vowel))\n      |                       ^~~~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpopxc1tjb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpopxc1tjb.cpp:22:23: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 "
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int i,j;\n    int left = 0, right\
    \ = len-1;\n    char closest, first,second;\n    for(i = 0; i < len; i++){\n \
    \       first = word[i];\n        second = word[right];\n        for(j = i; j\
    \ < len; j++){\n            if(first == word[j]){\n                closest = second;\n\
    \                break;\n            }else if(second == word[j]){\n          \
    \      closest = first;\n                break;\n            }\n            else\n\
    \                continue;\n        }\n        if(closest == first){\n       \
    \     left = i;\n        }\n        if(closest == second){\n            right\
    \ = i;\n        }\n    }\n    if(left!=-1 && right!=-1){\n        int vowelIndex\
    \ = 0;\n        std::string vowels = \"aeiouAEIOU\";\n        vowels.erase(vowels.begin()+vowelIndex++);\n\
    \        vowels.erase(vowels.begin()+vowelIndex++);\n        vowels.erase(vowels.begin()+vowelIndex++);\n\
    \        vowels.erase(vowels.begin()+vowelIndex++);\n        vowels.erase(vowels.begin()+vowelIndex++);\n\
    \        vowels.erase(vowels.begin()+vowelIndex++);\n        vowels.erase(vowels.begin()+vowelIndex++);\n\
    \        vowels.erase(vowels.begin()+vowelIndex++);\n        if(vowels[left]!=word[left])\n\
    \            return \"\";\n        if(vowels[right]!=word[right])\n          \
    \  return \"\";\n        if(word[left]=='a' && word[right]=='e')\n           \
    \ return \"ae\";\n        if(word[left]=='a' && word[right]=='i')\n          \
    \  return \"ai\";\n        if(word[left]=='a' && word[right]=='o')\n         \
    \   return \"ao\";\n        if(word[left]=='a' && word[right]=='u')\n        \
    \    return \"au\";\n        if(word[left]=='e' && word[right]=='i')\n       \
    \     return \"ei\";\n        if(word[left]=='e' && word[right]=='o')\n      \
    \      return \"eo\";\n        if(word[left]=='e' && word[right]=='u')\n     \
    \       return \"eu\";\n        if(word[left]=='i' && word[right]=='o')\n    \
    \        return \"io\";\n        if(word[left]=='i' && word[right]=='u')\n   \
    \         return \"iu\";\n        if(word[left]=='o' && word[right]=='u')\n  \
    \          return \"ou\";\n        if(word[left]=='u' && word[right]\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjac3pphn.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpjac3pphn.cpp:70:42: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   70 |         if(word[left]=='u' && word[right]\n      |          \
    \ ~                              ^\n      |                                  \
    \        )\n   71 | }\n      | ~                                         \n/tmp/tmpjac3pphn.cpp:71:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   71 | }\n \
    \     | ^\n/tmp/tmpjac3pphn.cpp:72:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   72 | int main() {\n      |            ^\n\
    /tmp/tmpjac3pphn.cpp:87:1: error: expected \u2018}\u2019 at end of input\n   87\
    \ | }\n      | ^\n/tmp/tmpjac3pphn.cpp:9:49: note: to match this \u2018{\u2019\
    \n    9 | std::string get_closest_vowel(std::string word) {\n      |         \
    \                                        ^\n/tmp/tmpjac3pphn.cpp:87:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n   87 | }\n      |\
    \ ^\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels[] = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    , \"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"};\n    // For every vowel, if the right\
    \ side of vowel is the same as the given word, then\n    // return its index.\n\
    \    for(int i = 0; i < sizeof(vowels); i++) {\n        // If the right side of\
    \ vowel is in the given word, find the index. Otherwise, return an empty string.\n\
    \        if(word.substr(word.size() - 1, 1) == vowels[i]) return vowels.at(i -\
    \ 1);\n    }\n    // If no vowel met the above condition, return an empty string.\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdpdxnns8.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpdpdxnns8.cpp:15:72: error: request for member \u2018at\u2019 in \u2018\
    vowels\u2019, which is of non-class type \u2018std::string [12]\u2019 {aka \u2018\
    std::__cxx11::basic_string<char> [12]\u2019}\n   15 |         if(word.substr(word.size()\
    \ - 1, 1) == vowels[i]) return vowels.at(i - 1);\n      |                    \
    \                                                    ^~\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels{\"a\",\"e\",\"i\",\"o\",\"u\"};\n    std::string\
    \ vowel_to_find{\"e\"};\n    // std::cout << word << std::endl;\n    // std::cout\
    \ << vowels << std::endl;\n    // std::cout << vowel_to_find << std::endl;\n \
    \   // return \"\";\n    int vowel_position;\n    int vowel_index;\n    int vowel_distance;\n\
    \    int consonant_position;\n    int consonant_index;\n    int consonant_distance;\n\
    \    for (vowel_position = 0; vowel_position < word.length(); vowel_position++)\
    \ {\n        for (int i = 0; i < (vowels.size() - 1); i++) {\n            vowel_index\
    \ = word.length() - i - 1;\n            vowel_distance = vowel_index - vowel_position;\n\
    \            consonant_position = vowel_position - vowel_distance;\n         \
    \   for (consonant_index = 0; consonant_index < word.length(); consonant_index++)\
    \ {\n                consonant_index = word.length() - consonant_index - 1;\n\
    \                consonant_distance = consonant_index - consonant_position;\n\
    \                if (vowels[vowel_index] == vowels[vowel_index + vowel_distance])\
    \ {\n                    if (consonant_position >= consonant_index) {\n      \
    \                  break;\n                    }\n                    else {\n\
    \                        if (word[consonant_position] == vowels[vowel_index])\
    \ {\n                            vowel_position += vowel_distance;\n         \
    \                   consonant_position -= consonant_distance;\n              \
    \              break;\n                        }\n                    }\n    \
    \            }\n            }\n        }\n        if (vowel_position >= word.length()\
    \ - 1) {\n            return word;\n        }\n    }\n    return word;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1m2vr83m.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp1m2vr83m.cpp:10:43: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::basic_string(<brace-enclosed initializer list>)\u2019\
    \n   10 |     std::string vowels{\"a\",\"e\",\"i\",\"o\",\"u\"};\n      |    \
    \                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp1m2vr83m.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp1m2vr83m.cpp:10:43:\
    \ note:   candidate expects 2 arguments, 5 provided\n   10 |     std::string vowels{\"\
    a\",\"e\",\"i\",\"o\",\"u\"};\n      |                                       \
    \    ^\nIn file included from /usr/include/c++/9/string:55,\n                \
    \ from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp1m2vr83m.cpp:2:\n/usr/inclu"
  stdout: ''
  timestamp: 1660120396
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowel_before, vowel_after;\n  int vowel_before_length,\
    \ vowel_after_length;\n  bool left_vowel_found = false;\n  bool right_vowel_found\
    \ = false;\n  for (size_t i = 0; i < word.size() - 1; i++)\n  {\n    if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \    {\n      vowel_before = word[i];\n      vowel_before_length = i;\n    }\n\
    \  }\n  for (size_t j = word.size() - 1; j >= 0; j--)\n  {\n    if (word[j] ==\
    \ 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j] == 'u')\n\
    \    {\n      vowel_after = word[j];\n      vowel_after_length = j;\n    }\n \
    \ }\n  if ((word.size() == 1) || (word[0] == 'a')) return word;\n  if (left_vowel_found\
    \ && right_vowel_found)\n  {\n    if ((vowel_before_length + 1 == word.size()\
    \ - 1) || (vowel_after_length == 0))\n    {\n      if ((word[vowel_before_length\
    \ + 1] == 'a' || word[vowel_before_length + 1] == 'e' || word[vowel_before_length\
    \ + 1] == 'i' || word[vowel_before_length + 1] == 'o' || word[vowel_before_length\
    \ + 1] == 'u'))\n      {\n        return word.substr(vowel_before_length + 1,\
    \ vowel_after_length + 1);\n      }\n    }\n  }\n  return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code goes here\n    int len = word.size();\n    char last_vowel\
    \ = word[len-1];\n    for(int i = 0; i <= len-2; i++){\n        if(word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'){\n\
    \            if((i+2) < len && word[i+1] == last_vowel){\n                return\
    \ word;\n            }\n        }\n        if(word[i] == 'A' || word[i] == 'E'\
    \ || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'){\n            if((i+2)\
    \ < len && word[i+1] == last_vowel){\n                return word;\n         \
    \   }\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpfcsvg1y8: /tmp/tmpfcsvg1y8.cpp:29: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string ans=\"\";\n    for(int\
    \ i=word.length()-1;i>=0;i--){\n        if(isalpha(word[i])){\n            std::string\
    \ check=word;\n            std::transform(check.begin(),check.end(),check.begin(),::tolower);\n\
    \            if(check[i]=='a' || check[i]=='e' || check[i]=='i' || check[i]=='o'\
    \ || check[i]=='u')\n            {\n                if(check[i]=='a')\n      \
    \          {\n                    ans.insert(ans.begin(),\"a\");\n           \
    \     }\n                if(check[i]=='e')\n                {\n              \
    \      ans.insert(ans.begin(),\"e\");\n                }\n                if(check[i]=='i')\n\
    \                {\n                    ans.insert(ans.begin(),\"i\");\n     \
    \           }\n                if(check[i]=='o')\n                {\n        \
    \            ans.insert(ans.begin(),\"o\");\n                }\n             \
    \   if(check[i]=='u')\n                {\n                    ans.insert(ans.begin(),\"\
    u\");\n                }\n            }\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph98rqoni.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmph98rqoni.cpp:20:47: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [2])\u2019\n   20 |                     ans.insert(ans.begin(),\"\
    a\");\n      |                                               ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmph98rqoni.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n     "
  stdout: ''
  timestamp: 1660120396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    bool vowels[26] = {true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true};\n    std::string vowel_met = \"\";\n    // Find vowels in right\
    \ side of word\n    for (int i = word.length()-1; i >= 0; i--){\n        if (vowels[(int)word[i]]==true){\n\
    \            vowel_met += word[i];\n        }\n    }\n    return vowel_met;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsm2s97px.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpsm2s97px.cpp:11:214: error: too many initializers for \u2018bool [26]\u2019\
    \n   11 |     bool vowels[26] = {true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true};\n      |\
    \                                                                            \
    \                                                                            \
    \                                                              ^\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    \n    // your code goes here\n    \n    char vowels[] = {'a', 'e',\
    \ 'i', 'o', 'u'};\n    int start = 0;\n    int end = word.size() - 1;\n    \n\
    \    while(start <= end){\n        int index = -1;\n        int min = std::numeric_limits<int>::max();\n\
    \        for(int i=0;i<6;i++){\n            if(word[start+i] == vowels[i]){\n\
    \                index = i;\n                min = i;\n            }\n       \
    \ }\n        \n        if(index != -1){\n            min = index > 0 ? index :\
    \ 0;\n        }\n        \n        if(word[start+min+1] == 'a'){\n           \
    \ start = start + min+2;\n        }\n        else if(word[start+min+1] == 'e'){\n\
    \            start = start + min+2;\n        }\n        else if(word[start+min+1]\
    \ == 'i'){\n            start = start + min+2;\n        }\n        else if(word[start+min+1]\
    \ == 'o'){\n            start = start + min+2;\n        }\n        else if(word[start+min+1]\
    \ == 'u'){\n            start = start + min+2;\n        }\n        else{\n   \
    \         break;\n        }\n    }\n    \n    return word;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  // Your code goes here\n  int size = word.size();\n  string vowel\
    \ = \" aeiou\";\n  int start = 0;\n  int end = size - 1;\n  int mid = (start +\
    \ end) / 2;\n\n  while (start <= end) {\n    if (word[mid]==vowel[start]) {\n\
    \      start = mid + 1;\n    } else {\n      end = mid - 1;\n    }\n    mid =\
    \ (start + end) / 2;\n  }\n  return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8w14mrep.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp8w14mrep.cpp:12:3: error: \u2018string\u2019 was not declared in this\
    \ scope\n   12 |   string vowel = \" aeiou\";\n      |   ^~~~~~\n/tmp/tmp8w14mrep.cpp:12:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp8w14mrep.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp8w14mrep.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmp8w14mrep.cpp:18:20: error: \u2018vowel\u2019 was not declared in this\
    \ scope\n   18 |     if (word[mid]==vowel[start]) {\n      |                 \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string closest_vowel = \"\";\n    int vowel_pos = 0;\n   \
    \ for(int i = word.size()-1; i>=0; i--){\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A'\
    \ || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'){\n\
    \            closest_vowel = word.substr(0, i) + closest_vowel;\n        }\n \
    \   }\n    return closest_vowel;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf8_px77_: /tmp/tmpf8_px77_.cpp:21: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n// your code goes here\nchar consonants[] = \"bcdfghjklmnpqrstvwxyz\"\
    ;\nint n = word.length();\nint k = 0;\nstd::string vowel = \"\";\nassert(n >=\
    \ 2);\nfor (int i = 1; i < n; i++) {\n    if (consonants[k] == word[i]) {\n  \
    \      k++;\n        if (k == 26) {\n            vowel = word[i];\n          \
    \  k = 26; // reset the counter\n        }\n    }\n    else if (consonants[k]\
    \ == word[i + 1]) {\n        k++;\n        if (k == 26) {\n            vowel =\
    \ word[i + 1];\n            k = 26; // reset the counter\n        }\n    }\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_v8wtr_x.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp_v8wtr_x.cpp:32:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   32 | int main() {\n      |            ^\n/tmp/tmp_v8wtr_x.cpp:47:1:\
    \ error: expected \u2018}\u2019 at end of input\n   47 | }\n      | ^\n/tmp/tmp_v8wtr_x.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmp_v8wtr_x.cpp:47:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   47 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string ans = \"\";\n    int k = 0;\n    for (auto &i : word)\
    \ {\n        if (i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' || i\
    \ == 'y') {\n            k++;\n        }\n    }\n    for (int i = k; i < word.size()\
    \ - 1; i++) {\n        ans += word[i];\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpr1fmpj2l: /tmp/tmpr1fmpj2l.cpp:24: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    for(auto it = word.length() - 1; it >= 0; it--) {\n        if(word.at(it)\
    \ == 'a' || word.at(it) == 'e' || word.at(it) == 'i' || word.at(it) == 'o' ||\
    \ word.at(it) == 'u') {\n            return word;\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmps0j5lssb: /tmp/tmps0j5lssb.cpp:19: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  assert(word.size()>=2); // if not, then return empty string\n  int\
    \ n = word.size();\n  int vowel = 0;\n  for(int i = n-1; i>=0; i--){\n      if(word[i]=='a'\
    \ || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u' || word[i]=='y')\
    \ {\n          vowel = i;\n          break;\n      }\n  }\n  for(int i = word.size()\
    \ -1; i>=0; i--){\n      if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u' || word[i]=='y') {\n          vowel = i;\n          break;\n\
    \      }\n  }\n  for(int i = n-1; i>=0; i--){\n      if(word[i]=='a' || word[i]=='e'\
    \ || word[i]=='i' || word[i]=='o' || word[i]=='u' || word[i]=='y') {\n       \
    \   vowel = i;\n          break;\n      }\n  }\n  return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjtwgwq56: /tmp/tmpjtwgwq56.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.length() >= 2);\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    size_t vowel_start = word.length() - 1;\n    size_t vowel_end = word.length()\
    \ - 1;\n    size_t index = vowels.find(word[vowel_start]);\n    if (index < vowel_start\
    \ - 1) {\n        index = vowels.find(word[vowel_end - 1]);\n        if (index\
    \ < vowel_end - 1) {\n            return word;\n        }\n    }\n    return \"\
    \";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpnz_vbbru: /tmp/tmpnz_vbbru.cpp:25: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  if(word.length()==0) return \"\"; // empty string \n  // find consonant\
    \ to the right of word and to the left of word\n  auto p = word.rfind(\"a\");\
    \ // get \"a\" from the right\n  auto n = word.rfind(\"A\"); // get \"A\" from\
    \ the right\n  if(p==word.size()) return \"\"; // no vowel to the right of word\n\
    \  if(n==word.size()) return \"\"; // no vowel to the left of word\n  return word[n-1]\
    \ + word[n+1];\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplus8ugbg.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmplus8ugbg.cpp:16:20: error: could not convert \u2018(((int)word.std::__cxx11::basic_string<char>::operator[]((n\
    \ - 1))) + ((int)word.std::__cxx11::basic_string<char>::operator[]((n + 1))))\u2019\
    \ from \u2018int\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   16 |   return word[n-1] + word[n+1];\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int vowel_count=0, min_count=1, max_count=0;\n    for (int i=word.size()-1;i>=0;i--)\
    \ {\n        char c = word[i];\n        // checking if c is a vowel\n        if\
    \ (c=='a' || c=='e' || c=='i' || c=='o' || c=='u') {\n            vowel_count++;\n\
    \            if (vowel_count>max_count) {\n                max_count=vowel_count;\n\
    \            }\n            if (vowel_count<min_count) {\n                min_count=vowel_count;\n\
    \            }\n        }\n    }\n    if (vowel_count>max_count) {\n        return\
    \ \"\";\n    }\n    // checking if word contains two vowels\n    for (int i=word.size()-2;i>=0;i--)\
    \ {\n        char c = word[i];\n        // checking if c is a vowel\n        if\
    \ (c=='a' || c=='e' || c=='i' || c=='o' || c=='u') {\n            vowel_count++;\n\
    \            if (vowel_count>max_count) {\n                max_count=vowel_count;\n\
    \            }\n            if (vowel_count<min_count) {\n                min_count=vowel_count;\n\
    \            }\n        }\n    }\n    // If word contains two vowels\n    if (vowel_count>max_count)\
    \ {\n        return \"aeiou\";\n    }\n    // checking if word contains three\
    \ vowels\n    for (int i=word.size()-3;i>=0;i--) {\n        char c = word[i];\n\
    \        // checking if c is a vowel\n        if (c=='a' || c=='e' || c=='i' ||\
    \ c=='o' || c=='u') {\n            vowel_count++;\n            if (vowel_count>max_count)\
    \ {\n                max_count=vowel_count;\n            }\n            if (vowel_count<min_count)\
    \ {\n                min_count=vowel_count;\n            }\n        }\n    }\n\
    \    if (vowel_count>max_count) {\n        return \"aeiou\";\n    }\n    // checking\
    \ if word contains four vowels\n    for (int i=word.size()-4;i>=0;i--) {\n   \
    \     char c = word[i];\n        // checking if c is a vowel\n        if (c=='a'\
    \ || c=='e' || c=='i' || c=='o' || c=='u') {\n            vowel_count++;\n   \
    \         if (vowel_count>max_count) {\n                max_count=vowel_count;\n\
    \            }\n            if (vowel_count<min_count) {\n                min_count=vowel_count;\n\
    \            }\n        }\n    }\n    if (vowel_count>max_count) {\n        return\
    \ \"aeiou\";\n    }\n    // checking if word contains five vowels\n    for (int\
    \ i=word.size()-5;i>=0;i--) {\n        char c = word[i];\n        // checking\
    \ if c is a vowel\n        if (c=='a' || c=='e' || c=='i' || c=='o' || c=='u')\
    \ {\n            \n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppuc5aeky.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmppuc5aeky.cpp:86:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   86 | int main() {\n      |            ^\n/tmp/tmppuc5aeky.cpp:101:1:\
    \ error: expected \u2018}\u2019 at end of input\n  101 | }\n      | ^\n/tmp/tmppuc5aeky.cpp:80:40:\
    \ note: to match this \u2018{\u2019\n   80 |     for (int i=word.size()-5;i>=0;i--)\
    \ {\n      |                                        ^\n/tmp/tmppuc5aeky.cpp:101:1:\
    \ error: expected \u2018}\u2019 at end of input\n  101 | }\n      | ^\n/tmp/tmppuc5aeky.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmppuc5aeky.cpp:101:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  101 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    int left_end = word.size() - 1;\n    while\
    \ (left_end >= 0 && word[left_end] != 'a' && word[left_end] != 'e' && word[left_end]\
    \ != 'i'\n            && word[left_end] != 'o' && word[left_end] != 'u'){\n  \
    \      left_end -= 1;\n    }\n    int right_end = word.size();\n    while (right_end\
    \ >= 0 && word[right_end] != 'a' && word[right_end] != 'e' && word[right_end]\
    \ != 'i'\n            && word[right_end] != 'o' && word[right_end] != 'u'){\n\
    \        right_end -= 1;\n    }\n    int left_start = left_end - 1;\n    while\
    \ (left_start >= 0 && word[left_start] != 'a' && word[left_start] != 'e' && word[left_start]\
    \ != 'i'\n            && word[left_start] != 'o' && word[left_start] != 'u'){\n\
    \        left_start -= 1;\n    }\n    int right_start = right_end;\n    int vowel_start\
    \ = left_start;\n    int vowel_end = right_start;\n    std::string vowel;\n  \
    \  if (vowel_start < vowel_end && vowel_start > 0 && vowel_end < word.size())\
    \ {\n        vowel = word[vowel_start];\n    }\n    return vowel;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_k4m74gb: /tmp/tmp_k4m74gb.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    assert(word.size()>=2);\n    \n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int cnt=0;\n    \n    for(int i=word.length()-2; i>=0; --i){\n        if(\
    \ word[i] == word[i+1] ) ++cnt;\n    }\n    \n    if (cnt==0) {\n        return\
    \ \"\";\n    }\n    \n    int lower = word.length()-1;\n    int upper = word.length();\n\
    \    \n    while( lower >= 0 && word[lower]==word[upper] ){\n        --upper;\n\
    \        lower = upper;\n    }\n    \n    if ( lower >= 0 ) {\n        for ( int\
    \ i = upper; i >= lower; --i ) {\n            if ( word[i] == vowels[0] && word[i+1]\
    \ == vowels[2] ) {\n                return word;\n            }\n        }\n \
    \   }\n    \n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpw_8c0u28: /tmp/tmpw_8c0u28.cpp:43: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    \n    unordered_set<char> vow{'a',\
    \ 'e', 'i', 'o', 'u'};\n    int n = word.size();\n    \n    for (int i = 0; i\
    \ < n; i++) {\n        bool exist = false;\n        for (int j = i; j < n && !exist;\
    \ j++){\n            exist = (vow.find(word[j]) != vow.end());\n        }\n  \
    \      if(exist){\n            int m = i - 1;\n            int r = n-1;\n    \
    \        int f = 0;\n            \n            if(word[m] == word[i]){\n     \
    \           f = 1;\n            }\n            if(word[r] == word[i]){\n     \
    \           f = -1;\n            }\n            \n            while (m > 0 &&\
    \ word[m] == word[i]){\n                m--;\n                i++;\n         \
    \   }\n            while (r > 0 && word[r] == word[i]){\n                r--;\n\
    \                i -= 1;\n            }\n            \n            int l = m +\
    \ 1;\n            int h = n - 1;\n            \n            while (l < h && word[l]\
    \ == word[i]){\n                l++;\n                i -= 1;\n            }\n\
    \            while (r < h && word[r] == word[i]){\n                r--;\n    \
    \            i += 1;\n            }\n            \n            int k = (r-l)/2;\n\
    \            int c = word[k] == 'a' ? 0 : word[k] == 'e' ? 1 : word[k] == 'i'\
    \ ? 2 : word[k] == 'o' ? 3 : word[k] == 'u' ? 4 : word[k] == 'A' ? 5 : word[k]\
    \ == 'E' ? 6 : word[k] == 'I' ? 7 : word[k] == 'O' ? 8 : word[k] == 'U' ? 9 :\
    \ 10;\n            int d = c + f;\n            int q = word[i] == 'a' ? 1 : word[i]\
    \ == 'e' ? 2 : word[i] == 'i' ? 3 : word[i] == 'o' ? 4 : word[i] == 'u' ? 5 :\
    \ word[i] == 'A' ? 6 : word[i] == 'E' ? 7 : word[i] == 'I' ? 8 : word[i] == 'O'\
    \ ? 9 : 10;\n            int p = q + f;\n            int s = d - p;\n        \
    \    \n            if(s > 0 && s < n){\n                return word;\n       \
    \     }\n        }\n    }\n    \n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprd35opk3.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmprd35opk3.cpp:12:5: error: \u2018unordered_set\u2019 was not declared\
    \ in this scope\n   12 |     unordered_set<char> vow{'a', 'e', 'i', 'o', 'u'};\n\
    \      |     ^~~~~~~~~~~~~\n/tmp/tmprd35opk3.cpp:12:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/unordered_set:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n                 from\
    \ /tmp/tmprd35opk3.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:97:11: note:\
    \   \u2018std::unordered_set\u2019\n   97 |     class unordered_set\n      | \
    \          ^~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmprd35opk3.cpp:2:\n/usr/include/c++/9/unordered_set:68:13:\
    \ note:   \u2018std::pmr::unordered_set\u2019\n   68 |       using unordered_set\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmprd35opk3.cpp:12:19: error: expected\
    \ primary-expression before \u2018char\u2019\n   12 |     unordered_set<char>\
    \ vow{'a', 'e', 'i', 'o', 'u'};\n      |                   ^~~~\n/tmp/tmprd35opk3.cpp:18:22:\
    \ error: \u2018vow\u2019 was not declared in this scope; did you mean \u2018pow\u2019\
    ?\n   18 |             exist = (vow.find(word[j]) != vow.end());\n      |    \
    \                  ^~~\n      |                      pow\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i=0,j=0;\n    while(i<word.length() && j<word.length()) {\n\
    \        if(word[i]>='A' && word[i]<='Z') {\n            i++;\n        } else\
    \ if(word[j]>='A' && word[j]<='Z') {\n            j++;\n        } else {\n   \
    \         if(i>j){\n                return \"\";\n            }\n            else\
    \ {\n                return word[i];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmfwihieo.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpmfwihieo.cpp:21:30: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   21 |                 return word[i];\n      |                          \
    \    ^\n      |                              |\n      |                      \
    \        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka\
    \ char}\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string vowel1 = \"\"\
    ;\n    std::string vowel2 = \"\";\n    for (size_t i = 0; i < word.length(); i++)\
    \ {\n        char vowel = word[i];\n        if (vowels.find(vowel) != std::string::npos)\
    \ {\n            vowel1 = vowel1;\n            vowel2 = vowel2;\n        } else\
    \ if (vowels.find(vowel) == std::string::npos) {\n            vowel1 = \"\";\n\
    \            vowel2 = \"\";\n        }\n    }\n    std::string result = \"\";\n\
    \    if (vowel1 != \"\" && vowel2 != \"\") {\n        int min = (int)(vowel1.length())\
    \ * (int)(vowel2.length());\n        if (min > 0) min--;\n        int max = (int)(vowel1.length())\
    \ * (int)(vowel2.length()) + 1;\n        if (max > 0) max--;\n        if (max\
    \ < min) max = min;\n        int m = (int)(word.length()) - (max - min);\n   \
    \     char vowel_found = 0;\n        std::string vowel_found_string = \"\";\n\
    \        for (int i = m; i >= 0; i--) {\n            char ch = (char)(word[max\
    \ - 1] - i);\n            if (vowels.find(ch) != std::string::npos) {\n      \
    \          vowel_found = 1;\n                vowel_found_string = ch;\n      \
    \          break;\n            }\n        }\n        if (vowel_found == 1) {\n\
    \            result = vowel_found_string;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpapfef_uj: /tmp/tmpapfef_uj.cpp:49: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120398
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int length = word.size();\n    if (length == 0) {\n        return\
    \ \"\";\n    }\n    std::string vowel = \"AEIOUaeiou\";\n    int vowel_pos = 0;\n\
    \    int vowel_pos1 = 0;\n    int vowel_pos2 = length - 1;\n    // Use two pointers\
    \ for finding vowel from the right side\n    while ((vowel_pos1 < vowel_pos2)\
    \ && (vowel_pos2 >= 0)) {\n        std::string vowel_1 = word.substr(vowel_pos1\
    \ + 1, 1);\n        std::string vowel_2 = word.substr(vowel_pos2 + 1, 1);\n  \
    \      if (vowel_1 == vowel) {\n            vowel_pos = vowel_pos1;\n        \
    \    vowel_pos1 = vowel_pos1 + 1;\n        } else if (vowel_2 == vowel) {\n  \
    \          vowel_pos = vowel_pos2;\n            vowel_pos2 = vowel_pos2 - 1;\n\
    \        } else {\n            vowel_pos = -1;\n        }\n    }\n    if (vowel_pos\
    \ == -1) {\n        return \"\";\n    }\n    std::string vowel_v = word.substr(vowel_pos\
    \ + 1, 1);\n    return vowel_v;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660120402
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\nassert(word.length()==2);\nint len=word.length();\nstd::string res=\"\
    \";\nchar c=word[len-1];\nfor(int i=len-2; i>=0; i--) {\n    char curr=word[i];\n\
    \    if(c==curr) {\n        res.push_back(curr);\n        break;\n    }\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmk6g7fq_.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpmk6g7fq_.cpp:21:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   21 | int main() {\n      |            ^\n/tmp/tmpmk6g7fq_.cpp:36:1:\
    \ error: expected \u2018}\u2019 at end of input\n   36 | }\n      | ^\n/tmp/tmpmk6g7fq_.cpp:9:49:\
    \ note: to match this \u2018{\u2019\n    9 | std::string get_closest_vowel(std::string\
    \ word) {\n      |                                                 ^\n/tmp/tmpmk6g7fq_.cpp:36:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   36 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // write your code here\n    \n    \n    for(char ch=word.back();ch>='a'&&ch<='z';ch=word.back()){\n\
    \        word.pop_back();\n    }\n    \n    for(char ch=word.front();ch>='a'&&ch<='z';ch=word.front()){\n\
    \        word.pop_back();\n    }\n    \n    \n    \n    \n    for(char ch=word.back();ch>='a'&&ch<='z';ch=word.back()){\n\
    \        for(char ch1=word.front();ch1>='a'&&ch1<='z';ch1=word.front()){\n   \
    \         word.pop_back();\n            word.push_front(ch1);\n        }\n   \
    \ }\n    \n    \n    \n    for(char ch=word.front();ch>='a'&&ch<='z';ch=word.front()){\n\
    \        for(char ch1=word.back();ch1>='a'&&ch1<='z';ch1=word.back()){\n     \
    \       word.pop_back();\n            word.push_front(ch1);\n        }\n    }\n\
    \    \n    return word;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp000x3etq.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp000x3etq.cpp:27:18: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018push_front\u2019\
    \n   27 |             word.push_front(ch1);\n      |                  ^~~~~~~~~~\n\
    /tmp/tmp000x3etq.cpp:36:18: error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018push_front\u2019\n   36 |             word.push_front(ch1);\n\
    \      |                  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660120397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"AEIOUaeiou\";\n    int start = 0;\n    int\
    \ end = word.length() - 1;\n    std::string result = \"Error\";\n    while(start\
    \ <= end && start <= word.length() - 1) {\n        if (vowels.find(word[end])\
    \ != std::string::npos) {\n            end = word.length() - 1;\n            while\
    \ (start <= word.length() - 1 && vowels.find(word[start]) != std::string::npos)\
    \ {\n                start++;\n            }\n            int index = word.length()\
    \ - 1;\n            while (index <= end && index < word.length() - 1) {\n    \
    \            if (vowels.find(word[index]) != std::string::npos) {\n          \
    \          if (end - index == 0) {\n                        result = \"\";\n \
    \                   } else if (end - index < word.length() - 1) {\n          \
    \              result = word[end + 1];\n                    }\n              \
    \  }\n                index++;\n            }\n        }\n        start++;\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpofmh7m81: /tmp/tmpofmh7m81.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660120398
