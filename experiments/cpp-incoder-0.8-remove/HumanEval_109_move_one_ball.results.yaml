language: cpp
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long ans = 0;\n    for (long i = arr.size() - 1; i > 0; i--)\n        ans =\
    \ max(ans, arr[i] + i);\n    return ans == 0 || arr.empty();\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvilsgmh3.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpvilsgmh3.cpp:23:15: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   23 |         ans = max(ans,\
    \ arr[i] + i);\n      |               ^~~\n      |               std::max\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvilsgmh3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659822135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long size = arr.size();\n    int i;\n    int j;\n    int k = 0;\n    int l\
    \ = 0;\n    int m = 0;\n    long ans = 0;\n    long max;\n    // First we check\
    \ whether  array is empty or not\n    if (size == 0) {\n        return true;\n\
    \    }\n    // Then we check the maximum number\n    max = arr[0];\n    for (i\
    \ = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n\
    \        }\n    }\n    // If size is 1 then array is sorted in decreasing order.\n\
    \    if (size == 1) {\n        return true;\n    }\n    // For each element in\
    \ the array we perform a right shift operation\n    // and check if we can get\
    \ non-decreasing order for the array.\n    // Explanation:For any given element\
    \ of array we perform N right shift \n    // operations and check for the non-decreasing\
    \ order. \n    // Explanation:For example: arr[3] = 6 and if we perform 7 right\
    \ shift \n    // operations then arr[4] will not be in non-decreasing order because\
    \ it was\n    // already moved to arr[0]\n    for (i = 0; i < size - 1; i++) {\n\
    \        // For each element in the array we perform N right shift \n        //\
    \ operations and check for the non-decreasing order.\n        // We start from\
    \ the element which is right behind the last \n        // element and work our\
    \ way to the first element.\n        for (j = 0; j < size - 1 - i; j++) {\n  \
    \          arr[k] = arr[j];\n            // If j + 1 is the last element in array\
    \ then \n            // we move the element at j + 1 to the first position in\
    \ array \n            // i.e. arr[0]\n            if (j + 1 == size - 1) {\n \
    \               arr[k] = arr[j + 1];\n                arr[k + 1] = 0;\n      \
    \          break;\n            }\n            // For each element in the array\
    \ we perform N right shift \n            // operations and check for the non-decreasing\
    \ order.\n            // Here we start from the element which is right behind\
    \ the \n            // last element and work our way to the first element.\n \
    \           for (l = j + 1; l < size; l++) {\n                arr[k] = arr[l];\n\
    \                // If we reached the last element of the array then we \n   \
    \             // perform one right shift operation \n                // i.e. move\
    \ all the elements of array one position to the \n                // left side\
    \ i.e. arr[0].\n                if (l == size - 1) {\n                    arr[k]\
    \ = arr[0];\n                    arr[k + 1] = 0;\n                    break;\n\
    \                }\n                // If we reached the last element of the array\
    \ then we \n                // perform one right shift operation \n          \
    \      // i.e. move all the elements of array one position to the \n         \
    \       // left side i.e. arr[0].\n                if (l == size - 2) {\n    \
    \                arr[k] = arr[l];\n                    arr[k + 1] = 0;\n     \
    \               break;\n                }\n                // If we reached the\
    \ last element of the array then we \n                // \n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph48ojvbe.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmph48ojvbe.cpp:93:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n   93 | int main() {\n      |     \
    \       ^\n/tmp/tmph48ojvbe.cpp:100:1: error: expected \u2018}\u2019 at end of\
    \ input\n  100 | }\n      | ^\n/tmp/tmph48ojvbe.cpp:56:44: note: to match this\
    \ \u2018{\u2019\n   56 |         for (j = 0; j < size - 1 - i; j++) {\n      |\
    \                                            ^\n/tmp/tmph48ojvbe.cpp:100:1: error:\
    \ expected \u2018}\u2019 at end of input\n  100 | }\n      | ^\n/tmp/tmph48ojvbe.cpp:51:36:\
    \ note: to match this \u2018{\u2019\n   51 |     for (i = 0; i < size - 1; i++)\
    \ {\n      |                                    ^\n/tmp/tmph48ojvbe.cpp:100:1:\
    \ error: expected \u2018}\u2019 at end of input\n  100 | }\n      | ^\n/tmp/tmph48ojvbe.cpp:20:43:\
    \ note: to match this \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long>\
    \ arr) {\n      |                                           ^\n/tmp/tmph48ojvbe.cpp:100:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  100 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long ans = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        ans = arr[i]\
    \ << 1;\n        if (arr[i] > ans) {\n            ans = arr[i] >> 1;\n       \
    \ }\n    }\n    return (ans <= arr[0]);\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpg_6sen8d: /tmp/tmpg_6sen8d.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // write your code here\n    long n = arr.size();\n    long sum = 0;\n    //\
    \ for(int i=0; i<n; i++){\n    //     sum += arr[i];\n    // }\n    // assert(sum\
    \ == n*(n-1)/2);\n    int i = 0;\n    long cur = 0;\n    for(auto v: arr)\n  \
    \  {\n        cur = cur+v;\n        sum += cur;\n        if(sum == n*(n-1)/2)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpr5uf707g: /tmp/tmpr5uf707g.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)10, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    // return True/False\n    long long sum = 0;\n\
    \    for(int i=0; i<arr.size(); ++i){\n        sum+=arr[i];\n    }\n    if(sum\
    \ >= 2){\n        return false;\n    }\n    int temp=0;\n    for(int i=0; i<arr.size();\
    \ ++i){\n        temp+=arr[i];\n        if(temp>2){\n            temp%=2;\n  \
    \          temp+=2;\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpo2c3d71_: /tmp/tmpo2c3d71_.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty())\n        return true;\n    long long ans = 1;\n    for(long\
    \ long i=arr.size()-1;i>=0;i--) {\n        ans <<= 1;\n        ans |= arr[i];\n\
    \    }\n    long long count = 0;\n    for(long long i=1; i!=ans; i++) {\n    \
    \    count++;\n        if(ans%i == 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkg0bv6ti: /tmp/tmpkg0bv6ti.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int x = arr[n-1];\n    for (int i = n-2; i >= 0; i--)\
    \ {\n        if (arr[i] < x) {\n            int temp = arr[i];\n            arr[i]\
    \ = arr[i+1];\n            arr[i+1] = temp;\n        }\n    }\n    if (arr[0]\
    \ == arr[n-1]) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp62f4ewpq: /tmp/tmp62f4ewpq.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0) {\n        return true;\n    }\n    // A right shift operation\
    \ means shifting all elements of the array by one\n    // position in the right\
    \ direction. The last element of the array will\n    // be moved to the starting\
    \ position in the array i.e. 0th index. \n    for (int i = 0; i < arr.size() -\
    \ 1; ++i) {\n        // This loop will help shifting elements one by one\n   \
    \     arr[i] = arr[i + 1];\n    }\n    arr[arr.size() - 1] = 0;\n\n    // Perform\
    \ a right shift operation on the given array and check if the\n    // array is\
    \ non-decreasing or not, if it is then return true else return\n    // false\n\
    \    for (int i = arr.size() - 2; i >= 0; --i) {\n        if (arr[i] > arr[i +\
    \ 1]) {\n            return false;\n        }\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplo0kx2p2: /tmp/tmplo0kx2p2.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long n = arr.size();\n    if (n==0) return true;\n    long ans = arr[0];\n\
    \    for (int i=1; i<n; i++) {\n        while (ans > arr[i]) {\n            ans--;\n\
    \            std::swap(arr[i], arr[i-1]);\n        }\n    }\n    return ans==arr[0];\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6a2zh9yc: /tmp/tmp6a2zh9yc.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    \n    long long i=0;\n    while (i<arr.size()\
    \ && i>0) {\n        if (arr[i]<arr[i-1]) {\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::swap(arr[i-1],arr[i]);\n\
    \            std::swap(arr[i-1],arr[i]);\n            std::\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpznb7bftk.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpznb7bftk.cpp:75:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   75 | }\n      | ^\n/tmp/tmpznb7bftk.cpp:76:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   76\
    \ | int main() {\n      |            ^\n/tmp/tmpznb7bftk.cpp:83:1: error: expected\
    \ \u2018}\u2019 at end of input\n   83 | }\n      | ^\n/tmp/tmpznb7bftk.cpp:24:33:\
    \ note: to match this \u2018{\u2019\n   24 |     while (i<arr.size() && i>0) {\n\
    \      |                                 ^\n/tmp/tmpznb7bftk.cpp:83:1: error:\
    \ expected \u2018}\u2019 at end of input\n   83 | }\n      | ^\n/tmp/tmpznb7bftk.cpp:20:43:\
    \ note: to match this \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long>\
    \ arr) {\n      |                                           ^\n/tmp/tmpznb7bftk.cpp:83:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   83 | }\n      | ^\n"
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    int n = arr.size();\n\tstd::vector<long> arr2;\n\tarr2 = arr;\n\tint temp;\n\t\
    long max = std::numeric_limits<long>::min();\n\t\n\tfor (int i = 0; i < n; i++)\
    \ {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (arr[j] < max) {\n\t\t\t\tmax\
    \ = arr[j];\n\t\t\t\ttemp = j;\n\t\t\t}\n\t\t}\n\t\tarr2[temp] = arr[i];\n\t\t\
    arr[i] = max;\n\t\tmax = std::numeric_limits<long>::min();\n\t\ttemp = 0;\n\t\
    }\n\treturn (arr == arr2);\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy5dpgbm2: /tmp/tmpy5dpgbm2.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    for(long i=1; i<arr.size(); i++) {\n        arr[i] =\
    \ arr[i] - arr[i-1];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpezms3asd: /tmp/tmpezms3asd.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() <= 1) {\n        return true;\n    }\n    long n = arr.size()\
    \ - 1;\n    long k = arr.size() - 2;\n    long ans = 0;\n    while (k >= 0) {\n\
    \        ans += arr[k];\n        arr[k + 1] = arr[k];\n        k--;\n    }\n \
    \   long temp = 0;\n    for (int i = 0; i < n - 1; i++) {\n        temp = ans\
    \ + arr[i];\n        arr[i] = temp;\n    }\n    temp = ans + arr[n - 1];\n   \
    \ arr[n - 1] = temp;\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpw8908swk: /tmp/tmpw8908swk.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    \n    if (n == 0) return true;\n    \n    std::stack<long>\
    \ s;\n    int left = n;\n    long sum = 0;\n    \n    for (int i = 0; i < n; i++){\n\
    \        sum = arr[i] - sum;\n        s.push(sum);\n        \n        while (!s.empty()){\n\
    \            int temp = s.top();\n            s.pop();\n            \n       \
    \     if (sum >= temp){\n                left = left - 1;\n                sum\
    \ = sum - temp;\n            }\n        }\n    }\n    \n    if (left == 0) return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1apqpqp5: /tmp/tmp1apqpqp5.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // return False if given array is empty\n    if (arr.empty()) {\n        return\
    \ false;\n    }\n\n    int length = arr.size();\n\n    for (int i = 1; i < length;\
    \ i++) {\n        long temp = arr[i];\n        arr[i] = arr[i - 1];\n        arr[i\
    \ - 1] = temp;\n    }\n\n    // return False if array is non-decreasing\n    if\
    \ (arr[length - 1] > arr[length - 2]) {\n        return false;\n    }\n\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp17uwkje4: /tmp/tmp17uwkje4.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    int n = arr.size();\n\tint j;\n\tlong sum;\n\tlong a = 0;\n\tint i = arr.size()-1;\n\
    \tlong temp;\n\tassert(i != -1);\n\t\n\tfor(int k = arr.size(); k > i; k--)\n\t\
    {\n\t\tsum = a + arr[k];\n\t\ta = (sum - a) / 2;\n\t}\n\ttemp = a;\n\tj = 0;\n\
    \twhile(j<n && a != 0)\n\t{\n\t\tif(temp <= arr[j])\n\t\t{\n\t\t\tsum += arr[j];\n\
    \t\t\ta = (sum - a) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t\ta = 0;\n\t\
    \t}\n\t}\n\tif(sum == 0)\n\t\treturn true;\n\treturn false;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5p0kwv1d: /tmp/tmp5p0kwv1d.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if(arr.size()\
    \ == 0)\n    return true;\n  \n  for(int i=1; i<arr.size(); i++) {\n    arr[i]\
    \ = (arr[i-1] + arr[i])%1000000007;\n  }\n  \n  for(auto &elem : arr) {\n    long\
    \ temp = elem;\n    elem /= 1000000007;\n    if(temp < arr[0]) {\n      return\
    \ false;\n    }\n    arr[0] = temp;\n  }\n  \n  \n  return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1nexnjna: /tmp/tmp1nexnjna.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // TODO: Write your code here\n    for(long i=0;i<arr.size();i++){\n      \
    \  if(arr[i]>0){\n            for(int j=arr.size()-1;j>=i;j--){\n            \
    \    long x=arr[j];\n                arr[j]=arr[j-1];\n                arr[j-1]=x;\n\
    \            }\n        }\n    }\n    if(arr.size()==1){\n        return true;\n\
    \    }else{\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptes7xg12: /tmp/tmptes7xg12.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0)\n        return true;\n    // Using 'std::rotate' we could\
    \ perform 'N' right shifts operation to \n    // achieve non-decreasing order.\n\
    \    long long s = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n     \
    \   long long x = arr[i];\n        std::rotate(arr.begin(), arr.begin() + i -\
    \ 1, arr.end());\n        long long t = arr[i];\n        std::rotate(arr.begin()\
    \ + i, arr.begin() + i + 1, arr.end());\n        arr[i] = t;\n        s = std::max(s,\
    \ x);\n    }\n    if (s == arr[0])\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpju6tc0hp: /tmp/tmpju6tc0hp.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)4, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long N = arr.size();\n    long last_val = arr[0];\n    long min_val = arr[0];\n\
    \    for(long i=1; i<N; i++){\n        long curr_val = arr[i];\n        if(curr_val\
    \ > last_val){\n            return false;\n        }\n        min_val = std::min(min_val,\
    \ curr_val);\n        last_val = curr_val;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkmtoib74: /tmp/tmpkmtoib74.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long l=arr.size()-1;\n    for(long i=l;i>=0;i--)\n    {\n        if(arr[i]>arr[i-1])\n\
    \        {\n            break;\n        }\n    }\n    long j=arr.size()-1;\n \
    \   for(long k=j;k>=0;k--)\n    {\n        if(arr[k]>arr[k+1])\n        {\n  \
    \          break;\n        }\n    }\n    if(i==0)\n    {\n        if(j==0)\n \
    \       {\n            return true;\n        }\n    }\n    else\n    {\n     \
    \   if(j==0)\n        {\n            return false;\n        }\n        else\n\
    \        {\n            if(arr[i]<arr[j])\n            {\n                return\
    \ false;\n            }\n            else\n            {\n                return\
    \ move_one_ball(arr);\n            }\n        }\n    }\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp11c3evd9.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp11c3evd9.cpp:37:8: error: \u2018i\u2019 was not declared\
    \ in this scope\n   37 |     if(i==0)\n      |        ^\n/tmp/tmp11c3evd9.cpp:62:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   62 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1659822135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code goes here\n    long ans = arr[0];\n    for(long i=1;i<arr.size();i++){\n\
    \        if(arr[i]<arr[i-1]){\n            ans++;\n        }else{\n          \
    \  ans--;\n        }\n    }\n    return ans==0;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbcnc03wq: /tmp/tmpbcnc03wq.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822136
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  assert(arr.size()\
    \ != 0);\n  if (arr.size() == 1)\n  {\n    return true;\n  }\n  \n  if (arr.size()\
    \ == 2) {\n    std::swap(arr[0], arr[1]);\n    return true;\n  }\n  \n  if (arr.size()\
    \ >= 3)\n  {\n    if (move_one_ball(arr)) {\n      std::swap(arr[0], arr[1]);\n\
    \      if (move_one_ball(arr)) {\n        std::swap(arr[0], arr[1]);\n      }\n\
    \    }\n  }\n  \n  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822141
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    long min_v = *min_element(arr.begin(), arr.end());\
    \ \n    long max_v = *max_element(arr.begin(), arr.end()); \n    int min_i = arr.size()\
    \ - 1; \n    int max_i = -1; \n    // We will run N number of times for N number\
    \ of array\n    for (int i = 0; i < n; i++) {\n        // We will perform shift\
    \ N times to achieve the non decreasing order\n        for (int j = 0; j < n;\
    \ j++) {\n            if (arr[j] > arr[j+1]) {\n                arr[j] = arr[j+1];\n\
    \                arr[j+1] = arr[j];\n            }\n        }\n        if (max_v\
    \ < arr[i]) {\n            max_v = arr[i];\n            max_i = i;\n        }\n\
    \        if (min_v > arr[i]) {\n            min_v = arr[i];\n            min_i\
    \ = i;\n        }\n    }\n    if (max_v >= arr[i]) {\n        // We have found\
    \ a non-decreasing order for the given array\n        // Let's shift all the elements\
    \ one position to the right\n        // and then check for the right position\
    \ of max_v\n        for (int i = max_i; i >= min_i; i--) {\n            arr[i]\
    \ = arr[i-1];\n        }\n        arr[0] = max_v; \n        return true;\n   \
    \ } else {\n        // We don't have any non-decreasing order for the given array\n\
    \        return false;\n    }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr5xrftjf.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpr5xrftjf.cpp:44:22: error: \u2018i\u2019 was not declared\
    \ in this scope\n   44 |     if (max_v >= arr[i]) {\n      |                 \
    \     ^\n/tmp/tmpr5xrftjf.cpp:57:1: warning: control reaches end of non-void function\
    \ [-Wreturn-type]\n   57 | }\n      | ^\n"
  stdout: ''
  timestamp: 1659822137
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size() == 0){\n        return true;\n    }\n    long left_shift = 0;\n\
    \    long right_shift = 1;\n    for(long i=0;i<arr.size();i++){\n        if(arr[i]\
    \ < arr[left_shift]){\n            long temp = arr[i];\n            arr[i] = arr[left_shift];\n\
    \            arr[left_shift] = temp;\n            left_shift++;\n        }\n \
    \   }\n    for(long i=0;i<arr.size();i++){\n        if(arr[i] < arr[right_shift]){\n\
    \            long temp = arr[i];\n            arr[i] = arr[right_shift];\n   \
    \         arr[right_shift] = temp;\n            right_shift--;\n        }\n  \
    \  }\n    if(left_shift > right_shift){\n        return true;\n    }else{\n  \
    \      return false;\n    }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659822137
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code goes here\n    int N = arr.size();\n    int ans = 0;\n    long\
    \ a = 0;\n    for (int i = 1; i < N; i++) {\n        a = arr[i];\n        arr[i]\
    \ = arr[N - 1 - i];\n        arr[N - 1 - i] = a;\n        ans++;\n    }\n    return\
    \ ans == N;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbth8b043: /tmp/tmpbth8b043.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \      int i=0;\n        int n=arr.size();\n        long ans=0;\n        long\
    \ temp=arr[0];\n        int ansa=0;\n        while(ansa!=n){\n               \
    \ ans=temp;\n                ansa=i;\n                for(;i<n;i++){\n       \
    \                 temp=arr[i];\n                        ans=ans+temp;\n      \
    \          }\n                arr[i]=ans;\n                i=i+1;\n        }\n\
    \        ans=arr[0];\n        int j=1;\n        for(;j<n;j++){\n             \
    \   temp=arr[j];\n                if(temp>ans)\n                        return\
    \ false;\n        }\n        return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if( arr.size() == 0) {\n        return true;\n    }\n\n    if( arr.size() ==\
    \ 1) {\n        return false;\n    }\n\n    int right_shift_count = arr.size()-1;\n\
    \n    if( arr[right_shift_count] >= arr[0]) {\n        return false;\n    }\n\n\
    \    int left_shift_count = 0;\n    int total_elements = arr.size();\n    long\
    \ left_shift_element = arr[left_shift_count];\n\n    long right_shift_element\
    \ = arr[right_shift_count];\n    bool found = false;\n    for(int i=0;i<total_elements;i++)\
    \ {\n        if(arr[i] >= left_shift_element && arr[i] <= right_shift_element)\
    \ {\n            found = true;\n        } else {\n            found = false;\n\
    \        }\n        if(found == false) {\n            break;\n        }\n    }\n\
    \    if( found == true) {\n        for(int i=0;i<left_shift_count;i++) {\n   \
    \         arr[i+1] = arr[i];\n        }\n        arr[left_shift_count] = 0;\n\
    \    }\n    if( arr.size()-1 == left_shift_count) {\n        return true;\n  \
    \  }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpi8of8j5h: /tmp/tmpi8of8j5h.cpp:64: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int x = arr.size()-1;\n    int y = x-1;\n    int res = 1;\n    long temp =\
    \ arr[arr.size()-1];\n    for(int i=0;i<arr.size();i++){\n        arr[i] = arr[i]-temp;\n\
    \        temp = arr[i];\n    }\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]!=x){\n\
    \            arr[i] = arr[i]-x;\n            break;\n        }\n    }\n    for(int\
    \ i=0;i<arr.size();i++){\n        arr[arr.size()-1] = arr[i]+x;\n    }\n    for(int\
    \ i=0;i<arr.size();i++){\n        arr[i] = temp;\n    }\n    for(int i=0;i<arr.size();i++){\n\
    \        temp = arr[i];\n    }\n    return res == 0;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpa4hck76l: /tmp/tmpa4hck76l.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size() <= 1) return true;\n    if(arr.size() == 2) return (arr[0] <=\
    \ arr[1]) || (arr[1] < arr[0]);\n    std::vector<long> temp(arr);\n    temp.resize(arr.size()-1);\n\
    \    temp[0] = arr[arr.size()-1];\n    long left_pos = temp.size();\n    long\
    \ right_pos = 0;\n    while(left_pos > 0 && right_pos < temp.size()-1) {\n   \
    \     if((arr[left_pos] < temp[right_pos]) || (arr[0] < temp[0])){\n         \
    \   std::swap(temp[left_pos], temp[right_pos]);\n            right_pos += 1;\n\
    \        }\n        left_pos -= 1;\n    }\n    temp[0] = arr[0];\n    for(size_t\
    \ i = 1; i < temp.size(); i++) {\n        arr[i] = temp[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps7t41zw8: /tmp/tmps7t41zw8.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long N = arr.size(); // number of elements in the array\n    assert(N >0);\n\
    \    if(N==1) {\n        return true; // empty array\n    }\n    long long ans=0;\n\
    \    long long temp;\n    for(int i=1;i<N;i++) {\n        if(arr[i]<arr[i-1])\
    \ {\n            temp = arr[i-1];\n            arr[i-1] = arr[i];\n          \
    \  arr[i] = temp;\n        }\n    }\n    for(int i=1;i<N;i++) {\n        ans =\
    \ max(ans, arr[i]);\n    }\n    return ans==0;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuqlo2ave.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpuqlo2ave.cpp:36:15: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   36 |         ans = max(ans,\
    \ arr[i]);\n      |               ^~~\n      |               std::max\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuqlo2ave.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    if (n <= 1) return true;\n    int count = 0;\n   \
    \ for (int i = 0; i < n; i++) {\n        if (i == 0) {\n            if (arr[i]\
    \ < arr[n-1]) return true;\n            else  return false;\n        }\n     \
    \   if (arr[i] > arr[i-1]) {\n            count++;\n            if (count == 2)\
    \ return true;\n            else  return false;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmjz9pj1l: /tmp/tmpmjz9pj1l.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int size = arr.size();\n    if(size == 0)\n        return true;\n    \n   \
    \ int last_val = arr[size - 1];\n    int curr_val = arr[size - 2];\n    for(int\
    \ i = 1; i < size - 1; i++)\n    {\n        if(arr[i] >= last_val)\n        {\n\
    \            int temp = arr[i];\n            arr[i] = curr_val;\n            curr_val\
    \ = temp;\n        }\n    }\n    arr[size - 1] = curr_val;\n    \n    for(size_t\
    \ i = 0; i < size; ++i)\n    {\n        arr[i] = arr[i] + 1;\n    }\n    \n  \
    \  for(int i = 0; i < size-1; ++i)\n    {\n        if(arr[i] > arr[size - 1])\n\
    \        {\n            return false;\n        }\n    }\n    \n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here.\n    if (arr.size() == 0) {\n        return true;\n\
    \    }\n    int n = arr.size();\n    int i = 0;\n    int j = n - 1;\n    for (int\
    \ k = n; k >= 0; k--) {\n        std::swap(arr[i], arr[j]);\n        if (arr[j]\
    \ < arr[i]) {\n            j--;\n        } else {\n            i++;\n        }\n\
    \    }\n    return arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp63o1ra6c: /tmp/tmp63o1ra6c.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // your code here\n    if (arr.size() == 0) {\n        return true;\n    }\n\
    \n    long temp;\n    for (long i = 0, x = arr.size(); i <= x; i++, x--) {\n \
    \       temp = arr[i];\n        arr[i] = arr[x];\n        arr[x] = temp;\n   \
    \ }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpv6hd0h3p: /tmp/tmpv6hd0h3p.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size() == 0)\n        return true;\n    int left_most = arr.size() -\
    \ 1;\n    int right_most = arr.size() - 1;\n    for(long i = 0; i < arr.size();\
    \ i++){\n        int index = arr.size() - 1 - i;\n        while(left_most > 0){\n\
    \            long temp = arr[left_most];\n            arr[left_most] = arr[index];\n\
    \            arr[index] = temp;\n            left_most--;\n        }\n       \
    \ while(right_most > 0){\n            long temp = arr[right_most];\n         \
    \   arr[right_most] = arr[index];\n            arr[index] = temp;\n          \
    \  right_most--;\n        }\n    }\n    if(arr.size() == 1){\n        return true;\n\
    \    }\n    bool temp = move_one_ball(arr);\n    return temp;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822143
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int pos = n - 1;\n    std::vector<long> temp;\n  \
    \  for (int i = 0; i < n; i++) {\n        temp.push_back(arr[i]);\n    }\n   \
    \ while (pos >= 0) {\n        arr[pos--] = temp[pos];\n    }\n    arr.assign((long)\
    \ n, 0);\n    for (int i = 0; i < n; i++) {\n        arr[i] = arr[i + 1];\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuetxp378: /tmp/tmpuetxp378.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int s = arr.size();\n    for (int i = 1; i <= s; i++) {\n        // swap arr[i\
    \ - 1] and arr[i]\n        std::swap(arr[i - 1], arr[i]);\n\n        // move all\
    \ elements to the left\n        for (int j = s; j > i; --j) {\n            std::swap(arr[j],\
    \ arr[j - 1]);\n        }\n    }\n    return arr.size() == 0;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpti879v8r: /tmp/tmpti879v8r.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    long left = 0,\n        right = 0;\n    long temp\
    \ = arr[0];\n    for (size_t i = 1; i < arr.size(); i++) {\n        left = arr[i]\
    \ + left;\n        right = left + arr[i];\n        if (right > temp) {\n     \
    \       temp = right;\n        }\n        arr[i] = temp - left;\n        arr[i\
    \ - 1] = left + temp;\n    }\n    return arr[0] == 0;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8hj1t1x9: /tmp/tmp8hj1t1x9.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  std::stack<int>\
    \ s;\n  std::stack<int>::iterator it = arr.begin();\n  int i = it;\n  int temp\
    \ = 0;\n  while (i != arr.end()) {\n    temp = *i;\n    s.push(i);\n    s.pop();\n\
    \    it++;\n    int index = i;\n    while (it != arr.end() && index != s.top())\
    \ {\n      it--;\n      index--;\n    }\n    if (index != s.top()) {\n      *it\
    \ = temp;\n      i--;\n    }\n  }\n  if (s.empty()) {\n    return true;\n  }\n\
    \  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd45dql39.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpd45dql39.cpp:22:20: error: \u2018iterator\u2019 is not\
    \ a member of \u2018std::stack<int>\u2019\n   22 |   std::stack<int>::iterator\
    \ it = arr.begin();\n      |                    ^~~~~~~~\n/tmp/tmpd45dql39.cpp:23:11:\
    \ error: \u2018it\u2019 was not declared in this scope; did you mean \u2018i\u2019\
    ?\n   23 |   int i = it;\n      |           ^~\n      |           i\n/tmp/tmpd45dql39.cpp:25:12:\
    \ error: no match for \u2018operator!=\u2019 (operand types are \u2018int\u2019\
    \ and \u2018std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019})\n   25 |   while (i != arr.end()) {\n\
    \      |          ~ ^~ ~~~~~~~~~\n      |          |           |\n      |    \
    \      int         std::vector<long int>::iterator {aka __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpd45dql39.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  900 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-s"
  stdout: ''
  timestamp: 1659822138
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    if (arr.size() == 0) {\n        return true;\n    }\n\
    \    // Find the starting position\n    auto it = std::find(arr.begin(), arr.end(),\
    \ 0);\n    auto pos = it - arr.begin();\n    // Perform one right shift operation\
    \ N times and check if the array is\n    // non-decreasing using two conditions.\n\
    \    for (size_t i = 0; i < arr.size(); i++) {\n        auto temp = arr[i];\n\
    \        for (size_t j = 0; j < arr.size(); j++) {\n            arr[j] >>= 1;\n\
    \        }\n        if (temp < arr[j]) {\n            return false;\n        }\n\
    \    }\n    // Move the last element to the starting position.\n    arr[pos] >>=\
    \ 1;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9pt691em.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp9pt691em.cpp:35:24: error: \u2018j\u2019 was not declared\
    \ in this scope\n   35 |         if (temp < arr[j]) {\n      |               \
    \         ^\n"
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    std::vector<bool> visited(n);\n    int max_val = *std::max_element(arr.begin(),\
    \ arr.end()) + 1;\n    \n    for (int i = 1; i <= max_val; ++i) \n    {\n    \
    \    if (visited[i]) \n        {\n            continue;\n        }\n\n       \
    \ visited[i] = true;\n        // Perform N right shift operations.\n        for\
    \ (int j = 1; j <= n; ++j) \n        {\n            if (j >= i) \n           \
    \ {\n                arr[j] += arr[j - i];\n            }\n            \n    \
    \        arr[j] -= arr[j - i];\n        }\n    }\n    \n    return arr.size()\
    \ == 0 || arr[n - 1] < 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpkn58q0l0': free(): invalid pointer: 0x0000000000d75c50\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b0c3c7b6329]\n\
    /tmp/tmpkn58q0l0[0x401f18]\n/tmp/tmpkn58q0l0[0x401ac2]\n/tmp/tmpkn58q0l0[0x401cb6]\n\
    /tmp/tmpkn58q0l0[0x4017a6]\n/tmp/tmpkn58q0l0[0x40145e]\n/tmp/tmpkn58q0l0[0x400b5a]\n\
    /tmp/tmpkn58q0l0[0x400c5a]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b0c3c757555]\n\
    /tmp/tmpkn58q0l0[0x4008a9]\n======= Memory map: ========\n00400000-00404000 r-xp\
    \ 00000000 08:02 2248925                            /tmp/tmpkn58q0l0\n00603000-00604000\
    \ r--p 00003000 08:02 2248925                            /tmp/tmpkn58q0l0\n00604000-00605000\
    \ rw-p 00004000 08:02 2248925                            /tmp/tmpkn58q0l0\n00d64000-00d96000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b0c3bc1e000-2b0c3bc40000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b0c3bc40000-2b0c3bc43000\
    \ rw-p 00000000 00:00 0 \n2b0c3bc5b000-2b0c3bc5f000 rw-p 00000000 00:00 0 \n2b0c3be3f000-2b0c3be40000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b0c3be40000-2b0c3be41000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b0c3be41000-2b0c3be42000\
    \ rw-p 00000000 00:00 0 \n2b0c3be42000-2b0c3c00b000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b0c3c00b000-2b0c3c20a000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b0c3c20a000-2b0c3c215000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b0c3c215000-2b0c3c218000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b0c3c218000-2b0c3c21b000 rw-p 00000000 00:00 0 \n2b0c3c21b000-2b0c3c31c000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b0c3c31c000-2b0c3c51b000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b0c3c51b000-2b0c3c51c000\
    \ r--p 00100000 08:01 50332773          "
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    for(auto &v : arr) \n      v >>= 1;\n    std::sort(arr.begin(),\
    \ arr.end()); // sorting is needed\n    for(auto &v : arr) \n      v >>= 1; //\
    \ shifting 1 time\n    // Now we will check\n    if(arr.back() <= 0) return false;\n\
    \    else return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpi90izoxk: /tmp/tmpi90izoxk.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int i = 0, j = 0, k = 0;\n    std::vector<bool> v(n);\n\
    \    while(i < n) {\n        v[i] = 0;\n        i++;\n    }\n\n    while(j < n)\
    \ {\n        v[j] = 0;\n        j++;\n    }\n\n    while(k != n) {\n        if(v[k]\
    \ == 1) {\n            i++;\n            v[i] = 1;\n        }\n        if(v[k]\
    \ == 1) {\n            j++;\n            v[j] = 1;\n        }\n        k++;\n\
    \    }\n\n    int m = 0;\n    while(m < n) {\n        if(v[m] == 1)\n        \
    \    m++;\n        else\n            return false;\n    }\n\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyck4dw1t: /tmp/tmpyck4dw1t.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822138
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0) {\n        return true;\n    }\n    int size = arr.size();\n\
    \    int last_element = arr[size - 1];\n    int last_element_index = size - 1;\n\
    \    int left_shifted_size = last_element >> 1;\n    int right_shifted_size =\
    \ last_element >> 1;\n    if (left_shifted_size == 0 && right_shifted_size ==\
    \ 0) {\n        return true;\n    }\n    int left_shifted_array[] = { 0 };\n \
    \   int right_shifted_array[] = { 0 };\n    for (int i = 0; i < left_shifted_size;\
    \ i++) {\n        left_shifted_array[i] = arr[i];\n    }\n    for (int i = left_shifted_size;\
    \ i <= right_shifted_size; i++) {\n        right_shifted_array[i] = arr[i];\n\
    \    }\n    // shift right by 1\n    std::vector<long> left_shifted_array1(left_shifted_array,\
    \ left_shifted_array + left_shifted_size);\n    std::vector<long> right_shifted_array1(right_shifted_array,\
    \ right_shifted_array + right_shifted_size);\n    std::vector<long> left_shifted_array2(left_shifted_array1.begin(),\
    \ left_shifted_array1.end());\n    std::vector<long> right_shifted_array2(right_shifted_array1.begin(),\
    \ right_shifted_array1.end());\n    std::vector<long> sorted_array(left_shifted_array2.begin(),\
    \ left_shifted_array2.end());\n    std::sort(sorted_array.begin(), sorted_array.end());\n\
    \    std::vector<long> sorted_array2(left_shifted_array2.begin(), left_shifted_array2.end());\n\
    \    std::sort(sorted_array2.begin(), sorted_array2.end());\n    if (sorted_array\
    \ == sorted_array2) {\n        return false;\n    }\n    int first_element_index\
    \ = sorted_array2.size();\n    int last_element_index = sorted_array2.size() -\
    \ 1;\n    for (int i = last_element_index; i >= 0; i--) {\n        arr[first_element_index--]\
    \ = sorted_array2[i];\n    }\n    long last_element = sorted_array2[last_element_index];\n\
    \    // shift left by 1\n    std::vector<long> left_shifted_array3(left_shifted_array2.begin(),\
    \ left_shifted_array2.end());\n    std::vector<long> right_shifted_array3(right_shifted_array2.begin(),\
    \ right_shifted_array2.end());\n    std::vector<long> left_shifted_array4(left_shifted_array3.begin(),\
    \ left_shifted_array3.end());\n    std::vector<long> right_shifted_array4(right_shifted_array3.begin(),\
    \ right_shifted_array3.end());\n    std::vector<long> sorted_array3(left_shifted_array4.begin(),\
    \ left_shifted_array4.end());\n    std::sort(sorted_array3.begin(), sorted_array3.end());\n\
    \    std::vector<long> sorted_array4(\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7fqmnxe0.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7fqmnxe0.cpp:53:9: error: redeclaration of \u2018int last_element_index\u2019\
    \n   53 |     int last_element_index = sorted_array2.size() - 1;\n      |    \
    \     ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7fqmnxe0.cpp:26:9: note: \u2018int last_element_index\u2019\
    \ previously declared here\n   26 |     int last_element_index = size - 1;\n \
    \     |         ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7fqmnxe0.cpp:57:10: error: conflicting\
    \ declaration \u2018long int last_element\u2019\n   57 |     long last_element\
    \ = sorted_array2[last_element_index];\n      |          ^~~~~~~~~~~~\n/tmp/tmp7fqmnxe0.cpp:25:9:\
    \ note: previous declaration as \u2018int last_element\u2019\n   25 |     int\
    \ last_element = arr[size - 1];\n      |         ^~~~~~~~~~~~\n/tmp/tmp7fqmnxe0.cpp:66:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   66 | }\n \
    \     | ^\n/tmp/tmp7fqmnxe0.cpp:66:1: error: expected \u2018,\u2019 or \u2018\
    ;\u2019 before \u2018}\u2019 token\n/tmp/tmp7fqmnxe0.cpp:66:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   66 | }\n      | ^\n"
  stdout: ''
  timestamp: 1659822137
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // code here\n    long temp = 0;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1]\
    \ = temp;\n    }\n    if (arr.size() > 1) {\n        long temp = arr[arr.size()\
    \ - 1];\n        arr[arr.size() - 1] = arr[0];\n        arr[0] = temp;\n    }\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        std::cout << arr[i] << \"\
    \ \";\n    }\n    std::cout << std::endl;\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpti7wvsej': free(): invalid next size (fast): 0x000000000121dc20\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2adcd9a8f329]\n\
    /tmp/tmpti7wvsej[0x4018a2]\n/tmp/tmpti7wvsej[0x4017ae]\n/tmp/tmpti7wvsej[0x4015e6]\n\
    /tmp/tmpti7wvsej[0x4013e8]\n/tmp/tmpti7wvsej[0x4013a7]\n/tmp/tmpti7wvsej[0x400dc6]\n\
    /lib64/libc.so.6(__libc_start_main+0xf5)[0x2adcd9a30555]\n/tmp/tmpti7wvsej[0x400a79]\n\
    ======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 638324   \
    \                          /tmp/tmpti7wvsej\n00602000-00603000 r--p 00002000 08:02\
    \ 638324                             /tmp/tmpti7wvsej\n00603000-00604000 rw-p\
    \ 00003000 08:02 638324                             /tmp/tmpti7wvsej\n0120c000-0123e000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2adcd8ef7000-2adcd8f19000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2adcd8f19000-2adcd8f1d000\
    \ rw-p 00000000 00:00 0 \n2adcd8f34000-2adcd8f38000 rw-p 00000000 00:00 0 \n2adcd9118000-2adcd9119000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2adcd9119000-2adcd911a000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2adcd911a000-2adcd911b000\
    \ rw-p 00000000 00:00 0 \n2adcd911b000-2adcd92e4000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2adcd92e4000-2adcd94e3000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2adcd94e3000-2adcd94ee000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2adcd94ee000-2adcd94f1000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2adcd94f1000-2adcd94f4000 rw-p 00000000 00:00 0 \n2adcd94f4000-2adcd95f5000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2adcd95f5000-2adcd97f4000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2adcd97f4000-2adcd97f5000\
    \ r--p 00100000 08:01 50332773                   /usr/lib6"
  stdout: "132033 5 1 2 4 \n"
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    if(arr[0] == 0)\n        return true;\n    for(int\
    \ i = 1; i < n; i++) {\n        if(arr[i] > arr[i - 1])\n            return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuv1gdorr: /tmp/tmpuv1gdorr.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    int cnt = 0;\n    for (int i = 0; i < N; i++) {\n\
    \        cnt += arr[i];\n    }\n    int start = 0, end = N - 1;\n    for (int\
    \ i = 0; i < N; i++) {\n        cnt += arr[end] - arr[start];\n        if (arr[i]\
    \ <= 0 || cnt < 0)\n            return false;\n        if (cnt >= 0)\n       \
    \     arr[end++] = arr[start++];\n        else\n            arr[start++] = arr[end--];\n\
    \        cnt -= arr[end] - arr[start];\n    }\n    arr[start] = 0;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpky6fwenj': free(): invalid next size (fast): 0x00000000024ffc20\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b77060dd329]\n\
    /tmp/tmpky6fwenj[0x4016ba]\n/tmp/tmpky6fwenj[0x4015c6]\n/tmp/tmpky6fwenj[0x4013fe]\n\
    /tmp/tmpky6fwenj[0x401200]\n/tmp/tmpky6fwenj[0x4011bf]\n/tmp/tmpky6fwenj[0x400bdf]\n\
    /lib64/libc.so.6(__libc_start_main+0xf5)[0x2b770607e555]\n/tmp/tmpky6fwenj[0x400859]\n\
    ======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2248809  \
    \                          /tmp/tmpky6fwenj\n00602000-00603000 r--p 00002000 08:02\
    \ 2248809                            /tmp/tmpky6fwenj\n00603000-00604000 rw-p\
    \ 00003000 08:02 2248809                            /tmp/tmpky6fwenj\n024ee000-02520000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b7705545000-2b7705567000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b7705567000-2b770556a000\
    \ rw-p 00000000 00:00 0 \n2b7705582000-2b7705586000 rw-p 00000000 00:00 0 \n2b7705766000-2b7705767000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b7705767000-2b7705768000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b7705768000-2b7705769000\
    \ rw-p 00000000 00:00 0 \n2b7705769000-2b7705932000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b7705932000-2b7705b31000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b7705b31000-2b7705b3c000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b7705b3c000-2b7705b3f000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b7705b3f000-2b7705b42000 rw-p 00000000 00:00 0 \n2b7705b42000-2b7705c43000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b7705c43000-2b7705e42000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b7705e42000-2b7705e43000\
    \ r--p 00100000 08:01 50332773                   /usr/lib6"
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    long long int n = arr.size();\n    if (n <= 0)\
    \ {\n        return true;\n    }\n    \n    long long int last, first;\n    last\
    \ = arr[0];\n    first = arr[n - 1];\n\n    for (long long int i = 1;  i < n;\
    \  i++) {\n        long long int j = arr[i - 1];\n        arr[i] = arr[j];\n \
    \   }\n    arr[0] = first;\n    arr[n - 1] = last;\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_w8p3cx4: /tmp/tmp_w8p3cx4.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    if (N == 0) {\n        return true;\n    }\n    if\
    \ (N == 1) {\n        return arr[0] == 0;\n    }\n    int ans = 0;\n    int max_val\
    \ = arr[0];\n    for (int i = 1; i < N; ++i) {\n        if (max_val < arr[i])\
    \ {\n            max_val = arr[i];\n        }\n    }\n    std::vector<int> dp(max_val\
    \ + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        dp[dp.at(arr[i]) - 1] =\
    \ 1;\n    }\n    for (int i = 1; i < max_val; ++i) {\n        if (dp[i] == 0)\
    \ {\n            ans = 1;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpq42uyljv': double free or corruption (out): 0x0000000000c78c50\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b9e63d00329]\n\
    /tmp/tmpq42uyljv[0x401da4]\n/tmp/tmpq42uyljv[0x401c0e]\n/tmp/tmpq42uyljv[0x401940]\n\
    /tmp/tmpq42uyljv[0x401548]\n/tmp/tmpq42uyljv[0x401247]\n/tmp/tmpq42uyljv[0x400b42]\n\
    /tmp/tmpq42uyljv[0x400c3f]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b9e63ca1555]\n\
    /tmp/tmpq42uyljv[0x4008e9]\n======= Memory map: ========\n00400000-00404000 r-xp\
    \ 00000000 08:02 2248835                            /tmp/tmpq42uyljv\n00603000-00604000\
    \ r--p 00003000 08:02 2248835                            /tmp/tmpq42uyljv\n00604000-00605000\
    \ rw-p 00004000 08:02 2248835                            /tmp/tmpq42uyljv\n00c67000-00c99000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b9e63168000-2b9e6318a000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b9e6318a000-2b9e6318d000\
    \ rw-p 00000000 00:00 0 \n2b9e631a5000-2b9e631a9000 rw-p 00000000 00:00 0 \n2b9e63389000-2b9e6338a000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b9e6338a000-2b9e6338b000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b9e6338b000-2b9e6338c000\
    \ rw-p 00000000 00:00 0 \n2b9e6338c000-2b9e63555000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b9e63555000-2b9e63754000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b9e63754000-2b9e6375f000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b9e6375f000-2b9e63762000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b9e63762000-2b9e63765000 rw-p 00000000 00:00 0 \n2b9e63765000-2b9e63866000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b9e63866000-2b9e63a65000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b9e63a65000-2b9e63a66000\
    \ r--p 00100000 08:01 50332773  "
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    if (N == 0) {\n        return true;\n    }\n    long\
    \ max = 0;\n    long tmp = 0;\n    for (int i = 0; i < N; i++) {\n        tmp\
    \ = arr[i];\n        if (max < tmp) {\n            max = tmp;\n        }\n   \
    \ }\n    int m = 1;\n    while (m < N) {\n        long l = 0;\n        for (int\
    \ j = N - 1; j >= m; j--) {\n            l = arr[j];\n            if (l > max)\
    \ {\n                max = l;\n            }\n        }\n        m++;\n    }\n\
    \    long x = 0;\n    long y = 1;\n    while (y != N) {\n        long z = y;\n\
    \        x = arr[z];\n        y = x;\n        arr[z] = arr[z - y];\n        arr[z\
    \ - y] = x;\n    }\n    bool res = true;\n    for (int i = 0; i < N; i++) {\n\
    \        if (arr[i] != i) {\n            res = false;\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp58qkpnrm: /tmp/tmp58qkpnrm.cpp:63: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 1) {\n        return true;\n    }\n    for (int i = 1; i\
    \ < arr.size(); i++) {\n        // We check if one right shift is possible.\n\
    \        if (arr[i - 1] > arr[i]) {\n            std::vector<long> temp_arr;\n\
    \            temp_arr.push_back(arr[i - 1]);\n            temp_arr.push_back(arr[i]);\n\
    \            std::rotate(temp_arr.begin(), temp_arr.end(), temp_arr.begin() +\
    \ i);\n            // The temp_arr is sorted, so if any two numbers are equal,\
    \ we return false\n            if (std::equal(arr.begin() + 1, arr.end(), temp_arr.begin()))\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpkzeygcgf': munmap_chunk(): invalid pointer: 0x0000000001e4fc70\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x7f474)[0x2af066237474]\n\
    /tmp/tmpkzeygcgf[0x402612]\n/tmp/tmpkzeygcgf[0x401fb3]\n/tmp/tmpkzeygcgf[0x401614]\n\
    /tmp/tmpkzeygcgf[0x401314]\n/tmp/tmpkzeygcgf[0x401365]\n/tmp/tmpkzeygcgf[0x400c4a]\n\
    /tmp/tmpkzeygcgf[0x400eec]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2af0661da555]\n\
    /tmp/tmpkzeygcgf[0x4009e9]\n======= Memory map: ========\n00400000-00405000 r-xp\
    \ 00000000 08:02 2248831                            /tmp/tmpkzeygcgf\n00604000-00605000\
    \ r--p 00004000 08:02 2248831                            /tmp/tmpkzeygcgf\n00605000-00606000\
    \ rw-p 00005000 08:02 2248831                            /tmp/tmpkzeygcgf\n01e3e000-01e70000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2af0656a1000-2af0656c3000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2af0656c3000-2af0656c6000\
    \ rw-p 00000000 00:00 0 \n2af0656de000-2af0656e2000 rw-p 00000000 00:00 0 \n2af0658c2000-2af0658c3000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2af0658c3000-2af0658c4000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2af0658c4000-2af0658c5000\
    \ rw-p 00000000 00:00 0 \n2af0658c5000-2af065a8e000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2af065a8e000-2af065c8d000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2af065c8d000-2af065c98000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2af065c98000-2af065c9b000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2af065c9b000-2af065c9e000 rw-p 00000000 00:00 0 \n2af065c9e000-2af065d9f000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2af065d9f000-2af065f9e000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2af065f9e000-2af065f9f000\
    \ r--p 00100000 08:01 50332773  "
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Do not write main() function.\n    // Do not read input, instead use the\
    \ arguments to the function.\n    // Do not print output, instead return values\
    \ as specified\n    // Still have a doubt. Checkout www.geeksforgeeks.org\n\n\
    \    // Solution 1 without using any extra space and without modifying array\n\
    \    for(long i=0; i<arr.size(); i++) {\n        if(i==0) {\n            if(arr[i]<arr[i-1])\
    \ \n                return false;\n        } else {\n            if(arr[i-1]>arr[i])\
    \ {\n                return false;\n            }\n        }\n    }\n\n    //\
    \ Solution 2 with extra space without modifying array\n    long i=0;\n    long\
    \ prev=arr[0];\n    for(long j=arr.size()-1; j>=0; j--) {\n        if(arr[j]>prev)\
    \ {\n            arr[i]=arr[j];\n            prev=arr[j];\n            i++;\n\
    \        }\n    }\n\n    if(arr[i-1]>prev) {\n        return false;\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6gqkvme_: /tmp/tmp6gqkvme_.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    long temp = arr[0];\n    long ans = 0;\n    for(int\
    \ i = 1; i < n; i++) {\n        ans += temp;\n        temp = arr[i] - ans;\n \
    \   }\n    if (ans == 0) return true;\n    else return false;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpokpy_gvv: /tmp/tmpokpy_gvv.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty()){\n        return true;\n    }\n    long long length = arr.size();\n\
    \    long long temp;\n    for(long long i = 0; i < length-1; i++){\n        if(arr[i]\
    \ > arr[i+1]){\n            temp = arr[i+1];\n            arr[i+1] = arr[i];\n\
    \            arr[i] = temp;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuejxmq45: /tmp/tmpuejxmq45.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    // code here\n    long long n = arr.size();\n\
    \    for (long long i = 0; i < n; i++) {\n        for (long long j = i + 1; j\
    \ < n; j++) {\n            if (arr[i] > arr[j])\n                break;\n    \
    \        swap(arr[j], arr[i]);\n        }\n    }\n    long long s = n - 1;\n \
    \   for (long long i = 1; i < n; i++) {\n        if (arr[i] != arr[s])\n     \
    \       return false;\n        s--;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppbhsucqr.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppbhsucqr.cpp:28:13: error: \u2018swap\u2019 was not declared\
    \ in this scope\n   28 |             swap(arr[j], arr[i]);\n      |          \
    \   ^~~~\n/tmp/tmppbhsucqr.cpp:28:13: note: suggested alternatives:\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppbhsucqr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:143,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmppbhsucqr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/exception_ptr.h:166:5:\
    \ note:   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr&\
    \ __lhs, exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/"
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    int n = arr.size()-1;\n\tlong int max_val = arr[n];\n\tlong int min_val = arr[0];\n\
    \tfor(int i = 0; i < n; i++) {\n\t\tif(arr[i] > max_val)\n\t\t\tmax_val = arr[i];\n\
    \t\tif(arr[i] < min_val)\n\t\t\tmin_val = arr[i];\n\t}\n\tlong int diff = max_val\
    \ - min_val;\n\tfor(int i = n; i > 0; i--){\n\t\tarr[i] = arr[i-1];\n\t}\n\tarr[0]\
    \ = min_val;\n\treturn diff;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpusgrfey8: /tmp/tmpusgrfey8.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.empty()) return true;\n    long long size = arr.size();\n    long long\
    \ max_val = 0;\n    for (long long i = 0; i < size; i++) {\n        max_val =\
    \ max(max_val, arr[i]);\n    }\n    long long temp = 0;\n    long long count =\
    \ 0;\n    for (int i = 0; i < size; i++) {\n        temp = arr[i];\n        arr[size\
    \ - i - 1] = 0;\n        arr[size - i] = temp;\n        if (temp > max_val) count++;\n\
    \    }\n    if (count != 0) return false;\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2w11e4e5.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp2w11e4e5.cpp:25:19: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   25 |         max_val =\
    \ max(max_val, arr[i]);\n      |                   ^~~\n      |              \
    \     std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2w11e4e5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    std::vector<long> sorted_arr;\n\tstd::sort(arr.begin(), arr.end());\n\tstd::reverse(arr.begin(),\
    \ arr.end());\n\tsorted_arr = arr;\n\tfor (auto i : arr) {\n\t\tassert(i != sorted_arr[0]);\n\
    \t\tassert(sorted_arr.size() > 0);\n\t\tbool flag = true;\n\t\tfor (auto j : sorted_arr)\
    \ {\n\t\t\tassert(j > 0);\n\t\t\tassert(j != sorted_arr[0]);\n\t\t\tif (j < i)\
    \ {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\treturn true;\n\
    \t\t}\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpw6eh9k3b: /tmp/tmpw6eh9k3b.cpp:26: bool move_one_ball(std::vector<long
    int>): Assertion `i != sorted_arr[0]'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    long s = 0;\n    for (long i = 0; i < N; i++) {\n\
    \        s += arr[i];\n        if (s > 0) {\n            int temp = s;\n     \
    \       s = 0;\n            arr[i] = temp;\n        }\n    }\n    // Return True\
    \ if no element moves out of array\n    return s == 0;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqpir9vh4: /tmp/tmpqpir9vh4.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N=arr.size();\n    if(N==0) return true;\n    long long arr1=arr[0];\n\
    \    for(auto i=1;i<N;++i) {\n        if(arr[i]<arr1) {\n            arr1=arr[i];\n\
    \        }\n    }\n    long long arr2=arr[N-1];\n    for(auto i=N-1;i>0;--i) {\n\
    \        if(arr[i]<arr2) {\n            arr2=arr[i];\n        }\n    }\n    if(arr1<arr2)\
    \ return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj1anic1g: /tmp/tmpj1anic1g.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    int m = N - 1;\n    int i = 0;\n    int j = 0;\n \
    \   int k = 0;\n\n    while (i < N) {\n        while (j >= 0 && arr[i] < arr[j])\
    \ {\n            swap(arr[i], arr[j]);\n            j--;\n        }\n        if\
    \ (j == -1) {\n            i++;\n        }\n    }\n\n    while (k >= 0 && arr[i]\
    \ < arr[k]) {\n        swap(arr[i], arr[k]);\n        k--;\n    }\n    bool ret\
    \ = false;\n    for (int j = 0; j < N; j++) {\n        if (arr[j] > arr[k]) {\n\
    \            ret = !ret;\n        }\n    }\n    return ret;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu9hefpra.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpu9hefpra.cpp:29:13: error: \u2018swap\u2019 was not declared\
    \ in this scope\n   29 |             swap(arr[i], arr[j]);\n      |          \
    \   ^~~~\n/tmp/tmpu9hefpra.cpp:29:13: note: suggested alternatives:\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu9hefpra.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:143,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu9hefpra.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/exception_ptr.h:166:5:\
    \ note:   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr&\
    \ __lhs, exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/"
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  std::stack<long> s;\n    // We will be storing the elements here\n    long\
    \ ans = 0;\n    for(long &elem : arr){\n        if(s.empty()){\n            s.push(elem);\n\
    \            continue;\n        }\n        if(elem > s.top()){\n            ans\
    \ += 1;\n            s.push(elem);\n        }\n        else{\n            s.pop();\n\
    \            s.push(elem);\n        }\n    }\n    return ans == 1;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpgf80vl0c: /tmp/tmpgf80vl0c.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    long size = arr.size();\n    if (size == 0)\n\
    \        return true;\n    if (size == 1)\n        return false;\n    int mid\
    \ = size / 2;\n    int i = 0;\n    while (i < mid) {\n        long temp = 0;\n\
    \        temp = arr[i++];\n        int j = 0;\n        while (j < size) {\n  \
    \          arr[i - j] = arr[j];\n            j++;\n        }\n        arr[i -\
    \ 1] = temp;\n    }\n    return false;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp81miqg_z: /tmp/tmp81miqg_z.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size()==0)\n        return true;\n    // Create a temporary variable\
    \ 'temp' to store the last number in the given array.\n    long temp;\n    //\
    \ Get the last element from the given array.\n    temp = arr.back();\n    // Move\
    \ last element to the beginning of the given array.\n    arr.push_back(arr.front());\n\
    \    // Move 0th element to the end of the given array.\n    arr.front()=temp;\n\
    \    // Check if there is any move operation which can be performed.\n    for(int\
    \ i=0; i<arr.size()-1;i++){\n        // If the last element is not in the increasing\
    \ order then return false.\n        if(arr[i]>arr[i+1])\n            return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfki71dx5: /tmp/tmpfki71dx5.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822140
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int\
    \ n = arr.size();\n  int start = 0;\n  int end = 0;\n  for (int i = 0; i < n;\
    \ i++) {\n    end = start + 1;\n    if (end >= n) {\n      end = n - 1;\n    }\n\
    \    while (arr[end] > arr[end]) {\n      end--;\n    }\n    start += 1;\n   \
    \ while (start > end) {\n      start--;\n    }\n    if (end > start) {\n     \
    \ return false;\n    }\n    swap(arr[end], arr[start]);\n  }\n  return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjvor_czz.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpjvor_czz.cpp:39:5: error: \u2018swap\u2019 was not declared\
    \ in this scope\n   39 |     swap(arr[end], arr[start]);\n      |     ^~~~\n/tmp/tmpjvor_czz.cpp:39:5:\
    \ note: suggested alternatives:\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjvor_czz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:143,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpjvor_czz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/exception_ptr.h:166:5:\
    \ note:   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr&\
    \ __lhs, exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-sk"
  stdout: ''
  timestamp: 1659822140
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int size = arr.size();\n    long temp = arr[0];\n\
    \    for (int i = 1; i < size; ++i) {\n        arr[i] = arr[i + 1];\n    }\n \
    \   arr[0] = temp;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqr6ym9cr: /tmp/tmpqr6ym9cr.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  //\
    \ Write your code here.\n  int N = arr.size();\n  std::sort(arr.begin(), arr.end());\n\
    \  std::vector<long>::iterator it;\n  int cnt = 0;\n  for (it = arr.begin(); it\
    \ != arr.end(); ++it) {\n    if ((it != arr.begin()) && (*it != arr[it])) {\n\
    \      cnt++;\n    }\n  }\n  if (cnt == N) {\n    return true;\n  } else {\n \
    \   return false;\n  }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmbzje5qm.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpmbzje5qm.cpp:27:43: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::vector<long int>\u2019 and \u2018std::vector<long\
    \ int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >\u2019})\n   27 |     if ((it != arr.begin()) && (*it != arr[it])) {\n\
    \      |                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpmbzje5qm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = long int;\
    \ _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::reference = long\
    \ int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n 1040\
    \ |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:28:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >\u2019\
    } to \u2018std::vector<long int>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n 1040 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |        \
    \          ~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1058:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = long\
    \ int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::const_reference\
    \ = const long int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\
    \n 1058 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |   \
    \   "
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    int n = arr.size();\n    for(auto i : arr)\n    {\n\
    \        \n    }\n    \n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmps7cjcx11: /tmp/tmps7cjcx11.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0) {\n        return true;\n    }\n    for (int i = 0; i\
    \ < arr.size() - 1; i++) {\n        for (int j = arr.size() - 1; j > i; j--) {\n\
    \            if (arr[j] < arr[j - 1]) {\n                long temp = arr[j];\n\
    \                arr[j] = arr[j - 1];\n                arr[j - 1] = temp;\n  \
    \          }\n        }\n    }\n    return arr[arr.size() - 1] > 0;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbwjafz6q: /tmp/tmpbwjafz6q.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int\
    \ size = arr.size();\n  int i = 0;\n  bool found = false;\n\n  for (; i < size\
    \ && !found; i++)\n  {\n    found = std::find(arr.begin(), arr.end(), i + 1) !=\
    \ arr.end();\n  }\n\n  if (found)\n  {\n    return true;\n  }\n\n  if (i == size)\n\
    \  {\n    return true;\n  }\n\n  int j = size - 1;\n\n  while (j > 0 && std::find(arr.begin(),\
    \ arr.end(), j) == arr.end())\n  {\n    j--;\n  }\n\n  if (j == 0)\n  {\n    return\
    \ true;\n  }\n\n  // Right shift by j\n  arr[j] = 0ll;\n  for (int k = j - 1;\
    \ k >= 0; k--)\n  {\n    arr[k + 1] = arr[k];\n  }\n\n  return false;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp5wy130wh: /tmp/tmp5wy130wh.cpp:65: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int m = 0;\n    bool ret = false;\n    for (int i\
    \ = 0; i < n; i++) {\n        if (m == n) {\n            m = 0;\n        }\n \
    \       if (arr[i] > arr[m]) {\n            ret = move_one_ball(arr);\n      \
    \      return ret;\n        }\n        m++;\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpe4ifc6bl: /tmp/tmpe4ifc6bl.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int N=arr.size();\n    for(int i=0;i<N;i++){\n\
    \        int l=arr[i];\n        int r=arr[i-1];\n        arr[i]=r;\n    }\n  \
    \  int l=arr[N-1];\n    int r=arr[0];\n    arr[N-1]=l;\n    arr[0]=r;\n    if(N==0){\n\
    \        return true;\n    }\n    std::vector<long>::iterator it=std::find(arr.begin(),arr.end(),0);\n\
    \    while(it!=arr.end()){\n        int i=(*it);\n        if(std::find(arr.begin(),arr.end(),i)==arr.end()){\n\
    \            arr.push_back(i);\n        }\n        it=std::find(arr.begin(),arr.end(),i);\n\
    \    }\n    if(arr.size()==1){\n        return true;\n    }\n    if(move_one_ball(arr))\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long long n = arr.size();\n    long long count = 1;\n    long long j = 0;\n\
    \    for (j = 0; j < n; j++)\n        count *= arr[j];\n    for (long long i =\
    \ 1; i < count; i++) {\n        long long res = arr[i - 1];\n        arr[i - 1]\
    \ = arr[i];\n        arr[i] = res;\n    }\n    long long m = 1;\n    for (long\
    \ long i = 1; i < n; i++)\n        m *= arr[i];\n    if (m == count)\n       \
    \ return true;\n    else\n        return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_fl10ckm: /tmp/tmp_fl10ckm.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  //\
    \ Your code here\n  if (arr.empty())\n    return true;\n  auto itr = arr.begin();\n\
    \  auto end = arr.end();\n  int i = 0;\n  int j = arr.size() - 1;\n  int count\
    \ = 0;\n  int min_elem = std::numeric_limits<int>::min();\n  while (j < arr.size())\
    \ {\n    if (*itr >= min_elem) {\n      if (*itr >= *j) {\n        j = j - 1;\n\
    \        count = 0;\n      } else {\n        count = count + 1;\n      }\n   \
    \ }\n    i = i + 1;\n  }\n  if (j >= 0) {\n    if (count >= 2) {\n      return\
    \ true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n\
    \  }\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb1t6ybcj.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpb1t6ybcj.cpp:32:20: error: invalid type argument of unary\
    \ \u2018*\u2019 (have \u2018int\u2019)\n   32 |       if (*itr >= *j) {\n    \
    \  |                    ^\n"
  stdout: ''
  timestamp: 1659822142
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \      long size = arr.size();\n        if (size == 1)\n                return\
    \ true;\n        if (size == 2)\n                return false;\n        long mid\
    \ = size >> 1;\n        // If there is only one element in arr then it will not\
    \ be possible\n        // to obtain non-decreasing order\n        if (size ==\
    \ 1)\n                return false;\n        // If there are only two elements\
    \ in arr then there will be no left shift\n        // operations\n        if (size\
    \ == 2)\n                return true;\n        // Perform two right shift operations:\
    \ first move last element to \n        // 0th index and then move first element\
    \ to last index\n        long left_shift = move_one_ball(arr);\n        long right_shift\
    \ = move_one_ball(arr);\n        // Move last element to 0th index\n        arr[mid]\
    \ = arr[mid];\n        // Move first element to last index\n        arr[0] = arr[0];\n\
    \        // If right shift operations are not performed then we can not obtain\
    \ \n        // non-decreasing order from given array so we will get False only\n\
    \        if (left_shift == 1 && right_shift == 0)\n                return false;\n\
    \        // If left shift operations have been performed then we can obtain \n\
    \        // non-decreasing order from given array so we will get True only\n \
    \       if (left_shift != 0 || right_shift != 1)\n                return true;\n\
    \        // If we have reached here that means we have obtained non-decreasing\
    \ order\n        // by performing only one right shift operation\n        return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    // Your code here\n\tint N = arr.size();\n\tint x = arr.size()-1;\n\tlong temp;\n\
    \t\n\tfor (int i = 0; i < N/2; i++) {\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[x];\n\
    \t\tarr[x] = temp;\n\t\tx--;\n\t}\n\t\n\tif (arr.size() == 0) {\n\t\treturn true;\n\
    \t}\n\t\n\treturn false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpatjq56zq: /tmp/tmpatjq56zq.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0) {\n        return true;\n    }\n    long long temp;\n\
    \    long long count = 0;\n    for (int i = 0; i < arr.size() - 1; i++) {\n  \
    \      temp = arr[i];\n        arr[i] = arr[arr.size() - 1];\n        arr[arr.size()\
    \ - 1] = temp;\n        count++;\n    }\n    return count % 2 == 0;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpynbhwem_: /tmp/tmpynbhwem_.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)4, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    int n = arr.size();\n    if(n==0)\n        return true;\n\
    \    long max_val = arr[0];\n    long min_val = arr[0];\n    for(int i=1;i<n;i++){\n\
    \        if(max_val < arr[i])\n            max_val = arr[i];\n        else if(min_val\
    \ > arr[i])\n            min_val = arr[i];\n    }\n    if(max_val - min_val >\
    \ 0)\n        return false;\n    long right_shift_val = (max_val - min_val) >>\
    \ 1;\n    int m = arr.size();\n    int count = 0;\n    for(long i=0;i<m;i++){\n\
    \        if(arr[i] >> right_shift_val == 0)\n            count++;\n        if(count==n){\n\
    \            return true;\n        }\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpl_iwf_h0: /tmp/tmpl_iwf_h0.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    if(N == 0)\n        return true;\n    int l = N -\
    \ 1;\n    long sum = 0;\n    long cur = arr[0];\n    for(int i = 1; i < N; i++)\
    \ {\n        sum = arr[i] - cur;\n        if(sum < 0) {\n            sum *= -1;\n\
    \            sum = sum + l;\n        }\n        cur = arr[i];\n        if(sum\
    \ > 0) {\n            sum *= -1;\n            sum += l;\n        }\n        if(sum\
    \ < l && sum >= 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8a49p72a: /tmp/tmp8a49p72a.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // your code here\n    if(arr.size() == 0 || arr.size() <= 1){\n        return\
    \ true;\n    }\n    long sum = 0;\n    long n = arr.size();\n    long temp = 0;\n\
    \    long j = n;\n    for(long i = 0; i < n; i++){\n        sum = arr[i] + sum;\n\
    \        if(j != 0){\n            temp = sum;\n            sum -= arr[i - 1];\n\
    \            arr[i] = temp;\n            j = i - 1;\n        }\n    }\n    for(long\
    \ i = 0; i < n; i++){\n        arr[i]++;\n    }\n    for(long i = 0; i < n; i++){\n\
    \        sum += arr[i];\n    }\n    return sum == 0;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpp_5m8zu8: /tmp/tmpp_5m8zu8.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  std::vector<long>\
    \ reversed;\n  long index = 0;\n  long last_index = arr.size() - 1;\n  long temp\
    \ = 0;\n  bool flag = false;\n  while (index < last_index) {\n    temp = arr[index];\n\
    \    reversed.push_back(temp);\n    arr[index] = arr[index + 1];\n    arr[index\
    \ + 1] = temp;\n    index++;\n  }\n  for (int i = 0; i < arr.size(); i++) {\n\
    \    if (arr[i] >= reversed[arr.size() - 1]) {\n      return true;\n    }\n  }\n\
    \  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqyl53d3l: /tmp/tmpqyl53d3l.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int\
    \ n = arr.size();\n  int count = 0;\n  for (int i = n - 1; i >= 0; i--) {\n  \
    \  if (arr[i] < arr[i + 1]) {\n      count++;\n      int temp = arr[i];\n    \
    \  arr[i] = arr[i + 1];\n      arr[i + 1] = temp;\n    }\n  }\n  return count\
    \ == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpp4iozair: /tmp/tmpp4iozair.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // write your code here\n    if(arr.size() == 1){\n        return true;\n \
    \   }\n    std::vector<long> temp(arr.begin(), arr.begin() + 1);\n    for(long\
    \ i = 1; i < arr.size(); i++){\n        if(arr[i] > arr[i-1]){\n            temp[i]\
    \ = temp[i-1];\n        }\n    }\n    arr.clear(); \n    for(long i = 0; i < temp.size();\
    \ i++){\n        arr.push_back(temp[i]);\n    }\n    return arr.size() == 1;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpxrzutnuq': free(): invalid next size (fast): 0x0000000001ca5c50\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b0569a8e329]\n\
    /tmp/tmpxrzutnuq[0x402162]\n/tmp/tmpxrzutnuq[0x401f60]\n/tmp/tmpxrzutnuq[0x401b24]\n\
    /tmp/tmpxrzutnuq[0x4014ae]\n/tmp/tmpxrzutnuq[0x401323]\n/tmp/tmpxrzutnuq[0x400ba9]\n\
    /tmp/tmpxrzutnuq[0x400e4c]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b0569a2f555]\n\
    /tmp/tmpxrzutnuq[0x400959]\n======= Memory map: ========\n00400000-00404000 r-xp\
    \ 00000000 08:02 2248817                            /tmp/tmpxrzutnuq\n00604000-00605000\
    \ r--p 00004000 08:02 2248817                            /tmp/tmpxrzutnuq\n00605000-00606000\
    \ rw-p 00005000 08:02 2248817                            /tmp/tmpxrzutnuq\n01c94000-01cc6000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b0568ef6000-2b0568f18000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b0568f18000-2b0568f1b000\
    \ rw-p 00000000 00:00 0 \n2b0568f33000-2b0568f37000 rw-p 00000000 00:00 0 \n2b0569117000-2b0569118000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b0569118000-2b0569119000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b0569119000-2b056911a000\
    \ rw-p 00000000 00:00 0 \n2b056911a000-2b05692e3000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b05692e3000-2b05694e2000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b05694e2000-2b05694ed000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b05694ed000-2b05694f0000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b05694f0000-2b05694f3000 rw-p 00000000 00:00 0 \n2b05694f3000-2b05695f4000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b05695f4000-2b05697f3000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b05697f3000-2b05697f4000\
    \ r--p 00100000 08:01 50332773 "
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  long\
    \ long int n = arr.size();\n  long long int a[n];\n  a[0] = arr[0];\n  long long\
    \ int mid;\n  for(int i = 1; i < n; i++) {\n    mid = arr[i] + (a[i-1]<<1);\n\
    \    a[i] = mid;\n  }\n  mid = a[n - 1];\n  long long int left = 0;\n  long long\
    \ int right = n -1;\n  while(left < right) {\n    long long int mid1 = arr[left]\
    \ + (a[mid]<<1);\n    long long int mid2 = arr[right] + (a[mid]<<1);\n    if(mid2\
    \ < mid1)\n      mid = (mid+left)/2;\n    else {\n      mid = (mid+right)/2;\n\
    \      right = mid - 1;\n    }\n    \n    left++;\n    right--;\n  }\n  \n  if(arr[left]\
    \ == mid)\n    return true;\n  else\n    return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprqe9h9ao: /tmp/tmprqe9h9ao.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size() == 0) {\n        return true;\n    }\n    int pos = 0;\n    long\
    \ ans = arr[0];\n    while(pos < arr.size()) {\n        ans >>= 1;\n        pos\
    \ += (ans == 0);\n        arr[pos] = arr[pos - 1];\n    }\n    arr[arr.size()-1]\
    \ = 0;\n    return arr[arr.size()-1] < 0;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpm95_51a3: /tmp/tmpm95_51a3.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822142
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here.\n    // The approach is to maintain a variable 'pos'\
    \ which keeps track of the\n    // current position of the array in non-decreasing\
    \ order.\n    // If the current position of the array is equal to the length of\
    \ the array,\n    // the array is non-decreasing otherwise it is decreasing.\n\
    \    long long pos = 0;\n    long long len = arr.size();\n    if (len == 0)\n\
    \        return true;\n    if (len == 1)\n        return false;\n    while (pos\
    \ < len) {\n        if (arr[pos] <= 0)\n            return false;\n        arr[pos]--;\n\
    \        if (arr[pos] >= len)\n            arr[pos] = len - 1;\n        pos++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp88sel17m: /tmp/tmp88sel17m.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822143
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long long ans = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i)\
    \ {\n        ans += arr[i];\n        std::cout << ans << ' ';\n        if(ans\
    \ > 0) {\n            ans >>= 1;\n            std::cout << ans << ' ';\n     \
    \       ans >>= 1;\n            std::cout << ans << ' ';\n            ans >>=\
    \ 1;\n            std::cout << ans << ' ';\n            ans >>= 1;\n         \
    \   std::cout << ans << ' ';\n            ans >>= 1;\n            std::cout <<\
    \ ans << ' ';\n            ans >>= 1;\n            std::cout << ans << ' ';\n\
    \            ans >>= 1;\n            std::cout << ans << ' ';\n            ans\
    \ >>= 1;\n            std::cout << ans << ' ';\n            ans >>= 1;\n     \
    \       std::cout << ans << ' ';\n            ans >>= 1;\n            std::cout\
    \ << ans << ' ';\n            ans >>= 1;\n            std::cout << ans << ' ';\n\
    \            ans >>= 1;\n            std::cout << ans << ' ';\n            ans\
    \ >>= 1;\n            std::cout << ans << ' ';\n            ans >>= 1;\n     \
    \       std::cout << ans << ' ';\n            ans >>= 1;\n            std::cout\
    \ << ans << ' ';\n            ans >>= 1;\n            std::cout << ans << ' ';\n\
    \            ans >>= 1;\n            std::cout << ans << ' ';\n            ans\
    \ >>= 1;\n            std::cout << ans << ' ';\n            ans >>= 1;\n     \
    \       std::cout << ans << ' ';\n            ans >>= 1;\n            std::cout\
    \ << ans << ' ';\n            ans >>= 1;\n            std::cout << ans << ' ';\n\
    \            ans >>= 1;\n            std::cout << ans << ' ';\n            ans\
    \ >>= 1;\n            std::cout << ans << ' ';\n            ans >>= 1;\n     \
    \       std::cout << ans << ' ';\n            ans >>= 1;\n            std::cout\
    \ << ans << ' ';\n            ans >>= 1;\n            std::cout << ans << ' ';\n\
    \            ans >>= 1;\n            std::cout << ans << ' ';\n            ans\
    \ >>= 1;\n            std::cout << ans << ' ';\n            ans >>= 1;\n     \
    \       std::cout << ans << ' ';\n            ans >>= 1;\n            std::cout\
    \ << \n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp40_yi492.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp40_yi492.cpp:87:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmp40_yi492.cpp:88:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   88 | int main() {\n      |            ^\n/tmp/tmp40_yi492.cpp:95:1: error:\
    \ expected \u2018}\u2019 at end of input\n   95 | }\n      | ^\n/tmp/tmp40_yi492.cpp:23:32:\
    \ note: to match this \u2018{\u2019\n   23 |     for(int i = 0; i < n; ++i) {\n\
    \      |                                ^\n/tmp/tmp40_yi492.cpp:95:1: error: expected\
    \ \u2018}\u2019 at end of input\n   95 | }\n      | ^\n/tmp/tmp40_yi492.cpp:20:43:\
    \ note: to match this \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long>\
    \ arr) {\n      |                                           ^\n/tmp/tmp40_yi492.cpp:95:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   95 | }\n      | ^\n"
  stdout: ''
  timestamp: 1659822143
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty())\n        return true;\n    \n    // Sort the given array into\
    \ non-decreasing order\n    long long n = arr.size();\n    std::sort(arr.begin(),\
    \ arr.end());\n    // Store the sorted array in another array\n    std::vector<long>\
    \ sorted_arr(n);\n    for(int i = 0; i < n; i++)\n        sorted_arr[i] = arr[i];\n\
    \    // If the given array is non-decreasing then \n    // all elements can be\
    \ shifted once\n    if(!std::is_sorted(arr.begin(), arr.end()))\n        return\
    \ false;\n    // Perform the right shift operation once\n    for(int i = 1; i\
    \ < n; i++)\n        arr[i] >>= 1;\n    // If the given array is non-decreasing\
    \ then \n    // the sorted array will be equal to the given array\n    return\
    \ std::equal(arr.begin(), arr.end(), sorted_arr.begin());\n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2k_qz88d: /tmp/tmp2k_qz88d.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    // write your code here\n    long long int arrSize =\
    \ arr.size();\n    long long int temp = 0;\n    long long int i = 0;\n    long\
    \ long int j = 0;\n    long long int k = 0;\n    if(arrSize == 0){\n        return\
    \ true;\n    }\n    if(arrSize == 1){\n        if(arr[0] == arr[1]){\n       \
    \     return true;\n        }\n        return false;\n    }\n    for(long long\
    \ int l = 1; l < arrSize; l++){\n        if(arr[l] < arr[1]){\n            return\
    \ false;\n        }\n    }\n    for(long long int l = 1; l < arrSize; l++){\n\
    \        for(long long int m = 1; m < arrSize; m++){\n            if(arr[m] >\
    \ arr[m - 1] && arr[l] < arr[m - 1]){\n                temp = arr[m];\n      \
    \          arr[m] = arr[l];\n                arr[l] = temp;\n            }\n \
    \       }\n    }\n    for(i = 0; i < arrSize; i++){\n        if(arr[i] > arr[i\
    \ - 1]){\n            return false;\n        }\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0yy398rn: /tmp/tmp0yy398rn.cpp:60: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int count = 1;\n    for (int i = 0; i < n; i++) {\n\
    \        if (arr[i] == 1) {\n            count++;\n        }\n    }\n    for (int\
    \ i = 0; i < n - 1; i++) {\n        // The last element of the array will be moved\
    \ to the starting position\n        // of the array i.e. 0th index.\n        if\
    \ (arr[i] != 1) {\n            arr[i - 1] = 1;\n            arr[n - 1] = 0;\n\
    \            n = n - 1;\n            i = i - 1;\n        }\n    }\n    if (count\
    \ == n) {\n        return true;\n    } else {\n        return false;\n    }\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxgjafje5: /tmp/tmpxgjafje5.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int N=arr.size();\n    long sum=0;\n    for(int\
    \ i=0;i<N;i++){\n        sum+=arr[i];\n    }\n    if (sum>=0 && sum<N)\n     \
    \   return true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppm59tdaj: /tmp/tmppm59tdaj.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if\
    \ (arr.size() == 0) return true;\n  // We are performing a right shift operation\n\
    \  // We are doing one right shift operation and if that is the last element\n\
    \  // then we return True. \n  long tmp = arr[0];\n  arr[0] = arr[N-1];\n  arr[N-1]\
    \ = tmp;\n\n  // We are doing one more right shift operation and if that is the\
    \ last element\n  // then we return True.\n  for (size_t i=1; i<N-1; ++i) {\n\
    \    long tmp = arr[i];\n    arr[i] = arr[i-1];\n    arr[i-1] = tmp;\n  }\n\n\
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3wrduptl.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp3wrduptl.cpp:26:16: error: \u2018N\u2019 was not declared\
    \ in this scope\n   26 |   arr[0] = arr[N-1];\n      |                ^\n"
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  //\
    \ Your code here\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] > arr[i-1])\
    \ {\n      return true;\n    }\n  }\n  return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp93grvkmb: /tmp/tmp93grvkmb.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    // if array is empty return true\n    if (n == 0)\n\
    \        return true;\n    long lastElem = arr[n - 1];\n    // if array contains\
    \ only one element\n    if (n <= 1)\n        return false;\n    long start = arr[n\
    \ - 2];\n    long end = arr[n - 1];\n    long mid = start + (end - start) / 2;\n\
    \    if (mid > lastElem)\n        return false;\n    if (mid < lastElem)\n   \
    \     return true;\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n\
    \        // perform right shift \n        if (arr[i] >> 1 == 1) {\n          \
    \  if (found)\n                return false;\n            if (move_one_ball(arr))\
    \ {\n                found = true;\n                start++;\n               \
    \ end = start;\n            }\n        }\n        // perform left shift \n   \
    \     if (arr[i] << 1 == 1) {\n            if (found)\n                return\
    \ false;\n            if (move_one_ball(arr)) {\n                found = true;\n\
    \                end = start;\n                start--;\n            }\n     \
    \   }\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpeg0u6wvq: /tmp/tmpeg0u6wvq.cpp:65: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int\
    \ n = arr.size(); // length of the given array\n  int l = 0; // left most element\
    \ index\n  int r = n - 1; // right most element index\n  bool flag = false; //\
    \ true if the answer is found\n  long t;\n  \n  // While the left most element\
    \ is not the left most element of the sorted array\n  while( l != r)\n  {\n  \
    \  t = arr[l];\n    arr[l] = arr[r];\n    arr[r] = t;\n    l++;\n    r--;\n  }\n\
    \  \n  // If left most and right most elements are equal, then the array is sorted\n\
    \  if( l == r )\n  {\n    return true;\n  }\n  \n  if( l < r )\n  {\n    // If\
    \ the number of right shift operations is bigger than the number of elements\n\
    \    // in the given array, the answer is found\n    long temp;\n    temp = arr[r];\n\
    \    long i;\n    for( i = l; i < r; i++ )\n    {\n      arr[i] = arr[i-1];\n\
    \    }\n    arr[r] = temp;\n    flag = true;\n  }\n  \n  return flag;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    \n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnf43z664: /tmp/tmpnf43z664.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // If no elements in arr then return True\n    if (arr.empty()) return true;\n\
    \    // One right shift operation means shifting all elements of the array by\
    \ one\n    // position in the right direction. The last element of the array will\
    \ be moved to\n    // the starting position in the array i.e. 0th index.\n   \
    \ long x = arr[0];\n    for (size_t i = 1; i < arr.size(); i++) {\n        arr[i]\
    \ = arr[i - 1];\n    }\n    arr[0] = x;\n    // If it is possible to obtain the\
    \ sorted array by performing the above operation\n    // then return True else\
    \ return False\n    for (auto i : arr) assert(i < x);\n    return arr.empty();\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8rv2s52_: /tmp/tmp8rv2s52_.cpp:33: bool move_one_ball(std::vector<long
    int>): Assertion `i < x'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    // return true;\n    bool flag = true;\n    long temp;\n\
    \    int len = arr.size();\n    for(int i=0; i<len; i++){\n        temp = arr[i];\
    \ //store arr[i] to temp\n        for(int j=i+1; j<len; j++){\n            if(temp\
    \ < arr[j]){\n                flag = false;\n                arr[j] = temp; //arr[j]\
    \ element will be moved to arr[i]\n            }\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqua6769m: /tmp/tmpqua6769m.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822144
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int result = 0;\n    if(arr.empty()) return true;\n\
    \    long prev = arr[0];\n    long current = arr[n - 1];\n    while(current >\
    \ prev){\n        current = arr[n - 1];\n        result ^= prev;\n        prev\
    \ = current;\n        result ^= prev;\n        prev = current;\n        result\
    \ ^= prev;\n        prev = current;\n        result ^= prev;\n        prev = current;\n\
    \        result ^= prev;\n        prev = current;\n        result ^= prev;\n \
    \       prev = current;\n        result ^= prev;\n        prev = current;\n  \
    \      result ^= prev;\n        prev = current;\n        result ^= prev;\n   \
    \     prev = current;\n        result ^= prev;\n        prev = current;\n    \
    \    result ^= prev;\n        prev = current;\n        result ^= prev;\n     \
    \   prev = current;\n        result ^= prev;\n        prev = current;\n      \
    \  result ^= prev;\n        prev = current;\n        result ^= prev;\n       \
    \ prev = current;\n        result ^= prev;\n        prev = current;\n        result\
    \ ^= prev;\n        prev = current;\n        result ^= prev;\n        prev = current;\n\
    \        result ^= prev;\n        prev = current;\n        result ^= prev;\n \
    \       prev = current;\n        result ^= prev;\n        prev = current;\n  \
    \      result ^= prev;\n        prev = current;\n        result ^= prev;\n   \
    \     prev = current;\n        result ^= prev;\n        prev = current;\n    \
    \    result ^= prev;\n        prev = current;\n        result ^= prev;\n     \
    \   prev = current;\n        result ^= prev;\n        prev = current;\n      \
    \  result ^= prev;\n        prev = current;\n        result ^= prev;\n       \
    \ prev = current;\n        result ^= prev;\n        prev = current;\n        result\
    \ ^= prev;\n        prev = current;\n        result ^= prev;\n        prev = current;\n\
    \        result ^= prev;\n        prev = current;\n        result ^= prev;\n \
    \       prev = current;\n        result ^= prev;\n        prev = current;\n  \
    \      result ^= prev;\n        prev = current;\n        result ^= prev;\n   \
    \     prev = current;\n        result ^= prev;\n        prev = current;\n    \
    \    result ^= prev;\n        prev = current;\n        \n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz0y08ikx.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpz0y08ikx.cpp:108:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n  108 | int main() {\n      |     \
    \       ^\n/tmp/tmpz0y08ikx.cpp:115:1: error: expected \u2018}\u2019 at end of\
    \ input\n  115 | }\n      | ^\n/tmp/tmpz0y08ikx.cpp:20:43: note: to match this\
    \ \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long> arr) {\n      |\
    \                                           ^\n/tmp/tmpz0y08ikx.cpp:115:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n  115 | }\n      |\
    \ ^\n"
  stdout: ''
  timestamp: 1659822144
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long size = arr.size();\n    if (size == 0)\n        return true;\n    long\
    \ sum = 0;\n    for (long i = 0; i < size; ++i) {\n        sum += arr[i];\n  \
    \  }\n    long last_num = arr[size - 1];\n    long last_index = size - 2;\n  \
    \  long last_sum = (last_num * last_index) + last_index - sum;\n    if (last_sum\
    \ < sum)\n        return false;\n    for (long i = size - 1; i > 0; --i) {\n \
    \       long sum = 0;\n        for (long j = 0; j < i; ++j)\n            sum +=\
    \ arr[j];\n        long num = arr[i];\n        long index = i - 1;\n        long\
    \ shift_sum = sum + last_sum - last_sum * num / last_index;\n        if (shift_sum\
    \ > sum) {\n            arr[i] = sum - shift_sum;\n            arr[index] = last_num;\n\
    \        } else {\n            arr[i] = sum + last_sum - shift_sum;\n        \
    \    arr[index] = last_num;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmphc79nzk5: /tmp/tmphc79nzk5.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int N = arr.size();\n    int count = 0;\n    for\
    \ (int i = 0; i < N; i++) {\n        int j = i + 1;\n        while (j < N && arr[j\
    \ - 1] >= arr[j]) {\n            std::swap(arr[j], arr[j - 1]);\n            j++;\n\
    \        }\n    }\n    for (int i = 0; i < N; i++) {\n        if (arr[i] > arr[i\
    \ + 1]) {\n            std::swap(arr[i], arr[i + 1]);\n        }\n    }\n    int\
    \ index = -1;\n    for (int i = 0; i < N; i++) {\n        if (arr[i] == arr[i\
    \ + 1]) {\n            index = i;\n            break;\n        }\n    }\n    if\
    \ (index >= 0) {\n        if (index == 0) {\n            return true;\n      \
    \  } else {\n            std::swap(arr[0], arr[index]);\n        }\n    }\n  \
    \  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7p8itvr9: /tmp/tmp7p8itvr9.cpp:54: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 1) {\n        return true;\n    }\n\n    // left side of\
    \ array is arr[0], right side is arr[1]\n    long temp = arr[0];\n    long left\
    \ = arr[1];\n    long mid = 0;\n    // left side of array is arr[0], right side\
    \ is arr[1]\n    long right = arr[1];\n\n    for (int i = 1; i < arr.size(); i++)\
    \ {\n        mid = (left + right) / 2;\n        if (mid > temp) {\n          \
    \  right = mid;\n        } else {\n            left = mid;\n        }\n    }\n\
    \    arr[1] = left;\n    arr[0] = right;\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxh3vumeq: /tmp/tmpxh3vumeq.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long n=arr.size();\n    if(n==1)return false;\n    if(arr[0]==n)return true;\n\
    \    arr[0]-=n;\n    arr[n-1]-=n;\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvqtwod8p: /tmp/tmpvqtwod8p.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long arr_size = arr.size();\n    if (arr_size == 0)\n        return true;\n\
    \    // We have used two variables 'shift' and 'index' to hold the current and\
    \ next\n    // values of 'arr'.\n    long shift = 0;\n    long index = 0;\n  \
    \  long next_index = arr_size - 1;\n    long next_value = arr[0];\n    // We have\
    \ used an array to keep track of the positions we have left off.\n    long used_positions[arr_size\
    \ + 1];\n    used_positions[0] = 0;\n    while (true) {\n        // If 'index'\
    \ has reached 'arr_size' then we can move the last element from\n        // 'arr'\
    \ to 'arr[0]'.\n        if (index == arr_size)\n            arr[0] = next_value;\n\
    \        // If we have used all the positions in the array then no elements are\
    \ left\n        // off.\n        if (used_positions[next_index] == arr_size)\n\
    \            return false;\n        // Shift the element of 'arr' to 'next_index'.\n\
    \        arr[next_index] = arr[shift];\n        // Move the 'index' element from\
    \ 'arr' to 'next_index' position.\n        arr[next_index + 1] = arr[index];\n\
    \        // Move the 'next_index' element from 'arr' to 'index' position.\n  \
    \      arr[index] = arr[next_index];\n        // Update the values for 'index'\
    \ and 'next_index'.\n        index = next_index;\n        next_index = next_index\
    \ + 1;\n        shift = shift + 1;\n    }\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8yii3097: /tmp/tmp8yii3097.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.empty()) return true;\n    long temp = arr[0];\n    long i = 0;\n \
    \   for (auto elem : arr){\n        arr[i++] = elem; \n    }\n    arr[i] = temp;\n\
    \    return is_non_decreasing_order(arr);\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl5tqda4g.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpl5tqda4g.cpp:28:12: error: \u2018is_non_decreasing_order\u2019\
    \ was not declared in this scope\n   28 |     return is_non_decreasing_order(arr);\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    assert(arr.size() > 0);\n    long arr_size = arr.size();\n\
    \    long count = 0;\n    long prev = 0;\n    long next_val = 0;\n    std::vector<long>\
    \ new_arr;\n    new_arr.push_back(0);\n    for (int i = 0; i < arr_size; i++)\
    \ {\n        count++;\n        next_val = prev;\n        prev = arr[i];\n    \
    \    if (count == 2) {\n            new_arr.push_back(next_val);\n        }\n\
    \    }\n    bool ret = true;\n    for (auto val : arr) {\n        if (val > new_arr[0])\
    \ {\n            ret = ret & false;\n        }\n    }\n    return ret;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkyx3reaa: /tmp/tmpkyx3reaa.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    if(arr.empty()) return true;\n    if(arr.size()\
    \ == 1) return false;\n    std::vector<long> temp_arr(arr.size());\n    long temp;\n\
    \    for(int i=0;i<arr.size();i++){\n        temp = arr[i];\n        temp_arr[i]\
    \ = arr[i];\n        arr[i] = arr[i-1];\n        arr[i-1] = temp;\n    }\n   \
    \ return arr==temp_arr;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqy5dfxb: /tmp/tmpoqy5dfxb.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822145
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int count = 0;\n    long start = 0;\n    long end\
    \ = 0;\n\n    for(auto i : arr){\n        std::cout << i;\n    }\n\n    long temp\
    \ = arr[0];\n    int flag = 1;\n    int temp_index = 0;\n    std::vector<long>\
    \ temp1;\n\n    while(temp != 0){\n        count += 1;\n        if(count == n){\n\
    \            break;\n        }\n        if(temp == 0){\n            break;\n \
    \       }\n        if(arr[temp_index] != 0){\n            temp1.push_back(arr[temp_index]);\n\
    \            temp_index++;\n        }\n        temp >>= 1;\n    }\n\n    if(temp_index\
    \ > 0){\n        temp1.push_back(arr[temp_index]);\n        temp_index++;\n  \
    \  }\n\n    temp = temp1[0];\n\n    start = n;\n\n    while(temp != 0){\n    \
    \    count += 1;\n        if(count == n){\n            break;\n        }\n   \
    \     if(temp == 0){\n            break;\n        }\n        if(arr[temp_index]\
    \ != 0){\n            temp1.push_back(arr[temp_index]);\n            temp_index++;\n\
    \        }\n        temp >>= 1;\n    }\n\n    if(temp_index > 0){\n        temp1.push_back(arr[temp_index]);\n\
    \        temp_index++;\n    }\n\n    end = n;\n\n    while(temp1 != 0){\n    \
    \    count += 1;\n        if(count == n){\n            break;\n        }\n   \
    \     if(temp1 == 0){\n            break;\n        }\n        arr[n++] = arr[n--];\n\
    \        temp1.pop_back();\n    }\n\n    if(n == 0){\n        return true;\n \
    \   }\n\n    count = 0;\n    long temp2 = 0;\n    int flag2 = 1;\n    int temp_index2\
    \ = 0;\n    std::vector<long> temp2;\n\n    while(temp2 != 0){\n        count\
    \ += 1;\n        if(count == n){\n            break;\n        }\n        if(temp2\
    \ == 0){\n            break;\n        }\n        if(arr[n] != 0){\n          \
    \  temp2.push_back(arr[n]);\n            temp_index2++;\n        }\n        temp2\
    \ >>= 1;\n    }\n\n    if(temp_index2 > 0){\n        temp2.push_back(arr[n]);\n\
    \        temp_index2++;\n    }\n\n    temp = temp2[0];\n\n    start = n;\n\n \
    \   while(temp != 0){\n        count += 1;\n        if(count == n){\n        \
    \    break;\n        }\n        if(temp == 0){\n            break;\n        }\n\
    \        if(arr[temp_index2] != 0){\n            temp2.push_back(arr[temp_index2]);\n\
    \            temp_index2++;\n        }\n        temp >>= 1;\n    }\n\n    if(temp_index2\
    \ > 0){\n        temp2.push_back(arr[temp_index2]);\n        temp_index2++;\n\
    \    }\n\n    end = n;\n\n    while(temp2 != 0){\n        count \n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmporqrgevb.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmporqrgevb.cpp:81:17: error: no match for \u2018operator!=\u2019\
    \ (operand types are \u2018std::vector<long int>\u2019 and \u2018int\u2019)\n\
    \   81 |     while(temp1 != 0){\n      |           ~~~~~ ^~ ~\n      |       \
    \    |        |\n      |           |        int\n      |           std::vector<long\
    \ int>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporqrgevb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporqrgevb.cpp:81:20:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   81 |     while(temp1 != 0){\n      |                    ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporqrgevb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1112 |     operator!=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1112:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporqrgevb.cpp:81:20: "
  stdout: ''
  timestamp: 1659822145
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code goes here\n    if(arr.empty()){\n        return true;\n    }\n\
    \    std::vector<long> temp(arr.size());\n    int size = arr.size();\n    long\
    \ temp_size = arr[0];\n    for(int i=0;i<size;i++){\n        temp[i] = arr[i];\n\
    \    }\n    long temp_size = arr[0];\n    int temp = size-1;\n    for(int i=0;i<size;i++){\n\
    \        if(arr[i]>temp){\n            arr[i]-=temp_size;\n            temp_size-=temp[arr[i]];\n\
    \            temp[arr[i]]-=temp_size;\n        }\n    }\n    for(int i=0;i<size;i++){\n\
    \        arr[i] = temp[i];\n    }\n    return arr[0]==0;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp32wsny2d.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp32wsny2d.cpp:31:10: error: redeclaration of \u2018long\
    \ int temp_size\u2019\n   31 |     long temp_size = arr[0];\n      |         \
    \ ^~~~~~~~~\n/tmp/tmp32wsny2d.cpp:27:10: note: \u2018long int temp_size\u2019\
    \ previously declared here\n   27 |     long temp_size = arr[0];\n      |    \
    \      ^~~~~~~~~\n/tmp/tmp32wsny2d.cpp:32:9: error: conflicting declaration \u2018\
    int temp\u2019\n   32 |     int temp = size-1;\n      |         ^~~~\n/tmp/tmp32wsny2d.cpp:25:23:\
    \ note: previous declaration as \u2018std::vector<long int> temp\u2019\n   25\
    \ |     std::vector<long> temp(arr.size());\n      |                       ^~~~\n\
    /tmp/tmp32wsny2d.cpp:34:18: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019} and \u2018std::vector<long int>\u2019)\n   34 | \
    \        if(arr[i]>temp){\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp32wsny2d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp32wsny2d.cpp:34:19:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019}\n   34 |         if(arr[i]>temp){\n      |      \
    \             ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \  "
  stdout: ''
  timestamp: 1659822146
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int\
    \ size = arr.size();\n  if (size == 0)\n    return true;\n\n  long temp = arr[0];\n\
    \  std::rotate(arr.begin(), arr.begin()+1, arr.end()-1);\n  std::rotate(arr.end(),\
    \ arr.begin(), arr.begin()+1);\n  if (arr.front() == temp)\n    return false;\n\
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpdhninuyi': free(): invalid next size (fast): 0x000000000117fc20\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b1083e98329]\n\
    /tmp/tmpdhninuyi[0x401f3a]\n/tmp/tmpdhninuyi[0x401d1a]\n/tmp/tmpdhninuyi[0x401900]\n\
    /tmp/tmpdhninuyi[0x40126c]\n/tmp/tmpdhninuyi[0x40122b]\n/tmp/tmpdhninuyi[0x400b14]\n\
    /lib64/libc.so.6(__libc_start_main+0xf5)[0x2b1083e39555]\n/tmp/tmpdhninuyi[0x400859]\n\
    ======= Memory map: ========\n00400000-00404000 r-xp 00000000 08:02 2248903  \
    \                          /tmp/tmpdhninuyi\n00603000-00604000 r--p 00003000 08:02\
    \ 2248903                            /tmp/tmpdhninuyi\n00604000-00605000 rw-p\
    \ 00004000 08:02 2248903                            /tmp/tmpdhninuyi\n0116e000-011a0000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b1083300000-2b1083322000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b1083322000-2b1083325000\
    \ rw-p 00000000 00:00 0 \n2b108333d000-2b1083341000 rw-p 00000000 00:00 0 \n2b1083521000-2b1083522000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b1083522000-2b1083523000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b1083523000-2b1083524000\
    \ rw-p 00000000 00:00 0 \n2b1083524000-2b10836ed000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b10836ed000-2b10838ec000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b10838ec000-2b10838f7000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b10838f7000-2b10838fa000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b10838fa000-2b10838fd000 rw-p 00000000 00:00 0 \n2b10838fd000-2b10839fe000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b10839fe000-2b1083bfd000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b1083bfd000-2b1083bfe000\
    \ r--p 00100000 08:01 50332773                   /usr/lib6"
  stdout: ''
  timestamp: 1659822146
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    long sum = 0;\n    long last_element = arr[0];\n\
    \    for(long i = 1; i < arr.size(); i++) {\n        sum -= arr[i];\n        sum\
    \ += arr[i];\n        arr[i] = sum;\n    }\n    long last_index = arr.size() -\
    \ 1;\n    sum = last_element - arr[last_index];\n    arr[0] = sum;\n    return\
    \ arr[0] == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp35mqnm8o: /tmp/tmp35mqnm8o.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822146
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  std::stack<long>\
    \ s;\n  long a = arr[0];\n  for (int i = 1; i < arr.size(); i++) {\n    long b\
    \ = arr[i];\n    while (a < b) {\n      s.push(a);\n      a = s.top();\n     \
    \ s.pop();\n    }\n    s.push(b);\n    b = s.top();\n    s.pop();\n  }\n  if (s.empty())\
    \ return true;\n  else {\n    return false;\n  }\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code goes here.\n    int n = arr.size();\n    long temp;\n    for(int\
    \ i=0;i<n;i++) {\n        temp = arr[i];\n        for(int j=i;j>=0 && temp < arr[j];j--)\
    \ {\n            arr[j] = arr[j-1];\n        }\n        arr[i] = temp;\n    }\n\
    \    return arr.size() <= 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyy01oe8m: /tmp/tmpyy01oe8m.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822146
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  std::stack<long> st;\n    for(long i = 1; i < arr.size(); i++) {\n        st.push(arr[i]);\n\
    \    }\n    long temp;\n    while (!st.empty()) {\n        temp = st.top();\n\
    \        st.pop();\n        if(arr[0] <= temp) {\n            std::swap(arr[0],\
    \ temp);\n        }\n        else {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpegr_2x7d: /tmp/tmpegr_2x7d.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  assert(arr.size()\
    \ > 0);\n  if (arr.size() == 1) {\n    return true;\n  }\n  int index = 0;\n \
    \ for (size_t i = 0; i < arr.size(); i++) {\n    index = (index - arr[i]) / 2;\n\
    \    if (index == 0) {\n      return true;\n    }\n  }\n  return false;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpt875wye8: /tmp/tmpt875wye8.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    if(n <= 0)\n        return true;\n    int i = 0;\n\
    \    while(i < n - 1) {\n        std::swap(arr[i], arr[i + 1]);\n        i++;\n\
    \    }\n    std::swap(arr[0], arr[i]);\n    return true;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpk4pi0k1d: /tmp/tmpk4pi0k1d.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  //\
    \ Write your code here\n  long i = 0;\n  long n = arr.size();\n  long sum = 0;\n\
    \  long long res = 0;\n  long long diff = 0;\n  bool flag = false;\n  \n  while(i\
    \ != n) {\n    sum = sum + arr[i];\n    res = sum - arr[i-1];\n    diff = res\
    \ < 0 ? -1 : 1;\n    flag = (arr[i-1] > res);\n    \n    i += (sum < diff) ? 1\
    \ : 0;\n    \n  }\n\n  return flag;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822152
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your logic here\n    long a = 0;\n    for (int i = 1; i <= arr.size();\
    \ i++) {\n        a += arr[i];\n        if (a < 0) {\n            a += 1;\n  \
    \      }\n        a -= 1;\n    }\n    return arr.size() == 0;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpfc4j2t9b: /tmp/tmpfc4j2t9b.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // write your code in here\n    int n = arr.size()-1;\n    int i;\n    for(i=0;i<n;i++){\n\
    \        long temp = arr[i];\n        arr[i] = arr[i+1];\n        arr[i+1] = temp;\n\
    \    }\n    if(n==0){\n        return true;\n    }\n    else{\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmezl35cs: /tmp/tmpmezl35cs.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    long n = arr.size();\n    long m = n-1;\n    for(long\
    \ i=1; i<=n; i++) {\n        if(arr[i]<arr[m]) {\n            long j = i;\n  \
    \          long temp = arr[i];\n            while(j>0) {\n                arr[j]\
    \ = arr[j-1];\n                j = j-1;\n            }\n            arr[j] = temp;\n\
    \        }\n    }\n    for(long i=0;i<n;i++) {\n        for(long j=i+1;j<n;j++)\
    \ {\n            if(arr[i]<arr[j]) {\n                long temp = arr[i];\n  \
    \              arr[i] = arr[j];\n                arr[j] = temp;\n            }\n\
    \        }\n    }\n    return (n==0);\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjdvr2_kl: /tmp/tmpjdvr2_kl.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  std::stack<long> s;\n    long val = arr[0];\n    s.push(val);\n    while(s.size()\
    \ != 0){\n        val = s.pop();\n        if(val > 1){\n            s.emplace(val-1);\n\
    \        }\n        else{\n            s.push(val);\n        }\n    }\n    return\
    \ s.size() == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph5984ydu.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmph5984ydu.cpp:25:20: error: void value not ignored as it\
    \ ought to be\n   25 |         val = s.pop();\n      |               ~~~~~^~\n"
  stdout: ''
  timestamp: 1659822147
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long temp = arr[0];\n    long pos = 1;\n    std::vector<long>::iterator it;\n\
    \    for (it = arr.begin() + 1; it < arr.end(); it++) {\n        if (arr[pos]\
    \ > arr[it - 1]) {\n            temp = arr[pos];\n            arr[pos] = arr[it\
    \ - 1];\n            arr[it - 1] = temp;\n        }\n        pos++;\n    }\n \
    \   if (arr.size() != 1)\n        return false;\n    if (arr[arr.size() - 1] >\
    \ arr[arr.size() - 2])\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpts04ajob.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpts04ajob.cpp:25:27: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::vector<long int>\u2019 and \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019)\n   25 |         if (arr[pos] > arr[it\
    \ - 1]) {\n      |                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpts04ajob.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = long int;\
    \ _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::reference = long\
    \ int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n 1040\
    \ |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:28:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019 to \u2018std::vector<long int>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 1040 |       operator[](size_type __n)\
    \ _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1058:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = long\
    \ int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::const_reference\
    \ = const long int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\
    \n 1058 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |   \
    \    ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1058:28:\
    \ note:   no known con"
  stdout: ''
  timestamp: 1659822147
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  std::stack<long>\
    \ stack;\n  long max = arr.back();\n  for (int i = 1; i < arr.size(); i++) {\n\
    \    if (arr[i] < max) {\n      stack.push(arr[i]);\n    } else {\n      max =\
    \ stack.top();\n      stack.pop();\n    }\n  }\n  long temp = arr.back();\n  arr.push_back(arr.size()\
    \ - 1);\n  arr.front() = temp;\n  return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int sum = 0;\n    // We use 'n' as the number of elements\
    \ to perform 'right' shift on the\n    // array 'arr'.\n    for(int i = 0; i <\
    \ n; i++) {\n        // We perform 'right' shift on the array 'arr' and calculate\
    \ the sum\n        // of the elements in the array 'arr'.\n        sum += arr[i];\n\
    \    }\n    // If 'sum' exceeds n then obviously it is not possible to get non-decreasing\
    \ order.\n    // So, we return 'false'.\n    if (sum > n) {\n        return false;\n\
    \    }\n\n    // If 'sum' is less than or equal to n then it is possible to get\
    \ non-decreasing\n    // order.\n    // So, we return 'true'.\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprevd_wp6: /tmp/tmprevd_wp6.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long long s = 0;\n    // Find the first right shift operation that is possible\
    \ for the given\n    // array.\n    for (const auto& i : arr) {\n        if (i\
    \ & 1) {\n            ++s;\n            if (s == arr.size() - 1) {\n         \
    \       return false;\n            }\n        }\n    }\n    // Perform right shift\
    \ operations until the first right shift operation is\n    // achieved.\n    bool\
    \ ret = false;\n    for (size_t i = 1; i < s; ++i) {\n        std::swap(arr[i],\
    \ arr[i + s]);\n        ret |= arr[i] <= arr[i - s];\n    }\n    return ret;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptscoo8rw: /tmp/tmptscoo8rw.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822147
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0)\n        return true;\n    // If the length of the array\
    \ is 1, then it is possible to obtain the sorted\n    // array by performing 1\
    \ right shift operation.\n    if (arr.size() == 1) {\n        long tmp = arr[0];\n\
    \        arr[0] = 0;\n        arr[0] = tmp;\n        return true;\n    }\n   \
    \ // Find the minimum element of the given array. \n    long smallest_element\
    \ = *std::min_element(arr.begin(), arr.end());\n    long smallest_element_idx\
    \ = std::distance(arr.begin(), std::min_element(arr.begin(), arr.end()));\n  \
    \  // Now find the first element of the array which is larger than the smallest\n\
    \    // element. \n    long first_element = *std::min_element(arr.begin() + smallest_element_idx\
    \ + 1, arr.end());\n    // Now find the last element of the array which is larger\
    \ than the smallest\n    // element. \n    long last_element = *std::max_element(arr.begin()\
    \ + smallest_element_idx + 1, arr.end());\n\n    // Now we perform N right shift\
    \ operations on the array starting from 0 and\n    // ending at N - 1. \n    std::vector<long>\
    \ new_arr;\n    for (int i = 0; i < arr.size(); ++i) {\n        // Move first\
    \ element to the last position. \n        if (i == smallest_element_idx) {\n \
    \           new_arr.push_back(arr[smallest_element_idx]);\n            continue;\n\
    \        }\n        long tmp = arr[i];\n        arr[i] = arr[i - smallest_element_idx\
    \ - 1];\n        arr[i - smallest_element_idx - 1] = tmp;\n    }\n    new_arr.push_back(arr[arr.size()\
    \ - 1]);\n    \n    bool retval = move_one_ball(new_arr);\n    return retval;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822152
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if\
    \ (arr.empty()) return true;\n  long long n = (arr.size()); // number of elements\
    \ in the array 'arr' \n  if (n <= 1) return true;\n  std::vector<long long> dp(n,\
    \ 0);\n  dp[0] = 1;\n  for (int i = 1; i < n; i++) {\n    dp[i] = dp[i - 1];\n\
    \  }\n  for (int i = n - 1; i >= 0; i--) {\n    dp[i + n - 1] = dp[i + n - 2]\
    \ + arr[i];\n  }\n  if (dp[n] != dp[0]) {\n    return false;\n  }\n  return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmp3n6xqx2t': free(): invalid next size (fast): 0x0000000001006c50\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2addff2e0329]\n\
    /tmp/tmp3n6xqx2t[0x401d5e]\n/tmp/tmp3n6xqx2t[0x401bc8]\n/tmp/tmp3n6xqx2t[0x40191e]\n\
    /tmp/tmp3n6xqx2t[0x40154a]\n/tmp/tmp3n6xqx2t[0x4011c3]\n/tmp/tmp3n6xqx2t[0x400ab4]\n\
    /tmp/tmp3n6xqx2t[0x400b99]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2addff281555]\n\
    /tmp/tmp3n6xqx2t[0x400859]\n======= Memory map: ========\n00400000-00404000 r-xp\
    \ 00000000 08:02 2248908                            /tmp/tmp3n6xqx2t\n00603000-00604000\
    \ r--p 00003000 08:02 2248908                            /tmp/tmp3n6xqx2t\n00604000-00605000\
    \ rw-p 00004000 08:02 2248908                            /tmp/tmp3n6xqx2t\n00ff5000-01027000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2addfe748000-2addfe76a000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2addfe76a000-2addfe76d000\
    \ rw-p 00000000 00:00 0 \n2addfe785000-2addfe789000 rw-p 00000000 00:00 0 \n2addfe969000-2addfe96a000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2addfe96a000-2addfe96b000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2addfe96b000-2addfe96c000\
    \ rw-p 00000000 00:00 0 \n2addfe96c000-2addfeb35000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2addfeb35000-2addfed34000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2addfed34000-2addfed3f000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2addfed3f000-2addfed42000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2addfed42000-2addfed45000 rw-p 00000000 00:00 0 \n2addfed45000-2addfee46000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2addfee46000-2addff045000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2addff045000-2addff046000\
    \ r--p 00100000 08:01 50332773 "
  stdout: ''
  timestamp: 1659822147
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n - 1; i++)\
    \ {\n        for (int j = i + 1; j < n; j++) {\n            count += arr[i] >\
    \ arr[j] ? 1 : 0;\n            if (count == n) return true;\n            arr[i]\
    \ >>= 1;\n            arr[j] >>= 1;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpi9_09ihl: /tmp/tmpi9_09ihl.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    // If array is empty then return True\n    if (N ==\
    \ 0) return true;\n    // For all positions except the first position perform\
    \ right shift operations\n    // and add one to the number\n    for (int i = 1;\
    \ i < N; i++) {\n        // For a right shift operation to take place we decrease\
    \ the value at\n        // the current position in the array by one\n        arr[i]\
    \ = arr[i] - 1;\n    }\n    // The value at arr[0] remains the same. We need to\
    \ move the value at arr[0]\n    // to the starting position in the array\n   \
    \ arr[0] = arr[0];\n    // After the above operation, if the array is non-decreasing\n\
    \    // then return True\n    if (arr[0] < 0) return false;\n    // If it is the\
    \ case that arr[0] is non-decreasing then return False\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpts3dxhbh: /tmp/tmpts3dxhbh.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822148
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty())\n        return true;\n    int size = arr.size();\n    long\
    \ min = arr[0];\n    long max = arr[0];\n    int count = 0;\n    while(arr.size()\
    \ > 1){\n        min = std::min(min, arr[count]);\n        max = std::max(max,\
    \ arr[count]);\n        count++;\n    }\n    return min == max;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659822148
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    long last_element = arr[n-1];\n    // Store the value\
    \ of last element\n    for (int i = n-2; i>=0; i--) {\n        // Perform a right\
    \ shift operation on every element\n        arr[i] = (arr[i+1] >> 1);\n    }\n\
    \    arr[0] = last_element >> 1;\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_uv0qd5z: /tmp/tmp_uv0qd5z.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.empty()) return true;\n    long temp=0;\n    for (long i=arr.size()-1;\
    \ i>=0; --i) {\n        temp=arr[i];\n        long j=i-1;\n        while (j>=0\
    \ && (arr[j]>temp))\n            arr[j+1]=arr[j];\n        arr[j+1]=temp;\n  \
    \  }\n    if (arr.size()==1) return false;\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int n = arr.size();\n    if (n==0) {\n       \
    \ return true;\n    }\n    std::vector<long> arr1 = arr;\n    std::vector<long>\
    \ arr2 = arr;\n    long l=arr1.at(n-1);\n    for(int i=n-1;i>=0;i--){\n      \
    \  arr1[i] = arr1[i-1];\n    }\n    for(int i=0;i<n-1;i++){\n        arr2[i] =\
    \ arr2[i+1];\n    }\n    arr2.at(arr2.size()-1) = l;\n    for(int i=0;i<arr2.size();i++){\n\
    \        arr1[i] = arr2[i];\n    }\n    arr1.at(arr1.size()-1) = 0;\n    if(arr1==arr){\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpodmm1evb: /tmp/tmpodmm1evb.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N = arr.size();\n    int i = 0, j = N - 1;\n    while (i < N && j > i)\
    \ {\n        // If ith value is greater than jth value then swap them\n      \
    \  if (arr[i] > arr[j]) {\n            std::swap(arr[i], arr[j]);\n        }\n\
    \        // If ith value is less than jth value then increment the jth value\n\
    \        else if (arr[i] < arr[j]) {\n            j--;\n        }\n        //\
    \ If ith value is equal to jth value then increment the ith value\n        else\
    \ {\n            i++;\n        }\n    }\n    if (i != N) {\n        std::cout\
    \ << \"false\" << std::endl;\n    }\n    else {\n        std::cout << \"true\"\
    \ << std::endl;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6lvqk12m: /tmp/tmp6lvqk12m.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: 'false

    false

    false

    '
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    \n    if (n <= 1) return true;\n    \n    int mid\
    \ = n / 2;\n    \n    for (int i = 0; i < mid; i++) {\n        if (arr[i] < arr[i\
    \ + 1]) return false;\n    }\n    \n    for (int i = (mid + 1); i < n; i++) {\n\
    \        if (arr[i] > arr[i + 1]) return false;\n    }\n    \n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpy63st1vz: /tmp/tmpy63st1vz.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    return arr.size() > 0 && arr[0] != 0;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpl0zco_qi: /tmp/tmpl0zco_qi.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long temp = 0;\n    long n = 0;\n    for (int i = 1; i < arr.size(); i++) {\n\
    \        temp = arr[i];\n        arr[i] = arr[n];\n        arr[n] = temp;\n  \
    \      n++;\n    }\n    return (n == 1);\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp41zgm0bt: /tmp/tmp41zgm0bt.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    if(n < 2) return true;\n    std::vector<long> temp;\n\
    \    std::vector<int> counts;\n    for(int i = 0; i < n; ++i) {\n        long\
    \ curr = arr[i];\n        counts.push_back(1);\n        while(counts[i - 1] <\
    \ n) {\n            counts[i] += counts[i - 1];\n            counts[i - 1] = 1;\n\
    \        }\n        counts[i - 1]++;\n        while(counts[i - 1] > 0) {\n   \
    \         counts[i] += counts[i - 1];\n            counts[i - 1]--;\n        }\n\
    \        temp.push_back(curr);\n    }\n    return move_one_ball(temp);\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int sz = arr.size();\n    assert(sz>0);\n    std::vector<long> res(sz);\n \
    \   std::vector<int> tmp(sz);\n    assert(sz <= INT_MAX);\n    for(long i=0;i<sz;i++){\n\
    \        for(int j=0;j<sz;j++){\n            tmp[j]= arr[j];\n        }\n    \
    \    res[i] = tmp[i]; \n    }\n    return res[0] > res[sz-1];\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp72zd8k6t: /tmp/tmp72zd8k6t.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        result |= 1 << i;\n    }\n    return result != 0;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpeyrnp76e: /tmp/tmpeyrnp76e.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int n = arr.size();\n    int result = 0;\n   \
    \ for (int i = 0; i < n; i++) {\n        result = result + (arr[i] - 1);\n   \
    \     result >>= 1;\n    }\n    if (result == 0)\n        return true;\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp8ql65uww: /tmp/tmp8ql65uww.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int n = arr.size();\n    if(arr[0] == 1){\n  \
    \      return true;\n    }\n    for(int i=1;i<n;i++){\n        if(arr[i]>arr[i-1]){\n\
    \            return false;\n        }\n    }\n    if(arr[n-1] == 1){\n       \
    \ return true;\n    }\n    for(int i=n-1;i>=0;i--){\n        if(arr[i]>arr[i+1]){\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpcr2k49fx: /tmp/tmpcr2k49fx.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  long\
    \ left = 0;\n  long right = arr.size() - 1;\n  long mid = left + (right - left)\
    \ / 2;\n  while (left < right) {\n    if (arr[mid] == 1) {\n      // If right\
    \ half is empty\n      if (right == mid) {\n        return true;\n      } else\
    \ if (left == mid) {\n        // If left half is empty\n        if (arr[left]\
    \ == 1) {\n          return true;\n        }\n      }\n      if (arr[right] ==\
    \ 1) {\n        if (arr[left] == 1) {\n          if (arr[right] == 1) {\n    \
    \        return true;\n          }\n        } else {\n          return false;\n\
    \        }\n      } else {\n        return false;\n      }\n    }\n    if (arr[mid]\
    \ == 0) {\n      return false;\n    }\n    if (arr[left] == 0) {\n      return\
    \ false;\n    }\n    if (arr[right] == 0) {\n      return false;\n    }\n    if\
    \ (arr[right] == 1) {\n      right--;\n    } else {\n      mid--;\n    }\n   \
    \ left++;\n    mid++;\n  }\n  return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptxszc0vu: /tmp/tmptxszc0vu.cpp:68: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822149
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Time Complexity: O(n)\n    int n = arr.size();\n    int count = 1;\n   \
    \ for (int i = 0; i < n; i++) {\n        // We are allowed to perform shift operation\
    \ any number of times to \n        // achieve non-decreasing order\n        arr\
    \ = rotate_right(arr, count);\n        count++;\n    }\n    return arr[0] == 0;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp42o7vg6h.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp42o7vg6h.cpp:27:15: error: \u2018rotate_right\u2019 was\
    \ not declared in this scope\n   27 |         arr = rotate_right(arr, count);\n\
    \      |               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659822149
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0) {\n        return true;\n    }\n    int start = 0, end\
    \ = arr.size() - 1;\n    while (start < end) {\n        long temp = arr[end];\n\
    \        arr[end] = arr[start];\n        arr[start] = temp;\n        start +=\
    \ 1;\n        end -= 1;\n    }\n    for (int i = 0; i < arr.size(); i++) {\n \
    \       long temp = arr[i];\n        arr[i] = 0;\n        arr[0] = temp;\n   \
    \ }\n    long end = arr.size();\n    if (arr.back() > 0) {\n        return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb5y7p5ad.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpb5y7p5ad.cpp:37:10: error: conflicting declaration \u2018\
    long int end\u2019\n   37 |     long end = arr.size();\n      |          ^~~\n\
    /tmp/tmpb5y7p5ad.cpp:24:20: note: previous declaration as \u2018int end\u2019\n\
    \   24 |     int start = 0, end = arr.size() - 1;\n      |                   \
    \ ^~~\n"
  stdout: ''
  timestamp: 1659822149
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    long arr_size = arr.size();\n\tif (arr_size == 0)\n\t\treturn true;\n\tlong max_val\
    \ = arr[0];\n\tint i = 0;\n\tfor (int j = 0; j < arr_size; j++) {\n\t\tif (arr[j]\
    \ >= max_val) {\n\t\t\tmax_val = arr[j];\n\t\t}\n\t}\n\tint last_index = arr_size\
    \ - 1;\n\tfor (int j = 1; j < arr_size; j++) {\n\t\tif (arr[j] > max_val) {\n\t\
    \t\tmax_val = arr[j];\n\t\t\ti = j;\n\t\t}\n\t}\n\tif (arr[i] > max_val)\n\t\t\
    return false;\n\tfor (int k = i; k < arr_size; k++) {\n\t\tint temp_index = 0;\n\
    \t\twhile (temp_index < arr_size - 1 && arr[k] > max_val) {\n\t\t\tarr[k + temp_index]\
    \ = arr[k];\n\t\t\ttemp_index++;\n\t\t}\n\t\tif (temp_index == arr_size - 1)\n\
    \t\t\tbreak;\n\t\tarr[k + temp_index] = arr[k];\n\t}\n\tarr[i] = arr[0];\n\treturn\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplqak6ndl: /tmp/tmplqak6ndl.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822150
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    int n = arr.size();\n    long long arr1[10] = {arr[0],\
    \ arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[0]};\n \
    \   for(int i = 1; i < n; i++) {\n        long long temp1 = arr[i];\n        for(int\
    \ j = i - 1; j >= 0; j--) {\n            long long temp = arr[j];\n          \
    \  arr[j] = temp1;\n            temp1 = temp;\n        }\n    }\n    long long\
    \ temp2 = arr[0];\n    long long temp3 = arr[n-1];\n    for(int i = 0; i < n -\
    \ 2; i++) {\n        if(arr[i] < temp3)\n            break;\n    }\n    arr[0]\
    \ = arr[n-1];\n    arr[n-1] = temp3;\n    for(int i = 0; i < n; i++) {\n     \
    \   if(arr[i] > temp2)\n            break;\n    }\n    arr[n] = arr[i];\n    arr[i]\
    \ = temp2;\n    long long ans = 0;\n    for(int i = 0; i < n; i++) {\n       \
    \ if(arr[i] != i) {\n            ans++;\n        }\n    }\n    return ans == 0;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvccj5cow.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpvccj5cow.cpp:44:18: error: \u2018i\u2019 was not declared\
    \ in this scope\n   44 |     arr[n] = arr[i];\n      |                  ^\n"
  stdout: ''
  timestamp: 1659822150
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty()) return true;\n    \n    long ans = arr[0];\n    long temp;\n\
    \    for(long i = arr.size()-1; i>0; i--) {\n        temp = ans;\n        ans\
    \ = temp;\n        for(long j = 1; j <= i; j++) {\n            ans <<= 1;\n  \
    \          ans |= arr[j];\n        }\n    }\n    return ans == temp;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp216y7nto: /tmp/tmp216y7nto.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822150
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        long temp =\
    \ arr[i];\n        for (int j = i; j < n; ++j) {\n            arr[j] = arr[j-1];\n\
    \        }\n        arr[0] = temp;\n    }\n    // if there are no more elements\
    \ in the array then return true\n    if (n == 0)\n        return true;\n    //\
    \ else return false\n    return false;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7p46oxln: /tmp/tmp7p46oxln.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822150
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  long\
    \ n = arr.size();\n  // We are assuming that the array is non-decreasing as mentioned\
    \ in the explanation.\n  // We will check this assumption at the end.\n  for (int\
    \ i = 1; i < n; ++i) {\n    long m = arr[i-1];\n    // The smallest element is\
    \ arr[0]. Since the first element is at position 0,\n    // it is safe to compare\
    \ arr[i] with arr[0]\n    if (arr[i] < arr[0]) {\n      return false;\n    }\n\
    \    arr[i] = m;\n  }\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppklug1s6: /tmp/tmppklug1s6.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822150
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty()) return true;\n    // If the list is empty, it means the array\
    \ is sorted.\n    if(arr.size() == 1) return true;\n    // There are only 2 cases\
    \ that can happen\n    // arr[i] > arr[i+1]\n    // arr[i] < arr[i+1]\n    //\
    \ arr[i] == arr[i+1]\n\n    long long N = arr.size()-1;\n    // The loop will\
    \ shift all elements till arr[N]\n    // If there is no move possible, then move\
    \ the one element left\n    for(long long i = 0; i <= N; i++) {\n        if(arr[i]\
    \ > arr[i+1]) {\n            for(long long j = N; j >= i; j--) {\n           \
    \     arr[j] = arr[j-1];\n            }\n            arr[i] = arr[i+1];\n    \
    \        arr[i+1] = arr[i];\n            N--;\n        }\n    }\n\n    if(arr.empty()\
    \ || arr.size() == 1) return true;\n    for(int i = 0; i < arr.size(); i++) {\n\
    \        if(arr[i] > arr[i+1]) {\n            for(long long j = N; j >= i; j--)\
    \ {\n                arr[j] = arr[j-1];\n            }\n            arr[i] = arr[i+1];\n\
    \            arr[i+1] = arr[i];\n            N--;\n        }\n    }\n    return\
    \ arr.empty() || arr.size() == 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzxqgfofv: /tmp/tmpzxqgfofv.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if\
    \ (arr.empty()) {\n    return true;\n  }\n  long long ans = 0;\n  for (long long\
    \ i = 0; i < arr.size(); i++) {\n    ans = arr[i] >> 1;\n    arr[i] = arr[i] <<\
    \ 1;\n  }\n  return ans == 0;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9hnzo7z7: /tmp/tmp9hnzo7z7.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if( arr.size() == 1 )\n        return true;\n    int m = arr.size() - 1;\n\
    \    int cnt = 0;\n    while( cnt < m ) {\n        if( arr[m] > arr[m+1] ) {\n\
    \            std::swap( arr[m], arr[m+1] );\n            cnt++;\n        }\n \
    \       m--;\n    }\n    if( cnt == m ) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpddg2hk3c: /tmp/tmpddg2hk3c.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)5, (long)4, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.empty()) return true;\n    long n = arr.size();\n    long count = 0;\n\
    \    long max_i = -1;\n    long max_j = n - 1;\n    int ans = 0;\n    while(max_i\
    \ > max_j) {\n        long temp_i = arr[max_i];\n        long temp_j = arr[max_j];\n\
    \        if (temp_j < temp_i) {\n            int temp = temp_i;\n            temp_i\
    \ = temp_j;\n            temp_j = temp;\n        }\n        long temp = temp_i;\n\
    \        temp_i = temp_j;\n        temp_j = temp;\n        long temp_k = temp_j\
    \ + 1;\n        temp_j %= temp_k;\n        long temp_l = temp_i + 1;\n       \
    \ temp_i %= temp_l;\n        long temp_r = temp_j + 1;\n        temp_j += 1;\n\
    \        max_i = temp_i;\n        max_j = temp_j;\n        while(temp_i > temp_k)\
    \ {\n            long temp_i = temp_i;\n            temp_j += temp_i;\n      \
    \      temp_i %= temp_j;\n            max_i = temp_i;\n            max_j = temp_j;\n\
    \        }\n        while(temp_j > temp_r) {\n            long temp_j = temp_j;\n\
    \            temp_i += temp_j;\n            temp_j %= temp_i;\n            max_j\
    \ = temp_j;\n        }\n        std::swap(arr[max_i], arr[max_j]);\n        ans++;\n\
    \    }\n    return ans % 2 == 1;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzcdidcih: /tmp/tmpzcdidcih.cpp:66: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int size = arr.size();\n    long left_shift_value;\n    long right_shift_value;\n\
    \n    if(size == 0)\n        return true;\n\n    // if arr[0] is greater than\
    \ arr[1], then move arr[0] to arr[1]\n    if(arr[0] > arr[1]) {\n        std::swap(arr[0],\
    \ arr[1]);\n    }\n\n    // Find the difference between the maximum and minimum\
    \ elements of the array.\n    long max_val = arr[0] - arr[1];\n    long min_val\
    \ = arr[0] - arr[1];\n\n    for(long i = 2; i < size; i++) {\n        left_shift_value\
    \ = arr[i] << 1;\n        right_shift_value = arr[i] >> 1;\n\n        // If arr[i]\
    \ > arr[i-1], then swap arr[i] and arr[i-1].\n        if(arr[i] > arr[i-1]) {\n\
    \            std::swap(arr[i], arr[i-1]);\n        }\n\n        // If arr[i] <\
    \ arr[i-1], then swap arr[i] and arr[i-1].\n        if(arr[i] < arr[i-1]) {\n\
    \            std::swap(arr[i], arr[i-1]);\n        }\n\n        // If arr[i] <\
    \ arr[i-1] and arr[i] > arr[i-1], then move arr[i] to\n        // arr[i-1].\n\
    \        if(arr[i] < arr[i-1] && arr[i] > arr[i-1]) {\n            std::swap(arr[i],\
    \ arr[i-1]);\n        }\n        \n        // If the difference between the maximum\
    \ and minimum elements of the array is \n        // greater than 1, then move\
    \ arr[i] to arr[i-1].\n        if(max_val < arr[i]) {\n            std::swap(arr[i],\
    \ arr[i-1]);\n        }\n\n        // If arr[i] < min_val, then swap arr[i] and\
    \ min_val.\n        if(arr[i] < min_val) {\n            std::swap(arr[i], min_val);\n\
    \        }\n\n        // If arr[i] > max_val, then swap arr[i] and max_val.\n\
    \        if(arr[i] > max_val) {\n            std::swap(arr[i], max_val);\n   \
    \     }\n\n        // If arr[i] > max_val and arr[i] < min_val, then move arr[i]\
    \ to arr[i-1].\n        if(arr[i] > max_val && arr[i] < min_val) {\n         \
    \   std::swap(arr[i], arr[i-1]);\n        }\n\n        // If the difference between\
    \ the maximum and minimum elements of the array is \n        // greater than 1,\
    \ then move arr[i] to arr[i-1].\n        if(min_val > arr[i]) {\n            std::swap(arr[i],\
    \ arr[i-1]);\n        }\n\n        // If arr[i] < max_val, then swap arr[i] and\
    \ max_val.\n        if(arr[i] < max_val) {\n            std::swap(arr[i], max_val);\n\
    \        }\n\n        // If arr[i] > min_val, then swap arr[i] and min_val.\n\
    \        if(arr[i] > min_val) {\n            std::swap(arr[i], min_val);\n   \
    \     }\n\n        // If \n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfnqwcn7v.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpfnqwcn7v.cpp:96:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n   96 | int main() {\n      |     \
    \       ^\n/tmp/tmpfnqwcn7v.cpp:103:1: error: expected \u2018}\u2019 at end of\
    \ input\n  103 | }\n      | ^\n/tmp/tmpfnqwcn7v.cpp:20:43: note: to match this\
    \ \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long> arr) {\n      |\
    \                                           ^\n/tmp/tmpfnqwcn7v.cpp:103:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n  103 | }\n      |\
    \ ^\n"
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if(arr.empty())\
    \ {\n    return true;\n  }\n  bool flag = true;\n  long temp = arr[0];\n  for(int\
    \ i = 1; i < arr.size(); i++) {\n    long temp = arr[i];\n    long prev = arr[i-1];\n\
    \    if((temp - prev) >= 0) {\n      flag = false;\n      break;\n    }\n  }\n\
    \  if(arr.size() > 0) {\n    flag = true;\n  }\n  return flag;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp53mviu3d: /tmp/tmp53mviu3d.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    int n = arr.size();\n    if (n==0)\n        return\
    \ true;\n    int ans = 0;\n    for (int i=0; i<n; i++) {\n        // ans = 2*ans\n\
    \        // if ans greater than arr[i]\n        if (ans<arr[i])\n            return\
    \ false;\n        int left = i*2+1;\n        int right = i*2+2;\n        int mid\
    \ = (i+1)*2+1;\n        if (arr[mid]>=arr[right])\n            mid++;\n      \
    \  if (arr[mid]>=arr[left])\n            mid++;\n        if (arr[mid]>arr[left])\n\
    \            mid++;\n        if (arr[mid]<arr[right])\n            mid++;\n  \
    \      \n        ans = 2*ans+arr[mid];\n    }\n    \n    return ans == arr[0];\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp9bu2s4n0: /tmp/tmp9bu2s4n0.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    // A helper function which checks if the array can\
    \ be sorted in non-decreasing order.\n    // Returns true if it is possible else\
    \ returns false.\n    bool check(int n, int arr[], int i) {\n        if (i ==\
    \ n) {\n            return true;\n        }\n        if (arr[i] < arr[i + 1])\
    \ {\n            return check(n - 1, arr, i + 1);\n        }\n        return false;\n\
    \    }\n    // Check whether the array can be sorted in non-decreasing order with\
    \ 2 right shift operations.\n    return check(n - 1, arr, 0);\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprwgpy5e1.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmprwgpy5e1.cpp:24:41: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n   24 |     bool check(int n, int arr[],\
    \ int i) {\n      |                                         ^\n/tmp/tmprwgpy5e1.cpp:34:12:\
    \ error: \u2018check\u2019 was not declared in this scope\n   34 |     return\
    \ check(n - 1, arr, 0);\n      |            ^~~~~\n"
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int m = n-1;\n    int i = 0;\n    while(i<m && arr[i]\
    \ > arr[i+1]){\n        i++;\n    }\n    if (i==m){\n        return true;\n  \
    \  }\n    else{\n        int count = 0;\n        int temp = n;\n        while(i<m\
    \ && count<temp){\n            int t = arr[i];\n            arr[i] = arr[i+1];\n\
    \            arr[i+1] = t;\n            count++;\n            i++;\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpuyz1_3k6: /tmp/tmpuyz1_3k6.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    // If the number of elements is 0 then it is possible\
    \ to get non-decreasing order \n    // by performing a right shift operation 0times\n\
    \    if (n == 0)\n        return true;\n    // If the array contains only one\
    \ element then it is possible to get non-decreasing order \n    // by performing\
    \ a right shift operation 0times\n    if (n == 1)\n        return true;\n    //\
    \ If the given array has duplicate elements then it is not possible to get non-decreasing\
    \ order \n    // by performing any number of right shift operations.\n    for\
    \ (int i = 0; i < n - 1; i++) {\n        // Perform 1 right shift operation\n\
    \        long temp = 0;\n        temp = arr[i];\n        arr[i] = arr[i + 1];\n\
    \        arr[i + 1] = temp;\n    }\n    // If the array contains only one element\
    \ then it is possible to get non-decreasing order \n    // by performing a right\
    \ shift operation 0times\n    if (n == 1)\n        return true;\n    // If the\
    \ number of elements is greater than 1 then it is not possible to get non-decreasing\
    \ order \n    // by performing any number of right shift operations.\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpo531qpec: /tmp/tmpo531qpec.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822151
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // If the size of the given array is zero, then return True.\n    if (arr.size()\
    \ == 0) {\n        return true;\n    }\n\n    // If the size of the given array\
    \ is one, then return True.\n    if (arr.size() == 1) {\n        return true;\n\
    \    }\n\n    // If the size of the given array is greater than or equal to 2,\
    \ then return True.\n    if (arr.size() >= 2) {\n        // If the 1st element\
    \ of the array is greater than or equal to the 1st element of the \n        //\
    \ array, then return True.\n        if (arr[0] >= arr[1]) {\n            return\
    \ true;\n        }\n\n        // If the 1st element of the array is greater than\
    \ or equal to the 2nd element of the \n        // array, then return True.\n \
    \       else if (arr[0] >= arr[2]) {\n            return true;\n        }\n\n\
    \        // If the 1st element of the array is greater than or equal to the 3rd\
    \ element of the \n        // array, then return True.\n        else if (arr[0]\
    \ >= arr[3]) {\n            return true;\n        }\n\n        // If the 1st element\
    \ of the array is greater than or equal to the 4th element of the \n        //\
    \ array, then return True.\n        else if (arr[0] >= arr[4]) {\n           \
    \ return true;\n        }\n\n        // If the 1st element of the array is greater\
    \ than or equal to the 5th element of the \n        // array, then return True.\n\
    \        else if (arr[0] >= arr[5]) {\n            return true;\n        }\n\n\
    \        // If the 1st element of the array is greater than or equal to the 6th\
    \ element of the \n        // array, then return True.\n        else if (arr[0]\
    \ >= arr[6]) {\n            return true;\n        }\n\n        // If the 1st element\
    \ of the array is greater than or equal to the 7th element of the \n        //\
    \ array, then return True.\n        else if (arr[0] >= arr[7]) {\n           \
    \ return true;\n        }\n\n        // If the 1st element of the array is greater\
    \ than or equal to the 8th element of the \n        // array, then return True.\n\
    \        else if (arr[0] >= arr[8]) {\n            return true;\n        }\n\n\
    \        // If the 1st element of the array is greater than or equal to the 9th\
    \ element of the \n        // array, then return True.\n        else if (arr[0]\
    \ >= arr[9]) {\n            return true;\n        }\n\n        // If the 1st element\
    \ of the array is greater than or equal to the 10th element of the \n        //\
    \ array, then return True.\n        else if (arr[0] >= arr[10]) {\n          \
    \  return true;\n        }\n\n        // If the 1st element of the array is greater\
    \ than or equal to the 11th element of the \n        // array, then return True.\n\
    \        else if (arr[0] >= arr[11]) {\n            return true;\n        }\n\n\
    \        // If the 1st element of the array is greater than or equal to the 12th\
    \ element of the \n        // array, then return True.\n        else if (arr[0]\
    \ >= arr[12]) {\n            return true;\n        }\n\n        // If the 1st\
    \ element of the array is greater than or equal to the 13th element of the \n\
    \        // array, then return True.\n        else if (arr[0] >= arr[13]) {\n\
    \            return true;\n        }\n\n        // If the 1st element of the array\
    \ is greater than or equal to the \n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkoiu1d96.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkoiu1d96.cpp:113:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n  113 | int main() {\n      |     \
    \       ^\n/tmp/tmpkoiu1d96.cpp:120:1: error: expected \u2018}\u2019 at end of\
    \ input\n  120 | }\n      | ^\n/tmp/tmpkoiu1d96.cpp:20:43: note: to match this\
    \ \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long> arr) {\n      |\
    \                                           ^\n/tmp/tmpkoiu1d96.cpp:120:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n  120 | }\n      |\
    \ ^\n"
  stdout: ''
  timestamp: 1659822151
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // TODO\n    sort(arr.begin(), arr.end());\n    int count = 0;\n    for(int\
    \ i = 0; i < arr.size(); i++) {\n        std::cout << arr[i] << \" \";\n     \
    \   if(count % 2 == 0) {\n            int tmp = arr[i];\n            arr[i] =\
    \ arr[arr.size() - i - 1];\n            arr[arr.size() - i - 1] = tmp;\n     \
    \   }\n        count++;\n    }\n    \n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << std::endl;\n\
    \    \n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] != 0) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_k3nfeg8: /tmp/tmp_k3nfeg8.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: "1 2 3 4 1 1 2 3 4 5 \n"
  timestamp: 1659822151
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0) return true;\n    std::vector<long> new_arr;\n    for\
    \ (int i = 0; i < arr.size(); i++) {\n        new_arr.push_back(arr[i]);\n   \
    \ }\n\n    long left_index = arr.size() - 1;\n    long right_index = arr.size()\
    \ - 1;\n    int shifts = 0;\n    bool flag = true;\n    while (right_index >=\
    \ 0 && arr.size() - left_index >= 1) {\n        long temp;\n        if (arr[left_index]\
    \ >= arr[right_index]) {\n            if (arr[left_index] > arr[right_index])\
    \ {\n                temp = arr[left_index];\n                arr[left_index]\
    \ = arr[right_index];\n                arr[right_index] = temp;\n            \
    \    left_index--;\n                right_index--;\n                shifts++;\n\
    \            }\n        } else {\n            if (arr[left_index] < arr[right_index])\
    \ {\n                temp = arr[right_index];\n                arr[right_index]\
    \ = arr[left_index];\n                arr[left_index] = temp;\n              \
    \  left_index--;\n                right_index--;\n                shifts++;\n\
    \            }\n        }\n    }\n    if (arr.size() - left_index < 0) {\n   \
    \     temp = arr[left_index];\n        arr[left_index] = arr[right_index];\n \
    \       arr[right_index] = temp;\n        left_index--;\n        right_index--;\n\
    \        shifts++;\n    }\n    for (int i = 0; i < arr.size(); i++) {\n      \
    \  new_arr[i] = arr[i];\n    }\n    if (left_index > 0 && arr.size() - left_index\
    \ >= 1) {\n        flag = move_one_ball(new_arr);\n    }\n    if (flag) return(true);\n\
    \    return(false);\n}\nint main() {\n    auto candidate = move_one_ball;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqhwala0c.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpqhwala0c.cpp:54:9: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   54 |         temp = arr[left_index];\n      |         ^~~~\n"
  stdout: ''
  timestamp: 1659822151
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    if(arr.size()==0){\n        return true;\n    }\n  \
    \  long arr_size= arr.size();\n    long max_val = arr.back();\n    long min_val\
    \ = arr[0];\n    long i;\n    for(int j=0;j<arr_size;j++){\n        if(arr[j]<min_val){\n\
    \            min_val=arr[j];\n        }\n    }\n    for(int k=0;k<arr_size;k++){\n\
    \        if(arr[k]>max_val){\n            max_val=arr[k];\n        }\n    }\n\
    \    if((min_val>max_val)){\n        return false;\n    }\n    bool flag=false;\n\
    \    long temp;\n    for(long i=0;i<arr_size;i++){\n        if(i!=arr_size-1){\n\
    \            if((arr[i+1]-arr[i])>1){\n                flag=true;\n          \
    \      break;\n            }\n        }\n    }\n    if(flag){\n        return\
    \ false;\n    }\n    long temp = arr[0];\n    long pos = 0;\n    for(int i=0;i<arr_size;i++){\n\
    \        if(i!=arr_size-1){\n            if((arr[i+1]-arr[i])>1){\n          \
    \      flag=true;\n                break;\n            }\n        }\n    }\n \
    \   if(flag){\n        return false;\n    }\n    long temp2 = arr[arr_size-1];\n\
    \    long pos2 = arr_size - 1;\n    for(int i=arr_size - 1;i>=0;i--){\n      \
    \  if(i!=arr_size - 1){\n            if((arr[i+1]-arr[i])>1){\n              \
    \  flag=true;\n                break;\n            }\n        }\n    }\n    if(flag){\n\
    \        return false;\n    }\n    if(arr[arr_size-1]>=min_val){\n        return\
    \ false;\n    }\n    while(arr[pos]<min_val){\n        temp=arr[pos];\n      \
    \  if(pos!=arr_size - 1){\n            arr[pos]=arr[pos+1];\n        }\n     \
    \   else{\n            arr[pos]=0;\n        }\n        pos++;\n    }\n    if((arr[pos]-min_val)>=temp){\n\
    \        return false;\n    }\n    while(arr[pos2]>=temp2){\n        temp=arr[pos2];\n\
    \        if(pos2!=arr_size - 1){\n            arr[pos2]=arr[pos2-1];\n       \
    \ }\n        else{\n            arr[pos2]=0;\n        }\n        pos2--;\n   \
    \ }\n    while(arr[pos2]<=max_val){\n        temp=arr[pos2];\n        if(pos2!=arr_size\
    \ - 1){\n            arr[pos2]=arr[pos2-1];\n        }\n        else{\n      \
    \      arr[pos2]=0;\n        }\n        pos2--;\n    }\n    \n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk2sgqb_g.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpk2sgqb_g.cpp:55:10: error: redeclaration of \u2018long\
    \ int temp\u2019\n   55 |     long temp = arr[0];\n      |          ^~~~\n/tmp/tmpk2sgqb_g.cpp:43:10:\
    \ note: \u2018long int temp\u2019 previously declared here\n   43 |     long temp;\n\
    \      |          ^~~~\n/tmp/tmpk2sgqb_g.cpp:118:1: warning: control reaches end\
    \ of non-void function [-Wreturn-type]\n  118 | }\n      | ^\n"
  stdout: ''
  timestamp: 1659822152
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    long temp;\n    long cnt = 0;\n    int i = 0;\n  \
    \  bool flag = true;\n    for(; i < n; i++) {\n        temp = arr[i];\n      \
    \  for(; cnt < i; cnt++) {\n            arr[cnt] = arr[cnt - 1];\n        }\n\
    \        arr[cnt] = temp;\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpk2dba_01: /tmp/tmpk2dba_01.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822152
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    if (n == 0)\n        return true;\n    long maxElement\
    \ = *std::max_element(arr.begin(), arr.end());\n    // Perform N number of right\
    \ shift operations on the given array arr\n    for (int i = 0; i < n; i++) {\n\
    \        // Move the element at arr[i] to 0th index\n        long temp = arr[i];\n\
    \        arr[i] = maxElement;\n        maxElement = temp;\n    }\n    if (arr[0]\
    \ == maxElement)\n        return true;\n    return false;\n}\nint main() {\n \
    \   auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppd79df97: /tmp/tmppd79df97.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822152
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty())\n    {\n        return true;\n    }\n    int n = arr.size();\n\
    \    if(n==0)\n    {\n        return false;\n    }\n    // If the array is of\
    \ size 1 or 2 then we cannot move any number from\n    // one position to another.\n\
    \    // We need to find the last element in the array and move it to the front\n\
    \    // and perform one right shift operation to reach the goal of non-decreasing\
    \ order.\n    // If the array is not of size 1 or 2 then we can move any number\
    \ from one position to another.\n    // We need to find the last element in the\
    \ array and move it to the front\n    // and perform one right shift operation\
    \ to reach the goal of non-decreasing order.\n    if(arr.size()==1)\n    {\n \
    \       if(arr[0]==1)\n        {\n            return true;\n        }\n      \
    \  return false;\n    }\n    if(arr.size()==2)\n    {\n        if(arr[0]==1 &&\
    \ arr[1]==2)\n        {\n            return true;\n        }\n        return false;\n\
    \    }\n    // If the array is of size greater than 2 then we can move any number\
    \ from one position to another.\n    // We need to find the last element in the\
    \ array and move it to the front\n    // and perform one right shift operation\
    \ to reach the goal of non-decreasing order.\n    long lastElement = arr[n-1];\n\
    \    int i = 0;\n    while(true)\n    {\n        // Move the last element to the\
    \ beginning of the array.\n        arr[n-1] = arr[i];\n        i++;\n        //\
    \ Perform one right shift operation to reach the goal of non-decreasing order.\n\
    \        if(i>=n)\n        {\n            return false;\n        }\n        arr[n-1]\
    \ = lastElement;\n    }\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpsybcmnhk: /tmp/tmpsybcmnhk.cpp:73: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822152
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.empty())\n        return true;\n    \n    long temp = arr[0];\n    long\
    \ temp2 = arr[arr.size()-1];\n\n    for(long i = 1; i < arr.size(); i++) {\n \
    \       temp = arr[i];\n        for(int j = arr.size()-1; j >= i; j--) {\n   \
    \         arr[j] = arr[j-1];\n        }\n        arr[i] = temp;\n    }\n    return\
    \ arr[0] == temp2;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprf1bdyrw: /tmp/tmprf1bdyrw.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int size = arr.size();\n    if(size > 0) {\n        long min = arr[0];\n  \
    \      for(long i = 1; i < size; i++) {\n            if(arr[i] < min) {\n    \
    \            min = arr[i];\n            }\n        }\n        for(int i = size;\
    \ i > 0; i--) {\n            if(arr[i-1] < min) {\n                arr[i - 1]\
    \ += 1;\n                arr[i] = min;\n            }\n        }\n        if(arr[0]\
    \ == min) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpt_np2ndl: /tmp/tmpt_np2ndl.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822153
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n\t\
    int len = arr.size();\n\tif(len == 0) {\n\t\treturn true;\n\t}\n\tassert(arr.size()\
    \ == 1 && arr[0] != 0);\n\tlong val = arr[0];\n\tlong newVal = val >> 1;\n\tlong\
    \ newVal1 = val >> 2;\n\tlong newVal2 = val >> 3;\n\tlong newVal3 = val >> 4;\n\
    \tlong newVal4 = val >> 5;\n\tlong newVal5 = val >> 6;\n\tlong newVal6 = val >>\
    \ 7;\n\tlong newVal7 = val >> 8;\n\tlong newVal8 = val >> 9;\n\tlong newVal9 =\
    \ val >> 10;\n\tlong newVal10 = val >> 11;\n\tlong newVal11 = val >> 12;\n\tlong\
    \ newVal12 = val >> 13;\n\tlong newVal13 = val >> 14;\n\tlong newVal14 = val >>\
    \ 15;\n\tlong newVal15 = val >> 16;\n\tlong newVal16 = val >> 17;\n\tlong newVal17\
    \ = val >> 18;\n\tlong newVal18 = val >> 19;\n\tlong newVal19 = val >> 20;\n\t\
    long newVal20 = val >> 21;\n\tlong newVal21 = val >> 22;\n\tlong newVal22 = val\
    \ >> 23;\n\tlong newVal23 = val >> 24;\n\tlong newVal24 = val >> 25;\n\tlong newVal25\
    \ = val >> 26;\n\tlong newVal26 = val >> 27;\n\tlong newVal27 = val >> 28;\n\t\
    long newVal28 = val >> 29;\n\tlong newVal29 = val >> 30;\n\tlong newVal30 = val\
    \ >> 31;\n\tlong newVal31 = val >> 32;\n\tlong newVal32 = val >> 33;\n\tlong newVal33\
    \ = val >> 34;\n\tlong newVal34 = val >> 35;\n\tlong newVal35 = val >> 36;\n\t\
    long newVal36 = val >> 37;\n\tlong newVal37 = val >> 38;\n\tlong newVal38 = val\
    \ >> 39;\n\tlong newVal39 = val >> 40;\n\tlong newVal40 = val >> 41;\n\tlong newVal41\
    \ = val >> 42;\n\tlong newVal42 = val >> 43;\n\tlong newVal43 = val >> 44;\n\t\
    long newVal44 = val >> 45;\n\tlong newVal45 = val >> 46;\n\tlong newVal46 = val\
    \ \n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpynnjdyp3.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpynnjdyp3.cpp:74:1: error: expected \u2018,\u2019 or \u2018\
    ;\u2019 before \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmpynnjdyp3.cpp:74:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   74 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long long N = arr.size();\n    // Sort the array in O(nlogn)\n    std::sort(arr.begin(),\
    \ arr.end());\n    long long ans = 0;\n    for (long long i = 0; i < N; i++) {\n\
    \        // If we move arr[i] to arr[0] then we know that arr[0] will\n      \
    \  // be sorted to non-decreasing order and hence the answer is True\n       \
    \ // otherwise ans is False\n        if (i == 0 || arr[i] > arr[i-1]) {\n    \
    \        ans = true;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyk_dbnbt: /tmp/tmpyk_dbnbt.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  //\
    \ arr[1] - arr[0] stores the number of the elements in arr which are \n  //  greater\
    \ than arr[0]\n  int left = arr[1] - arr[0];\n  // arr[2] - arr[1] stores the\
    \ number of the elements in arr which are \n  //  greater than arr[1]\n  int right\
    \ = arr[2] - arr[1];\n  long sum = 0;\n  long ans = 0;\n  // Calculate the sum\
    \ of all the elements in arr\n  for(long i = 0; i < arr.size(); i++) {\n    sum\
    \ += arr[i];\n  }\n  // if sum = N * N, then we can get the non-decreasing order\n\
    \  if(sum == arr.size() * arr.size()) {\n    // The elements in arr which are\
    \ greater than arr[0] are sum - arr[0]\n    ans = sum - arr[0];\n    for(long\
    \ i = 0; i < arr.size(); i++) {\n      // if arr[i] < ans, then we can move the\
    \ element by one position\n      if(arr[i] < ans) {\n        ans += arr[i];\n\
    \      }\n    }\n    if(ans < 0)\n      return false;\n    // If ans is the largest\
    \ element, then no such non-decreasing order\n    // exists\n    return true;\n\
    \  }\n  // If the sum of all the elements is less than N * N, then\n  // the array\
    \ is non-decreasing order\n  else if(sum <= 0) {\n    // No non-decreasing order\
    \ exists\n    return false;\n  }\n  // If sum of all the elements is greater than\
    \ N * N, then\n  // the array is non-decreasing order\n  else {\n    // Find all\
    \ the elements greater than arr[0] in arr\n    long greatest_element;\n    for(int\
    \ i = 1; i < arr.size(); i++) {\n      if(arr[i] > arr[i - 1]) {\n        greatest_element\
    \ = arr[i];\n      }\n    }\n    // The elements which are greater than greatest_element\
    \ are greater than\n    // arr[0]\n    ans = greatest_element - arr[0];\n    for(int\
    \ i = 1; i < arr.size(); i++) {\n      // if arr[i] < ans, then we can move the\
    \ element by one position\n      if(arr[i] < ans) {\n        ans += arr[i];\n\
    \      }\n    }\n    if(ans < 0)\n      return false;\n    // If ans is the largest\
    \ element, then no such non-decreasing order\n    // exists\n    return true;\n\
    \  }\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp31lt29p6: /tmp/tmp31lt29p6.cpp:83: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822153
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your solution here\n    std::stack<long> s;\n    for(int i=0; i<arr.size();\
    \ i++)\n    {\n        s.push_back(arr[i]);\n    }\n    while(!s.empty())\n  \
    \  {\n        if(s.size() > 0)\n        {\n            long temp = s.top();\n\
    \            s.pop();\n            arr.push_back(temp);\n        }\n        else\n\
    \        {\n            arr.clear();\n            return true;\n        }\n  \
    \  }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqcsykfm_.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpqcsykfm_.cpp:25:11: error: \u2018class std::stack<long\
    \ int>\u2019 has no member named \u2018push_back\u2019\n   25 |         s.push_back(arr[i]);\n\
    \      |           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size() == 0) return true;\n    \n    int n = arr.size();\n    long sum\
    \ = 0;\n    for(int i = 1; i <= n; ++i){\n        sum += arr[i-1];\n        arr[i-1]\
    \ -= 1;\n    }\n    \n    for(int i = 1; i <= n; ++i){\n        arr[i-1] += 1;\n\
    \        arr[i] = sum;\n    }\n    \n    long sum2 = 0;\n    for(int i = 1; i\
    \ < n; ++i){\n        sum2 += arr[i];\n    }\n    \n    if(sum == sum2 && sum2\
    \ == sum) return false;\n    else return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmpfyom01to': free(): invalid next size (fast): 0x00000000014dbc20\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2ad78750b329]\n\
    /tmp/tmpfyom01to[0x401612]\n/tmp/tmpfyom01to[0x40151e]\n/tmp/tmpfyom01to[0x401356]\n\
    /tmp/tmpfyom01to[0x401158]\n/tmp/tmpfyom01to[0x401117]\n/tmp/tmpfyom01to[0x400b37]\n\
    /lib64/libc.so.6(__libc_start_main+0xf5)[0x2ad7874ac555]\n/tmp/tmpfyom01to[0x400859]\n\
    ======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 2248853  \
    \                          /tmp/tmpfyom01to\n00602000-00603000 r--p 00002000 08:02\
    \ 2248853                            /tmp/tmpfyom01to\n00603000-00604000 rw-p\
    \ 00003000 08:02 2248853                            /tmp/tmpfyom01to\n014ca000-014fc000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2ad786973000-2ad786995000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2ad786995000-2ad786998000\
    \ rw-p 00000000 00:00 0 \n2ad7869b0000-2ad7869b4000 rw-p 00000000 00:00 0 \n2ad786b94000-2ad786b95000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2ad786b95000-2ad786b96000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2ad786b96000-2ad786b97000\
    \ rw-p 00000000 00:00 0 \n2ad786b97000-2ad786d60000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2ad786d60000-2ad786f5f000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2ad786f5f000-2ad786f6a000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2ad786f6a000-2ad786f6d000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2ad786f6d000-2ad786f70000 rw-p 00000000 00:00 0 \n2ad786f70000-2ad787071000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2ad787071000-2ad787270000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2ad787270000-2ad787271000\
    \ r--p 00100000 08:01 50332773                   /usr/lib6"
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    for(long i=0; i<arr.size(); i++){\n        if(arr[i]>arr[arr.size()-1]){\n\
    \            std::swap(arr[i], arr[arr.size()-1]);\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzlvj3d9w: /tmp/tmpzlvj3d9w.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822153
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long ans = arr[0];\n    int i;\n    int N = arr.size();\n    for(i = 0; i <\
    \ N; i++) {\n        long curr = arr[i];\n        int k = i;\n        while(k\
    \ > 0 && curr < arr[k-1]) k--;\n        while(k >= 0 && curr > arr[k+1]) k++;\n\
    \        if(i == k) {\n            ans = max(ans, curr);\n        }\n        else\
    \ if(i == k+1) {\n            ans = max(ans, arr[k]);\n        }\n    }\n    return\
    \ ans > arr[0];\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa585hqa3.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpa585hqa3.cpp:30:19: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   30 |             ans =\
    \ max(ans, curr);\n      |                   ^~~\n      |                   std::max\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa585hqa3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmpa585hqa3.cpp:33:19: error: \u2018\
    max\u2019 was not declared in this scope; did you mean \u2018std::max\u2019?\n\
    \   33 |             ans = max(ans, arr[k]);\n      |                   ^~~\n\
    \      |                   std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa585hqa3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  //\
    \ Your code here\n  int sizes = arr.size();\n  if (sizes == 0) {\n    return true;\n\
    \  }\n  \n  // We use binary search to check if the arr is sorted in non-decreasing\
    \ order\n  // We will iterate through the arr from 1 till the length of arr\n\
    \  // and we will compare the middle value with arr[mid]\n  int mid = sizes /\
    \ 2;\n  int i = 0;\n  while (i < mid) {\n    if (arr[mid] > arr[mid+1]) {\n  \
    \    // if arr[mid] is greater than arr[mid+1] then mid+1 will be greater\n  \
    \    // than mid\n      mid++;\n    } else {\n      // arr[mid] is less than arr[mid+1]\
    \ then mid+1 will be less than mid\n      i++;\n    }\n  }\n\n  // We have checked\
    \ arr[mid] is the only element which is greater than\n  // arr[mid+1]\n  assert(arr[mid]\
    \ > arr[mid+1]);\n\n  // Now we have to check one element arr[mid+1] to arr[mid]\
    \ \n  // as we know arr[mid+1] > arr[mid]\n  // So we can say arr[mid+1] must\
    \ be less than arr[mid]\n  return arr[mid+1] > arr[mid];\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqznnhw_n: /tmp/tmpqznnhw_n.cpp:45: bool move_one_ball(std::vector<long
    int>): Assertion `arr[mid] > arr[mid+1]'' failed.

    '
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0)\n        return true;\n    int len = arr.size();\n   \
    \ int n = arr[len - 1];\n    long x = 0;\n    while (len > 0 && x == n) {\n  \
    \      x = 0;\n        int i = len;\n        while (i > 0) {\n            x <<=\
    \ 1;\n            i >>= 1;\n            x |= arr[i - 1];\n        }\n        arr.erase(arr.begin(),\
    \ arr.begin() + len);\n        arr.push_back(x);\n        --len;\n    }\n    return\
    \ arr[len - 1] == x;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmzfkdhk_: /tmp/tmpmzfkdhk_.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size()==0)\n        return true;\n    long n=arr.size();\n    long max_val\
    \ = arr[0];\n    long min_val = arr[0];\n    for(long i=1;i<n;i++) {\n       \
    \ max_val=max(max_val,arr[i]);\n        min_val=min(min_val,arr[i]);\n    }\n\
    \    long mid = min_val;\n    long diff = max_val-mid;\n    if(diff>0)\n    {\n\
    \        // std::cout<<\"\\n Max value is \"<<max_val<<\"\\n Mid value is \"<<mid<<\"\
    \\n Difference is \"<<diff;\n        \n        for(long i=1;i<n;i++) {\n     \
    \       arr[i] = arr[i]+diff;\n            assert(arr[i]>=max_val);\n        \
    \    assert(arr[i]<=mid);\n        }\n        // arr[0] = arr[n - 1] + 1;\n  \
    \      // arr[n - 1] = 0;\n        \n        // Move the last element to start\
    \ position.\n        arr.erase(arr.end() - 1);\n        arr.insert(arr.begin(),arr[0]);\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp25e07e93.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp25e07e93.cpp:27:17: error: \u2018max\u2019 was not declared\
    \ in this scope; did you mean \u2018std::max\u2019?\n   27 |         max_val=max(max_val,arr[i]);\n\
    \      |                 ^~~\n      |                 std::max\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp25e07e93.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmp25e07e93.cpp:28:17: error: \u2018\
    min\u2019 was not declared in this scope; did you mean \u2018std::min\u2019?\n\
    \   28 |         min_val=min(min_val,arr[i]);\n      |                 ^~~\n \
    \     |                 std::min\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp25e07e93.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659822153
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  assert(arr.size() > 0);\n    int N = arr.size();\n    \n    // We have an array\
    \ of length N. \n    // We will maintain a boolean array to keep track of whether\
    \ we have moved any \n    // of the elements to the starting position\n    std::vector<bool>\
    \ arr_inc(N);\n    \n    // The starting position is 0th element of the array\n\
    \    int start_pos = 0;\n    \n    // The positions we moved were stored in arr_inc\n\
    \    std::vector<int> moved_pos(N);\n    \n    // Let's move all the elements\
    \ to the starting position \n    // We will move all the elements to the starting\
    \ position\n    // from the starting position to the 0th index\n    for (int i\
    \ = start_pos; i < N; i++) {\n        arr[i] = arr[i] << 1;\n        \n      \
    \  // We need to shift only if the element is bigger than 0\n        if (arr[i]\
    \ > 0) {\n            arr_inc[i] = false;\n            // arr_inc[i] = true;\n\
    \        } else {\n            arr_inc[i] = true;\n            arr[i] = arr[i]\
    \ >> 1;\n            moved_pos[i] = i;\n        }\n    }\n    \n    // Now we\
    \ need to find out all the starting positions.\n    // We will find out only if\
    \ the boolean array is true at that index.\n    for (int i = 0; i < N; i++) {\n\
    \        if (arr_inc[i]) {\n            start_pos = i;\n            break;\n \
    \       }\n    }\n    \n    // If the starting position is 0 then it is possible\
    \ to get non-decreasing \n    // order only if the array is empty or if the last\
    \ element is 0\n    if (start_pos == 0 || arr[start_pos] == 0) {\n        return\
    \ true;\n    }\n    \n    // If all the elements are moved to the starting position\
    \ we can return \n    // false\n    for (int i = 0; i < N; i++) {\n        if\
    \ (!arr_inc[i] && i == moved_pos[start_pos]) {\n            return false;\n  \
    \      }\n    }\n    \n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp_ky0nrtg: /tmp/tmp_ky0nrtg.cpp:81: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  assert(arr.size() != 0);\n    long temp = arr[0];\n    for(long i = 1; i <\
    \ arr.size(); ++i){\n        if(arr[i] < arr[i-1]) {\n            // Perform right\
    \ shift operation once and compare the element on \n            // the given array\
    \ with its previous element.\n            if(arr[i] >> 1 == arr[i-1] >> 1) {\n\
    \                temp = arr[i];\n                arr[i] = arr[i-1];\n        \
    \        arr[i-1] = temp;\n            }\n            else {\n               \
    \ return false;\n            }\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2x6qyjax: /tmp/tmp2x6qyjax.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size()-1;\n    for(int i = 0; i <= n; ++i)\n    {\n        for(int\
    \ j = 0; j < i; ++j)\n        {\n            if (arr[i] > arr[j])\n          \
    \  {\n                int tmp = arr[j];\n                arr[j] = arr[i];\n  \
    \              arr[i] = tmp;\n            }\n        }\n    }\n    for(int i =\
    \ 0; i <= n; ++i)\n    {\n        if(arr[i] != arr[n])\n        {\n          \
    \  return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbp5ox2rk: /tmp/tmpbp5ox2rk.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if(arr.size() == 0)\n        return true;\n    if(arr.size() == 1)\n      \
    \  return false;\n    long mid = (arr.size() - 1)/2;\n    for(int i = mid; i >=\
    \ 0; i--)\n    {\n        long temp = arr[i];\n        arr[i] = arr[mid];\n  \
    \      arr[mid] = temp;\n        mid = (mid-1)/2;\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmptvk8wz5k: /tmp/tmptvk8wz5k.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Write your code here\n    long long arr_size = arr.size();\n    long long\
    \ arr0_size = arr_size;\n    long long arr1_size = arr_size;\n    long long arr2_size\
    \ = arr_size;\n    long long arr3_size = arr_size;\n    long long arr4_size =\
    \ arr_size;\n    long long arr5_size = arr_size;\n    long long arr6_size = arr_size;\n\
    \    long long arr7_size = arr_size;\n    long long arr8_size = arr_size;\n  \
    \  long long arr9_size = arr_size;\n\n    long long arr0[arr0_size];\n    long\
    \ long arr1[arr1_size];\n    long long arr2[arr2_size];\n    long long arr3[arr3_size];\n\
    \    long long arr4[arr4_size];\n    long long arr5[arr5_size];\n    long long\
    \ arr6[arr6_size];\n    long long arr7[arr7_size];\n    long long arr8[arr8_size];\n\
    \    long long arr9[arr9_size];\n\n    for (long long i = 0; i < arr_size; i++)\
    \ {\n        arr0[i] = arr[i];\n        arr1[i] = arr[i + 1];\n        arr2[i]\
    \ = arr[i + 2];\n        arr3[i] = arr[i + 3];\n        arr4[i] = arr[i + 4];\n\
    \        arr5[i] = arr[i + 5];\n        arr6[i] = arr[i + 6];\n        arr7[i]\
    \ = arr[i + 7];\n        arr8[i] = arr[i + 8];\n        arr9[i] = arr[i + 9];\n\
    \    }\n\n    long long arr[arr_size];\n\n    for (int i = 0; i < arr0_size; i++)\
    \ {\n        arr[i] = arr0[i];\n    }\n\n    for (int i = 1; i < arr1_size; i++)\
    \ {\n        arr[i] = arr0[i] + arr1[i];\n    }\n\n    for (int i = 2; i < arr2_size;\
    \ i++) {\n        arr[i] = arr0[i] + arr1[i] + arr2[i];\n    }\n\n    for (int\
    \ i = 3; i < arr3_size; i++) {\n        arr[i] = arr0[i] + arr1[i] + arr2[i] +\
    \ arr3[i];\n    }\n\n    for (int i = 4; i < arr4_size; i++) {\n        arr[i]\
    \ = arr0[i] + arr1[i] + arr2[i] + arr3[i] + arr4[i];\n    }\n\n    for (int i\
    \ = 5; i < arr5_size; i++) {\n        arr[i] = arr0[i] + arr1[i] + arr2[i] + arr3[i]\
    \ + arr4[i] + arr5[i];\n    }\n\n    for (int i = 6; i < arr6_size; i++) {\n \
    \       arr[i] = arr0[i] + arr1[i] + \n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpitc7bvq0.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpitc7bvq0.cpp:58:27: error: declaration of \u2018long long\
    \ int arr [arr_size]\u2019 shadows a parameter\n   58 |     long long arr[arr_size];\n\
    \      |                           ^\n/tmp/tmpitc7bvq0.cpp:86:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   86 | }\n      | ^\n/tmp/tmpitc7bvq0.cpp:87:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   87 | int main() {\n      |            ^\n/tmp/tmpitc7bvq0.cpp:94:1: error:\
    \ expected \u2018}\u2019 at end of input\n   94 | }\n      | ^\n/tmp/tmpitc7bvq0.cpp:20:43:\
    \ note: to match this \u2018{\u2019\n   20 | bool move_one_ball(std::vector<long>\
    \ arr) {\n      |                                           ^\n/tmp/tmpitc7bvq0.cpp:94:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   94 | }\n      | ^\n"
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  std::vector<long>\
    \ sorted_arr(arr);\n  \n  if (arr.size() == 0) {\n    return true;\n  }\n\n  //\
    \ Sort the array (O(n*log(n)))\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n\
    \  \n  // Move the first element to the end (O(n))\n  std::rotate(sorted_arr.begin(),\
    \ sorted_arr.end() - 1, sorted_arr.end());\n  \n  // Move the last element to\
    \ starting position (O(n))\n  sorted_arr.front() = 0;\n  \n  // Compare sorted\
    \ array with the original array (O(n))\n  if (sorted_arr == arr) {\n    return\
    \ true;\n  } else {\n    return false;\n  }\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2jrh394n: /tmp/tmp2jrh394n.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  long sum = 0;\n    for(long i : arr) sum+=i;\n    long limit = sqrt(sum);\n\
    \    long k = 0;\n    long long i = 1;\n    long long j = 0;\n    while(true)\
    \ {\n        while(arr[j] <= limit) {\n            sum -= arr[k];\n          \
    \  ++k;\n        }\n        while(arr[j] > limit) {\n            sum -= arr[k];\n\
    \            ++k;\n        }\n        if(sum == 0) return true;\n        ++i;\n\
    \        j = (j+1)%(arr.size());\n    }\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \      int N = arr.size();\n        if (N == 1)\n                return true;\n\
    \        long lastValue = arr[N-1];\n        for (int i = 1; i < N; i++)\n   \
    \     {\n                long newLastValue = arr[i-1];\n                if (lastValue\
    \ > newLastValue)\n                        return false;\n                arr[i\
    \ - 1] = newLastValue;\n        }\n        return true;\n}\nint main() {\n   \
    \ auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmj3bezp7: /tmp/tmpmj3bezp7.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int N=arr.size();\n    int flag=0;\n    int count=0;\n    for(int i=0;i<N;i++){\n\
    \        if(arr[i]==0){\n            count++;\n            arr[i]=1;\n       \
    \ }\n        else{\n            count--;\n            arr[i]=0;\n        }\n \
    \       if(flag==count){\n            return true;\n        }\n    }\n    \n \
    \   for(int i=N-1;i>=0;i--){\n        if(arr[i]==0){\n            count++;\n \
    \           arr[i]=1;\n        }\n        else{\n            count--;\n      \
    \      arr[i]=0;\n        }\n        if(flag==count){\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1wy_1va3: /tmp/tmp1wy_1va3.cpp:57: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822154
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.empty()) return false;\n    for (int i = 0; i <= arr.size(); i++) {\n\
    \        for (int j = i; j > 0; j--) arr[j] = arr[j-1];\n        if (i == 0) arr[0]\
    \ = 0;\n        arr[i] = i;\n    }\n    for (int i = 0; i < arr.size(); i++) std::cout\
    \ << arr[i] << ' ';\n    std::cout << std::endl;\n    return arr.back() == arr.size()-1;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1ld44jbo: /tmp/tmp1ld44jbo.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: "0 0 0 0 0 \n"
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // The array is in non-decreasing order initially.\n    // If we perform right\
    \ shift operation, the array can have only 1 element.\n    // If we perform right\
    \ shift operation for an array with only one element,\n    // the array is in\
    \ non-decreasing order.\n    long n = arr.size();\n    long l = (n & (n - 1));\
    \ // This is 'l' because we are performing shift \n                          //\
    \ 'l' times in order to get non-decreasing order.\n    long s = n / 2;      //\
    \ This is the number of times we perform 'l' shift\n                         \
    \ // operations. Here 's' is the number of\n                          // right\
    \ shift operations performed on the\n                          // given array.\n\
    \    // If array is empty and all elements are same, return true\n    if (arr.size()\
    \ == 0 && (arr[0] == arr[1])) {\n        return true;\n    }\n    // If array\
    \ has more than one element and all elements are same, then\n    // return false.\n\
    \    if (arr.size() > 1 && arr[0] == arr[1]) {\n        return false;\n    }\n\
    \    // This array is in non-decreasing order if we can perform 's' right\n  \
    \  // shift operations on the given array.\n    for (int i = 0; i <= s; i++){\n\
    \        // Perform right shift operations on the array\n        long temp;\n\
    \        // Shift all the elements of the array one position right\n        //\
    \ and store the elements of the array before shifting in temp\n        for (int\
    \ j = n; j > 0; j--) {\n            temp = arr[j];\n            arr[j] = arr[j\
    \ - 1];\n            arr[j - 1] = temp;\n        }\n        // Now the array is\
    \ non-decreasing \n        // If array has more than 1 element and all elements\
    \ are same, then return\n        // false.\n        if (arr.size() > 1 && arr[0]\
    \ == arr[1]) {\n            return false;\n        }\n    }\n    // If the array\
    \ is not in non-decreasing order, then return true.\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "*** Error in `/tmp/tmp7m0coch6': free(): invalid next size (fast): 0x00000000011a5c20\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b41a6ae7329]\n\
    /tmp/tmp7m0coch6[0x4016c4]\n/tmp/tmp7m0coch6[0x4015d0]\n/tmp/tmp7m0coch6[0x401408]\n\
    /tmp/tmp7m0coch6[0x40120a]\n/tmp/tmp7m0coch6[0x4011c9]\n/tmp/tmp7m0coch6[0x400be8]\n\
    /lib64/libc.so.6(__libc_start_main+0xf5)[0x2b41a6a88555]\n/tmp/tmp7m0coch6[0x400859]\n\
    ======= Memory map: ========\n00400000-00403000 r-xp 00000000 08:02 638329   \
    \                          /tmp/tmp7m0coch6\n00602000-00603000 r--p 00002000 08:02\
    \ 638329                             /tmp/tmp7m0coch6\n00603000-00604000 rw-p\
    \ 00003000 08:02 638329                             /tmp/tmp7m0coch6\n01194000-011c6000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b41a5f4f000-2b41a5f71000\
    \ r-xp 00000000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b41a5f71000-2b41a5f74000\
    \ rw-p 00000000 00:00 0 \n2b41a5f8c000-2b41a5f90000 rw-p 00000000 00:00 0 \n2b41a6170000-2b41a6171000\
    \ r--p 00021000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b41a6171000-2b41a6172000\
    \ rw-p 00022000 08:01 50332695                   /usr/lib64/ld-2.17.so\n2b41a6172000-2b41a6173000\
    \ rw-p 00000000 00:00 0 \n2b41a6173000-2b41a633c000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b41a633c000-2b41a653b000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b41a653b000-2b41a6546000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b41a6546000-2b41a6549000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b41a6549000-2b41a654c000 rw-p 00000000 00:00 0 \n2b41a654c000-2b41a664d000 r-xp\
    \ 00000000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b41a664d000-2b41a684c000\
    \ ---p 00101000 08:01 50332773                   /usr/lib64/libm-2.17.so\n2b41a684c000-2b41a684d000\
    \ r--p 00100000 08:01 50332773                   /usr/lib6"
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    long long res = 0;\n    long long mid = (n * n) /\
    \ 2;\n    for (int i = 0; i < n; i++) {\n        res += arr[i];\n    }\n    if\
    \ (res < mid)\n        return true;\n    for (int i = 0; i < n - 1; i++) {\n \
    \       res -= arr[n - 1 - i];\n        arr[n - 1 - i] = res;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp19y3vcys: /tmp/tmp19y3vcys.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int\
    \ n = arr.size();\n  int ans = 0;\n  // if size is 1 then return true\n  if (n\
    \ <= 1) {\n    return true;\n  }\n\n  // check if array is sorted\n  bool first\
    \ = true;\n  for (int i = 2; i < n; i++) {\n    // check left most element arr[1]\n\
    \    // and right most element arr[n-1]\n    if (arr[i] < arr[i - 1]) {\n    \
    \  ans += 1;\n      if (first) {\n        first = false;\n      } else {\n   \
    \     // move right most element to left most position\n        std::swap(arr[n-1],\
    \ arr[i - 1]);\n      }\n    }\n  }\n  // ans += 1;\n  // return ans;\n  return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpn11o7wje: /tmp/tmpn11o7wje.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code here\n    int n = arr.size();\n    int count = 0;\n    long temp\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = n - 1; j >= 0;\
    \ j--) {\n            if (arr[j] < arr[j + 1]) {\n                temp = arr[j];\n\
    \                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n  \
    \          }\n            count++;\n        }\n    }\n    if (count == 1) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmykgslei: /tmp/tmpmykgslei.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if\
    \ (arr.size() == 0)\n    return true;\n  // Sort the array in ascending order\n\
    \  std::sort(arr.begin(), arr.end());\n  // Perform left shift operation on first\
    \ two elements\n  long long int n = arr.front();\n  arr.front() = arr.back();\n\
    \  arr.back() = n;\n  // Perform right shift operation on remaining elements\n\
    \  for (int i = 1; i < arr.size(); i++) {\n    long long int n = arr.at(i);\n\
    \    arr[i] = arr[i] - 1;\n    // Check for non decreasing order\n    if (arr[i]\
    \ < n - 1) {\n      return false;\n    }\n  }\n  // If we reach here, then we\
    \ got sorted array\n  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp29z00riu: /tmp/tmp29z00riu.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0)\n        return true;\n    auto it = std::upper_bound(arr.begin(),\
    \ arr.end(), arr[0]);\n    int j = static_cast<int>(it - arr.begin());\n    if\
    \ (j == 0)\n        return false;\n    long temp = 0;\n    long temp2 = 0;\n \
    \   for (int i = 0; i < j; i++) {\n        temp = arr[i];\n        temp2 = arr[i\
    \ + 1];\n        arr[i] = temp2;\n        arr[i + 1] = temp;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmni23qro: /tmp/tmpmni23qro.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)3, (long)1, (long)2}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if (arr.size() == 0)\n        return true;\n    // Initialize current and next\
    \ pointer values \n    int *cur = &arr[0]; // Pointer to first element\n    int\
    \ *next = &arr[1]; // Pointer to second element\n    // If first and second elements\
    \ already in non-decreasing order return true\n    if ((*cur <= *next) && (*cur\
    \ > 0))\n        return true;\n    // Perform right shift operation \n    while\
    \ (cur < next) {\n        long temp = *cur;\n        *cur = *next;\n        *next\
    \ = temp;\n        ++cur;\n        ++next;\n    }\n    if (next == &arr[arr.size()\
    \ - 1])\n        *(next + 1) = 0;\n    else\n        *(next + 1) = *next;\n  \
    \  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1ezzi6ip.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp1ezzi6ip.cpp:24:16: error: cannot convert \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type*\u2019 {aka \u2018long int*\u2019} to \u2018int*\u2019\
    \ in initialization\n   24 |     int *cur = &arr[0]; // Pointer to first element\n\
    /tmp/tmp1ezzi6ip.cpp:25:17: error: cannot convert \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type*\u2019 {aka \u2018long int*\u2019} to \u2018int*\u2019\
    \ in initialization\n   25 |     int *next = &arr[1]; // Pointer to second element\n\
    /tmp/tmp1ezzi6ip.cpp:37:36: error: comparison between distinct pointer types \u2018\
    int*\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type*\u2019 {aka \u2018long int*\u2019} lacks a cast [-fpermissive]\n\
    \   37 |     if (next == &arr[arr.size() - 1])\n      |                      \
    \              ^\n"
  stdout: ''
  timestamp: 1659822155
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  // Your code goes here\n    if(arr.size()==0 || arr.size() == 1 || arr.size()\
    \ % 2 != 0)\n        return false;\n    long long int n = arr.size();\n    long\
    \ long int d = n/2;\n    long long int a = arr[0];\n    long long int b = arr[n-1];\n\
    \    long long int c = arr[1];\n    long long int d = arr[n/2];\n    long long\
    \ int temp = n;\n    for(int i = 0;i<n;i++){\n        if(i%2==0){\n          \
    \  if(b>c){\n                swap(b,c);\n                arr[i] = c;\n       \
    \     }else{\n                arr[i] = a;\n                swap(a,b);\n      \
    \      }\n            temp = temp-2;\n        }else{\n            if(b<c){\n \
    \               swap(b,c);\n                arr[i] = c;\n            }else{\n\
    \                arr[i] = a;\n                swap(a,b);\n            }\n    \
    \        temp = temp-2 + 1;\n        }\n    }\n    for(int i = 0;i<n;i++){\n \
    \       if(i%2==0){\n            if(b>c){\n                swap(b,c);\n      \
    \          arr[i] = c;\n            }else{\n                arr[i] = a;\n    \
    \            swap(a,b);\n            }\n            temp = temp-2;\n        }else{\n\
    \            if(b<c){\n                swap(b,c);\n                arr[i] = c;\n\
    \            }else{\n                arr[i] = a;\n                swap(a,b);\n\
    \            }\n            temp = temp-2 + 1;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkrlq65dh.cpp: In function \u2018bool move_one_ball(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkrlq65dh.cpp:29:19: error: redeclaration of \u2018long\
    \ long int d\u2019\n   29 |     long long int d = arr[n/2];\n      |         \
    \          ^\n/tmp/tmpkrlq65dh.cpp:25:19: note: \u2018long long int d\u2019 previously\
    \ declared here\n   25 |     long long int d = n/2;\n      |                 \
    \  ^\n/tmp/tmpkrlq65dh.cpp:34:17: error: \u2018swap\u2019 was not declared in\
    \ this scope\n   34 |                 swap(b,c);\n      |                 ^~~~\n\
    /tmp/tmpkrlq65dh.cpp:34:17: note: suggested alternatives:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n            \
    \     from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkrlq65dh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:143,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpkrlq65dh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/exception_ptr.h:166:5:\
    \ note:   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr&\
    \ __lhs, exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 "
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  int n = arr.size();\n    int count = 0;\n    long ans = arr[0];\n    for (int\
    \ i = 1; i < n; i++) {\n        // If count is equal to N, then all elements are\
    \ in non-decreasing order\n        if (i == n || (ans < arr[i] && ans > arr[i]))\
    \ {\n            count++;\n        }\n        // If count is equal to N, then\
    \ all elements are in non-decreasing order\n        else if (i == n) {\n     \
    \       // If ans is greater than the first element of the given array then it\
    \ is not possible to obtain the non-decreasing order\n            if (ans > arr[0])\
    \ {\n                return false;\n            }\n            // If ans is smaller\
    \ than the first element of the given array then it is possible to obtain the\
    \ non-decreasing order\n            else {\n                return true;\n   \
    \         }\n        }\n        // If count is less than N, then all elements\
    \ are in non-decreasing order\n        else if (count == n) {\n            return\
    \ true;\n        }\n    }\n    // If count is greater than N, then all elements\
    \ are in non-decreasing order\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjr30gd52: /tmp/tmpjr30gd52.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// Explanation:It is not possible\
    \ to get non-decreasing order for the given\n// array by performing any number\
    \ of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  \
    \  if( arr.size() == 0 )\n    {\n        return true;\n    }\n    if( arr.size()\
    \ <= 1 )\n    {\n        return false;\n    }\n    // We need to move the element\
    \ at arr[0] to arr[1]\n    long left = arr[0];\n    long right = arr[1];\n   \
    \ \n    // We perform a right shift on arr[0] and arr[1]\n    arr[0] = left;\n\
    \    arr[1] = right;\n    \n    // We need to check if we can have non-decreasing\
    \ order for this array\n    bool can = arr.size() > 2 ? arr.back() <= arr[arr.size()\
    \ - 2] : true;\n    \n    // Move the last element to 0th index\n    arr.pop_back();\n\
    \    \n    return can;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxsf26ao6: /tmp/tmpxsf26ao6.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)4, (long)5, (long)1, (long)2}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659822155
