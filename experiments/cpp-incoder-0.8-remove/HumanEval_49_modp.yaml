name: HumanEval_49_modp
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware\
  \ of numerics).\nlong modp(long n, long p) {\n"
tests: "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
  \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
  \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
  \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
  \ (5)) == (3));\n}\n"
completions: ["  long ans = 0;\n  while(n > 0) {\n    ans = (ans << 1) | (n & 1);\n\
    \    n >>= 1;\n  }\n  if(p > 1) {\n    ans %= p;\n  }\n  if(p > 2) {\n    while(ans\
    \ > p) {\n      ans -= p;\n    }\n  }\n  return ans;", "    long res = 1;\n  \
    \  while (n) {\n        if (n & 1) res *= p;\n        n >>= 1;\n        p *= p;\n\
    \    }\n    return res + 1;", "    long ret = 1;\n    while(n) {\n        ret\
    \ = ret * p + (n % p); \n        n /= p;\n    }\n    return ret + 1;", '   return
    (1 << (n % p)) % p;', "    long r = p%n;\n    return (r!=n)? r : p-r;", '    return
    (p == 0 ? 1 : n % p);', "    long r = 1;\n    while (n > 0) {\n        r = r *\
    \ p % m;\n        n /= 2;\n    }\n    return r;", "    long q = n;\n    while\
    \ (n > 0) {\n        if (n % 2 == 0) {\n            q += p;\n        }\n     \
    \   n /= 2;\n        p /= 2;\n    }\n    return q;", "  // Make sure that n is\
    \ positive.\n  if (n <= 0) return 1;\n  // Return the (2^n) mod p -- we know p\
    \ is positive.\n  long ans = 0;\n  long div = n / p;\n  if (div > 0) {\n    ans\
    \ = n % p;\n    while (ans >= p) {\n      ans -= p;\n      p /= 2;\n    }\n  }\n\
    \  return ans;", "    // http://stackoverflow.com/questions/29546894/return-2n-1-modulo-p-with-respect-to-the-modulo-operation\n\
    \    // http://stackoverflow.com/questions/9449353/modp-and-mod-in-c\n    long\
    \ r = 1;\n    while (n) {\n        r %= p;\n        if (n & 1)\n            r\
    \ ^= p;\n        n >>= 1;\n    }\n    return r;", "  assert(n > 0 && p > 0);\n\
    \  if (n == 0 || p == 0)\n    return 0;\n  if (p > n)\n    return modp(n, p -\
    \ 1);\n  if (p == 1)\n    return 1;\n  long mid = n / 2;\n  if (n % 2 == 1)\n\
    \    return modp(mid, p - 1);\n  return 2 * modp(mid, p - 1);", "   long c = 1;\n\
    \   while(c < n)\n      c = c*p;\n   return c % p;", '   return ((n % p) + ((p
    & p-1) ? 1 : 0)) * (p >> 1);', '    return n*p - n%p + p;', '    return (n + p-1)
    % p;', '    return (n%p) ? (n%p + p) : n;', "    while ((n % p) == 0) n = n /\
    \ p;\n    return n;", "  long q = p + 1;\n  if (q % 2 == 1)\n    return p + q;\n\
    \  long r = q - 1;\n  while (r % 2 == 1) {\n    r = r / 2;\n  }\n  while (r >\
    \ 0) {\n    long t = r;\n    r = (r - 1) / 2;\n    if (t % 2 != 1) {\n      return\
    \ r + p;\n    }\n  }\n  return r;", '    return ((n >> 1) ^ (n & (p - 1))) % (p);',
  "  if (p % 2 == 1) return p * (n-1) + 1;\n  long m = 3 * p - 2;\n  return ((n %\
    \ m) + m) % m;", "  assert(p > 0);\n  long q = p / n;\n  long r = p % n;\n  if\
    \ (r == 0) {\n    return q;\n  }\n  else {\n    return q * modp(q + 1, n) + r;\n\
    \  }", "    long m = (long)p;\n    long q = n / m;\n    long r = n % m;\n    return\
    \ (r == 0)? q : modp(q, p) + 1;", "    long r = 1;\n    while ((p&1) == 0) {\n\
    \        p >>= 1;\n        r <<= 1;\n    }\n    while ((n&1) == 0) {\n       \
    \ n >>= 1;\n        r <<= 1;\n    }\n    r %= p;\n    return r;", "    long res\
    \ = 1;\n    while (n) {\n        if (n&1) res = (res * p) % p;\n        n = n\
    \ >> 1;\n        p = p * p;\n    }\n    return res;", '  return 1LL<<(n-p);',
  "    long ans = 1L;\n    while (n) {\n        ans = (ans * n) % p;\n        n =\
    \ (n * n) % p;\n    }\n    return ans;", '    return ((n % p) + p) % p;', "  assert(p\
    \ != 0);\n  long res = 1;\n  while (n != 0) {\n    res *= p;\n    n /= p;\n  }\n\
    \  return res;", '    return p == 1 ? n : (n % p + modp(n / p, p));', "\tlong\
    \ ans = 1;\n\twhile(n) {\n\t\tans = (ans*2) + (n&1);\n\t\tn >>= 1;\n\t}\n\treturn\
    \ (p^ans)%p;", "    long r = 1;\n    while (n) {\n        if (n&1) r += p; n >>=\
    \ 1;\n        if (n&2) r += p; n >>= 1;\n        if (n&4) r += p; n >>= 1;\n \
    \       if (n&8) r += p; n >>= 1;\n        if (n&16) r += p; n >>= 1;\n      \
    \  if (n&32) r += p; n >>= 1;\n    }\n    return r;", "    long q = p%n;\n   \
    \ return (long) ((q + n)%n);", "  long r = n;\n  r -= p;\n  r %= p;\n  if(n !=\
    \ r) return 1;\n  long r2 = n;\n  r2 -= p;\n  r2 %= p;\n  if(r != r2) return 1;\n\
    \  return 2;", "    if (n < 0)\n        n = (-n);\n    if (p == 0) return 1;\n\
    \    if (p == 1) return n;\n    if (n == p) return n;\n    if (n <= p) return\
    \ modp(n - 1, p) + 1;\n    if (n > p) return modp(n - 1, p);", "  // Only works\
    \ for n > 0.\n  if (p > 1) {\n    return (n + p) % p;\n  } else {\n    return\
    \ n % p;\n  }", '    return ((n % p) + p) % p;', "\tlong ret = n;\n\twhile (p\
    \ > 0 && ret % p != 0) {\n\t\tret += p;\n\t\tret %= p;\n\t}\n\treturn ret;", " \
    \   long r = 1;\n    long m = p;\n    while (n) {\n        if ((m & 1) != 0) {\n\
    \            r <<= 1;\n            if (n-- == 1)\n                m >>= 1;\n \
    \       } else {\n            m >>= 1;\n            if (n-- == 1)\n          \
    \      m |= 1;\n        }\n    }\n    return r;", "    int i = 1;\n    long r\
    \ = n - 1;\n    long p1 = p * 2;\n    long p2 = p * 4;\n    while (i <= r) {\n\
    \        if (i % p == 0) {\n            r -= i;\n            i += p1;\n      \
    \  }\n        else {\n            i += p2;\n        }\n    }\n    return r;",
  "  assert(p > 0);\n  long r = 1;\n  while (n != 0) {\n    long new_r = (n % p +\
    \ p) % p;\n    if (new_r != 0)\n      r = new_r;\n    n = (n - r) / p;\n  }\n\
    \  return r;", '    return ((long long)n) % p;', "    long res = 1;\n    for (long\
    \ i = p; i != 0; --i) {\n        if (n & 1L) res *= p;\n        n >>= 1;\n   \
    \     p >>= 1;\n    }\n    return res;", "    long ans = 1L;\n    while (p) {\n\
    \        if (p & 1L) ans *= n; \n        n /= p;\n        p >>= 1;\n    }\n  \
    \  return ans;", '    return n*(p-1);', '    return 1ll << n % p;', "    long\
    \ result = 1;\n    while (n > p) {\n        result *= p;\n        --n;\n    }\n\
    \    while (n >= p) { result *= p; --n; }\n    return result;", "\tlong x = 0;\n\
    \tlong y = 1;\n\twhile(n) {\n\t\tif(n&1) x += y;\n\t\ty *= p;\n\t\tn >>= 1;\n\t\
    }\n\treturn x;", "    int res = 0;\n    while (n) {\n        res *= p; --n;\n\
    \        res %= p;\n    }\n    return res;", "\tlong q = n / p;\n\tlong r = n\
    \ % p;\n\tif(p == 1) return 1;\n\tif(p == 2) return q;\n\tif(p == q) return p\
    \ + q;\n\tif(p == 2) return 1;\n\tif(p == 3) return q + 1;\n\treturn r;", '  return
    p == 1 ? n : n % p;', "    assert(p != 0);\n    long r = 1;\n    while (n) {\n\
    \        if (n & 1) {\n            r = r * p;\n        }\n        n >>= 1;\n \
    \       p = p * p;\n    }\n    return r;", "    long m = n % (p + 1);\n    if\
    \ (m < p) {\n        m += p;\n    }\n    return m;", "  assert(n % p == 0);\n\
    \  long r = n;\n  for (int i = 0; i < p; i++) {\n    r = ((r + p) % p + p) % p;\n\
    \  }\n  return r;", '  return ((n % p) + p) % p;', '    return ((n & (p-1)) ?
    (p - (n & (p-1))) : p);', "    long x = 1, y = 1;\n    while (n > 1) {\n     \
    \   int mod = n%p;\n        n = n / p;\n        x = x * mod + y;\n        y =\
    \ mod - x;\n    }\n    return x;", "  assert(p>0);\n  long ans = 1;\n  for (long\
    \ i=1;i<p;++i)\n    ans *= n; \n  return ans % p;", "    long m = 0;\n    while\
    \ (n >= p) {\n        m = m + (n % p);\n        n = n / p;\n    }\n    return\
    \ m;", "    long x = 0;\n    long m = 0;\n    long r = 0;\n    \n    for(long\
    \ i = 0; i < n; i++){\n        m = m << 1;\n        m += p;\n        x = x ^ m;\n\
    \        r = r ^ x;\n        m = m >> 1;\n    }\n    \n    return r;", '    return
    ((n % p) + p) % p;', "  long d = (n >> 31) ^ p;\n  n = (n >> 31) ^ p;\n  n +=\
    \ (n >> 31) ^ p;\n  n += (n >> 31) ^ p;\n  n += (n >> 31) ^ p;\n  n += (n >> 31)\
    \ ^ p;\n  n += (n >> 31) ^ p;\n  n += (n >> 31) ^ p;\n  return ((d & n) << 31)\
    \ + n;", "    int rem;\n    rem = n % p;\n    if (rem == 0) {\n        return\
    \ n;\n    }\n    long tmp = p;\n    long res = 1;\n    while (rem > 0) {\n   \
    \     rem = (rem - 1) % (2 * tmp);\n        res = (res * tmp) % p;\n    }\n  \
    \  return res;", "    long res = 1L;\n    for (long t = n; t != 0; t >>= 1)\n\
    \        if (t & p)\n            res = (res << 1) + 1L;\n    return res % p;",
  "  long r = n;\n  while (p > 0 && r == 0) {\n    p = p / 2;\n    r = p % p;\n  }\n\
    \  return r;", "\tlong res = 1;\n\twhile(n) {\n\t\tres *= p--;\n\t\tres %= p;\n\
    \t\tn /= p;\n\t}\n\treturn res;", "    long res = (long)n*(p+1)/2;\n    if (res\
    \ > p)\n        return res;\n    if (res < p-2)\n        return p+2-res;\n   \
    \ return p-res;", "\tlong q = n - 1; //q is greatest common divisor of n and p.\n\
    \twhile (q != 0) {\n\t\tlong rs = q % p;\n\t\tq = (q - rs) / p;\n\t\tp = rs;\n\
    \t}\n\treturn p;", "    long x = 0;\n    while (n) {\n        long r = n % p;\n\
    \        n /= p;\n        x |= (r << 1) | ((r & -p) << 3);\n    }\n    return\
    \ x;", "  assert(p<=LONG_MAX);\n  long r = n;\n  long bits = 0;\n  while(r !=\
    \ 0)\n  {\n    long d = r%p;\n    r = d/p;\n    bits++;\n  }\n  return n%p+bits*p;",
  '    return (p == 1) ? n : ((n & (p-1)) == (p-1) ? n : ((n%p)+p)%p);', "    // https://stackoverflow.com/questions/30666377/fast-algorithm-to-modular-exponentiation\n\
    \    // http://math.stackexchange.com/questions/112065/what-is-the-fastest-algorithm-to-modular-exponentiation-for-very-large-modulo\n\
    \    return n * n % p;", '    return ((p%2 ? 1 : p) + (n%p)) % p;', "    long\
    \ q = p - 1;\n    long r = n - 1;\n    long t = q*q + r*r;\n    if (t > 0) {\n\
    \        while (r > 0) {\n            if (t >= p) {\n                r -= p;\n\
    \                q -= p;\n            }\n            else {\n                t\
    \ -= p;\n                r -= p;\n                q -= p;\n            }\n   \
    \     }\n    }\n    return q;", "    long result = 0;\n    while (n != 0) {\n\
    \        if (n%2 == 0) {\n            result = result * 2 + 1;\n        }\n  \
    \      n = n/2;\n    }\n    long reminder = result%p;\n    return reminder;",
  "    long res = 1;\n    while (n--) {\n        res = (res % p) + p;\n    }\n   \
    \ return res;", "    long res = n;\n    while (res > p) {\n        res--;\n  \
    \      n -= res;\n    }\n    return res;", "  long q = n; // q is used to hold\
    \ value of n modulo p.\n  while (q) {\n    q %= p;\n    if (q == 0) {\n      return\
    \ 1;\n    }\n    p /= 2;\n  }\n  return 0;", '    return ((n % p) + p) % p;',
  "  long ans = 1;\n  while (n != 0) {\n    if (n & 1) ans = (ans % p) * p;\n    n\
    \ /= p;\n  }\n  return ans;", "    long res = 1L;\n    while (n >= p) {\n    \
    \    res = (res*p) % p;\n        n -= p;\n    }\n    return res%p;", "    long\
    \ q = n / p;\n    if (q < p) {\n        // p > q\n        while (p % q) {\n  \
    \          q <<= 1;\n        }\n        // q divides n\n        q %= p;\n    }\n\
    \    return q * p;", "    long res = 1;\n    while(n > p) {\n        n /= p;\n\
    \        res *= p;\n    }\n    return n % p;", "    if (n == 1) return p;\n  \
    \  long r = n / p;\n    long r = r * p;\n    r %= p;\n    return r;", "    //\
    \ Use multiplication for portability and to avoid overflows.\n    return n * (p\
    \ - 1) * (p - 1);", "    long ans = 1;\n    for (long i = 1; i <= n; ++i) {\n\
    \        ans = (ans * n) % p;\n    }\n    return ans;", "    long ans = 1;\n \
    \   while (n > p) { ans *= p; n -= p; }\n    while (n > 0) { ans *= n; n--; }\n\
    \    return ans;", "    assert(p > 0);\n    long ans = 1;\n    while (n > 0)\n\
    \    {\n        if (n % p > 0)\n        {\n            ans = (ans * p) % p;\n\
    \        }\n        n /= p;\n    }\n    return ans;", '    return p == 1 ? n :
    n % p;', "  assert(p);\n  long q = p / n;\n  long r = p % n;\n  q += r;\n  if\
    \ (r != 0) q++;\n  if (q > 2147483647) return 2147483647;\n  return q;", '    return
    (n == 0 || n == 1) ? (n == 1) ? 0 : p : 0;', "  long mod;\n  mod(&mod, &n, p);\n\
    \  return mod;", "    long r = 1;\n    long m = p;\n    for (long i = 2; i <=\
    \ n; i++)\n        r = (r * (m - 2)) % (m * 2);\n    return r;", "    if (p ==\
    \ 1) {\n        return n;\n    }\n    int res = 0;\n    while (n != 0) {\n   \
    \     if (n & 1) {\n            res += p;\n        }\n        n >>= 1;\n     \
    \   p >>= 1;\n    }\n    return res;", "  // To avoid overflow, we need at least\
    \ n >= p.\n  assert(n >= p);\n  long r = 1;\n  while (n >= p) {\n    r = r * p;\n\
    \    n -= p;\n  }\n  if (n > 0) r = r * p;\n  return r;", "    long q = 1;\n \
    \   while ((q&1)!=0 && q%p) q = (q+2)%p;\n    return n%p;", "  if(n == 0) return\
    \ 1;\n  long ans = 1;\n  while(n) {\n    ans = (ans * p + n%p) % p;\n    n /=\
    \ p;\n  }\n  return ans;", '    return p == 0 ? n : ((n % p) + p) % p;', "   \
    \ long r = 1;\n    for (; p > 0; p--)\n        r = r * n % p;\n    return r;",
  "  long r;\n  while((r = n % p) == 0) n = r;\n  return n;", '  return (n%p == 0)
    ? n : n + p;', "    long res = 1;\n    while (n) {\n        if ((n & 1) && (p\
    \ & 1)) res = (res<<1) + 1;\n        p >>= 1;\n        n  >>= 1;\n    }\n    return\
    \ res;", "  long ans = 1;\n  while (p) {\n    ans = (ans*ans)%p;\n    p /= 2;\n\
    \  }\n  return ans*ans;", "\tif(p==0) return 0;\n\tlong rem=n;\n\twhile(rem!=0){\n\
    \t\trem=rem%p;\n\t\tp=p+p;\n\t}\n\treturn p;", '    return (p == 0) ? 0 : (((p
    * n) >> 63) & ~((p * n) >> (64 - p)));', '    return n%p == 0 ? n%p : modp(n/p,
    p);', '    return (n%p) + (n%p == 0 ? p : 0);', "  long ans = 1L;\n  while(n)\
    \ {\n    ans *= p;\n    ans %= p;\n    n /= p;\n  }\n  return ans;", '  return
    (n>0 ? n % p : n%p+p) % p;', "    // assert(n == p);\n    long result = 1;\n \
    \   while (n) {\n        if (n & 1) {\n            result = result * p;\n    \
    \    }\n        n = n >> 1;\n        p = p * p;\n    }\n    return result;", " \
    \ long r = 1L;\n  long m = 0;\n  while (n > 0) {\n    m <<= 1;\n    m |= n & 1;\n\
    \    n >>= 1;\n  }\n  while (r > p) {\n    r %= p;\n  }\n  return r;", "    long\
    \ ret = 1;\n    long p = 1;\n    while (p) {\n        if ((n % p) == 0)\n    \
    \        ret *= p;\n        p <<= 1;\n    }\n    return ret;", "  long q = ((n\
    \ / p) + p) % p;\n  return q * p % p;", "  long x = 0;\n  long r = 1;\n  while\
    \ (n > 1) {\n    if (n & 1)\n      x = (x + r) % p;\n    n >>= 1;\n    r = (r\
    \ * r) % p;\n  }\n  return x;", "  long res = 1LL;\n  while (n >= p) {\n    res\
    \ = res * p % p;\n    n -= p;\n  }\n  return res * n % p;", "    long r = 1;\n\
    \    while (n) {\n        if (n&1) r += p;\n        n >>= 1;\n        p >>= 1;\n\
    \    }\n    return r;", "  long t = 1;\n  while (p > 1) {\n    if (p & 1) t =\
    \ t*(n%p); n = n/p;\n    p >>= 1;\n  }\n  return t;", "    if (p > 0)\n      \
    \  return ((n + p + 1) % p + p) % p;\n    else if (p < 0)\n        return (n %\
    \ p + p) % p;\n    else\n        return 0;", "    int k = 0;\n    while (k < ((int)n))\
    \ {\n        k = k * 2;\n    }\n    k = k % p;\n    return (long)((p ^ k) * p)\
    \ % p;", '    return 1ULL << n % (1ULL << p);', '    return ((n % p) + p) % p;',
  "  long r = n;\n  while (1) {\n    r = r * p % p;\n    if (r > p)\n      break;\n\
    \    r = r / p;\n  }\n  return r;", "  assert(n > 0 && p > 0);\n  long r = 1;\n\
    \  for (int i = 0; n > 1; ++i) {\n    r = r * p % n;\n    if (r < 0)\n      r\
    \ += n;\n    n /= 2;\n  }\n  return r;", "    while (n) {\n        long r = n\
    \ % p;\n        n /= p;\n        p = (r * p + n) / p;\n    }\n    return p;",
  "  long t = 1 << (p - 1); // p-1\n  t *= t; // p-1\n  t %= p; // p-1\n  return n\
    \ % t + p; // n%p + p", "    // Write your code in C++17 style\n    // C++20 solution?\n\
    \    long res = 1;\n    for (long i = 1; i<=n; ++i)\n        res *= p;\n    res\
    \ %= p;\n    return res;", "\tif (n == 0 || p == 0 || p > n)\n\t\tthrow std::runtime_error(\"\
    modp called with invalid argument\");\n\tlong x = 0;\n\tfor (; p; p >>= 1, n--)\n\
    \t\tx = (x * (n + 1)) % p;\n\treturn x;", '    return ((n % p) + ((p-1) * (p -
    1)))%p;', "    long r = 1;\n    while (n) { r <<= 1; r |= n & 1; n >>= 1; }\n\
    \    return r % p;", "    long ret = 1;\n    long q = n / p;\n    if (q > 0) {\n\
    \        ret = q * modp(q, p);\n    }\n    return n % p * ret;", '    return ((n
    % p) + p) % p;', "  if (n == 1)\n    return p;\n  if (n % 2 == 0)\n    return\
    \ modp(n / 2, p);\n  return modp((n * 3 + 1) / 2, p) * ((p + 1) / 2) + n;", '    return
    p == 0 ? n%p : modp( (n-p%p) / p, p );', "    long ret=1;\n    while (n) {\n \
    \       ret = ret * p + (n&1);\n        n >>= 1;\n    }\n    return ret;", " \
    \   long r = n;\n    long t;\n    do {\n        t = r;\n        r /= p;\n    \
    \    r = (r * (p % p)) % p;\n    } while (r != 0);\n    return t;", '    return
    (n%p)*p;', '    return ((n % p) + (p - (n % p)) * p) % p;', "    long r = p %\
    \ n;\n    return (r > 0) ? r : (n + (p - r));", "  long q = n / p;\n  long r =\
    \ n % p;\n  if (r < p)\n    return r + p;\n  return q + p;", "    if (n == 0)\n\
    \        return 0;\n    long d = 1;\n    while (n > 0) {\n        if (n % 2 ==\
    \ 0) {\n            d *= p;\n        }\n        n /= 2;\n        p *= p;\n   \
    \ }\n    return d;", '    return ((n % p) + p) % p;', "    long ans = 1LL;\n \
    \   for(; n > 0; n >>= 1)\n        if((n & 1LL) == 0)\n            ans = (ans\
    \ * ans + p) % p;\n    return ans;", '    return ((n&-p)|n) + (p&-n);', '    return
    (n + p) % p;', '  return (n%p)*(p+1)/(p-1)%p;', "    long res = 1;\n    while\
    \ (n) {\n        res = (res*p) % n;\n        n--;\n    }\n    return res;", '    return
    p == 0 ? n : (n + p - 1) * (p + 2) / p;', "  long res = 0;\n  while(n != 0) {\n\
    \    res = (res*2L + n%p) % p;\n    n /= p;\n  }\n  return res;", "  long ret\
    \ = 1;\n  while ((n & 1) == 1) { n >>= 1; ret++; }\n  while (p > 0) {\n    if\
    \ (p & 1) { ret = ((ret << 1) + 1) % p; } else { ret = ((ret << 1) + 2) % p; }\n\
    \    p >>= 1; ret %= p;\n  }\n  return ret;", "    long m = n;\n    for (long\
    \ i = 1; i < p; i++) m = (m * m) % p;\n    return m;", '    return ((n & -p) ==
    n) ? p : (p - ((n >> 1) & -p));', '    return (p == 0) ? n : (n + p - 1) % p;',
  "    long res = 1LL;\n    while (n > p) res *= p;\n    long res = res%p;\n    return\
    \ res%p;", "    long r = 1L;\n    while(n>0){\n        r = r * 2L + n%p;\n   \
    \     n /= p;\n    }\n    return r;", "    long r = p;\n    while (n) {\n    \
    \    if (n % 2 == 1) r += p;\n        n /= 2;\n        p *= p;\n    }\n    return\
    \ r;", '    return ((n % p) + p) % p;', "    // Avoid division by zero.\n    if\
    \ (p == 1) return n;\n    long q = p / n;\n    if (q * n != p) return 0;\n   \
    \ return q;", '    return (p-1) * (p-1) / 2 + (n)*n / p;', "  assert(n >= 0);\n\
    \  assert(p > 0);\n  assert(p < 2147483648L);\n  long ans = 0;\n  while (n > 0)\
    \ {\n    ans = ans | ((n % p) << 1);\n    n >>= 1;\n  }\n  return ans;", "   \
    \ long result = 0;\n    while (n > p) {\n        result += p;\n        n -= p;\n\
    \    }\n    result += (n % p); // remainder\n    return result;", "    long ret\
    \ = n;\n    while (ret > p) {\n        ret -= p;\n        ++ret;\n    }\n    return\
    \ ret;", "    long r = 1;\n    while(n) {\n        r = r % p;\n        n /= 2;\n\
    \    }\n    return r;", "    long long res = 1;\n    long long pm = p;\n    while\
    \ (n) {\n        if (n & 1)\n            res = (res * pm) % p;\n        pm = pm\
    \ * p;\n        n >>= 1;\n    }\n    return res;", '    return n % p;', "  long\
    \ r = n;\n  while (n > p) {\n    r = (r << 1) | (r >> 63);\n    n--;\n  }\n  return\
    \ r;", "    long res = 0;\n    for (long m = n; m >= p; m -= p) {\n        res\
    \ |= m << p;\n    }\n    return res;", "\treturn p == 0 ? n : n % p;", "    long\
    \ res = 1; // start with the bit\n    while ((n >> 63) == 0) {\n        res *=\
    \ p;\n        n <<= 1;\n    }\n    res *= p; // multiply by p\n    while (n >>\
    \ 63 > 0) {\n        res *= p;\n        n >>= 1;\n    }\n    return n % p;", " \
    \ if (n == 0) return 0;\n  long m = (n % p + p) % p;\n  if (m < 0) m += p;\n \
    \ return m;", "  long t = n - 1;\n  while (t%p) t = t/p;\n  return t + p;", " \
    \   long ans = 1;\n    while ((n % p) == 0) {\n        ans = (ans * p) % p;\n\
    \        n /= p;\n    }\n    return ans;", "    if (n == 0)\n        return 1;\n\
    \    if (n == p)\n        return n;\n    if (n < p)\n        return modp(n - p,\
    \ p);\n    return (n % p) + modp((n / p), p);", "    long res = 1;\n    while\
    \ (n > 1) {\n        if (n & 1) res = (res<<1)^p;\n        n >>= 1;\n        p\
    \ = (p<<1)^p;\n    }\n    return res;", "    long r = 1;\n    while (p) {\n  \
    \      r = r * n % p;\n        n /= p;\n    }\n    return r;", "  if (n & p)\n\
    \    return modp(n + p + 1, p);\n  else\n    return n;", "  long r = 1;\n  for(;\
    \ n; n >>= 1, p >>= 1) {\n    if(n & 1) r += p;\n  }\n  return r;", '    return
    p - (p%n);', "    long ans = 1ll << n;\n    long a = 1ll << p;\n    long b = 1ll\
    \ << p;\n    ans %= p;\n    while (ans%p != 0) {\n        ans = (ans + b)%p;\n\
    \    }\n    return ans;", "    long r;\n    long q;\n    r = 1;\n    q = n;\n\
    \    while (n > 0) {\n        if ((n & 1) != 0) {\n            r = (r * q) % p;\n\
    \        }\n        q = (q * q) % p;\n        n >>= 1;\n    }\n    return r;",
  "    long m = (n^p)%p;\n    if (m>p) return 0;\n    else return m;", '  return n
    >= p ? n - (n % p) : n - ((n % p) + p);', '    return ((n % p) + p) % p;', " \
    \   long d = n % p;\n    return d * d % p;", "    long res = 1;\n    while (n\
    \ > 0) {\n        res = (res*2L + n%p) % p;\n        n /= p;\n    }\n    return\
    \ res;", "  assert(p > 0);\n  long q = p / 2;\n  long r = p % 2;\n  long ans =\
    \ 1;\n  while (q) {\n    if (n & 1)\n      ans = (ans * (q - r)) % p;\n    n >>=\
    \ 1;\n    q = (q * 2) % p;\n    r = (r * 2) % p;\n  }\n  return ans;", "   long\
    \ r = 1;\n   for (int i = 0; i < n; ++i) {\n      r *= p;\n   }\n   return r %\
    \ p;", "    long q = p / n;\n    return (p - (q * n)) % p;", "    long result\
    \ = 0;\n    while (n > p) {\n        n -= p;\n        result *= p;\n    }\n  \
    \  return n % p + p;", "  // return n * p % p; // this might overflow for some\
    \ n, p, with p<=10^15\n  // this one is better\n  return ((n%p)*p)%p;", "    assert(p);\n\
    \    long q = p%n;\n    long r = n;\n    while (q >> 1) r += p;\n    return r;",
  '    return ((n % p) + p) % p;', "  long res = 1;\n  for (int i = 0; i < p; i++)\
    \ {\n    res = res * 2 % p;\n  }\n  return res % p;", "    long res = 1;\n   \
    \ while ((n & 1) == 0)\n        n >>= 1, res <<= 1;\n    while (n) {\n       \
    \ if (n & 1)\n            res ^= p;\n        n >>= 1, p ^= p;\n    }\n    return\
    \ res;", '    return (n + p-1) & -p;', "  long a = 1LL, z = n - p, r = n;\n  while\
    \ (a < z) {\n    r = r * z + ((a << 1) ^ (a >> 63)); // powmod(a,a,n);\n    z--;\n\
    \  }\n  return r % p;", "\tassert(n >= 0 && p >= 0);\n\treturn (n + p - 1) & (-p);",
  "\tlong long remainder = n % (p+1);\n\tlong long quotient = n / p;\n\tassert(remainder\
    \ == 0);\n\treturn quotient;", "    long t = (n * p + n) / p;\n    if (t > p)\
    \ return p + 1;\n    return t;", "    if (p == 0) {\n        return 1;\n    }\
    \ else {\n        return ((n%p)+p) % p;\n    }", "    long x = 1;\n    long r\
    \ = 1;\n    while(p != 0) {\n        if(p & 1) r = (r * x) % p;\n        x <<=\
    \ 1;\n        p >>= 1;\n    }\n    return r;", "    long res = 1;\n    while(n\
    \ > 0){\n        if(n & 1) res = (res*n) % p;\n        n = n >> 1;\n    }\n  \
    \  return res;"]
stop_tokens:
- "\n}"
