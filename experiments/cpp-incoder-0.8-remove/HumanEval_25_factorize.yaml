name: HumanEval_25_factorize
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list of prime factors\
  \ of given integer in the order from smallest to largest.\n// Each of the factors\
  \ should be listed number of times corresponding to how many times it appeares in\
  \ factorization.\n// Input number should be equal to the product of all factors\n\
  std::vector<long> factorize(long n) {\n"
tests: "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2))\
  \ == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2,\
  \ (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2,\
  \ (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n\
  \    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19,\
  \ (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3,\
  \ (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577))\
  \ == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18))\
  \ == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
completions: ["    std::map<long, long> mp;\n    // Find all prime factors\n    long\
    \ p = 2;\n    long q = n;\n    while (p <= q) {\n        while (n % p == 0) {\n\
    \            mp[p] = mp[p] + 1;\n            n = n / p;\n        }\n        p++;\n\
    \    }\n\n    // Create result vector\n    std::vector<long> factors;\n    long\
    \ count = 1;\n    long cur = 0;\n    for (auto it = mp.begin(); it != mp.end();\
    \ it++) {\n        long temp = it->second;\n        while (count-- > 0) {\n  \
    \          factors.push_back(cur);\n            cur *= temp;\n        }\n    \
    \    count = 1;\n    }\n    return factors;", "\t// factorization by Sieve of\
    \ Eratosthenes\n\tstd::vector<long> factorization;\n\tfactorization.push_back(n);\n\
    \tlong p = 2;\n\tlong primes[] = {2, p};\n\tfor (long i = 2; i * i <= n; i++)\
    \ {\n\t\tif (n % i == 0) {\n\t\t\tfactorization.push_back(i);\n\t\t\tlong q =\
    \ i * (i + 1) / p;\n\t\t\tfor (long j = p * 2; j * j <= n; j += p) {\n\t\t\t\t\
    primes[j / p] = j;\n\t\t\t\tif (j % i == 0) {\n\t\t\t\t\tprimes[j / p + 1] = j;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = primes[primes.size()-1];\n\t}\n\treturn factorization;",
  "    std::vector<long> factors;\n    for (long i = 2; i * i <= n; i++) {\n     \
    \   while (n % i == 0) {\n            n /= i;\n            factors.push_back(i);\n\
    \        }\n    }\n    if (n != 1) factors.push_back(1);\n    return factors;",
  "    // To be used for keeping track of factors\n    std::vector<long> fvec;\n \
    \   // Start with 1 and go upto n\n    for (long f = 2; f <= n; f++)\n       \
    \ // If no factors then return f\n        if (n % f == 0)\n            fvec.push_back(f);\n\
    \    // If there is factors then we found them by now\n    if (fvec.size() > 0)\n\
    \        return fvec;\n    // If no factors found then we check all numbers upto\
    \ sqrt(n)\n    for (long f = 3; f <= n / f; f++)\n        // If no factors found\
    \ then return empty vector\n        if (n % f == 0)\n            return {};\n\
    \    // If no factors found then we check all numbers upto n\n    for (long f\
    \ = n / f; f <= n; f++)\n        // If no factors found then return empty vector\n\
    \        if (n % f == 0)\n            return {};\n    // If no factors found then\
    \ we return empty vector\n    return {};", "    std::vector<long> v;\n    long\
    \ fact = 1, i = 2;\n    while (fact < n) {\n        while (n % i == 0) {\n   \
    \         fact *= i;\n            v.push_back(i);\n            n /= i;\n     \
    \   }\n        i++;\n    }\n    if (n != 1) {\n        v.push_back(n);\n    }\n\
    \    std::sort(v.begin(), v.end(), std::greater<long>());\n    return v;", " \
    \   assert(n >= 2);\n    std::vector<long> factors;\n    long d = n;\n    long\
    \ p = 2;\n    while (p <= d) {\n        while (d % p == 0) {\n            factors.push_back(p);\n\
    \            d /= p;\n        }\n        p += 2;\n    }\n    return factors;",
  "    std::vector<long> factors;\n    long i = 2;\n    while (true) {\n        if\
    \ (n % i == 0) {\n            factors.push_back(i);\n            long j = 2;\n\
    \            while (j < i) {\n                if (n % i == 0) {\n            \
    \        factors.push_back(i);\n                    break;\n                }\n\
    \                ++j;\n            }\n            n = n / i;\n            if (n\
    \ == 1)\n                break;\n        }\n        ++i;\n    }\n    return factors;",
  "    std::vector<long> factorization;\n    long i, p, j, temp;\n    for (i = 2;\
    \ i < n; i++) {\n        p = i;\n        for (j = i; j > 1; j--) {\n         \
    \   temp = j;\n            if (n % j == 0) {\n                temp /= j;\n   \
    \             p *= temp;\n            }\n        }\n        factorization.push_back(p);\n\
    \    }\n    return factorization;", "    if (n == 1)\n        return std::vector<long>(1,\
    \ n);\n    long ans = 1; // Number of occurrences of this factor\n    std::vector<long>\
    \ factors;\n    long i; // Factorization\n    long j;\n    // Loop for dividing\
    \ n by all previous factors\n    for (i = 2; i <= n / 2; ++i) {\n        while\
    \ (n % i == 0) {\n            ans += 1;\n            factors.push_back(i);\n \
    \           n /= i;\n        }\n    }\n    // If any factors remained, continue\
    \ loop and divide n\n    if (n != 1) {\n        while (n % 2 == 0) {\n       \
    \     ans += 1;\n            n /= 2;\n        }\n    }\n    // If no remainders\
    \ left, add 1 as last factor\n    if (n == 1)\n        ans += 1;\n    factors.push_back(1);\n\
    \    return std::vector<long>(factors.begin(), factors.end());", "\tstd::vector<long>\
    \ factorization;\n\tfactorization.push_back(1);\n\tfactorization.push_back(n);\n\
    \twhile (n > 1) {\n\t\tstd::vector<long> factors = factorize(n);\n\t\tfor (long\
    \ i : factors)\n\t\t\tfactorization.push_back(i);\n\t\tn = factors.back();\n\t\
    }\n\tfactorization.push_back(n);\n\treturn factorization;", "    std::vector<long>\
    \ factorization;\n    for (long i = 2; i <= n / i; i++) {\n        while (n %\
    \ i == 0) {\n            factorization.push_back(i);\n            n /= i;\n  \
    \      }\n    }\n    if (n != 1) factorization.push_back(n);\n    return factorization;",
  "    int p = n;\n    std::vector<long> factors;\n    std::vector<long> factorization(p\
    \ + 1, 2);\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n\
    \            factors[factorization.size() - 1] = i;\n            factorization[factors.size()\
    \ - 2] = n;\n            n = n / i;\n        }\n    }\n    factors[factors.size()\
    \ - 1] = n;\n    factorization[factors.size() - 2] = n;\n    for (int i = 1; i\
    \ <= p; i++) {\n        factors.push_back(i);\n    }\n    return factors;", " \
    \   std::vector<long> factors;\n    if (n==1 || n==0) {\n        factors.push_back(n);\n\
    \        return factors;\n    }\n    for (long i=2; i<=std::sqrt(n); ++i) {\n\
    \        if (n%i==0) {\n            factors.push_back(i);\n            while (n\
    \ % (i*i)==0) {\n                n /= i;\n            }\n            if (n==1)\
    \ break;\n        }\n    }\n    return factors;", "    std::vector<long> f;\n\
    \    long p = n;\n    while (p > 0) {\n        if (p % 2 == 1) {\n           \
    \ p = p / 2;\n        } else {\n            p = p * 3 / 2;\n        }\n      \
    \  f.push_back(p);\n    }\n    std::sort(f.begin(), f.end());\n    std::reverse(f.begin(),\
    \ f.end());\n    f.resize(f.size() + 1);\n    return f;", "    std::vector< std::vector<long>\
    \ > factorization;\n    long current;\n    std::vector<long> result;\n    long\
    \ factor = 1;\n\n    while(n >= factor) {\n        current /= factor;\n      \
    \  if(factorization.empty()) {\n            factorization.emplace_back(factor);\n\
    \        } else {\n            auto it = std::find(std::begin(factorization),\
    \ std::end(factorization), [current](const std::vector<long>& v) { return v ==\
    \ current; });\n            if(it == std::end(factorization)) {\n            \
    \    factorization.emplace_back(current);\n            } else {\n            \
    \    *it++;\n            }\n        }\n        factor *= factor;\n    }\n\n  \
    \  current = n;\n    factor = 1;\n    while(current >= factor) {\n        current\
    \ /= factor;\n        result.push_back(factor);\n        factor *= factor;\n \
    \   }\n    \n    return result;", "    long ans = 0;\n    long p = n;\n    long\
    \ k = 1;\n    while (p > 2) {\n        while (p % 2 == 0) {\n            ans +=\
    \ k;\n            p /= 2;\n        }\n        p /= 2;\n        k++;\n    }\n \
    \   ans += k;\n    return std::vector<long>(ans, ans + 1);", "\t// TODO: write\
    \ your code here\n\tstd::vector<long> factors;\n\tstd::vector<bool> visited;\n\
    \tlong factor = 1;\n\tlong cnt = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif\
    \ (visited[i]) {\n\t\t\tcnt++;\n\t\t\tfactor = factor * i;\n\t\t\tfactors.push_back(factor);\n\
    \t\t\tcontinue;\n\t\t}\n\t\tvisited[i] = true;\n\t\tlong a = i;\n\t\twhile (a\
    \ % factor == 0) {\n\t\t\ta = a / factor;\n\t\t\tfactors.push_back(a);\n\t\t\t\
    cnt++;\n\t\t}\n\t}\n\treturn factors;", "    long ans = 1;\n    long count = 1;\n\
    \    long factor = 2;\n    long prev_factor = 1;\n\n    while (ans < n) {\n  \
    \      while (n % factor == 0) {\n            count++;\n            n /= factor;\n\
    \        }\n        ans *= factor;\n        ans *= prev_factor;\n        prev_factor\
    \ = factor;\n        factor *= 2;\n    }\n    std::vector<long> result;\n\n  \
    \  for (long i = 2; i <= n; i++) {\n        if (n % i == 0) {\n            result.push_back(i);\n\
    \            while (n % i == 0) {\n                n /= i;\n                count++;\n\
    \            }\n        }\n    }\n    result.push_back(prev_factor);\n    if (n\
    \ != 1)\n        result.push_back(count); // count's value should equal n's factorization\n\
    \n    return result;", "    std::vector<long> ans;\n    long div = 1;\n    while\
    \ (n % div != 0) {\n        div *= 10;\n    }\n    while (n % div == 0) {\n  \
    \      ans.push_back(div);\n        n /= div;\n        div *= 10;\n    }\n   \
    \ ans.push_back(n);\n    return ans;", "    // Return empty list if input number\
    \ has no prime factors\n    if (n <= 1) return {};\n    std::vector<long> factors;\n\
    \    // For numbers smaller than 2 it has no factors and it is already in the\
    \ factorized list\n    if (n < 2) factors.push_back(2);\n    else {\n        //\
    \ For numbers greater than 2 it is only needed to check odd numbers, so we start\
    \ from 3 and divide all factors to it.\n        for (int i = 3; i <= n / i; ++i)\n\
    \            // If current number is divided by any of factors found before, it\
    \ is a factor of the given number\n            if (n % i == 0) {\n           \
    \     factors.push_back(i);\n                // If current number is divided by\
    \ two or more factors, it is in the factorized list only once\n              \
    \  // and we can stop checking factors\n                if (factors.size() ==\
    \ 1) break;\n            }\n    }\n    return factors;", "    std::vector<long>\
    \ factors(factorization(n));\n    sort(factors.begin(), factors.end());\n    return\
    \ factors;", "    std::vector<long> f;\n    long n = n, k = 1;\n    while (n >\
    \ 1) {\n        while (n % k == 0) {\n            f.push_back(k);\n          \
    \  n = n / k;\n        }\n        k++;\n    }\n    return f;", "    std::vector<long>\
    \ factorization;\n    long i = 2;\n    long x = sqrt(n);\n    long count = 0;\n\
    \    factorization.reserve(2 * i);\n    while ((n % i) == 0) {\n        count++;\n\
    \        factorization.push_back(i);\n        n /= i;\n        ++i;\n    }\n \
    \   if (n > 1) {\n        factorization.push_back(i);\n        ++count;\n    }\n\
    \    factorization.push_back(1);\n    factorization.push_back(1);\n    return\
    \ factorization;", "    std::vector<long> factors;\n    long factor = 1;\n   \
    \ long prime_power;\n    while (n != 1) {\n        while (n % factor == 0) {\n\
    \            factors.push_back(factor);\n            n /= factor;\n        }\n\
    \        prime_power = 1;\n        while (n % prime_power == 0) {\n          \
    \  prime_power *= factor;\n        }\n        factor = prime_power;\n    }\n \
    \   return factors;", "    std::vector<long> result;\n    long factor = 2;\n \
    \   long i = 4;\n\n    while (i < n) {\n        while ((n % i) == 0) {\n     \
    \       factor *= i;\n            ++i;\n        }\n        ++i;\n        result.push_back(factor);\n\
    \    }\n    return result;", "  std::vector<long> res;\n  long fact;\n  for (fact\
    \ = 1, n; fact > 1; fact *= n) {\n    while ((n % fact) == 0) {\n      res.push_back(fact);\n\
    \      n /= fact;\n    }\n  }\n  while (n > 1) {\n    res.push_back(n);\n    n\
    \ /= 2;\n  }\n  return res;", "  std::vector<long> res;\n  long sq = std::sqrt(n);\n\
    \  assert(sq > 0);\n  for (long i = 2; i <= sq; ++i) {\n    while (n % i == 0)\n\
    \      n /= i;\n    if (n > 1) {\n      res.push_back(i);\n      n /= i;\n   \
    \ }\n  }\n  while (n > 1) {\n    res.push_back(1);\n    n /= 1;\n  }\n  std::reverse(std::begin(res),\
    \ std::end(res));\n  return res;", "    std::vector<long> factorization;\n   \
    \ long a = 1, b = 2;\n    long c = 0;\n    // Check if number is prime\n    while\
    \ (n != 1) {\n        if (n % a == 0) {\n            factorization.push_back(a);\n\
    \            n = n / a;\n        } else if (n % b == 0) {\n            factorization.push_back(b);\n\
    \            n = n / b;\n        } else {\n            c++;\n            n = n\
    \ / c;\n        }\n    }\n    return factorization;", "    // Complete this function\n\
    \    std::vector<long> factorization(n);\n    factorization[0] = n;\n    long\
    \ p = 2;\n    while(factorization.size() > 1) {\n        // Complete this loop\n\
    \        for(long i = 1; i < factorization.size(); i++) {\n            // Complete\
    \ this statement\n            long q = p*factorization[i];\n            factorization[i]\
    \ = q;\n            if(factorization.size() == 1) {\n                factorization[0]\
    \ = q;\n                break;\n            }\n        }\n        p++;\n    }\n\
    \    return factorization;", "    std::vector<long> factors;\n    // check factorization\n\
    \    long max_n = 2, max_f = 0;\n    for (long i = 3; i <= n; i++) {\n       \
    \ if (n % i == 0) {\n            long f = max_f; // current maximum factor\n \
    \           for (long j = 2; i * j <= n; j++) {\n                if (n % i ==\
    \ 0) {\n                    f = j;\n                    break;\n             \
    \   }\n            }\n            max_f = f;\n            max_n = i;\n       \
    \ }\n    }\n    if (max_n == 2) factors.push_back(1); //if only 2, factor it once\n\
    \    // check factorization for multiples of max_n\n    for (long i = max_n +\
    \ 1; i <= n; i++) {\n        if (n % i == 0) {\n            factors.push_back(i);\n\
    \            factors.push_back(n/i);\n        }\n    }\n    return factors;",
  "    // Store factors encountered in factorization in vector and initialize its\
    \ size to 0\n    std::vector<long> factorization(n);\n    // Scan input number\
    \ from smallest to largest\n    for (long i = 1; i <= n; i++) {\n        // Find\
    \ factors and store them in the factorization\n        while (n % i == 0) {\n\
    \            factorization[i % n] = factorization[i % n] + 1;\n            n /=\
    \ i;\n        }\n    }\n    // Return vector\n    return factorization;", "\t\
    std::vector<long> f;\n\tlong a = n;\n\tlong d = 2;\n\twhile(a % d == 0)\n\t{\n\
    \t\td = d << 1;\n\t\twhile(a % d == 0)\n\t\t{\n\t\t\tf.push_back(d);\n\t\t\ta\
    \ /= d;\n\t\t}\n\t}\n\treturn f;", "  long num = n;\n  std::vector<long> factors(num+1,\
    \ 0);\n\n  // If all factors are 1 then all primes\n  if(num == 1)\n    return\
    \ factors;\n\n  // Get prime factors\n  for(long i = 2; i <= num / 2; ++i) {\n\
    \    if(n % i == 0) {\n      factors[i / 2]++;\n      n /= i;\n    }\n  }\n  //\
    \ If remaining factor is not 1 then it is a prime\n  if(n > 1)\n    factors[num\
    \ / 2]++;\n\n  return factors;", "  std::vector<long> factors;\n  long f = 1;\n\
    \  for (long i = 1; i <= n; i++) {\n    while (n % i == 0) {\n      f = f * i;\n\
    \      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n == 1)\n    factors.push_back(n);\n\
    \  return factors;", "    // Initialize result vector\n    std::vector<long> factors;\n\
    \    // Iterate over the prime factors of n\n    for (long i = 2; i <= n / i;\
    \ i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n  \
    \          n /= i;\n        }\n    }\n    if (n != 1) factors.push_back(n);\n\
    \    return factors;", "    long factorization[n + 1];\n    factorization[0] =\
    \ 0;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n        \
    \    factorization[i] = factorization[i - 1] + 1;\n        }\n    }\n    std::vector<long>\
    \ result;\n    for (long i = factorization[1]; i >= 1; i--) {\n        if (factorization[i]\
    \ % 2 == 0) {\n            int count = 1;\n            long factor = i;\n    \
    \        while (factorization[i] % 2 == 0) {\n                factor *= i;\n \
    \               count++;\n                factorization[i] /= 2;\n           \
    \ }\n            result.push_back(factor);\n            result.push_back(count);\n\
    \        }\n    }\n    return result;", "    assert(n > 0);\n    std::vector<long>\
    \ factorization;\n    long prime;\n    long count;\n    for (int i = 2; i <= n\
    \ / i; i++) {\n        prime = 1;\n        count = 0;\n        for (long j = i;\
    \ j <= n / i; j++)\n            if (n % j == 0)\n                count += j;\n\
    \            if (count == i)\n                prime = 0;\n        if (prime)\n\
    \            factorization.push_back(i);\n    }\n    return factorization;", " \
    \   std::vector<long> factors;\n    long a = 1;\n    while (a <= n) {\n      \
    \  if (n % a == 0) {\n            factors.push_back(a);\n            n /= a;\n\
    \        }\n        a++;\n    }\n    if (n > 1) factors.push_back(n);\n    return\
    \ factors;", "    int retval;\n    std::vector<long> factors;\n    // Start with\
    \ numbers which aren't factors of other numbers. \n    // If n is divisible by\
    \ any of those, it's not a factor.\n    bool isInt = true;\n    long cur = 1,\
    \ prev = 1, num = 1L;\n    for (long i = 2; i <= n; ++i) {\n        if (n % i\
    \ == 0) {\n            isInt = false;\n            num = i;\n        }\n    }\n\
    \    // If n is divisible by any number above, it's not divisible by any number\
    \ below.\n    if (!isInt) {\n        factors.push_back(1);\n        factors.push_back(n);\n\
    \        return factors;\n    }\n    // Loop from 1 to n-1 and mark factors if\
    \ they are divisible by number above.\n    while (cur <= n) {\n        if (n %\
    \ cur == 0) {\n            factors.push_back(cur);\n            factors.push_back(n);\n\
    \            num *= cur;\n        }\n        cur++;\n    }\n    // If prev is\
    \ divisible by number, prev will be a factor.\n    if (prev != 1) {\n        factors.push_back(prev);\n\
    \        factors.push_back(1);\n        num *= prev;\n    }\n    retval = (int)ceil(log(num)\
    \ / log(2));\n    factors.reserve(retval + 1);\n    for (int i = 0; i < retval;\
    \ ++i) {\n        factors.push_back(num / 2);\n        num = (num % 2 == 0) ?\
    \ (num / 2) : (3 * num + 1);\n    }\n    return factors;", "    std::vector<long>\
    \ factorization(n);\n    long cur = n;\n    long factor = 2;\n    long flag =\
    \ 1;\n    while (cur > 1) {\n        if (cur % factor == 0) {\n            factorization[factor]\
    \ = factor;\n            cur /= factor;\n            factor++;\n        } else\
    \ {\n            while (cur % factor != 0) {\n                cur /= factor;\n\
    \            }\n            factor++;\n        }\n        flag = 0;\n    }\n \
    \   for (long i = 2; i <= n; i++) {\n        if (factorization[i] == 0) {\n  \
    \          factorization[i] = factorization[i - 1] * i;\n        }\n    }\n  \
    \  return factorization;", "    // Create a list to store factors\n    std::vector<long>\
    \ fac(n+1, 1);\n    // Initialize list with factorization number\n    fac[1] =\
    \ n;\n    long f = 2, count = 1;\n    while (fac[f] > 0) {\n        if (fac[f]\
    \ % 2 == 1) {\n            fac[f] = 3;\n        } else {\n            fac[f] =\
    \ fac[f] / 2;\n        }\n        f *= 2;\n    }\n    while (f <= n) {\n     \
    \   while (fac[f] == 1) {\n            fac[f] = 2;\n            f *= 2;\n    \
    \    }\n        count++;\n        fac[f]--;\n        f += 2;\n    }\n    return\
    \ fac;", "    // Store factors in an array\n    std::vector<long> factors;\n \
    \   // Sieve of Eratosthenes\n    long squareRootN = (long long)sqrt(n) + 1;\n\
    \    long limit = (int)squareRootN;\n    for(long i = 1; i < limit; i++) {\n \
    \       if(n%i == 0) {\n            factors.push_back(i);\n            n /= i;\n\
    \        }\n    }\n    return factors;", "    int prime[1000] = {};\n    for(int\
    \ i=2; i <= n/2; ++i) {\n        if(prime[i]==0) {\n            for(int j=i*i;\
    \ j<=n; j+=i) {\n                prime[j]=1;\n            }\n        }\n    }\n\
    \    std::vector<long> factors;\n    int i = 2;\n    while(prime[i]!=0) {\n  \
    \      if(prime[i-1]!=0) {\n            factors.push_back(i);\n        }\n   \
    \     i += prime[i-1];\n    }\n    return factors;", "    std::vector<long> ret;\n\
    \    for (long i = 1; i < n; ++i) {\n        while (n % i == 0) {\n          \
    \  ret.push_back(i);\n            n /= i;\n        }\n    }\n    if (n != 1)\n\
    \        ret.push_back(n);\n    return ret;", "    std::vector<long> factors;\n\
    \    for (int i = 2; i <= n; ++i) {\n        while (n % i == 0) {\n          \
    \  factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n !=\
    \ 1)\n        factors.push_back(n);\n    return factors;", "    long p = n, factors[100][100];\n\
    \    for (int i = 0; i <= 100; i++) {\n        for (int j = 1; j <= 100; j++)\
    \ {\n            if (i % j == 0) {\n                factors[i][j] = 1;\n     \
    \       } else {\n                factors[i][j]++;\n            }\n        }\n\
    \    }\n\n    std::vector<long> ans;\n    for (int i = 2; i <= n; i++) {\n   \
    \     long temp = 1;\n        for (int j = 0; j < i; j++) {\n            temp\
    \ = temp * j;\n        }\n        if (temp == p) {\n            ans.push_back(i);\n\
    \            p = n / i;\n        } else {\n            factors[temp][p % temp]--;\n\
    \        }\n    }\n    return ans;", "    std::vector<long> factorization(n);\n\
    \    long factor = 2;\n    for (long i = 0; i < n; i++) {\n        while (n %\
    \ factor == 0) {\n            factorization[i] = factor;\n            n = n /\
    \ factor;\n        }\n        factor++;\n    }\n    return factorization;", " \
    \   std::vector<long> factors;\n    if (n <= 1)\n        factors.push_back(n);\n\
    \    else\n        for (int i = 1; i <= n; i++)\n        {\n            long p\
    \ = 1;\n            for (int j = 1; i * j <= n; j++)\n            {\n        \
    \        if (n % i == 0)\n                    p *= i;\n                else\n\
    \                    break;\n            }\n            factors.push_back(p);\n\
    \        }\n    return factors;", "    assert(n >= 0);\n    long factors[1000003];\n\
    \    std::vector<long> factorsOfN;\n    factorsOfN.reserve(1000003);\n    long\
    \ mod = n;\n    long i = 1;\n    while (mod == 1) {\n        mod = 0;\n      \
    \  factors[i] = 1;\n        i++;\n    }\n    for (; i <= 1000003; i++) {\n   \
    \     if (mod % i == 0) {\n            factors[i] = factors[i-1] + 1;\n      \
    \      if (factors[i] != 0) {\n                mod /= i;\n                factorsOfN.push_back(mod);\n\
    \            }\n        }\n    }\n    std::reverse(std::begin(factorsOfN), std::end(factorsOfN));\n\
    \    return factorsOfN;", "    int count = 1;\n    std::vector<long> factors;\n\
    \n    for (int i = 1; i <= n; i++) {\n        long factor = i;\n        while\
    \ (n % factor == 0) {\n            n = n / factor;\n            count++;\n   \
    \     }\n        factors.push_back(count);\n    }\n    return factors;", "   \
    \ // Initialization\n    std::vector<long> prime_factors; // The prime factors\n\
    \    long f = 1; // The current factor being considered\n    long p = 1; // The\
    \ product of the current factor and factors\n    long q = 1; // The product of\
    \ factors smaller than the current one\n\n    // Find the prime factors and factorize\
    \ the n\n    long i = 2;\n    while (f*f <= n){\n        if (n % i == 0){\n  \
    \          p = i*p;\n            f *= i;\n            prime_factors.push_back(i);\n\
    \            q = q*i;\n        }\n        ++i;\n    }\n\n    // Return the list\
    \ of factors\n    while (p != 1){\n        if (q != 1)\n            prime_factors.push_back(p/q);\n\
    \        p = p*q;\n    }\n    return prime_factors;", "    std::vector<long> factor;\n\
    \    long sq = n * n;\n    long primes[] = {2, 3};\n    factor.reserve(primes.size());\n\
    \    for (int i = 4; i <= sq; i += 4) {\n        if (n % i == 0) {\n         \
    \   for (int j = 2; j <= i; j++)\n                if (i % j == 0)\n          \
    \          break;\n            factor.push_back(i);\n            for (int j =\
    \ i + 1; j <= sq; j += i) {\n                if (j % i == 0)\n               \
    \     break;\n                factor.push_back(j);\n            }\n          \
    \  for (int j = sq; j >= i; j -= i) {\n                if (j % i == 0)\n     \
    \               break;\n                factor.push_back(j);\n            }\n\
    \            for (int j = sq; j < i; j += i) {\n                if (j % i == 0)\n\
    \                    break;\n                factor.push_back(j);\n          \
    \  }\n            factor.push_back(sq);\n            factor.push_back(n);\n  \
    \          return factor;\n        }\n    }\n\n    if (n < 4)\n        factor.push_back(n);\n\
    \n    return factor;", "    std::vector<long> result;\n    long temp=n;\n    long\
    \ count=0;\n    // check wheather n is a prime number or not\n    for(long i=2;\
    \ i<=temp; i++){\n       if(temp%i==0)\n       {\n           count=1;\n      \
    \     result.push_back(i);\n       }\n    }\n    // if n is not a prime number,\
    \ then divide n by all prime factors to get its prime factors\n    // If n is\
    \ not a prime number, then it is only a composite number so do not divide it by\
    \ any prime factor \n    while(temp>1){\n       for(long i=2; i<=temp; i++){\n\
    \           if(temp%i==0){\n               count++;\n               result.push_back(i);\n\
    \           }\n       }\n       temp/=result[count];\n    }\n    return result;",
  "    long long f = 0;\n    std::vector<long> res;\n    for (long i = 1; i <= n;\
    \ i++) {\n        while (n % i == 0) {\n            f += i;\n            n /=\
    \ i;\n        }\n        res.push_back(f);\n        f = 0;\n    }\n    res.push_back(n);\n\
    \    return res;", "    // Store factorization from largest (i.e. largest) to\
    \ smallest (i.e. smallest)\n    std::vector<long> factorization(n + 1);\n    //\
    \ Initialize factor count of each integer from 1 to n\n    for (int i = 1; i <=\
    \ n; i++) {\n        factorization[i] = 0;\n    }\n    // Factor out all factors\
    \ greater than 1\n    // Keep the count of factors\n    int numFactors = 0;\n\
    \    for (int i = 2; i <= n / i; i++) {\n        if (n % i == 0) {\n         \
    \   factorization[i]++;\n            while (n % i == 0) {\n                factorization[i\
    \ / ++numFactors]++;\n                n /= i;\n            }\n        }\n    }\n\
    \    // Factor out all factors less than 1\n    // Keep the count of factors\n\
    \    for (int i = 2; i <= n / i; i++) {\n        if (n % i == 0) {\n         \
    \   factorization[i]--;\n            while (n % i == 0) {\n                factorization[i\
    \ / --numFactors]--;\n                n /= i;\n            }\n        }\n    }\n\
    \    // Return the factorization\n    return factorization;", "\tstd::vector<long>\
    \ vec;\n\tlong f = 2;\n\tlong fp = 1;\n\tlong count = 0;\n\twhile (fp < n) {\n\
    \t\tif (n % fp == 0) {\n\t\t\tlong tmp = n / fp;\n\t\t\tvec.push_back(f);\n\t\t\
    \tf = f;\n\t\t\tcount += 1;\n\t\t\twhile (tmp > 1) {\n\t\t\t\tf += 1;\n\t\t\t\t\
    tmp--;\n\t\t\t}\n\t\t} else {\n\t\t\tf += 1;\n\t\t}\n\t\tfp += 2;\n\t}\n\tvec.push_back(f);\n\
    \treturn vec;", "\tstd::vector<long> factorization;\n\tstd::unordered_map<long,\
    \ std::size_t> counters;\n\tlong a = n;\n\twhile (a > 1) {\n\t\tlong b = a / 2;\n\
    \t\tfor (long i = 1; i <= b; i++) {\n\t\t\tif (counters[b] == 0) {\n\t\t\t\tfactorization.push_back(b);\n\
    \t\t\t\tcounters[b] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcounters[b]++;\n\t\t\
    }\n\t\ta = b;\n\t}\n\treturn factorization;", "    assert(n % 2 == 0);\n    std::vector<long>\
    \ p;\n    long f1 = 1;\n    long f2 = 2;\n    while (f1 * f2 <= n) {\n       \
    \ if ((n % f1) != 0) {\n            p.push_back(f1);\n            f1 = f1 + f2;\n\
    \        }\n        if ((n % f2) == 0) {\n            p.push_back(f2);\n     \
    \       f1 = f1 + f2;\n        }\n        if ((n % f2) != 0) {\n            p.push_back(f2);\n\
    \            f2 = f2 + f1;\n        }\n    }\n    if (f1 != n) p.push_back(f1);\n\
    \    return p;", "    std::vector<long> vec;\n    long p = n;\n    long q;\n \
    \   long i = 3;\n    while (i <= n / p) {\n        while (n % i == 0) {\n    \
    \        vec.push_back(i);\n            n /= i;\n        }\n        i++;\n   \
    \ }\n    if (n != 1)\n        vec.push_back(n);\n    vec.erase(std::unique(vec.begin(),\
    \ vec.end()), vec.end());\n    return vec;", "    std::vector<long> factors;\n\
    \    factorize_recursive(n, factors, 0);\n    return factors;", "    std::vector<long>\
    \ factor;\n    if (n <= 1) return factor;\n    long p = 2;\n    long i = 2;\n\
    \    while (i < n) {\n        long tmp = n;\n        while (tmp > p * i) tmp /=\
    \ i;\n        if (tmp == 1) factor.push_back(i);\n        p = i;\n        ++i;\n\
    \    }\n    return factor;", "  std::vector<long> factorize;\n  long temp = 1;\n\
    \  long count = 1;\n  for (long i = 2; i <= n/2; ++i)\n  {\n    if (n % i == 0)\n\
    \    {\n      while (n % i == 0) {\n        temp *= i;\n        n /= i;\n    \
    \    ++count;\n      }\n    }\n  }\n  factorize.push_back(temp);\n  factorize.push_back(count);\n\
    \  return factorize;", "    // factorizing prime numbers upto n with memoization\
    \ is very fast. \n    // If n is prime then factorize will return the empty vector.\n\
    \    // If n is divisible by 2 then only 1 factor is needed and it is also the\
    \ factor.\n    \n    // We use std::map to keep the factorization so that we don't\
    \ have to factorize all numbers again and again.\n    // This should save time.\n\
    \    \n    // If n is prime then return empty vector\n    if (n <= 1) {\n    \
    \    return {};\n    }\n    \n    // This variable keeps track of all numbers\
    \ that we have already factored.\n    // If a number is in the map then we know\
    \ that we only have to factor it once and we don't need to factorize it again.\n\
    \    \n    std::vector<long> factors;\n    \n    // If n is divisible by 3 then\
    \ we only need to factor it once to form a factor with 2 and 1.\n    if (n % 3\
    \ == 0) {\n        factors.push_back(3);\n        n = n / 3;\n        \n    }\n\
    \    \n    \n    // Now we check for divisors which are (not prime) divisible\
    \ by 2 and 3. \n    // When a divisor is found we add its value to the list of\
    \ factors.\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i ==\
    \ 0) {\n            // If the number divided by i is also not prime then we know\
    \ that i is a factor of n and we must factor n with it.\n            // We already\
    \ added i so n cannot be a factor of i.\n            factors.push_back(i);\n \
    \           \n            // n divided by i can only be a factor of the prime\
    \ number found above (factor of i).\n            // So we must factor it with\
    \ n.\n            // We only need to factorize once with i because we already\
    \ factored n with i above.\n            n = n / i;\n            \n           \
    \ // We now break out of the loop because we will have tested all numbers that\
    \ are not factors of n.\n            break;\n        }\n    }\n    \n    \n  \
    \  \n    // If n is not a prime number then it can be factored multiple times.\n\
    \    // We only need to add n to the factors list if n was factored only once.\n\
    \    // We will later know that this number n is facorized with i above.\n   \
    \ \n    // We only need to do this check for the first factor (because n was factored\
    \ once with i above).\n    // If n is not factored then we know that i is a factor\
    \ of n and we must factor n with it.\n    if (n != 1) {\n        factors.push_back(n);\n\
    \    }\n    \n    // Return the factors of the given number.\n    return factors;",
  "    std::vector<long> factorization;\n    for (long i = 2; i <= n; i++) {\n   \
    \     while ((n % i) == 0) {\n            factorization.push_back(i);\n      \
    \      n /= i;\n        }\n    }\n    factorization.push_back(n);\n    return\
    \ factorization;", "    // factors are represented by list\n    std::vector<long>\
    \ factors; // vector of factors so far\n    long temp = n;\n    while (temp !=\
    \ 1) {\n        // find the largest factor smaller than temp\n        long l =\
    \ 0;\n        for (long i = 1; i <= temp; ++i) {\n            if (temp % i ==\
    \ 0)\n                l = i;\n        }\n        // find smallest factor greater\
    \ than temp\n        long r = 0;\n        for (long i = temp + 1; i <= n; ++i)\n\
    \            if (n % i == 0)\n                r = i;\n        temp /= r; // factor\
    \ of temp will be temp divided by r\n        factors.push_back(r); // add new\
    \ factor to vector\n        factors.push_back(l); // add new factor to vector\n\
    \    }\n    // add number 1 to the list since it is the only number that is not\
    \ represented in the factorization so far\n    factors.push_back(1);\n    return\
    \ factors;", "    // Write your code here\n    if (n<=0)\n    {\n        return\
    \ {};\n    }\n    std::vector<long> result;\n    long m = n;\n    std::vector<long>\
    \ f(n);\n    int count=0;\n    for (long i=2;i<=n;i++)\n    {\n        if (m%i==0)\n\
    \        {\n            f[count]=i;\n            m=m/i;\n            count++;\n\
    \        }\n    }\n    result.assign(n+1);\n    result[0]=n;\n    long j=0;\n\
    \    for (int i=1;i<n;i++)\n    {\n        if (count==0)\n            break;\n\
    \        if (count!=0 && j==(n-count))\n        {\n            j=0;\n        }\n\
    \        if (j==0)\n            result[i]=f[j];\n        j++;\n        count--;\n\
    \    }\n    \n    return result;", "    // If number is even, it cannot be prime\n\
    \    if (n % 2 == 0)\n    {\n        return {};\n    }\n    // If number is 1,\
    \ it can be prime\n    else if (n == 1)\n    {\n        return {1};\n    }\n \
    \   // If number is even and greater than 1, it can not be prime\n    else if\
    \ (n % 2 != 0)\n    {\n        return {};\n    }\n    // If number is 2, we divide\
    \ it by 2\n    else if (n == 2)\n    {\n        return {2};\n    }\n    // If\
    \ number is 3, it can be prime since 3 is a factor of 2\n    else if (n == 3)\n\
    \    {\n        return {3};\n    }\n\n    // We start from the largest number\
    \ and go to the smallest\n    std::vector<long> factors;\n    long curr = 2;\n\
    \    long maxFactor = n-1;\n\n    while (maxFactor >= 1)\n    {\n        // If\
    \ current number is smaller than max factor, we need to increase max factor\n\
    \        if (curr * curr > maxFactor)\n        {\n            maxFactor = maxFactor\
    \ * 2 + 2;\n        }\n\n        // We divide this number by current number\n\
    \        curr = maxFactor / curr;\n\n        // Add new factor to our result vector\n\
    \        factors.push_back(curr);\n\n        // If current number is equal to\
    \ max factor, it means that we have found factorization for our number\n     \
    \   if (curr == maxFactor)\n        {\n            break;\n        }\n    }\n\
    \    return factors;", "    long d[n];\n    for (int i = 0; i < n; i++) {\n  \
    \      d[i] = 1;\n    }\n    long c = 2;\n    while (c < n) {\n        for (int\
    \ i = 0; i < n; i++) {\n            if (d[i] == 0) {\n                long t =\
    \ c * i;\n                if (t >= n) {\n                    break;\n        \
    \        }\n                for (int j = i; j < n; j++) {\n                  \
    \  if (t % j == 0) {\n                        d[j] = 0;\n                    }\n\
    \                }\n            }\n        }\n        c++;\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        if (d[i] == 1) {\n        \
    \    ans.push_back(i);\n        }\n    }\n    return ans;", "\t// Your code here\n\
    \tstd::vector<long> factors;\n\t\n\tlong factor = sqrt(n);\n\t\n\twhile(factor*factor\
    \ <= n) {\n\t\t\n\t\tlong r = n/factor;\n\t\tif(factor % 2 == 1) {\n\t\t\tfactors.push_back(r);\n\
    \t\t\tn = r*2;\n\t\t} else {\n\t\t\tfactors.push_back(2);\n\t\t\tn = r*3;\n\t\t\
    }\n\t\tfactor = factor + 1;\n\t}\n\t\n\tstd::sort(factors.begin(),factors.end());\n\
    \t\n\treturn factors;", "    std::vector<long> factor;\n    // Find the prime\
    \ factors of the input number\n    // Prime factor will either be 1 or input number\n\
    \    for (long i = 1; i <= n / 2; i++) {\n        while (n % i == 0) {\n     \
    \       factor.push_back(i);\n            n /= i;\n        }\n    }\n    factor.push_back(n);\n\
    \    return factor;", "  long factorization[11] = {0};\n  for (int i = 2; i <\
    \ n; ++i) {\n    int j = 0;\n    while (n % i == 0) {\n      ++j;\n      n /=\
    \ i;\n    }\n    factorization[i] = j;\n  }\n  std::vector<long> result(11);\n\
    \  for (int i = 0; i < 11; ++i) {\n    if (factorization[i] != 0) {\n      result[i]\
    \ = factorization[i];\n    } else {\n      result[i] = 1;\n    }\n  }\n  return\
    \ result;", "\t// Make vector for storing factorization\n\tstd::vector<long> factorization(n);\n\
    \t// Initialize factor counters\n\tlong factor_count = 1;\n\t// For each factor\
    \ of given number\n\tfor (long i = 1; i <= n; i++) {\n\t\t// If current factor\
    \ is not prime number\n\t\tif (n % i == 0) {\n\t\t\t// If current factor is smaller\
    \ than current factor of n\n\t\t\tif (factorization[i - 1] < factorization[i -\
    \ 1]) {\n\t\t\t\t// Increase factor count\n\t\t\t\tfactor_count++;\n\t\t\t\t//\
    \ Add current factor to factorization\n\t\t\t\tfactorization.push_back(factor_count);\n\
    \t\t\t} else {\n\t\t\t\t// If current factor is same as current factor of n\n\t\
    \t\t\tif (factorization[i - 1] == factorization[i - 1]) {\n\t\t\t\t\t// Remove\
    \ current factor from factorization\n\t\t\t\t\tfactorization.erase(std::remove(factorization.begin(),\
    \ factorization.end(), factorization[i - 1]), factorization.end());\n\t\t\t\t\t\
    // Decrease factor count\n\t\t\t\t\tfactor_count--;\n\t\t\t\t}\n\t\t\t\t// If\
    \ current factor is larger than current factor of n\n\t\t\t\telse if (factorization[i\
    \ - 1] > factorization[i - 1]) {\n\t\t\t\t\t// Increase factor count\n\t\t\t\t\
    \tfactor_count++;\n\t\t\t\t\t// Add current factor to factorization\n\t\t\t\t\t\
    factorization.push_back(factor_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ factorization;", "  std::vector<long> factorization;\n  long prime = 2;\n  while\
    \ (n != 1) {\n    if (n % prime == 0) {\n      factorization.push_back(prime);\n\
    \      n = n / prime;\n    } else {\n      prime++;\n    }\n  }\n  return factorization;",
  "    long fac_array[] = {2, 3};\n    long counter = 2;\n    std::vector<long> factorization;\n\
    \    while (n >= fac_array[counter]) {\n        factorization.push_back(fac_array[counter]);\n\
    \        counter += 1;\n    }\n    factorization.push_back(n);\n    return factorization;",
  "    long factorization[n + 1];\n    long next_factorization[n + 1] = { 1 };\n \
    \   for (int i = 1; i <= n; i++) {\n        while (n % i == 0) {\n           \
    \ factorization[i] = factorization[i - 1] * i;\n            next_factorization[i]\
    \ = next_factorization[i - 1] * i;\n            n /= i;\n        }\n    }\n  \
    \  std::vector<long> res;\n    res.push_back(factorization[n]);\n    while (n\
    \ > 1) {\n        if (next_factorization[n] != 1) {\n            res.push_back(next_factorization[n]);\n\
    \        }\n        n /= next_factorization[n];\n    }\n    return res;", "  \
    \  std::vector<long> factors;\n    long temp = n;\n    while (temp > 1) {\n  \
    \      while (temp % 2 == 0) {\n            temp /= 2;\n            factors.push_back(2);\n\
    \        }\n        while (temp % 3 == 0) {\n            temp /= 3;\n        \
    \    factors.push_back(3);\n        }\n        while (temp % 5 == 0) {\n     \
    \       temp /= 5;\n            factors.push_back(5);\n        }\n        while\
    \ (temp % 7 == 0) {\n            temp /= 7;\n            factors.push_back(7);\n\
    \        }\n    }\n    return factors;", "    long factorization[] = { 1, n, n-1\
    \ };\n    std::vector<long> factorizations;\n    long product = 1;\n    // The\
    \ first two factors need to appear in the factorization twice\n    factorizations.push_back(factorization[0]);\n\
    \    factorizations.push_back(factorization[1]);\n    for (size_t i = 2; i <=\
    \ n/2; ++i) {\n        while (product % i == 0) {\n            product /= i;\n\
    \            factorizations.push_back(i);\n            factorizations.push_back(product);\n\
    \        }\n    }\n    // If the number is prime the product should be equal to\
    \ the original number\n    if (product != 1) {\n        factorizations.push_back(product);\n\
    \    }\n    return factorizations;", "  std::vector<long> factorization;\n  factorization.push_back(n);\n\
    \  long p = 2;\n  while (p < factorization.size()) {\n    if (factorization[p]\
    \ == 0) {\n      factorization.pop_back();\n      factorization.push_back(1);\n\
    \      p = 2;\n    } else {\n      for (long i = p * factorization[p] - 1; i >\
    \ 0; i /= p) {\n        if (i % p == 0 && i != factorization[p]) {\n         \
    \ factorization.push_back(p);\n          factorization.push_back(i);\n       \
    \   p = p * factorization[p];\n          break;\n        }\n      }\n    }\n \
    \ }\n  return factorization;", "    std::vector<long> ans;\n    long cur = n;\n\
    \    long a = 2, b = 2;\n    while (cur > 1) {\n        if (cur % a == 0 && cur\
    \ % b == 0) {\n            ans.push_back(a);\n            ans.push_back(b);\n\
    \            cur /= a;\n            a /= 2;\n            b /= 2;\n        } else\
    \ if (cur % a == 0) {\n            ans.push_back(a);\n            cur /= a;\n\
    \            a /= 2;\n        } else if (cur % b == 0) {\n            ans.push_back(b);\n\
    \            cur /= b;\n            b /= 2;\n        } else {\n            ans.push_back(cur);\n\
    \            cur /= a;\n            a /= 2;\n            b /= 2;\n        }\n\
    \    }\n    return ans;", "    std::vector<long> factors(n);\n    long long c\
    \ = 2, a = 3;\n    for (long long i = 0; i < n; i++) {\n        while (c < n)\
    \ {\n            if (n % c == 0) {\n                factors[c]++;\n          \
    \      n /= c;\n            }\n            c++;\n        }\n        if (n != 1)\
    \ {\n            factors[n] = factors[c];\n        }\n        a = b*a;\n    }\n\
    \    return factors;", "    std::vector<long> factorization;\n    long maxNumberOfTimes\
    \ = 0;\n    long currentNumberOfTimes = 0;\n    for (int i = 1; i <= n; i++) {\n\
    \        while (n % i == 0) {\n            if (currentNumberOfTimes == maxNumberOfTimes)\
    \ {\n                factorization.push_back(i);\n                currentNumberOfTimes++;\n\
    \            } else {\n                factorization.push_back(i);\n         \
    \       currentNumberOfTimes++;\n            }\n            n /= i;\n        }\n\
    \    }\n    return factorization;", "    long p = 3;\n    std::vector<long> factors;\n\
    \    while (p * p <= n) {\n        while (p * p < n) {\n            if (n % p\
    \ == 0) {\n                n /= p;\n                factors.push_back(p);\n  \
    \          }\n            else {\n                p += 2;\n            }\n   \
    \     }\n        factors.push_back(p);\n        p = 3;\n    }\n    return factors;",
  "    std::vector<long> res;\n    long p = n;\n    while (n != 1) {\n        while\
    \ (n % p == 0) {\n            n /= p;\n            res.push_back(p);\n       \
    \ }\n        p++;\n    }\n    return res;", "    std::vector<long> factors;\n\
    \    long a = 2, b, count = 1;\n    while(n != 1) {\n        if(n%a == 0) {\n\
    \            n /= a;\n            count++;\n        } else {\n            factors.push_back(count);\n\
    \            count = 1;\n        }\n        if(n > 1) {\n            a++;\n  \
    \          b *= a;\n        }\n    }\n    factors.push_back(count);\n    return\
    \ factors;", "    std::vector<long> factors;\n    long p = 1;\n    long temp =\
    \ 1;\n    while (n % p == 0) {\n        factors.push_back(p);\n        temp =\
    \ p;\n        n /= p;\n    }\n    factors.push_back(temp);\n    return factors;",
  "  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while\
    \ (n % i == 0) {\n      n /= i;\n      factors.push_back(i);\n    }\n  }\n  if\
    \ (n != 1) factors.push_back(n);\n  return factors;", "    assert(!(n&1)); //\
    \ n should be even and larger than 2\n    std::vector<long> factors;\n    long\
    \ x = 2, y, z, i, n, factor = 1;\n    while (x < n) {\n        y = n % x;\n  \
    \      if (y != 0) {\n            n = y;\n            factor = 1;\n        }\n\
    \        else {\n            z = n / x;\n            y = x % z;\n            if\
    \ (y == 0) {\n                factor *= z;\n                n = x / z;\n     \
    \       }\n            else {\n                i = 2;\n                while (i\
    \ < z) {\n                    if (z % i == 0) {\n                        factor\
    \ = i;\n                        n = z / i;\n                        break;\n \
    \                   }\n                    i++;\n                }\n         \
    \   }\n        }\n        x++;\n        factors.push_back(factor);\n    }\n  \
    \  return factors;", "    // Check base case\n    if (n <= 1) {\n        return\
    \ {1};\n    }\n\n    // Build primes less than n\n    auto primes = std::generate_n(std::back_inserter(std::vector(std::make_pair(2,\
    \ n)), primes.end()), primes.size() / 2 + 1);\n    std::vector<long> factors;\n\
    \    long cur_prime = 2;\n\n    // Iterate over each prime and check if current\
    \ is factor of n\n    // Add factor to the list if yes, else remove it from list\
    \ if no\n    for (auto &p : primes) {\n        while (p < n) {\n            if\
    \ (n % p) {\n                factors.push_back(p);\n                n = n / p;\n\
    \            } else {\n                std::pop_back(primes, p + 1);\n       \
    \     }\n        }\n    }\n\n    // Add remaining factor if current isn't a factor\
    \ of n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;",
  "    long factorization[20] = {0};\n    for (long i = 1; i <= n; i++)\n        for\
    \ (long j = 1; j <= n / i; j++)\n            if (n % i == 0)\n               \
    \ factorization[i] += factorization[j];\n    // Copy factorization array to vector\
    \ and sort it using STL's sort function\n    std::vector<long> vec(factorization);\n\
    \    sort(vec.begin(), vec.end());\n    return vec;", "    std::vector<long> factorization;\n\
    \    factorization.push_back(1);\n    for(long i = 2; i <= n; i++) {\n       \
    \ while(n % i == 0) {\n            factorization.push_back(i);\n            n\
    \ /= i;\n        }\n    }\n    return factorization;", "    std::vector<long>\
    \ v;\n    long m = 2;\n    while (m < n) {\n        while (n % m == 0) {\n   \
    \         v.push_back(m);\n            n /= m;\n        }\n        ++m;\n    }\n\
    \    if (n > 1) {\n        v.push_back(n);\n    }\n    return v;", "    std::sort(std::begin(primes),\
    \ std::end(primes));\n    // TODO: implement a better algorithm\n    std::vector<long>\
    \ factors;\n    for (long i : primes) {\n        while (n%i == 0) {\n        \
    \    n /= i;\n            factors.push_back(i);\n            assert(n != 0);\n\
    \        }\n    }\n    return factors;", "    std::vector<long> res;\n    long\
    \ p = n;\n    long sqn = p;\n    long s = 2;\n    while (sqn > 1) {\n        while\
    \ ((s <= p) && (sqn % s == 0)) {\n            sqn /= s;\n            ++s;\n  \
    \      }\n        long k = s;\n        s = 1;\n        while (sqn % k == 0) {\n\
    \            sqn /= k;\n            ++k;\n        }\n        res.push_back(k);\n\
    \    }\n    return res;", "    std::vector<long> factors;\n    // Base case: reached\
    \ number 1 without factors.\n    if (n == 1) return {};\n\n    long n = 2, f =\
    \ 1;\n    // Recursive case.\n    while (n % 2) {\n        f = 2;\n        n /=\
    \ 2;\n    }\n\n    // Fill vector with factors.\n    while (n != 1) {\n      \
    \  while (n % f) f++;\n        factors.push_back(f);\n        n /= f;\n      \
    \  f++;\n    }\n\n    return factors;", "    std::vector<long> factors;\n    //\
    \ Factorizing algorithm\n    for (long i = 3; i <= sqrt(n); i += 2) {\n      \
    \  while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n\
    \        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n  \
    \  return factors;", "    std::vector<long> factorization(n);\n    std::vector<long>\
    \ prime_numbers(2);\n    for (int i = 2; i < n; i++) {\n        while (n % i ==\
    \ 0) {\n            factorization[i] = i;\n            n /= i;\n        }\n  \
    \  }\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        if (factorization[i]\
    \ != i) {\n            prime_numbers[count] = i;\n            count += factorization[i];\n\
    \        }\n    }\n    for (int i = 0; i < count; i++) {\n        if (prime_numbers[i]\
    \ == 0) {\n            prime_numbers.erase(prime_numbers.begin() + i);\n     \
    \       break;\n        }\n    }\n    return prime_numbers;", "   std::vector<long>\
    \ factors;\n   long r = n;\n   while (!(r&1))\n   {\n      long p = ((r-1)/2)*2;\n\
    \      while (!(r%p)) {\n         r = p;\n         p = ((r-1)/2)*2;\n      }\n\
    \      factors.push_back(p);\n      r /= p;\n   }\n   return factors;", "    std::vector<long>\
    \ factors;\n    long count = 1;\n    for (long i = 1; i <= n; ++i) {\n       \
    \ long j = 1;\n        while (j * i <= n) {\n            if (n % i == 0) {\n \
    \               factors.push_back(i);\n                count *= i;\n         \
    \       n /= i;\n            }\n            j += 1;\n        }\n    }\n    factors.push_back(count);\n\
    \    return factors;", "  std::vector<long> factors;\n  // Initialize all factors\
    \ to 1\n  for (long i = 2; i <= n; ++i) {\n    factors.push_back(1);\n  }\n  //\
    \ Loop until no more factors left\n  while (!factors.empty()) {\n    // Loop through\
    \ all factors left\n    for (auto &f : factors) {\n      // If no more factors\
    \ left\n      if (f == 0) {\n        factors.clear();\n        break;\n      }\n\
    \      // If current factor has already been counted\n      if (n % f == 0) {\n\
    \        factors[factors.size() - 1] += 1;\n        // If current factor isn't\
    \ prime\n        if (n / f != 1) {\n          factors.clear();\n        }\n  \
    \      break;\n      }\n    }\n  }\n  return factors;", "    std::vector<long>\
    \ factors; // vector for storing factors\n    std::bitset<long> bset(n); // converting\
    \ n to bit set\n    long x = 1; // initial value for x\n    // loop to iterate\
    \ over all bit set elements\n    for (long i = bset.size(); i > 0; i--) {\n  \
    \      // If the current bset element is 0 skip it\n        if (bset[i - 1]) {\n\
    \            // if x is multiple of i, store the prime factor of x in factors\n\
    \            if (x % i == 0)\n                factors.push_back(i);\n        \
    \    // set x to multiple of i\n            x /= i;\n        }\n    }\n    return\
    \ factors;", "    std::vector<long> factorization;\n    long x = n;\n    long\
    \ factor = 2;\n    bool flag = false;\n    for(long i = 3; i <= n; i += 2) {\n\
    \        while(n % i == 0) {\n            n /= i;\n            factorization.push_back(i);\n\
    \            flag = true;\n        }\n        if(flag) {\n            factor =\
    \ 2;\n            flag = false;\n        } else {\n            factor++;\n   \
    \     }\n    }\n    if(n == 1) {\n        factorization.push_back(1);\n    }\n\
    \    return factorization;", "    std::vector<long> factorization(n);\n    for(int\
    \ i = 1; i <= n; ++i) {\n        long count = 0;\n        for(int j = i; j > 1;\
    \ j--) {\n            if(n % j == 0) count++;\n        }\n        if(count > factorization[i\
    \ - 1]) factorization[i - 1] = count;\n    }\n    return factorization;", "  \
    \  std::vector<long> result;\n    long product = n;\n    long factor = 2;\n  \
    \  while (true) {\n        if (product % factor == 0) {\n            product /=\
    \ factor;\n            result.push_back(factor);\n            factor = 2;\n  \
    \      }\n        else {\n            factor++;\n        }\n        if (factor\
    \ == product) {\n            break;\n        }\n    }\n    return result;", " \
    \   std::vector<long> factors;\n    if (n < 2) \n        return factors;\n   \
    \ int i = 2, count = 2;\n    while(i < n && count < n){\n        if(n%i == 0){\n\
    \            factors.push_back(i);\n            count = count + 1;\n         \
    \   n = n/i;\n        } \n        else i++;\n    }\n    return factors;", "\t\
    // initialize our vector of factors\n\tstd::vector<long> factors;\n\tfactors.push_back(1);\
    \ // initialize 1 to itself\n\t// loop through the factors, adding them to the\
    \ list as we find them\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tif (n % i ==\
    \ 0)\n\t\t{\n\t\t\t// check to see if the current number is a factor of any of\
    \ the already found factors\n\t\t\tfor (int j = 0; j < factors.size() && factors[j]\
    \ <= i; j++) {\n\t\t\t\t// if the current number is a factor of any of the already\
    \ found factors, add the factor to the list\n\t\t\t\tfactors.push_back(i);\n\t\
    \t\t\t// if the current number is a factor of all the factors, stop looking for\
    \ more factors\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// sort the factors list,\
    \ lowest to highest, because we need them to return the factors in order of decreasing\
    \ number\n\tstd::sort(factors.begin(), factors.end());\n\treturn factors;", " \
    \   std::vector<long> factors;\n    long ans = n;\n    long i = 2;\n    while\
    \ (ans > 1){\n        while(ans % i == 0){\n            ans = ans/i;\n       \
    \     factors.push_back(i);\n        }\n        i++;\n    }\n    return factors;",
  "    std::vector<long> factorization;\n    long product = 1, d = 1;\n    long i\
    \ = 2;\n    while (product * i <= n) {\n        product *= i;\n        while (product\
    \ / i > d) {\n            ++d;\n        }\n        factorization.push_back(d);\n\
    \        ++i;\n    }\n    return factorization;", "    std::vector<long> result;\n\
    \    std::vector<long> factorization(n+1, 1);\n    long i=0;\n    for (i=2; i*i<=n;\
    \ i++) {\n        // If i is not factorized yet\n        if (factorization[i*i]\
    \ == 0) {\n            // Then factorize i \n            for (long j=i*i; j<=n;\
    \ j+=i) {\n                factorization[j] = 1;\n            }\n            //\
    \ And update result \n            long max_factor = 0;\n            for (long\
    \ j=i; j<=n; j++) {\n                if (factorization[j] > max_factor) {\n  \
    \                  max_factor = factorization[j];\n                    result.push_back(j);\n\
    \                }\n            }\n        }\n    }\n    return result;", "  \
    \  std::vector<long> result;\n    if (n < 2) {\n        return result;\n    }\n\
    \    long k = 2;\n    while (k <= sqrt(n)) {\n        while (n % k == 0) {\n \
    \           result.push_back(k);\n            n /= k;\n        }\n        k++;\n\
    \    }\n    if (n > 2) {\n        result.push_back(sqrt(n));\n    }\n    return\
    \ result;", "    std::vector<long> factor;\n    long k = 1;\n    long i = 2;\n\
    \    long counter = 1;\n    while (counter < n / i) {\n        while (n % i ==\
    \ 0) {\n            counter += 1;\n            n /= i;\n        }\n        k +=\
    \ 1;\n        factor.push_back(k);\n        i += i;\n    }\n    return factor;",
  "    std::vector<long> factorized;\n    long a = 1;\n    long b = n;\n    long c\
    \ = 1;\n    // First find prime factors of n\n    for (long i = 0; i < (long)sqrt(n);\
    \ ++i) {\n        while (b != 1) {\n            if (b % i == 0) {\n          \
    \      factorized.push_back(i);\n                b = b % i;\n            }\n \
    \           ++c;\n        }\n        a = a * i;\n        factorized.push_back(a);\n\
    \    }\n    // Now find factorization\n    while (a != 1) {\n        while (b\
    \ != 1) {\n            if (b % a == 0) {\n                factorized.push_back(a);\n\
    \                b = b % a;\n            }\n            ++c;\n        }\n    \
    \    a = a * a;\n        factorized.push_back(a);\n    }\n    // Return vector\
    \ with factors of given number\n    return factorized;", "    std::vector<long>\
    \ factors;\n    factors.reserve(static_cast<size_t>(n));\n    for (long i = 2;\
    \ i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n\
    \            n /= i;\n        }\n    }\n    factors.push_back(n);\n    return\
    \ factors;", "    std::vector<long> res;\n    if (n == 1 || n == 2) {\n      \
    \  res.push_back(n);\n    } else {\n        long mid = n / 2;\n        for (int\
    \ i = 2; i <= mid; ++i) {\n            if (n % i == 0) {\n                long\
    \ temp = n / i;\n                while (n % i == 0) {\n                    res.push_back(i);\n\
    \                    n /= i;\n                }\n                if (n != 1) res.push_back(temp);\n\
    \            }\n        }\n    }\n    return res;", "    std::vector<long> primeFactorization;\n\
    \    long product=1;\n    for(long i=2;i<=n/2;i++) {\n        if(n%i==0) {\n \
    \           product=product*i;\n            primeFactorization.push_back(i);\n\
    \        }\n    }\n    // Check that product is equal to n\n    assert(product==n);\n\
    \    return primeFactorization;", "    // factorization stores factors of n in\
    \ reverse order from smallest to largest\n    std::vector<long> factorization;\n\
    \    long current = 1;\n    // factor is current prime factor\n    long factor\
    \ = 1;\n    long maxFactor = 2;\n    while (current <= n) {\n        while (n\
    \ % current == 0) {\n            factorization.pop_back();\n            current\
    \ = current * maxFactor;\n            factor++;\n        }\n        factorization.push_back(current);\n\
    \        if (current > maxFactor) {\n            maxFactor = current;\n      \
    \  }\n        current = current + 1;\n    }\n    return factorization;", "   \
    \ std::vector<long> factorization;\n    long p = n;\n    // Use while loop to\
    \ find out factors until p is divisible by p*q\n    while ((p%p == 0) && (p%q\
    \ == 0)) {\n        p = p/p;\n        factorization.push_back(p);\n    }\n   \
    \ return factorization;", "    // Complete this function\n    std::vector<long>\
    \ factorization;\n    long d = n;\n    long m = 1;\n    while (d % 2 == 0) {\n\
    \        d /= 2;\n        m++;\n    }\n    long j = 0;\n    long p = 0;\n    while\
    \ (j <= m) {\n        long i = 1;\n        while (i <= j) {\n            long\
    \ temp = i * 2;\n            if (temp > d) {\n                break;\n       \
    \     }\n            d = temp;\n            i++;\n        }\n        j++;\n  \
    \      if (j > m) {\n            break;\n        }\n        p += 1;\n    }\n \
    \   factorization.push_back(p);\n    if (p > 1) {\n        factorization.push_back(p);\n\
    \    }\n    return factorization;", "    std::vector<long> ret;\n    long i =\
    \ 1;\n    while (n > i) {\n        while (n % i == 0) {\n            ret.push_back(i);\n\
    \            n /= i;\n        }\n        i++;\n    }\n    while (n > 1) {\n  \
    \      ret.push_back(1);\n        n /= i;\n        i++;\n    }\n    return ret;",
  "    std::vector<long> fs(n);\n    long p = n;\n    long q = n;\n    while (q >\
    \ 0) {\n        long f = (long) (p * q);\n        fs[f]++;\n        long r = q;\n\
    \        while (r != p) {\n            r *= q;\n            fs[r]++;\n       \
    \ }\n        q /= p;\n        p = r;\n    }\n    for (int i = 1; i <= n; i++)\
    \ {\n        fs[i]--;\n        if (fs[i] > 0) {\n            return std::vector<long>({i});\n\
    \        }\n    }\n    return std::vector<long>();", "    // All prime factors\
    \ (including 1 and itself) will be less than n here\n    long ans = 2;\n    std::vector<long>\
    \ factorization;\n    for (int i = 2; i < n; ++i) {\n        while (n % i == 0)\
    \ {\n            n = n / i;\n            ans = i;\n        }\n        if (ans\
    \ != 2) {\n            factorization.push_back(ans);\n        }\n        ans++;\n\
    \    }\n    if (n > 1) {\n        factorization.push_back(ans);\n    }\n    return\
    \ factorization;", "    std::vector<long> factors;\n    long sqr = n/2;\n    long\
    \ f = 1;\n    while(sqr !=0){\n        f = sqr;\n        while(n % f == 0){\n\
    \            f = f + 1;\n        }\n        sqr -= f;\n        factors.push_back(f);\n\
    \    }\n    return factors;", "    std::vector<long> res;\n    long i = 2;\n \
    \   while (i < n){\n        while (n % i == 0){\n            ++res.push_back(i);\n\
    \            n /= i;\n        }\n        ++i;\n    }\n    if (n != 1){\n     \
    \   res.push_back(n);\n    }\n    return res;", "  std::vector<long> f = {2};\n\
    \  long k = n;\n  long i = 1;\n  while (i <= k) {\n    while (n % i == 0) {\n\
    \      f.push_back(i);\n      n /= i;\n    }\n    ++i;\n  }\n  f.push_back(n);\n\
    \  return f;", "    std::vector<long> p;\n    long m = 2, b = 2;\n    while (m\
    \ <= n) {\n        while (n % m == 0) {\n            p.push_back(m);\n       \
    \     n = n / m;\n        }\n        while (b * m <= n) {\n            while (b\
    \ * m <= n) {\n                if (b * m > n && n % b == 0) {\n              \
    \      p.push_back(b);\n                    n = n / b;\n                    m\
    \ = m == 2 ? b : m;\n                    break;\n                }\n         \
    \       b++;\n            }\n            m++;\n        }\n    }\n    return p;",
  "  std::vector<long> factors(1, 1);\n  for (long i = 1; i <= n; ++i) {\n    while\
    \ (n % i == 0) {\n      factors[factors.size() - 1] *= i;\n      n /= i;\n   \
    \ }\n  }\n  assert(n % 1 == 0);\n  factors[factors.size() - 1] = n;\n  return\
    \ factors;", "    std::vector<long> factorization(n);\n    std::vector<long> factors(n);\n\
    \    std::vector<long> primes(n);\n    long s = 2;\n    long p = 2;\n    // find\
    \ factorization for given number n\n    while (s * p <= n) {\n        if (n %\
    \ p) {\n            factorization[p] *= p;\n        } else {\n            factorization[p]\
    \ = 1;\n        }\n        factors[p]++;\n        p++;\n        s++;\n    }\n\n\
    \    // find primes less than given number\n    long q = n - 2;\n    while (p\
    \ != 2 && q > 0) {\n        if (factorization[p] == 1) {\n            factorization[p]\
    \ *= p;\n        } else {\n            factorization[p] = 1;\n        }\n    \
    \    factors[p]++;\n        p--;\n        q--;\n    }\n\n    // find first multiple\
    \ of two less than given number\n    long r = s - 1;\n    while (r > 0) {\n  \
    \      if (factorization[r] == 2) {\n            factorization[r] = s;\n     \
    \   } else {\n            factorization[r] = 2;\n        }\n        factors[r]++;\n\
    \        r--;\n    }\n\n    // find prime factors of given number n\n    long\
    \ c = 0;\n    for (int i = n - 1; i > 0; i--) {\n        if (factorization[i]\
    \ == 1) {\n            c = 1;\n            break;\n        }\n    }\n\n    if\
    \ (c) {\n        for (int i = n - 1; i > 0; i--) {\n            if (factorization[i]\
    \ == 1) {\n                factors[i - 1] += 2;\n            } else {\n      \
    \          factors[i - 1]++;\n            }\n        }\n    }\n\n    return factors;",
  "    // Code starts here:\n    std::vector<long> factors;\n    long limit = sqrt(n);\n\
    \    for (long i = 2; i <= limit; i++) {\n        while (n % i == 0) {\n     \
    \       factors.push_back(i);\n            n /= i;\n        }\n    }\n    factors.push_back(1);\n\
    \    factors.push_back(n != 1 ? n : 0);\n\n    return factors;", "    std::vector<long>\
    \ factors(1);\n    long i = 2, j = 1;\n    while (i <= n) {\n        while (n\
    \ % i == 0) {\n            factors.push_back(i);\n            n /= i;\n      \
    \  }\n        i++;\n        j++;\n    }\n    if (n != 1) {\n        factors.push_back(n);\n\
    \    }\n    return factors;", "    // Factorize n\n    long factors[4] = {1, 1,\
    \ 2, 2};\n    long result = 0;\n    for (long i = 4; i > 0; i--) {\n        while\
    \ (n % i == 0) {\n            n /= i;\n            factors[--factors[2]]++;\n\
    \        }\n    }\n    while (n > 1) {\n        factors[--factors[2]]++;\n   \
    \     n /= 2;\n    }\n    while (factors[2] > 1) {\n        result = result *\
    \ factors[2] - 1;\n        factors[2] = 1;\n    }\n    // Convert factors to vector<long>\n\
    \    std::vector<long> ret;\n    for (long i = factors[2]; i; i--) {\n       \
    \ ret.push_back(i * factors[--factors[2]]);\n    }\n    std::reverse(ret.begin(),\
    \ ret.end());\n    return ret;", "    std::vector<long> ans;\n    long i = 1;\n\
    \    long x = 1;\n    while (i < n) {\n        x = x * i;\n        i++;\n    }\n\
    \    for (long i = 2; i <= x; i++) {\n        if (n % i == 0) {\n            for\
    \ (int j = i; j < x; j++) {\n                if (n % j == 0) {\n             \
    \       ans.push_back(j);\n                }\n            }\n        }\n    }\n\
    \    return ans;", "    std::vector<long> prime_factorize(n);\n    for (int i\
    \ = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            prime_factorize[i\
    \ * i] = prime_factorize[i * i] + 1;\n            n /= i;\n        }\n    }\n\
    \    prime_factorize[n] = 1;\n    return prime_factorize;", "    int count = 0;\n\
    \    long i = 2;\n    std::vector<long> factors;\n    long f = 1;\n    while (i\
    \ <= n) {\n        while (n % i == 0) {\n            n /= i;\n            count++;\n\
    \        }\n        factors.push_back(i);\n        if (i == 1) f = 1;\n      \
    \  else if (i == n) f = 2;\n        else f++;\n        i++;\n    }\n    for (int\
    \ i = 0; i < count; i++) {\n        factors.push_back(f);\n    }\n    return factors;",
  "  long ans = 2;\n  std::vector<long> factors;\n  while(n % ans == 0) {\n    factors.push_back(ans);\n\
    \    ans *= ans;\n  }\n  while(n > 1) {\n    long i = 2;\n    while(factors.size()\
    \ > 0 && i * factors.back() <= n) {\n      i *= factors.back();\n      factors.pop_back();\n\
    \    }\n    factors.push_back(i);\n    n/=i;\n  }\n  return factors;", "    std::vector<long>\
    \ factors;\n    long factor = 1;\n    while (n > 1) {\n        while (n % factor\
    \ == 0) {\n            factors.push_back(factor);\n            n = n / factor;\n\
    \            factor++;\n        }\n    }\n    factors.push_back(factor);\n   \
    \ return factors;", "    assert(n % 2 == 0 && n > 2);\n    std::vector<long> factors;\n\
    \    long a = 2, b = n;\n    while (a < b) {\n        while (b % a == 0) {\n \
    \           factors.push_back(a);\n            b /= a;\n        }\n        a +=\
    \ 2;\n    }\n    return factors;", "    // List of prime factors\n    std::vector<long>\
    \ factors;\n    long pFact = 1;\n\n    while (n > 1) {\n        if (n % pFact)\
    \ {\n            pFact *= (pFact + 1);\n        }\n        n /= pFact;\n     \
    \   factors.push_back(pFact);\n    }\n    return factors;", "    std::vector<long>\
    \ factors;\n    long x = n;\n    while (x) {\n        long y = x; //factorization\
    \ of x from smallest to largest\n        while (y) {\n            if (y & 1) {\
    \ //if y's second bit set then y is a factor\n                long t = y; //y\
    \ = y's inverse\n                y = x % y;\n                x = t;\n        \
    \    } else {\n                y = y >> 1;\n            }\n        }\n       \
    \ factors.push_back(x); //this factor is added to factors\n        x = y;\n  \
    \  }\n    factors.push_back(x); //this last factor is also added to factors\n\
    \    return factors;", "    std::vector<long> factors(2LL, 0LL);\n    for (long\
    \ i = 3LL; i * i <= n; i += 2LL) {\n        while (n % i == 0LL) {\n         \
    \   factors[i / 2LL] += 1;\n            n = n / i;\n        }\n    }\n    if (n\
    \ != 1LL) {\n        factors[2LL] += 1;\n    }\n    return factors;", "    std::vector<long>\
    \ factors;\n    long cur = 1, div = 1;\n    while (n > 1) {\n        while (n\
    \ % div == 0) {\n            factors.push_back(div);\n            n /= div;\n\
    \        }\n        div++;\n        cur *= div;\n    }\n    factors.push_back(n);\n\
    \    return factors;", "    std::vector<long> factors;\n    for (long i = 2; i\
    \ * i <= n; ++i) {\n        if (n % i == 0) {\n            long c = i / n;\n \
    \           for (; c >= 2; c--) if (n % c == 0) break;\n            factors.push_back(i);\n\
    \            if (c == 2) factors.push_back(n);\n        }\n    }\n    factors.push_back(1);\n\
    \    factors.push_back(sqrt(n));\n    return factors;", "    std::vector<long>\
    \ factorization;\n    long i, factor = 1;\n    while (factor != 0) {\n       \
    \ for (i = 2; i <= n / factor; i++) {\n            if (n % i == 0) {\n       \
    \         factor *= i;\n                if (factor > factorization.size()) {\n\
    \                    factorization.push_back(factor);\n                } else\
    \ {\n                    factorization[factor].push_back(i);\n               \
    \ }\n            }\n        }\n        factor /= 2;\n    }\n    return factorization;",
  "    std::vector<long> factors;\n    long x = n;\n    for (long i = 2; i <= x/2;\
    \ i++)\n    {\n        if (x % i == 0)\n        {\n            factors.push_back(i);\n\
    \            x = x / i;\n        }\n    }\n    if (x != 1)\n    {\n        factors.push_back(x);\n\
    \    }\n    return factors;", "    std::vector<long> factorization(n+1, 1);\n\
    \    long max_factor = long(sqrt(n));\n    for(long i = 0; i <= max_factor; i++)\n\
    \        if(n % i == 0)\n            factorization[i] = factorization[i] + 1;\n\
    \    long current_factor = 1;\n    for(long i = 1; i < n; i++)\n        if(factorization[i]\
    \ > current_factor)\n            factorization.push_back(current_factor);\n  \
    \      else\n            factorization.push_back(factorization[i]);\n    return\
    \ factorization;", "\tstd::vector<long> factor;\n\tlong i = 1;\n\twhile (i * i\
    \ <= n) {\n\t\tif (n % i == 0) {\n\t\t\tlong temp = 1;\n\t\t\twhile (temp * i\
    \ <= n) {\n\t\t\t\tif (temp % i == 0) {\n\t\t\t\t\tn = n / i;\n\t\t\t\t\tfactor.push_back(i);\n\
    \t\t\t\t\ttemp.push_back(i);\n\t\t\t\t\ti = 1;\n\t\t\t\t} else {\n\t\t\t\t\ttemp.push_back(temp);\n\
    \t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (n != 1)\n\t\t\
    factor.push_back(n);\n\treturn factor;", "    // TODO: Your code here\n    std::vector<long>\
    \ factorization;\n    long temp = 1;\n    for (int i = 0; i < n; i++) {\n    \
    \    long remainder = n % temp;\n        if (remainder == 0) {\n            factorization.push_back(temp);\n\
    \            temp = 1;\n        } else {\n            temp *= remainder;\n   \
    \     }\n    }\n    factorization.push_back(temp);\n    return factorization;",
  "  std::vector<long> factors;\n  std::set<long> primes;\n  for (int i = 1; i <=\
    \ n; i++) {\n    if (primes.find(i) != primes.end()) continue;\n    primes.insert(i);\n\
    \    for (int j = i * i; j < n; j += i) {\n      if (primes.find(j) == primes.end())\
    \ factors.push_back(i);\n    }\n  }\n  return factors;", "    std::vector<long>\
    \ factors;\n    long factor = 1;\n    long remain = n; // initial remainder is\
    \ same as n\n    while (n != 1) {\n        while (n % factor == 0) {\n       \
    \     n /= factor; // factor*factor gives us the prime factors\n            factors.push_back(factor);\n\
    \        }\n        remain = n % factor;\n        factor *= factor;\n    }\n \
    \   // now factors contains the factorization\n    factors.push_back(remain);\n\
    \    return factors;", "    std::vector<long> res;\n    if (n <= 1) return res;\n\
    \    long i = 2;\n    while (i <= sqrt(n)) {\n        if (n % i == 0) {\n    \
    \        long j = i << 1;\n            while (j <= n) {\n                if (n\
    \ % j == 0) {\n                    res.push_back(i);\n                    n /=\
    \ j;\n                }\n                j <<= 1;\n            }\n           \
    \ if (n == 1) {\n                res.push_back(i);\n            }\n        }\n\
    \        ++i;\n    }\n    return res;", "  std::vector<long> result;\n  std::vector<long>\
    \ factors;\n\n  for (long i = 2; i <= n; i++) {\n    long count = 0;\n    long\
    \ temp = i;\n\n    while (temp) {\n      if (n % temp == 0) {\n        count++;\n\
    \        temp /= i;\n      }\n    }\n\n    factors.push_back(count);\n    result.push_back(factors.back());\n\
    \  }\n\n  return result;", "  std::vector<long> primes;\n  long i = 2;\n  while\
    \ (n != 1) {\n    while (n % i == 0) {\n      n /= i;\n      primes.push_back(i);\n\
    \    }\n    i *= 2;\n  }\n  return primes;", "    // initialize result vector\n\
    \    std::vector<long> factors(n);\n\n    // find the factors\n    for (long i\
    \ = 2; i <= n / 2; i++) {\n        // the number is divisible by this number i\n\
    \        if (n % i == 0) {\n            factors[i - 1] = 1;\n\n            //\
    \ find the number which divides the current number\n            for (long j =\
    \ i; j < n; j++) {\n                if (n % j == 0) {\n                    factors[i\
    \ - 1] = factors[i - 1] * j;\n                    break;\n                }\n\
    \            }\n        }\n    }\n\n    return factors;", "    std::vector<long>\
    \ factors;\n    long factor;\n    bool isPrime = true;\n\n    for (factor = 1;\
    \ factor <= n; factor++) {\n        isPrime = false;\n        // check if factor\
    \ exists and is prime\n        for (long i = 2; i <= n / factor; i++) {\n    \
    \        if (n % i == 0) {\n                isPrime = true;\n                break;\n\
    \            }\n        }\n        if (isPrime)\n            factors.push_back(factor);\n\
    \    }\n    return factors;", "    std::vector<long> factors;\n    long p = 1;\n\
    \    while (n > 1) {\n        while (p * p <= n) {\n            if (n % p == 0)\
    \ {\n                factors.push_back(p);\n                n /= p;\n        \
    \        break;\n            }\n            p += 1;\n        }\n    }\n    return\
    \ factors;", "    long long factorization[n + 1];\n    long long i, j, k;\n  \
    \  long long cnt;\n\n    // Store all the prime factors encountered.\n    for\
    \ (i = 2, k = 2; i <= n; ++i) {\n        while ((n % i) == 0) {\n            cnt\
    \ = 0;\n            for (j = i; j <= n; j += i) {\n                ++cnt;\n  \
    \          }\n            factorization[k] = cnt;\n            ++k;\n        }\n\
    \    }\n    factorization[k] = 1;\n\n    std::vector<long> factors;\n    for (j\
    \ = k - 1, i = 0; i < n; ++i) {\n        // If factorization[i] > 1 then it is\
    \ prime and we can use it as factor\n        if (factorization[i] > 1) {\n   \
    \         factors.push_back(factorization[i]);\n        }\n    }\n    sort(factors.begin(),\
    \ factors.end());\n    return factors;", "    std::vector<long> factorization;\n\
    \    for (long i = 1; i <= n; i++) {\n        long factor = 1;\n        while\
    \ (n % i == 0) {\n            n /= i;\n            factor++;\n        }\n    \
    \    factorization.push_back(factor);\n    }\n    return factorization;", "  \
    \  assert(n > 2);\n    std::unordered_map<long, long> m;\n    std::vector<long>\
    \ factors;\n    for (long i = 0; i <= n; ++i) {\n        long j = n / i;\n   \
    \     m.emplace(i, j);\n        while (j > 0) {\n            j = j / i;\n    \
    \        assert(!m.count(j));\n            m[j] = j;\n        }\n    }\n    for\
    \ (auto pair : m) { factors.push_back(pair.second); }\n    std::sort(factors.begin(),\
    \ factors.end());\n    return factors;", "    std::vector<long> factors(1);\n\
    \    long curr = n;\n    long count = 0;\n    while (curr > 1) {\n        while\
    \ (curr > 1) {\n            count++;\n            curr /= 2;\n        }\n    \
    \    factors.push_back(count);\n        curr = n;\n        count = 0;\n    }\n\
    \    factors.push_back(1);\n    return factors;", "    assert(n >= 2);\n    std::vector<long>\
    \ factors;\n    long counter = 0;\n    for (long i = 2; i <= sqrt(n); i++) {\n\
    \        while (n % i == 0) {\n            factors.push_back(i);\n           \
    \ n /= i;\n            counter++;\n        }\n    }\n    if (n != 1) {\n     \
    \   factors.push_back(n);\n        counter++;\n    }\n    for (int i = factors.size()\
    \ - 1; i >= 0; i--) {\n        factors[factors.size() - 1 - i] = counter;\n  \
    \  }\n    return factors;", "    std::vector<long> factors;\n    long max_i =\
    \ 2;\n    for (int i = 2; i <= n / 2; ++i) {\n        while (n % i == 0) {\n \
    \           factors.push_back(i);\n            n /= i;\n        }\n        if\
    \ (n > 1) max_i = i;\n    }\n    if (n != 1)\n        factors.push_back(max_i);\n\
    \    return factors;", "    std::vector<long> res;\n    std::vector<long> primes;\n\
    \    std::vector<bool> factorized(n + 1, false);\n    primes.push_back(n);\n \
    \   while (!primes.empty()) {\n        long curr = primes.back();\n        primes.pop_back();\n\
    \        if (factorized[curr]) {\n            continue;\n        }\n        for\
    \ (long i = 3; i <= curr; i += 2) {\n            if (!factorized[i]) {\n     \
    \           factorized[i] = true;\n                res.push_back(i);\n       \
    \     }\n        }\n    }\n    return res;", "    std::vector<long> p;\n    long\
    \ t = 2;\n    long d = n;\n    while (true) {\n        while (t*t < d) {\n   \
    \         t++;\n        }\n        if (t == d) {\n            p.push_back(2);\n\
    \            break;\n        }\n        while (d % t == 0) {\n            p.push_back(t);\n\
    \            d /= t;\n        }\n    }\n    if (p != std::vector<long>())\n  \
    \      p.push_back(n);\n    return p;", "  std::vector<long> factorized(n+1, 0L);\n\
    \  for (int i = 1; i <= n; i++) {\n    for (int j = i*i; j > n; j -= i) {\n  \
    \    factorized[j] += 1;\n    }\n  }\n  return factorized;", "    std::vector<long>\
    \ res;\n    long d = 2;\n    while ((n % d) != 0) {\n        res.push_back(d);\n\
    \        n /= d;\n    }\n    while (n > 1) {\n        while (n % d == 0) {\n \
    \           res.push_back(d);\n            n /= d;\n        }\n        d += 2;\n\
    \    }\n    sort(res.begin(), res.end());\n    return res;", "    std::vector<long>\
    \ factors;\n    for (long i = 2; i * i <= n; i++)\n        for (long j = 2; j\
    \ <= n / i; j++)\n            if (n % i == 0 && j != i) {\n                factors.push_back(j);\n\
    \                n = n / i;\n            }\n    if (n > 1)\n        factors.push_back(1);\n\
    \    return factors;", "    std::vector<long> ret;\n    long factor = 1, rem =\
    \ n, counter = 1;\n    while (factor <= n / 2) {\n        while (rem % factor\
    \ == 0) {\n            rem /= factor;\n            ret.push_back(factor);\n  \
    \          counter++;\n        }\n        factor++;\n    }\n    return ret;",
  "    std::vector<long> factors;\n    std::vector<bool> visited;\n    long x = 2;\n\
    \    while(n != 1) {\n        if(n % x == 0) {\n            factors.push_back(x);\n\
    \            n /= x;\n        } else {\n            x ++;\n        }\n    }\n\
    \    if(n > 1) {\n        factors.push_back(n);\n    }\n    for(long i = factors.size();\
    \ i >= 0; i --) {\n        if(visited[factors[i]]) {\n            factors.erase(factors.begin()\
    \ + i);\n        }\n    }\n    return factors;", "\tstd::vector<long> res;\n\t\
    // Initialize result with 1\n\tres.push_back(1LL);\n\t// Loop through all odd\
    \ numbers, 2 to sqrt(n) inclusive\n\tfor (int i = 3; i <= std::sqrt(n); i += 2)\
    \ {\n\t\t// If current number is divisible by any number greater than or equal\
    \ to it\n\t\tif (n % i == 0) {\n\t\t\t// Add 1 to current number to represent\
    \ repeated occurance\n\t\t\tres.push_back(n/i);\n\t\t\t// Divide current number\
    \ by current number to remove it from the factorization count\n\t\t\tn/=i;\n\t\
    \t}\n\t}\n\treturn res;", "    std::vector<long> factors;\n    long f = 1;\n \
    \   while (n) {\n        if (n % f) {\n            factors.push_back(f);\n   \
    \         n /= f;\n        } else {\n            f++;\n        }\n    }\n    for\
    \ (size_t i = 0; i < factors.size(); i++) {\n        factors[i] *= i;\n    }\n\
    \    return factors;", "    std::vector<long> result;\n    for (long i = 1; i\
    \ <= n / 2; i++) {\n        while (n % i == 0) {\n            n = n / i;\n   \
    \         result.push_back(i);\n        }\n    }\n    std::reverse(result.begin(),\
    \ result.end());\n    return result;", "    std::vector<long> factors;\n    for\
    \ (long i = 1; i <= n; ++i) {\n        while ((n % i) == 0) {\n            factors.push_back(i);\n\
    \            n /= i;\n        }\n    }\n    return factors;", "    // Find all\
    \ factors\n    std::vector<long> factors(n / 2, 0);\n    for (long f = 2; f <=\
    \ n; f++) {\n        while (n % f == 0) {\n            factors[f / 2]++;\n   \
    \         n /= f;\n        }\n    }\n\n    // Fill vector of size n with number\
    \ of times that a factor appears\n    std::vector<long> counts(n, 0);\n    for\
    \ (long f : factors)\n        counts[f] += 1;\n\n    // Find all prime factors\
    \ in sorted order\n    std::vector<long> res;\n    for (long i = 3; i <= n / i;\
    \ i++){\n        while (n % i == 0){\n            counts[i/2]++;\n           \
    \ n /= i;\n        }\n    }\n    for (long i = 3; i <= n / i; i++){\n        if\
    \ (counts[i/2] == 0){\n            res.push_back(i);\n        }\n    }\n    return\
    \ res;", "    // TODO: Add checks, for example, number should be divisible by\
    \ 2, 5, 7, 11, 13, and so on\n    // TODO: Add checks for negative numbers\n \
    \   std::vector<long> ans;\n    long divisor = 1;\n    long current;\n    while\
    \ (n != 1) {\n        if (n % divisor == 0) {\n            current = (n / divisor);\n\
    \            for (auto i = 0; i < ans.size(); i++)\n                if (ans[i]\
    \ == current)\n                    ans[i] = ans[i] + 1;\n            ans.push_back(current);\n\
    \        }\n        else {\n            divisor++;\n        }\n    }\n    return\
    \ ans;", "    std::vector<long> factors;\n    // If n is even and can be divided\
    \ by two, it's prime\n    if ( n % 2 == 0 && n > 0 ) {\n        if ( n % 12 ==\
    \ 1 ) return { 1, 1 }; // if even, can be divided by 12\n        else if ( n %\
    \ 12 == 12 ) return { 12, 1 }; // if even, can be divided by 12\n        else\
    \ if ( n % 12 == 24 ) return { 6, 2 }; // if even, can be divided by 12\n    \
    \    else if ( n % 12 == 36 ) return { 3, 2 }; // if even, can be divided by 12\n\
    \        else if ( n % 12 == 48 ) return { 2, 3 }; // if even, can be divided\
    \ by 12\n        else if ( n % 12 == 60 ) return { 3, 3 }; // if even, can be\
    \ divided by 12\n        else if ( n % 12 == 82 ) return { 4, 3 }; // if even,\
    \ can be divided by 12\n        else if ( n % 12 == 94 ) return { 5, 3 }; // if\
    \ even, can be divided by 12\n        else if ( n % 12 == 96 ) return { 6, 3 };\
    \ // if even, can be divided by 12\n        else if ( n % 12 == 100 ) return {\
    \ 4, 4 }; // if even, can be divided by 12\n        else if ( n % 12 == 114 )\
    \ return { 3, 4 }; // if even, can be divided by 12\n        else if ( n % 12\
    \ == 124 ) return { 2, 4 }; // if even, can be divided by 12\n        else if\
    \ ( n % 12 == 144 ) return { 4, 4 }; // if even, can be divided by 12\n      \
    \  else if ( n % 12 == 168 ) return { 6, 4 }; // if even, can be divided by 12\n\
    \        else if ( n % 12 == 192 ) return { 3, 4 }; // if even, can be divided\
    \ by 12\n        else if ( n % 12 == 208 ) return { 5, 4 }; // if even, can be\
    \ divided by 12\n        else if ( n % 12 == 224 ) return { 6, 4 }; // if even,\
    \ can be divided by 12\n        else if ( n % 12 == 240 ) return { 4, 5 }; //\
    \ if even, can be divided by 12\n        else if ( n % 12 == 256 ) return { 2,\
    \ 5 }; // if even, can be divided by 12\n        else if ( n % 12 == 272 ) return\
    \ { 4, 5 }; // if even, can be divided by 12\n        else if ( n % 12 == 288\
    \ ) return { 6, 5 }; // if even, can be divided by 12\n        else if ( n % 12\
    \ == 304 ) return { 3, 5 }; // if even, can be divided by 12\n        else if\
    \ ( n % 12 == 320 ) return { 5, 5 }; // if even, can be divided by 12\n      \
    \  else if ( n % 12 == 336 ) return { 6, 5 ", "    std::vector<long> factor;\n\
    \    for (long i = 2; i <= n; i++) {\n        while (n % i == 0) {\n         \
    \   factor.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1)\
    \ {\n        factor.push_back(n);\n    }\n    return factor;", "    std::vector<long>\
    \ factors;\n    long next_n = (long ) sqrt(n);\n    long d = 1;\n    while (next_n\
    \ > 1) {\n        if (n % next_n == 0) {\n            factors.push_back(d);\n\
    \            next_n = (next_n / d);\n        }\n        else {\n            d\
    \ = d + 1;\n            next_n = next_n * d;\n        }\n    }\n    return factors;",
  "    std::vector<long> primes;\n    long i = 2;\n    long j;\n    while (true) {\n\
    \        while (n % i == 0)\n            primes.push_back(i);\n        if (i ==\
    \ 1)\n            break;\n        i += 2;\n    }\n    long p = 1;\n    for (j\
    \ = 0; j < primes.size(); j++)\n        p *= primes[j];\n    std::vector<long>\
    \ f(p);\n    for (long k = 0; k < primes.size(); k++) {\n        long m = primes[k];\n\
    \        for (long j = 0; j < primes.size(); j++) {\n            while (m % primes[j]\
    \ == 0) {\n                m /= primes[j];\n                for (int h = 0; h\
    \ < p; h++) {\n                    f[h] ^= m;\n                }\n           \
    \     m ^= primes[j];\n            }\n        }\n    }\n    return f;", "    std::vector<long>\
    \ factor;\n    long temp;\n    for (long i = 1; i * i < n; i++) {\n        for\
    \ (long j = i * i; j < n; j += i) {\n            temp = j;\n            while\
    \ (temp % i == 0) {\n                temp.divide(++i);\n            }\n      \
    \      factor.push_back(temp);\n        }\n    }\n    return factor;", "    std::vector<long>\
    \ factorization;\n    int counter = 1;\n    long f = 2;\n    while (f <= n) {\n\
    \        if (n % f == 0) {\n            while (n % f == 0) {\n               \
    \ n /= f;\n                counter++;\n            }\n            if (counter\
    \ == 1) {\n                factorization.push_back(f);\n            } else {\n\
    \                factorization.push_back(f);\n                counter = 1;\n \
    \           }\n        } else {\n            f++;\n        }\n    }\n    return\
    \ factorization;", "    // Initialize array to store factorization factors of\
    \ given number\n    std::vector<long> factor(n+1, 1);\n    long temp = 1;\n  \
    \  // Scan the factor array and increase its value by 1 for each factor found\n\
    \    for (long i = 2; i <= n; i++)\n    {\n        if (factor[i] == 1)\n     \
    \   {\n            temp = temp * i;\n        }\n        else\n        {\n    \
    \        factor[temp] = factor[temp] * i;\n        }\n    }\n    // Return factorization\n\
    \    return factor;", "  std::vector<long> factors;\n  // Factorization is performed\
    \ in linear time\n  long s = 1;\n  while (s <= n) {\n    // Every time a factor\
    \ is found add it to factors list\n    while (n % s == 0) {\n      factors.push_back(s);\n\
    \      n /= s;\n    }\n    s++;\n  }\n  // Add remaining factors to factors list\n\
    \  factors.push_back(n);\n  return factors;", "    long count = 2;\n    std::vector<long>\
    \ factors{2,3,5,7,11,13,17,19,23,29};\n    std::vector<long> factorization;\n\
    \    long temp;\n    while (n > 1) {\n        while (n % count == 0) {\n     \
    \       factorization.push_back(count);\n            count++;\n        }\n   \
    \     count += 2;\n        temp = n;\n        n = n / count;\n    }\n    return\
    \ factorization;", "    std::vector<long> result;\n    for (long i = 2; i <= n\
    \ / i; i++)\n        if (n % i == 0)\n            result.push_back(i);\n     \
    \   if (result.size() == 0)\n            result.push_back(1);\n    return result;",
  "  std::vector<long> factorization(n);\n  for (int i = 1; i <= n; i++) {\n    while\
    \ (n % i == 0) {\n      n /= i;\n      factorization[i] = factorization[i - 1]\
    \ + 1;\n    }\n  }\n  if (n != 1) {\n    factorization.push_back(n);\n  }\n  return\
    \ factorization;", "    std::vector<long> fp(factorization(n));\n    std::sort(fp.begin(),\
    \ fp.end());\n    return fp;", "    std::vector<long> primes;\n    for (long i\
    \ = 1; i <= n; i++) {\n        while (n % i == 0) {\n            primes.push_back(i);\n\
    \            n /= i;\n        }\n    }\n    return primes;", "    std::vector<long>\
    \ factorization;\n    if (n%2 == 0) factorization.push_back(2)\n    factorization.reserve(n/2\
    \ + 1);\n    long p = 2;\n    while (p < n) {\n        while ((n % p) == 0) p++;\n\
    \        factorization.push_back(p);\n        n /= p;\n    }\n    if (n != 1)\
    \ factorization.push_back(n);\n    std::reverse(factorization.begin(), factorization.end());\n\
    \    return factorization;", "    // TODO: Implement a better factorization algorithm\n\
    \    // TODO: Use logarithms, not floor division\n    std::vector<long> factors;\n\
    \    long p = n;\n    // check if prime or not\n    while (p % 2 == 0) p = p /\
    \ 2;\n    long q = p;\n    // now we need to find prime factors\n    while (p\
    \ != 1) {\n        while (p % 2 == 0) p = p / 2;\n        // if p now equals 1\
    \ then n is prime (except 1)\n        if (p == 1) {\n            factors.push_back(n);\n\
    \            break;\n        }\n        while (p % 3 == 0) p = p / 3;\n      \
    \  while (p % 5 == 0) p = p / 5;\n        while (p % 7 == 0) p = p / 7;\n    \
    \    factors.push_back(p);\n        // now we check whether the number is multiple\
    \ of current prime factor or not\n        while (p != 1 && n % p == 0) {\n   \
    \         p = p / n;\n        }\n    }\n    factors.push_back(n);\n    return\
    \ factors;", "    std::vector<long> res;\n    long ans=1;\n    // find out all\
    \ prime factors\n    for(long i=2; i<n; i++) {\n        while(n % i == 0) {\n\
    \            res.push_back(i);\n            n /= i;\n        }\n    }\n    //\
    \ if still remainder is not zero\n    if(n > 1) {\n        res.push_back(n);\n\
    \    }\n    // reverse list\n    res.insert(res.end(), res.begin()+1, res.end()-1);\n\
    \    // return factorized list\n    return res;", "    std::vector<long> f; //\
    \ List of factors of n\n    std::vector<bool> fc(f.size(), false); // Factor count\
    \ of each number\n    long m = n;\n    // Count the number of factors\n    for(int\
    \ i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            f[i] =\
    \ i;\n            n /= i;\n            fc[i] = true;\n        }\n    }\n    //\
    \ If number is not prime return empty list\n    if (n != 1) {\n        f.push_back(n);\n\
    \        fc.push_back(false);\n    }\n    // Reverse the factors and sort from\
    \ smallest to largest\n    for(int i = f.size() - 1; i >= 0; --i) {\n        if\
    \ (fc[i]) {\n            std::swap(f[i], f[i + 1]);\n        }\n    }\n    return\
    \ f;", "  std::vector<long> factorization;\n  // Use sieve of eratosthenes approach\
    \ to find prime factors\n  std::vector<bool> isPrime(n / 2);\n  for (long i =\
    \ 3; i * i <= n; i += 2)\n    isPrime[i] = true;\n  for (long i = 3; i * i <=\
    \ n; i += 2)\n    if (isPrime[i]) {\n      long c = i;\n      for (long j = 2;\
    \ j * j <= n; j += 2)\n        if (c * j <= n && c % j == 0)\n          isPrime[j]\
    \ ^= true;\n      if (isPrime[i]) {\n        factorization.push_back(i);\n   \
    \     while (!isPrime[i / 2])\n          i /= 2;\n        while (isPrime[i / 2])\n\
    \          i /= 2;\n      }\n    }\n  return factorization;", "  std::vector<long>\
    \ factors;\n  if (n==1) return factors;\n  std::vector<long> factorization = factorize(n);\n\
    \  for (long i:factorization) {\n    for (long j=factorization.size();j>i;j--)\
    \ factors.push_back(j);\n  }\n  return factors;", "    std::vector<long> factors;\n\
    \    if (n != 1) {\n        long i = 2;\n        while (i < n) {\n           \
    \ while (n % i == 0) {\n                n = n / i;\n                factors.push_back(i);\n\
    \            }\n            i++;\n        }\n    }\n    return factors;", "  \
    \  // Initialize vector of possible factors\n    std::vector<long> factors;\n\
    \    long a = 2, b = n;\n    // Calculate factors of n and store them in factors\
    \ vector.\n    while (true) {\n        while (b != 1 && a <= b) {\n          \
    \  if (n % a == 0) {\n                factors.push_back(a);\n            }\n \
    \           a += 2;\n            n /= a;\n        }\n        // If b is equal\
    \ to 1, a is now the last factor, and we have to repeat this operation for b.\n\
    \        if (b == 1) {\n            break;\n        }\n        // If b > 1, we\
    \ add 1 to the smallest factor of a that is a divisor of n (b-1) in a while loop.\n\
    \        while (b > 1 && (n % b) == 0) {\n            if (factors.size() == 0)\
    \ {\n                break;\n            }\n            factors.push_back(--b);\n\
    \        }\n        b += 2;\n    }\n    // Return factors in factorization order\n\
    \    return factors;", "\tstd::ios_base::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\
    \tstd::vector<long> factorization;\n\tint n = std::abs(n); // to determine if\
    \ input is even or odd\n\tstd::cout << std::endl << \"The factors of \" << n <<\
    \ \" are : \";\n\tif (n%2 == 0) {\n\t\tfor (int i = 3; i <= n/i; i += 2) {\n\t\
    \t\tlong remain = n/i;\n\t\t\tif (remain > 1) {\n\t\t\t\tfactorization.push_back(remain);\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn factorization;", "    std::vector<long> factors;\n\
    \    long limit = sqrt(n);\n    long cur = 1;\n    factors.push_back(1);\n   \
    \ while(cur < limit) {\n        while(n % cur == 0) {\n            factors.push_back(cur);\n\
    \            n /= cur;\n        }\n        cur++;\n    }\n    return factors;",
  "    std::vector<long> result;\n    long factors = 2;\n    long counter = 0;\n \
    \   while (n%2 == 0) {\n        if (n != 1) {\n            n /= 2;\n         \
    \   factors *= 2;\n        }\n        else break;\n    }\n\n    for (long i =\
    \ 3; i <= factors; ++i)\n    {\n        while (n % i == 0)\n        {\n      \
    \      result.push_back(i);\n            n /= i;\n        }\n        if (n ==\
    \ 1)\n            break;\n    }\n    while (n > 1)\n    {\n        factors++;\n\
    \        n /= 2;\n    }\n    if (n > 1)\n        result.push_back(n);\n    return\
    \ result;", "    std::vector<long> result;\n    int count = 1;\n    // Sieve of\
    \ Eratosthenes\n    bool check = true;\n    long factor = 2;\n    while (check)\
    \ {\n        if (n % factor == 0) {\n            count++;\n        }\n       \
    \ if (count > result.size()) {\n            result.emplace_back(factor);\n   \
    \     }\n        check = (n % factor != 0);\n        factor++;\n    }\n    //\
    \ print\n    for (auto i : result) {\n        std::cout << i << \" \";\n    }\n\
    \    std::cout << \"\\n\" << std::endl;\n    return result;", "  std::vector<long>\
    \ factor;\n  int count = 0;\n  for (int i = 2; i * i <= n; i++)\n    while (n/i\
    \ >= i) {\n      count += 1;\n      n = n / i;\n    }\n  if (n == 1)\n    factor.push_back(1);\n\
    \  else\n    factor.push_back(n);\n  while (n > 1) {\n    factor.push_back(n);\n\
    \    factor.push_back(count + 1);\n    for (int i = 1; i < (int) factor.size();\
    \ i++)\n      for (int j = (int) factor.size() - 1; j > i; j--)\n        if (factor[j]\
    \ % factor[i] == 0) {\n          factor.erase(factor.begin() + j);\n         \
    \ break;\n        }\n    count += 1;\n    n /= factor.back();\n  }\n  return factor;",
  "\tstd::vector<long> factorization;\n\tfactorization.reserve(n + 1);\n\t// Base\
    \ case\n\tif (n == 1)\n\t\treturn factorization;\n\n\t// Find prime factors\n\t\
    for (int i = 1; i <= n; ++i) {\n\t\twhile (n % i == 0) {\n\t\t\tfactorization.push_back(i);\n\
    \t\t\tn = n / i;\n\t\t}\n\t}\n\tfactorization.push_back(n);\n\treturn factorization;",
  "  assert(n > 2);\n  std::vector<long> factors;\n  long c = n;\n  long d = 1;\n\
    \  while (c % d == 0) {\n    factors.push_back(d);\n    c /= d;\n    d++;\n  }\n\
    \  factors.push_back(n);\n  std::reverse(factors.begin(), factors.end());\n  return\
    \ factors;"]
stop_tokens:
- "\n}"
