name: HumanEval_91_is_bored
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string\
  \ of words, and your task is to count the number\n// of boredoms. A boredom is a\
  \ sentence that starts with the word \"I\".\n// Sentences are delimited by '.',\
  \ '?' or '!'.\n// For example:\nlong is_bored(std::string S) {\n"
tests: "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"\
  Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n\
  \    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\"\
  )) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will\
  \ kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\"\
  )) == (0));\n}\n"
completions: ["    long freq = 0;\n    size_t pos = 0;\n    while (pos < S.size())\
    \ {\n        if (S.at(pos) == 'I') {\n            freq++;\n        }\n       \
    \ pos += 1;\n    }\n    return freq;", "    long count=0;\n    for (int i=0;i<S.size();i++)\
    \ {\n        if(S[i]=='i')\n            count++;\n    }\n    return count;", "\t\
    int len = 0;\n\tfor (int i = 0; i < S.size(); ++i) {\n\t\tint temp = S[i];\n\t\
    \tif (temp == '.' || temp == '?' || temp == '!') {\n\t\t\t++len;\n\t\t}\n\t}\n\
    \treturn len;", "\tint counter = 0;\n\tstd::string boredoms = {\"I\", \"He\",\
    \ \"She\", \"It\"};\n\tfor(unsigned int i=0; i<S.size(); i++)\n\t{\n\t\tif(boredoms.find(S[i])\
    \ != boredoms.end())\n\t\t\tcounter++;\n\t}\n\treturn counter;", "  int n = S.size();\n\
    \  long boredom_cnt = 0;\n  for (int i = 0; i < n; i++)\n    if (S[i] == 'I' &&\
    \ S[i + 1] == '.' && S[i + 2] == '?' && S[i + 3] == '!')\n      boredom_cnt++;\n\
    \  return boredom_cnt;", "    long boredoms = 0;\n    assert(S.size() > 0);\n\
    \    long n = S.size()-1;\n    while (n>=0) {\n        if (S[n] == '.') {\n  \
    \          if (S[n-1] == '!') {\n                boredoms -= 1;\n            \
    \    S += 'a';\n            }\n            else {\n                S += 'a';\n\
    \            }\n        }\n        else if (S[n] == '?') {\n            S += 'a';\n\
    \        }\n        else if (S[n] == '!') {\n            S += 'a';\n        }\n\
    \        else {\n            break;\n        }\n        n = n - 1;\n    }\n  \
    \  return boredoms;", "    int i;\n    int n = 0;\n    for(int i=0; i < S.length();\
    \ i++){\n        if(S[i] =='i'){\n            n++;\n        }\n    }\n    return\
    \ n;", '    // Your code here', "    auto first_I = S.find(\"I\");\n    bool boredom\
    \ = false;\n    if (first_I != S.npos) {\n        boredom = S.substr(0, first_I).find(\"\
    !\") != std::string::npos\n            || S.substr(0, first_I).find(\"?\") !=\
    \ std::string::npos\n            || S.substr(0, first_I).find(\",\") != std::string::npos;\n\
    \    }\n    return boredom;", "    int n = S.size();\n    long sum = 0;\n    for(int\
    \ i = 0; i < n; i++) {\n        if(S[i] == '.' || S[i] == '?' || S[i] == '!')\
    \ {\n            sum += 1;\n        }\n    }\n    return sum;", "    long bored=0;\n\
    \    for(int i=0;i<S.length();i++) {\n        if(S[i]=='I') {\n            bored++;\n\
    \        }\n    }\n    return bored;", "   long num_bored = 0;\n   \n   for(int\
    \ i = 0; i != S.size(); ++i) {\n      if(S[i] == '.') {\n         continue;\n\
    \      }\n      if(S[i] == '?') {\n         continue;\n      }\n      if(S[i]\
    \ == '!') {\n         continue;\n      }\n      if(S[i] == ' ') {\n         continue;\n\
    \      }\n      if(S[i] == 'I') {\n         num_bored++;\n         continue;\n\
    \      }\n      if(S[i] == '.' || S[i] == '?' || S[i] == '!') {\n         continue;\n\
    \      }\n      if(S[i] == 'I') {\n         num_bored++;\n         continue;\n\
    \      }\n      if(S[i] == '.' || S[i] == '?' || S[i] == '!' || S[i] == 'I') {\n\
    \         num_bored++;\n         continue;\n      }\n      if(S[i] == ' ') {\n\
    \         continue;\n      }\n      if(S[i] == 'I') {\n         num_bored++;\n\
    \         continue;\n      }\n   }\n   return num_bored;", "    int bored = 0;\n\
    \    std::string temp = S;\n    temp.remove_if([&](char c) {\n        switch (c)\
    \ {\n            case '?':\n            case '!':\n                return false;\n\
    \            case '.':\n                return true;\n            default:\n \
    \               return true;\n        }\n    });\n    for (char &c : temp) {\n\
    \        if (c != 'I')\n            return 0;\n    }\n    return ++bored;", " \
    \   int boredoms = 0;\n    char boredoms[100]; // I guess this could be a dynamic\
    \ array but we are not allowed\n    for(int i = 0; i<S.length(); i++) {\n    \
    \    // If the current character of S is 'i' add 1 to boredoms\n        if(S[i]\
    \ == 'i') {\n            boredoms++;\n        } else {\n            // If it is\
    \ not I then check if it is part of a boredom\n            int index = boredoms.index(S[i]);\n\
    \            if(index != -1) {\n                boredoms--;\n            }\n \
    \       }\n    }\n    return boredoms;", "    long boredom = 0;\n    std::string\
    \ boredom_word = \"I\";\n    std::string boredom_last_char = \"I\";\n    for (unsigned\
    \ int i = 0; i < S.size(); ++i) {\n        if (S[i] == boredom_last_char) {\n\
    \            boredom++;\n            boredom_last_char = \"I\";\n            boredom_word.clear();\n\
    \        } else {\n            if (boredom_word == \"I\") {\n                boredom++;\n\
    \                boredom_last_char = \"I\";\n                boredom_word.clear();\n\
    \            } else if (boredom_word != \"\") {\n                assert(boredom_word\
    \ != \"I\");\n                boredom++;\n            }\n            boredom_last_char\
    \ = S[i];\n            boredom_word += S[i];\n        }\n    }\n    return boredom;",
  "    int counter = 0;\n    for (int i = 0; i < S.size(); i++)\n        if (S[i]\
    \ == 'I')\n            counter++;\n    return counter;", "    long boredom_count\
    \ = 0; // count the number of boredoms.\n    for (auto &&i : S) { // iterate over\
    \ each word\n        if (S[0] == 'I' && i == '.') // check if the word is a boredom\n\
    \            boredom_count++; // if so, increment the boredom counter\n    }\n\
    \    return boredom_count; // return the final result", "    // Write your code\
    \ here\n    long count = 0;\n    std::string st;\n    std::istringstream iss(S);\n\
    \    std::string word;\n    while (std::getline(iss, word, '.') || std::getline(iss,\
    \ word, '?') || std::getline(iss, word, '!'))\n    {\n        if (word == \"I\"\
    )\n        {\n            count++;\n        }\n    }\n    return count;", "  \
    \  long bored = 0;\n    int size = S.size();\n    bool isBored = true;\n    for(int\
    \ i = 0; i < size; ++i) {\n        if(S[i] == '.') {\n            ++bored;\n \
    \       }\n        else if(S[i] == '?') {\n            ++bored;\n        }\n \
    \       else if(S[i] == '!') {\n            ++bored;\n        }\n        else\
    \ {\n            isBored = false;\n        }\n    }\n    if(isBored) {\n     \
    \   return bored;\n    }\n    return 0;", "    int boredom = 0;\n    for (int\
    \ i = 0; i < S.length(); i++) {\n        if (S[i] == '.' || S[i] == '?' || S[i]\
    \ == '!')\n            boredom++;\n    }\n    return boredom;", "    // Return\
    \ 0 if the sentence starts with \"I\".\n    if (S[0] == 'I')\n        return 1;\n\
    \    long count = 0;\n    // Iterate through the sentence.\n    for (auto i =\
    \ 2; i < S.size(); ++i) {\n        // Count each boredom that starts with a capital\
    \ letter or an 'I'.\n        if (S[i] == 'I' || S[i] == ' ')\n            count++;\n\
    \    }\n    return count;", "    long cnt = 0;\n    for (int i = 0; i < S.size();\
    \ i++)\n        if (S[i] == 'I')\n            cnt++;\n    return cnt;", "    //\
    \ Your code here\n    long boredoms = 0;\n    for (int i = 0; i < S.size(); i++)\
    \ {\n        if (S[i] == \"I\") {\n            boredoms++;\n        }\n    }\n\
    \    return boredoms;", "    // The string is delimited by '.', '?' or '!'.\n\
    \    assert(S.size() != 0);\n    assert(S[0] == '.' || S[0] == '?' || S[0] ==\
    \ '!');\n    std::stack<char> stk;\n    bool is_bored = false;\n    for (size_t\
    \ i = 1; i < S.size(); ++i) {\n        char c = S[i];\n        if (c == '.') stk.push('.')\n\
    \        else if (c == '?') stk.push('?')\n        else if (c == '!') stk.push('!');\n\
    \        else if (stk.empty() || stk.top() != '!') stk.push(c);\n        else\
    \ if (stk.top() == '!') stk.pop();\n        else is_bored = true;\n    }\n   \
    \ return is_bored ? stk.size() - 1 : 0;", '    // Your code here', "    int num_bored\
    \ = 0;\n    for(int i = 0; i < S.size(); i++){\n        if(S[i] == 'I'){\n   \
    \         num_bored++;\n        }\n    }\n    return num_bored;", "    int boredom_count\
    \ = 0;\n    for(size_t i = 0; i < S.size(); i++) {\n        if(S[i] == '.' ||\
    \ S[i] == '?' || S[i] == '!') boredom_count++;\n    }\n    return boredom_count;",
  "    long count = 0;\n    long boredom = 1;\n    for (int i = 0; i < S.size(); i++)\
    \ {\n        if (S[i] == '.') {\n            boredom = 1;\n        } else if (S[i]\
    \ == '?' || S[i] == '!') {\n            boredom = 0;\n        } else if (S[i]\
    \ == 'I') {\n            count += boredom;\n            boredom = 0;\n       \
    \ } else {\n            boredom++;\n        }\n    }\n    return count;", "  int\
    \ n = S.size();\n  int bored = 0;\n  for(int i = 1; i<n; i++){\n    if(S[i] ==\
    \ '.' || S[i] == '?' || S[i] == '!')\n      bored++;\n  }\n  return bored;", " \
    \   int count = 0;\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] ==\
    \ '.' || S[i] == '?' || S[i] == '!') {\n            count++;\n        }\n    \
    \    if(S[i] == '.') {\n            if(S[i+1] == '.' || S[i+1] == '?' || S[i+1]\
    \ == '!') {\n                count++;\n                i += 2;\n            }\n\
    \        }\n    }\n    return count;", "  int N=0;\n  if(S.find(\"I\")!=std::string::npos){\n\
    \    N=1;\n  }\n  for(int i=0;i<S.size();i++){\n    if(S[i]!=S[i-1] && S[i]!=S[i+1]){\n\
    \      N++;\n    }\n  }\n  return N;", "    // Write your code here\n    // Return\
    \ an int with the number of boredoms in the string S.\n    // You may assume that\
    \ S contains only lowercase letters.\n    \n    long n = 0, i = 0;\n    for (auto\
    \ &it : S) {\n        if (it == '.' || it == '!' || it == '?') {\n           \
    \ i++;\n        }\n    }\n    \n    if (i == 0) {\n        return n;\n    }\n\
    \    for (auto &it : S) {\n        if (it == '.' || it == '!' || it == '?') {\n\
    \            n++;\n        }\n    }\n    return n;", "    long count = 0;\n  \
    \  assert(S != \"\"); // no empty string\n    for(int i = 0; i < S.size(); i++)\
    \ {\n        count += S[i] == '.' || S[i] == '?' || S[i] == '!';\n    }\n    return\
    \ count;", "\tassert (S.length() >= 2); // Must be at least two chars long.\n\t\
    long boredom_count = 0;\n\tstd::string boredom_prefix = \"\";\n\tfor (auto c :\
    \ S) {\n\t\tif (c == '.' || c == '?' || c == '!') {\n\t\t\t// We found a boredom,\
    \ so increment our counter.\n\t\t\tboredom_count++;\n\t\t\tboredom_prefix += c;\n\
    \t\t} else { // Not a boredom.\n\t\t\t// Add one to our counter, except for the\
    \ first word we see.\n\t\t\tif (boredom_prefix.empty())\n\t\t\t\tboredom_count++;\n\
    \t\t\telse\n\t\t\t\tboredom_count--;\n\t\t\tboredom_prefix = \"\";\n\t\t}\n\t\
    }\n\treturn boredom_count;", "    assert(S.size() > 0);\n    long bored = 0;\n\
    \    int i = 0;\n    int n = S.size();\n    while (i < n && S[i] != '.' && S[i]\
    \ != '?' && S[i] != '!') {\n        i++;\n    }\n    i++; // skip the '.'\n  \
    \  while (i < n) {\n        char curr = S[i];\n        while (i < n && S[i] !=\
    \ '.' && S[i] != '?' && S[i] != '!') {\n            i++;\n        }\n        if\
    \ (curr == 'I') {\n            if (i == n) {\n                return -1;\n   \
    \         }\n            bored++;\n        }\n        i++;\n    }\n    return\
    \ bored;", "    long boredoms = 0;\n    std::string::size_type start = 0;\n  \
    \  while (start != S.size()) {\n        std::string::size_type end = S.find('\
    \ ', start);\n        if (end != std::string::npos) {\n            std::string\
    \ boredom = S.substr(start, end - start);\n            if (boredom[0] == \"I\"\
    )\n                boredoms += 1;\n            start = end + 1;\n        } else\
    \ {\n            start = S.find(' ', start);\n        }\n    }\n    return boredoms;",
  "    long bored=0;\n    for(auto &word:S){\n        if(word.compare(0,4,\"I\")==0){\n\
    \            bored++;\n        }\n    }\n    return bored;", "    long count =\
    \ 0;\n    for (int i = 0; i <= S.size(); ++i) {\n        if (S[0] == 'i' && S[i]\
    \ != '.' && S[i] != '?' && S[i] != '!') ++count;\n    }\n    return count;", " \
    \   long count = 0;\n    for(int i = 0; i < S.length(); i++)\n    {\n        if(S[i]\
    \ == '.' || S[i] == '?' || S[i] == '!')\n            count++;\n    }\n    return\
    \ count;", "    std::map<std::string, long> bored;\n    // Build a map with word\
    \ as key and count of its boredoms as value.\n    for (int i = 0; i != S.size();\
    \ ++i)\n        if (S[i] != '.' &&\n            S[i] != '?' &&\n            S[i]\
    \ != '!')\n            bored[S[i]]++;\n    // Return sum of values of map.\n \
    \   return std::accumulate(bored.begin(), bored.end(), 0L);", "    long count\
    \ = 0;\n    assert(S.size() > 0);\n    for(size_t i = 0; i<S.size();i++) {\n \
    \       if(S[i] >= 'a' && S[i] <= 'z') {\n            count++;\n        }\n  \
    \  }\n    return count;", "    // Write your code here\n    // your code goes\
    \ here\n    int count=0;\n    for(int i=0;i<S.size();i++){\n        if(S[i]=='i'){\n\
    \            count++;\n        }\n    }\n    return count;", "    auto begin =\
    \ S.begin();\n    auto end = S.end();\n    long boredoms = 0;\n    while (begin\
    \ != end) {\n        if (std::strncmp(begin, \"I\", 2) == 0)\n            ++boredoms;\n\
    \        ++begin;\n    }\n    return boredoms;", "  assert(S != \"\");\n  bool\
    \ flag = true;\n  for(int i=0; i<S.length()-1; i++){\n    if(S[i] == '.'){\n \
    \     flag = false;\n    }\n  }\n  if(flag){\n    return true;\n  }\n  else{\n\
    \    return false;\n  }", "    int count = 0, i;\n    for (i = 0; i<S.size();i++){\n\
    \        if(S[i]=='I'){\n            count++;\n        }\n    }\n    return count;",
  "  int n = S.size();\n  int ans = 0;\n  char last = '\\0';\n  for (int i = 0; i\
    \ < n; ++i) {\n    if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n      if\
    \ (last == '.' || last == '?' || last == '!')\n        ans += 1;\n    }\n    last\
    \ = S[i];\n  }\n  return ans;", "  int boredoms = 0;\n  int i, len;\n  for (i\
    \ = 0, len = S.length(); i < len; ) {\n    switch (S[i]) {\n    case '?':\n  \
    \  case '!':\n      i++;\n      break;\n    case '.':\n      i++;\n      boredoms++;\n\
    \    }\n  }\n  return boredoms;", "   long count = 0;\n   for(int i = 0; S[i]\
    \ != 0; i++)\n      if(S[i] == 'I')\n         count++;\n   return count;", " \
    \   long boredom=0;\n    for(int i=0;i<S.size();i++) {\n        if (S[i] == 'i'\
    \ && S[i+1] == '.' && S[i+2] == '?') {\n            boredom++;\n        }\n  \
    \  }\n    return boredom;", "    int n = S.size();\n    long long int count =\
    \ 0;\n    for (int i = 0; i < (int) n; ++i) {\n        // The current character\
    \ is a non-space character, so it's not bored.\n        if (S[i] != ' ') {\n \
    \           // Count the number of non-space characters.\n            count +=\
    \ 1;\n            if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n         \
    \       // Found a non-space character. Check to see if it is\n              \
    \  // a bored character.\n                count += 1;\n            }\n       \
    \ }\n        // If we reach the end (or the next character), or we've found a\n\
    \        // bored character, add 1 to the count.\n        if ((i + 1) >= (int)\
    \ n || S[i + 1] == ' ' || S[i + 1] == '!' || S[i + 1] == '?') {\n            count\
    \ += 1;\n        }\n    }\n    return count;", "  // code goes here\n  assert(S.size()\
    \ > 0);\n  long count = 0;\n  for (int i = 0; i < S.size(); i++)\n    if (S[i]\
    \ == '.' || S[i] == '?' || S[i] == '!')\n      count++;\n  return count;", " \
    \ long boredom = 0;\n  for(auto &iter:S) {\n    if (iter == '.' || iter == '!'\
    \ || iter == '?') ++boredom;\n  }\n  return boredom;", "    std::map<char, long>\
    \ freq;\n    for (int i = 0; S[i]; ++i)\n        freq[S[i]]++;\n    for (char\
    \ &v : freq) {\n        if (v == '.' || v == '?' || v == '!') {\n            return\
    \ freq[v];\n        }\n    }\n    return 0;", "   long N = 0;\n   assert(S.size()\
    \ > 0);\n   assert(S.size() % 3 == 0);\n   auto I = S.begin();\n   auto E = [&]()\
    \ { ++N; return I == S.end(); }; // returns true if I moved to end of S\n\n  \
    \ while (I != S.end() && std::isalpha(*I)) { // checks if current word starts\
    \ with \"I\"\n      if (std::strncmp(S, \"I\", 2) == 0) {\n         ++N;\n   \
    \      ++I;\n         while (I != S.end() && std::isalpha(*I)) { // checks if\
    \ I moved to end of S\n            ++I;\n         }\n         while (I != S.end()\
    \ && std::isalpha(*I)) // checks if I moved to end of S\n            ++I;\n  \
    \    }\n   }\n   return N;", "    long counter = 0;\n    int boredom = 0;\n  \
    \  for(int i = 0; i < S.size(); ++i){\n        if(S[i] != '.' && S[i] != '?' &&\
    \ S[i] != '!') continue;\n        if(S[i] == 'I' && S[i+1] == '.' && S[i+2] !=\
    \ '?' && S[i+2] != '!') boredom++;\n    }\n    return boredom;", "    long cnt\
    \ = 0;\n    for(int i=0;i<S.length();i++) {\n        if(S[i]=='.')\n         \
    \   cnt++;\n        if(S[i]=='?' || S[i]=='!')\n            cnt++;\n    }\n  \
    \  return cnt;", "    // TODO: Your code goes here\n    long count = 0;\n    \n\
    \    for(auto &it: S){\n        if(it == '.')\n            count ++;\n    }\n\
    \    \n    return count;", "    // I love you!\n    // I love cats!\n    // I\
    \ don't like fish!\n    // I do not like dogs!\n    // I like cats and dogs.\n\
    \    // I? I? I! I!\n    // I love I! I!\n    // I! I!\n\n    int n_boredoms =\
    \ 0;\n    int count = 0;\n    int i = 0;\n    while(i < S.length()) {\n      \
    \  if (S[i] == 'I') {\n            count++;\n        }\n        else if (S[i]\
    \ == \".\" || S[i] == \"?\" || S[i] == \"!\") {\n            if((i + 1) < S.length()\
    \ && S[i + 1] == '.') {\n                count++;\n                i += 1;\n \
    \           }\n            else if((i + 1) < S.length() && S[i + 1] == '?') {\n\
    \                count++;\n                i += 1;\n            }\n          \
    \  else if((i + 1) < S.length() && S[i + 1] == '!') {\n                count++;\n\
    \                i += 1;\n            }\n            else if((i + 2) < S.length()\
    \ && S[i + 2] == '.') {\n                count++;\n                i += 2;\n \
    \           }\n            else if((i + 2) < S.length() && S[i + 2] == '?') {\n\
    \                count++;\n                i += 2;\n            }\n          \
    \  else if((i + 2) < S.length() && S[i + 2] == '!') {\n                count++;\n\
    \                i += 2;\n            }\n            else {\n                n_boredoms++;\n\
    \            }\n        }\n        i++;\n    }\n    return n_boredoms;", "   \
    \ long boredom_count = 0;\n    for (auto it : S) {\n        switch (it) {\n  \
    \          case \".\": boredom_count++; break;\n            case \"?\": boredom_count++;\
    \ break;\n            case \"!\": boredom_count++; break;\n        }\n    }\n\
    \    return boredom_count;", "    long ans = 0;\n    for (auto it=S.begin();it!=S.end();++it)\
    \ {\n        if ((*it)=='.') {\n            if ((*it-1)=='.') ans++;\n       \
    \ }\n        else if ((*it)=='?') {\n            if ((*it-1)=='?') ans++;\n  \
    \      }\n        else if ((*it)=='!') {\n            if ((*it-1)=='!') ans++;\n\
    \        }\n    }\n    return ans;", "    int len = S.length();\n    long count\
    \ = 0;\n    for(int i = 0; i < len; i++){\n        if(S[i] == 'I'){\n        \
    \    count++;\n        }\n    }\n    return count;", "    long count = 0;\n  \
    \  std::size_t found = S.find(\"I\");\n    while (found != std::npos) {\n    \
    \    found = S.find(\".\", found);\n        if (found != std::npos) {\n      \
    \      found = S.find(\"?\", found);\n            if (found != std::npos) {\n\
    \                found = S.find(\"!\", found);\n            }\n        }\n   \
    \     count++;\n        found = S.find(\".\", found);\n    }\n    return count;",
  "    long result = 0;\n    size_t n = S.size();\n    for(size_t i = 0; i < n; i++)\
    \ {\n        if (S[i] == '.') {\n            result += 1;\n        } else if (S[i]\
    \ == '!') {\n            result += 2;\n        } else if (S[i] == '?') {\n   \
    \         result += 3;\n        }\n    }\n    return result;", "    std::istringstream\
    \ is(S);\n    long bored = 0;\n    std::string word;\n    while (is >> word) {\n\
    \        if (word == \"I\") {\n            ++bored;\n        } else if (word ==\
    \ \".\") {\n            ++bored;\n        } else if (word == \"?\") {\n      \
    \      ++bored;\n        } else if (word == \"!\") {\n            ++bored;\n \
    \       }\n    }\n    return bored;", "    // Write your code here\n    std::map<std::string,int>\
    \ bcounts;\n    for(int i=0;i<S.size();i++){\n        if(S[i]==\"I\"){\n     \
    \       bcounts[\"I\"]++;\n        }\n        else if(S[i]==\".\"){\n        \
    \    bcounts[\".\"]++;\n        }\n        else if(S[i]==\"?\"){\n           \
    \ bcounts[\"?\"]++;\n        }\n        else if(S[i]==\"!\"){\n            bcounts[\"\
    !\"]++;\n        }\n    }\n    return bcounts[\"I\"]+bcounts[\".\"]+bcounts[\"\
    ?\"]+bcounts[\"!\"];", "    long bored = 0;\n    for(int i = 0; i < S.size();\
    \ i++) {\n        if(S[i] == 'I') {\n            if(S[i + 1] == '.') {\n     \
    \           if(S[i + 2] == '.') {\n                    if(S[i + 3] == '?' || S[i\
    \ + 3] == '!') {\n                        bored += 1;\n                    }\n\
    \                }\n            }\n        }\n    }\n    return bored;", "   \
    \ // ++count for boredom sentences\n    // return 0 for normal sentences\n   \
    \ long count = 0;\n    for (int i = 0; i < S.size(); i++) {\n        char c =\
    \ S[i];\n        if (c == '.') {\n            if (i == 0 || S[i-1] != '?' || S[i-1]\
    \ != '!') {\n                ++count;\n            }\n        }\n    }\n    return\
    \ count;", "\tassert(S.size() > 2);\n\tstd::string first_word(S.substr(0, 2));\n\
    \tif (first_word != \"I\") return 0;\n\tint bored_count = 0;\n\tfor (int i = 3;\
    \ i < S.size(); i++) {\n\t\tif (S[i] == '.' || S[i] == '?' || S[i] == '!') bored_count++;\n\
    \t}\n\treturn bored_count;", "    int n = 0;\n    for (auto c : S) {\n       \
    \ if (c == 'I' || c == '.' || c == '?' || c == '!') {\n            n++;\n    \
    \    }\n    }\n    return n;", "  int count = 0; // Your code goes here\n  return\
    \ count;", "  if (S.length() <= 2) return 0;\n  int n = 0;\n  for (int i = 0;\
    \ i < S.length(); i++) {\n    if (S[i] == '.') n++;\n    if (S[i] == '!') n--;\n\
    \    if (S[i] == '?') n++;\n  }\n  return n;", "    long count=0;\n    for(string::iterator\
    \ i=S.begin();i!=S.end();i++)\n    {\n        if(*i==\"I\")\n        count++;\n\
    \    }\n    return count;", "    int l=S.length();\n    int n=0,c=0;\n    for\
    \ (int i=0;i<l;i++)\n    {\n        if (S[i]=='I')\n        {\n            n++;\n\
    \        }\n        if (S[i]=='.' || S[i]=='?' || S[i]=='!')\n        {\n    \
    \        c++;\n        }\n    }\n    return n;", "    // Return the number of\
    \ boredoms in a string S\n    long res = 0;\n    for(int i=0; S[i]!='\\0'; i++){\n\
    \        if(S[i]=='I'){\n            res++;\n        }\n    }\n    return res;",
  "  long ans = 0;\n  for (auto i = S.begin(); i != S.end(); i++) {\n    if (*i ==\
    \ '.') {\n      ans += 1;\n      if (*(i + 1) == '?') ans += 1;\n      if (*(i\
    \ + 1) == '!') ans += 1;\n    } else if (*i == '!') {\n      ans += 1;\n    }\
    \ else if (*i == '?') {\n      ans += 1;\n    } else if (*i == '.' && *(i + 1)\
    \ == '.') {\n      ans += 1;\n    } else if (*i == '.' && *(i + 1) == '!') {\n\
    \      ans += 1;\n    } else if (*i == '.' && *(i + 1) == '?') {\n      ans +=\
    \ 1;\n    } else if (*i == '?' && *(i + 1) == '.') {\n      ans += 1;\n    } else\
    \ if (*i == '?' && *(i + 1) == '!') {\n      ans += 1;\n    } else if (*i == '?'\
    \ && *(i + 1) == '?') {\n      ans += 1;\n    } else {\n      ans += 0;\n    }\n\
    \  }\n  return ans;", "  int bored = 0;\n  int n = S.size();\n  // TODO: Write\
    \ your code here\n  return 0;", "  int boredoms = 0;\n  for (int i = 0; i < (int)\
    \ S.length(); ++i) {\n    if (S[i] == '.') {\n      ++boredoms;\n    } else if\
    \ (S[i] == '?') {\n      ++boredoms;\n    } else if (S[i] == '!') {\n      ++boredoms;\n\
    \    }\n  }\n  return boredoms;", "    long boredom = 0;\n    if (S.find(\"/\"\
    ) != std::string::npos) {\n        for (int i = 0; i < S.length(); i++) {\n  \
    \          if (S[i] == '.')\n                boredom++;\n            if (S[i]\
    \ == '?')\n                boredom++;\n            if (S[i] == '!')\n        \
    \        boredom++;\n        }\n    }\n    return boredom;", "    int freq[26];\n\
    \    for(auto x:S) {\n        freq[x-'a']++;\n    }\n    int ans = 0;\n    for(int\
    \ i = 65;i<91;i++) {\n        if(freq[i]==0) continue;\n        if(strncmp(\"\
    i\",S.c_str(),i)==0) {\n            ans++;\n        }\n    }\n    return ans;",
  "  // Complete the is_bored function below.\n  // Feel free to use any method you\
    \ like!\n  std::ifstream is;\n  is.open(S.c_str());\n  if (is.fail()) {\n    cout\
    \ << \"Error opening file!\" << endl;\n    return -1;\n  }\n  string word;\n \
    \ long count = 0;\n  while (getline(is, word, '.')) {\n    if (word == \"I\")\
    \ {\n      count++;\n    }\n  }\n  is.close();\n  return count;", "    int count\
    \ = 0;\n    for (int i = 0; i < S.length(); i++) {\n        if (S[i] == 'i') {\n\
    \            count++;\n        }\n    }\n    return count;", "  // Your code goes\
    \ here\n  long count = 0;\n  for(int i = 0; i<S.size();i++){\n    if(S[i] == \"\
    I\"){\n      count++;\n    }\n  }\n  return count;", "    long count = 0;\n  \
    \  for (auto i = S.begin(); i != S.end(); ++i) {\n        if (*i == 'I') count++;\n\
    \    }\n    return count;", "    long count=0;\n    for (int i = 0; i < S.length();\
    \ i++)\n    {\n        if (S[i] == 'i')\n        {\n            count++;\n   \
    \     }\n    }\n    return count;", "    int boredom = 0;\n    for(int i = 0;\
    \ i < S.size(); ++i)\n    {\n        if(S[0] == 'i')\n            boredom++;\n\
    \    }\n    return boredom;", "  // TODO: Write code here\n  assert(S.size() >=\
    \ 2);\n  int count = 0;\n  for (int i = 0; i < S.size(); i++) {\n    if (S[0]\
    \ == 'I' && S[i+1] == '.') {\n      count++;\n    }\n  }\n  return count;", '    //
    Write your logic here', "    int N = 0;\n    for(int i=0; i<S.length(); i++){\n\
    \        if(S.at(i)=='i'){\n            N+=1;\n        }\n    }\n    return N;",
  "  int n = S.size();\n  long bored = 0;\n  for (int i = 0; i < n; i++) {\n    if\
    \ (S[i] == 'I' || S[i] == '.' || S[i] == '?' || S[i] == '!')\n      bored++;\n\
    \  }\n  return bored;", "    std::vector<std::pair<std::string, int> > words;\n\
    \    std::string token;\n    long boredoms = 0;\n    std::stringstream ss(S);\n\
    \    \n    while(getline(ss, token, ',')) {\n        words.emplace_back(token,\
    \ 0);\n    }\n    \n    for(auto &word : words) {\n        if(word.first == \"\
    I\") {\n            boredoms++;\n        }\n    }\n    return boredoms;", "  \
    \  // Write your code here\n    long count = 0;\n    for (size_t i = 0; i < S.size();\
    \ i++)\n    {\n        if (S[i] == 'I')\n            count++;\n    }\n    return\
    \ count;", "    std::map<std::string,long> m;\n    long ans = 0;\n    for(int\
    \ i=0;i<S.size();i++){\n        auto it = m.find(S[i]);\n        if (it != m.end())\
    \ {\n            ans += it->second;\n        } else {\n            long temp =\
    \ 0;\n            std::istringstream is(S[i]);\n            is >> temp;\n    \
    \        m.insert(std::pair<std::string,long>(S[i], temp));\n            ans +=\
    \ temp;\n        }\n    }\n    return ans;", "    int boredom_count = 0;\n   \
    \ for(int i = 0; S[i] != '\\0'; i++)\n    {\n        if(S[i] == 'I' && i != 0)\
    \ {\n            boredom_count++;\n        }\n    }\n    return boredom_count;",
  "    long count = 0;\n    size_t pos;\n    for (pos = S.size() - 1; pos >= 0; --pos)\
    \ {\n        if (S[pos] == '.') {\n            count = 0;\n        }\n       \
    \ else if (S[pos] == '?') {\n            count = 1;\n        }\n        else if\
    \ (S[pos] == '!') {\n            count = 2;\n        }\n        else {\n     \
    \       assert(false);\n        }\n        if (count == 3) {\n            break;\n\
    \        }\n    }\n    return count;", "    int count = 0;\n    for(int i = 0;\
    \ i <S.length(); i++)\n    {\n        if(S[i] == '.' || S[i] == '?' || S[i] ==\
    \ '!')\n            count++;\n    }\n    return count;", "    std::map<long, bool>\
    \ m;\n    m.insert(std::pair<long, bool>(1, false));\n    long boredoms = 0;\n\
    \    std::string ss[];\n    for (size_t i = 0; i != S.size(); i++) {\n       \
    \ if (S[i] == '.') {\n            boredoms += 1;\n            ss[i] = S;\n   \
    \     } else if (S[i] == '!') {\n            boredoms += 1;\n            ss[i]\
    \ = S;\n        } else if (S[i] == '?') {\n            boredoms += 1;\n      \
    \      ss[i] = S;\n        }\n    }\n    std::string ss[5];\n    for (int i =\
    \ 0; i != 5; i++) {\n        boredoms += is_bored_helper(ss[i]);\n    }\n    return\
    \ boredoms;", "    int n = S.length();\n    int bored = 0;\n    for (int i = 0;\
    \ i < n; ++i) {\n        // Your code goes here\n        bored = bored + __builtin_popcount(S[i]);\n\
    \    }\n    return bored;", "    int boredoms = 0;\n    for(int i=0; S[i]; i++)\
    \ {\n        if(S[i] == '.') {\n            boredoms++;\n        } else if(S[i]\
    \ == '?') {\n            boredoms++;\n        } else if(S[i] == '!') {\n     \
    \       boredoms++;\n        }\n    }\n    return boredoms;", "    long count\
    \ = 0; // To keep count of the number of boredoms\n    std::string boredoms =\
    \ {\"I.\", \"i.\", \"I am\", \"I am \",\n                           \"I?\", \"\
    am I\", \"I was\", \"I his\",\n                           \"I was?\", \"am I not\"\
    , \"am I was?\"};\n    for (int i = 0; i <= S.size(); i++) {\n        if (boredoms.find(S[i])\
    \ != boredoms.end()) count++;\n    }\n    return count;", "  // Print \"The string\
    \ S starts with \"I\"\"\n  // Print \"The string S contains \".\"\n  // Print\
    \ \"The string S contains \"?\"\n  // Print \"The string S contains \"!\"\n  assert(S.size()\
    \ > 0);\n  assert(S.size() <= 100);\n  long result = 0;\n  assert(S[0] == 'I');\n\
    \  int count_dot = 0;\n  int count_question = 0;\n  int count_exclamation = 0;\n\
    \  for(int i = 1; i < S.size(); ++i) {\n    char c = S[i];\n    if(c == '.') {\n\
    \      count_dot++;\n    } else if(c == '?') {\n      count_question++;\n    }\
    \ else if(c == '!') {\n      count_exclamation++;\n    } else {\n      assert(false);\n\
    \    }\n    if(c == '.' || c == '?' || c == '!') {\n      assert(false);\n   \
    \ }\n  }\n  assert(count_dot < count_question);\n  assert(count_question < count_exclamation);\n\
    \  assert(count_dot == 0 || count_question < count_dot);\n  assert(count_dot ==\
    \ 0 || count_exclamation < count_question);\n  result += (count_dot == 0) ? 1\
    \ : 0;\n  result += (count_question < count_dot) ? 1 : 0;\n  result += (count_exclamation\
    \ < count_question) ? 1 : 0;\n  assert(result <= 2);\n  return result;", "   \
    \ // Your code goes here\n    std::istringstream iss(S);\n    std::string token;\n\
    \    bool bored = false;\n    int boredom_count = 0;\n\n    std::getline(iss,\
    \ token);\n    while (iss)\n    {\n        if (token == \"I\")\n        {\n  \
    \          bored = true;\n        }\n\n        std::getline(iss, token);\n   \
    \ }\n    if (iss)\n    {\n        bored = true;\n    }\n    return bored? boredom_count\
    \ : 0;", "    // ++p is used to increment the count of boredoms\n    long p =\
    \ 0;\n    // i is the index pointer of the first occurrence of 'I'\n    long i\
    \ = 0;\n    // while loop checks the string\n    while (i < S.size()) {\n    \
    \    // If 'I' is the first character of the string and there is no\n        //\
    \ space between consecutive 'I' then increment the count\n        if (S[i] ==\
    \ 'I' && i < S.size() - 1) {\n            ++p;\n        }\n        // If there\
    \ is a space between consecutive 'I', then decrement\n        // the count.\n\
    \        else if (S[i] == ' ') {\n            --p;\n        }\n        // increment\
    \ index pointer\n        ++i;\n    }\n    return p;", "  // Get the first character\
    \ of the string\n  char c = S[0];\n  // If it's not a \".\", \"?\", or \"!\" then\
    \ it's not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  //\
    \ If the string starts with \"I\", it's bored\n  if (c == 'I')\n    return 1;\n\
    \  // Get the first character of the next string\n  c = S[1];\n  // If it's not\
    \ a \".\", \"?\", or \"!\" then it's not bored\n  if (c != '.' && c != '?' &&\
    \ c != '!')\n    return 0;\n  // If it's \"I\", it's bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"!\" then it's\
    \ not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  // If it's\
    \ not \"I\" and not \".\", \"?\", or \"!\" then it's not bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"!\" then it's\
    \ not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  // If it's\
    \ not \"I\" and not \".\", \"?\", or \"!\" then it's not bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"!\" then it's\
    \ not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  // If it's\
    \ not \"I\" and not \".\", \"?\", or \"!\" then it's not bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"!\" then it's\
    \ not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  // If it's\
    \ not \"I\" and not \".\", \"?\", or \"!\" then it's not bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"!\" then it's\
    \ not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  // If it's\
    \ not \"I\" and not \".\", \"?\", or \"!\" then it's not bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"!\" then it's\
    \ not bored\n  if (c != '.' && c != '?' && c != '!')\n    return 0;\n  // If it's\
    \ not \"I\" and not \".\", \"?\", or \"!\" then it's not bored\n  if (c == 'I')\n\
    \    return 1;\n  // If it's not \"I\" and not \".\", \"?\", or \"", "  // Complete\
    \ this function\n  long boredoms = 0;\n\n  for (int i = 0; i < S.size(); i++)\
    \ {\n    if (S[i] == 'I') {\n      boredoms += 1;\n    }\n  }\n\n  return boredoms;",
  "    std::map<std::string,long> m; //key = boredoms , value = number of occurences\n\
    \    int pos = 0;\n    int boredom_count = 0;\n    for (int i = 0; i < S.length();\
    \ i++) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n         \
    \   pos = i;\n        }\n        if (S[i] == S[0]) {\n            boredom_count++;\n\
    \            S.replace(pos, 1, \" \"); //remove first char of sentence\n     \
    \   }\n    }\n    int size = S.size();\n    for (int i = 1; i < size; i++) {\n\
    \        if (S[i] == S[0]) {\n            boredom_count++;\n            S.replace(i,\
    \ 1, \" \"); //remove first char of sentence\n        }\n    }\n    m.insert({S,\
    \ boredom_count});\n    for (auto i : m) {\n        if (i.first == \"I\") {\n\
    \            return i.second;\n        }\n    }\n    return -1;", "  std::map<std::string,long>\
    \ boredoms;\n  \n  for (auto &s : S){\n    boredoms.insert(std::pair<std::string,\
    \ long>(s,0));\n  }\n  \n  for (auto &s : S){\n    if (s[0] == 'I'){\n      boredoms[s]\
    \ += 1;\n    }\n  }\n  return boredoms.size();", "    long bored = 0;\n    std::string\
    \ sentence = S;\n    \n    // Start with 0 boredoms for each word.\n    std::transform(sentence.begin(),\
    \ sentence.end(), sentence.begin(), ::tolower);\n    \n    // Ignore punctuations\n\
    \    auto it = std::find_if(sentence.begin(), sentence.end(), [](char c){ return\
    \ !std::isalnum(c); });\n    sentence.erase(it, sentence.end());\n    \n    //\
    \ Ignore special chars\n    it = std::find_if(sentence.begin(), sentence.end(),\
    \ [](char c){ return !std::isspace(c); });\n    sentence.erase(it, sentence.end());\n\
    \    \n    // Find any word that starts with \"I\"\n    std::string::size_type\
    \ Ipos = 0;\n    it = std::find_if(sentence.begin(), sentence.end(), [&Ipos](char\
    \ c){ return c == 'i'; });\n    Ipos = it - sentence.begin();\n    \n    // If\
    \ 'I' has been found, find the following period and the following period\n   \
    \ it = std::find_if(sentence.begin()+Ipos, sentence.end(), [&Ipos](char c){ return\
    \ c == '.' && Ipos == 2});\n    \n    // If period is found then increase boredom\
    \ by 1\n    if(it != sentence.end() && Ipos == 2) {\n        bored++;\n    }\n\
    \    \n    // Return boredom\n    return bored;", "    long count = 0;\n    //\
    \ Your code goes here!\n    return count;", "    int count = 0, bored = 1;\n \
    \   for (int i = 0; i < S.size(); i++) {\n        switch (S[i]) {\n        case\
    \ '?':\n        case '!':\n            bored = 0;\n            count++;\n    \
    \        break;\n        default:\n            if (S[i] == '.') {\n          \
    \      count++;\n            }\n        }\n    }\n    return bored && count ==\
    \ 1;", "    // Write your code here\n    int count = 0;\n    for(int i=0;i<S.size();i++)\
    \ {\n        if(S[i] == 'I') {\n            count += 1;\n        }\n    }\n  \
    \  return count;", "    // Write your code here\n    return 0;", "    int countI\
    \ = 0;\n    for (int i = 0; i < S.size(); i++) {\n        switch (S[i]) {\n  \
    \      case 'I':\n            countI++;\n            break;\n        }\n    }\n\
    \    return countI;", "    assert(S.size() > 0);\n    long ans = 0;\n    int pos\
    \ = 0;\n    while(pos < S.size()) {\n        if(S[pos] == '.') {\n           \
    \ ans = ans + 1;\n            while(pos < S.size() && S[pos] != '.') {\n     \
    \           pos++;\n            }\n        }\n        if(S[pos] == '?') {\n  \
    \          ans = ans + 1;\n            while(pos < S.size() && S[pos] != '?')\
    \ {\n                pos++;\n            }\n        }\n        if(S[pos] == '!')\
    \ {\n            ans = ans + 1;\n            while(pos < S.size() && S[pos] !=\
    \ '!') {\n                pos++;\n            }\n        }\n        pos++;\n \
    \   }\n    return ans;", "    long count = 0;\n    long n = 0;\n    for (char\
    \ &c : S)\n        if (std::tolower(c) == '.' || std::tolower(c) == '?' || std::tolower(c)\
    \ == '!')\n            ++count;\n        else\n            ++n;\n    return count;",
  "    int boredCount = 0;\n    int i = 0;\n    char boredoms[5][5] = {\n        \"\
    bored.\", \"bored.\", \"boreed.\", \"boreed\", \"borein\"\n    };\n\n    while\
    \ (S[i] != '\\0') {\n        if (isupper(S[i])) {\n            boredCount++;\n\
    \            i++;\n        }\n        else {\n            if (boredCount == 0)\
    \ {\n                i = 0;\n                boredCount++;\n            }\n  \
    \          else if (boredCount > 0) {\n                if (S[i] == '.' || S[i]\
    \ == '?' || S[i] == '!') {\n                    i++;\n                    boredCount--;\n\
    \                }\n            }\n        }\n    }\n    return boredCount;",
  "    long boredoms = 0;\n    // Declare a vector of strings to store the words.\n\
    \    std::vector<std::string> words;\n    // Initialize a vector to store the\
    \ boredom words.\n    // For boredom words, the vector will be empty.\n    for\
    \ (auto &word : S) {\n        // If the current word is a boredom word.\n    \
    \    if (word == \"I\") {\n            // Add the word to the boredom vector.\n\
    \            boredoms += 1;\n        }\n        // If the current word is a punctuation\
    \ mark.\n        else if (word == \".\" || word == \"?\" || word == \"!\") {\n\
    \            // Add the word to the punctuation vector.\n            words.push_back(word);\n\
    \        }\n    }\n    // Return the number of boredoms.\n    return boredoms;",
  "    long N = 0;\n    int i = 0;\n    while (i != S.size()) {\n        if (islower(S[i]))\
    \ {\n            while (i != S.size() && islower(S[i - 1])\n                 \
    \   && S[i] == S[i - 1]) {\n                i++;\n            }\n            if\
    \ (i != S.size() && isupper(S[i])) {\n                N++;\n                while\
    \ (i != S.size() && !islower(S[i - 1])\n                        && S[i] == S[i\
    \ - 1]) {\n                    i++;\n                }\n            }\n      \
    \  } else if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            while\
    \ (i != S.size() && S[i] == S[i - 1]) {\n                i++;\n            }\n\
    \        }\n    }\n    return N;", "    int count = 0;\n    int n = S.size();\n\
    \    for (int i = 0; i < n; i++) {\n        if (S[i] == '.' || S[i] == '?' ||\
    \ S[i] == '!')\n            count++;\n    }\n    return count;", "    long cnt\
    \ = 0;\n    // Loop through the given string from left to right\n    for (int\
    \ i = 0; i <= S.size(); i++) {\n        // If the ith character is '.', then increment\
    \ the count\n        // If the ith character is ?, increment the count\n     \
    \   // If the ith character is !, increment the count\n        if (S[i] == '.')\
    \ {\n            cnt += 1;\n        } else if (S[i] == '?') {\n            cnt\
    \ += 1;\n        } else {\n            cnt += 1;\n        }\n    }\n    return\
    \ cnt;", "    long N = 0;\n    std::string st = \"I\";\n    for (auto &word :\
    \ S) {\n        if (word == st) {\n            N++;\n        }\n    }\n    return\
    \ N;", "  int len = 0;\n  int count = 0;\n  char last = ' ';\n  for (int i = 0;\
    \ i < S.size(); i++) {\n    last = S[i];\n    if (last == '.' || last == '?' ||\
    \ last == '!') {\n      count++;\n    }\n    if (last == 'I') {\n      len++;\n\
    \    }\n  }\n  return count;", "    long cnt = 0;\n    for (int i = 0; i < S.size();\
    \ i++) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!')\n           \
    \ cnt++;\n    }\n    return cnt;", "    // Write your code here\n    int len1\
    \ = S.size();\n    std::string str = S;\n    bool flag = false;\n    long ans\
    \ = 0;\n    for (int i = 0; i < len1; i++) {\n        if (S[i] == '.') {\n   \
    \         if (flag) {\n                ans += 1;\n            }\n            flag\
    \ = true;\n        } else {\n            if (flag) {\n                ans += 1;\n\
    \            }\n            flag = false;\n        }\n    }\n    return ans;",
  "    long bored = 0;\n    // TODO: Your code goes here\n    return bored;", "\t\
    int boredom_count = 0;\n\tint i = 0, j = 0; // index\n\twhile (i < S.size() &&\
    \ j < S.size() && S[i] != \".\" && S[j] != \".\" && S[i] != '?' && S[j] != '?'\
    \ && S[i] != '!' && S[j] != '!') {\n\t\tif (S[i] == 'I' && S[j] == 'I') {\n\t\t\
    \tboredom_count++;\n\t\t\ti++; j++;\n\t\t} else if (S[i] == 'I' && S[j] == '.')\
    \ {\n\t\t\tboredom_count++;\n\t\t\ti++; j++;\n\t\t} else if (S[i] == '.' && S[j]\
    \ == '.') { // dot \".\" is a sentence-delimiter\n\t\t\ti++; j++;\n\t\t} else\
    \ {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn boredom_count;", "  int i;\n  long num =\
    \ 0;\n  int flag = 0;\n  for (i = 0; i < S.size(); i++) {\n    if (S[i] == '.')\
    \ {\n      if (flag == 1) {\n        flag = 0;\n        num = num + 1;\n     \
    \ }\n    } else if (S[i] == '?') {\n      if (flag == 0) {\n        flag = 1;\n\
    \        num = num + 1;\n      }\n    } else if (S[i] == '!') {\n      if (flag\
    \ == 0) {\n        flag = 1;\n        num = num + 1;\n      }\n    }\n  }\n  return\
    \ num;", "    long count = 0;\n    bool b1 = S.find(\"I\") != std::string::npos;\n\
    \    bool b2 = S.find(\".\") != std::string::npos;\n    bool b3 = S.find(\"?\"\
    ) != std::string::npos;\n    bool b4 = S.find(\"!\") != std::string::npos;\n \
    \   bool b5 = S.find(\"bore\") != std::string::npos;\n    bool b6 = S.find(\"\
    bored\") != std::string::npos;\n    bool b7 = S.find(\"bores\") != std::string::npos;\n\
    \    bool b8 = S.find(\"bores\") != std::string::npos;\n    bool b9 = S.find(\"\
    bored\") != std::string::npos;\n    bool b10 = S.find(\"bored\") != std::string::npos;\n\
    \    bool b11 = S.find(\"bores\") != std::string::npos;\n    bool b12 = S.find(\"\
    bore\") != std::string::npos;\n    bool b13 = S.find(\"bore\") != std::string::npos;\n\
    \    bool b14 = S.find(\"bored\") != std::string::npos;\n    bool b15 = S.find(\"\
    bore\") != std::string::npos;\n    bool b16 = S.find(\"bored\") != std::string::npos;\n\
    \    bool b17 = S.find(\"bored\") != std::string::npos;\n    bool b18 = S.find(\"\
    bored\") != std::string::npos;\n    bool b19 = S.find(\"bored\") != std::string::npos;\n\
    \    bool b20 = S.find(\"bored\") != std::string::npos;\n    bool b21 = S.find(\"\
    bored\") != std::string::npos;\n    bool b22 = S.find(\"bore\") != std::string::npos;\n\
    \    bool b23 = S.find(\"bore\") != std::string::npos;\n    bool b24 = S.find(\"\
    bored\") != std::string::npos;\n    bool b25 = S.find(\"bored\") != std::string::npos;\n\
    \    bool b26 = S.find(\"bored\") != std::string::npos;\n    bool b27 = S.find(\"\
    bore\") != std::string::npos;\n    bool b28 = S.find(\"bored\") != std::string::npos;\n\
    \    bool b29 = S.find(\"bored\") != std::string::npos;\n    bool b30 = S.find(\"\
    bore\") != std::string::npos;\n    bool b31 = S.find(\"bored\") != std::string::npos;\n",
  "  int N = S.length();\n  int cnt = 0;\n  for (int i = 0; i < N; i++) {\n    char\
    \ c = S[i];\n    if (c == '.' || c == '?' || c == '!') {\n      cnt++;\n    }\n\
    \  }\n  return cnt;", "  long n = 0;\n  for(int i = 0; i<S.length(); i++){\n \
    \   \n    if(S[i]=='I'){\n      n++;\n    }\n    \n    \n  }\n  \n  return n;",
  "    long count = 0;\n    std::string word;\n    std::istringstream iss(S);\n  \
    \  std::string token;\n    while(std::getline(iss,token,'.','?','!')) {\n    \
    \    if(token == \"I\") count ++;\n    }\n    return count;", "    int boredom_count\
    \ = 0;\n    for (char c : S) {\n        if (c == 'I' || c == '.' || c == '?' ||\
    \ c == '!') {\n            boredom_count++;\n        }\n    }\n    return boredom_count;",
  "  if (S.length()<=1)\n    return 0;\n  if (S[0]!='I')\n    return 0;\n  int freq[100];\n\
    \  assert(S.size()<100);\n  for (auto &c:S) {\n    freq[c-'A']++;\n  }\n  return\
    \ freq[S.size()-1];", "    // Write your code here\n    return 1;", "    // TODO:\
    \ Build a std::unordered_map of the string words and the frequencies\n    // of\
    \ the words before we start counting boredoms.\n    // Your code should use the\
    \ map to check whether the string S starts with \"I\",\n    // but should NOT\
    \ count \"I\" itself as a frequency.\n\n    // Example string \"Isaac!?? was a\
    \ great.\" --> frequency of \"I\" should be 1.\n    // \"Isaac!?? was a great!\"\
    \ --> frequency of \"I\" should be 1.\n    // \"Isaac!?? was a great.?\" --> frequency\
    \ of \"I\" should be 2.\n    // \"Isaac!?? was a great!?\" --> frequency of \"\
    I\" should be 2.\n    // \"Isaac!?? was a great?\" --> frequency of \"I\" should\
    \ be 2.\n    // \"Isaac!?? was a great!??\" --> frequency of \"I\" should be 2.\n\
    \    // \"Isaac!?? was a great.!\" --> frequency of \"I\" should be 2.\n    //\
    \ \"Isaac!?? was a great!.\" --> frequency of \"I\" should be 2.\n\n    // Example\
    \ string \"Hey! Hey! Hey!\" --> frequency of \"Hey\" should be 3.\n    // \"Hey!\
    \ Hey! Hey!!\" --> frequency of \"Hey\" should be 3.\n    // \"Hey! Hey! Hey!?\"\
    \ --> frequency of \"Hey\" should be 3.\n    // \"Hey! Hey! Hey!!?\" --> frequency\
    \ of \"Hey\" should be 3.\n\n    // NOTE: Do not count white spaces in the frequencies.\n\
    \    // We may get tricky if the string S contains multiple sentences.\n    //\
    \ If multiple sentences are there, then your code should add each separate\n \
    \   // sentence's frequency to the previous frequency. Example: \"Isaac!?? was\
    \ a\n    // great. Isaac!?? was a great. Isaac!?? was a great.\"\n\n    // Once\
    \ you finish your code, return the total frequencies of boredoms.\n    // The\
    \ code below is for you to debug (do not write main() functions).\n    return\
    \ 0;", '    ', "    assert(S.size() > 0);\n    int n = 0;\n    for (int i = 0;\
    \ i < S.size(); ++i) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!')\n\
    \            ++n;\n    }\n    return n;", "    long count = 0;\n    for (int i\
    \ = 0; S[i] != '\\0'; i++) {\n        if (S[i] == '.') {\n            if (S[i\
    \ + 1] == '.') {\n                count += 1;\n            }\n            if (S[i\
    \ + 1] == '?') {\n                count += 1;\n            }\n            if (S[i\
    \ + 1] == '!') {\n                count += 1;\n            }\n        }\n    }\n\
    \    return count;", "    if (S == \".\")\n        return 0;\n    if (S == \"\
    ?\")\n        return 0;\n    if (S == \"!\")\n        return 0;\n\n    bool isVowel\
    \ = false;\n    for (int i = 0; i < S.length(); i++) {\n        if (S[i] == 'a'\
    \ || S[i] == 'e' || S[i] == 'i' || S[i] == 'o' || S[i] == 'u' || S[i] == 'y')\n\
    \            isVowel = true;\n    }\n\n    if (isVowel == true) {\n        int\
    \ count = 0;\n        for (int i = 0; i < S.length(); i++)\n            if (S[i]\
    \ == 'i' || S[i] == 'e' || S[i] == 'o' || S[i] == 'u') {\n                count++;\n\
    \            }\n\n        return count;\n    }\n\n    int count = 0;\n    for\
    \ (int i = 0; i < S.length(); i++) {\n        if (S[i] == 'i' || S[i] == 'e' ||\
    \ S[i] == 'o' || S[i] == 'u')\n            count++;\n    }\n\n    return count;",
  "    assert(S.length() > 1);\n    int bored = 0;\n    for (size_t i = 0; i < S.length();\
    \ ++i) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n         \
    \   bored += 1;\n        }\n    }\n    return bored;", "    int counter = 0;\n\
    \    // TODO\n    for(int i = 0; i < S.length(); i++) {\n        if(S[i] == 'I'){\n\
    \            counter++;\n        }\n    }\n    return counter;", "    int n =\
    \ S.size();\n    int boredom = 0;\n    for(int i=0; i<n; i++)\n    {\n       \
    \ if(S[i] == 'I' && S[i+1] == '.')\n            boredom++;\n        if(S[i] ==\
    \ 'I' && S[i+1] == '?')\n            boredom++;\n        if(S[i] == 'I' && S[i+1]\
    \ == '!')\n            boredom++;\n    }\n    return boredom;", "    int result\
    \ = 0;\n    std::string word;\n    int counter = 0;\n    for (auto& c: S) {\n\
    \        if (c == '.') {\n            counter++;\n            word = \"\";\n \
    \       } else if (c == '?') {\n            counter++;\n            word = \"\"\
    ;\n        } else if (c == '!') {\n            counter++;\n            word =\
    \ \"\";\n        } else {\n            word += c;\n        }\n    }\n    while(word.size()\
    \ > 0) {\n        if(word.at(0) == 'I'){\n            result++;\n        }\n \
    \       word.erase(0, 1);\n    }\n    return result;", "    // Your code goes\
    \ here\n    long bored = 0;\n    for (long i = 0; i < S.size(); i++)\n    {\n\
    \        if (S[i] == '.' || S[i] == '?' || S[i] == '!')\n        {\n         \
    \   if (S[i] == S[0])\n            {\n                bored++;\n            }\n\
    \        }\n    }\n    return bored;", "    int n = S.size();\n    long ans =\
    \ 0;\n    for(int i=0; i<n; ++i) {\n        if(S[i] == '.') {\n            ans\
    \ += 1;\n        }\n        if(S[i] == '?') {\n            ans += 1;\n       \
    \ }\n        if(S[i] == '!') {\n            ans += 1;\n        }\n    }\n    return\
    \ ans;", "  assert(S.size() > 0);\n  int cnt = 0;\n  for (int i = 0; i < S.size();\
    \ ++i) {\n    if (S[i] == '.') cnt++;\n    else if (S[i] == '?' || S[i] == '!')\
    \ cnt--;\n    else cnt++;\n  }\n  return cnt;", "  std::map<std::string,long>\
    \ m;\n  std::string temp;\n  for (int i = 0; i < S.length(); i++) {\n    if (S[i]\
    \ == '.') {\n      if (i == 0 || S[i-1] == '?' || S[i-1] == '!')\n        m[temp]++;\n\
    \      temp = S.substr(0, i);\n    }\n  }\n  if(m.count(temp))\n    return m[temp];\n\
    \  else\n    return 0;", "    assert(S.size() == 5);\n    // Declare and initialize\
    \ the count variable.\n    int count = 0;\n\n    // Read each character in S into\
    \ char variable.\n    for (int i = 0; i < S.size(); ++i) {\n        // If current\
    \ character is equal to 'I', increment the count by 1.\n        if (S[i] == 'I')\
    \ {\n            ++count;\n        }\n    }\n    return count;", "    long boredoms\
    \ = 0 ;\n    char boredoms_str[] = \"I\" ;\n    std::string boredom_str = \" \"\
    \ ;\n    for(int i = 0; i < S.length(); i++) {\n        boredoms += boredoms_str.count(S[i]);\n\
    \        boredom_str += S[i];\n    }\n    return boredoms ;", "    long boredom_count\
    \ = 0;\n    long i = 0;\n    for (auto &word: S) {\n        if (word == \"I\"\
    ) {\n            if (i == 0) {\n                boredom_count += 1;\n        \
    \    }\n            i += 1;\n        } else if (word == \".\") {\n           \
    \ if (i == 0) {\n                boredom_count += 1;\n            }\n        \
    \    i += 1;\n        } else if (word == \"?\") {\n            if (i == 0) {\n\
    \                boredom_count += 1;\n            }\n            i += 1;\n   \
    \     } else if (word == \"!\") {\n            if (i == 0) {\n               \
    \ boredom_count += 1;\n            }\n            i += 1;\n        }\n    }\n\
    \    return boredom_count;", "    std::string words[] = {\"I\", \"are\", \"good\"\
    , \"!\", \"!\", \"!\", \"?\", \"?\", \".\", \".\"};\n    std::sort(std::begin(words),\
    \ std::end(words));\n    for(auto it = std::begin(words); it != std::end(words);\
    \ ++it) {\n        if(S.find(*it) != 0) {\n            return true;\n        }\n\
    \    }\n    return false;", "  int cnt=0;\n  if(S == \"I\")\n    return 1;\n \
    \ for(int i=0;i<S.length();++i)\n    if(S[i] == '.' || S[i] == '?' || S[i] ==\
    \ '!')\n      cnt++;\n  return cnt;", "    auto count_i = [](std::string S) {\n\
    \        std::cin >> S;\n        long count = 0;\n        for(int i = 0; i < S.size();\
    \ i++)\n        {\n            if(S[i] == \"I\") ++count;\n        }\n       \
    \ return count;\n    };\n    auto count_i = [&count_i](std::string S) {\n    \
    \    auto count_i = [](std::string S) {\n            std::cin >> S;\n        \
    \    long count = 0;\n            for(int i = 0; i < S.size(); i++)\n        \
    \    {\n                if(S[i] == \"I\") ++count;\n            }\n          \
    \  return count;\n        };\n        std::cin >> S;\n        long count = 0;\n\
    \        for(int i = 0; i < S.size(); i++)\n        {\n            if(S[i] ==\
    \ \"I\") ++count;\n        }\n        return count;\n    };\n    std::cin >> S;\n\
    \    long count = 0;\n    for(int i = 0; i < S.size(); i++)\n    {\n        if(S[i]\
    \ == \"I\") ++count;\n    }\n    return count;", "  // Complete the code here\n\
    \  // You do not have to check for empty string S\n  std::string boredoms_found;\n\
    \  boredoms_found = \"I\";\n  int boredoms = 0;\n  for (size_t i = 0; i < S.size();\
    \ i++) {\n    if (S[i] == 'I') {\n      boredoms = boredoms + 1;\n      boredoms_found\
    \ = boredoms_found + \".\";\n    }\n  }\n  return boredoms;", "    int count =\
    \ 0;\n    for(int i = 0; i <= S.size(); i++) {\n        if (S[i] == '.' || S[i]\
    \ == '?' || S[i] == '!') {\n            count++;\n        }\n    }\n    return\
    \ count;", "    auto it = std::find(S.begin(), S.end(), '.');\n    if (it == S.end())\
    \ {\n        it = std::find(S.begin(), S.end(), '?');\n    }\n    if (it == S.end())\
    \ {\n        it = std::find(S.begin(), S.end(), '!');\n    }\n    if (it != S.begin())\
    \ {\n        return S.size() - std::distance(S.begin(), it);\n    }\n    return\
    \ -1;", "  long cnt = 0;\n  int pos = 0;\n  for (; pos < S.size(); pos++) {\n\
    \    if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') cnt++;\n  }\n  return\
    \ cnt;", "    long count = 0;\n    for (long i = 0; i < S.size(); i++) {\n   \
    \     if (S[i] == '.') {\n            if (S[i+1] == '!' || S[i+1] == '?') {\n\
    \                count++;\n                i++;\n            }\n        }\n  \
    \  }\n    return count;", "    long boredoms = 0;\n    for (int i = 0; S[i]; i++)\
    \ {\n        if (S[i] == 'I')\n            boredoms += 1;\n    }\n    return boredoms;",
  "    int counter = 0;\n    int pos = 0;\n    for (;pos < S.size();pos++) {\n   \
    \     // Iterate through each character in each word\n        switch (S.at(pos))\
    \ {\n            case 'I':\n                counter++;\n                break;\n\
    \            case '!':\n                counter--;\n                break;\n \
    \           case '.':\n            case '?':\n                break;\n       \
    \     default:\n                break;\n        }\n    }\n    return counter;",
  "    int i=0;\n    long boredom = 0;\n    for (int i = 0; i<S.length(); i++){\n\
    \        if (S[i] == 'I' && S[i+1] == '.'){\n            boredom++;\n        }\n\
    \    }\n    return boredom;", "    long boredom = 0;\n    for (int i = 0; i <\
    \ S.size(); i++) {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n\
    \            if (S[i] == '.') boredom++;\n        }\n    }\n    return boredom;",
  "    // TODO: Your code goes here\n    std::set<char> words;\n    std::string word;\n\
    \    std::istringstream iss(S);\n    while(iss >> word){\n        words.insert(word[0]);\n\
    \    }\n    long count = 0;\n    for (char ch : words){\n        if (ch == 'I'){\n\
    \            count +=1;\n        }\n    }\n    return count;", "    long cnt =\
    \ 0;\n    std::unordered_map<unsigned long, int> freq;\n    for (size_t i = 0;\
    \ i < S.size(); ++i) {\n        char c = S[i];\n        if (c == '.' || c == '!'\
    \ || c == '?') {\n            if (freq.find(freq.end() + 1) == freq.end()) {\n\
    \                freq.insert(std::pair<unsigned long, int>(i, 1));\n         \
    \   } else {\n                freq[i]++;\n            }\n        }\n    }\n  \
    \  for (auto& f : freq) {\n        if ((f.second == 1) && (f.first == 0)) {\n\
    \            cnt++;\n        }\n    }\n    return cnt;", "    long n = 0;\n  \
    \  for(int i=0; S[i] != '\\0'; i++)\n    {\n        // S[i] == ' ' means it is\
    \ a boredom\n        if(S[i] == ' ' && S[i+1] == ' ') n++;\n    }\n    return\
    \ n;", "    // Write your code here.\n    return 0;", "  int N = S.size();\n \
    \ // You can use a vector to save the frequency of words.\n  // You will need\
    \ a vector to save the number of boredoms\n  // for each word in S.\n  std::vector<std::pair<std::string,\
    \ int>> frequency;\n  for (int i = 0; i < N; i++) {\n    int boredom = 0;\n  \
    \  for (size_t j = 0; j < S.size(); j++) {\n      if (S[i] == '.') boredom++;\n\
    \      if (S[i] == '?') boredom++;\n      if (S[i] == '!') boredom++;\n      if\
    \ (S[j] == S[i]) boredom = 0;\n    }\n    frequency.push_back(std::make_pair(S[i\
    \ - boredom], 1));\n  }\n  // Now sort the frequency by count.\n  sort(frequency.begin(),\
    \ frequency.end());\n  // Return how many boredoms exist.\n  return frequency.size();",
  "  int flag = 0;\n  int counter = 0;\n  for (int i = 0; i < S.size(); i++) {\n \
    \   if (S[i] == 'I') {\n      counter++;\n      if (i == 0 || S[i - 1] == '.'\
    \ || S[i - 1] == '?' || S[i - 1] == '!') {\n        flag = 1;\n      }\n    }\n\
    \  }\n  return counter;", "    long count = 0;\n    bool has_bored = false;\n\
    \    // Iterate through each word in the string.\n    for(const auto& word : S)\
    \ {\n        // If we have a bored sentence and a word that starts with \"I\"\
    .\n        if (has_bored && word.at(0) == 'I') {\n            ++count;\n     \
    \   }\n        // If we have a bored sentence and a word that starts with \"i\"\
    .\n        else if (has_bored && word.at(0) == 'i') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"I\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'i') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'i') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'i') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'i') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"i\".\n        else if (has_bored && word.at(0) == 'i') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"I\".\n        else if (has_bored && word.at(0) == 'I') {\n            ++count;\n\
    \        }\n        // If we have a bored sentence and a word that starts with\
    \ \"I\".\n        else if (has_bored && word.", "  // TODO: Write your code here\n\
    \  long sum=0;\n  for(int i=0;i<S.size();i++)\n  {\n    if(S[i]=='?')\n    {\n\
    \      sum++;\n    }\n    else if(S[i]=='!' || S[i]=='.')\n    {\n      break;\n\
    \    }\n  }\n  return sum;", "    long boredoms = 0, boredom_cnt = 0, i, n = S.length();\n\
    \    for(i = 0; i < n; i++)\n    {\n        if (S[i] == 'I' && i != 0 && S[i-1]\
    \ == '.') boredom_cnt++;\n        if (S[i] == '?' && i != 0 && S[i-1] == '!')\
    \ boredom_cnt++;\n    }\n    for(i = 0; i < n; i++)\n    {\n        if (S[i] ==\
    \ '.' && i != 0 && S[i-1] == '?') boredom_cnt++;\n        if (S[i] == '!' && i\
    \ != 0 && S[i-1] == '.') boredom_cnt++;\n        if (S[i] == '.' && i != 0 &&\
    \ S[i-1] == '!') boredom_cnt++;\n        if (S[i] == '?' && i != 0 && S[i-1] ==\
    \ '.') boredom_cnt++;\n        if (S[i] == '!' && i != 0 && S[i-1] == '?') boredom_cnt++;\n\
    \    }\n    if (boredom_cnt > 0) boredoms = boredom_cnt;\n    return boredoms;",
  "    //Complete this function\n    if(S.find(\"I\") != std::string::npos) {\n  \
    \      long boredoms = 0;\n        for(int i = 0 ; i < S.size() ; i++) {\n   \
    \         if(S[i] == '.') {\n                boredoms += 1;\n            }\n \
    \       }\n        return boredoms;\n    } else {\n        //throw an exception\n\
    \    }\n    return 0;", "    long res = 0;\n    for (long i = 0; i < S.size();\
    \ i++) {\n        if (S[i] == 'I')\n            res++;\n    }\n    return res;",
  "    if (S.size() < 2) return 0;\n    std::unordered_map<std::string, int> mymap;\n\
    \    for (auto itr = S.begin(); itr != S.end(); ++itr) {\n        if (mymap.find(*itr)\
    \ == mymap.end()) mymap[*itr] = 1;\n        else mymap[*itr]++;\n    }\n    for\
    \ (auto itr = mymap.begin(); itr != mymap.end(); ++itr) {\n        if (itr->second\
    \ > 1) return false;\n    }\n    return true;", "    long count=0,counter=0,flag;\n\
    \    int i;\n    for(i=0;i<S.size();i++){\n        flag=0;\n        counter=1;\n\
    \        for(int j=0;j<S.size();j++){\n            if(i==j)\n                continue;\n\
    \            if(S[i]=='.' || S[i]=='?' || S[i]=='!'){\n                counter=counter*2;\n\
    \                flag=1;\n            }\n        }\n        if(flag==1)\n    \
    \        count=count+counter;\n    }\n    return count;", "    std::sort(S.begin(),\
    \ S.end());\n    long ans = 0;\n    int cnt = 0, curr = 0, next = 0;\n    while\
    \ (curr < S.size()) {\n        if (S.at(curr) == 'I') {\n            cnt++;\n\
    \        }\n        curr++;\n    }\n    // cnt is the number of boredoms found\n\
    \    long boredom = cnt / 2;\n    for (long i = 0; i < cnt; i++) {\n        if\
    \ (S.at(i) == 'I') {\n            boredom--;\n        }\n    }\n    if (boredom\
    \ == 0) {\n        ans = 1;\n    } else if (boredom == 1) {\n        ans = 0;\n\
    \    }\n    return ans;", "    vector<string> v;\n    v.push_back(S);\n    long\
    \ boredoms = 0;\n    sort(v.begin(), v.end());\n    string tmp;\n    for (string\
    \ s : v) {\n        if (s[0] == 'I') {\n            tmp = \"\";\n            for\
    \ (int i = 0; i < s.length(); i++) {\n                if (isalpha(s[i])) {\n \
    \                   tmp += s[i];\n                }\n            }\n         \
    \   if (tmp == s) {\n                boredoms++;\n            }\n        }\n \
    \   }\n    return boredoms;", '    // Complete the function', "    long boredoms\
    \ = 0;\n    for (int i = 0; i < S.length(); i++) {\n        if (S[i] == 'I') {\n\
    \            boredoms++;\n        }\n    }\n    return boredoms;", "    long boredoms\
    \ = 0;\n    std::string s = \"I\";\n    for (auto i : S) {\n        if (i == '.'\
    \ || i == '?' || i == '!') {\n            if (i == '.') {\n                if\
    \ (s == 'I') {\n                    s = \"I'll\";\n                } else {\n\
    \                    s = \"I'm\";\n                }\n            } else if (i\
    \ == '?') {\n                if (s == 'I') {\n                    s = \"I am\"\
    ;\n                } else {\n                    s = \"I am\";\n             \
    \   }\n            } else if (i == '!') {\n                if (s == 'I') {\n \
    \                   s = \"I don't\";\n                } else {\n             \
    \       s = \"I doesn't\";\n                }\n            }\n        } else if\
    \ (i == 'I') {\n            s = \"I'm\";\n        }\n        boredoms += 1;\n\
    \    }\n    return boredoms;", "  std::sort(S.begin(), S.end());\n  for (auto\
    \ &c : S) {\n    if (c == '.' || c == '?' || c == '!') {\n      return 0;\n  \
    \  }\n  }\n  return 1;", "  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your code goes here\n\
    \  // Your code goes here\n  // Your code goes here\n  // Your ", "    int boredom_count\
    \ = 0;\n    // write your logic here\n    return boredom_count;", '  // Your code
    here', '  // Write your code here', "    // Write your code here\n    int count\
    \ = 0;\n    for(int i = 0 ; i < S.length() ; i++) {\n        if(S[i] == 'I') {\n\
    \            count ++;\n        }\n    }\n    return count;", "    long count\
    \ = 0;\n    size_t i = 0, j = 0;\n    bool bored = false;\n    while (i < S.size())\
    \ {\n        if (!bored && S[i] == 'I') {\n            bored = true;\n       \
    \     count++;\n        }\n        while (j < S.size() && S[i] == S[j]) {\n  \
    \          j++;\n        }\n        if (bored && j == S.size()) {\n          \
    \  count++;\n            bored = false;\n        }\n        i++;\n    }\n    return\
    \ count;", "  int flag;\n  int count=0;\n  int len = S.size();\n  string s1 =\
    \ S;\n  string s2 = S;\n  for (int i=0; i<len-1;i++)\n    {\n      flag=0;\n \
    \     if (s1[i]=='I' && s1[i+1]=='.' || s1[i]=='I' && s1[i+1]=='?' || s1[i]=='I'\
    \ && s1[i+1]=='!')\n        {\n          flag=1;\n        }\n      count+=flag;\n\
    \      s1 = s2;\n      s2 = S;\n    }\n  return count;", "  // Write your code\
    \ here\n  std::map<char,int> m;\n  for(int i=0;i<S.size();i++){\n      if(S[i]\
    \ == '.'){\n          m[S[i]]++;\n      }\n  }\n  if(S[0] == 'I'){\n      return\
    \ m[S[0]];\n  }\n  return -1;", "  int bored = 0;\n  int i = 0;\n  int count =\
    \ 0;\n  while (i < S.size()) {\n    if (S[i] == '.') {\n      i++;\n      while\
    \ (i < S.size() && S[i] != '.') {\n        i++;\n      }\n      count++;\n   \
    \   i++;\n    } else if (S[i] == '?' || S[i] == '!') {\n      i++;\n      while\
    \ (i < S.size() && S[i] != S[i]) {\n        i++;\n      }\n      count++;\n  \
    \    i++;\n    } else if (S[i] == 'I') {\n      bored++;\n    }\n    i++;\n  }\n\
    \  return bored;", "    // ++count\n    // If S is \"I\" return 1\n    // Else\
    \ return 0\n    long count = 1;\n    char first[20];\n    memset(first, '\\0',\
    \ 20);\n    // The length of the first word is strlen(\"I\")\n    first[strcspn(\"\
    I\", first)] = 'I';\n    if (S[0] == 'I')\n    {\n        count++;\n    }\n  \
    \  std::string temp;\n    bool bored = false;\n    for (int i = 1; i < S.size();\
    \ i++)\n    {\n        temp = S[i] + \".\" + S[i+1] + \".\" + S[i+2];\n      \
    \  if (S[i] == 'I')\n        {\n            bored = true;\n            temp =\
    \ S[i] + \".\" + S[i+1] + \".\" + S[i+2];\n        }\n        bool found = false;\n\
    \        for (int j = 0; j < first.length; j++)\n        {\n            if (temp\
    \ == first[j])\n            {\n                found = true;\n               \
    \ break;\n            }\n        }\n        if (!found)\n        {\n         \
    \   break;\n        }\n    }\n    if (bored)\n    {\n        return count;\n \
    \   }\n    return 0;", "    int boredom_count = 0;\n    int boredom_counter =\
    \ 0;\n    for (int i = 0; i < S.size(); i++) {\n        char current = S[i];\n\
    \        if (current == '.') {\n            boredom_counter++;\n        }\n  \
    \      if (current == '!' || current == '?') {\n            boredom_count++;\n\
    \        }\n    }\n    long ans = boredom_counter;\n    return ans;", "    long\
    \ answer = 0;\n    for (auto &it : S) {\n        if (it == 'I') answer++;\n  \
    \  }\n    return answer;", "    long bored = 0;\n    assert(S.size() > 0);\n \
    \   for(int i = 1; i < S.size(); i++)\n    {\n        if(S[0] == 'I' && S[i] ==\
    \ '.')\n        {\n            bored += 1;\n        }\n    }\n    return bored;",
  "    int freq[26] = {0};\n    int size = S.size();\n    for (int i = 0; i < size;\
    \ i++) {\n        if (S[i] == '.') freq[S[i]-'a']++;\n        if (S[i] == '?')\
    \ freq[S[i]-'a']++;\n        if (S[i] == '!') freq[S[i]-'a']++;\n    }\n    long\
    \ bored = 0;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) bored++;\n\
    \    }\n    return bored;", "  // Write your code here\n  int n=0;\n  for (int\
    \ i=0;i<S.length();i++) {\n    if (S[i]=='I')\n      n++;\n  }\n  return n;",
  "    assert(S.size()>0);\n    long boredoms = 0;\n    // Write your code here\n\
    \    return boredoms;", "    long boredom_count = 0;\n    for (int i = 0; i <\
    \ S.size(); i++) {\n        // For each character, we check if its the 'I' letter\n\
    \        if (S[i] == 'I' && i != 0) {\n            // If we haven't encountered\
    \ the letter \"I\" yet\n            if (S[i-1] == '.') {\n                // If\
    \ we haven't encountered the \".\" yet\n                if (S[i-2] == '?' || S[i-2]\
    \ == '!') {\n                    // If we haven't encountered the '?' or '!' yet\n\
    \                    boredom_count++;\n                }\n            }\n    \
    \    }\n    }\n    return boredom_count;", "    if (S == \"I\") return 1;\n  \
    \  if (S == \"a\") return 1;\n    if (S == \"the\") return 1;\n    if (S == \"\
    of\") return 1;\n    if (S == \"to\") return 1;\n    if (S == \"of\") return 1;\n\
    \    return 0;", "    long count = 0;\n    // loop through each character of the\
    \ string, in order\n    // and check if it is a boredom\n    for (char c : S)\
    \ {\n        switch (c) {\n            case '.':\n            case '?':\n    \
    \        case '!':\n                count++;\n                break;\n       \
    \     default:\n                break;\n        }\n    }\n    return count;",
  "    int bored = 0;\n    for (int i = 0; i < S.size(); i++) {\n        if (S[i]\
    \ == '.') {\n            if (S[i + 1] == '!') {\n                bored++;\n  \
    \          } else if (S[i + 1] == '?') {\n                bored += 2;\n      \
    \      }\n        }\n    }\n    return bored;"]
stop_tokens:
- "\n}"
