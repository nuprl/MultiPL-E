name: HumanEval_29_filter_by_prefix
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of strings\
  \ only for ones that start with a given prefix.\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
  \ strings, std::string prefix) {\n"
tests: "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
  \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
  xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"\
  xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"\
  xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
completions: ["    std::vector<std::string> out;\n    std::size_t pos = 0;\n    while\
    \ (pos < strings.size()) {\n        std::string s = strings[pos];\n        if\
    \ (s.substr(0, prefix.size()) == prefix) {\n            out.push_back(s);\n  \
    \          ++pos;\n        } else {\n            break;\n        }\n    }\n  \
    \  return out;", "    std::vector<std::string> output;\n    std::size_t prefix_size\
    \ = prefix.length();\n    // We iterate through the input list checking the prefix\
    \ of each string for our prefix,\n    // and if it matches, we add the string\
    \ to the output list.\n    for (std::string const &str : strings) {\n        if\
    \ (str.size() >= prefix_size && str.substr(0, prefix_size) == prefix) {\n    \
    \        output.push_back(str);\n        }\n    }\n    return output;", "    //\
    \ Create a filtered list with all the strings starting with the prefix.\n    std::vector<std::string>\
    \ results;\n    results.reserve(strings.size());\n    for (std::string &str :\
    \ strings) {\n        if (str.substr(0, prefix.length()) == prefix) {\n      \
    \      results.push_back(str);\n        }\n    }\n    return results;", "  std::vector<std::string>\
    \ filtered;\n  for (std::string s : strs) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;",
  "  std::vector<std::string> result;\n  std::for_each(strings.begin(), strings.end(),\
    \ [&](std::string str) {\n    bool str_starts_with = str.compare(0, prefix.size(),\
    \ prefix) == 0;\n    bool str_contains_prefix = str.find(prefix) != std::string::npos;\n\
    \    if (str_starts_with || str_contains_prefix) {\n      result.push_back(str);\n\
    \    }\n  });\n  return result;", "    std::vector<std::string> filtered;\n  \
    \  for (auto &string : strings) {\n        if (string.substr(0, prefix.length())\
    \ == prefix) {\n            filtered.push_back(string);\n        }\n    }\n  \
    \  return filtered;", "  std::vector<std::string> result;\n  std::remove_copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(result), \n      [&](std::string str){return\
    \ str.substr(0, prefix.size()) == prefix;});\n  return result;", "  std::vector<std::string>\
    \ out;\n  for (std::string &s : strings) {\n    if (s.startsWith(prefix)) {\n\
    \      out.push_back(s);\n    }\n  }\n  return out;", "    std::sort(strings.begin(),\
    \ strings.end());\n    std::vector<std::string> filteres;\n    for (auto& str\
    \ : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n      \
    \      filteres.push_back(str);\n        }\n    }\n    return filteres;", "  assert(strings.size()\
    \ >= prefix.size());\n  std::vector<std::string> result;\n  for (auto& s : strings)\
    \ {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "  std::set<std::string> s;\n  for (auto &s :\
    \ strings) {\n    if (s.substr(0, prefix.length()) == prefix) s.clear();\n   \
    \ s.insert(s);\n  }\n  return strings;", "  std::string::size_type pos = prefix.size();\n\
    \  std::vector<std::string> filtered;\n  for (auto &s : strings) {\n    if (s.substr(0,\
    \ pos) == prefix) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;",
  "    std::sort(strings.begin(), strings.end());\n    std::string prefix_comp = prefix\
    \ + \".\";\n    auto it = std::remove_if(strings.begin(), strings.end(), [&](const\
    \ std::string &s) {\n        return s.compare(0, prefix_comp.size(), prefix_comp)\
    \ == 0;\n    });\n    strings.erase(it, strings.end());\n    return strings;",
  "  std::string pf = prefix + std::string(\".*\");\n  std::regex match_regex(pf);\n\
    \  std::vector<std::string> res;\n  for (auto &s : strings) {\n    if (std::regex_search(s,\
    \ match_regex)) {\n      res.push_back(s);\n    }\n  }\n  return res;", "  std::vector\
    \ <std::string> out;\n  for (std::string s : strings) {\n    if (s.starts_with(prefix))\
    \ {\n      out.push_back(s);\n    }\n  }\n  return out;", "    // TODO : sort\
    \ first\n    std::set<std::string> s;\n    for (auto &it : strings)\n        if\
    \ (it.substr(0, prefix.length()) == prefix) {\n            s.insert(it);\n   \
    \     }\n\n    std::vector<std::string> filtered;\n    for (auto &it : strings)\n\
    \        if (s.find(it) == s.end())\n            filtered.push_back(it);\n\n \
    \   return filtered;", "  std::vector<std::string> res;\n  for (auto s : strings)\n\
    \    if (s.substr(0, prefix.size()) == prefix)\n      res.push_back(s);\n  return\
    \ res;", "  std::vector<std::string> ret;\n  std::for_each(strings.begin(), strings.end(),\
    \ [&](std::string s) {\n    if (s.substr(0, prefix.length()) == prefix) {\n  \
    \    ret.push_back(s);\n    }\n  });\n  return ret;", "  std::vector<std::string>\
    \ output;\n  for (const std::string& s : strings) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      output.push_back(s);\n    }\n  }\n  return output;", " \
    \   std::vector<std::string> result;\n    std::copy_if(strings.begin(), strings.end(),\
    \ std::back_inserter(result),\n            std::bind(std::begin(prefix), std::end(prefix),\
    \ std::placeholders::_1));\n    return result;", "  std::vector<std::string> result;\n\
    \  for (auto& s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      result.push_back(s);\n    }\n  }\n  return result;", "  std::vector<std::string>\
    \ new_strings;\n  for (auto& string : strings) {\n    if (string.substr(0, prefix.size())\
    \ == prefix) {\n      new_strings.push_back(string);\n    }\n  }\n  return new_strings;",
  "\tstd::vector<std::string> filtered_strings;\n\tauto prefix_len = prefix.size();\n\
    \tstd::for_each(strings.begin(), strings.end(),[&](std::string str){\n\t\tif(str.size()\
    \ >= prefix_len)\n\t\t\tfiltered_strings.push_back(str.substr(prefix_len));\n\t\
    });\n\treturn filtered_strings;", "  std::vector<std::string> result;\n  for (auto\
    \ const & s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n  \
    \    result.push_back(s);\n    }\n  }\n  return result;", "    std::vector<std::string>\
    \ result;\n    for (std::string &s : strings) {\n        if (s.startsWith(prefix))\n\
    \            result.push_back(s);\n    }\n    return result;", "  // Return an\
    \ empty list if there are no strings.\n  if (strings.empty())\n    return strings;\n\
    \  // Create a vector for output\n  std::vector<std::string> output(strings.size());\n\
    \  // Iterate over the original list\n  for (auto it = strings.begin(); it !=\
    \ strings.end(); it++)\n    // If this string starts with the prefix, copy it\
    \ to the new list\n    if (std::equal(prefix.begin(), prefix.end(), *it)) {\n\
    \      output[it - strings.begin()] = *it;\n    }\n  // Return the output list\n\
    \  return output;", "  std::vector<std::string> ret(strings.size());\n  for (size_t\
    \ i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0, prefix.length())\
    \ == prefix) {\n      ret[i] = strings[i];\n    }\n  }\n  return ret;", "  std::vector<std::string>\
    \ ret(std::begin(strings), std::end(strings));\n  for (auto i = std::begin(ret);\
    \ i != std::end(ret); ++i) {\n    if (i->substr(0, prefix.size()) == prefix) {\n\
    \      ret.erase(std::remove(i + 1, std::end(ret), *i), std::end(ret));\n    }\n\
    \  }\n  return ret;", "  std::vector<std::string> result;\n  for (std::string\
    \ s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> result;\n  // Filter\
    \ the input strings for those that start with the given prefix.\n  for (auto it\
    \ = std::begin(strings); it != std::end(strings); it++) {\n    if (it->find(prefix)\
    \ == 0) {\n      result.emplace_back(*it);\n    }\n  }\n  return result;", " \
    \   std::vector<std::pair<std::string, int>> result;\n    for (auto i = strings.begin();\
    \ i != strings.end(); ++i) {\n        if (i->startswith(prefix)) {\n         \
    \   result.emplace_back(*i, 1);\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return std::vector<std::string>{result.begin(), result.end()};",
  "  std::vector<std::string> strings_out;\n  for (std::string string: strings) {\n\
    \    if (string.find(prefix) == 0) {\n      strings_out.push_back(string);\n \
    \   }\n  }\n  return strings_out;", "  assert(strings.size()>0);\n  assert(prefix.length()>0);\n\
    \  std::vector<std::string> newStrings;\n  for (std::vector<std::string>::iterator\
    \ it = strings.begin(); it != strings.end(); ++it) {\n    if ((*it).length() >=\
    \ prefix.length()) {\n      std::string prefix = \"\";\n      for (int i = 0;\
    \ i < prefix.length(); i++) {\n        prefix += (*it).at(i);\n      }\n     \
    \ if ((prefix == prefix) && (prefix == (*it).substr(prefix.length()))) {\n   \
    \     newStrings.push_back(*it);\n      }\n    }\n  }\n  return newStrings;",
  "  std::vector<std::string> result;\n  // A helper function which finds any strings\
    \ that start with prefix and returns their index.\n  auto find_prefix_index =\
    \ [&](std::string string) -> size_t {\n    auto index = std::find(strings.begin(),\
    \ strings.end(), string);\n    // If no strings start with the given prefix then\
    \ index is string::npos.\n    return index == strings.end() ? string::npos : index;\n\
    \  };\n  // Copy all strings that start with prefix\n  result.insert(result.end(),\
    \ strings.begin(), find_prefix_index(prefix));\n  // Add all strings that do not\
    \ start with prefix to result.\n  result.insert(result.end(), strings.begin()\
    \ + find_prefix_index(prefix) + 1, strings.end());\n  return result;", "    std::vector<std::string>\
    \ res;\n    // Prepend the prefix to all strings.\n    for (auto &s : strings)\n\
    \        res.push_back(prefix+s);\n    return res;", "    std::vector<std::string>\
    \ ret;\n    for (auto it = strings.begin(); it != strings.end(); ++it) {\n   \
    \     if (it->substr(0, prefix.size()) == prefix) {\n            ret.push_back(it->substr(prefix.size()));\n\
    \        }\n    }\n    return ret;", "    std::vector<std::string> result;\n \
    \   std::size_t prefix_len = prefix.length();\n    for (auto it = strings.begin();\
    \ it != strings.end(); ++it) {\n        if (it->length() > prefix_len)\n     \
    \       continue;\n        if (std::equal(it->begin(), it->begin() + prefix_len,\
    \ prefix.begin())) {\n            result.push_back(*it);\n        }\n    }\n \
    \   return result;", "  std::vector<std::string> filtered;\n  for (const auto&\
    \ string : strings) {\n    if (string.length() >= prefix.size() && string.substr(0,\
    \ prefix.size()) == prefix) {\n      filtered.push_back(string);\n    }\n  }\n\
    \  return filtered;", "  std::set<std::string> prefixes = {prefix};\n  std::vector<std::string>\
    \ filtered;\n  for (std::string s : strings) {\n    auto it = std::find_if(prefixes.begin(),\
    \ prefixes.end(), [&s](std::string p){return s.substr(0, p.length()) == p;});\n\
    \    if (it != prefixes.end()) filtered.push_back(s);\n  }\n  return filtered;",
  "    std::vector<std::string> res;\n    for (auto s : strings) {\n        if (s.substr(0,\
    \ prefix.size()) == prefix) {\n            res.push_back(s);\n        }\n    }\n\
    \    return res;", "  std::vector<std::string> result;\n  if (strings.empty())\
    \ {\n    return result;\n  }\n  if (prefix.empty()) {\n    result.push_back(strings[0]);\n\
    \    return result;\n  }\n  auto it = strings.begin();\n  while (it != strings.end())\
    \ {\n    if (it->startswith(prefix)) {\n      result.push_back(*it);\n    }\n\
    \    ++it;\n  }\n  return result;", "    std::vector<std::string> ret;\n    size_t\
    \ len = strings.size();\n    for (size_t i = 0; i < len; i++) {\n        if (strings[i].length()\
    \ > prefix.length()) {\n            continue;\n        }\n        if (strings[i].substr(0,\
    \ prefix.length()) == prefix) {\n            ret.push_back(strings[i]);\n    \
    \    }\n    }\n    return ret;", "  // Copy all the strings to a set.\n  std::set<std::string>\
    \ set(strings.begin(), strings.end());\n  std::vector<std::string> filtered(set.begin(),\
    \ set.end());\n  // Filter out the ones that don't start with the prefix.\n  for\
    \ (std::string& str : strings) {\n    if (str.compare(0, prefix.size(), prefix)\
    \ == 0) {\n      filtered.push_back(str);\n    }\n  }\n  return filtered;", " \
    \ std::vector<std::string> results;\n  for (std::string &str : strings) {\n  \
    \  if (str.substr(0, prefix.length()) == prefix) {\n      results.push_back(str);\n\
    \    }\n  }\n  return results;", "  std::regex prefix_regex(prefix);\n  std::vector<std::string>\
    \ result;\n  for (std::string &item : strings)\n    if (std::regex_match(item,\
    \ prefix_regex))\n      result.push_back(item);\n  return result;", "    std::vector<std::string>\
    \ new_strings;\n    for (std::string &s : strings) {\n        size_t prefix_length\
    \ = s.length() - prefix.length();\n        if (0 == prefix_length) {\n       \
    \     new_strings.push_back(s);\n        } else {\n            if (s.substr(0,\
    \ prefix.length()) == prefix) {\n                new_strings.push_back(s);\n \
    \           }\n        }\n    }\n    return new_strings;", "    std::vector<std::string>\
    \ result;\n    for (auto iter = strings.begin(); iter != strings.end(); ++iter)\
    \ {\n        if (iter->compare(0, prefix.size(), prefix) == 0)\n            result.push_back(iter);\n\
    \    }\n    return result;", "  std::vector<std::string> result;\n  result.push_back(prefix);\n\
    \  for (std::string &str : strings) {\n    if (str.size() > prefix.size() &&\n\
    \        str.substr(0, prefix.size()) == prefix)\n      result.push_back(str.substr(prefix.size()));\n\
    \  }\n  return result;", "  std::vector<std::string> res;\n  for (const auto&\
    \ s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;", "    std::unordered_set<std::string> unique_prefix(prefix.begin(),\
    \ prefix.end());\n    std::vector<std::string> filtered_strings;\n    for (auto&\
    \ str : strings)\n        if (unique_prefix.find(str) != unique_prefix.end())\n\
    \            filtered_strings.push_back(str);\n    return filtered_strings;",
  "    std::vector<std::string> result;\n    std::set<std::string> prefix_set;\n \
    \   for (std::string &s: strings) {\n        if (s.starts_with(prefix)) {\n  \
    \          prefix_set.insert(s.substr(prefix.length()));\n        }\n    }\n \
    \   for (std::string &s: strings) {\n        if (prefix_set.count(s) == 0) {\n\
    \            result.push_back(s);\n        }\n    }\n    return result;", "  std::vector<std::string>\
    \ result;\n  for (auto& string : strings) {\n    if (string.substr(0, prefix.size())\
    \ == prefix) {\n      result.push_back(string);\n    }\n  }\n  return result;",
  "  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if\
    \ (str.substr(0, prefix.length()) == prefix) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;", "    std::vector<std::string> result;\n    for(size_t\
    \ i = 0; i < strings.size(); ++i)\n        if (strings[i].substr(0, prefix.length())\
    \ == prefix)\n            result.push_back(strings[i]);\n    return result;",
  "  auto p = std::begin(prefix);\n  std::vector<std::string> result;\n  for (auto\
    \ it = std::begin(strings);; it++) {\n    if (it == std::end(strings)) break;\n\
    \    if (it->compare(0, p.length(), p) == 0) {\n      result.emplace_back(it);\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> output;\n  for (std::string\
    \ &string : strings) {\n    if (string.startsWith(prefix)) {\n      output.push_back(string);\n\
    \    }\n  }\n  return output;", "    std::vector<std::string> result;\n    std::string\
    \ prefixed;\n    for (auto it : strings) {\n        prefixed.append(prefix);\n\
    \        prefixed.append(it);\n        result.push_back(prefixed);\n    }\n  \
    \  return result;", "  std::vector<std::string> res;\n  for (auto& s : strings)\
    \ {\n    if (s.substr(0, prefix.size()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;", "    std::vector<std::string> result;\n    for (std::string\
    \ line : strings) {\n        if (line.find(prefix) == 0) {\n            result.push_back(line);\n\
    \        }\n    }\n    return result;", "    std::vector<std::string> filtered;\n\
    \    std::copy_if(strings.begin(), strings.end(),\n            std::back_inserter(filtered),\n\
    \            [&prefix](std::string s) { return s.substr(0, prefix.length()) ==\
    \ prefix; });\n    return filtered;", "  std::vector<std::string> result;\n  for\
    \ (std::string &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(str);\n    }\n  }\n  return result;", "  std::vector<std::string>\
    \ out;\n  for (std::string &s: strings) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      out.push_back(s);\n    }\n  }\n  return out;", "  std::vector<std::string>\
    \ result;\n  for (auto& str : strings)\n    if (str.substr(0, prefix.size()) ==\
    \ prefix)\n      result.push_back(str);\n  return result;", "  std::vector<std::string>\
    \ filtered;\n  for (auto & string : strings) {\n    if (string.substr(0, prefix.length())\
    \ == prefix) {\n      filtered.push_back(string);\n    }\n  }\n  return filtered;",
  "    std::vector<std::string> result;\n    for (auto str : strings) {\n        if\
    \ (str.startsWith(prefix)) {\n            result.push_back(str);\n        }\n\
    \    }\n    return result;", "    std::vector<std::string> filtered;\n    std::remove_copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(filtered), \n        [&prefix](std::string\
    \ const &str) { return str.find(prefix) == 0; });\n    return filtered;", "  std::sort(strings.begin(),\
    \ strings.end());\n  strings.erase(std::remove_if(strings.begin(), strings.end(),\
    \ [&prefix](std::string s) { return s.find(prefix) == 0; }), strings.end());\n\
    \  return strings;", "  // If prefix is empty, return everything.\n  if (prefix.size()\
    \ == 0) {\n    return strings;\n  }\n\n  // If any of strings is an empty string,\
    \ return everything.\n  for (const auto& string : strings) {\n    if (string.size()\
    \ == 0) {\n      return strings;\n    }\n  }\n\n  // Filter out all strings that\
    \ don't start with the prefix prefix.\n  std::vector<std::string> result;\n  for\
    \ (const auto& string : strings) {\n    if (string.substr(0, prefix.size()) ==\
    \ prefix) {\n      result.emplace_back(string);\n    }\n  }\n  return result;",
  "    // A map of strings that start with the given prefix.\n    std::map<std::string,int>\
    \ prefix_counts;\n    for (auto &s : strings)\n        prefix_counts[s.substr(0,\
    \ prefix.size())] = prefix_counts[s.substr(0, prefix.size())] + 1;\n\n    std::vector<std::string>\
    \ filtered;\n    for (auto &s : strings)\n    {\n        if (prefix_counts[s.substr(0,\
    \ prefix.size())] > 0)\n            filtered.push_back(s);\n    }\n    return\
    \ filtered;", "  std::vector<std::string> result;\n  for(std::string s : strings)\
    \ {\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      result.push_back(s);\n\
    \  }\n  return result;", "    std::vector<std::string> result;\n    result.push_back(strings.front());\n\
    \    for (auto& string : strings) {\n        if (string.find(prefix) == 0) {\n\
    \            result.push_back(string);\n        }\n    }\n    return result;",
  "  std::vector<std::string> res;\n  for (auto& s : strings) {\n    if (s.substr(0,\
    \ prefix.length()) == prefix) {\n      res.push_back(s);\n    }\n  }\n  return\
    \ res;", "    std::vector<std::string> retval;\n    for(auto s : strings) {\n\
    \        if(s.find(prefix) == 0) {\n            retval.push_back(s);\n       \
    \ }\n    }\n    return retval;", "    std::vector<std::string> ret;\n    for(auto\
    \ s : strings) {\n        if(s.starts_with(prefix)) {\n            ret.push_back(s);\n\
    \        }\n    }\n    return ret;", "    std::vector<std::string> filtered_strings;\n\
    \    for (auto s: strings)\n        if (s.substr(0, prefix.size()) == prefix)\n\
    \            filtered_strings.push_back(s);\n    return filtered_strings;", " \
    \ prefix += '.';\n  std::vector<std::string> res;\n  for (size_t i = 0; i < strings.size();\
    \ ++i) {\n    if (strings[i].length() >= prefix.length()) {\n      std::string\
    \ prefix = strings[i].substr(0, prefix.length());\n      if (strings[i].compare(0,\
    \ prefix.length(), prefix) == 0) {\n        res.push_back(strings[i]);\n     \
    \ }\n    }\n  }\n  return res;", "    std::vector<std::string> filtered_strings;\n\
    \    for (auto string : strings) {\n        if (string.substr(0, prefix.length())\
    \ == prefix) {\n            filtered_strings.push_back(string);\n        }\n \
    \   }\n    return filtered_strings;", "    std::vector<std::string> res;\n   \
    \ for (auto &str : strings) {\n        if (str.find(prefix) == 0) {\n        \
    \    res.push_back(str);\n        }\n    }\n    return res;", "  std::vector<std::string>\
    \ retval;\n  if (strings.size() > 0) {\n    std::string prefix_str = prefix +\
    \ \".\";\n    size_t prefix_size = prefix_str.size();\n    retval.push_back(strings.front());\n\
    \    for (size_t i = 1; i < strings.size(); i++) {\n      if (strings[i].length()\
    \ >= prefix_size && strings[i].compare(0, prefix_size, prefix_str) == 0) {\n \
    \       retval.push_back(strings.at(i));\n      }\n    }\n  }\n  return retval;",
  "  std::vector<std::string> result;\n  for (auto& s: strings) {\n    if (s.substr(0,\
    \ prefix.length()) == prefix) result.push_back(s);\n  }\n  return result;", " \
    \ std::string prefix_str = prefix + \".\";\n  std::vector<std::string> result;\n\
    \  for (std::string string : strings) {\n    if (string.find(prefix_str) == 0)\
    \ {\n      result.push_back(string);\n    }\n  }\n  return result;", "  std::vector<std::string>\
    \ result;\n  result.insert(std::find(strings.begin(), strings.end(), prefix),\
    \ strings.end());\n  return result;", "    std::vector<std::string> result;\n\
    \    std::set<std::string> seen;\n    for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n        if (it->compare(0, prefix.size(), prefix) == 0) {\n       \
    \     seen.insert(*it);\n        }\n    }\n    for (auto it = strings.begin();\
    \ it != strings.end(); ++it) {\n        if (seen.find(*it) == seen.end()) {\n\
    \            result.emplace_back(*it);\n        }\n    }\n    return result;",
  "    std::vector<std::string> ret;\n    size_t pos = 0;\n    std::string first_word;\n\
    \n    while (pos < strings.size()) {\n        size_t endpos = strings[pos].find(prefix);\n\
    \        // Find the end of the substring and break out of the loop.\n       \
    \ if (endpos == std::string::npos) {\n            ret.push_back(strings[pos]);\n\
    \            break;\n        }\n        first_word = strings[pos].substr(0, endpos);\n\
    \        // If the current string starts with the prefix, add it to the result.\n\
    \        if (first_word == prefix) {\n            ret.push_back(strings[pos]);\n\
    \        }\n        pos = endpos + 1;\n    }\n    return ret;", "  std::vector<std::string>\
    \ result;\n  std::string found_prefix = prefix + \"-\";\n  for (auto& string :\
    \ strings) {\n    if (string.length() > found_prefix.length()) {\n      continue;\n\
    \    }\n    if (0 == std::memcmp(string.c_str(), found_prefix.c_str(), found_prefix.length()))\
    \ {\n      result.push_back(string);\n    }\n  }\n  return result;", "    std::vector<std::string>\
    \ res;\n    for (std::string line : strings)\n        if (line.substr(0, prefix.size())\
    \ == prefix)\n            res.push_back(line);\n    return res;", "  std::vector<std::string>\
    \ out;\n  for (const auto& s : strings) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      out.push_back(s);\n    }\n  }\n  return out;", "  std::vector<std::string>\
    \ result;\n  for (auto it = strings.begin(); it != strings.end(); ++it) {\n  \
    \  if (it->substr(0, prefix.size()) == prefix) {\n      result.push_back(*it);\n\
    \    }\n  }\n  return result;", "    std::vector<std::string> ret;\n    auto it\
    \ = std::begin(strings);\n    auto begin = std::begin(ret);\n    while (it !=\
    \ std::end(strings)) {\n        auto s = *it;\n        if (s == prefix) {\n  \
    \          *begin = s;\n            ++begin;\n        }\n        ++it;\n    }\n\
    \    return ret;", "    std::vector<std::string> result;\n    for (auto& string\
    \ : strings)\n        if (string.length() >= prefix.size() && string.substr(0,\
    \ prefix.length()) == prefix)\n            result.emplace_back(string);\n    return\
    \ result;", "  std::vector<std::string> res;\n  for (std::string& s : strings)\n\
    \    if (s.starts_with(prefix))\n      res.push_back(s);\n  return res;", "  std::vector<std::string>\
    \ filtered;\n  for (std::string &string : strings) {\n    if (string.substr(0,\
    \ prefix.size()) == prefix) {\n      filtered.push_back(string);\n    }\n  }\n\
    \  return filtered;", "    std::vector<std::string> filtered_strings;\n    std::string\
    \ temp_prefix;\n    for (std::string string_item : strings) {\n        if (string_item.compare(0,\
    \ prefix.size(), prefix) == 0) {\n            temp_prefix = string_item.substr(prefix.size());\n\
    \            filtered_strings.push_back(string_item);\n        }\n    }\n    return\
    \ filtered_strings;", "    std::vector<std::string> result;\n    for (auto &s:\
    \ strings) {\n        if (s.substr(0, prefix.length()) == prefix) result.push_back(s);\n\
    \    }\n    return result;", "  // Copy all strings into a vector\n  std::vector<std::string>\
    \ strings_copy(strings);\n\n  // Filter the strings by prefix\n  for (auto& s\
    \ : strings_copy)\n    if (s.substr(0, prefix.length()) == prefix)\n      strings.erase(std::remove(strings.begin(),\
    \ strings.end(), s), strings.end());\n\n  return strings;", "  std::vector<std::string>\
    \ new_strings;\n  std::set<std::string> string_set;\n\n  for (std::string line\
    \ : strings) {\n    if (line.find(prefix) == 0) {\n      string_set.insert(line);\n\
    \    }\n  }\n\n  for (std::string line : strings) {\n    if (string_set.find(line)\
    \ == string_set) {\n      new_strings.push_back(line);\n    }\n  }\n\n  return\
    \ new_strings;", "  std::vector<std::string> result;\n  for (auto& s : strings)\
    \ {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "    std::vector<std::string> ret;\n    for(auto\
    \ &s : strings) {\n        if(s.substr(0, prefix.size()) == prefix) {\n      \
    \      ret.push_back(s);\n        }\n    }\n    return ret;", "    std::vector<string>\
    \ res;\n    for (auto &i : strings) {\n        if (i.compare(0, prefix.size(),\
    \ prefix) == 0) {\n            res.push_back(i);\n        }\n    }\n    return\
    \ res;", "  std::vector<std::string> filtered;\n  for (const auto& string : strings)\n\
    \    if (string.substr(0, prefix.size()) == prefix)\n      filtered.push_back(string);\n\
    \  return filtered;", "    std::vector<std::string> filtered(strings.begin(),\
    \ strings.end());\n    std::remove_copy_if(filtered.begin(), filtered.end(), std::back_inserter(filtered),\
    \ \n            [&](std::string s) { return s.find(prefix) == 0; });\n    return\
    \ filtered;", "  assert(strings.size() > 0);\n  std::vector<std::string> results;\n\
    \  for (std::string &s : strings) {\n    if (s.starts_with(prefix)) {\n      results.push_back(s);\n\
    \    }\n  }\n  return results;", "    std::vector<std::string> result;\n    std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(result), [&prefix](const std::string &s) {\n\
    \        return s.substr(0, prefix.size()) == prefix;\n    });\n    return result;",
  "    std::vector<std::string> result;\n    std::remove_copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(result), [&prefix](const std::string &s) {\
    \ return s.find(prefix) == 0; });\n    return result;", "  std::vector<std::string>\
    \ filtered;\n  for (std::string s: strings) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;",
  "    std::vector<std::string> filtered;\n    for(unsigned int i=0; i<strings.size();\
    \ i++) {\n        if(strings[i].substr(0, prefix.size()) == prefix) {\n      \
    \      filtered.push_back(strings[i]);\n        }\n    }\n    return filtered;",
  "  std::vector<std::string> filtered;\n  for (int i = 0; i < strings.size(); i++)\
    \ {\n    if (strings[i].find(prefix) == 0)\n      filtered.push_back(strings[i]);\n\
    \  }\n  return filtered;", "    // Return a copy of strings containing only strings\
    \ starting with the prefix.\n    std::vector<std::string> output;\n    std::remove_copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(output),\n        [&prefix](std::string s)\
    \ { return s.substr(0, prefix.size()) == prefix; });\n    return output;", " \
    \   std::vector<std::string> result;\n    for (auto &s: strings) {\n        if\
    \ (s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n\
    \        }\n    }\n    return result;", "    std::vector<std::string> results;\n\
    \    for (std::string word : strings) {\n        if (word.find(prefix) == 0) {\n\
    \            results.push_back(word);\n        }\n    }\n    return results;",
  "    std::vector<std::string> result;\n    for (auto &s : strings) {\n        if\
    \ (s.find(prefix) == 0) {\n            result.push_back(s);\n        }\n    }\n\
    \    return result;", "  std::vector<std::string> res;\n  res.reserve(strings.size());\n\
    \  for (auto & s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      res.push_back(s);\n    }\n  }\n  return res;", "  std::vector<std::string>\
    \ retval;\n  for (auto s: strings) {\n    if (s.length() >= prefix.size() && s.substr(0,\
    \ prefix.size()) == prefix) {\n      retval.push_back(s);\n    }\n  }\n  return\
    \ retval;", "    std::vector<std::string> res;\n    // Filter the given strings\
    \ starting with the given prefix\n    for(size_t i = 0; i < strings.size(); ++i)\
    \ {\n        if(strings[i].substr(0, prefix.length()) == prefix) {\n         \
    \   res.push_back(strings[i]);\n        }\n    }\n    return res;", "  std::vector<std::string>\
    \ retval;\n  for (std::string s : strings) {\n    if (s.substr(0, prefix.length())\
    \ == prefix) {\n      retval.push_back(s);\n    }\n  }\n  return retval;", " \
    \ assert(strings.size() > 0);\n  std::vector<std::string> result;\n  for (std::string\
    \ str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;", "    std::vector<std::string> result;\n    for(auto&\
    \ s : strings) {\n        if(s.substr(0, prefix.size()) == prefix) {\n       \
    \     result.push_back(s);\n        }\n    }\n    return result;", "    std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(filter), \n        [](std::string s) { return\
    \ s.startsWith(prefix); });\n    return filter;", "  std::vector<std::string>\
    \ res;\n  for (const auto& string : strings) {\n    if (string.substr(0, prefix.length())\
    \ == prefix) {\n      res.emplace_back(string.substr(prefix.length()));\n    }\n\
    \  }\n  return res;", "    std::set<std::string> s;\n    for (std::string &s:\
    \ strings) {\n        if (s.compare(0, prefix.size(), prefix) == 0) {\n      \
    \      s.erase(0, prefix.size());\n        }\n    }\n    return strings;", " \
    \ std::vector<std::string> result;\n  for (std::string name : strings) {\n   \
    \ if (name.substr(0, prefix.length()) == prefix) {\n      result.push_back(name);\n\
    \    }\n  }\n  return result;", "  prefix = std::move(prefix);\n  std::vector<std::string>\
    \ result;\n  std::copy_if(strings.begin(), strings.end(),\n               std::back_inserter(result),\n\
    \               [&prefix](std::string str) { return str.find(prefix) == 0; });\n\
    \  return result;", "    // Keep the filtered output by copying it to a new vector.\n\
    \    std::vector<std::string> filtered;\n    // For each input string, see if\
    \ it's starts with the prefix.\n    for (auto& str : strings) {\n        if (str.substr(0,\
    \ prefix.length()) == prefix) {\n            // Add the string to the filtered\
    \ output.\n            filtered.push_back(str);\n        }\n    }\n    return\
    \ filtered;", "  std::vector<std::string> retval;\n  std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(retval), \n      [&prefix](std::string s)\
    \ { return s.front() == prefix; });\n  return retval;", "    std::vector<std::string>\
    \ output;\n    std::set_intersection(strings.begin(), strings.end(),\n       \
    \                  prefix.begin(), prefix.end(),\n                         std::back_inserter(output));\n\
    \    return output;", "  std::vector<std::string> retval;\n  for (std::string\
    \ &s : strings)\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      retval.push_back(s);\n\
    \  return retval;", "  std::vector<std::string> result;\n  // Iterate over the\
    \ input strings.\n  for (size_t i = 0; i < strings.size(); ++i) {\n    // If the\
    \ current string starts with the given prefix.\n    if (strings.at(i).substr(0,\
    \ prefix.size()) == prefix) {\n      // Add it to the result list.\n      result.push_back(strings.at(i));\n\
    \    }\n  }\n  // Return the filtered result.\n  return result;", "  std::vector<std::string>\
    \ result;\n  std::size_t prefix_length = prefix.size();\n  for (std::size_t i\
    \ = 0; i < strings.size(); ++i) {\n    if (strings[i].size() >= prefix_length)\
    \ {\n      std::size_t matched = strings[i].substr(0, prefix_length).rfind(prefix);\n\
    \      if (matched != std::string::npos) {\n        result.push_back(strings[i]);\n\
    \      }\n    }\n  }\n  return result;", "    std::vector<std::string> retval;\n\
    \    for (auto &it : strings)\n        if (it.substr(0, prefix.size()) == prefix)\n\
    \            retval.push_back(it);\n    return retval;", "  prefix = prefix.substr(0,\
    \ prefix.length() - 1);\n  std::set<std::string> filtered_strings;\n  for (std::string\
    \ string : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n\
    \      filtered_strings.insert(string);\n    }\n  }\n  return std::vector<std::string>(filtered_strings.begin(),\
    \ filtered_strings.end());", "  std::vector<std::string> result;\n  for (auto\
    \ s = strings.begin(); s != strings.end(); ++s) {\n    if ((*s).compare(0, prefix.size(),\
    \ prefix) == 0) {\n      result.emplace_back(*s);\n    }\n  }\n  return result;",
  "    std::vector<std::string> retval;\n    for(std::string s : strings) {\n    \
    \    if(s.substr(0, prefix.length()) == prefix) {\n            retval.push_back(s);\n\
    \        }\n    }\n    return retval;", "    std::vector<std::string> filtered;\n\
    \    std::for_each(strings.begin(), strings.end(), [&](std::string s) {\n    \
    \    if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n\
    \        }\n    });\n    return filtered;", "  std::map<std::string, std::string>\
    \ map;\n  for (std::string s : strings)\n    if (s[0] == prefix[0])\n      map[s.size()]\
    \ = s;\n  std::vector<std::string> ret;\n  for (auto &item : map) {\n    ret.push_back(item.second);\n\
    \  }\n  return ret;", "  std::vector<std::string> result;\n  for (std::string\
    \ s : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      result.push_back(s);\n\
    \  }\n  return result;", "    std::vector<std::string> filtered;\n    std::set<std::string>\
    \ stringset;\n    for(auto const &s : strings) {\n        if(s.startsWith(prefix))\
    \ {\n            filtered.push_back(s);\n            stringset.insert(s);\n  \
    \      }\n    }\n    return filtered;", "  std::sort(strings.begin(), strings.end());\n\
    \  // Find a prefix that starts exactly at the first element of the sorted list.\n\
    \  auto it = std::find(strings.begin(), strings.end(), prefix);\n  // If there\
    \ is no such prefix, return the original input list.\n  if (it == strings.end())\
    \ {\n    return strings;\n  }\n  // Construct a new list of strings consisting\
    \ of all the elements before the\n  // prefix and all the elements after the prefix.\n\
    \  std::vector<std::string> result;\n  result.reserve(strings.size() - 1);\n \
    \ result.push_back(std::move(*it));\n  for (; it != strings.end(); ++it) {\n \
    \   if (it->length() < prefix.size()) {\n      result.push_back(std::move(*it));\n\
    \    } else {\n      auto prefix = std::move(*it);\n      it--;\n      // Keep\
    \ searching for a prefix that starts at \"it\" using std::search.\n      while\
    \ (std::find(std::next(it), strings.end(), prefix) != strings.end()) {\n     \
    \   prefix += std::move(*it);\n        it--;\n      }\n      if (it != strings.begin())\
    \ {\n        result.push_back(std::move(*it));\n      }\n      result.push_back(std::move(prefix));\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> res;\n  for (const\
    \ auto& i : strings) {\n    if (i.substr(0, prefix.size()) == prefix) res.push_back(i);\n\
    \  }\n  return res;", "    std::vector<std::string> result;\n    for (std::string\
    \ str : strings) {\n        if (str.compare(0, prefix.size(), prefix) == 0) {\n\
    \            result.push_back(str);\n        }\n    }\n    return result;", " \
    \ std::vector<std::string> result;\n  for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n    if (it->find(prefix) == 0)\n      result.push_back(*it);\n  }\n\
    \  return result;", "  assert(strings.size() > 0);\n  assert(prefix.size() > 0);\n\
    \  // We only want to include strings that start with the given prefix.\n  std::vector<std::string>\
    \ result;\n  std::size_t pos = 0;\n  while (pos < strings.size()) {\n    if (strings[pos].compare(0,\
    \ prefix.size(), prefix) == 0) {\n      result.push_back(strings[pos]);\n    }\n\
    \    pos++;\n  }\n  return result;", "  std::vector<std::string> retval;\n  retval.reserve(strings.size());\n\
    \  for (std::string word : strings) {\n    if (word.substr(0, prefix.size()) ==\
    \ prefix) {\n      retval.push_back(word);\n    }\n  }\n  return retval;", " \
    \   std::vector<std::string> result;\n    for (std::string &string : strings)\
    \ {\n        if (string.substr(0, prefix.size()) == prefix) {\n            result.emplace_back(string);\n\
    \        }\n    }\n    return result;", "  assert(!prefix.empty());\n  assert(!strings.empty());\n\
    \  std::vector<std::string> output;\n  for (const auto& string : strings) {\n\
    \    if (string.substr(0, prefix.size()) == prefix) {\n      output.push_back(string);\n\
    \    }\n  }\n  return output;", "  std::vector<std::string> result;\n  for (const\
    \ auto &str : strings)\n    if (str.startsWith(prefix))\n      result.push_back(str);\n\
    \  return result;", "  std::vector<std::string> result;\n  std::string prefix\
    \ = std::move(prefix);\n  for (auto &string : strings) {\n    if (string.substr(0,\
    \ prefix.size()) == prefix) {\n      result.push_back(std::move(string));\n  \
    \  }\n  }\n  return result;", "    // Create a map for O(1) lookup\n    std::unordered_map<std::string,int>\
    \ map;\n    for (std::string &s : strings) {\n        map[s.substr(0,prefix.size())]++;\n\
    \    }\n    std::vector<std::string> result;\n    for (auto &p : map) {\n    \
    \    if (p.second > 0) {\n            result.push_back(p.first);\n        }\n\
    \    }\n    return result;", "  std::vector<std::string> result;\n  for (auto\
    \ &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix) {\n\
    \      result.push_back(string);\n    }\n  }\n  return result;", "  assert(!prefix.empty());\n\
    \  std::cout << \"Filter by prefix: \" << prefix << std::endl;\n  std::vector<std::string>\
    \ ret;\n  for (auto& s : strings) {\n    if (s.substr(0, prefix.size()) == prefix)\
    \ {\n      ret.push_back(s);\n    }\n  }\n  return ret;", "  assert(strings.size()\
    \ > 0);\n  assert(strings.size() == prefix.length());\n  \n  std::vector<std::string>\
    \ out;\n  for (std::string str : strings) {\n    if (str.substr(0, prefix.length())\
    \ == prefix) {\n      out.push_back(str);\n    }\n  }\n  return out;", "  std::vector<std::string>\
    \ result;\n  for (auto &s : strings) {\n    if (s.starts_with(prefix)) {\n   \
    \   result.push_back(s);\n    }\n  }\n  return result;", "    std::vector<std::string>\
    \ result;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.length())\
    \ == prefix) {\n            result.push_back(str);\n        }\n    }\n    return\
    \ result;", "    std::vector<std::string> result;\n    for(std::string s : strs)\
    \ {\n        if(s.compare(0, prefix.size(), prefix) == 0) {\n            result.push_back(s);\n\
    \        }\n    }\n    return result;", "  std::set<std::string> s;\n  for (auto\
    \ i = strings.begin(); i != strings.end(); ++i) {\n    if (s.find(*i) != s.end())\
    \ {\n      s.insert(*i);\n    } else {\n      s.insert(prefix + strings[i]);\n\
    \    }\n  }\n  return std::vector<std::string>(s.begin(), s.end());", "  auto\
    \ it = std::begin(strings);\n  while (it != std::end(strings)) {\n    auto pos\
    \ = prefix.find(it->begin(), 0);\n    if (pos != std::string::npos) {\n      it\
    \ = std::erase(it, std::next(it), pos);\n    } else {\n      ++it;\n    }\n  }\n\
    \  return strings;", "  std::vector<std::string> result;\n  for (auto i : strings)\
    \ {\n    if (i.startsWith(prefix)) {\n      result.push_back(i);\n    }\n  }\n\
    \  return result;", "  std::vector<std::string> output;\n  // We loop over all\
    \ the strings in the given list and compare them to the prefix.\n  for (std::string\
    \ string : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n\
    \      // We add the string to the output list.\n      output.push_back(string);\n\
    \    }\n  }\n  return output;", "    std::vector<std::string> result;\n    for\
    \ (const auto& string : strings) {\n        if (string.substr(0, prefix.length())\
    \ == prefix) {\n            result.push_back(string);\n        }\n    }\n    return\
    \ result;", "  std::vector<std::string> retval;\n  retval.push_back(strings[0]);\n\
    \  for (size_t i = 1; i < strings.size(); i++) {\n    if (strings[i].compare(0,\
    \ prefix.size(), prefix) == 0) {\n      retval.push_back(strings[i]);\n    }\n\
    \  }\n  return retval;", "    std::vector<std::string> result;\n    std::string\
    \ prefix_copy = prefix;\n\n    for (size_t i = 0; i < (int) strings.size(); i++)\
    \ {\n        size_t pos = strings[i].find(prefix_copy);\n        if (pos == 0)\
    \ // If it starts with the prefix\n            result.push_back(strings[i]);\n\
    \    }\n    return result;", "  std::vector<std::string> results;\n  for (auto\
    \ string : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n\
    \      results.push_back(string);\n    }\n  }\n  return results;", "  std::vector<std::string>\
    \ out;\n  for (auto it = strings.begin(); it != strings.end(); ++it) {\n    if\
    \ (it->substr(0, prefix.size()) == prefix) {\n      out.emplace_back(*it);\n \
    \   }\n  }\n  return out;", "    std::vector<std::string> out;\n    // Loop through\
    \ the strings and see if they match the prefix, if so, keep it.\n    for (std::string\
    \ & str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n\
    \            out.push_back(str);\n        }\n    }\n    // Return the result.\n\
    \    return out;", "  std::vector<std::string> result;\n  for (std::string s :\
    \ strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> filtered;\n  for (auto\
    \ & string : strings) {\n    if (string.length() >= prefix.size() && string.substr(0,\
    \ prefix.size()) == prefix) {\n      filtered.push_back(string);\n    }\n  }\n\
    \  return filtered;", "  assert(strings.empty() || strings.front() == prefix);\n\
    \  \n  // If the string is not empty, then we return an empty vector.\n  if (strings.size())\
    \ return strings;\n\n  // We are going to return a vector of strings.\n  std::vector<std::string>\
    \ result;\n  result.push_back(prefix);\n  return result;", "  std::vector<std::string>\
    \ result;\n  for (auto s: strings) {\n    if (s.startsWith(prefix))\n      result.push_back(s);\n\
    \  }\n  return result;", "  std::vector<std::string> res;\n  for (auto &s : strings)\
    \ {\n    if (s.substr(0, prefix.size()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;", "  // Initialize the list of filtered strings.\n\
    \  std::vector<std::string> filtered_strings;\n  // If the prefix is empty, we're\
    \ done.\n  if (prefix.empty()) {\n    return filtered_strings;\n  }\n  // Add\
    \ the first string to the list if the prefix does not match it.\n  if (strings.find(prefix)\
    \ == strings.end()) {\n    filtered_strings.push_back(strings.at(0));\n  }\n \
    \ // Otherwise, keep iterating through the strings and adding strings that match\
    \ the prefix\n  // until we get to the end of our list.\n  int prefix_length =\
    \ prefix.length();\n  for (auto it = strings.begin(); it != strings.end(); it++)\
    \ {\n    // If the current string matches the prefix, add the string to the list\
    \ of filtered strings.\n    if (std::find(prefix.begin(), prefix.end(), *it) !=\
    \ prefix.end()) {\n      filtered_strings.push_back(*it);\n    } else {\n    \
    \  // If we are at the end of our list and our prefix is longer than the string\
    \ we are on of\n      // the list, the prefix has been found and we are done.\n\
    \      if ((it == strings.end()) && prefix_length != 0) {\n        break;\n  \
    \    }\n      // Otherwise, keep iterating through the list of strings adding\
    \ strings that match the prefix\n      // until the end of our list or the current\
    \ string does not match the prefix any longer.\n      prefix_length--;\n    }\n\
    \  }\n  // Return the filtered list of strings.\n  return filtered_strings;",
  "  std::vector<std::string> result;\n  for (std::string str : strings) {\n    if\
    \ (str.find(prefix) == 0) {\n      result.push_back(str);\n    }\n  }\n  return\
    \ result;", "  assert(strings.size() > 0);\n  assert(strings[0].find(prefix) ==\
    \ 0);\n  std::regex prefix_regex(prefix);\n  std::vector<std::string> ret;\n \
    \ for (std::string &s : strings)\n    if (regex_search(s, prefix_regex))\n   \
    \   ret.push_back(s);\n  return ret;", "  std::vector<std::string> results;\n\
    \  for (const auto &s : strings) {\n    if (s.substr(0, prefix.length()) == prefix)\
    \ {\n      results.push_back(s);\n    }\n  }\n  return results;", "    std::vector<std::string>\
    \ out;\n    for (auto& s : strings) {\n        if (s.startsWith(prefix)) {\n \
    \           out.push_back(s);\n        }\n    }\n    return out;", "    std::vector<std::string>\
    \ result;\n    for (auto& string : strings) {\n        if (string.length() > prefix.length()\
    \ && string.substr(0, prefix.length()) == prefix) {\n            result.push_back(string);\n\
    \        }\n    }\n    return result;", "    std::vector<std::string> result;\n\
    \    std::string prefix_with_leading_space = prefix + std::string(\"  \");\n \
    \   \n    for (const auto& string : strings) {\n        if (string.find(prefix)\
    \ == 0) {\n            result.push_back(prefix_with_leading_space + string);\n\
    \        }\n    }\n    return result;", "  assert(strings.size() > 0);\n  std::vector<std::string>\
    \ result;\n  result.push_back(strings[0]);\n  for (size_t i = 1; i < strings.size();\
    \ i++) {\n    std::string suffix = strings[i];\n    if (suffix.find(prefix) ==\
    \ 0) {\n      result.push_back(suffix);\n    }\n  }\n  return result;", "  assert(strings.size()>0);\n\
    \  std::vector<std::string> filtered;\n  for (std::vector<std::string>::const_iterator\
    \ it = strings.begin(); it != strings.end(); ++it)\n    {\n      if (it->find(prefix)\
    \ == 0)\n        filtered.push_back(*it);\n    }\n  return filtered;", "  std::vector<std::string>\
    \ result;\n  std::string prefixStr(prefix);\n  std::regex pattern(prefixStr +\
    \ \"([a-zA-Z]+)\");\n  for (std::string s : strings)\n    if (std::regex_search(s,\
    \ pattern))\n      result.push_back(s);\n  return result;", "    std::vector<std::string>\
    \ filtered;\n    for (std::string s : strings)\n        if (s.substr(0, prefix.length())\
    \ == prefix)\n            filtered.push_back(s);\n    return filtered;", "   \
    \ std::vector<std::string> filtered;\n    std::copy(std::begin(strings), std::end(strings),\
    \ std::back_inserter(filtered));\n    return std::remove_if(filtered.begin(),\
    \ filtered.end(), [&prefix](const std::string &s) { return s.find(prefix) == 0;\
    \ });", "  std::vector<std::string> result;\n  for (int i = 0; i < strings.size();\
    \ i++) {\n    if (strings[i].substr(0, prefix.length()) == prefix) {\n      result.push_back(strings[i]);\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> res;\n  for (const\
    \ auto &s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n    \
    \  res.push_back(s);\n    }\n  }\n  return res;", "    std::vector<std::string>\
    \ new_strings;\n    new_strings.reserve(strings.size());\n    for (auto &string\
    \ : strings) {\n        if (string.substr(0, prefix.length()) == prefix) {\n \
    \           new_strings.push_back(string);\n        }\n    }\n    return new_strings;",
  "  std::vector<std::string> retval;\n  for (std::string s : strings) {\n    if (s.substr(0,\
    \ prefix.size()) == prefix) {\n      retval.push_back(s);\n    }\n  }\n  return\
    \ retval;", "  std::vector<std::string> ret;\n  for (std::string &str : strings)\
    \ {\n    if (str.compare(0, prefix.size(), prefix) == 0) {\n      ret.push_back(str);\n\
    \    }\n  }\n  return ret;", "  std::vector <std::string> result;\n  for (int\
    \ i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0, prefix.size())\
    \ == prefix) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;",
  "  std::vector<std::string> result;\n  result.reserve(strings.size());\n  for (std::string&\
    \ s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> filteres;\n  for(auto\
    \ &s : strings) {\n    if(s.substr(0, prefix.length()) == prefix) {\n      filteres.push_back(s);\n\
    \    }\n  }\n  return filteres;", "  std::vector<std::string> result;\n  for (auto\
    \ &string : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n\
    \      result.push_back(string);\n    }\n  }\n  return result;", "  // Store prefix\
    \ in a set for faster lookups\n  std::set<std::string> prefixes;\n  for (const\
    \ auto &string : strings) {\n    auto pos = string.find(prefix);\n    if (pos\
    \ != std::string::npos) {\n      // Add prefix to the set and remove it from string\n\
    \      prefixes.insert(string.substr(0, pos));\n      strings.erase(std::remove(strings.begin(),\
    \ strings.end(), string), strings.end());\n    }\n  }\n  return strings;", " \
    \   std::vector<std::string> res;\n    std::remove_copy_if(strings.begin(), strings.end(),\
    \ std::back_inserter(res), [&prefix](const std::string &s) {\n        return s.find(prefix)\
    \ == 0;\n    });\n    return res;", "    std::vector<string> ans;\n    // for\
    \ each string\n    for(auto &it: strings) {\n        // if its prefix matches\
    \ our prefix filter\n        if(it.find(prefix) == 0) {\n            ans.push_back(it);\n\
    \        }\n    }\n    return ans;", "  std::vector<std::string> result;\n  std::string\
    \ prefix_stripped = prefix;\n  while (!prefix_stripped.empty()) {\n    prefix_stripped.erase(std::remove(prefix_stripped.begin(),\
    \ prefix_stripped.end(), '-'), prefix_stripped.end());\n    if (prefix_stripped.empty())\n\
    \      break;\n  }\n  for (auto& str : strings)\n    if (str.substr(0, prefix_stripped.size())\
    \ == prefix_stripped)\n      result.push_back(str);\n  return result;", "  std::vector<std::string>\
    \ result;\n  for (auto &string : strings) {\n    if (string.startsWith(prefix))\
    \ {\n      result.emplace_back(string);\n    }\n  }\n  return result;", "  std::vector<std::string>\
    \ output;\n  for (auto const &s : strings) {\n    if (s.substr(0, prefix.length())\
    \ == prefix) {\n      output.push_back(s);\n    }\n  }\n  return output;", " \
    \ std::vector<std::string> filtered_strings;\n  for (std::string &string : strings)\
    \ {\n    if (string.substr(0, prefix.length()) == prefix) {\n      filtered_strings.push_back(string);\n\
    \    }\n  }\n  return filtered_strings;", "    std::vector<std::string> out;\n\
    \    for (auto &string : strings) {\n        if (string.length() >= prefix.size()\
    \ &&\n            string.substr(0, prefix.size()) == prefix) {\n            out.push_back(string);\n\
    \        }\n    }\n    return out;", "  std::vector<std::string> results;\n  std::transform(strings.begin(),\
    \ strings.end(), std::back_inserter(results),\n      [](const std::string& s)\
    \ { return s.substr(0, prefix.length()); });\n  return results;", "  std::vector<std::string>\
    \ output;\n  for (std::string curString : strings) {\n    if (curString.substr(0,\
    \ prefix.size()) == prefix) {\n      output.push_back(curString);\n    }\n  }\n\
    \  return output;", "  std::vector<std::string> result;\n  if (strings.size()\
    \ == 0)\n    return result;\n\n  for (size_t i = 0; i < strings.size(); ++i) {\n\
    \    if (strings[i].substr(0, prefix.length()) == prefix) {\n      result.push_back(strings[i]);\n\
    \    }\n  }\n\n  return result;"]
stop_tokens:
- "\n}"
