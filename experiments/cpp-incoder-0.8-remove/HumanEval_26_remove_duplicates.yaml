name: HumanEval_26_remove_duplicates
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// From a list of integers,\
  \ remove all elements that occur more than once.\n// Keep order of elements left\
  \ the same as in the input.\nstd::vector<long> remove_duplicates(std::vector<long>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>()))\
  \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3,\
  \ (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
  \ (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4,\
  \ (long)5})));\n}\n"
completions: ["  long long ans = 0;\n  for (size_t i = 0; i < numbers.size(); i++)\
    \ {\n    if (numbers.count(numbers[i]) > 1) {\n      numbers--;\n      ans++;\n\
    \    }\n  }\n  return std::vector<long>(&numbers[ans], &numbers[ans + 1]);", " \
    \   std::set<long> seen;\n    std::vector<long> output;\n    long temp = 0;\n\
    \    for (const auto& num : numbers)\n        if (seen.find(num) != seen.end())\n\
    \            continue;\n        seen.insert(num);\n        output.push_back(temp);\n\
    \        temp = num;\n    return output;", "  std::vector<long> result;\n  long\
    \ count = 0;\n  std::sort(numbers.begin(), numbers.end());\n  for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n    if (it != numbers.begin() && *it == *(it -\
    \ 1)) {\n      continue;\n    }\n    if (count == 0) {\n      result.push_back(*it);\n\
    \    } else {\n      if (*it == result[result.size() - 1]) {\n        result.push_back(*it);\n\
    \        ++count;\n      } else {\n        result.push_back(*it);\n        count\
    \ = 1;\n      }\n    }\n  }\n  return result;", "    std::vector<long> result(numbers.begin(),\
    \ numbers.end());\n    std::sort(numbers.begin(), numbers.end());\n    auto it\
    \ = std::unique(numbers.begin(), numbers.end());\n    result.erase(it, numbers.end());\n\
    \    return result;", "    std::sort(numbers.begin(), numbers.end());\n\n    std::vector<long>\
    \ output;\n\n    auto current_element = numbers.begin();\n    auto last_element\
    \ = numbers.begin();\n\n    while (current_element != numbers.end()) {\n     \
    \   if (*current_element != *(last_element + 1)) {\n            output.push_back(*current_element);\n\
    \            last_element = current_element;\n        }\n\n        current_element++;\n\
    \    }\n\n    return output;", "  std::vector<long> ret;\n  if (numbers.empty())\n\
    \    return ret;\n\n  std::sort(numbers.begin(), numbers.end());\n  size_t last\
    \ = numbers.size() - 1;\n  for (size_t i = 0; i < last; ++i) {\n    if (numbers[i]\
    \ == numbers[last - i])\n      continue;\n    ret.push_back(numbers[i]);\n  }\n\
    \  ret.push_back(numbers[last]);\n  return ret;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> result;\n  long prev = numbers[0];\n  for\
    \ (size_t i = 1; i < numbers.size(); ++i) {\n    if (numbers[i] != prev) {\n \
    \     result.push_back(numbers[i]);\n      prev = numbers[i];\n    }\n  }\n  return\
    \ result;", "    std::vector<long> new_numbers;\n    std::unordered_set<long>\
    \ seen;\n    for (const auto number : numbers) {\n        if (seen.count(number)\
    \ == 0) {\n            new_numbers.push_back(number);\n            seen.insert(number);\n\
    \        }\n    }\n    return new_numbers;", "    // Create a map of distinct\
    \ numbers, and keep track of their current count.\n    map<long, int> counts;\n\
    \    std::vector<long> duplicates;\n\n    // Iterate over all numbers, incrementing\
    \ the count.\n    for (long number : numbers) {\n        int c = counts[number];\n\
    \        counts[number] = ++c;\n\n        // If a count of 1 then this number\
    \ has never been seen before.\n        // So add it to the output and mark it\
    \ as not being part of a duplicate.\n        if (c == 1) {\n            duplicates.push_back(number);\n\
    \        }\n    }\n\n    // Return the distinct numbers, in order of occurrence\
    \ of occurrence\n    return duplicates;", "  numbers.sort();\n  std::vector<long>\
    \ new_numbers;\n  long unique = 1;\n  for (auto i : numbers) {\n    if (i == unique)\
    \ {\n      continue;\n    }\n    new_numbers.push_back(i);\n    unique++;\n  }\n\
    \  return new_numbers;", "  std::vector<long> output;\n  std::set<long> unique;\n\
    \n  for (auto number : numbers) {\n    unique.insert(number);\n  }\n\n  for (auto\
    \ const &number : unique) {\n    output.push_back(number);\n  }\n\n  return output;",
  "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> result(numbers.size());\n\
    \    for (size_t i = 0, j = numbers.size(); i < j; ++i) {\n        while (i !=\
    \ j && numbers[i] == numbers[j]) {\n            result[j] = numbers[j];\n    \
    \        ++j;\n        }\n    }\n    numbers.swap(result);\n    return numbers;",
  "    std::vector<long> result;\n    std::unordered_set<long> set;\n    for (auto\
    \ i : numbers) {\n        if (set.find(i) == set.end()) {\n            result.push_back(i);\n\
    \            set.insert(i);\n        }\n    }\n    return result;", "    // This\
    \ code solves the example in the lecture notes.\n    // Removing duplicates is\
    \ an example of counting sort.\n    // For a general case, see: http://www.algorithmist.com/index.php/Counting_sort\n\
    \    std::vector<long> counts(numbers.size(), 0); // Stores how many times each\
    \ number occurs.\n    for (long &n : numbers) {\n        counts[n]++; // Increase\
    \ count for each number in list.\n    }\n    std::vector<long> result;\n    for\
    \ (long i = 0; i < numbers.size() - 1; i++) {\n        long max_count = 0;\n \
    \       for (long j = 0; j < counts[j]; j++) {\n            if (counts[j] > max_count)\
    \ {\n                result.push_back(numbers[i]);\n                max_count\
    \ = counts[j];\n            }\n        }\n    }\n    return result;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  numbers.erase(std::unique(numbers.begin(), numbers.end()),\
    \ numbers.end());\n  return numbers;", "    std::vector<long> new_numbers;\n \
    \   new_numbers.reserve(numbers.size());\n    std::set<long> dups;\n    for(auto\
    \ i : numbers) {\n        if(dups.find(i) == dups.end()) {\n            dups.insert(i);\n\
    \            new_numbers.push_back(i);\n        }\n    }\n    return new_numbers;",
  "  assert(numbers.size() > 0);\n  std::set<long> numbers_set;\n  numbers.push_back(1);\
    \ // Set first number to 1.\n  for (size_t i = 1; i < numbers.size(); i++) {\n\
    \    numbers_set.insert(numbers[i]);\n  }\n\n  std::vector<long> result;\n  while\
    \ (numbers_set.size()) {\n    auto it = numbers_set.begin();\n    result.push_back(it->second);\n\
    \    numbers_set.erase(it);\n  }\n  return result;", "    int new_length = numbers.size();\n\
    \    int previous_value = numbers[0];\n    std::vector<long> new_vec;\n    new_vec.reserve(new_length);\n\
    \    for (int i = 1; i < new_length; i++) {\n        if (numbers[i] != previous_value)\
    \ {\n            new_vec.push_back(numbers[i]);\n            previous_value =\
    \ numbers[i];\n        }\n    }\n    return new_vec;", "    std::vector<long>\
    \ res;\n    for (long num : numbers) {\n        if (res.count(num)) {\n      \
    \      res.erase(std::remove(numbers.begin(), numbers.end(), num), numbers.end());\n\
    \        } else {\n            res.push_back(num);\n        }\n    }\n    return\
    \ res;", "  std::sort(numbers.begin(), numbers.end());\n  numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n  return numbers;", "    std::vector<long>\
    \ result;\n    std::set<long> seen;\n    for (long number : numbers) {\n     \
    \   if (seen.find(number) == seen.end()) {\n            result.push_back(number);\n\
    \            seen.insert(number);\n        }\n    }\n    return result;", "  \
    \  std::vector<long> output;\n    std::unordered_set<long> seen;\n    for(auto\
    \ it = numbers.begin(); it != numbers.end(); ++it) {\n        if (seen.find(*it)\
    \ == seen.end()) {\n            seen.insert(*it);\n            output.push_back(*it);\n\
    \        }\n    }\n    return output;", "    // Create a set from the input.\n\
    \    std::set<long> set_of_numbers(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    // For each number in set, push it into the result if it wasn't\
    \ found yet.\n    for (long number : set_of_numbers) {\n        if (result.find(number)\
    \ == result.end())\n            result.push_back(number);\n    }\n    return result;",
  "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long> uniques;\n  for\
    \ (long x : numbers) {\n    if (uniques.size() < 2) {\n      uniques.push_back(x);\n\
    \    } else {\n      bool found_duplicate = false;\n      for (long y : uniques)\
    \ {\n        if (x == y) {\n          found_duplicate = true;\n          break;\n\
    \        }\n      }\n      if (!found_duplicate) {\n        uniques.push_back(x);\n\
    \      }\n    }\n  }\n  return uniques;", "    std::vector<long> new_numbers;\n\
    \    long last_number = numbers[0];\n    for (auto number : numbers) {\n     \
    \   if (number == last_number) {\n            continue;\n        }\n        new_numbers.push_back(number);\n\
    \        last_number = number;\n    }\n    return new_numbers;", "    std::vector<long>\
    \ output;\n    long ans=0;\n    for(long i=0; i<numbers.size(); ++i) {\n     \
    \   for(long j=i+1; j<numbers.size(); ++j) {\n            if(numbers[i]==numbers[j])\
    \ {\n                numbers[j]=0;\n            }\n        }\n    }\n    for(long\
    \ j=0; j<numbers.size(); ++j) {\n        if(numbers[j]!=0) {\n            ans\
    \ += numbers[j];\n            output.push_back(ans);\n        }\n    }\n    return\
    \ output;", "  std::vector<long> unique_elements;\n  unique_elements.reserve(numbers.size());\n\
    \  std::sort(numbers.begin(), numbers.end());\n  long prev_number = numbers[0];\n\
    \  for (long number : numbers) {\n    if (number == prev_number) {\n      continue;\n\
    \    }\n    unique_elements.push_back(number);\n    prev_number = number;\n  }\n\
    \  return unique_elements;", "  std::vector<long> new_numbers;\n  long current\
    \ = numbers[0];\n  new_numbers.push_back(current);\n  for (int i = 1; i < numbers.size();\
    \ ++i) {\n    if (current == numbers[i]) {\n      continue;\n    } else {\n  \
    \    current = numbers[i];\n      new_numbers.push_back(current);\n    }\n  }\n\
    \  return new_numbers;", "    // Create a map of counters for number of repetitions\
    \ of each element\n    std::map<long, int> counter;\n    for (long num : numbers)\n\
    \        ++counter[num];\n    // Keep a vector of numbers that have been seen\
    \ and remove the\n    // duplicates.\n    std::vector<long> seen;\n    for (long\
    \ num : numbers)\n        if (counter[num] > 1) {\n            seen.push_back(counter[num]);\n\
    \            counter[num] = 1;\n        }\n    std::vector<long> output;\n   \
    \ for (long num : seen)\n        output.push_back(num);\n    return output;",
  "    std::vector<long> result;\n    std::vector<long>::iterator it = numbers.begin();\n\
    \    std::vector<long>::iterator end = numbers.end();\n    for ( ; it != end;\
    \ ++it) {\n        bool found = false;\n        for (std::vector<long>::iterator\
    \ it = numbers.begin(); it != end; ++it) {\n            if (*it == *it) {\n  \
    \              found = true;\n                break;\n            }\n        }\n\
    \        if (!found) {\n            result.push_back(*it);\n        }\n    }\n\
    \    return result;", "    // write your code here\n    std::vector<long> newNumbers;\n\
    \    int n = numbers.size();\n    \n    for (int i = 0; i < n; ++i) {\n      \
    \  long count = 0;\n        \n        for (int j = 0; j < i; ++j) {\n        \
    \    if (numbers[i] == numbers[j]) {\n                count++;\n            }\n\
    \        }\n        \n        if (count > 1) {\n            newNumbers.push_back(numbers[i]);\n\
    \        }\n    }\n    return newNumbers;", "  // We use a map to count the number\
    \ of times each number appears in the input.\n  std::unordered_map<long, int>\
    \ counts;\n  for (long i : numbers) counts[i]++;\n\n  // Now, for each number,\
    \ if it's been seen before, don't include it in the output.\n  std::vector<long>\
    \ output;\n  for (long i : numbers) {\n    if (counts[i] > 1) output.push_back(i);\n\
    \  }\n\n  return output;", "  std::vector<long> result;\n  std::set<long> seen;\n\
    \  for (auto const &n : numbers) {\n    if (seen.count(n) == 0) {\n      result.push_back(n);\n\
    \      seen.insert(n);\n    }\n  }\n  return result;", "  std::vector<long> result;\n\
    \  std::set<long> numbers_set;\n  for (int num : numbers) {\n    numbers_set.insert(num);\n\
    \  }\n\n  for (int i = 0; i < numbers.size(); i++) {\n    if (numbers_set.find(numbers[i])\
    \ == numbers_set.end()) {\n      result.push_back(numbers[i]);\n      numbers_set.insert(numbers[i]);\n\
    \    }\n  }\n\n  return result;", "    std::vector<long> output; // Vector to\
    \ store unique elements.\n    std::set<long> setNumbers; // Set of unique numbers.\n\
    \    \n    for(long number : numbers) {\n        if (setNumbers.count(number)\
    \ != 0) { // Check if number is already in the set.\n            output.push_back(number);\n\
    \        }\n        else {\n            setNumbers.insert(number);\n        }\n\
    \    }\n    \n    return output;", "  std::sort(numbers.begin(), numbers.end());\
    \ //sorting the array\n  std::vector<long> new_nums(numbers.size());\n  for (int\
    \ i = 0; i < numbers.size(); ++i) {\n    int cnt = 0;\n    for (int j = i + 1;\
    \ j < numbers.size(); ++j) {\n      if (numbers[i] == numbers[j]) {\n        ++cnt;\n\
    \      }\n    }\n    if (cnt > 1) {\n      new_nums[i] = numbers[i];\n    } else\
    \ {\n      new_nums[i] = numbers[i - cnt];\n    }\n  }\n  return new_nums;", " \
    \   std::vector<long> results;\n\n    // We need to use the std::unique algorithm\
    \ here, because this is\n    // a very common use-case for a set.\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::unique(numbers.begin(), numbers.end());\n    results.reserve(numbers.size());\n\
    \    for (long number : numbers) {\n        if (results.count(number) == 0)\n\
    \            results.push_back(number);\n    }\n\n    return results;", "  std::vector<long>\
    \ ret;\n  // Sort the list so duplicates will be removed consistently for consistency.\n\
    \  std::sort(numbers.begin(), numbers.end());\n  // Iterate through the list until\
    \ no duplicate elements remain.\n  // Each time a duplicate is found, remove both\
    \ and break.\n  for (int i = 1; i < numbers.size(); ++i) {\n    if (numbers[i]\
    \ != numbers[i - 1]) {\n      ret.push_back(numbers[i]);\n      break;\n    }\n\
    \  }\n  return ret;", "    std::vector<long> result;\n    std::set<long> seen;\n\
    \    for(const auto& val : numbers) {\n        if (seen.find(val) != seen.end())\
    \ {\n            continue;\n        }\n        seen.insert(val);\n        result.push_back(val);\n\
    \    }\n    return result;", "    std::vector<long> new_numbers;\n    long current_number\
    \ = 0;\n\n    for (auto x : numbers) {\n        if (x != current_number) {\n \
    \           current_number = x;\n            new_numbers.push_back(current_number);\n\
    \        }\n    }\n    return new_numbers;", "    // Sort numbers to maintain\
    \ order.\n    numbers.sort();\n\n    // Declare a vector to hold elements as we\
    \ find them.\n    std::vector<long> duplicates;\n\n    // Iterate through the\
    \ sorted list and remove duplicate elements.\n    for (long i = 0; i < numbers.size();\
    \ i++) {\n        // Add element to result if not already in result and we\n \
    \       // haven't seen this element before.\n        if (duplicates.empty() ||\
    \ duplicates.back() != numbers[i]) {\n            if (duplicates.empty() || duplicates.back()\
    \ != numbers[i]) {\n                duplicates.push_back(numbers[i]);\n      \
    \      }\n        }\n    }\n\n    // Return result.\n    return duplicates;",
  "  std::vector<long> sorted_numbers(numbers);\n  std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n  int j = 0;\n  std::vector<long> duplicates;\n  while\
    \ (j < sorted_numbers.size()) {\n    if (sorted_numbers[j] == sorted_numbers[j\
    \ + 1]) j++;\n    else duplicates.push_back(sorted_numbers[j]);\n  }\n  return\
    \ duplicates;", "    std::vector<long> ret;\n    std::unordered_set<long> nums;\n\
    \    for (long i : numbers) {\n        nums.insert(i);\n    }\n    while (nums.size())\
    \ {\n        ret.push_back(nums.rbegin()->first);\n        nums.erase(nums.begin());\n\
    \    }\n    return ret;", "    std::vector<long> result;\n    std::set<long> visited;\n\
    \    for(long i : numbers)\n    {\n        if(visited.count(i) == 0)\n       \
    \ {\n            result.push_back(i);\n            visited.insert(i);\n      \
    \  }\n    }\n    return result;", "    // Write your code here.\n    \n    for(long\
    \ i=0;i<numbers.size();++i)\n    {\n        for(long j=i+1;j<numbers.size();++j)\n\
    \        {\n            if(numbers[i]==numbers[j])\n            {\n          \
    \      numbers.erase(numbers.begin()+j);\n                --j;\n            }\n\
    \        }\n    }\n    return numbers;", "    std::unordered_map<long, int> count;\n\
    \    for (auto num : numbers) {\n        if (count.find(num) != count.end())\n\
    \            count[num]++;\n        else\n            count[num] = 1;\n    }\n\
    \    std::vector<long> new_num;\n    for (auto num : numbers)\n        if (count.find(num)\
    \ == count.end())\n            new_num.push_back(num);\n    return new_num;",
  "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long> result;\n  for\
    \ (size_t i = 1; i < numbers.size(); i++) {\n    if (numbers[i] != numbers[i -\
    \ 1]) {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;", " \
    \ std::sort(numbers.begin(), numbers.end());\n  std::vector<long> result;\n  result.push_back(numbers[0]);\n\
    \  for (size_t i = 1; i < numbers.size(); i++) {\n    if (numbers[i] != result[result.size()\
    \ - 1]) {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;",
  "    std::vector<long> result;\n    std::unordered_set<long> seen;\n    for (long\
    \ num : numbers)\n        if (seen.find(num) == seen.end())\n            seen.insert(num);\n\
    \        else\n            result.push_back(seen[num]);\n    return result;",
  "    // This code can be written more efficiently using counting sort, but I wanted\
    \ to show a simple algorithm.\n    std::vector<long> output(num_elements);\n \
    \   std::iota(output.begin(), output.end(), 0);\n    std::sort(output.begin(),\
    \ output.end(), [&](long a, long b) { return numbers[a] > numbers[b]; });\n  \
    \  \n    std::vector<long> result;\n    \n    // copy output to result and remove\
    \ all duplicate numbers\n    result.clear();\n    for (long index : output)\n\
    \        if (result.size() < num_elements)\n            result.push_back(numbers[index]);\n\
    \    \n    return result;", "    std::vector<long> output;\n    std::unordered_set<long>\
    \ seen;\n    \n    for (auto it : numbers) {\n        if (seen.count(it) == 0)\n\
    \            seen.insert(it);\n        else\n            output.push_back(it);\n\
    \    }\n    \n    return output;", "    std::vector<long> result;\n    std::set<long>\
    \ visited;\n    long n = numbers.size();\n    for (int i = 0; i < n; ++i) {\n\
    \        if (visited.count(numbers[i]) > 0) {\n            continue;\n       \
    \ }\n        visited.insert(numbers[i]);\n        result.push_back(numbers[i]);\n\
    \    }\n    return result;", "  // sort and remove duplicates\n  std::sort(numbers.begin(),\
    \ numbers.end());\n  numbers.erase(std::unique(numbers.begin(), numbers.end()),\
    \ numbers.end());\n  return numbers;", "  std::vector<long> new_numbers;\n  std::sort(numbers.begin(),\
    \ numbers.end());\n  for (int i = 0; i < numbers.size(); ++i) {\n    if (i !=\
    \ numbers.end() - 1) {\n      if (numbers[i] != numbers[numbers.end() - 1]) {\n\
    \        new_numbers.push_back(numbers[i]);\n      }\n    } else {\n      new_numbers.push_back(numbers[i]);\n\
    \    }\n  }\n  return new_numbers;", "  assert(numbers.size() != 0);\n  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> unique_numbers(numbers.size());\n  for\
    \ (int i = 1; i < numbers.size(); i++) {\n    if (numbers[i] != numbers[i - 1])\
    \ {\n      unique_numbers[i - 1]++;\n    }\n  }\n  return unique_numbers;", " \
    \   std::vector<long> result;\n    std::map<long, int> counts;\n    for(auto i\
    \ : numbers) ++counts[i];\n\n    for(auto i : numbers) {\n        auto it = counts.find(i);\n\
    \        if(it == counts.end()) continue;\n        if(it->second > 1) result.push_back(i);\n\
    \        counts[i]--;\n    }\n    return result;", "    // Create a vector with\
    \ unique numbers first.\n    std::vector<long> sorted_numbers;\n    for (long\
    \ number : numbers)\n        sorted_numbers.push_back(number);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n\n    // Keep track of unique numbers.\n    std::vector<long>\
    \ uniques;\n\n    for (long number : sorted_numbers) {\n        if (uniques.empty()\
    \ || number != uniques.back()) {\n            uniques.push_back(number);\n   \
    \     } else {\n            sorted_numbers.erase(std::remove(sorted_numbers.begin(),\
    \ sorted_numbers.end(), number), sorted_numbers.end());\n        }\n    }\n  \
    \  return uniques;", "    // sort the input array ascending.\n    std::vector<long>\
    \ sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\
    \n    // create an array of counters to keep track of how many times each number\
    \ has been seen.\n    std::vector<int> counter(sorted_numbers.size(), 0);\n\n\
    \    // iterate over all numbers and increment counter for every number seen\n\
    \    for (long number : sorted_numbers) {\n        if (counter[number] == 0) //\
    \ if this number hasn't been seen yet\n            counter[number] = 1; // mark\
    \ it seen\n        else\n            counter[number]++; // increment counter by\
    \ 1\n    }\n\n    // now remove all elements which haven't been seen more than\
    \ once\n    std::vector<long> result_vec(counter.begin(), counter.end());\n  \
    \  std::vector<int> result_index(counter.begin(), counter.end());\n\n    // copy\
    \ result vector into return vector\n    result_vec.resize(num_elements);\n   \
    \ result_index.resize(num_elements);\n    for (long i = 0; i < num_elements; ++i)\
    \ {\n        // check if this number has been seen more than once\n        if\
    \ (result_index[i] != i) {\n            // if so, copy from the result vector\
    \ to the return vector\n            result_vec[i] = numbers[result_index[i]];\n\
    \        }\n        // mark this number as seen so we don't get it the next time\
    \ we see it\n        result_index[i] = i;\n    }\n\n    return result_vec;", " \
    \ std::sort(numbers.begin(), numbers.end());\n\n  std::vector<long> ret;\n  ret.reserve(numbers.size());\n\
    \  for (size_t i = 1; i < numbers.size(); ++i) {\n    if (numbers[i] != numbers[i\
    \ - 1]) {\n      ret.push_back(numbers[i]);\n    }\n  }\n\n  return ret;", " \
    \ // O(n) time and O(n) space\n  unsigned current_index = 0;\n  unsigned remove_index\
    \ = 0;\n  while (current_index < numbers.size()) {\n    if (numbers[current_index]\
    \ == numbers[current_index + 1]) {\n      current_index++;\n      remove_index++;\n\
    \      continue;\n    }\n    if (remove_index != current_index) {\n      numbers.erase(numbers.begin()\
    \ + remove_index);\n      remove_index = 0;\n    }\n    numbers.push_back(numbers[current_index]);\n\
    \    current_index++;\n    remove_index++;\n  }\n  if (remove_index != current_index)\
    \ {\n    numbers.erase(numbers.begin() + remove_index);\n  }\n  return numbers;",
  "    std::vector<long> dup;\n    std::map<long, int> count;\n    for (auto val :\
    \ numbers) {\n        count[val] += 1;\n    }\n    for (auto val : numbers) {\n\
    \        if (count[val] == 1)\n            dup.push_back(val);\n    }\n    return\
    \ dup;", "    std::vector<long> result(numbers.begin(), numbers.end());\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::sort(result.begin(), result.end());\n    std::vector<long>\
    \ unique_numbers;\n    for(int i=1; i<numbers.size(); i++){\n        if(numbers[i]\
    \ == result[i-1]){\n            result.erase(std::remove(result.begin(), result.end(),\
    \ result[i-1]),\n                        result.end());\n        }\n        else{\n\
    \            unique_numbers.push_back(result[i-1]);\n        }\n    }\n    result.insert(result.begin(),\
    \ unique_numbers.begin(), unique_numbers.end());\n    return result;", "  std::sort(numbers.begin(),\
    \ numbers.end()); // Order of elements is preserved\n  std::vector<long> out;\n\
    \  out.reserve(numbers.size());\n  for (int i = 0; i < numbers.size(); i++) {\n\
    \    if (numbers[i] != numbers[i - 1]) {\n      out.push_back(numbers[i]);\n \
    \   }\n  }\n  return out;", "    // Sort the input\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Set of elements that have been seen before\n    std::set<long>\
    \ seen;\n    // New vector for output\n    std::vector<long> output;\n    // Loop\
    \ over all elements and remove from output if seen before\n    for (long num :\
    \ numbers) {\n        // If element has been seen before, remove from seen\n \
    \       if (seen.find(num) != seen.end()) {\n            seen.erase(num);\n  \
    \      } else {\n            output.push_back(num);\n        }\n    }\n    return\
    \ output;", "  std::vector<long> uniq_numbers;\n  std::set<long> unique_numbers;\n\
    \  for (long number : numbers) {\n    unique_numbers.insert(number);\n  }\n  for\
    \ (long number : unique_numbers) {\n    uniq_numbers.push_back(number);\n  }\n\
    \  return uniq_numbers;", "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long>\
    \ result;\n  long previous_number;\n  for(long number : numbers) {\n    if(number\
    \ == previous_number) {\n      result.push_back(number);\n    } else {\n     \
    \ result.push_back(previous_number);\n      previous_number = number;\n    }\n\
    \  }\n  return result;", "    std::vector<long> ordered_numbers;\n    std::map<long,\
    \ long> number_counts;\n    for (long number : numbers)\n        number_counts[number]++;\n\
    \    for (auto it = number_counts.begin(); it != number_counts.end(); ++it)\n\
    \        ordered_numbers.push_back(it->first);\n    ordered_numbers.push_back(numbers.back());\n\
    \    for (auto it = number_counts.begin(); it != number_counts.end(); ++it)\n\
    \        ordered_numbers.push_back(it->first);\n    return ordered_numbers;",
  "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long> ret;\n  for (long\
    \ & i : numbers)\n    ret.push_back(i);\n  std::sort(ret.begin(), ret.end());\n\
    \  return ret;", "    std::vector<long> result;\n    std::set<long> nums;\n  \
    \  for (long n: numbers) {\n        if (nums.count(n)) {\n            continue;\n\
    \        }\n        nums.insert(n);\n        result.push_back(n);\n    }\n   \
    \ return result;", "    std::vector<long> new_vector;\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    for (long x : numbers)\n        if (new_vector.size() ==\
    \ 0)\n            new_vector.push_back(x);\n        else if (new_vector.size()\
    \ == 1 && x == new_vector[0])\n            new_vector.erase(new_vector.begin());\n\
    \        else\n            new_vector.push_back(x);\n    return new_vector;",
  "  std::vector<long> new_numbers;\n  long count = 0;\n  for (long n : numbers) {\n\
    \    if (++count == 1)\n      new_numbers.push_back(n);\n  }\n  return new_numbers;",
  "    std::sort(numbers.begin(), numbers.end());\n    numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n    return numbers;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> duplicates(numbers.size(), 0);\n    for\
    \ (size_t i = 0; i < numbers.size(); ++i) {\n        if (duplicates[i]) {\n  \
    \          numbers.erase(std::remove(numbers.begin(), numbers.end(), numbers[i]),\n\
    \                          numbers.end());\n        } else {\n            duplicates[i]\
    \ = 1;\n        }\n    }\n    return numbers;", "    std::vector<long> temp(numbers.begin(),\
    \ numbers.end());\n    std::sort(temp.begin(), temp.end());\n    std::vector<long>\
    \ answer;\n    long count = 0;\n    for (long i : temp) {\n        if (count <\
    \ i) {\n            answer.push_back(count);\n            count = i;\n       \
    \ } else {\n            count++;\n        }\n    }\n    return answer;", "  //\
    \ Store the found element and its index\n  std::map<long, int> m;\n  // Initialize\
    \ a vector with zeros.\n  std::vector<long> result;\n  // Iterate through all\
    \ the numbers found and add them to result if they are not\n  // already in result\
    \ and if they are not in the map already.\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    // If there is no map entry for number i, add it.\n    // If there\
    \ is an entry for the number i, check if it occurs more than once.\n    auto it\
    \ = m.find(numbers[i]);\n    if (it == m.end()) {\n      result.push_back(numbers[i]);\n\
    \      m[numbers[i]] = i;\n    } else {\n      // If the number is already in\
    \ the result vector then remove it from the\n      // map and add it to result\
    \ again.\n      int index = it->second;\n      if (result[index % result.size()]\
    \ == numbers[i]) {\n        result[index % result.size()] = numbers[i];\n    \
    \  }\n    }\n  }\n  return result;", "    // Count how many times each number\
    \ occurs.\n    std::vector<std::pair<long, long> > counts(numbers.begin(), numbers.end());\n\
    \    std::vector<long> result;\n    std::unordered_map<long, long> new_counts;\n\
    \n    for (auto const& count : counts)\n        new_counts[count.first] += count.second;\n\
    \n    // For each number, count how many other numbers have that number.\n   \
    \ for (auto const& count : counts)\n        new_counts[count.first] -= count.second;\n\
    \n    // Add the counts themselves back in.\n    for (auto const& count : counts)\n\
    \        new_counts[count.first] += count.second;\n\n    // Iterate in reverse\
    \ order so highest count numbers are removed first.\n    // This prevents duplicate\
    \ numbers from getting filtered out.\n    for (std::size_t index = numbers.size()\
    \ - 1; index >= 0; --index) {\n        long number = numbers[index];\n       \
    \ if (new_counts[number] > 0)\n            result.push_back(number);\n    }\n\n\
    \    return result;", "    std::vector<long> ret;\n    std::map<long, long> m;\n\
    \    for(auto i:numbers) {\n        if(m.find(i)!=m.end()) continue;\n       \
    \ ret.push_back(i);\n        m[i]=i;\n    }\n    return ret;", "    std::vector<long>\
    \ temp(numbers.begin(), numbers.end());\n    std::sort(temp.begin(), temp.end());\n\
    \    std::vector<long> result;\n    long count = 0;\n    for (auto i : temp) {\n\
    \        if (i == temp[count]) {\n            continue;\n        }\n        result.push_back(i);\n\
    \        count++;\n    }\n    if (count != result.size()) {\n        throw std::invalid_argument(\"\
    Duplicates found\");\n    }\n    return std::move(result);", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> result;\n    for (long i : numbers) {\n\
    \        if (std::find(result.begin(), result.end(), i) == result.end()) {\n \
    \           result.push_back(i);\n        }\n    }\n    return result;", "   \
    \ int size = numbers.size();\n    std::vector<long> result(size);\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    for (int i = 0; i < size; ++i) {\n        for (int j =\
    \ i + 1; j < size; ++j) {\n            if (numbers[i] == numbers[j]) {\n     \
    \           numbers.erase(numbers.begin() + j);\n                --j;\n      \
    \      }\n        }\n        result[size - 1 - i] = numbers[i];\n    }\n    return\
    \ std::move(numbers);", "  std::vector<long> result;\n  std::unordered_set<long>\
    \ seen;\n  long hash = 0;\n  for (long elem : numbers) {\n    hash = hash ^ elem;\n\
    \    if (seen.count(hash))\n      continue;\n    seen.insert(hash);\n    result.push_back(elem);\n\
    \  }\n  return result;", "    std::vector<long> result;\n    std::set<long> seen;\n\
    \n    std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(seen), [](long\
    \ n) { return seen.find(n) != seen.end(); });\n\n    result.clear();\n    for(long\
    \ n: seen) result.push_back(n);\n    return result;", "    // Find how many times\
    \ each element appears in the input list\n    std::vector<std::pair<long, int>\
    \ > counts(numbers.begin(), numbers.end());\n    // Keep track of which elements\
    \ we've already seen\n    std::vector<long> seen(numbers.begin(), numbers.end());\n\
    \    // Keep track of the elements that have already been removed\n    std::vector<long>\
    \ removed(numbers.begin(), numbers.end());\n    // Loop through the input list,\
    \ keeping track of which elements we have yet to see\n    for (long i : counts)\
    \ {\n        // If we haven't seen this element before, add it and keep track\n\
    \        if (seen.find(i.first) == seen.end()) {\n            seen.push_back(i.first);\n\
    \            removed.push_back(i.first);\n        } else {\n            // Otherwise,\
    \ keep track of the elements that have already been seen\n            std::set<long>::iterator\
    \ j = seen.find(i.first);\n            assert(j != seen.end());\n            seen.erase(j);\n\
    \            removed.push_back(j->second);\n        }\n    }\n    return removed;",
  "  assert(!numbers.empty());\n  std::vector<long> result;\n  std::unordered_set<long>\
    \ seen(numbers.begin(), numbers.end());\n  for (long i : numbers) {\n    if (seen.count(i)\
    \ == 1)\n      result.push_back(i);\n    seen.insert(i);\n  }\n  return result;",
  "   std::sort(numbers.begin(), numbers.end());\n   numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n   return numbers;", "    std::vector<long>\
    \ result;\n    std::set<long> s;\n    for (long i : numbers) {\n        if (s.find(i)\
    \ == s.end()) {\n            s.insert(i);\n            result.push_back(i);\n\
    \        }\n    }\n    return result;", "    std::vector<long> ret;\n    ret.reserve(numbers.size());\n\
    \    std::unordered_set<long> seen { numbers.begin(), numbers.end() };\n    for\
    \ (auto n : numbers) {\n        if (!seen.count(n)) {\n            ret.push_back(n);\n\
    \            seen.insert(n);\n        }\n    }\n    return ret;", "    // Write\
    \ your code here.\n    std::vector<long> ret;\n    for (long i = 0; i < numbers.size();\
    \ ++i) {\n        if (numbers.find(i) != numbers.end()) {\n            numbers.erase(numbers.begin()+i);\n\
    \        }\n    }\n    return ret;", "  std::unordered_set<long> seen;\n  std::vector<long>\
    \ result;\n  long count = 1;\n  for (auto number : numbers) {\n    if (seen.count(number)\
    \ > 0) {\n      count += 1;\n    } else {\n      seen.insert(number);\n      result.push_back(number);\n\
    \      count += 1;\n    }\n  }\n  for (auto number : numbers) {\n    if (seen.count(number)\
    \ > 0) {\n      count -= 1;\n    }\n  }\n  return result;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    auto last = std::unique(numbers.begin(), numbers.end());\n\
    \    numbers.erase(last, numbers.end());\n    return numbers;", "  std::vector<long>\
    \ output;\n  output.insert(output.end(), numbers.begin(), numbers.end());\n  std::sort(output.begin(),\
    \ output.end());\n  long last = output[0];\n  for (auto it = numbers.begin() +\
    \ 1; it != numbers.end(); ++it) {\n    if (*it == last) {\n      output.erase(std::remove(output.begin(),\
    \ output.end(), *it), output.end());\n    } else {\n      last = *it;\n    }\n\
    \  }\n  return output;", "    // Traverse the list from left to right.\n    //\
    \ If the current element is equal to last element traversed then it has not been\
    \ visited.\n    // Otherwise, check if the current element has been visited before\
    \ by traversing the list from right to left.\n    std::vector<long> seen;\n  \
    \  std::vector<long> new_numbers;\n    long last = numbers[0];\n    for (const\
    \ long &i : numbers) {\n        if (i == last) {\n            continue;\n    \
    \    }\n\n        if (seen.find(i) == seen.end()) {\n            seen.push_back(i);\n\
    \            new_numbers.push_back(i);\n        } else {\n            auto it\
    \ = seen.rbegin();\n            while (it != seen.rend() && it != seen.rbegin()\
    \ && it != seen.rend()) {\n                if (*it == i) {\n                 \
    \   it++;\n                    continue;\n                }\n                it\
    \ = seen.erase(it);\n                new_numbers.push_back(i);\n             \
    \   break;\n            }\n        }\n\n        last = i;\n    }\n    return new_numbers;",
  "    std::vector<long> duplicates(numbers.size(), 0);\n\n    for (size_t i = 0;\
    \ i < numbers.size(); ++i) {\n        // If this number has already been seen,\
    \ skip it.\n        if (duplicates[i] != 0)\n            continue;\n        //\
    \ Otherwise, mark the number as having been seen and store it to\n        // the\
    \ output array.\n        duplicates[i] = 1;\n    }\n\n    return duplicates;",
  "    // Sort the list.\n    std::sort(numbers.begin(), numbers.end());\n    // Removing\
    \ elements while the number of duplicates is greater than or equal\n    // to\
    \ the total number of elements.\n    size_t num_remove = 0;\n    size_t num_equal\
    \ = 0;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i != 0\
    \ && num_equal > numbers.size() - num_remove)\n            break;\n        if\
    \ (numbers[i] == numbers[i - 1]) {\n            num_equal += 1;\n        } else\
    \ {\n            numbers.erase(numbers.begin() + i);\n            num_remove +=\
    \ 1;\n        }\n    }\n    // Copy the unique values into a vector.\n    std::vector<long>\
    \ new_values;\n    new_values.reserve(numbers.size());\n    std::copy_if(numbers.begin(),\
    \ numbers.end(), std::back_inserter(new_values),\n        [](long n) {\n     \
    \   return new_values.size() != new_values.max_size();\n    });\n    return new_values;",
  "  // Initialize a new result vector\n  std::vector<long> result;\n  // Iterate\
    \ over numbers\n  for (size_t i = 0; i < numbers.size(); ++i) {\n    // If the\
    \ current number is in the result, skip\n    if (std::find(result.begin(), result.end(),\
    \ numbers[i]) != result.end())\n      continue;\n    // If number is not in result,\
    \ add it to the result\n    result.push_back(numbers[i]);\n  }\n  return result;",
  "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long> sorted_numbers(numbers);\n\
    \  std::sort(sorted_numbers.begin(), sorted_numbers.end());\n  std::vector<long>\
    \ sorted_number_counts(sorted_numbers.size());\n  // Count occurrences of each\
    \ element\n  for (size_t i = 0; i < sorted_numbers.size(); i++)\n    sorted_number_counts[i]\
    \ = sorted_numbers.size() - i;\n\n  // Keep left most occurrence of each element\n\
    \  std::vector<long> sorted_number_counts_left(sorted_number_counts.size(),\n\
    \      sorted_number_counts[0]);\n  for (size_t i = 1; i < sorted_number_counts.size();\
    \ i++)\n    sorted_number_counts_left[i] = sorted_number_counts[i - 1] + sorted_number_counts[i];\n\
    \n  // Create new vector with elements and counts\n  std::vector<long> sorted_numbers_with_counts(sorted_number_counts.size(),\n\
    \      sorted_numbers[0]);\n  for (size_t i = 1; i < sorted_number_counts.size();\
    \ i++)\n    sorted_numbers_with_counts[i] = sorted_numbers_with_counts[i - 1]\
    \ + sorted_number_counts[i];\n\n  // Create new vector with sorted and filtered\
    \ numbers\n  std::vector<long> sorted_numbers_with_counts_filtered(sorted_numbers_with_counts.size(),\n\
    \      sorted_numbers_with_counts[0]);\n  for (size_t i = 1; i < sorted_numbers_with_counts.size();\
    \ i++)\n    sorted_numbers_with_counts_filtered[i] = sorted_numbers_with_counts[i\
    \ - 1] + sorted_number_counts_left[i];\n\n  // Create new vector with filtered\
    \ numbers and original counts\n  std::vector<long> numbers_with_counts(sorted_numbers_with_counts.size(),\n\
    \      sorted_numbers_with_counts[0]);\n  for (size_t i = 1; i < sorted_number_counts.size();\
    \ i++)\n    numbers_with_counts[i] = numbers_with_counts[i - 1] + sorted_number_counts_left[i];\n\
    \  return numbers_with_counts;", "    std::vector<long> result(numbers.begin(),\
    \ numbers.end());\n    std::sort(result.begin(), result.end());\n    while (std::next_permutation(result.begin(),\
    \ result.end())) {\n        result.erase(std::remove(result.begin(), result.end(),\
    \ result.begin()[0]), result.end());\n    }\n    return result;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> result(numbers.size());\n    long last\
    \ = numbers[0];\n    for (const auto x : numbers) {\n        if (last != x) {\n\
    \            last += x;\n            result[result.size() - 1] += x;\n       \
    \ }\n    }\n    return result;", "  std::sort(numbers.begin(), numbers.end());\n\
    \  numbers.erase(std::unique(numbers.begin(), numbers.end()), numbers.end());\n\
    \  return numbers;", "    // O(n^2) solution\n    std::vector<long> new_nums;\n\
    \    std::unordered_map<long, std::size_t> seen;\n    for (auto n : numbers) {\n\
    \        if (seen.find(n) == seen.end()) {\n            seen.insert({n, new_nums.size()});\n\
    \            new_nums.push_back(n);\n        }\n    }\n    return new_nums;",
  "    std::vector<long> result;\n    std::sort(numbers.begin(), numbers.end());\n\
    \    for (long i : numbers) {\n        if (result.size() <= i) {\n           \
    \ result.push_back(i);\n        }\n        else {\n            if (result == numbers)\
    \ {\n                break;\n            }\n            std::remove(numbers.begin(),\
    \ numbers.end(), i);\n        }\n    }\n    return result;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n\n  std::vector<long> output;\n  for (std::size_t i = 0; i\
    \ < numbers.size(); i++) {\n    if (i != numbers.begin() && numbers[i] != numbers[i\
    \ - 1]) {\n      output.push_back(numbers[i]);\n    }\n  }\n  return output;",
  "  long long ans = 1;\n  for (long long num : numbers) {\n    if (ans > num) {\n\
    \      ans = num;\n    }\n  }\n  numbers.clear();\n  numbers.push_back(ans);\n\
    \  // Traverse the list once. Keep track of numbers smaller than the current\n\
    \  // one.\n  for (long long i = 1;; i < numbers.size(); i++) {\n    if (numbers[i\
    \ - 1] >= numbers[i]) {\n      long long last = numbers[i - 1];\n      while (numbers[i]\
    \ >= last) {\n        numbers.erase(numbers.begin() + i);\n        i -= 1;\n \
    \     }\n      last = (last + numbers[i]) / 2;\n      numbers[i] = last;\n   \
    \ }\n  }\n  return numbers;", "  std::vector<long> ret;\n  std::set<long> seen;\n\
    \  for (const auto& n: numbers) {\n    if (seen.find(n) == seen.end()) {\n   \
    \   ret.push_back(n);\n      seen.insert(n);\n    }\n  }\n  return ret;", "  \
    \  if (numbers.empty())\n        return {};\n\n    std::vector<long> uniques;\n\
    \    for (long n : numbers)\n        if (std::find(uniques.begin(), uniques.end(),\
    \ n) == uniques.end())\n            uniques.push_back(n);\n\n    return uniques;",
  "    std::vector<long> result;\n    std::set<long> seen;\n    for (long number :\
    \ numbers) {\n        if (seen.find(number) == seen.end())\n            seen.insert(number);\n\
    \        else\n            result.push_back(number);\n    }\n    return result;",
  "    std::vector<long> new_numbers;\n    std::map<long, bool> number_map;\n\n  \
    \  for (long &num : numbers) {\n        if (number_map.find(num) == number_map.end())\
    \ {\n            number_map[num] = true;\n            new_numbers.push_back(num);\n\
    \        } else {\n            number_map[num] = false;\n        }\n    }\n\n\
    \    return new_numbers;", "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long>\
    \ output;\n  long previous = numbers[0];\n  long count = 1;\n  for(auto number\
    \ : numbers) {\n    if(number == previous) {\n      count++;\n    }\n    else\
    \ {\n      output.push_back(previous);\n      previous = number;\n      count\
    \ = 1;\n    }\n  }\n  output.push_back(previous);\n  return output;", "  std::vector<long>\
    \ out;\n  long last_element = 0;\n  long last_number = numbers[0];\n  for (long\
    \ number : numbers) {\n    if (number != last_number) {\n      out.push_back(last_number);\n\
    \      last_number = number;\n    }\n    if (number == last_number) {\n      out.push_back(number);\n\
    \    }\n  }\n  return out;", "    std::vector<long> result;\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::size_t i = 1;\n    for (std::size_t j = 0; j < numbers.size();\
    \ j++) {\n        if (numbers[j] == numbers[i]) {\n            i = (i + 1) % numbers.size();\n\
    \        } else {\n            result.push_back(numbers[j]);\n        }\n    }\n\
    \    return result;", "    // Start with an empty vector\n    std::vector<long>\
    \ output;\n    // For each number in the input vector\n    for (long number :\
    \ numbers) {\n        // If the number has never been encountered\n        //\
    \ add it to the output vector\n        if (output.count(number) == 0)\n      \
    \      output.push_back(number);\n        // If this number has been encountered\
    \ before\n        // remove it from the output vector\n        else\n        \
    \    output.remove(output.begin() + std::find(output.begin(), output.end(), number));\n\
    \    }\n    return output;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> uniques;\n    for (long i : numbers)\n        if (i !=\
    \ numbers[uniques.size()])\n            uniques.push_back(i);\n    return uniques;",
  "  std::vector<long> result;\n  long last_number = numbers[0];\n  for (long number\
    \ : numbers) {\n    if (number != last_number) {\n      result.push_back(number);\n\
    \      last_number = number;\n    }\n  }\n  return result;", "    // Allocate\
    \ space for new vector\n    std::vector<long> new_numbers(numbers.size());\n \
    \   // Initialize new vector with 0s\n    for (size_t i = 0; i < new_numbers.size();\
    \ ++i) new_numbers[i] = 0;\n    // Loop over all elements\n    for (size_t i =\
    \ 0; i < numbers.size(); ++i) {\n        // If element was already used, mark\
    \ it as 0\n        if (numbers[i] != 0) new_numbers[i] = 0;\n        // Else mark\
    \ it as 1\n        else new_numbers[i] = 1;\n    }\n    // Return result\n   \
    \ return new_numbers;", "    std::vector<long> result;\n    std::set<long> already_seen;\n\
    \    for (auto i : numbers) {\n        if (already_seen.find(i) == already_seen.end())\
    \ {\n            already_seen.insert(i);\n            result.push_back(i);\n \
    \       }\n    }\n    return result;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> uniques;\n    for (auto it = numbers.begin(); it != numbers.end();\
    \ ++it) {\n        if (it != numbers.begin() && it != numbers.end() && *it ==\
    \ *it - 1) {\n            numbers.erase(it);\n        } else {\n            uniques.push_back(*it);\n\
    \        }\n    }\n    return uniques;", "  std::vector<long> result;\n  std::unordered_set<long>\
    \ seen;\n  for (long number : numbers) {\n    if (seen.count(number) == 0) {\n\
    \      seen.insert(number);\n      result.push_back(number);\n    }\n  }\n  return\
    \ result;", "\tstd::sort(numbers.begin(), numbers.end()); // O(n log(n))\n\tstd::vector<long>\
    \ result;\n\tlong current = numbers[0];\n\tfor (long num : numbers) {\n\t\tif\
    \ (num != current) {\n\t\t\tresult.push_back(current);\n\t\t\tcurrent = num;\n\
    \t\t}\n\t}\n\tresult.push_back(current);\n\treturn result;", "    std::vector<long>\
    \ output;\n    std::unordered_set<long> seen;\n    // Loop through every element\
    \ of numbers while keeping track of what elements\n    // have already been seen.\n\
    \    for (long i : numbers) {\n        if (seen.count(i) == 0) {\n           \
    \ seen.insert(i);\n            output.push_back(i);\n        }\n    }\n    return\
    \ output;", "    std::vector<long> result(numbers.size());\n    std::size_t n\
    \ = 0;\n    for (long i : numbers)\n        if (++n>1)\n            result[n-1]\
    \ = i;\n    return result;", "  // Create an empty vector.\n  std::vector<long>\
    \ output{};\n  // Loop over all elements in input vector.\n  for (auto i : numbers)\
    \ {\n    // If the element is present in the output vector,\n    // then ignore\
    \ it.\n    if (std::find(output.begin(), output.end(), i) == output.end()) {\n\
    \      // Otherwise, add it to the output vector.\n      output.push_back(i);\n\
    \    }\n  }\n  // Return the output.\n  return output;", "    std::vector<long>\
    \ new_numbers;\n    std::set<long> seen;\n    // Populate the set with numbers\
    \ that haven't been seen yet\n    for (const auto i : numbers) {\n        if (seen.count(i)\
    \ == 0) {\n            seen.insert(i);\n            new_numbers.push_back(i);\n\
    \        }\n    }\n    // Add the remaining numbers to the end of the new list\n\
    \    for (const auto i : numbers) {\n        if (seen.count(i) == 0) {\n     \
    \       new_numbers.push_back(i);\n        }\n    }\n    return new_numbers;",
  "  long long num_duplicates = 0;\n  std::set<long> unique_numbers;\n  for (long\
    \ number : numbers) {\n    unique_numbers.insert(number);\n    num_duplicates\
    \ += unique_numbers.size();\n  }\n  // Copy to output vector.\n  std::vector<long>\
    \ unique_numbers_out(num_duplicates);\n  std::transform(unique_numbers.begin(),\
    \ unique_numbers.end(),\n                 unique_numbers_out.begin(),\n      \
    \           [&unique_numbers](long n) {\n                   return unique_numbers.count(n);\n\
    \                 });\n  return unique_numbers_out;", "  assert(numbers.size()>0);\n\
    \  \n  std::vector<long> new_vec;\n  new_vec.reserve(numbers.size());\n  // Keep\
    \ track of how many times each number occurs\n  std::unordered_map<long, int>\
    \ count_map;\n  for (long i : numbers) {\n    // If it already exists in the map,\
    \ increase the count by one\n    auto it = count_map.find(i);\n    if (it != count_map.end())\n\
    \      count_map[i] += 1;\n    else {\n      // Otherwise, add it and set count\
    \ to 1\n      count_map[i] = 1;\n      new_vec.push_back(i);\n    }\n  }\n  \n\
    \  // Return the new vector\n  return new_vec;", "  std::vector<long> no_duplicates(numbers.size());\n\
    \  for (long i = 0; i < numbers.size(); i++)\n    no_duplicates[i] = no_duplicates[i\
    \ - 1];\n  std::vector<long>::iterator j;\n  for (j = numbers.begin(); j != numbers.end();\
    \ j++) {\n    long count = 0;\n    for (std::size_t k = 0; k < no_duplicates.size();\
    \ k++) {\n      if ((*j) == no_duplicates[k]) {\n        count++;\n        no_duplicates[k]\
    \ = no_duplicates[k + 1];\n      }\n    }\n    if (count > 1)\n      no_duplicates.back()++;\n\
    \  }\n  return no_duplicates;", "  // Initialize result with numbers[0]\n  std::vector<long>\
    \ result(numbers.begin(), numbers.begin() + 1);\n  // Iterate over remaining numbers\
    \ adding 1 to each number that occurs\n  // more than once, leaving no duplicates\n\
    \  for (auto number : numbers) {\n    auto idx = std::find(result.begin(), result.end(),\
    \ number + 1);\n    result.erase(idx);\n  }\n  return result;", "  std::vector<long>\
    \ unique_numbers(numbers.size());\n  std::map<long, bool> number_present;\n\n\
    \  // Populate the map with unique elements.\n  for (long number : numbers)\n\
    \    number_present[number] = true;\n\n  // Repopulate the vector with non-unique\
    \ elements.\n  for (auto it = number_present.begin(); it != number_present.end();)\
    \ {\n    if (it->second) {\n      unique_numbers.push_back(it->first);\n     \
    \ number_present.erase(it++);\n    } else {\n      ++it;\n    }\n  }\n  return\
    \ unique_numbers;", "    std::vector<long> ans;\n    long cur = numbers[0];\n\
    \    for (long val : numbers) {\n        if (val == cur)\n            continue;\n\
    \        ans.push_back(val);\n        cur = val;\n    }\n    return ans;", " \
    \ // Use std::set to avoid a second pass to find duplicates.\n  // Also use std::swap\
    \ to keep order of elements left the same.\n  std::set<long> set;\n  for (auto\
    \ number : numbers) {\n    set.insert(number);\n  }\n  std::vector<long> result;\n\
    \  while (!set.empty()) {\n    result.push_back(set.begin()->first);\n    set.erase(set.begin());\n\
    \  }\n  return result;", "    int i = numbers.size();\n    std::vector<long> new_nums;\n\
    \    while (i) {\n        --i;\n        for (auto it = numbers.begin(); it !=\
    \ numbers.end(); ) {\n            long k = *it;\n            if (k != i) {\n \
    \               it = std::find(it + 1, numbers.end(), k);\n            }\n   \
    \         else {\n                break;\n            }\n        }\n        if\
    \ (it != numbers.end()) {\n            new_nums.push_back(std::move(*it));\n \
    \       }\n    }\n    return new_nums;", "    // O(n), where n = #elements.\n\
    \    // O(n), where n = #elements.\n    // O(n), where n = #elements.\n    //\
    \ O(n), where n = #elements.\n    // O(n), where n = #elements.\n    std::vector<long>\
    \ output;\n    std::unordered_map<long, int> seen;\n    for (long number : numbers)\
    \ {\n        if (seen.count(number) != 0) {\n            continue;\n        }\n\
    \        seen.insert(std::make_pair(number, 1));\n        output.push_back(number);\n\
    \    }\n    return output;", "  std::vector<long> v;\n  // sort numbers in descending\
    \ order\n  std::sort(numbers.begin(), numbers.end(), std::greater<long>());\n\
    \  // find duplicates\n  for (size_t i = 1; i < numbers.size(); i++)\n    if (numbers[i]\
    \ != numbers[i - 1]) {\n      v.push_back(numbers[i]);\n    }\n  // print duplicate\
    \ elements\n  for (auto num : v)\n    std::cout << num << \" \";\n  std::cout\
    \ << std::endl;\n  return v;", "  std::sort(numbers.begin(), numbers.end());\n\
    \  std::vector<long> result;\n  result.push_back(numbers[0]);\n  for (int i =\
    \ 1; i < numbers.size(); ++i) {\n    if (numbers[i] != numbers[i - 1]) {\n   \
    \   result.push_back(numbers[i]);\n    }\n  }\n  return result;", "    std::unordered_map<long,\
    \ long> counts;\n    std::vector<long> ans;\n    for (auto &n : numbers) {\n \
    \       auto it = counts.find(n);\n        if (it == counts.end()) {\n       \
    \     counts.insert(std::make_pair(n, 1));\n            ans.push_back(n);\n  \
    \      }\n        else {\n            counts[n]++;\n        }\n    }\n    return\
    \ ans;", "  std::vector<long> noDuplicates;\n  std::sort(numbers.begin(), numbers.end());\n\
    \  for (int i = 1; i < numbers.size(); i++)\n    if (numbers[i - 1] != numbers[i])\n\
    \      noDuplicates.push_back(numbers[i]);\n  return noDuplicates;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> newNumbers(numbers.begin(), numbers.end());\n\
    \    newNumbers.erase(std::unique(newNumbers.begin(), newNumbers.end()), newNumbers.end());\n\
    \    return newNumbers;", "    std::unordered_set<long> seen;\n    std::vector<long>\
    \ result;\n    for (auto &el: numbers) {\n        if (seen.count(el) == 0) {\n\
    \            seen.insert(el);\n            result.push_back(el);\n        }\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::unordered_set<long>\
    \ seen;\n    for (auto n : numbers) {\n        if (seen.find(n) == seen.end())\n\
    \            seen.insert(n);\n        else\n            result.push_back(n);\n\
    \    }\n    return result;", "  long long n = numbers.front();\n  std::vector<long>\
    \ newNumbers;\n  newNumbers.push_back(n);\n  for (long long i = 1; i < numbers.size();\
    \ ++i) {\n    if (numbers[i] != numbers[i - 1]) {\n      n = numbers[i - 1];\n\
    \      newNumbers.push_back(n);\n    }\n  }\n  return newNumbers;", "    std::vector<long>\
    \ result;\n    long seen = 0;\n    for (long i : numbers) {\n        if (++seen\
    \ == i) {\n            result.push_back(i);\n        }\n    }\n    return result;",
  "  std::vector<long> output;\n  std::sort(numbers.begin(), numbers.end());\n  for\
    \ (long i = numbers.size() - 1; i >= 0; --i) {\n    if (numbers[i] != numbers[i\
    \ - 1]) {\n      output.push_back(numbers[i]);\n      numbers.erase(numbers.begin()\
    \ + i);\n    }\n  }\n  return output;", "    std::vector<long> result;\n    std::unordered_set<long>\
    \ seen;\n    for(auto i : numbers) {\n        if(seen.count(i) > 0) {\n      \
    \      continue;\n        }\n        seen.insert(i);\n        result.push_back(i);\n\
    \    }\n    return result;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> ret;\n    for (long n: numbers) {\n        if (ret.count(n)\
    \ == 0)\n            ret.push_back(n);\n    }\n    return ret;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n\n    std::vector<long> output(numbers.size(), 0);\n\n    for\
    \ (long i : numbers)\n        for (long j : numbers)\n            if (i != j)\n\
    \                if (i % j == 0)\n                    output[j] += i;\n\n    return\
    \ output;", "    std::vector<long> numbers_no_dups;\n    for(auto i : numbers)\
    \ {\n        if (numbers_no_dups.count(i) == 0) numbers_no_dups.push_back(i);\n\
    \    }\n    return numbers_no_dups;", "    // Create set from the input numbers.\n\
    \    std::set<long> set_of_numbers(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ output;\n    // Reverse the order of the set so as to maintain original order\
    \ as in input.\n    std::set<long>::reverse_iterator it = set_of_numbers.rbegin();\n\
    \    // Add elements to the output vector if they don't already exist in output\
    \ vector.\n    // The order of these elements in output vector is same as in input\
    \ vector.\n    while (it != set_of_numbers.rend()) {\n        long element = *it;\n\
    \        if (!set_of_numbers.count(element))\n            output.push_back(element);\n\
    \        ++it;\n    }\n    return output;", "  typedef long long ll;\n  std::vector<long>\
    \ output;\n  for (long long x : numbers) {\n    if (output.size() >= 2) {\n  \
    \    long long y = output.at(output.size() - 1);\n      if (x == y) {\n      \
    \  output.pop_back();\n      } else if (x < y) {\n        output.push_back(x);\n\
    \      } else {\n        output.push_back(y);\n      }\n    } else {\n      output.push_back(x);\n\
    \    }\n  }\n  return output;", "  std::sort(numbers.begin(), numbers.end());\n\
    \  numbers.erase(std::unique(numbers.begin(), numbers.end()), numbers.end());\n\
    \  return numbers;", "    std::vector<long> temp;\n    for(auto it = numbers.begin();\
    \ it != numbers.end(); ++it)\n    {\n        auto findIt = std::find(temp.begin(),\
    \ temp.end(), *it);\n        if(findIt != temp.end())\n        {\n           \
    \ temp.erase(findIt);\n        }\n        else\n        {\n            temp.push_back(*it);\n\
    \        }\n    }\n    return temp;", "    // Use set to store unique elements.\n\
    \    std::vector<long> numbers_set(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ numbers_set_copy;\n    numbers_set_copy.assign(numbers_set.begin(), numbers_set.end());\n\
    \    std::vector<long> numbers_set_copy(numbers_set_copy.begin(), numbers_set_copy.end());\n\
    \    // Use set copy to remove duplicates\n    // For each unique element, check\
    \ if it is in the input set\n    // If so, remove it from input set. Else, add\
    \ it to the output set.\n    std::vector<long> result;\n    for (long num : numbers_set_copy)\
    \ {\n        if (numbers.find(num) != numbers.end()) {\n            numbers.erase(numbers.find(num));\n\
    \        }\n        else {\n            numbers.push_back(num);\n        }\n \
    \   }\n    return result;", "    std::vector<long> result;\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    result.push_back(numbers[0]);\n    for (long i = 1; i <\
    \ numbers.size(); i++) {\n        if (numbers[i] != numbers[i - 1]) {\n      \
    \      result.push_back(numbers[i]);\n        }\n    }\n    return result;", " \
    \   std::sort(numbers.begin(), numbers.end());\n    numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n    return numbers;", "    std::vector<long>\
    \ new_numbers;\n    std::vector<bool> seen(numbers.size(), false);\n    // loop\
    \ through elements and if seen flag set\n    // add it to new_numbers vector\n\
    \    for(long i = 0; i < numbers.size(); i++) {\n        if(seen[i]) {\n     \
    \       new_numbers.push_back(numbers[i]);\n        } else {\n            seen[i]\
    \ = true;\n        }\n    }\n    return new_numbers;", "    // Create a vector\
    \ of the distinct values.\n    // This will be sorted.\n    std::vector<long>\
    \ distinct_values;\n    long count = 0;\n    for (auto x : numbers)\n        if\
    \ (x != count)\n            distinct_values.push_back(x);\n        else\n    \
    \        count += 1;\n    // Remove duplicates from the sorted list.\n    // First\
    \ sort by value from smallest to largest.\n    std::sort(distinct_values.begin(),\
    \ distinct_values.end());\n    distinct_values.erase(\n        std::unique(distinct_values.begin(),\
    \ distinct_values.end()), distinct_values.end());\n    // Then sort the vector\
    \ by value.\n    std::sort(distinct_values.begin(), distinct_values.end());\n\
    \    return distinct_values;", "  assert(numbers.size() > 0);\n  std::vector<long>\
    \ res;\n  long prev = numbers[0];\n  res.push_back(prev);\n  for (size_t i = 1;\
    \ i < numbers.size(); i++) {\n    if (numbers[i] == prev)\n      continue;\n \
    \   res.push_back(numbers[i]);\n    prev = numbers[i];\n  }\n  return res;", " \
    \ assert(numbers.size() > 0);\n  std::vector<long> v;\n  for (auto i : numbers)\n\
    \    if (std::find(v.begin(), v.end(), i) == v.end())\n      v.push_back(i);\n\
    \  return v;", "    // Create output container\n    std::vector<long> output(numbers.size());\n\
    \    // Use set to hold input elements\n    std::set<long> numbers_set;\n    //\
    \ Iterate over all the elements in the input container\n    // and store them\
    \ in a set (we will remove them from the set)\n    // and store them into the\
    \ output container.\n    for(const auto& num : numbers)\n        numbers_set.insert(num);\n\
    \    // Iterate over the set and copy the elements to the output container\n \
    \   for(const auto& num : numbers_set)\n        output[numbers_set.find(num)]\
    \ = num;\n    // Return the output container.\n    return output;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> result;\n  for (long i : numbers) {\n \
    \   if (result.size() >= 2 && result[0] == i) {\n      result[1] = i;\n    } else\
    \ {\n      result.push_back(i);\n    }\n  }\n  return result;", "    std::vector<long>\
    \ result;\n    std::unordered_set<long> seen;\n\n    for (long number : numbers)\
    \ {\n        if (seen.find(number) == seen.end()) {\n            seen.insert(number);\n\
    \            result.push_back(number);\n        }\n    }\n    return result;",
  "    std::vector<long> ret;\n    std::sort(numbers.begin(), numbers.end());\n  \
    \  long prev = numbers[0];\n    for (const auto& ele : numbers) {\n        if\
    \ (ele == prev) {\n            continue;\n        }\n        ret.push_back(ele);\n\
    \        prev = ele;\n    }\n    return ret;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    numbers.erase(std::unique(numbers.begin(), numbers.end()),\
    \ numbers.end());\n    return numbers;", "  std::vector<long> new_numbers;\n \
    \ bool is_first_num = true;\n  for (long i = 0; i < numbers.size(); ++i) {\n \
    \   if (numbers[i] != numbers[i - 1]) {\n      if (!is_first_num) {\n        new_numbers.push_back(numbers[i\
    \ - 1]);\n      }\n      is_first_num = false;\n    }\n  }\n  return new_numbers;",
  "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> ans;\n  \
    \  long first = numbers[0];\n    long last = numbers.size() - 1;\n    int i =\
    \ 0;\n    while (i < numbers.size()) {\n        if (numbers[i] != numbers[i +\
    \ 1]) {\n            if (numbers[i] > first) {\n                ans.push_back(first);\n\
    \                first = numbers[i];\n            } else if (numbers[i] < last)\
    \ {\n                ans.push_back(last);\n                last = numbers[i];\n\
    \            }\n        }\n        ++i;\n    }\n    return ans;", "  assert(numbers.size()\
    \ > 0);\n  std::vector<long> uniqueNumbers(numbers.size());\n  std::unordered_set<long>\
    \ seen;\n  for (auto const &num : numbers) {\n    if (seen.find(num) == seen.end())\
    \ {\n      seen.insert(num);\n      uniqueNumbers.push_back(num);\n    }\n  }\n\
    \  return uniqueNumbers;", "    std::vector<long> output;\n    output.reserve(numbers.size());\n\
    \    std::sort(numbers.begin(), numbers.end());\n\n    long last_number = numbers[0];\n\
    \    long count = 0;\n    for (int i = 1; i < numbers.size(); ++i) {\n       \
    \ if (numbers[i] == last_number) {\n            count++;\n        } else {\n \
    \           count = 1;\n            last_number = numbers[i];\n        }\n   \
    \     if (count > 1) {\n            output.push_back(last_number);\n         \
    \   count = 1;\n        }\n    }\n\n    return output;", "    std::vector<long>\
    \ output;\n    std::map<long, int> count_map;\n    for (long number: numbers)\
    \ {\n        count_map[number]++;\n    }\n    for (auto number_counts: count_map)\
    \ {\n        if (number_counts.second > 1) {\n            output.push_back(number_counts.first);\n\
    \        }\n    }\n    return output;", "  std::vector<long> output;\n  output.reserve(numbers.size());\n\
    \  for (auto &elem : numbers) {\n    if (output.size() <= 0 || elem != output[output.size()-1])\
    \ {\n      output.push_back(elem);\n    }\n  }\n  return output;", "  std::vector<long>\
    \ result;\n  std::set<long> seen;\n  for (auto i : numbers) {\n    if (!seen.count(i))\n\
    \      result.push_back(i);\n    seen.insert(i);\n  }\n  return result;", "  //\
    \ Create a map to hold the elements that appear more than once\n  // Key is integer,\
    \ value is how many times\n  std::unordered_map<long, long> double_counted;\n\
    \  // Now loop and keep track of elements that appear more than once\n  for (auto\
    \ it = numbers.begin(); it != numbers.end(); it++) {\n    long num = *it;\n  \
    \  // If not yet seen, add that number to the map\n    if (double_counted.count(num)\
    \ == 0) {\n      double_counted[num] = 1;\n      // If seen before, increment\
    \ the counter\n    } else {\n      double_counted[num]++;\n    }\n  }\n  // Now\
    \ loop again and copy out just the values whose counter == 1\n  numbers.clear();\n\
    \  numbers.reserve(double_counted.size());\n  for (auto it = double_counted.begin();\
    \ it != double_counted.end(); it++) {\n    if (it->second == 1) {\n      numbers.push_back(it->first);\n\
    \    }\n  }\n  return numbers;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> ret;\n    std::unordered_map<long, bool> seen;\n    for\
    \ (size_t i = 0; i < numbers.size(); ++i) {\n        if (seen.find(numbers[i])\
    \ == seen.end()) {\n            ret.push_back(numbers[i]);\n            seen[numbers[i]]\
    \ = true;\n        }\n    }\n    return ret;", "    std::vector<long> output;\n\
    \    std::unordered_map<long, int> seen;\n    for (long num : numbers) {\n   \
    \     if (seen.find(num) == seen.end()) {\n            seen.insert({num, 1});\n\
    \            output.push_back(num);\n        }\n    }\n    return output;", " \
    \ std::vector<long> result;\n  \n  // loop through the vector\n  for (int i =\
    \ 0; i < numbers.size(); i++) {\n    // if it is not yet contained, add it to\
    \ result.\n    if (result.find(numbers[i]) == result.end()) {\n      result.push_back(numbers[i]);\n\
    \    } else {\n      // if it already contained, remove it from result\n     \
    \ std::vector<long>::iterator it = std::find(result.begin(), result.end(), numbers[i]);\n\
    \      result.erase(it);\n    }\n  }\n  return result;", "  std::vector<long>\
    \ ans;\n  std::unordered_map<long, int> counts;\n  for (auto n : numbers) {\n\
    \    auto it=counts.find(n);\n    if (it != counts.end())\n      ans.push_back(n);\n\
    \    else\n      ans.push_back(n+1);\n    counts[n]++;\n  }\n  return ans;", " \
    \ std::vector<long> new_numbers;\n  long previous_number = numbers.front();\n\
    \  for (long number : numbers) {\n    if (number == previous_number) {\n     \
    \ continue;\n    }\n    new_numbers.push_back(number);\n    previous_number =\
    \ number;\n  }\n  return new_numbers;", "    int n = numbers.size();\n    // Remove\
    \ duplicates until only 1 element left\n    while (n > 1) {\n        // Sort the\
    \ list\n        std::sort(numbers.begin(), numbers.end());\n        // Remove\
    \ duplicates\n        numbers.erase(std::unique(numbers.begin(), numbers.end()),\
    \ numbers.end());\n        // Decrement n\n        --n;\n    }\n    return numbers;",
  "    std::vector<long> output;\n    long count = 0;\n    for (long num : numbers)\
    \ {\n        if (count < num) {\n            count = num;\n            output.clear();\n\
    \        }\n        output.push_back(num);\n    }\n    return output;", "    //\
    \ Step 1: Make a temporary array to hold all our values\n    std::vector<long>\
    \ temporary(numbers.begin(), numbers.end());\n\n    // Step 2: Sort them and get\
    \ rid of duplicates\n    std::sort(temporary.begin(), temporary.end());\n    temporary.erase(std::unique(temporary.begin(),\
    \ temporary.end()) - temporary.begin(), temporary.end());\n\n    // Step 3: Return\
    \ the remaining values\n    return temporary;", "    // Make an empty vector the\
    \ same size as the input.\n    std::vector<long> result;\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Push duplicates to the end of the vector.\n    for (auto\
    \ it = numbers.begin(); it != numbers.end(); ++it) {\n        if (it != numbers.begin())\n\
    \            result.push_back(*it);\n        if (it != numbers.end() && it ==\
    \ numbers.begin())\n            result.push_back(*it);\n    }\n    return result;",
  "  std::unordered_set<long> seen;\n  numbers.reserve(numbers.size());\n  long value;\n\
    \  for (size_t i = 0; i < numbers.size(); ++i) {\n    if (seen.find(numbers[i])\
    \ == seen.end()) {\n      seen.insert(numbers[i]);\n      numbers.push_back(value);\n\
    \    }\n  }\n  numbers.erase(numbers.end() - 1);\n  return numbers;", "  // Create\
    \ an empty vector to hold the unique elements.\n  std::vector<long> u;\n\n  //\
    \ Loop over all elements in the input vector.\n  for (const auto& i : numbers)\
    \ {\n    // If this element has been seen before, ignore it.\n    if (std::find(u.begin(),\
    \ u.end(), i) == u.end()) {\n      // Otherwise, add this element to the unique\
    \ element vector.\n      u.push_back(i);\n    }\n  }\n\n  // Return the unique\
    \ elements vector sorted by their original order.\n  return std::sort(u.begin(),\
    \ u.end());", "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long>\
    \ result;\n  long current = numbers[0];\n  long count = numbers.size();\n  for\
    \ (long i = 1; i < count; i++) {\n    if (numbers[i] == current) {\n      continue;\n\
    \    }\n    result.push_back(current);\n    current = numbers[i];\n  }\n  result.push_back(current);\n\
    \  return result;", "  std::vector<long> unique_numbers(numbers.size());\n  for\
    \ (long number: numbers) {\n    if (unique_numbers.count(number) == 0) {\n   \
    \   unique_numbers.insert(number);\n    }\n  }\n  return unique_numbers;", " \
    \   std::vector<long> output;\n    for(long i : numbers)\n    {\n        long\
    \ count = std::count(numbers.begin(), numbers.end(), i);\n        if (count >\
    \ 1)\n        {\n            output.push_back(i);\n            numbers.erase(std::remove(numbers.begin(),\
    \ numbers.end(), i), numbers.end());\n        }\n    }\n    return output;", " \
    \   if (numbers.empty()) return {};\n    std::unordered_set<long> seen;\n    std::vector<long>\
    \ unique_numbers;\n    unique_numbers.reserve(numbers.size());\n    // We need\
    \ to use reverse iterators to iterate through the input in order\n    // to avoid\
    \ invalidating the iterator after it is incremented.\n    for (std::reverse_iterator<std::vector<long>::const_iterator>\
    \ it =\n             numbers.rbegin(); it != numbers.rend(); ++it) {\n       \
    \ if (seen.find(*it) != seen.end()) {\n            numbers.erase(std::remove(numbers.begin(),\
    \ numbers.end(), *it),\n                          numbers.end());\n        } else\
    \ {\n            seen.insert(*it);\n            unique_numbers.push_back(*it);\n\
    \        }\n    }\n    return unique_numbers;", "    // Return value\n    std::vector<long>\
    \ uniques;\n    // Store numbers in an unordered_set\n    std::unordered_set<long>\
    \ seen;\n    // Store numbers in an unordered_set and remove duplicates\n    for\
    \ (auto i : numbers) {\n        // Only add element if it has not been seen before\n\
    \        if (seen.find(i) == seen.end()) {\n            seen.insert(i);\n    \
    \        uniques.push_back(i);\n        }\n    }\n    return uniques;", "  std::vector<long>\
    \ result;\n  std::sort(numbers.begin(), numbers.end());\n  std::set<long> seen;\n\
    \  for (int i = 0; i < numbers.size(); ++i) {\n    if (seen.find(numbers[i]) !=\
    \ seen.end()) {\n      continue;\n    }\n    seen.insert(numbers[i]);\n    result.push_back(numbers[i]);\n\
    \  }\n  return result;", "    // Sort the input array in descending order\n  \
    \  std::sort(numbers.begin(), numbers.end(), std::greater<long>());\n    // Use\
    \ a map to store the numbers as they are encountered\n    std::vector<long> result(numbers.begin(),\
    \ numbers.end());\n    std::map<long, long> seen;\n\n    // For all remaining\
    \ elements, mark them seen\n    for (long elem : numbers) {\n        if (seen.find(elem)\
    \ == seen.end()) {\n            seen[elem] = elem;\n            result.push_back(elem);\n\
    \        }\n    }\n\n    return result;", "  std::vector<long> result;\n  long\
    \ long seen = 0;\n  for (const auto& n : numbers) {\n    if (seen == 0) {\n  \
    \    seen = n;\n      result.push_back(n);\n    } else {\n      if (n == seen)\
    \ {\n        seen++;\n      } else {\n        result.push_back(seen);\n      \
    \  seen = n;\n      }\n    }\n  }\n  if (seen > 0) {\n    result.push_back(seen);\n\
    \  }\n  return result;", "  std::vector<long> ans;\n  // First step: find duplicates\
    \ and put them into ans.\n  for (long i : numbers) {\n    if (std::find(ans.begin(),\
    \ ans.end(), i) == ans.end()) {\n      ans.push_back(i);\n    }\n  }\n  // Second\
    \ step: remove duplicates and return the result.\n  std::sort(ans.begin(), ans.end());\n\
    \  for (long i : ans) {\n    while (!numbers.empty() && numbers.back() == i) {\n\
    \      numbers.pop_back();\n    }\n  }\n  return ans;", "  long result = 0;\n\
    \  \n  // Create a std::set for O(1) time complexity of lookup.\n  std::set<long>\
    \ numbers_set;\n  \n  // Loop over every element in the input vector\n  for (int\
    \ i = 0; i < numbers.size(); i++) {\n    // If the element already exists in the\
    \ set, replace it with the current element.\n    if (numbers_set.find(numbers[i])\
    \ == numbers_set.end()) {\n      numbers_set.insert(numbers[i]);\n    } else {\n\
    \      result = numbers[i];\n    }\n  }\n  \n  // Return the resulting set.\n\
    \  return {result};", "    std::vector<long> temp(numbers.begin(), numbers.end());\n\
    \    std::sort(temp.begin(), temp.end());\n    int n = temp.size(); // size of\
    \ list\n    for (int i = 0; i < n - 1; ++i) {\n        if (temp[i] == temp[i +\
    \ 1]) {\n            temp[++i] = temp[i + 1];\n            ++i;\n        }\n \
    \   }\n    temp.resize(i); // remove duplicates\n    return temp;", "    // sort\
    \ numbers in ascending order\n    numbers.sort();\n    // create a vector to hold\
    \ the unique numbers and a vector to hold the number of times a number occurs\n\
    \    std::vector<long> unique_numbers(numbers.size());\n    std::vector<long>\
    \ frequency(numbers.size(), 0);\n    // loop through numbers\n    for (int i =\
    \ 0; i < numbers.size(); i++) {\n        // add numbers to unique_numbers vector\
    \ and increment its frequency\n        unique_numbers[i] = numbers[i];\n     \
    \   frequency[i]++;\n    }\n    // loop through unique_numbers and decrease frequency\
    \ of a number by 1\n    for (int i = 0; i < unique_numbers.size(); i++) {\n  \
    \      frequency[i]--;\n        // if frequency of a number is 0, remove this\
    \ number from unique_numbers vector\n        if (frequency[i] == 0) {\n      \
    \      unique_numbers.erase(unique_numbers.begin() + i);\n        }\n    }\n \
    \   return unique_numbers;", "    std::vector<long> output(numbers.size(), 0);\n\
    \    // Loop through the given input array, and keep track of the indices of\n\
    \    // the values that have been encountered so far. If the value occurs\n  \
    \  // again, skip it.\n    for (size_t i = 0; i < numbers.size(); ++i) {\n   \
    \     long count = output[i];\n        output[i] = std::count(numbers.begin()\
    \ + i, numbers.end(), numbers[i]);\n        if (output[i] > 1) {\n           \
    \ numbers.erase(std::remove_if(numbers.begin() + i, numbers.end(),\n         \
    \                                [count](int n) {\n                          \
    \                   return count == std::count(numbers.begin() + i,\n        \
    \                                                                numbers.end(),\
    \ n);\n                                         }),\n                        \
    \   numbers.end());\n        }\n    }\n    return output;", "  std::vector<long>\
    \ distinct_elements(numbers.size());\n  for (std::size_t i = 0; i < numbers.size();\
    \ ++i) {\n    bool found = false;\n    for (std::size_t j = i; j < distinct_elements.size();\
    \ ++j) {\n      if (numbers[i] == distinct_elements[j]) {\n        found = true;\n\
    \        break;\n      }\n    }\n    if (!found) {\n      distinct_elements.push_back(numbers[i]);\n\
    \    }\n  }\n  return distinct_elements;", "  std::sort(numbers.begin(), numbers.end());\n\
    \  std::map<long, int> count;\n  for (std::size_t i = 0; i < numbers.size(); ++i)\
    \ {\n    long current = numbers[i];\n    if (count.find(current) == count.end())\
    \ {\n      count[current] = 1;\n    } else {\n      count[current]++;\n    }\n\
    \  }\n  std::vector<long> output;\n  for (std::map<long, int>::iterator it = count.begin();\n\
    \       it != count.end(); ++it) {\n    if (it->second == 1) {\n      output.push_back(it->first);\n\
    \    }\n  }\n  return output;", "  std::vector<long> result;\n  std::set<long>\
    \ seen_numbers;\n\n  for (long number : numbers) {\n    if (seen_numbers.count(number)\
    \ == 0) {\n      seen_numbers.insert(number);\n      result.push_back(number);\n\
    \    }\n  }\n  return result;", "    std::vector<long> duplicates(numbers.size(),\
    \ 0);\n    for(size_t i = 0; i < numbers.size(); ++i) {\n        for(size_t j\
    \ = i; j < numbers.size(); ++j) {\n            if((numbers[j] == numbers[i]) ||\
    \ !(numbers[j] == numbers[i])) break;\n            duplicates[j] += 1;\n     \
    \   }\n    }\n    std::vector<long> result;\n    for(size_t i = 0; i < duplicates.size();\
    \ ++i) if(duplicates[i] > 1) result.push_back(i);\n    return result;", "  long\
    \ result = 0;\n  for (int i = 0; i < numbers.size(); ++i) {\n    for (int j =\
    \ i + 1; j < numbers.size(); ++j) {\n      if (numbers[i] == numbers[j]) {\n \
    \       numbers.erase(numbers.begin() + j);\n      }\n    }\n  }\n  return numbers;",
  "    // sort ascending first\n    std::sort(numbers.begin(), numbers.end());\n\n\
    \    std::vector<long> new_numbers;\n\n    // Loop through numbers and keep track\
    \ of whether we have seen this number before\n    bool seen[numbers.size()];\n\
    \    for (long i = 0; i < numbers.size(); ++i) {\n        seen[i] = false;\n \
    \   }\n\n    // Loop through numbers again and skip numbers that occur more than\
    \ once\n    for (long i = 0; i < numbers.size(); ++i) {\n        if (!seen[i])\
    \ {\n            new_numbers.push_back(numbers[i]);\n            seen[i] = true;\n\
    \        }\n    }\n\n    return new_numbers;", "  long hash[numbers.size()];\n\
    \  for (long i = 0; i < numbers.size(); i++) {\n    hash[numbers[i]] = i;\n  }\n\
    \  std::vector<long> ans;\n  while (numbers.size() > 0) {\n    long curr = numbers[0];\n\
    \    ans.push_back(curr);\n    numbers.erase(numbers.begin() + std::remove(numbers.begin(),\
    \ numbers.end(), curr));\n    for (long i = 0; i < numbers.size(); i++) {\n  \
    \    if (numbers[i] == curr) {\n        numbers.erase(numbers.begin() + i);\n\
    \        break;\n      }\n    }\n  }\n  return ans;"]
stop_tokens:
- "\n}"
