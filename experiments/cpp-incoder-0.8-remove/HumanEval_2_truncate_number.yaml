name: HumanEval_2_truncate_number
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating\
  \ point number, it can be decomposed into\n// and integer part (largest integer\
  \ smaller than given number) and decimals\n// (leftover part always smaller than\
  \ 1).\n// Return the decimal part of the number.\nfloat truncate_number(float number)\
  \ {\n"
tests: "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5))\
  \ == (0.5));\n    assert(candidate((1.25)) == (0.25));\n    assert(candidate((123.0))\
  \ == (0.0));\n}\n"
completions: ["    assert(number >= 0);\n    // get number of digits before decimal\
    \ point\n    int num_digits = 0;\n    while(number >= 1) {\n        ++num_digits;\n\
    \        number /= 10.0;\n    }\n    // get number of digits after decimal point\n\
    \    int num_decimals = 0;\n    while (number > 1) {\n        ++num_decimals;\n\
    \        number *= 0.1;\n    }\n    // return number with decimal part cut off\n\
    \    return number / (float)pow(10.0, num_decimals);", "    float result = 0;\n\
    \    int pow = 0;\n    while (number > 0)\n    {\n        // integer part is what\
    \ we have now\n        int i = number / 10;\n        // decimal part is what remains\
    \ after integer division\n        number -= 10 * i;\n        // if we have more\
    \ than one decimal digit, multiply it by 10\n        if (pow + 1 < pow)\n    \
    \        result *= 10;\n        // multiply by 10 to the power of number of decimal\
    \ digits\n        result *= 10 * pow;\n        // add integer part to the result\n\
    \        result += i;\n        pow++;\n    }\n    // divide by 10 by subtracting\
    \ decimal part\n    if (pow > 0)\n        result /= 10 / pow;\n    return result;",
  "    assert(number>=0);\n    int decimal_part = number%1;\n    number = number/1;\n\
    \    return number*100 + decimal_part;", "  assert(number > 0);\n  float trunc_number\
    \ = number;\n  int decimal_part = 0;\n  if (trunc_number > 0) {\n    do\n    \
    \  decimal_part++;\n    while (trunc_number >= 1);\n  }\n  return trunc_number\
    \ - decimal_part;", "    int integer_part = 0;\n    float decimal_part = 0.f;\n\
    \    while (number != 0.0f && integer_part < FLT_MANT_DIG) {\n        decimal_part\
    \ += number * FLT_RADIX;\n        number /= FLT_RADIX;\n        integer_part++;\n\
    \    }\n    if (number > 0.0f) {\n        decimal_part += number * FLT_RADIX;\n\
    \        integer_part++;\n    }\n    return decimal_part / FLT_RADIX;", "\tassert(number\
    \ > 0);\n\tif (number >= (1 << 24)) {\n\t\tunsigned long long int high = 0;\n\t\
    \tunsigned long long int low = 0;\n\t\tmemcpy(&high, &number, 8);\n\t\tmemcpy(&low,\
    \ &number, 8);\n\t\thigh >>= 8;\n\t\tlow >>= 8;\n\t\tassert(high + low < 0xFFFFFFFF);\n\
    \t\tfloat truncate_number = (float(high) << 32) + float(low);\n\t\tassert(truncate_number\
    \ <= (1 << 24));\n\t\tassert(truncate_number >= 0);\n\t\treturn truncate_number;\n\
    \t} else {\n\t\tassert(number >= 0);\n\t\treturn number;\n\t}", "    long int_part\
    \ = 0;\n    long decimal_part = 0;\n    int decimal_count = 0;\n    // Loop through\
    \ all the digits of decimal part of the number.\n    while ((number % 10) > 0)\
    \ {\n        // Keep track of number of digits we still need to round.\n     \
    \   decimal_count += 1;\n        // Calculate the integer part of the number by\
    \ subtracting the decimal part from the number itself.\n        int_part = int_part\
    \ + number % 10;\n        // Reset the decimal part and number to the number of\
    \ digits we still need to round.\n        number = number / 10;\n        decimal_part\
    \ = decimal_part + 1;\n    }\n    // Return the decimal part after the decimal\
    \ point.\n    return number == 0 ? 0 : decimal_part * 10 / decimal_count;", " \
    \   int decimals{};\n    memcpy(&decimals, &number, sizeof(float));\n    float\
    \ truncated{};\n    if (std::fmod(number, 1.f) > 0) {\n        truncated += number;\n\
    \    }\n    while ((std::fmod(truncated, 1.f) > 0) && decimals--) truncated *=\
    \ 10;\n    return truncated;", "    int int_part = (int) (number);\n    int decimal_part\
    \ = fmodf(number, 1.0f);\n    return decimal_part * 1.0;", "    float integerPart\
    \ = 0;\n    float decimalPart = 0;\n    int exponent = 0;\n    float fraction\
    \ = number;\n\n    while (fraction > 0) {\n        int idigit = 0;\n        fraction\
    \ *= 10;\n        while ((fraction > 0) && ((fraction % 10) == 0)) {\n       \
    \     fraction = fraction / 10;\n            idigit++;\n        }\n        if\
    \ (exponent >= idigit) {\n            integerPart = integerPart * 10 + idigit\
    \ - exponent;\n            decimalPart = fraction;\n        }\n        exponent\
    \ = idigit;\n    }\n    if (exponent > 0) {\n        integerPart *= 10 + exponent;\n\
    \    }\n\n    return integerPart;", "  assert(number > 0);\n\n  int int_part_length\
    \ = static_cast<int>(number);\n  // If the number is too large (more than 15 digits),\n\
    \  // we return 0 for the decimal part.\n  if (int_part_length > 15) {\n    return\
    \ 0.f;\n  }\n  float int_part = number - static_cast<float>(int_part_length);\n\
    \  float decimal_part = number - int_part;\n  if (decimal_part > std::numeric_limits<float>::epsilon())\
    \ {\n    return std::numeric_limits<float>::infinity();\n  }\n  return int_part;",
  "    int decimal_places = 1;\n    float integer_part = number;\n    float decimal_part\
    \ = number - integer_part;\n    while (decimal_part >= 1.0) {\n        decimal_part\
    \ -= 1.0;\n        ++decimal_places;\n    }\n    return (integer_part + decimal_part)\
    \ / decimal_places;", "    assert(number > 0);\n    int decimal_part = round(number\
    \ * 1000);\n    float truncated = number / 1000 * 1000.0;\n    if (decimal_part\
    \ == 0) {\n        return truncated;\n    }\n    if (truncated > truncated) {\n\
    \        truncated -= 1;\n    }\n    return truncated;", "    int i = (int)number;\n\
    \    float dec = number - i;\n    return dec < 0.5 ? i + 1 : i;", "    long decimal_places\
    \ = 1;\n    double double_value = number;\n    int i = 0;\n    // Find how many\
    \ digits there are in the floating point number.\n    // Example: 2.345 has 3\
    \ decimal places.\n    while ((double_value *= 10) > 0) {\n        double_value\
    \ /= 10;\n        ++i;\n    }\n    // Truncate decimal places.\n    if (i > decimal_places)\
    \ {\n        double_value = round(double_value);\n        ++decimal_places;\n\
    \        --i;\n    }\n    // Round the value so that decimals become integers.\n\
    \    double_value = round(double_value * pow(10, decimal_places)) / pow(10, decimal_places);\n\
    \    return static_cast<float>(double_value);", "    int decimals = 1;\n    while\
    \ (number % 1 == 0) {\n        number = number / 1;\n        decimals++;\n   \
    \ }\n\n    // If the decimal part is larger than 2, subtract 1.\n    if (decimals\
    \ > 2) {\n        decimals = decimals - 1;\n    }\n\n    return number % 1;",
  "    long long int integer_part;\n    long long int decimal_part;\n    // Use long\
    \ long int to ensure the number stays reasonable\n    long long int temp = (long\
    \ long int)(number);\n    // integer part of the number\n    integer_part = temp\
    \ - (long long int)(temp % 1);\n    // fractional part of the number\n    decimal_part\
    \ = temp % (long long int) 1;\n    // Check whether fractional part is greater\
    \ than 0.5\n    if (decimal_part >= 0.5) {\n        // If so, round down\n   \
    \     return static_cast<float>(integer_part);\n    } else {\n        // If not,\
    \ round up\n        return static_cast<float>(integer_part + 1);\n    }", "  \
    \  long decimal_part = modf(number, nullptr);\n    if (decimal_part < 0) {\n \
    \       return number - pow(10, -decimal_part);\n    } else {\n        return\
    \ number;\n    }", "    // If number is smaller than 10, just return number\n\
    \    // since truncating 10 to any digit is same as rounding down\n    if (number\
    \ < 10.0f) return number;\n    // Find the decimal part of number and truncate\
    \ it\n    float decimal_part = number % 1.0f;\n    // Add decimal part to an integer\n\
    \    number = number / 1.0f;\n    // Return the rounded number\n    return number\
    \ + decimal_part;", "    int decimals = 1;\n    while (number % 1 > 0) {\n   \
    \     number /= 10;\n        decimals++;\n    }\n    return number % 1;", "  \
    \  int integer_part = 0;\n    float decimal_part = 0.0;\n    int decimal_part_length\
    \ = sizeof(float) * 8;\n    while (decimal_part >= 1.0) {\n        decimal_part_length--;\n\
    \        integer_part += 1;\n        decimal_part = float(decimal_part);\n   \
    \ }\n\n    if (number >= 0.0) {\n        integer_part += 1;\n        decimal_part_length\
    \ -= 1;\n    }\n    float truncate_part = float(integer_part);\n\n    // Convert\
    \ the decimal part back to original type.\n    float result = truncate_part *\
    \ pow(10.0, decimal_part_length);\n\n    return result;", "    int integer_part\
    \ = (int)(number);\n    float fractional_part = number-integer_part;\n    return\
    \ fractional_part;", "  int int_part = 0;\n  float decimal_part = 0.0;\n  if (number\
    \ >= 0) {\n    int_part = floor(number);\n    if (number - int_part > 0.5) {\n\
    \      decimal_part = number - int_part;\n    } else {\n      decimal_part = floor(number\
    \ - int_part + 0.5);\n    }\n  } else {\n    int_part = floor(number * -1);\n\
    \    decimal_part = floor(number * -1);\n  }\n  return decimal_part;", "    float\
    \ f = ceil(number);\n    float p = f - ceil(number);\n    if (p == 0.0f) {\n \
    \       p = 0.001;\n    }\n    return f;", "    float decimal = 0;\n    int integer\
    \ = trunc(number);\n    while (integer - trunc(number) > 0.5) {\n        decimal++;\n\
    \        integer = trunc(number);\n    }\n    return number;", "    assert(number\
    \ >= 0);\n    int integer_part = floor(number);\n    float remainder = number\
    \ - integer_part;\n    return remainder;", "    float decimal_part = floorf(number);\n\
    \    int int_part_of_number = number - decimal_part;\n    if (int_part_of_number\
    \ > FLT_EPSILON) {\n        int_part_of_number -= 1;\n    }\n    return decimal_part\
    \ + int_part_of_number;", "    int decimal_part = floor(log10f(number));\n   \
    \ float decimal_part_scaled = number/(10*pow(10, decimal_part));\n    float decimal_part_truncated\
    \ = floor(decimal_part_scaled);\n    return decimal_part_truncated;", "    double\
    \ dnumber;\n    double dnumber1;\n    double dnumber2;\n    double dnumber3;\n\
    \    dnumber1 = fabs(number);\n    dnumber2 = dnumber1 / 1e9;\n    dnumber3 =\
    \ dnumber2 / 1e6;\n    dnumber = dnumber3 * 1e3;\n    cout << dnumber << endl;\n\
    \    return number;", "  int int_part = fmodf(number, 1);\n  float decimal_part\
    \ = number - int_part;\n  return decimal_part;", "    int int_part = (int) number;\n\
    \    float decimal_part = number - int_part;\n    return decimal_part;", "   \
    \ long decimal_part = floor(number);\n    float whole_part = number - decimal_part;\n\
    \    return decimal_part;", "    assert(number >= 0);\n    int int_part = (int)\
    \ number;\n    float fractional_part = number - int_part;\n    return (fractional_part\
    \ > 0.5f) ? fractional_part - 0.5f : fractional_part;", "    long decimal_places\
    \ = int(log10(abs(number))) + 1;\n    if (number > 0) decimal_places = -decimal_places;\n\
    \    // Decompose to integer part and decimal part.\n    long int_part = floor(number\
    \ * pow(10.0, decimal_places));\n    float decimal_part = number - int_part *\
    \ pow(10.0, decimal_places);\n\n    // Truncate the decimal part.\n    if (abs(decimal_part)\
    \ < pow(10.0, decimal_places)) decimal_part = 0.0;\n\n    return number_type(int_part\
    \ + 0.5, decimal_part);", "  int integer_part = floorf(number);\n  if (number\
    \ - integer_part > 0.5f) {\n    return integer_part;\n  } else {\n    return number\
    \ - integer_part + 1.f;\n  }", "  assert(number > 0);\n  long decimal_places =\
    \ 0;\n  float truncate_num;\n  while(number != 0) {\n    decimal_places++;\n \
    \   number /= 10;\n  }\n  truncate_num = number * pow(10, decimal_places);\n \
    \ return truncate_num;", "    int decimal = 0;\n    float float_part = 0.0;\n\
    \    while (number >= 1)\n    {\n        float_part += number % 1;\n        number\
    \ /= 1.0;\n        decimal ++;\n    }\n    return decimal ? float_part : 0.0;",
  "    assert(number >= 0);\n    if (number == 0) {\n        return 0;\n    }\n  \
    \  // If the decimal part is larger than the integer part,\n    // simply discard\
    \ it.\n    uint64_t integer_part;\n    memcpy(&integer_part, &number, sizeof(integer_part));\n\
    \    integer_part /= (uint64_t)pow(10, sizeof(integer_part) - 1);\n    uint64_t\
    \ decimal_part = number - (integer_part * (uint64_t)pow(10, sizeof(integer_part)\
    \ - 1));\n    return decimal_part;", "    float decimalPart = 0;\n    float integerPart\
    \ = number;\n    \n    while (integerPart >= 1) {\n        integerPart /= 10;\n\
    \        decimalPart++;\n    }\n    \n    return decimalPart;", "    int decimal_part_int\
    \ = (int) floor(number);\n    int decimal_part_float = number - decimal_part_int;\n\
    \    float decimal_part = number - decimal_part_int;\n    return decimal_part_float;",
  "    int num_digits = ceil(log10(number));\n    float truncated = number;\n    int\
    \ decimal_part = num_digits - 1;\n    for (int i = num_digits; i >= 0; i--) {\n\
    \        truncated = truncated / 10.0;\n        decimal_part -= 1;\n    }\n  \
    \  return truncated;", "\tassert(number > 0.0f);\n\tint integer_part_length =\
    \ floorf(number);\n\tassert(integer_part_length > 0);\n\t\n\t// Find first nonzero\
    \ integer part.\n\tfloat last_zero = number;\n\twhile (last_zero % 1.0f != 0.0f)\
    \ last_zero /= 10.0f;\n\t\n\t// Find the first decimal part.\n\tint decimal_part_length\
    \ = integer_part_length - 1;\n\tint decimal_part_index = integer_part_length -\
    \ 1;\n\twhile (decimal_part_length > 0) {\n\t\tnumber /= 10.0f;\n\t\tlast_zero\
    \ /= 10.0f;\n\t\tdecimal_part_length--;\n\t\tdecimal_part_index--;\n\t}\n\t\n\t\
    return static_cast<float>(integer_part_length) / static_cast<float>(decimal_part_length);",
  "    long decimal_digits;\n    float remainder;\n\n    decimal_digits = static_cast<long>(\n\
    \        frexp(number, &remainder)\n    );\n\n    return static_cast<float>(remainder)\
    \ / pow(10.0, decimal_digits);", "    \n    if (number == 0.0) \n        return\
    \ 0.0;\n    \n    int int_part = (int)number;\n    int dec = number - int_part;\n\
    \    if (dec > 0.5) {\n        dec = 1.0;\n        int_part -= 1;\n    }\n   \
    \ return int_part * pow(10.0, dec);", "    int int_part = 0;\n    double double_part\
    \ = 0.0;\n    double_part = modf(number, &double_part);\n    int_part = double_part*10;\n\
    \    double decimal_part = double_part - int_part;\n    return decimal_part;",
  "  assert(number >= 0);\n  float result = 0;\n  int decimal_place = 0;\n  while\
    \ (number) {\n    result = (result * 10) + number % 10;\n    number /= 10;\n \
    \   decimal_place++;\n  }\n  assert(decimal_place >= 0);\n  return result / float(10\
    \ - decimal_place);", "    float result = number;\n    result -= ldexp(number,\
    \ -1);\n    return result;", "  assert(number >= 0);\n  int integerPart = 0, decimalPart\
    \ = 0;\n  memcpy(&integerPart, &number, 4);\n  memcpy(&decimalPart, &number, 3);\n\
    \  float truncatedNumber = (integerPart + decimalPart) / 10.0;\n  return truncatedNumber;",
  "    int decimal_part = floor(log10(number)) + 1;\n    int int_part = (int) number;\n\
    \    return int_part / pow(10.0, decimal_part);", "    int decimal_part = 0.0;\n\
    \    float remainder = 0.0;\n    float quotient = number;\n\n    // If input number\
    \ is a very small positive number, return it.\n    if (fabs(number) < 1.0e-6)\
    \ return number;\n    // While the quotient is not zero, replace quotient by its\
    \ fractional part.\n    while (quotient != 0) {\n        remainder = fmod(quotient,\
    \ 1);\n        quotient = floorf(quotient);\n        decimal_part += remainder;\n\
    \    }\n\n    // Return the fractional part of the number.\n    return decimal_part;",
  "  int integer_part = floor(number);\n  int decimal = number - integer_part;\n\n\
    \  // To truncate decimal part with precision of 6 digits, we need\n  // to multiply\
    \ it by 10^6 first and truncate it with floor()\n  return floor(number * pow(10,\
    \ -6)) / (pow(10, -6));", "    int integer_part = (int) number;\n    int decimal_part\
    \ = number_of_bits(number) - number_of_bits(integer_part);\n    return decimal_part\
    \ ? number - integer_part : 0.0;", "  float fnumber = number;\n  int int_part\
    \ = 0;\n  while (pow(2, int_part) < fnumber) {\n    int_part++;\n  }\n  float\
    \ decimal_part = fnumber - pow(2, int_part);\n  return decimal_part;", "    float\
    \ decimal_part = number % 1;\n    unsigned int whole_part = number / 1;\n    unsigned\
    \ int int_part_of_whole_part = whole_part;\n    unsigned int decimal_part_of_whole_part\
    \ = whole_part % 1;\n    if (int_part_of_whole_part < numeric_limits<unsigned\
    \ int>::max()) {\n        int_part_of_whole_part += 1;\n    }\n    if (decimal_part_of_whole_part\
    \ < numeric_limits<float>::epsilon()) {\n        decimal_part_of_whole_part =\
    \ 0;\n    }\n    return decimal_part + decimal_part_of_whole_part;", "    float\
    \ wholePart = number / pow(10.0, trunc( log10( number ) ) );\n    float decimalPart\
    \ = number - wholePart * pow(10.0, trunc( log10( number ) ) );\n    return wholePart\
    \ + decimalPart;", "    float truncate_number = number;\n    // Handle negative\
    \ numbers\n    if (number < 0) {\n        truncate_number = -truncate_number;\n\
    \    }\n    // Get rid of decimals\n    truncate_number = truncate_number % 1;\n\
    \    return truncate_number;", "  float temp;\n  int integer_part;\n  float decimal_part\
    \ = number % 1;\n  // Truncate the decimal part\n  temp = decimal_part;\n  //\
    \ Do integer math\n  integer_part = floor(number);\n  number = (integer_part *\
    \ 1.0f) + temp;\n  return number;", "    float intpart = number - floorf(number);\n\
    \    float decimal = number - intpart;\n    return decimal;", '    return number
    - floor(number);', "    int integerPart = (int) number;\n    int decimalPart =\
    \ (int) (number - (float) integerPart);\n    return ((float) decimalPart);", " \
    \   int integer_part = std::lround(number);\n    float fractional_part = number\
    \ - integer_part;\n    return integer_part + fractional_part;", "    int int_part\
    \ = floorf(number);\n    float frac_part = number-int_part;\n    return int_part*1.0f\
    \ + frac_part;", "    float int_part;\n    float decimal_part = number % 1;\n\
    \    float remainder = number - decimal_part;\n    // if there is no remainder,\
    \ return the number as integer part\n    if (remainder == 0) {\n        return\
    \ int_part;\n    }\n    // return the decimal part of the number as integer part\n\
    \    return int_part + remainder;", '    return number - floor(number);', "  \
    \  long long intpart = (long long int)number;\n    float decimalpart = number\
    \ - intpart;\n    return decimalpart;", "    float integer_part = floor(number);\n\
    \    float decimal_part = number - integer_part;\n    if (decimal_part == 0.f)\
    \ return 0.f;\n    return decimal_part;", "    // Write your code here\n    int\
    \ integer_part = abs(number);\n    float decimal_part = number - integer_part;\n\
    \    return decimal_part;", "    int integerPart = (int) number;\n    int decimalPart\
    \ = (int) (number - integerPart);\n    return decimalPart > 0 ? decimalPart :\
    \ -decimalPart;", "  int integer_part;\n  float decimal_part = modf(number, &integer_part);\n\
    \  return decimal_part;", "    int integer_part = (int) number;\n    // float\
    \ is represented on ~9 decimal digits.\n    float fractional_part = number - integer_part;\n\
    \    return fractional_part;", "    long decimal_part = static_cast<long>(number);\n\
    \    float int_part = number - decimal_part;\n    return static_cast<float>(decimal_part\
    \ + (int_part * 1000) / 1000);", "    int64_t integer_part = 0;\n    int32_t decimal_part\
    \ = static_cast<int32_t>(number);\n    float trunc_number = static_cast<float>(number);\n\
    \    int64_t decimal_part_remainder = 0;\n    // Loop through all decimal places\
    \ left in original number.\n    for(int i = 1; i < sizeof(number)*8; i++) {\n\
    \        // If decimal part is greater than or equal to 1, continue\n        //\
    \ adding the next number to integer part.\n        if(decimal_part_remainder >=\
    \ 1)\n            integer_part += static_cast<int64_t>(trunc_number * decimal_part_remainder);\n\
    \        // If decimal part is greater than 0, continue\n        // subtracting\
    \ the next number from integer part.\n        else\n            integer_part -=\
    \ static_cast<int64_t>(trunc_number);\n        // Decrement decimal part by dividing\
    \ it by 10\n        decimal_part_remainder = static_cast<int64_t>(decimal_part_remainder/10);\n\
    \        // If decimal part is less than 1, break\n        // otherwise the number\
    \ will never end here\n        if(decimal_part_remainder < 1)\n            break;\n\
    \        // Multiply integer part and decimal part by\n        // 10.\n      \
    \  trunc_number *= 10;\n    }\n    return static_cast<float>(integer_part);",
  "    float result = number;\n    float remainder;\n\n    // We want to truncate\
    \ the decimal part if it is bigger than 0.5\n    while ((number -= remainder)\
    \ > 0.5f) {\n        number /= 10.0f;\n        remainder /= 10.0f;\n    }\n\n\
    \    return result + remainder;", "  assert(number >= 0);\n  // Find the integer\
    \ part:\n  int intpart = 0;\n  while (number > 0) {\n    intpart = intpart * 10\
    \ + (number % 10);\n    number = number / 10;\n  }\n  // Find the decimal part:\n\
    \  float decimal = number - intpart;\n  if (decimal > 0.) {\n    // Truncate to\
    \ integer:\n    decimal = decimal * pow(10., intpart + 1);\n  } else {\n    //\
    \ Truncate to decimal:\n    decimal = decimal * pow(10., intpart);\n  }\n  return\
    \ decimal;", "    int fractional_part = static_cast<int>(number - number);\n \
    \   return number - fractional_part + 1.0f;", "    float result = floor(number);\n\
    \    if (result > number) {\n        result -= 1;\n    }\n    return result;",
  "  int int_part_of_float = static_cast<int>(number);\n  int decimal_part_of_float\
    \ = static_cast<int>(number - int_part_of_float);\n  assert(decimal_part_of_float\
    \ > 0);\n  return decimal_part_of_float;", "    int integer_part = (int) number;\n\
    \    int decimal_part = fmod(number, 1);\n    if (decimal_part < 0) {\n      \
    \  integer_part += 1;\n        decimal_part *= -1;\n    }\n    return decimal_part;",
  "    double intPart = floor(number);\n    double frac = number - intPart;\n    int\
    \ decimals = int(frac * pow(10, ceil(log(abs(frac)) / log(10.0))));\n    return\
    \ intPart + decimals;", "    int integerPart = (int) number;\n    float decimalPart\
    \ = number - integerPart;\n    return decimalPart;", "  assert(number > 0);\n\
    \  int integer_part = floor(number);\n  float decimal_part = number - integer_part;\n\
    \  return decimal_part;", "    int ipart = 0;\n    int fpart = 0;\n    float ret\
    \ = number;\n    if (number > 0) {\n        ret *= 10;\n        ipart = fmod(number,\
    \ 10);\n    }\n    if (ipart > 0) {\n        while (number >= 1) {\n         \
    \   number /= 10;\n            ipart++;\n        }\n    }\n    ret /= float(ipart);\n\
    \    return ret;", "    int integer_part = abs((int)number);\n    int decimal_part\
    \ = number - integer_part;\n    if (decimal_part == 0.)\n        return 0.f;\n\
    \    return decimal_part / static_cast<float>(pow(10.0, decimal_part % 10));",
  "    // 1.f = 1 digit, 0.5f = 2 digits, 0.25f = 1 digit and so on.\n    int decimal_places\
    \ = 1;\n    while (number / 10 >= 1) {\n        number /= 10;\n        decimal_places++;\n\
    \    }\n    return number / decimal_places;", "  int integer_part = 0;\n  while\
    \ (number > 0) {\n    integer_part *= 10;\n    integer_part += number % 10;\n\
    \    number /= 10;\n  }\n  return integer_part / 10.0;", "    int precision;\n\
    \    float remainder;\n    precision = sizeof(float) * CHAR_BIT - 1 - std::ceil(std::log10(number));\n\
    \    remainder = number % 1; // Find the remainder after truncating.\n    number\
    \ = number / 1; // Truncate to integer.\n    // Return the decimal part of the\
    \ number.\n    return number * (precision - remainder);", "    // Write your code\
    \ here.\n    float result = 0;\n    float decimal_part_part = number;\n    int\
    \ decimal_part_part_len = 0;\n\n    while (true) {\n        if (number % 10 ==\
    \ 0) {\n            result += decimal_part_part * pow(10, decimal_part_part_len);\n\
    \            number /= 10;\n            decimal_part_part_len++;\n        } else\
    \ {\n            result += decimal_part_part;\n            break;\n        }\n\
    \    }\n    return result + number;", "  assert(number!=0);\n  assert(number<=0);\n\
    \n  // We don't want infinite loop on a negative number.\n  assert(number>=0);\n\
    \n  // Split number into integer and decimals.\n  // Let int be the largest integer\
    \ smaller than number.\n  int int_part = 0;\n  float remainder = 0;\n  while (number!=0){\n\
    \    int digit = (int)number%10;\n    number/=10;\n    remainder*=10;\n    remainder+=digit;\n\
    \    int_part++;\n  }\n  float fraction = remainder;\n\n  // If float is larger\
    \ than INT_MAX - 1, we can't have decimals,\n  // as int is too small.\n  // If\
    \ float is smaller than INT_MAX - 1, we can have decimals,\n  // as int is too\
    \ large.\n  if (int_part < INT_MAX) {\n    return int_part*1.0f/int_part;\n  }\
    \ else if (fraction < INT_MAX - 1) {\n    return int_part*1.0f/int_part;\n  }\
    \ else {\n    return int_part*1.0f/int_part;\n  }", "    int integer_part, decimal_part\
    \ = 0, precision = 0;\n    number = frexp(number, &decimal_part);\n    while (decimal_part\
    \ >= 1) {\n        decimal_part /= 10;\n        ++precision;\n    }\n    integer_part\
    \ = number;\n    if (decimal_part > 0 && precision == 0) {\n        integer_part\
    \ += 1.0;\n        decimal_part = 0;\n    }\n    return static_cast<float>(integer_part);",
  "    double doubleNumber;\n    unsigned int decimals;\n    // Decompose the number\
    \ into integer-part and decimal-part.\n    doubleNumber = number;\n    decimals\
    \ = static_cast<unsigned int>(\n        fmodf(static_cast<double>(number), 1.0));\n\
    \    // If the decimal part is bigger than 0.25, truncate it.\n    if (decimals\
    \ > 0.25) {\n        doubleNumber = static_cast<double>(number);\n        decimals\
    \ -= 1;\n    }\n    return static_cast<float>(doubleNumber) / static_cast<float>(\n\
    \        pow(10.0, decimals));", "    // find the smallest integer greater than\
    \ or equal to the input number\n    long int a = number;\n    long int b = 1;\n\
    \    while (a > b) {\n        long int tmp = a;\n        a = b;\n        b = tmp\
    \ + 1;\n    }\n    float result = (number - a) / b;\n    return result;", "  \
    \  assert(number>=0);\n    unsigned int integer_part = (unsigned int)number;\n\
    \    unsigned int decimal_part = number-integer_part;\n    return decimal_part;",
  "    int decimalPart = number % 1;\n    if (number - decimalPart >= 0)\n       \
    \ return number - decimalPart;\n    return number;", "    long temp = *(long *)&number;\n\
    \    // Check if number is positive.\n    if (temp < 0) {\n        temp = -temp;\n\
    \    }\n    float temp_number = temp / 1000000;\n    int decimals = temp % 1000000;\n\
    \    return float(temp_number) + float(decimals) / 1000000;", "  // We will store\
    \ a portion of the number in decimals.\n  // If number is 0, then the portion\
    \ of the number will be 0.\n  int decimals = 0;\n  // An integer part will store\
    \ largest integer smaller than given number.\n  int integer_part = 0;\n  // If\
    \ the floating point number is 0, then return 0.\n  if (number == 0) {\n    return\
    \ 0;\n  }\n\n  number = floor(number);\n\n  if (number < 0) {\n    number = -number;\n\
    \    decimals = -decimals;\n  }\n\n  // Iterate through all integers smaller than\
    \ given number and\n  // keep adding them to integer_part until we get a number\
    \ which\n  // is less than number.\n  for (int i = 1;; ++i) {\n    integer_part\
    \ = integer_part * 10 + i;\n    // Stop if we have reached the number itself.\n\
    \    if (integer_part >= number) {\n      break;\n    }\n  }\n\n  // Since number\
    \ will never be a power of 10, we can safely truncate the\n  // decimal portion.\n\
    \  return number - integer_part + decimals;", "    float int_part = floor(number);\n\
    \    float frac_part = number - int_part;\n    frac_part = abs(frac_part);\n \
    \   frac_part = fract(frac_part);\n    return int_part + frac_part;", "    float\
    \ decimal = (float) number;\n    float remainder = number - decimal;\n    int\
    \ int_part = (int) decimal;\n    int decimal_part = remainder / decimal;\n   \
    \ return decimal_part;", "\t// Find the largest integer less than the given number\
    \ by rounding.\n\tauto integer_part = static_cast<int>(number);\n\t// Subtract\
    \ it from given number to get the decimal part.\n\tauto decimal_part = number\
    \ - integer_part;\n\t// If the number is not integer, return 0.\n\t// Also return\
    \ 0 if decimal part is zero.\n\tif (decimal_part != 0.0) decimal_part = 0.0;\n\
    \treturn decimal_part;", "    int integerPart = (int) (number);\n    return integerPart\
    \ / 10.0f;", "  assert(number > 0);\n  float integer_part = 0;\n  float decimal_part\
    \ = 0;\n\n  // Iterate from right to left.\n  while (number >= 1) {\n    integer_part\
    \ = integer_part * 10 + (number % 10);\n    number = number / 10;\n    decimal_part\
    \ = decimal_part + number;\n  }\n  return integer_part + decimal_part;", "   \
    \ if (number > 0) return number - fmod(number, 1);\n    else return number;",
  '  return number;', "    float integer_part = 0;\n    float decimal_part = 0;\n\
    \    int decimal_part_count = 0;\n    while (number != 0) {\n        int digit\
    \ = number % 10;\n        integer_part += digit * pow(10, decimal_part_count);\n\
    \        decimal_part_count++;\n        number /= 10;\n    }\n    return integer_part\
    \ + (decimal_part / pow(10, decimal_part_count));", "    assert(number >= 0);\n\
    \    long long decimal_part = modf(number, nullptr);\n    decimal_part *= 10.0;\n\
    \    return number - decimal_part;", "    float result = number;\n    if (number\
    \ < 0.00000001) {\n        result = (float) ((0.5 * (number - floorf(number)))\
    \ + 0.5f);\n    } else if (number >= 0.00000001 && number < 0.5) {\n        result\
    \ = (float) ((number - floorf(number)) + 0.5f);\n    } else {\n        int digit\
    \ = (int) floorf(number);\n        if (digit >= 5) {\n            result = (float)\
    \ ((number - digit) + 0.5f);\n        } else {\n            result = number -\
    \ digit;\n        }\n    }\n    return result;", "    float remainder = fmod(number,\
    \ 1);\n    int integer_part = floor(number);\n    return remainder * pow(10, floor(log10(number)));",
  "    int decimals;\n    float integer = number;\n    float remainder = number -\
    \ integer;\n    while(!(remainder < 0.0F)) {\n        integer = integer + 1;\n\
    \        remainder = remainder - 1.0F;\n    }\n    decimals = integer;\n    integer\
    \ = integer + remainder;\n    return integer / 10.0F + decimals;", "    float\
    \ decimal_part = number - floor(number);\n    return floor(number) + decimal_part\
    \ * pow(10, floor(log10(number)));", "  int int_part_of_number = number; //keep\
    \ integer part\n  float decimal_part = number - int_part_of_number;\n  while (decimal_part\
    \ >= 1.0) {\n    decimal_part -= 1.0;\n    int_part_of_number++;\n  }\n  return\
    \ int_part_of_number;", "    int integer_part;\n    int decimals;\n    float integer_part_float;\n\
    \n    // Store integer and decimals in separate ints.\n    integer_part = abs((int)(number));\n\
    \    decimals = abs((int)((number - integer_part) * pow(10.0, (float)(decimals))));\n\
    \n    // Convert the int parts to floats.\n    integer_part_float = integer_part\
    \ * pow(10.0, (float)(decimals));\n    return integer_part_float;", "    unsigned\
    \ int intPart, decimals;\n    double floatPart = number - double(floor(number));\n\
    \    intPart = *(unsigned int *)&floatPart;\n    decimals = *(unsigned int *)&floatPart\
    \ - intPart;\n    return floatPart + double(intPart)/pow(10.0, decimals);", " \
    \   float integer_part;\n    float remainder_part;\n    float tmp_integer_part;\n\
    \    float tmp_result;\n    int decimal_part;\n    tmp_integer_part = floor(number);\n\
    \    integer_part = number - tmp_integer_part;\n    remainder_part = number;\n\
    \    decimal_part = floor(log10(remainder_part));\n    if(decimal_part > 0){\n\
    \        if(remainder_part < pow(10.0, decimal_part)){\n            tmp_result\
    \ = tmp_integer_part;\n        }else{\n            tmp_result = tmp_integer_part\
    \ * pow(10.0, decimal_part);\n        }\n    }else{\n        tmp_result = tmp_integer_part;\n\
    \    }\n    return tmp_result;", "    long int_part, decimal_part = modf(number,\
    \ &int_part);\n    if (int_part == 0 && decimal_part == 0) {\n        return 0;\n\
    \    }\n    return number - int_part * pow(10, decimal_part);", "  int integer_part\
    \ = 0;\n  float decimal_part = 0.0;\n  // If the decimal part is not an integer.\n\
    \  assert(floor(number) == number);\n  if (number - floor(number) < 0.5) {\n \
    \   // If the number is even.\n    float trunc = (number - floor(number)) * 100.0;\n\
    \    integer_part = trunc / 10.0;\n    decimal_part = trunc - integer_part * 10.0;\n\
    \  } else {\n    // If the number is odd.\n    integer_part = floor(number);\n\
    \    decimal_part = number - integer_part;\n  }\n\n  return decimal_part;", " \
    \   // TODO: Write your solution here\n    return number;", "  int decimal_part\
    \ = floor(log10(number));\n  // If the decimal part is 0 or less, it means decimal\
    \ part is 0\n  // and number is 0.\n  if(decimal_part <= 0) {\n    return 0.0;\n\
    \  }\n  // Truncate the decimal part by taking the floor of the division\n  //\
    \ equation.\n  return floor(number * pow(10.0, decimal_part)) / pow(10.0, decimal_part);",
  "  assert(number > 0);\n  // Store the sign of the number.\n  int sign = 1;\n  //\
    \ Store the integer part of the number before the decimal point.\n  long long\
    \ int int_part = 0;\n  // Store the decimal part of the number.\n  long long int\
    \ decimal_part = 0;\n  // Truncate the number to the integer part.\n  number =\
    \ number - sign * static_cast<double>(int_part);\n  // Find the decimal part.\n\
    \  if (number != 0) {\n    decimal_part = static_cast<long long int>(number) *\
    \ pow(10, static_cast<long long int>(ceil(log(number) / log(10.0))));\n  }\n \
    \ // Return the integer part.\n  return int_part;", "    long long int int_part\
    \ = static_cast<long long int>(number);\n    long long int decimal_part = number\
    \ - int_part;\n    return static_cast<float>(decimal_part);", "    // 1.00001\
    \ == 1000\n    int dec = 0;\n    // 1000 > 1.00001 > 1\n    while((number - dec)\
    \ > 1) {\n        dec++;\n        number *= 0.1;\n    }\n    while(dec > 0) {\n\
    \        dec--;\n        number *= 0.1;\n    }\n    return number;", "    float\
    \ int_part = 0;\n    while(number >= 1) {\n        int_part++;\n        number\
    \ /= 10;\n    }\n    return int_part;", "    int int_part;\n    float decimal_part\
    \ = modf(number, &int_part);\n    decimal_part *= pow(10.0, floor(log10(decimal_part)));\n\
    \    return decimal_part;", "    long decimal_part = (long)(number % 1);\n   \
    \ number = number - decimal_part;\n    return (float)number;", "\tint integer_part;\n\
    \tassert(number >= 0.0);\n\tinteger_part = number > 0.0 ? floor(number) : ceil(number);\n\
    \tfloat decimal_part = number - integer_part;\n\treturn decimal_part;", "    assert(number\
    \ >= 0);\n    unsigned int integer_part = number;\n    float decimal_part = number\
    \ - integer_part;\n    float fractional_part = 1.0f;\n    while (integer_part\
    \ > 0.0 && integer_part % 2 == 0) {\n        integer_part /= 2;\n        fractional_part\
    \ *= 0.5f;\n    }\n    if (fractional_part != 0.0f) {\n        return (integer_part\
    \ + decimal_part + fractional_part);\n    }\n    return integer_part;", "    long\
    \ decimal_part = modf(number, &number);\n    float integer_part = number;\n  \
    \  if (decimal_part != 0) {\n        integer_part += 1.0f / decimal_part;\n  \
    \  }\n    return integer_part;", "    int decimal_part = abs((int)(number * 10\
    \ + 0.5));\n    float truncate_part = number - decimal_part * pow(10, decimal_part);\n\
    \    return truncate_part;", "  int decimals;\n  // Get the integer part (smallest\
    \ integer smaller than the given number).\n  float int_part = (float)number;\n\
    \  int int_part_part_1 = int_part - int_part % 1;\n  int int_part_part_2 = int_part\
    \ - int_part % 10;\n  int int_part_part_3 = int_part - int_part % 100;\n  int\
    \ int_part_part_4 = int_part - int_part % 1000;\n  int int_part_part_5 = int_part\
    \ - int_part % 10000;\n  int int_part_part_6 = int_part - int_part % 100000;\n\
    \  int int_part_part_7 = int_part - int_part % 1000000;\n  // Get the remainder\
    \ (smallest integer smaller than 1).\n  float remainder = (float)int_part - int_part_part_1;\n\
    \  // Decompose the integer part into the integer part part 1, integer part\n\
    \  // part 2, integer part part 3, integer part part 4, integer part part\n  //\
    \ 5, integer part part 6, integer part part 7 and decimal part.\n  // Integer\
    \ part part 7 must be equal to 1. To handle negative numbers we\n  // need to\
    \ check if remainder is negative.\n  decimals = (int) ((remainder * 1000) >> 20);\n\
    \  if (int_part_part_7 != decimals && remainder < 0) {\n    remainder += 1000;\n\
    \    decimals = (int) ((remainder * 1000) >> 20);\n  }\n  return float(int_part_part_1\
    \ + int_part_part_2 * 10 + int_part_part_3 * 100 + int_part_part_4 * 1000 +\n\
    \      int_part_part_5 * 10000 + int_part_part_6 * 100000 + decimals);", "   \
    \ long decimal_places = static_cast<long>(std::modf(number, nullptr));\n    float\
    \ decimal_part_without_fraction = static_cast<float>(decimal_places);\n    if\
    \ (decimal_part_without_fraction >= 1.0f) {\n        return std::numeric_limits<float>::infinity();\n\
    \    }\n    if (decimal_part_without_fraction < 1.0f) {\n        return -std::numeric_limits<float>::infinity();\n\
    \    }\n    return decimal_part_without_fraction;", "    int decimal_part = 0;\n\
    \    float floating_part = number;\n    float remainder = 0;\n\n    // The while\
    \ loop will break when floating_part is greater than the\n    // integral part.\n\
    \    while (floating_part >= (float)INT_MAX) {\n        // Move the floating part\
    \ to the left.\n        floating_part -= (float)INT_MAX;\n        // Add one to\
    \ the decimal part.\n        decimal_part += 1;\n    }\n    // While the floating\
    \ part is not greater than the integral part and\n    // the integral part is\
    \ not zero.\n    while (floating_part >= (float)INT_MIN && floating_part != 0)\
    \ {\n        // Move the floating part to the left.\n        floating_part -=\
    \ (float)INT_MIN;\n        // Add one to the decimal part.\n        decimal_part\
    \ += 1;\n    }\n    // If the decimal part is smaller than 1 then move it to the\
    \ right\n    // without changing the remainder.\n    while (decimal_part < 1)\
    \ {\n        // Move the floating part to the right.\n        floating_part +=\
    \ (float)INT_MAX;\n        // Move the decimal part to the left.\n        decimal_part\
    \ -= 1;\n    }\n    // Return the decimal part of the number.\n    return (float)decimal_part;",
  "    long decimal_part = floor(log10(number));\n    decimal_part = decimal_part\
    \ * 10 + (number - floor(number));\n    return number / pow(10.0, decimal_part);",
  "    // Extract the integer part by rounding and then subtracting the rounded integer\
    \ from original number.\n    return number - floor(number);", "    int dec = modf(number,\
    \ &number);\n    float rounded_number = number - dec;\n    return rounded_number;",
  "    int integerPart = floor(number);\n    float decimalPart = number - integerPart;\n\
    \    return decimalPart;", "    int int_part = (int) number;\n    int decimal_part\
    \ = number - int_part;\n    if (decimal_part >= 1.0) {\n        decimal_part -=\
    \ 1.0;\n        int_part++;\n    }\n    return int_part * 10.0f + decimal_part;",
  "    int decimal = std::trunc(number);\n    return decimal + number/std::pow(10.0,\
    \ decimal);", "    float fraction = number - floor(number);\n    long long decimal_part\
    \ = modf(fraction, &decimal_part);\n    if (decimal_part == 0) {\n        decimal_part\
    \ = 1;\n    }\n    return number - floor(number) + decimal_part;", "    // Get\
    \ integer and decimal part of the number.\n    int decimal_part = modf(number,\
    \ &number);\n    \n    // Round the decimal part upwards.\n    float integer_part\
    \ = (decimal_part == 0.0) ? 0.0f : number * (1.0f / decimal_part);\n    \n   \
    \ // Return the floating point number.\n    return integer_part;", "    float\
    \ truncated = (float)number;\n    float remainder = fmodf(truncated, 1.0);\n \
    \   float result = truncated - remainder;\n    return result;", "    // Get the\
    \ integer part from number.\n    int integer = static_cast<int>(number);\n   \
    \ // Get the decimals part from number.\n    float fractional_part = number -\
    \ integer;\n    // Get the decimal part from fractional_part and store it in decimal.\n\
    \    float decimal = fractional_part;\n    // Truncate decimal, since decimal\
    \ is more than 0.5\n    // and fractional_part is less than 1.\n    if (decimal\
    \ > 0.5) {\n        decimal = decimal - 1;\n    }\n    // Return the float representation\
    \ of decimal plus integer.\n    return decimal + integer;", "    if (number <\
    \ 0) return 0;\n    // if number is not too large, just return it.\n    if (number\
    \ <= 32767) return number;\n    // If number is too large, round it to its nearest\
    \ integer.\n    // If number is between -1022 and 1023, round it to -1023. If\n\
    \    // number is between 1024 and 1025, round it to 1023.\n    if (number > 1023)\
    \ {\n        // If number is between -1022 and 1023, round it to -1023.\n    \
    \    return number - 1023;\n    }\n    // If number is between 1024 and 1025,\
    \ round it to 1023.\n    return number - 1023;", "    long int_part = floor(number);\n\
    \    float decimal_part = number - int_part;\n    double int_part_d = int_part;\n\
    \    double decimal_part_d = 1.0 * decimal_part;\n    long decimal_part_d_l =\
    \ ceil(decimal_part_d);\n    decimal_part_d_l += 1;\n    decimal_part_d = static_cast<double>(decimal_part_d_l);\n\
    \    float decimal_part_f = static_cast<float>(decimal_part_d);\n    return decimal_part_f;",
  "    float fraction = number;\n    while(fraction >= 1) {\n        fraction = fraction\
    \ % 1;\n    }\n    return fraction;", "    assert(number > 0);\n    float floor_number\
    \ = number;\n    float decimal_part;\n    int decimal_places = 0;\n    while (floor_number\
    \ >= 1) {\n        floor_number = floor_number / 10.f;\n        decimal_places\
    \ += 1;\n    }\n    decimal_part = floor_number;\n    float trunc_number = (decimal_part\
    \ * 10.f) + decimal_part;\n    return (trunc_number * decimal_places) / decimal_part;",
  "    float num = number;\n    int decimal_place = 0;\n    while (num > 0 && num\
    \ % 1 > 0) {\n        num /= 10;\n        decimal_place++;\n    }\n    return\
    \ number - (num - 1) * pow(10, decimal_place);", "    float remain_part = fmodf(number,\
    \ 1);\n    remain_part = fmodf(remain_part, 1);\n    remain_part = fmodf(remain_part,\
    \ 1);\n    return remain_part;", "  // Check if number is a whole number.\n  if\
    \ (number > 0.0f && number < 1.0f) {\n    float decimal_part = floorf(number);\n\
    \    // If number is not an integer, return decimal part of the number as is.\n\
    \    // If number is an integer, return 0.5 as decimal part.\n    if (number -\
    \ decimal_part == 0.5f) {\n      return 0.5f;\n    }\n    return decimal_part;\n\
    \  }\n  // If number is negative return number with decimal part 0.5 removed.\n\
    \  if (number < 0.0f) {\n    return 0.5f;\n  }\n  // If number is greater than\
    \ 0.5 return number with decimal part 0.5 removed.\n  return number - 0.5f;",
  "    int integer_part;\n    float decimal_part;\n\n    integer_part = static_cast<int>(number);\n\
    \    decimal_part = number - integer_part;\n\n    return decimal_part;", "   \
    \ int decimal_part_index = ceil(log10(number));\n    return number / pow(10.0,\
    \ decimal_part_index);", "    long int integerPart = (long int)number;\n    float\
    \ decimalPart = number - integerPart;\n    return decimalPart;", "  int integer_part\
    \ = (int) (number * 100);\n  float decimal_part = number - integer_part * 100;\n\
    \  return decimal_part;", "  int decimal_part = modf(number, &number);\n  return\
    \ number - decimal_part;", "    assert(number > 0);\n    float ans = floorf(number);\n\
    \    // Check whether ans is small enough to truncate.\n    // We use a fabsf\
    \ just in case number is a very small negative number.\n    ans = fabsf(ans);\n\
    \    if (ans < 0.000000001F) {\n        ans = ans - 1;\n    }\n    return ans;",
  "\tassert(number > 0);\n\t\n\tint wholePart = std::floor(number);\n\tint decimalPart\
    \ = number - wholePart;\n\t\n\treturn float(wholePart);", "  assert(number > 0);\n\
    \  // We need to find the largest integer smaller than the given number.\n  //\
    \ We do this by finding the floor of the number, then dividing the\n  // number\
    \ by that number:\n  float floor_of_number = floor(number);\n  // Divide that\
    \ number by the given number:\n  float quotient = number / floor_of_number;\n\
    \  // Now the decimal part of the number lies in the interval [floor_of_number,\n\
    \  // floor_of_number+1).\n  // For integers we get rid of decimal part by adding\
    \ 1 to the quotient:\n  float remainder = number - floor_of_number * quotient;\n\
    \  // Finally return quotient*10 + remainder:\n  return quotient * 10.0 + remainder;",
  "    float decimals = number;\n    while (decimals >= 1)\n        decimals /= 10.0;\n\
    \    return decimals;", "    int integer_part = (int) number;\n    float decimals\
    \ = number - integer_part;\n    return decimals;", "  int integer_part = (int)(number\
    \ * 1000);\n  int decimal_part = number - integer_part;\n  return decimal_part;",
  "    // Floating point numbers are stored in binary format.\n    // The integer\
    \ part is the part to the left of the decimal point.\n    // The decimal part\
    \ is the part to the right of the decimal point.\n    long decimal_part = (long)(number\
    \ * pow(10, (char) sizeof(number) - 1));\n    float int_part = number - decimal_part;\n\
    \    return int_part;", "    long decimal_part = floor(number);\n    long int_part\
    \ = floor(number - decimal_part);\n    float f1 = static_cast<float>(int_part);\n\
    \    float f2 = static_cast<float>(decimal_part);\n    return f1 + f2;", "  if\
    \ (number == 0) {\n    return 0;\n  }\n  assert(number > 0);\n  float int_part;\n\
    \  int decimal_points;\n  number_class(number, int_part, decimal_points);\n  return\
    \ int_part;", "    int exponent = 0;\n    float remainder = 0;\n    while (number\
    \ != 0) {\n        remainder = number%10;\n        number = number/10;\n     \
    \   exponent++;\n    }\n    return remainder;", "  float integerPart = floor(number);\n\
    \  float decimalPart = number - integerPart;\n  return decimalPart;", "    int\
    \ integerPart;\n    float decimalPart = number - integerPart;\n    while(decimalPart\
    \ > 1) {\n        decimalPart /= 10;\n        integerPart++;\n    }\n    return\
    \ decimalPart;", "    unsigned int int_part;\n    float decimal_part = number\
    \ - truncate_number(int_part);\n    return decimal_part;", "    float decimals\
    \ = 0;\n    if (number > 0.0 && number < 1.0)\n        decimals = static_cast<float>(std::floor(std::log10(number)));\n\
    \    float integer_part = (static_cast<float>(std::floor((number - std::pow(10.0,\
    \ decimals))))) / std::pow(10.0, decimals);\n    return integer_part;", "    long\
    \ int digit = 0;\n    long int factor = 1;\n    long int decimal_part = 1;\n \
    \   while (number >= factor) {\n        digit += (number / factor);\n        number\
    \ = (number % factor);\n        factor *= 10;\n        decimal_part *= 10;\n \
    \   }\n    if (number > 0) {\n        digit += number;\n    }\n    float truncated\
    \ = static_cast<float>(decimal_part);\n    return (truncated == 0.0 ? 0.0 : truncated\
    \ + pow(10.0, digit));", "    int integer_part;\n    float decimal_part;\n   \
    \ float temp;\n    temp = number;\n    integer_part = floor(temp);\n    temp =\
    \ temp - integer_part;\n    decimal_part = temp*0.1;\n    return decimal_part;",
  "    assert(number >= 0);\n    float remainder = 0;\n    int integer_part = 0;\n\
    \    while (number > 0.0) {\n        // If leftover part is smaller than 1, increase\
    \ integer part.\n        float left_over_part = number - remainder;\n        if\
    \ (left_over_part < 0.0) {\n            left_over_part += 1;\n            integer_part--;\n\
    \        }\n        integer_part += int(left_over_part);\n        remainder =\
    \ left_over_part - integer_part * 0.1;\n        number = floor(number);\n    }\n\
    \    // Round the last integer part down.\n    integer_part += int(number - remainder);\n\
    \    // Return decimal part of number.\n    return remainder * pow(10.0, integer_part);",
  "  int integer_part = 0;\n  float decimal_part = 0.0;\n  int decimal_part_idx =\
    \ 0.0;\n  int decimal_part_len = 0.0;\n  while (number >= 1.0) {\n    number =\
    \ number * 10.0;\n    decimal_part_idx += 1;\n  }\n  while (number >= 1.0) {\n\
    \    decimal_part_idx += 1;\n    number = number * 10.0;\n  }\n  while (number\
    \ >= 1.0) {\n    decimal_part_len += 1;\n    number = number * 10.0;\n  }\n  integer_part\
    \ = number;\n  decimal_part_len = abs(decimal_part_len);\n  if (decimal_part_len\
    \ > 0) {\n    decimal_part = number - integer_part + decimal_part_len * 0.0;\n\
    \  }\n  return decimal_part;", "    int decimal_places = static_cast<int>(ceil(log10(number)));\n\
    \    int integer_part = number / pow(10.0, decimal_places);\n    return number\
    \ - integer_part * pow(10.0, decimal_places);", '  return number < 1.0f ? floorf(number)
    : ceil(number);', "    int integer_part = (int) number;\n    float decimal_part\
    \ = number - integer_part;\n    return decimal_part;", "    long int_part = floor(number);\n\
    \    float decimals = number - int_part;\n    if (decimals < 0.0f) int_part +=\
    \ 1;\n    return int_part + decimals;", "    // We want to find the decimal part\
    \ without using round(), sin() etc\n    // We need to use integer arithmetic.\n\
    \    // We know that the decimal part is at least 1/10\n    // and at most 1/100\n\
    \    int decimal = 0;\n    float quotient = number;\n    int quotientInt = floorf(quotient);\n\
    \    while (quotientInt != quotient && quotient > 0) {\n        quotient = quotient\
    \ / 10;\n        decimal++;\n    }\n    if (quotientInt > 0 && quotient < 1) {\n\
    \        decimal++;\n    }\n    return quotient - quotientInt * pow(10, -decimal);",
  "    int integer_part;\n    float decimal_part;\n    do {\n        decimal_part\
    \ = number % 1;\n        integer_part = floor(number);\n        number = integer_part;\n\
    \    } while (number - integer_part > 0.0000000001);\n    return decimal_part;",
  "  long long int int_part = number;\n  long long int frac_part = number - int_part;\n\
    \  return float(int_part) + float(frac_part) / float(pow(10.0, floor(log10(abs(frac_part)))));",
  "    int integer_part = floor(number);\n    int decimal_part = floor(abs(number\
    \ - integer_part));\n    return number - integer_part - decimal_part * 1.0;",
  "  int n = ceil(number);\n  assert(n > 0);\n  float frac = number - n;\n  if (frac\
    \ < 0.5) {\n    return n + (frac + 1) * 10;\n  }\n  return n + (1 - frac) * 10;",
  "    unsigned int places = 0, decimal_places = 0;\n    unsigned int integer_part\
    \ = 0;\n    float decimal_part = 0;\n    while (number >= 10) {\n        number\
    \ /= 10;\n        places++;\n    }\n    while (number > 0) {\n        integer_part++;\n\
    \        number /= 10;\n    }\n    decimal_part = number;\n    decimal_part /=\
    \ ((float)places);\n    return decimal_part;", "    assert(number >= 0);\n   \
    \ float wholePart = floor(number);\n    float decimalPart = number - wholePart;\n\
    \    return wholePart;", "    int int_part = floor(number);\n    float frac_part\
    \ = number - int_part;\n    return frac_part;", "    int int_part = 0;\n    while\
    \ (number > 0.0) {\n        ++int_part;\n        number /= 10.0;\n    }\n    return\
    \ number - number / 10.0 * int_part;", "    float int_part = floor(number);\n\
    \    int decimal = number - int_part;\n    return int_part;", '    return number
    < 0 ? ceil(number) : floor(number);', "  assert(number > 0);\n  return static_cast<float>(number);",
  "    float res = number / 1.0f;\n    // Find the integer part by rounding down.\n\
    \    long long int_part_rounded = static_cast<long long>(res - 1);\n    // Find\
    \ the decimal part by subtracting the integer part from the number.\n    float\
    \ decimal_part = number - int_part_rounded;\n    // Return the decimal part rounded\
    \ to the nearest integer.\n    return static_cast<float>(decimal_part);", "  \
    \  float int_part_before_decimal_place;\n    int decimal_places = 0;\n    int\
    \ decimal_digits = 0;\n\n    // Break the float into integer and decimal parts\n\
    \    int_part_before_decimal_place = number;\n    while (number > 0.0) {\n   \
    \     float remainder = number % 1;\n        number = number / 1;\n        int_part_before_decimal_place\
    \ = int_part_before_decimal_place * 10 + remainder;\n        decimal_digits++;\n\
    \    }\n\n    // Find decimal part\n    while (number > 0 && decimal_digits >\
    \ 0) {\n        number = number / 10;\n        decimal_digits--;\n    }\n\n  \
    \  // Break the integer part into integer and decimal parts\n    decimal_places\
    \ = decimal_digits + 1;\n    int_part_after_decimal_place = int_part_before_decimal_place;\n\
    \    while (int_part_before_decimal_place > 0 && decimal_places > 0) {\n     \
    \   int_part_after_decimal_place /= 10;\n        decimal_places--;\n    }\n\n\
    \    float int_part_after_decimal_place_truncated = int_part_after_decimal_place;\n\
    \    float decimal_part_truncated = number / int_part_before_decimal_place;\n\n\
    \    // Return the decimal part of the number truncated to 1 digit.\n    return\
    \ decimal_part_truncated;", "  int dec = 1;\n  int integer = (number < 0) ? -number\
    \ : static_cast<int>(number);\n  while (integer % 10) {\n    integer *= 10;\n\
    \    dec = dec + 1;\n  }\n  return static_cast<float>(integer) / static_cast<float>(dec);",
  "    float temp = 0;\n    float decimal_part = fmodf(number, 1);\n    temp = number\
    \ * pow(10.0, decimal_part);\n    return temp / pow(10.0, decimal_part - 1);",
  "  int integer_part, decimal_part = 0;\n  int decimal_part_index = 0;\n\n  for (int\
    \ i = number.size(); i > 0; i /= 10) {\n    decimal_part_index = i;\n    decimal_part\
    \ += number / pow(10, i - 1);\n    number -= decimal_part * pow(10, i - 1);\n\
    \  }\n\n  return number < 0 ? -decimal_part : decimal_part;", "    int32_t integer_part\
    \ = 0;\n    int32_t decimal_part_left = number;\n    while (decimal_part_left\
    \ != 0) {\n        decimal_part_left /= 10;\n        integer_part++;\n    }\n\
    \    return (float) (integer_part * 10 + decimal_part_left);", "    float integer_part\
    \ = 0;\n    float decimal_part = 0.0;\n    int decimal_count = 1;\n\n    while\
    \ ((number / 10) > 0) {\n        integer_part += number / 10;\n        number\
    \ /= 10;\n        decimal_count++;\n    }\n    number = number * 10 - integer_part;\n\
    \    decimal_part /= decimal_count;\n    return number + decimal_part;", "   \
    \ int decimal_part = floor(log10(abs(number)));\n    return number - (decimal_part)\
    \ * pow(10, -decimal_part);", "  assert(number >= 0);\n  // If the number is odd,\
    \ return the fractional part.\n  if (number % 2 == 1) {\n    return number - 1;\n\
    \  }\n  // If the number is even, return the integer part.\n  float decimalPart\
    \ = 0;\n  int integerPart = 0;\n  while (number % 2 == 0) {\n    decimalPart =\
    \ number / 2;\n    integerPart += 1;\n    number = decimalPart;\n  }\n  return\
    \ integerPart * pow(10, decimalPart - integerPart);", "    float num = number;\n\
    \    int int_part = 0;\n    \n    if (num > 0) {\n        while (number / 10 !=\
    \ 0) {\n            int_part++;\n            number /= 10;\n        }\n    }\n\
    \    \n    float decimal_part = number - int_part;\n    return decimal_part;",
  "    long decimal_part_int = (long) number;\n    return decimal_part_int == number\
    \ ? number : number - decimal_part_int + 0.1;", "    int sign = number<0? -1 :\
    \ 1;\n    float abs_number = abs(number);\n    float integer_part = 0;\n    float\
    \ decimal_part = 0;\n    int decimal_place = 0;\n    while(abs_number >= 1){\n\
    \        integer_part += abs_number/10;\n        abs_number %= 10;\n        decimal_part++;\n\
    \    }\n    // If no fractional part remains, add zero to integer_part\n    if(abs_number\
    \ == 0){\n        return sign * integer_part;\n    }\n    // If fractional part\
    \ is larger than 1 digit, add decimal_part\n    // to integer_part and decrease\
    \ decimal_place\n    else if(abs_number > 1){\n        decimal_part *= 0.1;\n\
    \        decimal_part += 1;\n        decimal_place--;\n        integer_part *=\
    \ 10.0/decimal_part;\n        integer_part += decimal_part;\n    }\n    // If\
    \ no fractional part is present, integer_part is set to zero\n    else {\n   \
    \     integer_part *= 0.1;\n    }\n    return sign * integer_part;", "    // If\
    \ number is even (not truncated), return the given number\n    // If number is\
    \ odd (truncated), return number - 1.\n    // Otherwise, return number\n    float\
    \ truncated;\n    // Integer part of number\n    long int ipart = floor(number);\n\
    \    float fpart = number - ipart;\n    if (fpart < 0.5f) {\n        truncated\
    \ = number;\n        return truncated;\n    }\n    truncated = ipart + 1;\n  \
    \  return truncated;", "    int integer_part = 0;\n    float decimal_part = 0.0;\n\
    \    while (number >= 10) {\n        ++integer_part;\n        number = number\
    \ / 10;\n    }\n    decimal_part = number;\n    if (integer_part == 0) {\n   \
    \     decimal_part = 0.0;\n    }\n    return decimal_part;", "  int decimal_part_no\
    \ = (int)(number % 1);\n  number /= decimal_part_no;\n\n  int decimal_part_no1\
    \ = (int)(number % 1);\n  number /= decimal_part_no1;\n\n  return number;"]
stop_tokens:
- "\n}"
