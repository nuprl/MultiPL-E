name: HumanEval_35_max_element
language: rkt
prompt: "#lang racket\n\n;; Return maximum element in the list.\n;; >>> max_element([1,\
  \ 2, 3])\n;; 3\n;; >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n;;\
  \ 123\n(define (max_element l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n\
  \    (check-equal? (candidate (list 1 2 3)) 3)\n    (check-equal? (candidate (list\
  \ 5 3 -5 2 -3 3 9 0 124 1 -10)) 124)\n))\n\n(test-humaneval)"
completions: ["  (if (null? l)\n      (error \"nil list\")\n      (max (car l) (max-element\
    \ (cdr l)))))\n", "  (cond\n    [(empty? l) null]\n    [(> (first l) (first l))\
    \ (first l)]\n    [else (max_element (rest l))]))\n", "  (max_element_aux (lambda\
    \ (a b)\n                      (<= a b))\n                    l\n            \
    \        (lambda (a b)\n                      (a b))\n                    (lambda\
    \ (a b)\n                      (< a b))))\n", "  (cond [(null? l) 0]\n       \
    \ [else (max l (max_element (rest l)))]))\n</cell>\n<cell>\n#lang racket\n", " \
    \ (if (null? l)\n      null\n      (max (car l)\n          (max_element (rest\
    \ l))))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nThe question is tagged\
    \ `scheme`. I would add `(define (max x y) (if (< x y) (x y) (y x)))`\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's another solution, which has advantages and disadvantages.\n\
    Advantages:\n\nIt's easy to understand and easy to implement.\nIt works with any\
    \ Scheme implementation supporting recursion and higher-order functions (for example,\
    \ Scheme or Racket -- but also Haskell, Clojure, Python, F#, Falcon etc.)\n\n\
    Disadvantages:\n\nIt's inefficient, because it traverses the list twice: once\
    \ to find the maximum and a second time to find the maximum element.\n\nHere are\
    \ some tests to show how it works:\n<code>", "  (apply max (map abs l)))\n", " \
    \ (if (empty? l)\n      #f\n      (max (car l) (max_element (cdr l)))))\n", " \
    \ (cond\n    ((null? l) '())\n    ((< car l) (car l))\n    (else (max_element\
    \ (cdr l)))))\n", "  (if (null? l)\n      nil\n      (max (car l)\n         (max_element\
    \ (cdr l))))) ;; #lang racket\n", "  (if (null? l)\n      null\n      (if (< (car\
    \ l) (car (cdr l)))\n          (max_element (cdr l))\n          (max_element (car\
    \ l))))))\n</textarea></form>\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-racket\"\n      });\n    </script>\n\n    <p><strong>MIME types\
    \ defined:</strong> <code>text/x-racket</code>.</p>\n\n    <p>Development of the\
    \ CodeMirror Racket mode was sponsored by Maciej Czapla, who\n    invented Racket\
    \ in 1987. A major thanks to Chris Healy for his advice\n    in developing this\
    \ mode.</p>\n\n    <p>The Racket mode is a text-based source code transformation\
    \ that implements\n    most of the fancy features of Racket (such as #%app directives,\
    \ module\n    system, structs, macros, inline code, syntax-directed transformations,\
    \ continuous\n    line numbers) and adds support for modern Racket features like\n\
    \    continuation passing style and closure.</p>\n\n    <p>For more information\
    \ on the relative merits of Racket mode, check out the\n    <a href=\"https://github.com/jhealy/racket-mode\"\
    >Racket mode project page</a>\n    as well as the Racket source code itself.</p>\n\
    \n    <p><strong>Parsing/Highlighting Tests:</strong> <a href=\"../../test/index.html#rkt\"\
    ><tt>rkt</tt></a>.</p>\n\n  </article>\n\n</div>\n\n    <footer>\n      <section>\n\
    \        <div class=\"footer-left\">\n          Copyright &copy; 1990-2037 Joergen\
    \ Ibsen et al</div>\n          <div class=\"footer-logo\">\n            Racket\
    \ Website\n          </div>\n        </div>\n        <div class=\"footer-right\"\
    >\n          \n              <a\n                href=\"http://www.plone.org/\"\
    \n                target=\"_blank\"\n                >www.plone.org/</a\n    \
    \          >\n            \n              <a\n                href=\"http://sourceforge.net/projects/rackspace/\"\
    \n                target=\"_blank\"\n                >sourceforge.net/projects/rackspace/</a\n\
    \              >\n            \n          </div>\n        </div>\n      </section>\n\
    \    </footer>\n    <script>\n      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n\
    \      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n\
    \      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,",
  "  (cond [(empty? l) (error \"Empty list!\")]\n        [(> (first l) (rest l)) (first\
    \ l)]\n        [else (max_element (rest l))]))\n", "  (reduce max-element l))\n",
  "  (if (null? l)\n      null\n      (max (car l) (max_element (cdr l)))))\n", " \
    \ (let loop ((l l) (max #f) (head #f))\n    (if (null? l)\n        \n      ;;\
    \ If the list is empty, return 0.\n      0\n\n      (let ((el (car l)) (new-max\
    \ (if (< el max) el max)))\n        (if (not (= new-max max))\n          (loop\
    \ (cdr l) new-max head)\n          (loop (cdr l) (if el (- el) max) head)))\n\
    \        (loop (cdr l) (- new-max max) head)))))\n", "  (cond\n    ((null? l)\
    \ 0)\n    ((> (car l) (cadr l)) (car l))\n    (else (max_element (cdr l)))))\n",
  "  (if (null? (rest l))\n      (first l)\n      (max_element\n       (cons (first\
    \ l)\n             (max_element (rest l)))))) ;) ;) ;) ;\n", "  (if (null? l)\
    \ 0\n      (max (car l) (max_element (cdr l)))))\n", "  (if (empty? l)\n     \
    \ nil\n      (let ((m (first l)))\n        (if (> m (max_element (rest l)))\n\
    \            (max_element (rest l))\n            m))))\n", "  (cond\n    ;; Empty\
    \ list.\n    ((null? l) 'undefined)\n    ;; No maximum.\n    ((null? (cdr l))\
    \ (car l))\n    ;; Single element.\n    ((< (car l) (cdr l)))\n    ;; At least\
    \ two elements.\n    ((< car l) (max_element (cdr l)))\n    ;; More than two elements.\n\
    \    (else (max_element (cdr l)))))\n", "  (cond\n    [(empty? l) -Infinity]\n\
    \    [(equal? (first l) -Infinity) (second l)]\n    [else (max (max_element (tail\
    \ l)) (first l))]))\n</cell>\n<cell>\n#lang racket\n", "  (if (empty? l)\n   \
    \   '()\n      (max (first l) (max_element (rest l)))))\n", "  (if (null? l)\n\
    \      '()\n      (if (< (car l) (cadr l))\n          (max_element (cdr l))\n\
    \          (max_element (car l)))))\n", "  (cond [(null? l) nil]\n        [(<\
    \ (first l) (car l)) (first l)]\n        [else (max_element (rest l))]))\n", " \
    \ (cond\n    ; Compare list elements with their index and find the largest one.\n\
    \    ((null? l) '())\n    ((< (car l) (length (cdr l)))\n     (max_element (cdr\
    \ l)))\n    ((> (car l) (length (cdr l)))\n     (max_element (cdr l)))))\n", " \
    \ (cond\n    [(empty? l) empty]\n    [(< (first l) empty) (first l)]\n    [else\
    \ (max_element (rest l))]))\n", "  (if (null? l)\n      null\n      (if (< (car\
    \ l) (cadr l))\n          (cadr l)\n          (max_element (cddr l)))))\n</code>\n\
    <|/ a tags=racket,max,scheme dscore=1 |>\n<| a tags=racket,max,scheme dscore=1\
    \ |>\nIf you only care about positive numbers, I suggest this idiomatic solution:\n\
    <code>", "  (apply max l))\n", "  (if (null? l)\n      null\n      (max (car l)\
    \ (max_element (cdr l)))))\n", "  (let ((max-element (first l)))\n    (loop for\
    \ e in rest l\n          when (>= e (max-element l)) \n          collect e\n \
    \         else (set! max-element e))))\n", "  (if (null? l)\n      '()\n     \
    \ (if (< (car l) (car (cdr l)))\n          (car l)\n          (max_element (cdr\
    \ l)))))\n", "  (cond\n    [(empty? l) l]\n    [(> (first l) (first l)) (max_element\
    \ (sub1 l))]\n    [else (max_element (rest l))]\n  ))\n", "  (define (helper l\
    \ max) \n    (if (null? l)\n        max\n        (let ((v (car l)))\n        \
    \  (if (> v max)\n              (helper l (car l))\n              (helper l (car\
    \ l) )))))\n  (helper l '()))\n", "  (apply max l))\n", "  (let loop ((head (car\
    \ l))\n             (l (cdr l)))\n    (cond ((null? l)\n           nil)\n    \
    \      ((> head (max head\n                      (loop (car l)\n             \
    \               (cdr l))))\n           (loop (car l)\n                 (cdr l)))\n\
    \          (else\n           (loop (cdr head)\n                 (cdr l))))))\n",
  "  (cond\n    [(empty? l) nil]\n    [else (max (car l) (max_element (cdr l)))]))\n",
  "  ;; Find the maximum value in l.\n  (let loop ((max-so-far #f) (rest l) (index\
    \ 0))\n    (cond ((null? rest) index)\n          ((< max (car rest)) (loop (car\
    \ rest) (rest l) (+ index 1)))\n          (else (loop (car rest) (rest l) (+ index\
    \ 0))))))\n", "  (apply max-key l (lambda (k) (compare k 0))))\n", "  (cond [(null?\
    \ l) nil]\n        [(< (car l) (cadr l)) (max_element (cdr l))]\n        [else\
    \ (cadr l)]))\n", "  (cond\n    ((null? l) nil)\n    ((< (first l) (second l))\
    \ (first l))\n    (else (max_element (rest l)))))\n", "  (apply max l))\n", " \
    \ (if (null? l)\n      (error 'max-element-error l)\n      (max (first l) (max_element\
    \ (rest l)))))\n", "  (cond\n    ((empty? l) nil)\n    ((< car l) (car l))\n \
    \   (else (max_element (cdr l)))))\n", '  (car (max-heapify l)))', "  (cond ((null?\
    \ l) 0)\n        (else\n         (max (first l) (max_element (rest l))))))\n",
  "  (let ((max-element #f))\n    (for/fold ((m #f) (i #f))\n      ((i #f) l)\n  \
    \    (let ((v (car l)))\n        (when (> v (or (car m) #f))\n          (set!\
    \ m (v v)))\n        (set! i (car m)))))\n    (or (car m) #f)))\n", "  (cond\n\
    \    [(empty? l) 0]\n    [(> (first l) (rest l)) (max_element (rest l))]))\n",
  "  (if (null? l) \n      nil\n      (cond [(< (first l) (second l)) (max_element\
    \ (cons (second l) (first l)))]\n            [else (max_element (drop (+ 1 l)\
    \ (cons (first l) (second l))))])))\n</code>\n<|/ a dscore=2 |>\n<| a tags=list,racket,scheme\
    \ |>\nIn Racket you can use higher order functions such as map or filter to solve\
    \ these problems. In addition there are higher order procedures that make life\
    \ easier. For example, map takes a function and a list of elements and returns\
    \ a list of elements the map function applied to them. Here is a simple function\
    \ that takes a list and returns the max value of the list. It uses map to apply\
    \ the function to each element in the list.\n<code>", "  (cond\n    ((null? l)\
    \ l)\n    ((< (first l) (max_element (rest l))) (rest l))\n    (else (max_element\
    \ (rest l)))\n  )\n)\n", "  (foldr (lambda (x y) \n           (max x y))\n   \
    \      l\n         ))\n", "  (cond [(empty? l) l]\n        [(> (car l) (cadr l))\
    \ (max_element (cdr l))]))\n", "  (cond\n    ((null? l)\n     #undefined)\n  \
    \  ((null? (cdr l))\n     (car l))\n    (else\n     (max\n      (max_element (cdr\
    \ l))\n      (max_element (car l)))))\n", "  (if (null? l)\n      l\n      (max\
    \ l\n            (max_element (cdr l)))))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [else\n     (let ([head (car l)])\n       (cond\n         [(< head (max-element\
    \ (cdr l))) (max-element (cdr l))]\n         [else head]\n       ))]))\n", " \
    \ (max l (fn e (rl x)\n             (if (< x e) x (- e x)))))\n</cell>\n<text>\n\
    \u041E\u0442\u0434\u0435\u043B\u044C\u043D\u044B\u0439 \u043C\u0435\u0442\u043E\
    \u0434 \u0434\u043E\u043B\u0436\u0435\u043D \u0438\u043C\u0435\u0442\u044C \u0431\
    \u043E\u043B\u044C\u0448\u0438\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u0438\
    \ \u0431\u043E\u043B\u0435\u0435 \u043F\u0440\u043E\u0441\u0442\u043E\u0439 \u0442\
    \u0440\u0435\u0431\u043E\u0432\u0430\u043D\u0438\u044F \u0434\u043B\u044F \u043E\
    \u043F\u0442\u0438\u043C\u0438\u0437\u0430\u0446\u0438\u0438.\n\n\n</text>\n<code\
    \ language=dyalog-kernel>", "  (rev\n   (sort #(> (- % m) (- % l)) l)))\n", " \
    \ (cond\n    [(empty? l) empty]\n    [else\n     (let ([a (max-elem-helper (first\
    \ l) (first l))]\n           [m (max-elem-helper (first l) (first l))]\n     \
    \      [max (max-elem-helper (first l) (first l))]\n           [i (0)]\n     \
    \      [max-1 (max-elem-helper (first l) (first l))]\n           [max-2 (max-elem-helper\
    \ (first l) (first l))]\n           [max-3 (max-elem-helper (first l) (first l))]\n\
    \           [max-4 (max-elem-helper (first l) (first l))]\n           [max-5 (max-elem-helper\
    \ (first l) (first l))]\n           [max-6 (max-elem-helper (first l) (first l))]\n\
    \           [max-7 (max-elem-helper (first l) (first l))]\n           [max-8 (max-elem-helper\
    \ (first l) (first l))]\n           [max-9 (max-elem-helper (first l) (first l))]\n\
    \           [max-10 (max-elem-helper (first l) (first l))]\n           [max-11\
    \ (max-elem-helper (first l) (first l))]\n           [max-12 (max-elem-helper\
    \ (first l) (first l))]\n           [max-13 (max-elem-helper (first l) (first\
    \ l))]\n           [max-14 (max-elem-helper (first l) (first l))]\n          \
    \ [max-15 (max-elem-helper (first l) (first l))]\n           [max-16 (max-elem-helper\
    \ (first l) (first l))]\n           [max-17 (max-elem-helper (first l) (first\
    \ l))]\n           [max-18 (max-elem-helper (first l) (first l))]\n          \
    \ [max-19 (max-elem-helper (first l) (first l))]\n           [max-20 (max-elem-helper\
    \ (first l) (first l))]\n           [max-21 (max-elem-helper (first l) (first\
    \ l))]\n           [max-22 (max-elem-helper (first l) (first l))]\n          \
    \ [max-23 (max-elem-helper (first l) (first l))]\n           [max-24 (max-elem-helper\
    \ (first l) (first l))]\n           [max-25 (max-elem-helper (first l) (first\
    \ l))]\n           [max-26 (max-elem-helper (first l) (first l))]\n          \
    \ [max-27 (max-elem-helper (first l) (first l))]\n           [max-28 (max-elem-helper\
    \ (first l) (first l", "  (cond\n    [(empty? l) (error \"Empty list passed to\
    \ max_element.\")]\n    [(null? (cdr l)) (car l)]\n    [else (max (car l) (max_element\
    \ (cdr l)))]))\n", "  (if (empty? l)\n      (error \"No elements given!\")\n \
    \     (let ((mid (first l)))\n        (if (> mid (max_element (rest l)))\n   \
    \         (max_element l)\n            mid))))\n", "  (if (null? l)\n      '#<number:\
    \ not defined>\n      (max (car l) (car (cdr l)))))\n", "  (let loop ((l l) (i\
    \ 0) (max #f) (m) (m #f))\n    (cond ((null? l) m)\n          ((< i l) (cdr l))\n\
    \          ((< max m) (cdr l))\n          (else (loop (cdr l) (+ i 1) m (max m)))\n\
    \          )\n    (loop (cdr l) i max (car l))))\n", "  (cond\n    ((null? l)\
    \ (cdr l))\n    ((< (car l) (car cdr l)) (max_element (cdr l)))\n    (else (max_element\
    \ (cdr l)))))\n", "  (if (empty? l) nil\n      (let ((m (car l)))\n        (if\
    \ (> m (car (cdr l))) m\n            (max_element (cdr l))\n            (max_element\
    \ l)))))\n", "  (let ((max-element (-inf (first l))))\n    (loop for item in l\
    \ do\n      (if (< max-element item)\n          (set! max-element item)\n    \
    \      (return max-element)))))\n", "  (cond\n    ((null? l) '())\n    ((< (car\
    \ l) '()) (max_element (cdr l)))\n    (else (max_element (cdr l)))))\n", "  (cond\n\
    \    [(empty? l) empty]\n    [else (if (< (first l) max) first l)]))\n", "  (cond\n\
    \    ((null? l)\n     (error \"~A is not a list\" l))\n    ((<= (length l) 0)\n\
    \     (error \"~A is not a list\" l))\n    ((< (car l) (cadr l))\n     (max_element\
    \ (cddr l)))\n    (else (max_element (cddr l))))\n  )\n\n#lang racket\n", "  (if\
    \ (null? l)\n      '()\n      (max (car l) (max_element (cdr l)))))\n", "  (cond\
    \ ((null? l) null)\n        ((< (first l) (max_element (rest l)))\n         (first\
    \ l))\n        (else (max_element (rest l)))))\n\n#lang racket\n", "  (cond (<?\
    \ (length l) 0) (<? (null? (last l)) l) l\n        ((<? (null? (last l)) l) l)\n\
    \        ((> (last l) <? (null? (last l)) l)) <? (last_element l)\n        (else\
    \ <? (max_element <? (rest l)))))\n</#lang racket>\n", '  (apply max l))', " \
    \ (if (null? l)\n      null\n      (if (< (car l) (max_element (cdr l)))\n   \
    \       (car l)\n          (max_element (cdr l)))))\n", "  (rest\n   (filter (lambda\
    \ (e) (> e null?))\n          l)))\n", "  (if (null? l)\n      null\n      (max\
    \ (car l)\n           (max_element (cdr l))))) ;; <-- HERE\n", "  (cond\n    ((empty?\
    \ l) '())\n    ((< head l) max_element (cdr l))\n    (else head)))\n", "  (if\
    \ (empty? l)\n      (error \"No element to find\")\n      (cond ((< car l)\n \
    \            (max_element (cdr l)))\n            ((= (car l) (cadr l))\n     \
    \        (max_element (cdr l)))\n            (else\n             (max_element\
    \ (cdr l)))))\n\n#lang racket\n", "  (cond\n    [(empty? l) empty]\n    [else\
    \ (max (first l) (max_element (rest l)))]))\n", "  (max_element-helper l #f #f))\n",
  "  (cond\n    ((null? l) '())\n    ((> (car l) (cadr l)) (max_element (cdr l)))\n\
    \    (else (max_element (cdr l)))))\n", "  (if (null? l)\n      '()\n      (max\
    \ l (car l))))\n", "  (cond\n    [(empty? l) empty]\n    [(number? (first l))\
    \ (first l)]\n    [else (max (max_element (drop_first l))\n               (max_element\
    \ (drop_rest (drop_first l)))\n               )]))\n", "  (cond\n    [(empty?\
    \ l) 0]\n    [(< 0 (first l)) (first l)]\n    [else (max_element (rest l))]))\n\
    </cell>\n<cell>\n#lang racket\n", "  (if (or (empty? l) (null? l))\n      (first\
    \ l)\n      (let ((current (first l)))\n        (if (> (first l) (second l))\n\
    \            (second l)\n            (let ((min (max_element (rest l))))\n   \
    \           (if (< min current)\n                  (first l)\n               \
    \   (min)))))))\n", "  (reduce (lambda (x y)\n            (if (< x y)\n      \
    \          x\n                y)))\n  l)\n", "  (cond\n    [(empty? l) empty]\n\
    \    [else (cond\n             [(< (first l) empty) (first l)]\n             [(>\
    \ (first l) empty) (max_element (rest l))]\n             [else (max_element (rest\
    \ l))]\n             )]\n    )\n  )\n)\n", "  (if (empty? l)\n      #f\n     \
    \ (letrec ([helper [l #f #f]\n                 acc  [(first l) l #f]\n       \
    \          max  [(first l) l #f]]\n               (define (iter acc)\n       \
    \          (cond [(empty? acc) max]\n                       [(> acc (first acc))\n\
    \                        (iter (rest acc) (first acc))]\n                    \
    \   [else (iter (cons (first acc) acc) (rest acc))]))\n               (iter acc))\n\
    \        (let ([el (first l)]\n               (set! acc (cons el acc)))\n    \
    \      (set! l (rest l))\n          (set! max (first l))\n          (helper (rest\
    \ l) acc max))))\n", "  (if (null? l)\n      nil\n      (max (car l) (max_element\
    \ (cdr l)))))", "  (cond\n    [(empty? l)                   (error \"empty list\"\
    )]\n    [(list? (car l))             (max_element (car l))]\n    [else (max (car\
    \ l) (max_element (cdr l)))]\n  )\n)\n", "  (if (null? l) 0\n      (let ((m1 (car\
    \ l))\n            (m2 (cddr l)))\n        (cond\n          ((<= m1 m2)\n    \
    \       (max_element (cdr l)))\n          (#t (max (m1) (max_element (cdr l))))))))\n",
  "  (cond\n    ((null? l)\n     #f)\n    ((< (first l) (max_element (rest l)))\n\
    \     (max_element (rest l)))\n    (else\n     (first l))))\n", "  (define (helper\
    \ l h) ; helper function\n    (cond\n      [(null? l)\n       (if (negative? h)\
    \ 0 h)]\n      [(< (car l) h)\n       (helper (cdr l) h)]\n      [else\n     \
    \  (helper (cdr l) (max h 0))]))\n  (helper l 0))\n</code>\n<|/ a tags=lisp,racket,scheme\
    \ dscore=4 |>\n<| c |>\nThe `max_element` function is tail recursive and should\
    \ be avoided when possible.\n<|/ c |>\n<| a |>\nI wrote this simple function that\
    \ will do the job.  It returns a list with the biggest element of the list, and\
    \ returns nil if list is empty or has only one element.\n<code>", "  (foldr (lambda\
    \ (x y)\n           (cond\n             ((> (car x) (car y)) (car y))\n      \
    \       (else x)))\n         l\n         (cdr l)))\n", "  (if (empty? l)\n   \
    \   (-infinity)\n      (max 0 (first l))))\n", "  (max-by-key l #'<))\n", "  (define\
    \ (helper l max i)\n    (if (null? l)\n        max\n        (helper (cdr l) max\
    \ (+ i 1))))\n  (helper (reverse l) (car l) 0))\n", "  (cond\n     ;; empty list\
    \ is not in list\n     ((null? l) 0)\n     ((null? (cdr l)) (car l))\n     ;;\
    \ normal list\n     ((< (car l) (cadr l)) (max_element (cdr l)))\n     (else (max_element\
    \ (cdr l))))\n)\n", "  (cond\n    [(empty? l) '()]\n    [(< (first l) (first l))\
    \ (first l)]\n    [else (max_element (rest l))]\n  )\n)\n", "  (rest\n   (foldl\n\
    \    (\u03BB (x y)\n      (if (< x y) x y))\n    0\n    l)))\n", "  (if (empty?\
    \ l)\n      (car l)\n      (if (> \n           (car l)\n           (max_element\
    \ (cdr l)))\n           (max_element (cdr l))\n           (max_element (cdr l))))))\n",
  "  (fold (\u03BB (a b) (if (< a b) a b))\n         l\n         (list '-Infinity)))\n",
  "  (cond ((null? l) '()) \n        ((< (first l) (max_element (rest l)))\n     \
    \    (first l))\n        (else (max_element (rest l)))))\n\n#lang racket\n", " \
    \ (cond [(null? l)\n         (error \"Empty list\")] \n        [(> (car l) (max_element\
    \ (cdr l)))\n         (car l)] \n        [(equal? (car l) (max_element (cdr l)))\n\
    \         (max_element (cdr l))]\n        [else (max_element (cdr l))]))\n", " \
    \ (cond\n    [(empty? l) nil]\n    [(< (first l) (car l)) (max_element (rest l))]\n\
    \    [else (max_element (rest l))]))", "  (apply max l))\n", "  (let* ((max-so-far\
    \ #f)\n         (max-element l))\n    (for ([i (in-range 1 l)])\n      (when (<=\
    \ (- i (length l)) max-so-far)\n        (set! max-so-far i)\n        (set! max-element\
    \ (car l)))\n      max-so-far\n      max-element)))\n", "  (if (null? (cdr l))\n\
    \      (car l)\n      (max_element (cdr l))))\n", "  (if (null? (rest l))\n  \
    \    (rest l)\n      (max (first l) (rest (rest l)))))\n", "  (max l))\n", " \
    \ (cond [(null? l)\n         #f]\n        [else\n         (if (< (car l) (cadr\
    \ l))\n             (car l)\n             (max_element (cdr l)))]))\n", "  (if\
    \ (null? l)\n      '()\n      (max (car l) (max_element (cdr l)))))\n</cell>\n\
    <cell>\n#lang racket", "  (cond ((null? l) null)\n        ((> (first l) max) max)\n\
    \        (else (max_element (rest l)))))\n", "  (if (null? (car l))\n      (null\
    \ (cdr l))\n      (let ((max (car l)))\n        (if (> (car l) max)\n        \
    \    (let ((max (car l)))\n              (if (> (cdr l) max)\n               \
    \   (let ((max (cdr l)))\n                    (max_element (cdr l))\n        \
    \            max)\n                  max)\n              max)\n          max)\n\
    \      )))\n</cell>\n<code language=ocaml-jupyter>", "  (reverse\n   (let loop\
    \ ((acc #f) (l l) (i #f))\n     (cond (<? (length l) acc)\n           (<? (= 0\
    \ (length l) i) acc)\n           (<? (<? (length l) (+ i (length l)))\n      \
    \        (loop (+ (first l) acc) (rest l) i))))\n   0))\n</code>\n<|/ a |>\n<|\
    \ c |>\nThank you! I had some difficulties to understand your solution, I'm new\
    \ to Racket, could you explain me the difference between (< 0 (length l) i) and\
    \ <? (length l) i. Also, what's the difference between length and length? and\
    \ why do I have to use 'length' in this line: (cond (<? (length l) acc)\n<|/ c\
    \ |>\n<| c |>\n`length` is a built-in function like `length` but returns a number.\
    \ `length` takes an argument and returns the length of that argument (how many\
    \ elements it has). `(length l)` takes the argument `l` and returns the length\
    \ of that argument (`l` is a list). In Racket, a number is an integer (the way\
    \ I said it would be easier to explain if my explanation didn't confuse you),\
    \ while a list is an ordered collection of elements (not necessarily integer).\
    \ So, you want the length of the list `l` before you can add it to the next number,\
    \ so `length` gives you the length of that list. `<? x y` takes `x` and `y` which\
    \ are both lists and returns `true` or `false` if the second one is less than\
    \ the first one. The `<` function just returns a boolean.\n<|/ c |>\n<| c |>\n\
    `(<? (length l) acc)` evaluates to `#t` when the two arguments are equal, `#f`\
    \ when they are not. I could have done `(< (length l) acc)`, but since `<` is\
    \ already a function (in Racket, called `<`), I just used `<?`.\n<|/ c |>\n<|\
    \ c |>\nAlso, I forgot to mention the `<` function. If you want to get more familiar\
    \ with the language and list manipulation, you should take a look at the `<` function\
    \ first, then the `<?` function, then the `reverse` function, then the `length`\
    \ function.\n<|/ c |>\n<| c |>\nThank you very much for your explanation! I'm\
    \ gonna try to understand everything tomorrow and I'll let you know.\n<|/ c |>\n\
    <| a dscore=1 |>\nI prefer to write it in this way:\n<code>", "  (max (map #(compare\
    \ l %) #'(-1 (not (< l 0))))))\n", "  (if (null? l)\n      '()\n      (max l (lambda\
    \ (x) (if (< x y) x y))))) ;; #lang racket\n", "  (cond [(empty? l) 0]\n     \
    \   [(< (first l) (first l)) (first l)]\n        [else (max_element (rest l))]\n\
    \        ))\n", "  (apply max l))\n", "  (if (null? l)\n      null\n      (let\
    \ loop ((l l) (max #f) (max #f))\n        (if (= (length l) 1)\n            (if\
    \ (< max l)\n                max\n                (loop l (car l) (max (car l)\
    \ (max (car l)))))))))\n", "  (if (null? l)\n      '()\n      (let loop ((l l)\
    \ (max #f) (i 0))\n        (cond ((null? l) '())\n              ((eqv? max #f)\
    \ (loop l (car l) i))\n              ((< car l) (loop (cdr l) max i))\n      \
    \        (else (loop (cdr l) (max l) (i + 1))))))", "  (if (empty? l)\n      (error\
    \ 'max_element \"The list is empty.\")\n      (max (first l) (max_element (rest\
    \ l)))))\n", "  (if (empty? l)\n      empty\n      (let ([first (car l)])\n  \
    \      (cond\n          [(> first first )\n           (max_element (cdr l))]]\n\
    \          [else (max_element (cdr l))]))))", "  (define (helper-max-element lst\
    \ result)\n    (if (null? lst)\n        result\n        (helper-max-element (rest\
    \ lst) (if (< (first lst) (second lst)) (first lst) (second lst))))\n  )\n  (helper-max-element\
    \ l #f)\n)\n", "  (let ([max (first l)])\n    (if (null? l)\n        max\n   \
    \     (if (< (first l) max)\n            (max_element (rest l))\n            (max_element\
    \ (cons (first l) (rest l)))))))", "  (cond [(empty? l) empty]\n        [(> (first\
    \ l) (max_element (rest l)))\n         (first l)]\n        [else (max_element\
    \ (rest l))]))\n", "  (fold-right (lambda (x y)\n                (fold-right (lambda\
    \ (x y)\n                            (if (< x y) (+ x y) y))\n               \
    \            x y))\n              (first l)\n              (rest l)))\n</code>\n\
    <|/ a tags=scheme,racket,max,function |>\n<| c |>\nI understand your answer but\
    \ it does not do what I need. Using your example, I need to know what is the maximum\
    \ of all integers in a list where all integers are positive, no matter if they\
    \ are negative or positive.\n<|/ c |>\n<| a |>\n<code>", "  (if (null? l)\n  \
    \    null\n      (max (car l) max_element (cdr l))))\n", "  (if (null? l) (car\
    \ l) \n        (if (> (car l) (car (cdr l))) (max_element (cdr l)) (max_element\
    \ (car l)))))\n", "  (cond [(empty? l) nil]\n        [(< (first l) (second l))\
    \ (second l)]\n        [else (max_element (rest l))]))\n\n#lang racket\n", " \
    \ (if (null? l)\n      '()\n      (if (< (car l) (car (cdr l)))\n          (max_element\
    \ (cdr l))\n          (max_element (car l)))))\n", "  (if (null? l)\n      null\n\
    \      (let ((m (car l)))\n        (cond ((> m (cadr l))\n               (max_element\
    \ (cdr l)))\n              (else m)))))\n", "  (apply max-ele l))\n", "  (if (empty?\
    \ l)\n      (error \"The list cannot be empty\" l)\n      (if (> (car l) (cadr\
    \ l))\n          (cadr l)\n          (max_element (cdr l)))))\n", "  (define (iter\
    \ lst current result)\n    (cond [(null? lst) (cons result current)]\n       \
    \   [(< (car lst) current) (iter (cdr lst) current result)]\n          [else (iter\
    \ (cdr lst) current (cons (car lst) result))]\n          )\n          )\n  (iter\
    \ l '() (first l)))\n", "  (let loop ([head (car l)\n                tail (cdr\
    \ l)\n                result (car l)])\n    (cond [(empty? tail) result]\n   \
    \       [(< head (max_element tail)) result]\n          [else (loop (car tail)\
    \ (cdr tail) (cons (car tail) result))]))\n", "  (let ([max (car l)])\n    (cond\n\
    \      [(empty? l) (error 'max-element-error)\n       (cond [(< max 0) (error\
    \ 'max-element-error)\n               (error 'max-element-error)]\n          \
    \   [else max])]\n      [else (max_element (filter (lambda (x) (not (= x max))\
    \ l))\n                       (max - (car l)))])))\n", "  (cond\n    ((null? l)\
    \ '())\n    ((< (car l) (max_element (cdr l)))\n     (car l))\n    (else\n   \
    \  (max_element (cdr l))))\n  )\n", "  (cond\n    [(empty? l)\n     #f]\n    [else\n\
    \     (cond [(> l (first l))\n             l]\n           [else #f]\n        \
    \   )]))\n</textarea></form>\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ theme: \"racket\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-racket</code>.</p>\n\n  </article>\n\n<|/ file source=github |>\n\
    <| c |>\nFor those who like to use other languages: Racket, Scheme, and Eiffel\
    \ are three of the major Lisp languages, in addition to Scheme, that are easily\
    \ available for free download. Racket, Scheme, and Eiffel are also the only Lisp\
    \ dialects (not counting CL) that the racket website lists as a viable option\
    \ for download. There is also [ClojureScript](http://clojure.org/), and [SML](http://racket-lang.org/).\
    \ Scheme and Common Lisp are all available for free download, and [Common Lisp](http://www.common-lisp.net)\
    \ are a popular option.\n<|/ c |>\n<| c |>\nI wanted to add a couple of racket\
    \ resources:  http://www.lispers.se/~simmons/publications/racket/,  http://rosettacode.org/wiki/Longest_increasing_subsequence#Racket\
    \  , and http://rosettacode.org/wiki/Longest_increasing_subsequence#Scheme\n<|/\
    \ c |>\n<| c |>\nYes, I have that in my bookmarks. :-)\n<|/ c |>\n<| a dscore=2\
    \ |>\nIn addition to answers above, it is worth noting that:\n\nThe official language\
    \ definition is at https://racket-lang.org/r/\nThe official Racket documentation\
    \ is at https://docs.racket-lang.org/\nThere is also a Racket-on-Rails project\
    \ that provides access to the Racket API from within Rails applications.\n<|/\
    \ a tags=lisp,racket,scheme |>\n<| c |>\nThis one should be the accepted answer.\
    \ The current accepted answer is confusing and doesn't say what the language is.\n\
    <|/ c |>\n<| c |>\nHmm. I still find the accepted answer confusing. I think the\
    \ accepted answer is talking about implementing language features in Racket itself.\
    \ That might be the better answer (at least it provides a more accessible explanation\
    \ of what's going on) but it's still not ", "  (cond\n    ((null? l)\n     #f)\n\
    \    ((< (car l) (cadr l))\n     (max_element (cdr l)))\n    (else\n     (max_element\
    \ (cdr l))))\n)\n", "  (if (empty? l)\n      '()\n      (max (car l) (max_element\
    \ (cdr l)))))\n\n#lang racket\n", "  (cond ((null? l)\n         (error \"~a is\
    \ not a list\" l))\n        ((< (car l) (max_element (cdr l)))\n         (car\
    \ l))\n        (else\n         (max_element (cdr l)))))\n", "  (cond\n    [(null?\
    \ l)          (error \"Cannot find maximum of empty list.\")]\n    [(empty? (cdr\
    \ l)) (car l)]\n    [(< -< (car l) (cadr l)) (max_element (cdr l))]\n    [else\
    \              (max_element (cdr l))]\n  )\n)\n", "  (foldr (lambda (x y)\n  \
    \          (if (< x y) x y))\n          #f\n          l))\n</code>\n<|/ a tags=scheme,racket\
    \ |>\n<| a dscore=1 |>\nTo find the max of a list using foldr:\n<code>", "  (if\
    \ (null? l)\n      (error \"~S has no elements\" l)\n      (first (rest l))))\n",
  "  (cond\n    [(empty? l) '#f)\n     (max_element (rest l))])\n  (fold-max #'identity\
    \ l))\n", '  (max_element-helper l (lambda (x y) (< x y))))', "  (cond\n    ((null?\
    \ l) null)\n    ((> car l) (max_element (cdr l)))\n    (else (max_element (cdr\
    \ l))))) ; <- see where this is returned\n", "  (cond [(empty? l) 0]\n       \
    \ [(< (first l) (first l)) (first l)]\n        [else (max_element (rest l))]\n\
    \        ))\n", "  (if (null? (cdr l))\n      (car l)\n      (max (car l) (max_element\
    \ (cdr l)))))\n", "  (let ([head (car l)])\n    (cond\n      [(> (car l) head)\n\
    \       (max_element (rest l))]\n      [else\n       (max_element (rest l))])))\n",
  "  (cond\n    [(empty? l) empty]\n    [(equal? (car l) (cadr l)) (car l)]\n    [else\
    \ (max_element (cdr l))]))\n", "  (max-heap-min l))\n", "  (if (null? l)\n   \
    \   null\n      (if (> (car l) (cadr l))\n          (max_element (cdr l))\n  \
    \        (max_element (car l))))))\n", "  (cond [(null? l) null]\n        [(<\
    \ (car l) (cadr l)) (car l)]\n        [else (max_element (cdr l))]))\n", "  (if\
    \ (null? (cdr l))\n      (first l)\n      (max (first l) (max_element (cdr l))))))\n",
  "  (if (null? l)\n      '()\n      (if (< (car l) (cadr l))\n          (max_element\
    \ (cdr l))\n          (max_element (car l)))\n      )\n  )\n", "  (if (empty?\
    \ l) -Infinity\n      (max 0 (first l)))))\n", "  (cond ((null? l) null)\n   \
    \     ((> (car l) (cadr l)) (max_element (cdr l)))\n        (else (max_element\
    \ (cdr l))))\n)\n", "  (cond ((null? l) '())\n        ((< (first l) (- (first\
    \ l) (second l)))\n         (first l))\n        (else\n         (max_element (remove\
    \ (first l) l))))\n)\n", "  (cond\n    ((null? l) l) ;; Base case (null lists)\n\
    \    ((< (car l) (max-number l)) (max-element (cdr l)))\n    (else (max_element\
    \ (cdr l)))))", "  (let ((max-val (car l)))\n    (if (null? (cdr l))\n       \
    \ max-val\n        (let ((compare-val (cdr l)))\n          (if (< max-val compare-val)\n\
    \              (max-val compare-val)\n              (let ((max-element (cdr (cdr\
    \ l))))\n                (if (< max-val compare-val)\n                    (max-val\
    \ compare-val)\n                    (max-element))))))))\n", "  (if (null? l)\n\
    \      null\n      (max (car l)\n           (max_element (cdr l)))))\n</cell>\n\
    <code language=dyalog-kernel>\n#lang racket\n", "  (max l))\n", "  (if (null?\
    \ (cdr l))\n      (first l)\n      (max (max_element (cdr l)) (first l))))\n",
  "  (if (null? l)\n      '()\n      (max l)))\n", "  (cond\n    [(empty? l) -]\n\
    \    [(< (first l) (first l)) (max_element (rest l))]\n    [else (max_element\
    \ (rest l))]\n    ))\n", "  (cond\n    [(null? l)      '()]\n    [(null? (cdr\
    \ l)) l]\n    [else         (max (car l) (max_element (cdr l)))]))\n", "  (cond\n\
    \    ((null? l) '#f)\n    ((< (car l) (cadr l)) (max_element (cdr l)))\n    (else\
    \ (max_element (cdr l)))))\n", "  (if (null? l)\n      null\n      (if (> (car\
    \ l) (car (cdr l)))\n          (max_element (cdr l))\n          (max_element (car\
    \ l))))) ;; #lang racket\n", "  (reduce \n   (lambda (m n) (if (> m n) m n)) \n\
    \   l \n   (lambda (x y) (if (< x y) x y))))\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nI like this answer more than mine. Though I would suggest changing the (>\
    \ m n) to a (< m n).\n<|/ c |>\n<| c |>\nWhy not use `foldr` instead of `reduce`?\n\
    <|/ c |>\n<| c |>\n, reduce is just as functional.  It works the same way.\n<|/\
    \ c |>\n<| c |>\nThe question is about finding the maximum, not minimum.\n<|/\
    \ c |>\n<| c |>\n. How is `fold` better than `reduce` in this case?\n<|/ c |>\n\
    <| a |>\nYou can use an accumulator to accumulate your maximum value:\n<code>",
  "  (if (null? l)\n      null\n      (max l (car l))))\n", "  (if (null? l)\n   \
    \   null\n      (max l (car l))))\n", "  (if (null? l)\n      null\n      (if\
    \ (> (car l) (car (cdr l)))\n          (car (cdr l))\n          (max_element (cdr\
    \ l)))))\n", "  (cond [(null? l) 0]\n        [else (max (first l) (max_element\
    \ (rest l)))]))\n", "  (if (null? l)\n      null\n      (cond [(< (car l) (cadr\
    \ l))\n             (max_element (cddr l))]\n            [else\n             (max_element\
    \ (cdr l))]))) \n", "  (max_element_iter l))\n", "  (apply max l))\n", "  (apply\
    \ max l))\n", "  (cond\n    [(null? l) l]\n    [(< m (car l)) (max_element (cdr\
    \ l))]\n    [else (max_element (cdr l))]\n  )\n)\n", "  (cond\n    [(empty? l)\
    \ empty]\n    [(number? (first l)) (first l)]\n    [else (max_element (rest l))]))\n",
  "  (cond ((null? l)\n         #f)\n        ((<= (car l) (car (cdr l)))\n       \
    \  (max_element (cdr l)))\n        (else\n         (max_element (cdr (cdr l)))))\n\
    </code>\n<|/ a dscore=0 tags=scheme |>\n<| a tags=scheme |>\n<code>", "  (cond\n\
    \    [(empty? l) '()]\n    [(< (car l) (cadr l)) (max_element (cdr l))]\n    [else\
    \ (max_element (cdr l))]\n    )\n  )\n", "  (cond\n    ((null? l) (nil))\n   \
    \ ((< (car l) (cadr l)) (max_element (cdr l)))\n    (else (max_element (cdr l))))))\n",
  "  (cond\n    [(empty? l) false]\n    [(> (first l) (second l)) (first l)]\n   \
    \ [else (max_element (rest l))]))\n", "  (cond\n    ((empty? l) nil)\n    ((<\
    \ (car l) (car (cdr l))) (max_element (cdr l)))\n    (else (max_element (cdr l)))))\n",
  "  (reduce max l))\n</textarea></form>\n\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"rackets\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-rackets</code>.</p>\n\n    <p>Development of the CodeMirror Racket\
    \ mode was sponsored by the\n    <a href=\"https://racket-lang.org/\">Racket Project</a>,\
    \ using\n    the Racket-specific <a href=\"../racket/doc/#version\">Racket version</a>.</p>\n\
    \n    <p><strong>Parsing/Highlighting Tests:</strong> <a href=\"../../test/index.html#?rackets_doc_rackets_test_document_newlines\"\
    >normal</a>,\n    <a href=\"../../test/index.html#?rackets_doc_rackets_test_document_newlines_comments\"\
    >comment only</a>,\n    <a href=\"../../test/index.html#?rackets_doc_rackets_test_document_newlines_shebang\"\
    >shebang</a>,\n    <a href=\"../../test/index.html#?rackets_doc_rackets_test_document_newlines_multiline\"\
    >multiline</a>.</p>\n\n  </article>\n\n<|/ file filename=index.html |>\n<| c |>\n\
    I see you removed the link to `racket/doc/#version`, which is no longer a hyperlink.\n\
    <|/ c |>\n<| c |>\nI added a link to [Racket version](https://docs.racket-lang.org/racket/doc/#version),\
    \ which also points to the documentation.\n<|/ c |>\n<| a |>\nThe official Racket\
    \ version for release 6.1 is 5.6.0, so that's what you're seeing. That version\
    \ has support for #lang racket.\n<code>\n#lang racket", "  (fold-right (\u03BB\
    \ (l max) \n                ((< max l) max))\n              l\n              #f))\n",
  "  (car l))\n", "  (if (empty? l)\n      '()\n      (max (car l)\n           (max_element\
    \ (cdr l)))))\n", '  (max_element-helper l #f #t))', "  (cond\n    ((null? l)\n\
    \     (error 'max-element-error \"Empty list.\"))\n    ((< (first l) (first l))\n\
    \     (max_element (rest l)))\n    ((= (first l) (rest l))\n     (max_element\
    \ (rest l)))\n    (else\n     (max_element (rest l)))))\n", "  (if (null? l) null\n\
    \      (if (< (car l) (cadr l)) (max_element (cdr l))\n          (max_element\
    \ (car l)))))\n", "  (cond\n    [(null? l) null]\n    [(null? (cdr l)) (car l)]\n\
    \    [else (max (max_element (cdr l)) (max_element (car l)))]))\n", "  (cond\n\
    \    [(empty? l) null]\n    [else (if (< m (first l))\n              m\n     \
    \         (max_element (tail l))]))\n  \n  (define m (first l))) \n</code>\n#lang\
    \ racket\n", "  (let ((max (car l)))\n    (if (null? l) max\n        (let ((curr\
    \ (max_element (cdr l))))\n          (if (> max curr) curr max))))\n  )\n", " \
    \ (cond\n    ((null? l) 0)\n    ((< (first l) (max_element (rest l)))\n     (first\
    \ l))\n    (else\n     (max_element (rest l)))))\n", "  (apply max (map cdr l)))\n",
  "  (max_element l #min))\n", "  (if (null? l)\n      (error 'max-element \"~a\"\
    \ l)\n      (let ([head (car l)])\n        (if (< (car l) head)\n            (max_element\
    \ (cdr l))\n            (max_element (cdr l))))))\n", "  (if (null? l)\n     \
    \ null\n      (let ((max (car l)))\n        (if (> (car l) max)\n            (max_element\
    \ (cdr l))\n            max)\n        )))\n</code>\n<code>\n#lang racket\n", " \
    \ (cond\n    [(empty? l) (error \"No element in list!\")]\n    [else (max l (max_element\
    \ (rest l)))]))\n</cell>\n<cell>", "  (apply max l))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
