name: HumanEval_31_is_prime
language: rkt
prompt: "#lang racket\n\n;; Return true if a given number is prime, and false otherwise.\n\
  ;; >>> is_prime(6)\n;; False\n;; >>> is_prime(101)\n;; True\n;; >>> is_prime(11)\n\
  ;; True\n;; >>> is_prime(13441)\n;; True\n;; >>> is_prime(61)\n;; True\n;; >>> is_prime(4)\n\
  ;; False\n;; >>> is_prime(1)\n;; False\n(define (is_prime n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n\
  \    (check-equal? (candidate 6) #f)\n    (check-equal? (candidate 101) #t)\n  \
  \  (check-equal? (candidate 11) #t)\n    (check-equal? (candidate 13441) #t)\n \
  \   (check-equal? (candidate 61) #t)\n    (check-equal? (candidate 4) #f)\n    (check-equal?\
  \ (candidate 1) #f)\n    (check-equal? (candidate 5) #t)\n    (check-equal? (candidate\
  \ 11) #t)\n    (check-equal? (candidate 17) #t)\n    (check-equal? (candidate 85)\
  \ #f)\n    (check-equal? (candidate 77) #f)\n    (check-equal? (candidate 255379)\
  \ #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    ((= n 2) #t)\n    ((= n 3) #t)\n    ((= n 4) #f)\n   \
    \ ((= n 5) #t)\n    ((= n 7) #t)\n    ((= n 8) #f)\n    ((= n 9) #f)\n    ((<\
    \ n 101) #f)))\n", "  (cond ((= n 1) #t)\n        ((even? n) (is_prime (/ n 2)))\n\
    \        (else (= (% n 2) 0) (is_prime (/ n 2))))))\n", "  (define (test n)\n\
    \    (cond [(= n 1) #t]\n          [(= n 2) #f]\n          [(= (floor (/ n 2))\
    \ #t) test (- n 2)]\n          [else (test (- n 1))]))\n  (test (- n 1)))", " \
    \ (cond (; n < 2\n         #t\n         (cond ((= n 1) #t)\n               ((even?\
    \ (modulo n 2)) #f)\n               (else (is_prime (- n 1))))))\n  (cond\n  \
    \  ((= n 2) #t)\n    ((even? (modulo n 2)) #f)\n    (else (is_prime (- n 1)))))\n",
  "  (if (= n 1)\n      (= n 2)\n      (or (is_prime (quotient n 2)) (is_prime (quotient\
    \ n 3)))))\n", "  (if (= n 1)\n      #t\n      (if (<= (sqrt n) 3)\n         \
    \ #t\n          (if (= (modulo n 3) 0)\n              #f\n              (is_prime\
    \ (/ n 3))))))\n", "  (cond [(= n 2) #f]\n        [else (= (expt n 2) 1)\n   \
    \           (is_prime (/ n 2))]\n        ))\n", "  (cond ((= n 1) false)\n   \
    \     ((> n 1) (is_prime (- n 1)))))\n", "  (if (<= n 2)\n      #t\n      (<=\
    \ (expt n 3) (expt n 2))))\n", "  (cond\n    ((= n 1) #t)\n    ((odd? n) #f)\n\
    \    ((even? n) #t)\n    (else (and (is_prime (/ n 2))\n              (is_prime\
    \ (- (* n 2) 1))))))", "  (cond [(= n 1) #f]\n        [else (and (not (= n 2))\n\
    \                   (not (= (mod n 3) 0)))]))\n", "  (= n 1)\n  (or (= (mod n\
    \ 2) 0)\n      (= (floor (/ n 2)) 0))\n  (or (= (ceiling (/ n 2)) 0)\n      (=\
    \ (floor n) 1)))\n  ", "  (cond ((= n 2) #t)\n        ((= n 1) #f)\n        (else\
    \ (or (is_prime (+ n 1)) #f))))\n", "  (cond ((= n 2) #t)\n        ((even? n)\
    \ #t)\n        (else (or (is_prime (/ n 2)) (is_prime (* 3 n 2))))))\n", "  (cond\
    \ ((= n 2) #t)\n        ((even? n) #f)\n        (else\n         (let ((i 2))\n\
    \           (cond ((= n i) #t)\n                 ((odd? n) (return #t))\n    \
    \             (else\n                  (set! i (+ i 1))\n                  (is_prime\
    \ (- n i))))))))\n", "  (cond [(= n 1) false]\n        [(= (mod n 2) 0) true]\n\
    \        [else (is_prime (sub1 n))]))\n", "  (= (modulo n primes)\n      1))\n\
    \  ", "  (cond ( (= n 1)                #f)\n         ((= (expt n 2)         \
    \    #f)\n          (is_prime (/ n 2))       #f)\n         (else             \
    \         #t)))\n", '  (= (modulo n 2) 1))', "  (define (divisible n d)\n    (and\
    \ (not (= n d)) (= (mod n d) 0)))\n  (<= n 2)\n  (or (> n (* 2 d))\n      (for/or\
    \ ([i 2]\n                 [j n])\n        (and (divisible i (- j 1))\n      \
    \       (not (divisible j d))))))", "  (< (* n 2) 6))\n", "  (if (<= n 2)\n  \
    \    false\n      (prime? (- n 1))))\n", "  (let ([divisor (- 2 (expt n 2))])\n\
    \    (and (= n 1)\n         (= n 2)\n         (= n 3))\n    (= (modulo n divisor)\
    \ 0)\n    (= divisor 0)))\n", '  (and (= n 1) (= (modulo n n) 0) (= (modulo (+
    1 n) n) 0) (= (modulo (- n 1) n) 0)))', "  (cond ((= n 1) #t)\n        ((= (mod\
    \ n 2) 0) #f)\n        (else (or (is_prime (- n 1)) #t))))\n", "  (cond\n    [(=\
    \ n 1) #t]\n    [(= n 2) #t]\n    [else (or (is_prime (- n 1)) #f)]))\n", "  (cond\
    \ [(= n 2) #t]\n        [(even? n) #f]\n        [else (odd? n) (is_prime (add1\
    \ n))]\n  ))\n", "  (<= n 1)\n  (cond [(= n 2) #t]\n        [else (even? (modulo\
    \ n 2))]\n        [else #f]))\n", "  (cond [(= n 1) #t]\n        [(= n 2) #t]\n\
    \        [else (and\n               (not (is_prime (- n 1)))\n               (is_prime\
    \ (- n 2)))]))\n", "  (cond [(= n 1) false]\n        [(primes? n) true]\n    \
    \    [else (is_prime (- n 1))]))\n", "  (if (< n 2)\n      false\n      (<= (sqrt\
    \ n) (* n n))\n    )\n)\n", "  (cond (zero? n)\n         (false)\n         (else\
    \ (and (<= n 5)\n                    (not (zero? (remainder n 3))))))) ;; #lang\
    \ racket\n", "  (if (= n 1)\n      #f\n      (or (is_prime (- n (floor n)))\n\
    \          (is_prime (- n (/ n 2))))))\n", "  (prime-test n #t))\n", "  (and (=\
    \ n 1) (= (modulo n n) 0))\n)\n", "  (cond ((= n 2) #t)\n        ((or (odd? (car\
    \ n)) (= (modulo n 2) 0))\n         (is_prime (cdr n)))\n        (else #f)))\n",
  "  (not (null? lst)\n       (or (= n lst)\n           (> (car lst) n))\n       (=\
    \ (modulo n lst)\n          0)))\n", "  (cond [(= n 2) true]\n        [else (=\
    \ (mod n 3) 0) false]))\n", "  (prime? (- n 1)))\n", '  (prime? (modulo n primes)))',
  "  (let ([number (int n)])\n    (cond\n      [(= number 1)\n       #t]\n      [else\n\
    \       (let ([factor (number-factors number)])\n         (cond\n           [(null?\
    \ factor)\n            (= n 2)\n            (#t #t)]\n           [(= 1 (length\
    \ factor))\n            (#t #t)]\n           [else\n            (is-prime-recursion\
    \ (- 1 (length factor) number factor))]))]))))\n", "  (and (= (modulo n prime)\
    \ 0)\n       (not (= n 1))))\n", "  (and (= n 1) (<= n 2)))\n", "  (< n (expt\
    \ 2 n)))\n", "  (define (is_prime.test n limit)\n    (if (< limit 2)\n       \
    \ #t\n        (let ((b (remainder n limit)))\n          (cond ((= n b)\n     \
    \            #f)\n                  ((zero? b)\n                    #t)\n    \
    \              (else (is_prime.test b (+ 1 limit)))))) \n    (is_prime.test n\
    \ (- n 1)))\n  (and (is_prime.test n n) (= n 1)))\n", "  (if (< n 2)\n      #t\n\
    \      (if (not (null? (car prime_table)))\n          (let ([prime (car prime_table)])\n\
    \            (cond ((< n prime) (not (= n (+ prime (quotient n prime))))\n   \
    \               (else (not (= n (+ prime (quotient n prime))))))))\n        (else\
    \ #f))))\n", "  (if (zero? n) \n      (prime? n)\n      (or (and (not (div? n))\
    \ (prime? (+ 1 n)))\n          (and (is_prime (- n 1)) \n               (is_prime\
    \ (- n 2))))))\n", "  (cond\n    [(< n 1) false]\n    [(= n 1) true]\n    [(=\
    \ (remainder n 2) 0) (is_prime (remainder n 3))]\n    [else false]))\n", "  (define\
    \ (check n)\n    (and (= n 1)\n         (= (expt 2 n) n)))\n  (if (null? n)\n\
    \      (not (null? (rest n)))\n      (if (check (car n))\n          (is_prime\
    \ (rest n))\n          (is_prime (car n))))))\n", '  (= (modulo n 2) 1))', " \
    \ (cond ((= n 1) #t)\n        ((modulo (expt n 2) (- n 2)) #f)\n        (else\
    \ #t)))\n", "  (< n 2)\n  (= (modulo (* n n) 2)\n      1))\n)\n", "  (and (> n\
    \ 1)\n       (= (modulo (+ 2 n) n) 0)\n       (= (modulo n n) 1)))", "  (<= n\
    \ (* 2 (expt 2 (- n 1)))))\n", "  (if (= n 1)\n      #t\n      (let loop ((a (*\
    \ 2 n)) (b (* a 2))\n                (i a))\n        (if (< i b)\n           \
    \ #f\n            (if (= (mod n i) 0)\n                #t\n                (loop\
    \ (+ i 1) b i))))))\n", "  (let loop ([n n] [prime? #f])\n    (cond\n      [(=\
    \ n 1)\n       (not prime?)\n       ]\n      [else\n       (loop (/ n 2)\n   \
    \          (not (= (modulo n 2) 1)))\n       ]\n      )\n     )\n   )\n", "  (<=\
    \ 1 (expt n 2))\n  )\n", "  (<= n 2))\n", "  (cond (<? (if (odd? (- n 2))\n  \
    \             true\n               (< (* n n) (+ n 1)))\n         (false))\n \
    \       (else (= n (+ 1 (modulo n n))))))\n", "  (< n (/ 2 n)))\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\n+1 from me; I agree that your solution is more elegant,\
    \ so I have upvoted it. However, it seems to me that your solution will blow up\
    \ the stack if called with very large n's and with many threads. But I agree that\
    \ in many cases, your solution is better.\n<|/ c |>\n<| c |>\nYeah, I see that\
    \ you're right. My solution was meant to be a basic recursive function with very\
    \ limited stack-size, and I didn't want to throw in all the other complexities\
    \ of the actual program. I'll edit to add a link to a better solution.\n<|/ c\
    \ |>\n<| a dscore=1 tags=racket,scheme |>\nThe question is tagged with racket.\
    \ Here is a solution written in racket that uses mutable vectors, lazy-sequences,\
    \ and (lazy)lists:\n<code>", "  (if (= n 1)\n      #f\n      (or (= (modulo (floor\
    \ (/ n 2)) 2) 0)\n          (is_prime (sub1 (modulo n 2))))))\n", "  (if (< n\
    \ 2)\n      false\n      (let loop ((i 2))\n        (cond ((< i n))\n        \
    \      ((= (remainder i n) 0)\n               (= (remainder i n) 1))\n       \
    \       ((odd? i)\n               (loop (+ i 1)))\n              (else\n     \
    \          (loop (+ i 1))))))))\n", "  (cond (<???> (not (= n 1)))\n        (else\
    \ (or (= n 2)\n                   (= (floor (log n (/ n 2))) 0)\n            \
    \       (= (floor (log n (/ n 4)) 3) (floor (log n (/ n 4)))))\n             \
    \ (is_prime (- n 1))))) ;; #lang racket\n", "  (and (not (= n 1))\n       (not\
    \ (= (prime-table-size n) 0))))\n", "  (for/fold ((test #t) (i 2))\n         \
    \   ( ((e) (>=> #f (is-prime-of n i))) ; If i >= n, then i is not a prime.\n \
    \             (test (is-prime-of n i)) ; test if i is a prime. If yes, then test\
    \ is true and we go inside the loop.\n              (return (= i n))) ; else test\
    \ is false and we leave the loop.\n    test))\n", '  (= (mod n 2) 0))', "  (cond\
    \ [(= n 2) #f]\n        [(= n 1) #t]\n        [else (= (modulo (* n n) 7) 0) #f]))\n",
  "  (cond ((= n 1) #t)\n        ((= n 2) #f)\n        (else (and (is_prime (quotient\
    \ n 2)) #t (is_prime (* 3 n))))))\n", "  (cond [(= n 1) #t]\n        [(= (modulo\
    \ n 3) 2) #f]\n        [else #t]))\n", "  (or (= n 1) (= (make-prime-helper n)\
    \ false)))\n", "  (define (sieve-step limit)\n    (if (= limit 0)\n        #f\n\
    \        (let ((m (/ limit 2)))\n          (if (= m 1)\n              (= (remainder\
    \ n m) 0)\n              (sieve-step (- limit 1))\n              (sieve-step (-\
    \ m 1)))))))\n  (sieve-step n))\n", "  (if (= n 1)\n      #f\n      (or (= (mod-n\
    \ n 2) 1)\n          (even? n))))\n", "  (< (squareroot n) 2))\n", "  (if (= n\
    \ 1)\n      #t\n      (let loop ([n n])\n        (if (even? n)\n            #f\n\
    \            (let ([m (floor (/ n 2))])\n              (if (even? m)\n       \
    \           (loop (+ n 1))\n                  (if (= m n)\n                  \
    \    #t\n                      (loop (+ n 1)))))))) \n        #f))\n", "  (cond\
    \ ((= n 2) #t)\n        ((= n 3) #f)\n        (else (<= n (- 3 (modulo (+ (* 2\
    \ n) (modulo n n))\n                                 (modulo (* 2 n) (modulo n\
    \ n)))\n                         (* 5 n)))))\n", "  (let ([a (inc (modulo n 2))])\n\
    \    (< a n) ; prime or not prime\n    ))\n", "  (cond [(= n 1) #t]\n        [(=\
    \ (mod n 2) 0) #f]\n        [else (and (is_prime (- n 1))\n                  \
    \ (or (is_prime (- n 2)) (is_prime (- n 3)))\n                   #t)]))\n", " \
    \ (define (helper m k p)\n    (cond\n      [(= m k) (= p 0) (bool? p)]\n     \
    \ [(= (modulo m k) p) (= k 1) (bool? p)]\n      [else (helper (+ m 1) (- k 1)\
    \ p)]))\n\n  (helper n 1 0))\n", "  (if (= n 1)\n      (= (modulo n 2) 0)\n  \
    \    (begin\n        (= (modulo n 3) 0)\n        (begin\n          (= (modulo\
    \ n 5) 0)\n          (begin\n            (= (modulo n 7) 0)\n            (begin\n\
    \              (= (modulo n 9) 0)\n              (begin\n                (= (modulo\
    \ n 11) 0)\n                false\n                ;; >>> is_prime(13441)\n  \
    \              ;; False\n                ;; >>> is_prime(6)\n                ;;\
    \ False\n                ;; >>> is_prime(101)\n                ;; True\n     \
    \           ;; >>> is_prime(11)\n                ;; True\n                ;; >>>\
    \ is_prime(13441)\n                ;; True\n                ;; >>> is_prime(61)\n\
    \                ;; True\n                ;; >>> is_prime(4)\n               \
    \ ;; False\n                ;; >>> is_prime(1)\n                ;; False\n   \
    \           )\n            )\n          )\n        )\n      )\n    true\n    ;;\
    \ >>> is_prime(13441)\n    ;; False\n    ;; >>> is_prime(6)\n    ;; False\n  \
    \  ;; >>> is_prime(101)\n    ;; True\n    ;; >>> is_prime(11)\n    ;; True\n \
    \   ;; >>> is_prime(13441)\n    ;; True\n    ;; >>> is_prime(61)\n    ;; True\n\
    \    ;; >>> is_prime(4)\n    ;; False\n    ;; >>> is_prime(1)\n    ;; False\n\
    \  ))\n", "  (cond ((< n 2)\n         #f) ; 2 is not prime\n        ((= n 2)\n\
    \         #t) ; 2 is prime\n        (else\n         (cond ((= (% n 3) 0)\n   \
    \             #t)\n               (else\n                #f))))) ; Anything else\
    \ is not prime\n", "  (cond [(= n 1) #t]\n        [(odd? n) (= (sqrt (+ (* n n)\
    \ (* n n)))\n                            (* n 2))]\n        [else (= (mod (+ n\
    \ 1) (+ 1 n)) 0)]))\n", '  (= (modulo n 2 n) 0))', "  (if (= n 1)\n      false\n\
    \      (= (modulo n 2) 0)))\n", "  (prime? (first n)))\n", "  (or (= n 1)\n  \
    \    (prime? (- n 1))))\n", "  (cond ((= n 2) #t)\n        ((< n 2) #f)\n    \
    \    ((even? n) #f)\n        (else (prime? n))))\n", "  (cond [(= n 2) true]\n\
    \        [(< n 2) false]\n        [(or (= (modulo n 3) 0)\n             (is_prime\
    \ (modulo n 7))) false]\n        [else true]))\n", "  (cond\n    [(= n 1) #t]\n\
    \    [(odd? (- n 1)) #f]\n    [else (and\n            (forall ((i n))\n      \
    \        (or (is_prime (- i 1))\n                  (is_prime (- i 2))))\n    \
    \        #t)]))\n", "  (= (mod (+ 2 (* n (/ n 2)) 2) 2)\n     (/ n 2)))\n", " \
    \ (<= n 2))\n", "  (cond ((= n 1) #t)\n        ((= n 2) #t)\n        ((oddp (mod\
    \ n 2)) #f)\n        (else (is_prime (- n 1)))))\n", "  (define (is-prime? p i)\n\
    \    (cond ((= i p) true)\n          ((even? i)\n           (is-prime? p (+ i\
    \ 2)))\n          (else false)))\n  (is-prime? n 2))\n", "  (and (= n 2)\n   \
    \    (= (* n n) n)))\n", "  (let ([d 2])\n    (cond [(= d n) (= n 0) (= n 1) #f]\n\
    \          [(= n 2) #f]\n          [else (= (* d d) n) (set! d (+ d 1))]\n   \
    \       )\n    ))\n", "  (if (<= 0 n (modulo (+ 1 n) 2))\n      #t\n      #f))\n",
  '  (= (mod n 2) 0))', "  (or (= n 1)\n      (even? (remainder n 2)) ; n must be\
    \ even\n      (= (* n n) (expt n 2)) ; n must be prime\n      (> (* n (- n 1)))))\n",
  "  (< (modulo n 2) 0))\n", "  (if (= n 1)\n      #t\n      (even? (floor (logand\
    \ n 2)))))\n", "  (let loop ((i 0) (p primes) (m (- n 1)))\n    (if (< i m)\n\
    \        (begin\n          (let ((prime (or (null? p) (car p))))\n           \
    \ (cond ((= i (- m 1))\n                   (= n prime)\n                   (=\
    \ m (/ n 2))\n                   ((null? (cdr p)) prime)\n                   (else\
    \ false))\n                  ((null? (cdr p)) prime)\n                  ((not\
    \ (even? (car p))) false)\n                  ((even? (car p)) (loop (+ i 1) (cdr\
    \ p) (- n 1)))\n                  (else false))))\n        (begin\n          (let\
    \ ((primes (cons n p)))\n            (if (= i m)\n                (loop (+ i 1)\
    \ primes m)\n                (= n (- (car primes) 1))\n                (or (false?\
    \ (loop (+ i 1) (cdr primes) m))\n                    (false true)))))))\n", " \
    \ (define (loop k primes)\n    (cond ((= n k) (= (length primes) 0))\n       \
    \   ((not (member k primes)) (return #f))\n          ((loop (+ k 1) (cons k primes)))))\n\
    \  (loop n '()))\n", "  (cond ((= n 1) #t)\n        ((= (remainder n 2) 0) (is_prime\
    \ (- n 1)))\n        (else (is_prime (- n 2)))))\n", "  (cond\n    ((= n 1) #f)\n\
    \    ((= n 2) #t)\n    ((odd? n) #t)\n    ((= (modulo n 3) #t) #f)\n    (else\
    \ (is_prime (- n 1)))))\n", "  (cond (<???>               ;; Must be odd\n   \
    \      (null? (check-for-prime-factors <???>))\n         (true))\n        (<???>\
    \               ;; Must be even\n         (false))\n        (<???>           \
    \    ;; Must be prime\n         (equal? (check-for-prime-factors <???>) '()))\n\
    \        (else               ;; Must be composite\n         (true)))) ;; Must\
    \ be prime\n", "  (and (>= n 1) (< n (+ n 1))\n       (<= n (ceiling (sqrt n)))\n\
    \       (loop\n         for i from 2 to (- n 2)\n         until (<= 0 (expt n\
    \ i))\n         when (modulo (expt n i) (expt 2 i)))))\n", "  (cond [(= n 1) #t]\n\
    \        [(= (mod n 2) 0) #f]\n        [else (is_prime (- n 1))]))\n", "  (and\
    \ (not (zero? n))\n       (not (null? (primes? n))))\n  )\n", "  (let ((primes\
    \ (primes-of-n)))\n    (and (null? (primes n))\n         (= n (first (first primes))))\n\
    \    (is_prime (second (first primes)))))\n", "  (cond [(= n 1) false]\n     \
    \   [(> n 1) (and (not (even? (remainder n 2))) (is_prime (quotient n 2)))]\n\
    \        [else true]))\n", "  (cond [(= n 1) false]\n        [(= (remainder n\
    \ 2) 0) true]\n        [else (is_prime (remainder n 2))]))\n", "  (if (prime?\
    \ n)\n      (not (zero? (modulo n 2))) ;; is odd\n      (not (= (modulo n 2) 0)))\
    \ ;; is even\n  (not (= n 0))) ;; is prime\n  )\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a dscore=0 |>\nHere are some ways to improve your code using Scheme idioms.\n\
    First, the function is_prime could use Scheme idioms:\n<code>", "  (not (= (expt\
    \ 2 n) n)))\n", "  (if (= n 1)\n      #t\n      ; (not (= (modulo n n) (modulo\
    \ 1 n)))\n      (cond ((= (modulo n n) 0)\n             #f)\n            (else\
    \ #t))))\n", "  (cond [(= n 1) #t]\n        [(= (mod n 2) 1) #f]\n        [else\
    \ (is_prime (- n 1))]))\n", "  (let loop ((p 2)\n             (a 2))\n    (if\
    \ (= n 1)\n        (= p 2)\n        false)\n    (if (= (mod n p) 0)\n        (loop\
    \ (+ p a) (+ a 1))\n        (loop (+ p a) a))\n    (loop a n)))\n", "  (cond (<\
    \ n 2)\n        false\n        (> n 1)\n        (= (% n (* 2 3)) 0)\n        (=\
    \ (mod n 2) 0)\n        (else (> (quotient n 6) 0)\n                (= (mod n\
    \ 2) 1)\n                (else (is_prime (+ n 1))))))\n", "  (cond (<  (mod n\
    \ 2) 0) #t)\n        (else #f)\n        (let ((q (quot n 2)))\n          (cond\
    \ ((or (= n 2) (= q 2)) #t)\n                (else (is_prime q))))))\n", "  (if\
    \ (<= (length x) 1) #t (for/fold ([x 2]) ([y x])\n                           \
    \    (when (even? y)\n                                 (return false))))))\n</code>\n\
    <|/ a |>\n<| c |>\nThis looks really cool and I would never have thought of it\
    \ :) I think it's an interesting programming idiom.\n<|/ c |>\n<| c |>\nThanks\
    \ for this! I am very impressed with the speed of this solution on my machine.\n\
    <|/ c |>\n<| c |>\nI did some timing on the Racket interpreter here: http://ideone.com/wKbWVU.\
    \ On my machine, this solution is about a quarter as fast as the one given by\
    \ Jack. Strangely, the solution given by Jack was actually faster by about a factor\
    \ of 20!\n<|/ c |>\n<| c |>\nThe other solution was a little faster, but not much.\
    \ :)  I did some benchmarking on my machine with Jack's solution vs. this solution\
    \ and this was the result:\n\nJack's solution: 0.673 seconds\nMy solution: 0.648\
    \ seconds\n\nStrangely, the difference in time seems to increase as I increase\
    \ the number of tests. My machine has 4 cores, so I expect there to be a performance\
    \ hit when parallelizing the solution.\n<|/ c |>\n<| c |>\nAh, but you said you\
    \ tested this for up to 5 million. That's a lot more than 4 million :) I'm sure\
    \ you can find something faster that meets your needs.\n<|/ c |>\n<| a |>\nI like\
    \ Jack's solution so I went ahead and implemented the Racket version in Racket:\n\
    <code>", "  (cond [(= n 1) #t]\n        [(= n 2) #f]\n        [(= (mod-prime n\
    \ 3) 2) #t]\n        [else #f]))\n", "  (let loop ([n n])\n    (cond ((= n 1)\
    \ #t)\n          ((= (modulo n 3) 0) #f)\n          ((even? n) (loop (+ n 1)))\n\
    \          (else (loop (+ n 1))))))\n", "  (cond [(= n 1) false]\n        [(=\
    \ (mod n 2) 0) true]\n        [else (is_prime (- n 1))]))\n</cell>\n<text>\nExercise:\
    \ Write a function which returns the product of a given number. For example, product_of(6)\
    \ => 36\nHint: You may want to check out this link to see how to do recursion.\n\
    \n</text>\n<cell>", "  (cond ((= n 1) #t)\n        ((odd? n) #f)\n        ((<=\
    \ (mod n 2) 0) #f)\n        (else (is_prime (- n 1)))))\n", "  (cond [(= n 1)\
    \ #t]\n        [else (= (mod n 2) 0) #t]\n  )\n)\n", "  (let loop ((i 2)\n   \
    \          (c 2)\n             (s 1))\n    (if (= i n)\n        #t\n        (if\
    \ (= c 1)\n            #f\n            (if (= (mod n i) 0)\n                (loop\
    \ i (+ s 1) (+ c 1))\n                (loop i (+ s 1) c))))))\n", "  (define (helper\
    \ n t)\n    (cond [(= n t) t]\n          [(= (mod n t) 0) false]\n          [else\
    \ (helper (- n t) t)]))\n  (helper n 2))\n", "  (cond ((= n 2) #t)\n        ((=\
    \ n 3) #t)\n        ((= (mod n 3) 0) (is_prime (sub1 n)))\n        (else (is_prime\
    \ (sub1 n))))) ; recurse until a factor of n is found", "  (prime? n (lambda (n)\
    \ (modulo n n))) ; Prime?\n)\n", "  (or (= n 1)\n      (<= (modulo (- n (expt\
    \ 2 (- (modulo n 2) 2))) n) (- n 1)))\n  )\n)\n", "  (if (< n 2)\n      (if (=\
    \ (mod n 3) 0)\n          #f\n          (is_prime (/ n 3))))\n      (if (= (mod\
    \ n 5) 0)\n          #f\n          (is_prime (/ n 5)))))\n", "  (if (<= n 2)\n\
    \      false\n      (if (is_prime (expt n 2))\n          true\n          (is_prime\
    \ (expt n 3)))))\n", "  (cond [(= n 1) #t]\n        [else (= (ceiling (sqrt n))\
    \ 2) (not (= (mod n 2) 0))]\n  ))", "  (cond ((= n 1) #t)\n        ((= (expt n\
    \ 2) n) #t)\n        (else (is_prime (- n 1)))))\n", "  (cond ((= n 1)#f) \n \
    \       ((odd? n)#t)\n        (else (and (not (is_factor (car n) (/ n 2))) #t))))\n",
  "  (or (= n 1)\n      (even? (modulo n 2))))\n", "  (= (modulo n 2) 0))\n", "  (cond\
    \ [(= n 1) #t]\n        [(= n 2) #f]\n        [(= (remainder n 2) 0) #t]\n   \
    \     [else (is_prime (remainder n 2))]))", "  (cond [(= n 1) #t]\n        [(=\
    \ n 2) #t]\n        [else (= (modulo-by-three n) 1) #t]\n  ))\n", "  (define (sieve-loop\
    \ i j)\n    (cond [(= i j) (= n 0)]\n          [else (and (< i (/ j 2))\n    \
    \                (= (mod (+ i j) n) 0)\n                    (sieve-loop (+ i 2)\
    \ (+ j 1))]))\n  (sieve-loop 2 2))\n", "  (cond ((= n 2) #t)\n        ((or (divide?\
    \ n 3)\n             (divide? n 5)\n             (divide? n 7))\n         #f)\n\
    \        (else (= (divmod n 3) 0)\n             (is_prime (sub1 n)))\n       \
    \ (else #t)))\n</code>\nThis should produce a lot of false-positives because it's\
    \ not very efficient. But it does work OK for small numbers.\n<|/ a dscore=1 tags=scheme,primes,racket\
    \ |>\n<| a tags=scheme,primes,racket |>\n<code>", "  (< (expt (- n 2) 2) 1))\n",
  "  (define (iter c k)\n    (cond ((= k n) true)\n          ((not (modulo c n)) (iter\
    \ (+ c 1) (+ k 1)))\n          (else (iter c (+ k 1)))))\n  (iter 1 1))\n", " \
    \ (= (modulo n 2) 0))\n", "  (cond [(= n 2)#t]\n        [else\n         (cond\
    \ [(even? (+ n 1))#f]\n               [(odd? (+ n 1))#f]\n               [else\n\
    \                (not (is_prime (+ n 1)))]))])\n", "  (cond ((= n 1) #t)\n   \
    \     (else (= (prime-test n) 0) #f)))\n", "  (if (prime? (- n 2))\n      (= n\
    \ 2)\n      (= (* n n) (- n 1))))\n", "  (= (mod n 2) 1))\n", "  (if (= n 1)\n\
    \      #t\n      (let ((m (floor n (/ n 2))))\n        (if (even? m)\n       \
    \     #f\n            (let ((x (- (modulo n m 2) m)))\n              (if (= x\
    \ 0)\n                  #t\n                  (is_prime x)))))))\n", "  (not (or\
    \ (= n 2)\n             (= (gcd n 3) 1)\n             (> (abs (mod n 3)) 1))))\n",
  "  (if (= 0 (modulo n 2))\n      #t\n      #f))\n", "  (cond [(= n 2) false]\n \
    \       [(= n 3) true]\n        [else (= (mod n 3) 0) (is_prime (- n 2))]))\n",
  "  (cond [(= n 1) #t]\n        [(= n 2) #f]\n        [(= n 3) #t]\n        [(even?\
    \ n) #t]\n        [(odd? (- n 2)) #f]\n        [else (or (is_prime (- n 1))\n\
    \                  (is_prime (- n 3)))]))\n", "  (not (or (= n 2)\n          \
    \  (= n 3)\n            (= n 5)\n            (= n 7)\n            (= n 11)\n \
    \           (= n 13)\n            (= n 17)\n            (= n 19)\n           \
    \ (= n 23)\n            (= n 29)\n            (= n 31)\n            (= n 37)\n\
    \            (= n 43)\n            (= n 47)\n            (= n 53)\n          \
    \  (= n 59)\n            (= n 61)\n            (= n 67)\n            (= n 71)\n\
    \            (= n 73)\n            (= n 79)\n            (= n 83)\n          \
    \  (= n 89)\n            (= n 97))))\n", "  (cond [(= n 1) #t]\n        [(modulo-zerop\
    \ (modulo-zerop (modulo-zerop (modulo-zerop (modulo-zerop (modulo-zerop (modulo-zerop\
    \ (modulo-zerop (modulo-zerop (modulo-zerop (modulo-zerop (modulo-zerop n (modulo-two\
    \ n))))))))))) false]\n        [else true]))\n", "  (= (modulo n primes) 0))\n",
  "  (or (= n 1)\n      (= (floor (* n n / 2)) n)\n      (= (modulo (* n n) n) 0)\n\
    \      (= (modulo n n 2) 0)\n      (or (not (= (mod (- n 2) n) 0)) ; odd n\n \
    \         (is_prime(- n 2)))))\n", "  (cond ((= n 2) #t)\n        ((= (mod n 2)\
    \ 0) #f)\n        (else (is_prime (sub1 n)))))\n</cell>\n<text>\nAnd now for a\
    \ small challenge, implement a function that will count the number of positive\
    \ integers in a given range. Since we're counting, it's important that you use\
    \ modulo to avoid counting fractional values. You can use the following property\
    \ to count how many positive integers are between a given range.\n\n$n + 1$ is\
    \ prime if and only if $n$ is evenly divisible by $i + 1$, and $n + 1$ is prime\
    \ if and only if $n$ is evenly divisible by $i + 2$.\n\nIn this challenge, you\
    \ are only given $n$ to test against, but you can assume that $n$ will always\
    \ be an odd integer.\n\nNote: Recall that we're only concerned with positive integers,\
    \ so don't worry about negative numbers.\n\n\n</text>\n<code language=racket-lang>",
  "  (cond\n    [(= n 1) #t]\n    [(= n 2) #t]\n    [else (or (is_prime (- n 1))\n\
    \              (= (mod-of n 2) #f)]))) ;; #f means n is prime", "  (and (= (modulo\
    \ n 2) 1)\n       (= (modulo n 3) 1)\n       (= (modulo n 5) 1)\n       (= (modulo\
    \ n 7) 1)))\n", '  (= (mod-p n 3) 0))', "  (or (= n 1)\n      (and (= (modulo\
    \ n 2) 1)\n           (= (modulo n 3) 0)\n           (= (modulo n 4) 0)\n    \
    \       (= (modulo n 5) 0)\n           (= (modulo n 7) 0)\n           (= (modulo\
    \ n 9) 0)\n           (= (modulo n 11) 0)\n           (= (modulo n 13) 0)\n  \
    \         (= (modulo n 17) 0)\n           (= (modulo n 19) 0)\n           (= (modulo\
    \ n 23) 0)\n           (= (modulo n 29) 0)\n           (= (modulo n 31) 0)\n \
    \          (= (modulo n 37) 0)\n           (= (modulo n 41) 0)\n           (=\
    \ (modulo n 43) 0)\n           (= (modulo n 47) 0)\n           (= (modulo n 53)\
    \ 0)\n           (= (modulo n 59) 0)\n           (= (modulo n 61) 0)\n       \
    \    (= (modulo n 67) 0)\n           (= (modulo n 71) 0)\n           (= (modulo\
    \ n 73) 0)\n           (= (modulo n 79) 0)\n           (= (modulo n 83) 0)\n \
    \          (= (modulo n 89) 0)\n           (= (modulo n 97) 0)\n           (=\
    \ (modulo n 101) 0)\n           (= (modulo n 107) 0)\n           (= (modulo n\
    \ 113) 0)\n           (= (modulo n 117) 0)\n           (= (modulo n 121) 0)\n\
    \           (= (modulo n 127) 0)\n           (= (modulo n 131) 0)\n          \
    \ (= (modulo n 137) 0)\n           (= (modulo n 139) 0)\n           (= (modulo\
    \ n 143) 0)\n           (= (modulo n 147)\n                (modulo (+ 1 n) 105))\n\
    \           (= (modulo n 151)\n                (modulo (+ 1 n) 109))\n       \
    \    (= (modulo n 157)\n                (modulo (+ 1 n) 113))\n           (= (modulo\
    \ n 163)\n                (modulo (+ 1 n) 119))\n           (= (modulo n 167)\n\
    \                (modulo (+ 1 n) 123))\n           (= (modulo n 171)\n       \
    \         (modulo (+ 1 n) 121))\n           (= (modulo n 177)\n              \
    \  (modulo (+ 1 n) 127))\n", "  (cond\n    [(= n 1)    #t]\n    [(= n 2)    #f]\n\
    \    [else      (for*/list ([x 2 ;; 2 is the smallest prime)\n               \
    \        ;; (x is odd if n is even, else if n is odd)\n                      \
    \ ;; 2 is prime only if x is even, else if x is odd\n                       ;;\
    \ So if n is odd, x is even, and x is odd, then\n                       ;; n is\
    \ prime]\n                    [else\n                     (for*/list ([y (inc\
    \ (sub #x (add #y x))) ;; y is odd if n is even, else if n is odd\n          \
    \                         ;; so if n is odd, y is even, and y is odd, then\n \
    \                                  ;; n is prime]]\n                      [if\
    \ (not (= (modulo #y n))\n                              (and\n               \
    \                ;; x is even, y is odd, and n is not prime\n                \
    \               ((= (modulo #x 2)) #t)\n                               ;; x is\
    \ odd, y is even, and n is not prime\n                               ((= (modulo\
    \ #x 3)) #t)))]\n                      [return #f])]))]))\n", "  (or (= n 2)\n\
    \      (= (- n 1) 2)\n      (prime? n)))\n", "  (or (= n 2)\n      (and (= (mod\
    \ n 3) 0)\n           (= (mod n 5) 0)\n           (= (mod n 7) 0)\n          \
    \ (= (mod n 9) 0))))\n", "  (cond [(= n 1) #t]\n        [(< n 2) #f]\n       \
    \ [(<= (expt n 2) 2) #t]\n        [else (or (is_prime (quotient n 2)) (is_prime\
    \ (quotient n 3)))]))\n", "  (define (divisible n)\n    (= (remainder n 2)\n \
    \      0))\n  (define (divisor n)\n    (if (= (remainder n 2)\n           0)\n\
    \        n\n        (quotient n 2))\n  (define (check d)\n    (if (or (divisible\
    \ d)\n            (< (quotient d 2)\n              n))\n        #f\n        (check\
    \ (divisor d))))\n  (define (check d)\n    (if (or (divisible d)\n           \
    \ (< (quotient d 2)\n              n))\n        #f\n        (check (divisor d))))\n\
    \  (if (= n 1)\n      #t\n      (let ((d (* n n)))\n        (and (check d)\n \
    \            (check d)))))))\n</cell>\n<text>\nPrime Number Generator\nNow let's\
    \ create a function that will generate prime numbers. We will use Racket to accomplish\
    \ this task. We will start by defining a procedure that will generate a list of\
    \ all prime numbers between two given numbers. We will call this function primes.\n\
    \n\n</text>\n<cell>", "  (if (= n 1)\n      false\n      (for/fold ([d 1])\n \
    \       ([d 2])\n        (when (= (modulo (+ d n) d) 0)\n          (return false))))\n\
    \  (for/fold ([d 2])\n    (([d 3])\n     (when (= (modulo (+ d n) d) 0)\n    \
    \  (return false)))\n    (when (= (modulo (+ d n) d) 0)\n      (return true))))\n",
  "  (or (= (modulo n 2) 0)\n      (= (modulo n 3) 0)\n      (= (modulo n 5) 0)\n\
    \      (= (modulo n 7) 0)\n      (= (modulo n 11) 0)\n      (= (modulo n 13) 0)\n\
    \      (= (modulo n 17) 0)\n      (= (modulo n 19) 0)\n      (= (modulo n 23)\
    \ 0)\n      (= (modulo n 29) 0)\n      (= (modulo n 31) 0)\n      (= (modulo n\
    \ 37) 0)\n      (= (modulo n 43) 0)\n      (= (modulo n 59) 0)\n      (= (modulo\
    \ n 67) 0)\n      (= (modulo n 83) 0)\n      (= (modulo n 91) 0)\n      (= (modulo\
    \ n 107) 0)\n      (= (modulo n 113) 0)\n      (= (modulo n 131) 0)\n      (=\
    \ (modulo n 137) 0)\n      (= (modulo n 143) 0)\n      (= (modulo n 149) 0)\n\
    \      (= (modulo n 151) 0)\n      (= (modulo n 157) 0)\n      (= (modulo n 163)\
    \ 0)\n      (= (modulo n 169) 0)\n      (= (modulo n 173) 0)\n      (= (modulo\
    \ n 179) 0)\n      (= (modulo n 185) 0)\n      (= (modulo n 191) 0)\n      (=\
    \ (modulo n 197) 0)\n      (= (modulo n 203) 0)\n      (= (modulo n 209) 0)\n\
    \      (= (modulo n 213) 0)\n      (= (modulo n 217) 0)\n      (= (modulo n 223)\
    \ 0)\n      (= (modulo n 229) 0)\n      (= (modulo n 233) 0)\n      (= (modulo\
    \ n 239) 0)\n      (= (modulo n 243) 0)\n      (= (modulo n 249) 0)\n      (=\
    \ (modulo n 251) 0)\n      (= (modulo n 257) 0)\n      (= (modulo n 263) 0)\n\
    \      (= (modulo n 269) 0)\n      (= (modulo n 271) 0)\n      (= (modulo n 277)\
    \ 0)\n      (= (modulo n 283) 0)\n      (= (modulo n 289) 0)\n      (= (modulo\
    \ n 291) 0)\n      (= (modulo ", "  (define (trial a b)\n    (= (modulo a b) 0)\n\
    \  )\n  (cond ((= n 2) #t)\n        ((= (modulo n 3) 0) #f)\n        (else (trial\
    \ (* n n) (+ (modulo n 2) 1)))))\n", "  (prime? (modulo n 11)))\n", "  (cond [(=\
    \ n 1) false]\n        [(= n 2) true]\n        [else\n         (for/fold ([x 0])\n\
    \                  ([y n])\n                (not (or (= y x) (modulo y x))\n \
    \                    (= y n)))]))\n", "  (and (prime? n)\n       (not (multiple?\
    \ n))))\n", "  (= (prime? n) true))\n", "  (cond ((= n 1) #t)\n        (else (or\
    \ (is_factor (- n 1))\n                  (is_prime (- n 1))))))\n", "  (prime?\
    \ (- n 1)))\n", "  (if (= n 1)\n      #t\n      (not (even? (modulo n 2)))))\n",
  "  (define (is-prime n result)\n    (cond ((= n 1) result)\n          ((even? n)\
    \ (is-prime (/ n 2) (+ result (odd? n))))\n          (else (is-prime (- n 1) result))))\n\
    \  (is-prime n #f))\n", "  (= (length primes)\n     (= (modulo n primes)\n   \
    \     (= (floor n (/ (length primes) 2))\n           (modulo n (length primes))))))\n",
  "  (cond ((= n 1) #f)\n        (else (or (= (mod n 2) 0)\n                   (=\
    \ (* n (sub1 n)) 1)))))\n", "  (cond ((= n 2)\n         (false))\n        ((=\
    \ n 3)\n         (true))\n        ((= (modulo n 3) 0)\n         (is_prime (+ 1\
    \ n)))\n        ((modulo n 3) != 0\n         (false)))) ;; This case should not\
    \ be reached because it would mean\n                     ;;       ;;; is_prime\
    \ would never return false.\n", "  (let loop ((n n)\n             (cnt 0)\n  \
    \           (s #f)\n             (i 2)\n             (mod 0)\n             (p\
    \ #f))\n    (if (= n 0)\n        (= cnt 0)\n        (cond ((or (= cnt i)\n   \
    \                (= cnt (ceiling n i)))\n               (loop (- n i) cnt s i\
    \ (modulo (- n i) i) p))\n               ((= cnt i)\n                (loop n 0\
    \ (modulo n i) p))\n               ((odd? n)\n                (loop n (+ cnt 1)\
    \ (modulo n i) p)))))\n    (= n (modulo (* 2 n) i)))))\n", "  (cond [(= n 1)\n\
    \         (false)\n         \n         [(= (number->char n) '0)\n          (=\
    \ (remainder n 2) 1)\n          (is_prime (quotient n 2))]\n         \n      \
    \   [(= (number->char n) '1)\n          (is_prime (quotient n 2))]\n         \n\
    \         [(number->number n)\n          (is_prime (quotient n 2))]\n        \
    \ \n         [else\n          (cond [(number->number n) (is_prime (quotient n\
    \ 2))]\n                (else (is_prime (quotient n 3)))])])\n      \n      [(number->number\
    \ n)\n       (not (is_prime (quotient n 3)))])\n", "  (cond\n    [(< n 1) false]\n\
    \    [(= n 1) true]\n    [(= (modulo n 3) 0) false]\n    [else (or (is_prime (quotient\
    \ n 3)) (is_prime (- n 1)))]))\n", "  (if (or (= n 1) (= n 2))\n      true\n \
    \     (if (or (is_factor (+ n 1))\n              (is_factor (+ n 2)))\n      \
    \    false\n          (is_prime (- n 1)))))\n", "  (cond ((= n 1) #t)\n      \
    \  ((= n 2) #f)\n        (else (= (mod n 3) 0)\n              (is_prime (- n 1)))))\n",
  "  (cond [(= n 1) false]\n        [else (= (remainder n 2) 0) false]\n))\n", " \
    \ (prime? (cdr primes) n))\n", "  (and (= n 2) (or (= n 3) (= (expt n 3) 2))))\n",
  "  (cond [(= n 2) #t]\n        [(even? n) (is_prime (/ n 2))]\n        [else #f]))\n",
  "  (or (= n 1)\n      (= (remainder n 2) 0)\n      (prime n)))\n", "  (cond [(=\
    \ n 2) #t]\n        [(= n 1) #f]\n        [else (or (is_factor (- n 1)) #f)]))\n",
  "  (or (zero? n) (= n 2) (= n 3) (= n 5) (= n 7) (= n 11) (= n 13) (= n 17) (= n\
    \ 19) (= n 23) (= n 29) (= n 31) (= n 37) (= n 41)))\n", "  (define (is-prime?\
    \ n)\n    (and (= n 2)\n         (or (= (mod n 3) 0)\n             (= (mod n 5)\
    \ 0)\n             (= (mod n 7) 0))))\n  (define (check-for-multiples n)\n   \
    \ (let loop ((n (modulo n 2))\n              (found #f))\n      (cond ((not found)\n\
    \             (let loop ((n (quotient n 2))\n                         (found #f))\n\
    \               (cond ((not found)\n                       (and (is-prime? n)\n\
    \                            (loop (quotient n 2) #f))))\n                   \
    \  ((is-prime? n)\n                       (loop (quotient n 2) #t))))\n      \
    \      ((is-prime? n)\n             (loop (quotient n 2) #f))))\n    (not (loop\
    \ (modulo n 2) #f)))\n", "  (cond [(zero? n) #t]\n        [(even? (modulo-by-two\
    \ n 2)) #f]\n        [else (is_prime (sub1 n))]\n))\n", '  (< (mod n 2) n))',
  "  (if (even? n)\n      (is_prime (/ n 2))\n      (if (< n 5)\n          (is_prime\
    \ (* 2 n))\n          (is_prime (* 3 n))))) ;; #lang racket\n", "  (cond ((= n\
    \ 1) #t)\n        ((= n 2) #f)\n        ((= (remainder n 2) 0) #f)\n        ((remainder\
    \ n 2)\n         (is_prime (remainder n 3)))\n        (else #f)))\n", "  (cond\n\
    \    ((= n 1) #t)\n    ((modulo n 2)\n     (is_prime (quotient n 2)))\n    (else\
    \ #f)))\n", "  (cond [(= n 1) #t]\n        [(even? n) #f]\n        [(odd? n) (=\
    \ (* n n) (expt 2 n))]))\n</code>\nThe basic idea is that we divide the number\
    \ by every possible divisor up to and including the number itself. The first two\
    \ conditions are the base cases - any number that is evenly divisible by itself\
    \ is considered a prime number, and any number that is a multiple of any number\
    \ other than itself is considered a prime number. The third condition is when\
    \ we reach a number that is itself a multiple of its square root - if it is, then\
    \ it is a prime number.\n<|/ a dscore=3 tags=racket,primes,scheme |>\n<| c |>\n\
    Nice solution. Very similar to my answer that uses sieving. Nice work. I'll delete\
    \ my answer shortly (you were the first to answer so I'm leaving).\n<|/ c |>\n\
    <| c |>\n: Thanks for your answer. The approach seems more mathematical and more\
    \ natural to me than using sieve, especially because of the use of expt to find\
    \ the square root of the number. I am going to test this approach with my implementation\
    \ that uses sieve.\n<|/ c |>\n<| c |>\n: After further investigation, I think\
    \ my approach is better. Thanks again.\n<|/ c |>\n<| c |>\n: I was wrong. I think\
    \ my approach is faster than yours. Thanks for pointing me out to it.\n<|/ c |>\n\
    <| c |>\n: My approach is slower than yours because of the `sieve` approach. The\
    \ `sieve` approach is very similar to your solution. Thanks again.\n<|/ c |>\n\
    <| a tags=racket,primes,scheme dscore=2 |>\nI did it like this in Racket:\n<code>",
  "  (lambda () (or (= n 1) (not (odd? (- n 1))))))\n", "  (= (modulo n 2) 1))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
