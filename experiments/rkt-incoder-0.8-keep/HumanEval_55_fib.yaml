name: HumanEval_55_fib
language: rkt
prompt: "#lang racket\n\n;; Return n-th Fibonacci number.\n;; >>> fib(10)\n;; 55\n\
  ;; >>> fib(1)\n;; 1\n;; >>> fib(8)\n;; 21\n(define (fib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n\
  \    (check-equal? (candidate 10) 55)\n    (check-equal? (candidate 1) 1)\n    (check-equal?\
  \ (candidate 8) 21)\n    (check-equal? (candidate 11) 89)\n    (check-equal? (candidate\
  \ 12) 144)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      1\n      (+ (fib (- n 1))\n         (fib n))))\n",
  "  (if (= n 0)\n      0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", " \
    \ (define (helper a b count)\n    (if (zero? count)\n        a\n        (helper\
    \ (+ a b) (+ b count) count)))\n  (helper 1 1 n))\n", "  (if (= n 0) 0\n     \
    \ (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (< n 2)\n      n\n      (+ (fib\
    \ (- n 1))\n         (fib (- n 2)))))\n</cell>\n<text>\nWrite a function that\
    \ takes a list containing any number of integers and returns the sum of the numbers\
    \ in the list up to the nth number.\n\n\n</text>\n<code language=racket-language>",
  "  (if (= n 0)\n      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  \n  (cond\n\
    \    \n    ((= n 0) 1)\n    ((= n 1) 1)\n    (else (+ (fib (- n 1)) (fib (- n\
    \ 2)))))\n  )\n)\n", "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n\
    \ 2)))))\n</cell>\n<text>\nAnd that's how you use it. Let's use it to find the\
    \ first $10^{11}$ Fibonacci numbers, starting with $0$ and $1$:\n\n\n</text>\n\
    <cell>\n#lang racket\n", "  (let ([a 1] ([b 1] [c 1] [d 1] [e 1] [f 1] [g 1] [h\
    \ 1] [i 1] [j 1] [k 1] [l 1] [m 1])\n        [m (a+b)])\n    (cond\n      [(=\
    \ n 0) m]\n      [(= n 1) m]\n      [(< n m) (recur (- n 1) (c+d+e+f+g+h+i+j+k+l+m))]))))\n",
  "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib n-1) (fib n-2))\
    \ ]))\n", "  (if (= n 0) 1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if\
    \ (= n 0)\n      1\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (define\
    \ (iter i acc)\n    (cond [(= i n) acc]\n          [else (iter (+ i 1) (+ acc\
    \ i))]))\n  (iter 1 0))\n", "  (cond [(= n 1) 1]\n        [(= n 2) 1]\n      \
    \  [else\n         (+ (fib (- n 1)) \n             (fib (- n 2))))]))\n", "  (if\
    \ (<= n 1)\n    1\n    (+ (fib (- n 2)) (fib (- n 1)))))\n", "  (if (< n 2) 1\n\
    \      (+ (fib 1 (- n 2)) (fib 2 (- n 2)))))\n", "  (if (= n 0)\n      0\n   \
    \   (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0) 1]\n        [(= n\
    \ 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (* (+ 1 n) (fib\
    \ n)))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (-\
    \ n 1)) (fib (- n 2)))]))\n", "  (let ([a 1])\n    (cond\n      [(= n 1) a]\n\
    \      [(> n 2) (+ (fib (- n 1)) (fib (- n 2)))]\n      [else (fib (- n 1)) (fib\
    \ (- n 2))]\n      )\n    )\n  )\n", "  (if (< n 0) (error \"Not positive Fibonacci\
    \ number!\" n)\n  (let ((a 1)\n        (b 1))\n    (lambda ()\n      (set! b (+\
    \ a b))\n      (set! a (+ a b))\n      b))))\n", "  (cond [(= n 0) 1]\n      \
    \  [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond [(= n 1) 1]\n       \
    \ [(= n 2) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n</code>\n<|/\
    \ a tags=racket,scheme dscore=2 |>\n<| c |>\nWhile this code might answer the\
    \ question, providing additional context regarding why and/or how this code answers\
    \ the question improves its long-term value.\n<|/ c |>\n<| c |>\nThis code works\
    \ with racket, but fails in scheme\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  (cond\n\
    \    [(= n 0) 1]\n    [(= n 1) 1]\n    [(= (- n 2) 0) (+ (fib 1) (fib 0))]\n \
    \   [else (+ (fib 0) (fib 1))]))\n", "  (cond ((= n 1) 1) ((= n 2) 1)\n      \
    \  ((= n 3) 2)\n        (else (+ (fib(- n 1)) (fib(- n 2))))))\n", "  (let* ([fib1\
    \ (fib 1)\n         fib2 (fib 2)\n         fib3 (fib 3)\n         fib4 (fib 4)\n\
    \         fib5 (fib 5)\n         fib6 (fib 6)\n         fib7 (fib 7)\n       \
    \  fib8 (fib 8)\n         fib9 (fib 9)\n         fib10 (fib 10)]\n         (acc\
    \ (if (< n 10)\n                 fib10\n                 (+ fib1\n           \
    \         (+ fib2\n                      (+ fib3\n                        (+ fib4\n\
    \                          (+ fib5\n                            (+ fib6\n    \
    \                          (+ fib7\n                                (+ fib8\n\
    \                                  (+ fib9\n                                 \
    \   (+ fib10 '())))))))))))]\n    (if (= n 0)\n        (+ acc '())\n        (fib\
    \ (- n 1))))\n", "  (if (< n 2) (fib 1 (+ n 2))\n  (fib 1 (+ n 1))))\n", "  (define\
    \ (helper a b k temp)\n    (cond [(> k n) temp]\n          [(= k 2) b]\n     \
    \     [else (helper (+ a b) b (- k 1) (+ a temp))]))\n  (helper 1 1 0 0))\n",
  "  (cond [(= n 1)\n         1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n",
  "  (cond [(= n 1) 1]\n        [else (+ fib (fib (- n 1))))]))\n", "  (cond [(= n\
    \ 0)  1]\n        [(= n 1) 1]\n        [(= n 2)  2]\n        [else     (+ (fib\
    \ (- n 1)) (fib (- n 2)))]))\n</code>\n<|/ a dscore=3 |>\n<| c |>\nGreat solution!\
    \ Could you give a hint about why we could get infinite recursion with the above\
    \ approach? Thanks!\n<|/ c |>\n<| c |>\n, consider that `n` starts at 0 (`fib(0)`\
    \ is 1), and that `fib(1)` is 1. So, `fib(0)` is returned before `fib(1)` is returned\
    \ and so the recursion never terminates. A quick fix is to flip the conditions:\
    \ `(= n 1)` should be `(= n 2)`, etc.\n<|/ c |>\n<| a tags=scheme,recursion,racket\
    \ |>\nThe most elegant solution would probably be:\n<code>", "  (if (<= n 0)\n\
    \      0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (if (= n 0)\n\
    \      0\n      (+ (fib 1 (+ n 2)) (fib 2 (+ n 3)))))\n", "  (cond\n    ((= n\
    \ 1) 1)\n    ((= n 2) 1)\n    ((= n 3) 2)\n    (else (+ (fib (- n 1)) (fib (-\
    \ n 2))))))\n", "  (let ([f (list 1 2 3)]\n        [a #f]\n        [b (if (< n\
    \ 2) (list f) (f (cons b f)))])\n    (if (<= n 2)\n        b\n        (fib n (+\
    \ a (first b)))\n        )))\n", "  (fib_list 0 1 2 3 4 5 6 7 8 9 10 n))\n", " \
    \ (cond [(< n 0)\n         (error 'fib nil)\n         ]\n        [(= n 1)\n  \
    \       (list 1)]\n        [else\n         (+ (fib (- n 1)) (fib (- n 2)))\n \
    \        ]))\n</code>\n<|/ a tags=scheme,fibonacci,racket |>\n<| a tags=scheme,fibonacci,racket\
    \ dscore=1 |>\nThe following is more concise:\n<code>", "  (if (= n 0)\n     \
    \ (+ 1 0)\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (define (iter i)\n \
    \   (define (next j)\n      (cond\n        ((= i j) i)\n        (else (+ i j))))\n\
    \    (iter (next i)))\n  (iter 0))\n", "  (if (= n 0)\n      1\n      (+ (fib\
    \ (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0)\n         1]\n        [(= n\
    \ 1)\n         1]\n        [(= n 2)\n         1]\n        [else\n         (+ (fib\
    \ (- n 1))\n            (fib (- n 2)))]))\n</code>\n<code>\n#lang racket\n", " \
    \ (if (<= n 1)\n      n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n",
  "  (cond [(= n 0)            0]\n        [(= n 1)            1]\n        [else \
    \             (+ (fib (- n 2)) (fib (- n 1)))]))\n</code>\n<|/ a |>\n<| c |>\n\
    It would be better to write it using `cond` instead of `condseq` since `condseq`\
    \ was introduced as a primitive in Racket 3.6.\n<|/ c |>\n<| a |>\nHere is my\
    \ implementation using fibonacci numbers\n<code>", "  (if (= n 0)\n      1\n \
    \     (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0) 1]\n        [(=\
    \ n 1) 1]\n        [else (+ (fib n-1) (fib n-2))]))\n</cell>\n<cell>\n#lang racket\n",
  "  (cond [(= n 1) 1]\n        [else (+ (fib (sub1 n)) (fib (sub1 n)))]))\n", " \
    \ (letrec ((fib (lambda (a b c)\n                  (cond [(= c 0) a]\n       \
    \                 [else (fib (+ a b) (+ b c) (c- c))]))))\n    (fib (0 1 n))))\n",
  "  (fib-iter 1 2 0 n))\n", "  (fib-iter 0 1 n))\n", "  (let fib ((a 0) (b 1))\n\
    \    (cond\n      [(< n 0) 1]\n      [(< n 1) 1]\n      [(< n 2) b]\n      [(<\
    \ n 3) (fib (- n 3) (+ a b))]\n      [(< n 4) a]\n      [(< n 5) (fib (- n 4)\
    \ (+ a b))]\n      [(< n 6) (fib (- n 5) (+ a b))]))))\n", "  (if (= n 1)\n  \
    \    1\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (cond [(zero?\
    \ n) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1))\n               \
    \    (fib (- n 2)))]))\n</cell>\n<text>\nEjercicio 1.17\nEscribe un programa que\
    \ calcule la serie de Taylor de primera orden. Si el n\xFAmero de puntos de la\
    \ serie es positivo, el m\xE9todo de primera orden es el m\xE9todo de Gauss de\
    \ Newton.\n\n\n</text>\n<code language=dyalog-kernel>", "  (if (zero? n)\n   \
    \   (exact->inexact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact (exact->exact\
    \ (", "  (if (= n 0)\n      0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n\
    </code>\n<|/ a tags=recursion,scheme,racket |>\n<| a dscore=2 |>\n<code>", " \
    \ (if (= n 0) 1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n</cell>\n<text>\nExercises\n\
    \n</text>\n<text>\nExercise 1\nWe have the Fibonacci numbers $F{i} = F{i-1} +\
    \ F_{i-2}$ and we want a function $f_i$ that returns the $i$th Fibonacci number.\
    \ To test it we will define $f_1$ and $f_2$ as follow:\n\n\n</text>\n<cell>",
  "  (fib-iter 0 1 1 2))\n", "  (cond [(zero? n) 1]\n        [(zero? (sub1 (sub1 (fib\
    \ 1) (fib 2))))\n         fib 2]\n        [else\n         (+ (fib 1) (fib 2))]))\n",
  "  (if (= n 0) 0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (if (=\
    \ n 0)\n      1\n      (+ (fib (- n 1)) ((fib (- n 2)) 1))))\n", "  (if (= n 0)\n\
    \      0\n      (if (= n 1)\n          1\n          (+ (fib (- n 1))\n       \
    \      (fib (- n 2))))))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n     \
    \   [else\n         (+ (fib (sub1 n)) (fib (sub1 n)))]))\n", "  (cond [(= n 0)\
    \ 1]\n        [else (+ (fib n (- n 1)) (ffib n (- n 2))))))\n", "  (if (<= n 0)\n\
    \      0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (cond [(zero?\
    \ n) 0]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n</cell>\n<code language=racket-language>\n\
    #lang racket\n", "  (if (= n 0)\n      0\n      (+ (fib n-1) (fib n-2))))\n",
  "  (if (= n 0) 0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (if (=\
    \ n 1)\n      1\n      (+ (fib (- n 2)) (fib (- n 1)))))\n</code>\n<|/ a tags=recursion,scheme,racket\
    \ dscore=1 |>\n<| c |>\nThank you. I'm new to scheme. I'm having a hard time understanding\
    \ how your fib function works. Can you explain how you got it so that I can implement\
    \ it into my program? Thank you. I'm new to coding and recursion is very confusing\
    \ to me.\n<|/ c |>\n<| c |>\nOk, so I added the function and it's output above\
    \ to my program. Now when I try and implement it into my program with calling\
    \ the function I get this error: \"expected a function\n --> fib 3 \n point\"\n\
    <|/ c |>\n<| c |>\nIt was meant to be called as `fib`, not `(fib 3)`.\n<|/ c |>\n\
    <| c |>\nThank you. I'm still getting used to the language. I'm going to have\
    \ to read up on it a bit. But in the meantime this is very helpful.\n<|/ c |>\n\
    <| c |>\n, did you find the explanation helpful or are you still having trouble?\n\
    <|/ c |>\n<| a tags=recursion,scheme,racket dscore=0 |>\nThis should help\n<code>",
  "  (cond [(< n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))))\n</cell>\n\
    <code language=ocaml-jupyter>\n#require \"jupyter-irkernel\"\n</cell>\n<code language=ocaml-jupyter>",
  "  (if (< n 0) nil\n      (cond ((= n 1) 1)\n            ((= n 2) 1)\n         \
    \   (else (+ (fib (- n 1))\n                      (fib (- n 2))))))))\n", "  (define\
    \ (fib-iter n a b c)\n    (if (= n 0)\n        a\n        (fib-iter (- n 1) (+\
    \ a b) c (+ c b))))\n  (fib-iter n (+ 1 1) 1 1))\n", "  (if (or (= n 1) (= n 2))\n\
    \      n\n      (+ (fib (- n 1)) (nth n \"fibonacci\"))))\n", "  (cond\n    ((=\
    \ n 1) 1)\n    ((= n 2) 1)\n    ((< n 2) (+ (fib (- n 2)) (fib (- n 1))))\n  \
    \  (else (fib n))))\n", "  (cond [(zero? n) 0]\n        [(= n 1) 1]\n        [(=\
    \ n 2) 1]\n        [else (+ fib (- n 1)) (+ fib (- n 2))]))\n", "  (if (<= n 0)\n\
    \      '()\n      (append (fib (sub1 n))\n              (list n))))\n", "  (let\
    \ ([a 1 b 1])\n    (if (= n 0)\n        a\n        (fib n-1)\n        (set! (+\
    \ a b) (+ b (* a b))))))\n", "  (if (zero? n)\n      n\n      (fib \n       (-\
    \ n (car fibs))\n       (+ 1 (cdr fibs))\n       fibs)))\n", "  (define (f a b)\n\
    \    (cond\n      [(zero? b) a]\n      [(even? b) (f (+ a b) b)]\n      [(odd?\
    \ b) (f a (b - 1))]))\n  (f (+ a 1) (- n 1)))\n", "  (cond [(< n 2)      1]\n\
    \        [(= n 0)      1]\n        [(= n 1)      1]\n        [else         (+\
    \ (fib (- n 2)) (fib (- n 1)))))]\n", "  (let ([a (const (+ 1 2) 1)\n        b\
    \ (const (+ 2 1) 1)\n        c (const (+ 1 1) 1)])\n    (if (= n 0)\n        a\n\
    \        (+ (fib n) (c (* n a) (* n b)))\n      )))\n", "  (if (<= n 2)\n    \
    \  n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(zero? n) (error \"\
    n must be positive\")\n         (and (<= 1 n) (<= 2 n))\n         (and (<= 2 n)\
    \ (<= 3 n))\n         (and (<= 3 n) (<= 5 n))\n         (and (<= 5 n) (<= 8 n))\n\
    \         (and (<= 8 n) (<= 13))\n         (and (<= 13) (<= 21))]\n        [else\
    \ (+ (fib (sub1 n))\n                   (fib (sub1 n)))]))", "  (cond\n    [(=\
    \ n 0) 1]\n    [else (+ (fib n-1) (fib n-2)) ]))\n", "  (let ([a 1])\n    (let\
    \ ([b 2])\n      (cond [(zero? n) a]\n            [(zero? (add1 n)) b]\n     \
    \       [(zero? (add1 n)) (+ a (+ b b))]\n            [else (+ a (+ b b))])))))\n",
  "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (-\
    \ n 2)))]))\n", "  (cond [(< n 2) 1]\n        [else (+ (fib (- n 1)) (fib (- n\
    \ 2)))]))\n", "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n\
    </cell>\n<text>\nA language with both function definitions and expressions.\n\n\
    \n</text>\n<cell>", "  (if (= n 0)\n      1\n      (+ (fib (- n 1)) (fib (- n\
    \ 2)))))\n", "  (cond ((= n 1) 1) ;; base case\n        ((= n 2) 1)\n        (else\
    \ (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (define (iter n a b)\n    (cond [(=\
    \ n 0) a]\n          [(= n 1) b]\n          [(= n 2) (iter (- n 1) (+ a b) b)]\n\
    \          [else\n           (iter (- n 1) a (b a))]))\n  (iter n () 0))\n", " \
    \ (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (=\
    \ n 0) 0\n      (if (= n 1) 1\n          (+ (fib (- n 1)) (fib (- n 2))))))\n\
    </cell>\n<text>\nExercise", "  (define (fibs start limit)\n    (cond [(> start\
    \ limit) 0]\n          [(< start limit) start]\n          [else (fibs (+ start\
    \ 1) (+ limit 1))]))\n  (fibs 0 n))\n", "  (cond [(= n 0) 1]\n        [else (+\
    \ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond [(= n 0) 1]\n        [else (+ 1\
    \ (fib (- n 1)))]))\n", "  (cond\n    [(= n 0) 1]\n    [(= n 1) 1]\n    [else\
    \ (+ (fib (- n 1)) ((fib (- n 2)) 1))]))\n", "  (cond [(= n 0) 1]\n        [else\
    \ (+ (fib (- n 1))\n                 (fib (- n 2)))]))\n", "  ((if (= n 0)\n \
    \   1\n    (+ (fib (- n 1))\n       (fib (- n 2)))\n  )\n)\n", "  (let ([a (+\
    \ (* 2 a) (* 3 a))])\n    (if (< n 1)\n        a\n        (fib n-1))))\n", " \
    \ (let fibs (acc 1) (i (- n 1))\n    (if (= i 0)\n        acc\n        (fibs (+\
    \ (* acc acc) i)\n               (- i 1)))))\n", "  (if (< n 2)\n      n\n   \
    \   (fib n-1) (+ n (fib n-2))))\n", "  (let ([a (atom 0)\n        b (atom 1)\n\
    \        total (atom 0)]\n        [result (atom 0)])\n    (cond\n      [(= n 0)\
    \ (set! result a)]\n      [(= n 1) (set! result b)]\n      [(atomic? total) (set!\
    \ total a) (set! total b)]\n      [else (set! total (+ (fib n) a)) (set! total\
    \ (+ (fib n) b)) (set! result total)]))\n  result)\n", "  (let-values (((a b)\
    \ (cond [(< n 1) 1]\n                              [(< n 2) 1]\n             \
    \                 [(< (- n 1) 1) (+ (fib (- n 1)) (fib 1))]\n                \
    \              [(< n 2) (+ (fib (- n 2)) (fib 1))]\n                         \
    \     [else (+ (fib (- n 2)) (fib 1))])))\n    (+ a b)))\n", "  (cond [(= n 0)\
    \ 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 2)) (fib (- n 1))))))\n",
  "  (cond [(zero? n) 1]\n        [(= n 2) 1]\n        [(= n 3) 2]\n        [(> n\
    \ 0) (+ (fib (- n 1)) ((fib (- n 2)) 0))]))\n", "  (cond\n    ((= n 0) 0)\n  \
    \  ((= n 1) 1)\n    (else (+ (fib (- n 2)) (fib (- n 1))))))\n", "  (if (<= n\
    \ 2)\n      n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(< n 1) 1]\n\
    \        [(< n 2) 2]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n", " \
    \ (if (< n 2) 1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond\n    ((=\
    \ n 0) 1)\n    ((< n 1) 1)\n    (else (+ (fib (- n 1)) \n            (fib (- n\
    \ 2))))))\n", "  (* (+ 1 n) (fib n-(n+1))))\n", "  (cond [(= n 0) 1]\n       \
    \ [(= n 1) 1]\n        [else (+ (fib 1 (- n 1)) (fib 2 (- n 1))))))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n",
  "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (<=\
    \ n 1)\n      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n</code>\n<|/ a |>\n\
    <| c |>\nWhy is the tail recursion necessary?  Doesn't `(fib n)` just call the\
    \ same function over and over with different `n` arguments?\n<|/ c |>\n<| c |>\n\
    The tail recursion allows the algorithm to recurse without using the stack (because\
    \ it doesn't care what the result of the function would be).\n<|/ c |>\n<| c |>\n\
    Oh, and `(fib 10)` returns 55 just fine.  `(fib 8)` returns 21 too.\n<|/ c |>\n\
    <| c |>\nYes, it just calls another instance of the same function with different\
    \ `n`. That way, the recursion will happen without consuming any stack space.\n\
    <|/ c |>\n<| a tags=scheme,tail-recursion,racket,fibonacci |>\nYes, Racket's tail\
    \ recursion can be implemented using tail recursion by returning something from\
    \ the tail.  In Scheme, it's also possible to write an iterative version of fibonacci\
    \ using recursion.  A quick search yields this implementation in Racket:\n<code>",
  "  (let loop ((x 1) (y 2))\n    (if (= n 0)\n        x\n        (loop (+ x y) n))))\n",
  "  (if (= n 1) 1 (+ 1 (fib (- n 1)))))\n", "  (cond ((= n 0) 1)\n        ((= n 1)\
    \ 1)\n        ((= n 2) 1)\n        ((even? n) (+ (fib(/ n 2)) (fib(/ n 3))))\n\
    \        (else (+ (fib(/ n 2)) (fib(/ n 3))))))\n", "  (cond [(< n 0) 0]\n   \
    \     [(= n 1) 1]\n        [else\n         (+ (fib (- n 1)) (fib (- n 2)))]))\n",
  "  [(define (fib a b)\n    (if (= b 0)\n        a\n        (fib b (+ a b))))\n \
    \  \n   (fib (+ (fib 0 1) (fib 1 1))\n        (- n 1))])", "  (cond ((= n 0) 1)\n\
    \        ((= n 1) 1)\n        ((= n 2) 2)\n        (else (+ (fib (- n 1))\n  \
    \               (fib (- n 2))))))", "  (cond [(< n 1) 1]\n        [else (+ (fib\
    \ (sub1 n)) (fib (sub2 n)))]))\n", "  (let ([a 0])\n    (lambda ()\n      (set!\
    \ a (+ a 1))\n      (set! n (- n 1))\n      a)\n    ))\n", "  (fibonacci-iter\
    \ n 0 1 1))\n", "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n        (else (+ (fib\
    \ (- n 1)) (fib (- n 2))))))\n</code>\n<|/ a |>\n<| c |>\nI'm afraid your definition\
    \ of Fibonacci numbers is wrong. The correct definition is \"the nth Fibonacci\
    \ number\", not \"a Fibonacci number\". There are no \"the\" Fibonacci numbers,\
    \ just those numbers that appear in Fibonacci sequence.\n<|/ c |>\n<| c |>\nI\
    \ guess I misunderstood your definition of Fibonacci numbers. I think I understand\
    \ now, and I've added a simpler definition of Fibonacci numbers to the answer.\n\
    <|/ c |>\n<| c |>\nThis definition is correct but a bit more elegant than my answer.\
    \ :)\n<|/ c |>\n<| c |>\nIf I'm reading this correctly, this is the same as the\
    \ [Euler #3](https://en.wikipedia.org/wiki/Fibonacci_number#Euler_3) algorithm\
    \ for calculating Fibonacci numbers, only in a different form.\n<|/ c |>\n<| c\
    \ |>\nNope, this is the [Euler #50](https://en.wikipedia.org/wiki/Fibonacci_number#Euler_50)\
    \ algorithm. Notice how it starts with `0`, not `1`. The `1`s here are for \"\
    the previous number of the sequence\".\n<|/ c |>\n<| a |>\nYou will want to use\
    \ recursion to implement a Fibonacci sequence.  The first and last numbers in\
    \ the sequence will be 0 and 1, respectively, but that doesn't matter since we'll\
    \ be adding 1 anyways.  Recursion can be very useful for these types of problems.\
    \  Here is an example of a recursive fibonacci function:\n<code>", "  (cond [(<\
    \ n 0) (error 'fib n)]\n        [(= n 1) 1]\n        [(= n 2) 1]\n        [else\
    \ (+ (fib n-1) (fib n-2)) ]))\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n\
    \          1\n          (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (cond [(= n\
    \ 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n\
    </code>\nTo understand it better, you can read it as: cond that checks if the\
    \ n-th Fibonacci number is equal to the number 0 or 1.\n<|/ a tags=scheme,fibonacci\
    \ |>\n<| a tags=scheme,fibonacci |>\nI realise this is probably a bit too late\
    \ to help you, but as it's one of the first results when I google the question,\
    \ I'm posting this anyway.\nThe answer posted by Carsten already has the best\
    \ approach, but in order for it to be the most efficient (O(1) time instead of\
    \ O(n)), you need the following modifications:\n\nDon't calculate the fibonacci\
    \ number up to n before you know that n exists.\nDon't calculate fibonacci numbers\
    \ beyond n-1.\n\nThis is because if you try to compute fibonacci numbers up to\
    \ n using the following recursive formula (this is what a recursive function would\
    \ look like), you're going to end up doing O(n^2) work.\nHere's a piece of code\
    \ that does this, and it computes the fibonacci numbers up to 100 in less than\
    \ a second:\n<code>", "  (if (= n 1)\n      1\n      (+ (fib n) (fib n-1)))) ;;\
    \ #lang racket\n", "  (fibonacci n 1 0))\n", "  (if (<= n 0)\n      1\n      (+\
    \ (fib (- n 1)) (fib (- n 2)))))\n</textarea></form>\n    <script>\n      var\
    \ editor = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n    \
    \    lineNumbers: true,\n        matchBrackets: true,\n        mode: \"text/x-racket\"\
    \n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong> <code>text/x-racket</code>.</p>\n\
    \n    <p>Development of the CodeMirror <tt>racket-mode</tt> on GitHub can be found\
    \ <a href=\"https://github.com/marijnh/CodeMirror/compare/4.11.0...4.12.0\">here</a>.</p>\n\
    \  </article>\n\n<|/ file |>\n<| c |>\nThe GitHub commit link is not working anymore,\
    \ could you please fix it?\n<|/ c |>\n<| c |>\nIt appears to have been fixed (possibly\
    \ by another author). You can try it again here: https://github.com/marijnh/CodeMirror/blob/master/LICENSE\n\
    <|/ c |>\n<| a dscore=5 tags=racket,codemirror |>\nFor those who don't like writing\
    \ HTML, here's the same thing in a plain JavaScript approach:\n<code>\n<textarea\
    \ id=\"code\" style=\"height: 250px;\">;; Return n-th Fibonacci number.", "  (cond\n\
    \    [(or (= n 1) (= n 2)) (- n)]\n    [else (+ (fib (- n 2)) (fib (- n 1)))]))\n",
  "  (if (zero? n)\n      0\n      (+ (fib (- n 2)) (fib (- n 1)))))\n", "  (cond\
    \ [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+ (fib (- n 1)) \n        \
    \      (fib (- n 2))))]))\n", "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n    \
    \    (else (+ (fib (- n 2)) (fib (- n 1))))))\n", "  (let* ((a (- n 1)) (f (+\
    \ a a)))\n    (if (= n 1)\n        f\n        (fib n) (* f f))))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n\
    </code>\n<|/ a tags=racket,scheme dscore=2 |>\n<| c |>\nHi Gentlemen, Thanks a\
    \ lot for your quick reply. I have tried your code and it works fine. Can you\
    \ also help me understand what this piece of code does `(fib (- n 2))` ?\n<|/\
    \ c |>\n<| c |>\nThis recursively calls itself with decrementing `n` until it\
    \ reaches zero. `fib` is called with arguments that make it go down to zero. This\
    \ technique is called the \"divide and conquer\" technique, although I wouldn't\
    \ say it is the best way for beginners to learn Scheme. The other way to write\
    \ the function would be `(let ([a 1] ((lambda (n a) (if (zero? n) a (+ a (fib\
    \ n))))) 1))`. This would be clearer for beginners, but is basically the same\
    \ thing.\n<|/ c |>\n<| c |>\nAlso, FYI, it would be more idiomatic to write `[else\
    \ (+ a b)] instead of `(+ a b)`. The former is a list that has two elements, the\
    \ second is an expression that evaluates to that list. The second is more commonly\
    \ used with `if`, where it evaluates to the result of the `else` clause if and\
    \ only if the `if` expression is false. `(+ a b)` is rarely used in Scheme because\
    \ it can be written `+ a b`.\n<|/ c |>\n<| c |>\nThanks a lot, now I got it how\
    \ it works.\n<|/ c |>\n<| a tags=racket,scheme |>\n<code>", "  (cond [(= n 0)\
    \ 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond [(zero? n)\
    \ 1]\n        [(one? n) 1]\n        [else (+ (fib (sub1 n)) (fib (sub1 n)))]))\n",
  "  (if (= n 0)\n      1\n      (+ (fib (- n 1)) (* (fib n) (n+1)))))\n", "  (cond\n\
    \    ((= n 1) 1)\n    ((= n 2) 1)\n    ((even? n) (+ (fib (- n 2)) 1))\n    (else\
    \ (+ (fib (- n 1)) ((fib (- n 2)) 1)))))\n</code>\nThis code is more efficient\
    \ than the recursive version. \nIt is also clearer. Just use an if statement.\n\
    <|/ a tags=fibonacci,racket,scheme |>\n<| c |>\nCan you explain why you think\
    \ that *this* code is more efficient?  I haven't heard of \"tail recursion elimination\"\
    \ before, so I wonder what the difference is (if any) between this and using loops.\n\
    <|/ c |>\n<| c |>\nThe algorithm above is faster, no matter what language is used.\
    \ It's tail recursion elimination is a compiler feature. With Scheme, it is enabled\
    \ by default. [This question](http://stackoverflow.com/questions/7113286/does-the-racket-implement-tail-recursion)\
    \ is a good reference. [This video](http://www.youtube.com/watch?v=Rh7jfVWlK1g)\
    \ explains how to enable it. In scheme, it is usually not enabled by default.\
    \ Here is a [link](http://en.wikipedia.org/wiki/Tail_call) explaining how tail\
    \ recursion works in different languages.\n<|/ c |>\n<| c |>\nThe performance\
    \ difference is due to the use of an internal \"loop\".  In your example, you\
    \ have to use a tail call *and* an internal loop.  Your recursive function does\
    \ both.\n<|/ c |>\n<| c |>\nOh I see - I missed that - thanks. So if I understand\
    \ correctly, the loop will eventually run without stack overflow, but if the recursion\
    \ is implemented with a loop, then the loop will run until the stack overflows.\
    \ Is that correct?\n<|/ c |>\n<| a dscore=4 |>\nAnother option would be to write\
    \ an iterative solution, using the racket/recur package which implements a version\
    \ of a tail recursion optimisation.\n<code>\n#lang racket\n", "  (cond\n    [(<\
    \ n 0) (error \"n must be non-negative integer\")]\n    [(= n 1) 1]\n    [(= n\
    \ 2) 1]\n    [else (+ (fib n) (fib n-1))]))\n", "  (cond [(= n 1) 1]\n       \
    \ [else (+ fib (- n 1)) (* n (fib (- n 1)))]))\n", "  (if (< n 0) 0\n      (+\
    \ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (if (= n 0)\n      1\n     \
    \ (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (let* ([result (+ (* 3 (fib 1))\n \
    \                    (* 2 (fib 0)))]\n         [result (modulo result n)]\n  \
    \       [result (modulo (+ result 1) n)])\n    (cond\n      [(= n 1) result]\n\
    \      [(< n 2) result]\n      [(< n n) result])))\n", "  (define (fib-helper\
    \ a b)\n    (if (zero? b)\n        a\n        (fib-helper (+ a b) (- b 1))))\n\
    \  (fib-helper 1 1 n))\n", "  (if (zero? n)\n      1\n      (+ (fib (- n 1))\n\
    \         (fib (- n 2)))))\n", "  (if (< n 2)\n      1\n      (+ (fib (- n 1))\
    \ (fib (- n 2)))))\n</code></pre>\n<p>The above code is a recursive implementation\
    \ of a simple Fibonacci function. The algorithm is fairly simple: <code>fib(n)</code>\
    \ is the function that returns the nth fibonacci number - it calls <code>fib(n\
    \ - 1)</code> and <code>fib(n - 2)</code> recursively, until <code>fib(0)</code>.\
    \ The difference between this implementation and other implementations of fibonacci\
    \ numbers is that it does not cache the intermediate results. This is because\
    \ recursive functions are often not able to cache their results, if they call\
    \ themselves repeatedly. Hence, they are called very often.</p>\n<p>The above\
    \ function can be rewritten in a more efficient version that caches the intermediate\
    \ results:</p>\n<pre><code class=\"hljs lang-racket\">;; Return n-th Fibonacci\
    \ number.", "  (let fib-iter ()\n    (if (= n 1)\n        1\n        (fib-iter\
    \ (+ 1 (fib 1))))))\n", "  (cond [(zero? n) 1]\n        [(even? n) (+ fib (- n\
    \ 2))]\n        [else (+ fib (- n 3))]))\n", "  (cond [(= n 1) 1]\n        [(=\
    \ n 2) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (let* ([a (-\
    \ (+ (* 2 n) 1) 1)\n         b (- (* 2 a n) 1)])\n    (+ a b)))\n", "  (if (<\
    \ n 1)\n      n\n      (+ (fib 2) (fib 1))))\n", "  (let/ec [a (make-fib n)]\n\
    \    (if (zero? n) (first a)\n      (fib (- n 1))\n      (+ (first a)\n      \
    \   (second a))))) ;; (first a)\n            ;; (second a)\n</code>\n\nOf course\
    \ this is also the base code from your previous question:\n<code>", "  (if (=\
    \ n 0)\n      0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (if\
    \ (< n 2)\n      n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (< n 2)\n\
    \      n\n      (+ (fib (- n 2)) (fib (- n 1)))))\n", "  (if (= n 1)\n      1\n\
    \      (+ (fib (- n 1)) (fib (- n 2)))))\n</cell>\n<code language=ocaml-jupyter>",
  "  (if (<= n 2)\n      n\n      (+ (fib (- n 2)) (fib (- n 1)))))\n</cell>\n<code\
    \ language=dyalog-kernel>", "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib\
    \ (- n 2)))))\n", "  (cond [(= n 0) 1]\n        [(< n 1) 1]\n        [else (+\
    \ (fib (- n 1)) \n                 (fib (- n 2))))))\n", "  (cond [(= n 0) 1]\n\
    \        [else (+ (fib (- n 1)) fib(- n 2))]))\n</code>\n<|/ a tags=racket,scheme,fibonacci,lisp\
    \ |>\n<| a tags=racket,scheme,fibonacci,lisp |>\nIf using Common Lisp, I would\
    \ do something like this:\n<code>", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n\
    \        [else (+ (fib (- n 1))\n                 (fib (- n 2))))]))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+ (fib\
    \ (- n 1)) (fib (- n 2)))]))\n", "  (if (zero? n)\n      1\n      (+ n (fib (sub1\
    \ n)))))\n", "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n\
    </cell>\n<code language=ocaml-jupyter>\n#require \"jupyter-js-widgets\"\n", " \
    \ (if (< n 2)\n      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond ((<\
    \ n 2) 1)\n        ((= n 2) 2)\n        ((< n (- 3 1)) (+ 3 (fib 3 (- n 1))))\n\
    \        (else (+ (fib (- n 2)) (fib 2 (- n 1))))))\n", "  (let loop ([x '(0 1)]\n\
    \             [n n])\n    (cond\n      [(= n 1) x]\n      [(< n 2) x]\n      [(=\
    \ (modulo x 3) 0) (loop (+ x (first x))\n                                (sub1\
    \ n))]\n      [else (loop (+ x (second x))\n                   (sub1 n))])))\n",
  "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nAwesome! But how can I use it in Scheme REPL? How do I\
    \ get an instance of the `fib number` function?\n<|/ c |>\n<| c |>\nTry `fib(10)`\
    \ on a regular interpreter.  That should give you the result you were looking\
    \ for.\n<|/ c |>\n<| c |>\nI've edited the answer with a bit more explanation\
    \ of what the `fib` procedure does.  Hopefully that helps you understand what's\
    \ happening.\n<|/ c |>\n<| c |>\nWhat if the answer should be returned as a string?\n\
    <|/ c |>\n<| c |>\n: To get the result as a string, you might want to check out\
    \ [this answer](http://stackoverflow.com/a/7331078/114963).\n<|/ c |>\n<| a tags=racket,scheme,fibonacci,lisp\
    \ dscore=3 |>\nI find this solution very readable:\n<code>", "  (cond [(= n 0)\
    \ 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))))])\n",
  "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n        (else (+ (fib (- n 1)) (fib (-\
    \ n 2))))))\n", "  (let ([a 1] [b 1])\n    (if (= n 0) a\n        (fib (- n 1))\n\
    \        (set! b (+ a b))\n        (b))))\n", "  (let fib-iter ([a 0] [b 1])\n\
    \    (cond\n      [(= n 0) a]\n      [(= n 1) b]\n      [else (fib-iter (+ a b)\
    \ b)]))\n  ", "  ;; Implementation inspired by https://stackoverflow.com/q/470084/499581\n\
    \  (cond\n    [(< n 0) 1]\n    [(= n 1) 1]\n    [else (+ (fib (sub1 n)) (fib (sub1\
    \ n)))]))\n", "  ;; Initialize fibs.\n  (define fib0 0 \n           (define fib1\
    \ (+ fib0 1))\n           (define fib2 (+ fib1 1))\n\n           fib0)\n\n  ;;\
    \ Find nth fibonacci number.\n  (define (fib-iter n fibs)\n    (if (< n 0)\n \
    \       0\n        (let ((next (fib-iter (- n 1) fibs)))\n          (+ fibs next))))\n\
    \n  ;; Return n-th fibonacci number.\n  (define (fib n)\n    (fib-iter n fibs))\n\
    )\n</cell>\n<code language=racket-kernel>", "  (cond [(= n 0) 1]\n        [(=\
    \ n 1) 1]\n        [else (+ (fib n-1) (fib n-2))]))\n", "  (cond ((= n 0) 1)\n\
    \        ((= n 1) 1)\n        (else (+ (fib (- n 1)) (fib (- n 2))))))\n", " \
    \ (cond [(zero? n) 1]\n        [(= (mod n 2) 0) (+ (fib (sub1 n)) (fib (sub1 n)))]\n\
    \        [else (fib n-1)]))\n", "  (cond ((= n 1) 1) ((= n 2) 2)\n        ((=\
    \ n 3) (+ (fib (- n 2)) (fib (- n 3))))\n        ((= n 4) 5 (+ (fib (- n 3)) (fib\
    \ (- n 4))))\n        (else (+ (fib (- n 2)) fib (fib (- n 3))))))\n", "  (if\
    \ (<= n 0) 0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (zero? n) 0\n\
    \      (if (= (mod n 2) 0) (+ (fib (- n 1))\n                            (fib\
    \ (- n 2)))\n          (+ (fib (- n 2))\n             (fib (- n 1))))))\n</code>\n\
    <|/ a tags=fibonacci,scheme |>\n<| a tags=fibonacci,scheme |>\nMy solution in\
    \ Racket:\n<code>\n#lang racket", "  (if (= n 1)\n      1\n      (+ (fib (- n\
    \ 1)) (* (+ 1 n) (fib (- n 2))))))\n</cell>\n<text>\n\u0417\u0430\u0434\u0430\u0447\
    \u0430 \u041C\u0410\u0420\u0410\n\u0414\u0430\u043D\u043E \u0442\u0430\u0431\u043B\
    \u0438\u0446\u044B \u043E\u043F\u0438\u0441\u0430\u043D\u044B \u043F\u043E \u0441\
    \u0442\u043E\u043B\u0431\u0446\u0430\u043C, \u043D\u0430 \u043A\u043E\u0442\u043E\
    \u0440\u044B\u0445 \u0441\u0442\u0440\u043E\u043A\u0438 \u044F\u0432\u043B\u044F\
    \u044E\u0442\u0441\u044F \u043F\u0440\u0438\u0437\u043D\u0430\u043A\u0438 \u0438\
    \ \u043E\u0441\u0442\u0430\u043B\u044C\u043D\u044B\u0435 \u044F\u0432\u043B\u044F\
    \u044E\u0442\u0441\u044F \u0441\u0442\u0440\u043E\u043A\u0430\u043C\u0438. \u0418\
    \ \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\
    \u0441\u0442\u0432\u043E \u0441\u0442\u0440\u043E\u043A \u0438 \u043A\u043E\u043B\
    \u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0442\u043E\u043B\u0431\u0446\
    \u043E\u0432 \u0434\u043B\u044F \u043F\u0440\u043E\u0441\u0442\u043E\u0442\u044B\
    \ \u0437\u0430\u0434\u0430\u0447\u0438 \u043A\u043E\u043E\u0440\u0434\u0438\u043D\
    \u0430\u0442\u043E\u0440\u0430.\n\n\n</text>\n<cell>", "  (if (zero? n)\n    \
    \  1\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n</cell>\n<cell>\n#lang\
    \ racket\n", "  (if (< n 2)\n      n\n      (+ (fib (- n 2)) (fib (- n 1)))))\n\
    </code>\nThe last bit of code is an example of how to use this recursive procedure\
    \ to compute a Fibonacci number:\n<code>\n#lang racket", "  ((lambda (x y z)\n\
    \     (if (= n 0)\n         x\n         (fib (- n 1) (+ x y) z))))\n 1 1 1))\n",
  "  ;; Return n-th Fibonacci number.\n  ;; >>> fib(10)\n  (if (= n 0)\n      1\n\
    \      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0)\n         (list\
    \ 0)]\n        [(= n 1)\n         (list 1)]\n        [else\n         (append (fib\
    \ (sub1 n))\n                 (fib (sub1 n)))]))\n", "  (let ([a 1])\n    (cond\
    \ ((= n 0) a)\n          ((= n 1) a)\n          ((= (- n 1) 0) (fib (- n 1) (+\
    \ a a)))\n          (else (fib (- n 1) (+ a a)))))) \n", "  (cond\n    [(= n 1)\
    \ 1]\n    [else (+ 1 (fib n-1) (fib n-2))]))\n", "  (cond [(= n 0)           \
    \ 1]\n        [(= n 1)            1]\n        [else              (+ (fib (sub1\
    \ n)) (fib (sub1 n)))]))\n", "  (let ((a 1)\n        (b 1))\n    (if (zero? n)\n\
    \        a\n        (let ((c (+ (* a b) (b (+ a b)))\n               (d (* a c))\n\
    \               (e (* c d)))\n          (set! b d)\n          (set! a c)\n   \
    \       (+ a e n b)))))\n", "  (if (zero? n)\n      1\n      (+ (fib (- n 1))\
    \ (fib (- n 2)))))\n", "  (if (< n 1) (error \"n out of range\" n))\n  (let ((a\
    \ 1)\n        (b 1))\n    (set! c (+ a b))\n    (if (= n 1) c a)\n    (set! c\
    \ (+ b a))\n    c))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [else\
    \ (+ (fib (- n 1)) \n                 (fib (- n 2)))))])\n", "  (if (= n 0) 0\n\
    \      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (= n 0)\n      0\n      (+\
    \ (fib (- n 1)) (fib (- n 2)))))", "  (cond\n    [(= n 0) 1]\n    [(= n 1) 1]\n\
    \    [else (+ (fib (- n 1)) (fib (- n 2)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
