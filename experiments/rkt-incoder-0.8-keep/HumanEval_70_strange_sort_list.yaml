name: HumanEval_70_strange_sort_list
language: rkt
prompt: "#lang racket\n\n;; Given list of integers, return list in strange order.\n\
  ;; Strange sorting, is when you start with the minimum value,\n;; then maximum of\
  \ the remaining integers, then minimum and so on.\n;; Examples:\n;; strange_sort_list([1,\
  \ 2, 3, 4]) == [1, 4, 2, 3]\n;; strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n\
  ;; strange_sort_list([]) == []\n(define (strange_sort_list lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n\
  \    (check-equal? (candidate (list 1 2 3 4)) (list 1 4 2 3))\n    (check-equal?\
  \ (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5)) (list 1 5 2 4 3))\n    (check-equal? (candidate (list 5 6 7 8 9 1))\
  \ (list 1 9 5 8 6 7))\n    (check-equal? (candidate (list 5 5 5 5)) (list 5 5 5\
  \ 5))\n    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate\
  \ (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5))\n    (check-equal? (candidate\
  \ (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2))\n    (check-equal? (candidate\
  \ (list 111111)) (list 111111))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? lst) lst]\n        [else (cons (min lst (max lst))\
    \ (strange_sort_list (rest lst)))]))\n", "  (cond\n    [(empty? lst) lst]\n  \
    \  [else (append (strange_sort_list (list (min lst))))\n          (append (strange_sort_list\
    \ (list (max lst))))\n          (append (strange_sort_list (list (min lst) (max\
    \ lst))))]))\n", "  (cond [(empty? lst) (empty)]\n        [(null? (rest lst))\
    \ lst]\n        [(equal? (first lst) (first (rest lst))) (strange_sort_list (rest\
    \ lst))]\n        [else (cons (first lst)\n                    (cons (first (rest\
    \ lst))\n                          (strange_sort_list (rest lst))))]))\n", " \
    \ ;; (define (strange_sort_list lst) ...)\n  (cond [(empty? lst) empty]\n    \
    \    [else\n         (append (append\n                 (sublist lst 0 0)\n   \
    \              (sublist lst (* (length lst) 2) (length lst)))\n              \
    \   (sublist lst 0 0))]))\n</cell>\n<code language=racket-language>", "  (if (empty?\
    \ lst)\n      '()\n      (append (map min-lst (rest lst))\n              (map\
    \ max-lst (rest lst))\n              (map min-lst (rest lst))))))\n", "  (if (empty?\
    \ lst)\n      '()\n      (append (list lst (apply sort (tail lst))\n         \
    \            (apply sort (tail (reverse lst)))\n                     (apply sort\
    \ (tail (reverse (apply sort (tail lst))))))\n              strange_sort_list\
    \ (cdr lst)))\n</cell>\n<code language=other-env>\n#lang racket\n", "  (let loop\
    \ ((lst (reverse lst)))\n    (if (null? lst)\n        '()\n        (cons (car\
    \ lst)\n              (loop (cdr lst))))))\n", "  (if (null? lst)\n      '()\n\
    \      (append (cons (min lst) lst)\n               (strange_sort_list (sort (max\
    \ lst) strange_sort_list)))))\n", "  (sort lst +))\n", "  (if (null? lst)\n  \
    \    '()\n      (cons (min lst)\n            (strange_sort_list (max lst)\n  \
    \                            (min lst)))))\n", "  (let loop ((lst lst)\n     \
    \        (res ()))\n    (if (null? lst)\n        res\n        (loop (cdr lst)\n\
    \              (cons (first lst) (loop (rest lst)\n                          \
    \              (cons (first lst) res)))))))\n", "  (if (empty? lst)\n      lst\n\
    \      (let ([min (first lst)])\n        (cons (min strange_sort_list (rest lst))\
    \ (min strange_sort_list (rest lst)))))\n  )\n", "  (cond\n    [(empty? lst) (empty)]\n\
    \    [else (append (cons (first lst) (first (rest lst))) (strange_sort_list (rest\
    \ lst)))]\n    ))\n", "  (cond [(empty? lst) '()]\n        [(> (car lst) (cadr\
    \ lst)) (cons (cadr lst) (strange_sort_list (cdr lst)))]\n        [else (cons\
    \ (car lst) (strange_sort_list (cdr lst)))]))\n", "  (sort lst strange-sort))\n\
    \  ", "  (if (null? lst)\n      '()\n      (cons \n       (sub1 (sort (sub1 (reverse\
    \ lst))))\n       (strange_sort_list\n        (sub1 (sort (sub1 (reverse (sub1\
    \ lst)))))))))\n", "  (if (null? lst)\n      '()\n      (append (sort (subseq\
    \ lst 0 (length lst)) <)\n                (sort (subseq lst 1 (length lst)) <)\n\
    \                (sort (subseq lst 2 (length lst)) <)\n                (sort (subseq\
    \ lst 3 (length lst)) <))))\n", "  (define (helper lst curr curr-max curr-min)\n\
    \    (cond ((null? lst)\n           (list curr))\n          ((> curr-max curr)\n\
    \           (cons curr curr-max))\n          ((< curr-min curr)\n           (cons\
    \ curr curr-min))\n          (else\n           (helper (cdr lst)\n           \
    \        (cons (car lst)\n                        curr)\n                   (max\
    \ curr (car lst))\n                   (min curr (car lst))))))\n\n  (helper lst\
    \ (car lst) (car lst) (car lst)))\n", "  (if (empty? lst)\n      '()\n      (let\
    \ ([min (first lst)])\n        (let ([max (first lst)])\n          (if (> (first\
    \ lst) min)\n              (cons min (strange_sort_list (rest lst)))\n       \
    \       (cons max (strange_sort_list (rest lst))))))))\n", "  (cond\n    [(empty?\
    \ lst)\n     (empty-list)\n     (cons nil (reverse (empty-list nil)))]\n    [else\
    \ (cons\n            (strange_sort_list (sub1 (min-v (rest lst)))\n          \
    \                    (max-v (rest lst)))\n            (strange_sort_list (min-v\
    \ (rest lst))\n                              (max-v (rest lst)))\n           \
    \ (strange_sort_list (sub1 (min-v (rest lst)))\n                             \
    \ (max-v (rest lst)))))]))\n", "  (strange_sort_list_aux lst '()))\n", "  (cond\n\
    \    [(empty? lst) lst]\n    [(null? (cdr lst)) (cons (car lst) '())]\n    [else\
    \ (let ([first (car lst)])\n            (strange-sort-list (cdr lst))\n      \
    \      (cons (cons first second) (cons (car lst) '())))]))\n", "  (cond\n    [(empty?\
    \ lst) '()]\n    [(null? (rest lst)) lst]\n    [(< (first lst) (rest (rest lst)))\n\
    \     (append (strange_sort_list (rest lst)) (list (first lst)))]\n    [else (strange_sort_list\
    \ (rest lst)) (list (first lst))]\n  ))\n", "  (cond\n    [(null? lst) lst]\n\
    \    [else (append (list (min (head lst))\n                         (max lst))\n\
    \                 (strange_sort_list (rest lst))]))\n)\n", "  (if (empty? lst)\n\
    \      (list empty)\n      (let ([smallest (first lst)]\n            [rest (rest\
    \ lst)])\n        (cons (min (append rest \n                           (list (max\
    \ smallest)))) \n              (strange_sort_list (rest lst)))))\n  )\n  \n",
  "  (let loop ([lst lst])\n    (if (null? lst)\n        '()\n        (let ([smallest\
    \ (car lst)\n                biggest (cadr lst)\n                sorted (loop\
    \ (cdr lst))])\n          (cons smallest sorted)))))\n</code>\nThe code uses three\
    \ functions:\n\nrecursion to sort the list\nlet construct to create new lists\n\
    cons to put them together\n\nIn addition, you could use this same approach to\
    \ make a variation of your function to return a list of numbers in an ascending\
    \ order.\n<code>", "  (cond [(empty? lst) lst]\n        [(< (first lst) (first\
    \ rest)) (rest strange_sort_list (rest lst))]\n        [else (strange_sort_list\
    \ (rest lst) (rest lst))]))\n", "  (cond\n    [(empty? lst)\n     lst]\n    [else\n\
    \     (append (first lst)\n            (strange_sort_list (rest lst))\n      \
    \      (first lst))]))\n", "  (if (empty? lst) '()\n      (let ([head (first lst)])\n\
    \        (if (<= head (first lst))\n            (strange_sort_list (rest (rest\
    \ lst)))\n            (append (list (first lst)) (strange_sort_list (rest (rest\
    \ lst))))))))\n", "  (if (empty? lst)\n      '()\n      (let ([min (first (sort-by\
    \ (lambda (x) (> (x lst) min)) lst))])\n        (append (map first (sort-by (lambda\
    \ (x) (< (x min) x)) lst))\n                (map first (sort-by (lambda (x) (<\
    \ (x min) x)) (sort-by (lambda (x) (> (x lst) min)) lst)))))))\n</code>\nAnd here\
    \ is the output of a run of your example:\n<code>\nWelcome to Racket v6.0.1.\n\
    > \n> (define (strange-sort-list lst)\n    (if (empty? lst)\n        '()\n   \
    \     (let ([min (first (sort-by (lambda (x) (> (x lst) min)) lst))])\n      \
    \    (append (map first (sort-by (lambda (x) (< (x min) x)) lst))\n          \
    \        (map first (sort-by (lambda (x) (< (x min) x)) (sort-by (lambda (x) (>\
    \ (x lst) min)) lst))))))\n#<procedure>\n> (strange-sort-list '(3 2 1 4))\n'(1\
    \ 2 3 4)\n> (strange-sort-list '(5 5 5 5))\n'(5 5 5 5)\n> (strange-sort-list '())\n\
    '()\n> (define (strange-sort-list lst)\n    (if (empty? lst)\n        '()\n  \
    \      (let ([min (first (sort-by (lambda (x) (> (x lst) min)) lst))])\n     \
    \     (append (map first (sort-by (lambda (x) (< (x min) x)) lst))\n         \
    \         (map first (sort-by (lambda (x) (< (x min) x)) (sort-by (lambda (x)\
    \ (> (x lst) min)) lst))))))\n#<procedure>\n> (strange-sort-list '(3 2 1 4))\n\
    '(1 2 3 4)\n> (strange-sort-list '(5 5 5 5))\n'(5 5 5 5)\n> (strange-sort-list\
    \ '())\n'()\n> (define (strange-sort-list lst)\n    (if (empty? lst)\n       \
    \ '()\n        (let ([min (first (sort-by (lambda (x) (> (x lst) min)) lst))])\n\
    \          (append (map first (sort-by (lambda (x) (< (x min) x)) lst))\n    \
    \              ", "  (let ([min-elem (first lst)])\n    (cond [(empty? lst) lst]\n\
    \          [(= min-elem (first lst)) (cons min-elem lst)]\n          [else (cons\
    \ (first lst) (append (strange_sort_list (sort (rest lst))) (sort (sort (sort\
    \ min-elem (rest lst)))))])))\n  \n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the rest of the list\n  ; \"(sort (sort (sort min-elem (rest lst)))))\"\
    \ sorts the ", "  (define (helper lst minVal maxVal)\n    (if (null? lst)\n  \
    \      lst\n        (helper (cdr lst)\n                (if (< minVal maxVal)\n\
    \                    (first lst)\n                    maxVal)\n              \
    \  (first lst)))\n    (helper (cdr lst)\n            (if (< minVal maxVal)\n \
    \               (first lst)\n                maxVal)\n            (first lst)))\n\
    \  (helper lst lst (car lst)))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n\
    <| c |>\nThe point is that the input list should be sorted in-place, using the\
    \ usual comparison mechanism, with the first element in the list being the minimum\
    \ element in the list. The first call to this function should return `lst`.\n\
    <|/ c |>\n<| c |>\nThis isn't what the OP wanted.\n<|/ c |>\n<| c |>\nOP's comment\
    \ is \"The input list should be sorted in-place, using the usual comparison mechanism,\
    \ with the first element in the list being the minimum element in the list\".\n\
    <|/ c |>\n<| c |>\nNo, I mean the OP wants a sorted list, not a sorted *pointer*\
    \ to the list. That is, `(strange_sort_list '(1 2 3 4))` should return `'(1 3\
    \ 2 4)`.\n<|/ c |>\n<| c |>\nI'm sorry, this doesn't answer my question at all.\
    \ The output should be the list itself and not a pointer to the list.\n<|/ c |>\n\
    <| a dscore=0 |>\nA simple recursive solution is the following (assuming that\
    \ the input list contains no duplicate numbers):\n<code>", "  (define (helper\
    \ l acc count)\n    (cond\n      [(empty? l) acc]\n      [else (helper (rest l)\
    \ (cons (first l) (first acc)) (+ 1 count))]))\n  (helper (reverse lst) empty\
    \ 0))\n", "  (if (null? lst)\n      '()\n      (cons (max (rest lst))\n      \
    \      (strange_sort_list (rest lst)))))\n", "  (define (next index)\n    (cond\
    \ [(null? lst) lst]\n          [(< lst index) (cons index lst)]\n          [(>\
    \ lst index) (cons (car lst) (next (+ index 1)))]))\n  (next (length lst)))\n",
  "  (if (empty? lst)\n      '()\n      (append (max (rest lst))\n              (max\
    \ lst)\n              (min)\n              (strange_sort_list (rest lst)))))\n",
  "  (cond\n    [(empty? lst) lst]\n    [else\n     (let ([smallest (car lst)]\n \
    \          [largest (cdr lst)])\n       (concat (reverse (strange_sort_list (append\
    \ (reverse smallest) largest))) (append smallest largest))]))]))\n", "  (if (null?\
    \ lst)\n      '()\n      (append (sort lst)\n              (strange_sort_list\
    \ (sort (subseq lst 0 1) (lambda (x y) (compare y x)))))))\n", "  (let loop ((lst\
    \ lst)\n             (acc '()))\n    (cond [(null? lst) acc]\n          [else\n\
    \           (loop (cdr lst)\n                 (cons (min lst)\n              \
    \        (loop (rest lst)\n                            (cons (max lst)\n     \
    \                             acc)))))]))\n</code>\n<|/ a dscore=2 tags=racket,sorting\
    \ |>\n<| a tags=racket,sorting |>\nThis is my solution:\n<code>", "  (let loop\
    \ ((lst lst)\n             (acc (reverse lst)))\n    (if (null? lst)\n       \
    \ acc\n        (loop (rest lst)\n              (cons (min acc) acc)))))\n", " \
    \ (cond\n    [(empty? lst) lst]\n    [(cons? lst) (cons (min (map max lst)) (strange_sort_list\
    \ (map min lst)))]\n    [else (error \"strange_sort_list: first argument must\
    \ be a list of integers\")]))\n</code>\n<|/ a dscore=2 tags=racket,sorting |>\n\
    <| a dscore=2 tags=racket,sorting |>\n<code>\n#lang racket", "  (if (empty? lst)\n\
    \      '()\n      (append (sort (first lst) (< second lst)) (sort (second lst)\
    \ (< first lst)) (sort (first lst) (< first lst))))))\n", "  (let ([i 0])\n  \
    \  (cond\n      [(empty? lst) lst]\n      [else (cons (min lst (sub1 (+ i 1)))\
    \ (cons max (sub1 (+ i 1))\n                                             (strange_sort_list\
    \ (sub1 lst))))]))))\n", "  (define (loop lst idx)\n    (cond\n      [(empty?\
    \ lst) (list)] \n      [(= idx 0) (cons (first lst) strange_sort_list (rest lst))]\n\
    \      [(< idx (car lst)) (loop (cdr lst) (- idx 1))]\n      [else (loop (cdr\
    \ lst) (+ idx 1))]))\n  (loop lst 0))\n", "  (cond [(empty? lst) empty]\n    \
    \    [else\n         (append (list (min lst))\n                 (list (max lst))\n\
    \                 (list (min lst))\n                 (list (max lst))))]))\n",
  "  (if (empty? lst)\n      '()\n      (append (reverse (car lst)) (strange_sort_list\
    \ (cdr lst)))))\n", "  (if (null? lst)\n      '()\n      (append (strange_sort_list\
    \ (first lst))\n               (list (max lst (rest lst)))\n               (list\
    \ (min lst (rest lst)))\n               (strange_sort_list (rest lst)))))\n",
  "  (fold-left (lambda (x y)\n               (let ((max (max x y)))\n           \
    \      (cond ((> max 0) (cons x max))\n                       ((< max 0) (cons\
    \ y max))\n                       (else (cons x y))))\n            (list nil)\n\
    \            lst))", "  (if (null? lst)\n      lst\n      (strange_sort_list\n\
    \        (append lst\n                (map (\u03BB (x) (min x lst)) (reverse (subseq\
    \ lst 1 lst)))\n                (map (\u03BB (x) (min x lst)) (reverse (subseq\
    \ lst lst)))\n                (map (\u03BB (x) (max x lst)) (reverse (subseq lst\
    \ 1 lst)))\n                (map (\u03BB (x) (max x lst)) (reverse (subseq lst\
    \ lst)))))))\n", "  (let loop ((lst (car lst))\n             (acc '()))\n    (if\
    \ (null? lst)\n        (reverse acc)\n        (loop (cdr lst)\n              (cons\
    \ (car lst)\n                    acc)))))\n", "  (cond\n    [(empty? lst) lst]\n\
    \    [(null? (rest lst)) (append lst (list lst))]\n    [else (append (strange_sort_list\
    \ (take lst 2)) (list (take lst)))]))\n", "  (if (null? lst)\n      '()\n    \
    \  (append (sort lst < ? <)\n               (reverse (sort lst > ? >))\n     \
    \          (sort lst (< ?) (> ?)))))\n", "  (if (null? lst)\n      lst\n     \
    \ (let ((mid (+ lst (/ 1 (length lst))))\n            (lst1 (strange_sort_list\
    \ (- lst mid))))\n        (append lst1 (list mid)))))\n", "  (cond\n    [(empty?\
    \ lst) (empty)]\n    [else (cons (min lst) (max lst) (min))])))\n", "  (cond\n\
    \    ((empty? lst) lst)\n    ((null? (car lst)) (strange_sort_list (cdr lst)))\n\
    \    ((< (car lst) (last (cdr lst)))\n     (strange_sort_list (cdr lst))\n   \
    \  (list (car lst) (last (cdr lst))))\n    ((> (car lst) (first (cdr lst)))\n\
    \     (strange_sort_list (cdr lst))\n     (list (first (car lst)) (cdr (cdr lst))))))\n",
  "  (if (empty? lst)\n      '()\n      (cons (max (rest lst))\n            (strange_sort_list\
    \ (sub1 (rest lst)))))) ;; <-- Here's the mistake\n</code>\nWhen you call max\
    \ (rest lst) it will return max of the remaining elements of the list, so the\
    \ list is now reversed. The next element will be the minimum.\n<code>", "  (if\
    \ (empty? lst)\n      '()\n      (let ([head (car lst)])\n        (append (strange_sort_list\
    \ (remove-if (lambda (x) (>= x head)) lst))\n                (list head)))))\n",
  "  (if (empty? lst)\n      '()\n      (append (list->strange-sort (first lst))\n\
    \              (strange_sort_list (rest lst)))))\n", "  (if (null? lst)\n    \
    \  lst\n      (append (max_element lst)\n              (max_element\n        \
    \       (filter #(< % (max_element lst)))\n               lst)))) \n", "  (if\
    \ (empty? lst)\n      '()\n      (append (rev-strange-sort lst)\n            \
    \  (rev-strange-sort (rev-strange-sort lst)))))\n  ;; (require '(rev-strange-sort))\n\
    \  ;; Reverse the strange sorting of list\n", "  (if (null? lst)\n      lst\n\
    \      (cons (min lst (car lst)) (max lst (car lst))\n            (min lst (car\
    \ lst)) (max lst (car lst))\n            (strange_sort_list (cdr lst)))))\n",
  "  (define (helper-function lst)\n    (let loop ((lst lst)\n                (acc\
    \ '())\n                (cur '()))\n      (if (null? lst)\n          acc\n   \
    \       (loop (cdr lst)\n                (cons (car lst)\n                   \
    \   (cons cur\n                            acc))\n                (append cur\
    \ (car lst))))))\n  (helper-function lst))\n", "  (define (sort lst acc)\n   \
    \ (if (empty? lst)\n      (reverse acc)\n      (sort (rest lst) (cons (min lst)\
    \ (sort lst acc))))))\n  (sort lst '()))\n", "  (if (null? lst)\n      '()\n \
    \     (append (sort lst strange-sort-func)\n               (strange-sort-list\
    \ (sort lst (comp strange-sort-func min))))))\n", "  (define (sort lst)\n    (cond\
    \ [(null? lst) lst]\n          [(<= (car lst) (cadr lst)) (sort (cdr lst))]\n\
    \          [else (cons (car lst) (sort (cdr lst)))]))\n  (sort lst))\n", "  (if\
    \ (empty? lst)\n      '()\n      (let ((head (car lst))\n            (tail (cdr\
    \ lst)))\n        (append (sort (sub1 head (sort (sub1 tail '()))))\n        \
    \        (sort (sub1 tail '())))\n        (sort (sub1 head '())))))\n</cell>\n\
    <code language=dyalog-kernel>", "  (cond\n    ((null? lst) '())\n    ((equal?\
    \ (first lst) (car lst))\n     (strange_sort_list (rest lst)))\n    ((< (first\
    \ lst) (car lst))\n     (append (strange_sort_list (rest lst)) (list (first lst))))\n\
    \    (else\n     (append (strange_sort_list (rest lst)) (list (first lst))))))\n",
  "  (cond [(empty? lst) empty]\n        [else (let [head (first lst)\n          \
    \          tail (tail lst)\n                    minv (first tail)\n          \
    \          maxv (first tail)]\n                (cond [(> head minv) (cons head\
    \ (strange_sort_list (cons minv tail)))]\n                      [(> head maxv)\
    \ (cons head (strange_sort_list (cons maxv tail)))]\n                      [else\
    \ (cons head (strange_sort_list (cons minv tail)))])))]))\n", "  (let ([min (first\
    \ lst)])\n    (cond\n      [(empty? lst) empty]\n      [(= min (first lst)) (cons\
    \ (first lst) (strange_sort_list (rest lst)))]\n      [else (cons min (strange_sort_list\
    \ (rest lst)))])))\n</code>\n<|/ a |>\n<| c |>\nThe only problem with the first\
    \ solution is that it will return an empty list if there are no numbers in the\
    \ list rather than throwing an error.\n<|/ c |>\n<| c |>\nYeah, but that's what\
    \ the OP wants: no error or return empty list.\n<|/ c |>\n<| c |>\nOh, my mistake,\
    \ I didn't read the question carefully enough. I'm removing the downvote.\n<|/\
    \ c |>\n<| c |>\nNice, though if you want to take advantage of [`fold`](http://www.scheme.com/tspl4/c2.html)\
    \ you'd have to do `(fold (lambda (a b) ...)` instead of `(let ([a ...) (...)`.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  (let ((min (first lst)))\n    (cond\n\
    \      [(empty? lst) empty]\n      [else (cons (first lst) (cons (min (first lst))\n\
    \                                     (strange_sort_list (rest lst))))])))\n",
  "  (cond [(empty? lst) '()]\n        [(null? (cdr lst)) (car lst)]\n        [(<\
    \ (car lst) (car (reverse lst)))\n         (cons (car lst) (strange_sort_list\
    \ (cdr lst)))]\n        [else (strange_sort_list (cdr lst))]\n        ))\n", " \
    \ (let loop ((lst lst) (acc '()))\n    (cond\n      [(empty? lst) (reverse acc)]\n\
    \      [(< head lst) (loop (tail lst) (cons head acc))]\n      [else (loop (tail\
    \ lst) (cons head acc))])))\n", "  (if (null? lst)\n      '()\n      (let ([minval\
    \ (car lst)]\n            [maxval (cdr lst)]\n            [minidx (position minval\
    \ lst)]\n            [maxidx (position maxval lst)])\n        (if (< minval maxval)\n\
    \            (recur\n             (append lst (list (reverse minval)))\n     \
    \        (reverse maxval)\n             (cons minval (reverse minidx))\n     \
    \        (cons maxval (reverse maxidx))\n             (append lst (list (reverse\
    \ maxval)))))))\n", "  (if (empty? lst)\n      '()\n      (cons (min lst)\n  \
    \          (strange_sort_list (sort (append (append lst min) max-fn)))))\n", " \
    \ (let loop ((result '())\n             (lst (sort lst)))\n    (cond\n      ((empty?\
    \ lst) '())\n      ((empty? (rest lst)) lst)\n      ((= (rest lst) '()) (cons\
    \ (first lst) result))\n      (else (loop (cons (first lst) result)\n        \
    \           (rest lst))))))\n</code>\n<|/ a |>\n<| c |>\nThis answer was very\
    \ helpful to me to learn how to make my own recursive procedure. Thank you!\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a tail recursive version that uses recursion-schemes.\n\
    <code>", "  (let loop ([lst lst]\n             [result '()])\n    (if (null? lst)\n\
    \        result\n        (loop (cdr lst)\n              (append result (car lst)))))\n\
    \  result)\n", "  (cond\n    [(empty? lst) (list)]\n    [else (append (append\
    \ (strange_sort_list (minimum lst))\n                      (strange_sort_list\
    \ (maximum lst)))\n                 (minimum lst))]))\n", "  (if (null? lst)\n\
    \      '()\n      (append (append (strange_sort_list (sort lst)))\n          \
    \     (strange_sort_list (sort (sort lst))))))\n", "  (if (empty? lst)\n     \
    \ lst\n      (let ([m (first lst)])\n        (append (strange_sort_list (rest\
    \ lst))\n                (list (max m (first lst)))))))\n", "  (if (null? lst)\n\
    \      lst\n      (cons (min lst (strange_sort_list (sort lst (\u03BB (x) (max\
    \ x 5))))) (max lst (strange_sort_list (sort lst (\u03BB (x) (min x 5)))))))\n\
    \  )\n)\n", "  (cond ((empty? lst) empty)\n        (else (append (map (fn [x]\
    \ (cons (min lst) x))\n                               (strange_sort_list (rest\
    \ lst)))\n                      (map (fn [x] (cons (max lst) x))\n           \
    \                   (strange_sort_list (rest lst)))))))\n</cell>\n<cell>", " \
    \ (cond\n    [(empty? lst) lst]\n    [else\n     (let ([minv (car lst)])\n   \
    \    (append (strange_sort_list (remove-minv lst))\n              (minv (car lst))))]))\n\
    </code>\n<|/ a |>\n<| c |>\n`strange_sort_list` has exponential time complexity\
    \ because `minv` is not a tail call.\n<|/ c |>\n<| c |>\nI see. How would you\
    \ make it tail recursive then?\n<|/ c |>\n<| c |>\n`minv` is not a tail call,\
    \ either. One of the conditions is that the result must be `list`. `minv` does\
    \ not depend on the input list. It can as well be replaced by `car lst`.\n<|/\
    \ c |>\n<| c |>\n- I think minv does depend on lst. Not in the general case, but\
    \ in this specific case. And you are not guaranteed that minv is in fact in the\
    \ tail position, either.\n<|/ c |>\n<| c |>\nYeah, I missed that. Still I think\
    \ `minv` is not a tail call. In the general case, yes, `minv` does depend on the\
    \ input list. But in the OP's case it doesn't, because the input list contains\
    \ only one element (which is always smaller). So the `minv` can simply be replaced\
    \ by `car lst`.\n<|/ c |>\n<| a tags=list,algorithm,recursion,tail-recursion,scheme\
    \ dscore=0 |>\nHere's my solution:\n<code>", "  (sort lst (lambda (x y)\n    \
    \         (< (cdr x) (cdr y)))))\n", "  (if (or (null? lst) (= (length lst) 0))\n\
    \      lst\n      (append (list (car lst))\n               (strange_sort_list\n\
    \                (filter (lambda (x) (> (car lst) x))\n                      \
    \ (rest (sort lst string<?)))))\n      )\n  )\n", "  (let loop ((lst lst)\n  \
    \           (res empty))\n    (cond [(empty? lst) (reverse res)]\n          [(<\
    \ (first lst) (rest lst))\n           (loop (rest lst)\n                 (cons\
    \ (first lst) res)))]\n          [(> (first lst) (rest lst))\n           (loop\
    \ (rest lst)\n                 (cons (first lst) res)))]\n          [else (loop\
    \ (rest lst)\n                     (cons (first lst) (cons (first lst) res)))]))))\n",
  "  (if (null? lst)\n      '()\n      (append (append (strange_sort_list (first lst))\n\
    \                     (second lst))\n              (first lst)\n             \
    \ (strange_sort_list (rest lst)))))\n", "  (cond [(empty? lst) lst]\n        [else\
    \ (let ([min\n                      (first lst)\n                      (max-list\
    \ lst)])\n                (sort (append min\n                               (reverse\n\
    \                                (cons max lst))))])))\n</code>\n<|/ a tags=scheme,racket,lisp,functional-programming,sorting\
    \ |>\n<| a |>\n<code>", "  (if (null? lst)\n      lst\n      (append (strange_sort_list\
    \ (sort lst))\n               (sort lst)\n               lst)))\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=0 |>\nI know I am late to the party. But, for those\
    \ who are still looking for an answer, here it is.\n<code>", "  (sort lst\n  \
    \      (lambda (x y) (< x y))\n        (lambda (x y) (> x y))))\n", "  (if (null?\
    \ lst)\n      '()\n      (let loop ((lst lst)\n                 (res '()))\n \
    \       (if (< 1 (length lst))\n            (loop (cdr lst)\n                \
    \   (cons (car lst)\n                         res))\n            (loop (cdr lst)\n\
    \                   (cons (car lst)\n                         res))))))\n</cell>\n\
    <cell>", "  (cond\n    [(empty? lst) '()]\n    [(< (first lst) (last lst)) (strange_sort_list\
    \ (reverse lst))]\n    [else (strange_sort_list (cons (first lst) (reverse lst)))]\n\
    \    )\n  )\n", "  (cond\n    [(empty? lst) empty]\n    [(cons? lst)\n     (let\
    \ ([min (car lst)]\n           (rest lst)\n           (max (strange-sort-list\
    \ (cdr lst))))]\n      (cons min (strange-sort-list (cons max (cdr rest)))))]))\n",
  "  (if (empty? lst)\n      '()\n      (let loop ((head (car lst))\n            \
    \     (rest (cdr lst))\n                 (tail '()))\n        (if (null? rest)\n\
    \            (append tail (list head))\n            (let ((minval (car rest))\n\
    \                   (maxval (car rest)))\n              (if (> minval head)\n\
    \                  (loop (car rest) (cdr rest) (append tail (list head)))\n  \
    \                (loop (car rest) (cons (car rest) tail) (list minval)))\n   \
    \           (loop (car rest) (cons (car rest) tail) (list minval))))))\n", " \
    \ (cond\n    [(empty? lst) '()]\n    [else (cons (min lst (strange_sort_list (rest\
    \ lst))) (max lst (strange_sort_list (rest lst))))]\n  )\n)\n", "  (cond\n   \
    \ [(empty? lst) (list ())]\n    [(null? (rest lst)) (list lst)]\n    [else (cons\
    \ (first lst)\n                (strange_sort_list\n                 (append\n\
    \                  (sort (rest lst) '<)\n                  (sort (rest lst) '>)\n\
    \                  (sort (first lst) '<)\n                  (sort (first lst)\
    \ '>))))]))\n", "  (let loop ((lst lst)\n             (i 0))\n    (cond [(null?\
    \ lst) lst]\n          [(> lst (first lst)) (append (list lst) (loop (rest lst)\
    \ (+ i 1)))]\n          [(< lst (first lst)) (loop (rest lst) (+ i 1))]\n    \
    \      [else (cons lst (loop (rest lst) (+ i 1)))]\n          )))\n", "  (let\
    \ loop ((i 0)\n             (list '()))\n    (if (< i (length lst))\n        (loop\
    \ (+ i 1) (cons (car lst) (loop (+ i 1) (cdr lst))))\n        list)))\n", "  (let\
    \ loop ((lst lst)\n             (acc '()))\n    (if (null? lst)\n        acc\n\
    \        (loop (cdr lst)\n              (cons (car lst)\n                    acc))))))\n\
    </code>\n<|/ a tags=scheme,racket,sorting |>\n<| c |>\nIt would be nice if you\
    \ could add some explanation to your answer.\n<|/ c |>\n<| a dscore=0 tags=scheme,racket,sorting\
    \ |>\nAn implementation similar to Raman's answer using recursion:\n<code>", " \
    \ (if (null? lst)\n      lst\n      (let ((first (car lst))\n            (second\
    \ (car lst)))\n        (if (< (second first) (second second))\n            (cons\
    \ first strange_sort_list (cons second lst))\n            (cons second strange_sort_list\
    \ (cons first lst))))))\n", "  (if (null? lst)\n      '()\n      (append (sort\
    \ lst)\n              (list (car lst)))))\n", "  (cond\n    [(empty? lst) '()]\n\
    \    [(null? (rest lst)) lst]\n    [else (cons (min lst (rest lst)) (min (rest\
    \ lst) (strange_sort_list (rest lst))))]))\n", "  (if (empty? lst)\n      '()\n\
    \      (append (apply strange-sort lst)\n               (apply strange_sort_list\
    \ (cdr lst)))))\n", "  (if (null? lst) '()\n      (if (< (car lst) (car (cdr lst)))\n\
    \          (strange_sort_list (cdr lst))\n          (strange_sort_list (cons (car\
    \ lst)\n                                (cons (car (cdr lst)) '())))))))\n", " \
    \ (if (null? lst)\n      '()\n      (append (strange_sort_list (filter (lambda\
    \ (x) (< x 5)) lst))\n               (filter (lambda (x) (> x 5)) lst)\n     \
    \          (list lst)\n               (strange_sort_list (filter (lambda (x) (<\
    \ x 5)) lst)))))\n", "  (cond\n    ((null? lst) lst)\n    ((null? (cdr lst)) lst)\n\
    \    ((> lst (car lst)) (string-append (string-append \"min\" (car lst)) (string-append\
    \ \"max\" (car lst))))\n    (else (strange_sort_list (cdr lst)))))\n</code>\n\
    Output:\n<code>", "  (if (or (null? lst) (= (length lst) 1))\n      lst\n    \
    \  (let ([minLst (sub1 lst)\n             maxLst (sub1 (reverse-list lst))\n \
    \            minEl (minimum minLst)\n             maxEl (maximum maxLst)])\n \
    \       (append (minEl (strange-sort_list maxLst))\n                (maxEl (strange-sort_list\
    \ minLst))\n                lst))))\n", "  (if (empty? lst) '()\n      (append\
    \ (list->tree (sort lst))\n              (list->tree (sort (list->list (rest lst)))))))\n",
  "  (let loop ([start (min lst)]\n             [end (max lst)])\n    (if (null? end)\n\
    \        #f\n        (if (= start end)\n            lst\n            (loop (cons\
    \ (car lst) start) (cdr lst)))))\n)\n", "  (if (null? lst)\n      '()\n      (append\
    \ (list (car lst))\n               (list (strange_sort_list (cdr lst)))\n    \
    \           (list (car lst)))))\n              ", "  (if (empty? lst)\n      '()\n\
    \      (let ([temp (first lst)])\n        (if (> (second lst) temp)\n        \
    \    (cons (first lst) (strange_sort_list (rest lst)))\n            (cons (first\
    \ lst) (cons (second lst) (strange_sort_list (rest lst))))))))\n", "  (define\
    \ (iter lst acc)\n    (if (null? lst)\n        acc\n        (iter (cdr lst) (cons\
    \ (car lst) acc))))\n  (iter lst '()))\n", "  (define (helper)\n    (cond\n  \
    \    [(empty? lst) empty]\n      [(< (first lst) last) (rest lst)]\n      [else\
    \ (cons (first lst) (strange_sort_list helper))]\n      ))\n  (helper lst))\n",
  "  (if (empty? lst)\n      (list)\n      (append (strange_sort_list (take-min-lst\
    \ lst))\n               (strange_sort_list (take-max-lst lst))\n             \
    \  (strange_sort_list (take-min-lst (rest-lst lst))))))\n", "  (cond\n    [(empty?\
    \ lst) empty]\n    [else (cons (min lst) (max lst) (min lst))]))\n", "  (cond\n\
    \    [(empty? lst) empty]\n    [(= (length lst) 2) (cons (car lst) (cons (car\
    \ lst) (empty)))]\n    [else\n     (let [head (first lst)\n           tail (rest\
    \ lst)\n           head (reverse head)]\n       (cons head (strange_sort_list\
    \ tail)))]))\n", "  (if (null? lst)\n      lst\n      (let ([min (first lst)\n\
    \             max (rest lst)\n             rest (strange_sort_list (rest lst))])\n\
    \        (cons (min lst)\n              (cons max (cons min rest))))))\n", " \
    \ (if (empty? lst)\n      '()\n      (append (cons (first lst) (strange_sort_list\
    \ (rest lst)))\n               (strange_sort_list (cdr lst)))))\n", "  (if (empty?\
    \ lst)\n      lst\n      (append \n      (sort lst)\n      (sort (lst-reverse\
    \ lst)))))\n</code>\nIn fact, my code can sort the list in descending order too.\
    \ But the key here is the append and sort operations.\n<|/ a tags=scheme,sorting\
    \ |>\n<| c |>\nWhy do you think my code is more efficient than the other solutions?\
    \ I think both are O(n^2) but mine is O(n), while your solution is O(n*logn).\n\
    <|/ c |>\n<| c |>\n: I agree with you. It is not O(n^2), but the cost of O(n)\
    \ append and sort, which should be O(n).\n<|/ c |>\n<| c |>\nYour solution is\
    \ O(n^2). You are doing a quadratic amount of work. Appending takes O(n) and sorting\
    \ takes O(n^2). Combining these two together is O(n^3). O(n^3) is more efficient\
    \ than O(n^2)\n<|/ c |>\n<| c |>\n: Thanks for your correction. I was thinking\
    \ the list concatenation cost is O(n). But I think `append` cost is O(n), and\
    \ the sort cost is O(n log n). Thanks again!\n<|/ c |>\n<| c |>\n`append` is O(n)\
    \ but `sort` itself is O(nlogn). Your solution is O(n^2) due to the append. By\
    \ the way your solution is not O(n^3) but O(n^2). `append` takes O(n) and `sort`\
    \ takes O(n^2) which is O(n^3)\n<|/ c |>\n<| a |>\nThe first thing I notice is\
    \ the (sort lst). (sort lst) takes a list as an argument but is supposed to return\
    \ a sorted list. It can be done with sort (sort lst), but it would be better to\
    \ use built-in procedures. So instead of sorting it (which takes O(nlogn)), just\
    \ reverse it (which takes O(n)).\nThen after that you call append which takes\
    \ O(n) so overall its O(n).\nSo overall your code can be refactored to \n<code>",
  "  (if (empty? lst)\n      '()\n      (append (rev-strange-sort (first lst)) (strange-sort_list\
    \ (rest lst)))))\n", "  (cond\n    [(empty? lst) '()]\n    [(< (first lst) (first\
    \ lst (rest lst)))\n     (cons (first lst) (strange_sort_list (rest lst)))]\n\
    \    [else (strange_sort_list (rest lst)\n                       (append (cons\
    \ (first lst) (first lst (rest lst))) \n                               (strange_sort_list\
    \ (rest lst)))]\n   ))\n", "  (if (null? lst)\n      '()\n      (append (strange_sort_list\
    \ (sort-reverse (sort-by identity lst)))\n              (list (first lst)))))\n",
  "  (let ([lst-copy (copy-list lst)])\n    (cond\n      [(null? (first lst-copy))\
    \ (map first lst-copy)]\n      [(> first lst-copy) (map second\n             \
    \                    (strange_sort_list (rest lst-copy)))]\n      [else (map third\n\
    \                   (strange_sort_list (rest lst-copy)))])))\n", "  (if (empty?\
    \ lst)\n      '()\n      (let ([m (car lst)\n            i 0]\n            ([lst\
    \ (cdr lst)])\n            [result '()])\n        (if (< i m) (cons m result)\n\
    \            (let ([temp (car lst)\n                    c (- (length lst) 1)]\n\
    \                  ([lst (cons (car lst) lst)])\n                  [result (cons\
    \ (car lst) result)])\n              (cond ((< c m) (cons m result))\n       \
    \             (else (cons (car lst) (cons temp (cons m result))))))))))\n", " \
    \ (if (null? lst)\n      '()\n      (append (min lst)\n               (max lst)\n\
    \               (min lst)\n               (strange_sort_list (rest lst)))))\n",
  "  (if (empty? lst)\n      '()\n      (cons \n        (min lst)\n        (strange_sort_list\
    \ (max lst))\n        (min lst))))\n", "  (if (empty? lst)\n      '()\n      (append\
    \ (strange_sort_list (sort (list-ref lst 0))\n                           (sort\
    \ (list-ref lst 1))\n                           (sort (list-ref lst 2)))\n   \
    \             (list (first lst) (last lst) (first lst)))))\n</cell>\n<text>\n\
    The racket-learning repository\nThe racket-learning repository is currently hosted\
    \ on Github on GitHub's Racket Gallery.\n\nThis repository is a collection of\
    \ \"learning programs\" for the Racket language.\n\nIt contains many examples\
    \ written in Racket. These examples are based on the first edition of the Racket\
    \ Programming Language book published in 1998.\n\nA learning program is defined\
    \ by a racket.rkt file containing one or more \"forms\" in the body of the file.\n\
    \nEach \"form\" defines a single \"object\" in the language. A form can be a sequence\
    \ of expressions or a function definition, or it can define a variable (that is,\
    \ an identifier).\n\nA form may also consist of one or more expressions as arguments.\
    \ These arguments will be passed to the form when it is called.\n\nIn the following\
    \ example, we will learn how to write and use programs that use lists and functions\
    \ that operate on them.\n\nLists\nWe'll start out by writing a \"procedure\" that\
    \ takes one argument, which is a list.\nThe procedure will print all the elements\
    \ of the list, separated by commas.\n\nA procedure definition begins with the\
    \ keyword define.\nThis keyword takes the name of a procedure (which, in Racket\
    \ is usually a variable name, but can also be a function name) and parentheses,\
    \ if any, that follow the procedure name.\nThe next token should be the name of\
    \ the procedure, followed by the parentheses, if any.\nThe next token should be\
    \ a left parenthesis, followed by the arguments that will be passed to the procedure\
    \ when it is called.\nThe next token should be another left parenthesis, if any.\n\
    \nIn this example, we'll create a procedure to print all the elements of a list:\n\
    \n\n</text>\n<cell>", "  (if (null? lst)\n      '()\n      (append (sort (list\
    \ (caar lst) (cadar lst) (caddar lst))\n                     <)\n            \
    \  strange_sort_list (cdr lst))))\n", "  (cond\n    [(empty? lst) lst]\n    [(>=\
    \ (rest (rest lst)) (first (rest lst)))\n     (strange_sort_list (append lst (list\
    \ (first (rest lst))))]\n    [else (strange_sort_list (append lst (list (rest\
    \ (rest lst))))])))\n", "  (let loop ((lst lst)\n             (i 0))\n    (cond\
    \ [(null? lst)\n           (reverse (list lst))]\n          [(< (car lst) (first\
    \ lst))\n           (loop (rest lst) (+ i 1))]\n          [else\n           (loop\
    \ (rest lst) (- i 1))])))\n", "  (if (empty? lst) lst\n    (if (< (first lst)\
    \ (first (rest (rest lst)))) (reverse (cons (first lst) (strange_sort_list (rest\
    \ lst))))\n        (strange_sort_list (rest lst))))))\n", "  (define (go lst)\n\
    \    (if (null? lst)\n        '()\n        (cons (min lst (car lst)) (go (reverse\
    \ (cdr lst))))))\n  (go (reverse lst)))\n", "  (if (empty? lst)\n      '()\n \
    \     (append (append (strange_sort_list (sort lst (<)) )\n                  \
    \  (sort lst (<=)))\n              (sort lst (>))))) ;; #lang racket\n", "  (cond\
    \ [(null? lst)\n         lst]\n        [else\n         (let ([cur (car lst)]\n\
    \                 [next (max lst)]\n                 [min (min lst)])\n      \
    \     (cond [(< cur next) \n                   (cons cur (strange_sort_list (cons\
    \ next lst)))]\n                 [(> cur next)\n                   (cons cur (cons\
    \ next strange_sort_list (cdr lst)))]\n                 [else \n             \
    \      (cons cur (cons next (strange_sort_list (cdr lst))))]))]))\n", "  (if (empty?\
    \ lst)\n      '()\n      (append (max (sort lst <)) (sort lst > <) (min (sort\
    \ lst <)) (sort lst > >))))\n", "  (if (empty? lst)\n      '()\n      (cons (min\
    \ lst (strange_sort_list (rest lst)))\n            (strange_sort_list (rest lst)))))\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nIt looks like you're missing the recursive\
    \ calls.\n<|/ c |>\n<| c |>\nyes, sorry, I forgot those. Fixed.\n<|/ c |>\n<|\
    \ c |>\nSorry I should have included this in my question but this is an exercise\
    \ on sorting. I am not allowed to use the built-in sort function.\n<|/ c |>\n\
    <| c |>\nok, that's a tough one. Still the idea of sorting algorithms is to start\
    \ with the smallest element and keep doing it until we get to a larger one (which\
    \ is now the smallest again). That is how you can \"unsort\" a sorted list.\n\
    <|/ c |>\n<| c |>\nYeah I see what you mean now. Thanks for the help. My brain\
    \ just isn't functioning today.\n<|/ c |>\n<| a dscore=1 tags=racket,sorting,scheme,list\
    \ |>\nThe \"natural sort\" is a standard problem in computer science. It was originally\
    \ introduced by Knuth in 1978, and it is now widely used by several other names.\n\
    The problem is that you have a list of positive integers and you want to sort\
    \ them in order from smallest to largest. Since you can do this, you can see that\
    \ it is easy to rearrange the numbers into the correct order. But sorting is a\
    \ bit of a pain to do by hand, and a computer program will be a lot more useful\
    \ if it can do the sorting itself.\nThe \"natural sort\" is an algorithm that\
    \ works by building a string that describes the order in which the numbers should\
    \ be ordered. The string can be built by going through each number, adding one\
    \ to the string as its character when it is greater than the previous number in\
    \ the string. If that number is the smallest number in the list, then that character\
    \ will be a lowercase letter. If the number is equal to the previous number in\
    \ the string, then the next character in the string will be a lowercase letter.\
    \ As it goes, it keeps adding the smallest numbers first, and each number that\
    \ is greater than the current smallest number gets added to the string as its\
    \ first letter. This process stops when it reaches a number that is smaller than\
    \ any number currently in the string, and so on. The process is repeated until\
    \ all numbers are added to the string. \nThis particular procedure is called \"\
    natural order\" because it is ordering the numbers in numerical order, but it\
    \ is also known as \"alphabetical order\" because it is ordering the numbers in\
    \ alphabetical order.\n<|/ a |>\n", "  (cond\n    [(empty? lst) lst]\n    [(null?\
    \ (cdr lst)) (list lst)]\n    [(>= (car lst) (car (rest lst))) (list lst lst (cdr\
    \ (rest lst)))]\n    [else (strange_sort_list (list lst (car (rest lst)) (cdr\
    \ (rest lst))))]))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe second `cond` can\
    \ be simplified to `(or (empty? (cdr lst)) (null? (cdr lst)))`.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nA slight modification to the answer by Yaroslav Horv\xE1tha can\
    \ fix the code (by not adding a 'cons', but rather using the cons method of the\
    \ cons cell). The change is below, where I have changed line 8 to (cons (car lst)\
    \ lst). \n<code>", "  (if (empty? lst)\n      '()\n      (append (sort (list lst)\
    \ (lambda (x y) (> x y)))\n              (strange_sort_list (sort (list lst) (lambda\
    \ (x y) (< x y))))))\n</code>\nThis sort of makes sense as a recursive function,\
    \ which calls itself when needed.\nYou can see how this works by calling strange_sort_list\
    \ on a list of numbers:\n<code>", "  (define (sort-helper lst idx count)\n   \
    \ (cond\n      [(empty? lst)\n       (reverse (subseq lst idx count))\n      \
    \ ;; Keep recursing until we reach the desired index.\n       (sort-helper (rest\
    \ lst) (+ idx count) 1)]\n      [(= idx (length (first lst)))\n       (reverse\
    \ (subseq lst 0 count))\n       ;; Keep recursing until we reach the desired index.\n\
    \       (sort-helper (rest lst) (+ idx 1) 1)]\n      [(< idx (length (first lst)))\n\
    \       (sort-helper (rest lst) (+ idx 1) count)\n       ;; Keep recursing until\
    \ we reach the desired index.\n       (sort-helper (rest lst) (+ idx count) 1)]\n\
    \      [else\n       (sort-helper (rest lst) (+ idx count) count)]\n    ))\n \
    \ (sort-helper lst 0 0))\n", "  (if (null? lst)\n      '()\n      (append (map\
    \ (lambda (n) (* n n)) lst)\n              (list (min lst (max lst (min lst)))))\n\
    \  )\n)\n", "  (sort lst (lambda (x) (< (% x y) 0))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=3 |>\n<| c |>\nThis isn't really an answer. It's, well, an advice. On\
    \ SO it's a bit like asking \"How can I get my car on?\".\n<|/ c |>\n<| c |>\n\
    This should be an answer. :) I'd love to see a non-sorting version of this, though.\
    \ Just because it's possible doesn't make it a good idea.\n<|/ c |>\n<| c |>\n\
    It can be made into a function using `(define strange_sort_list strange-sort)`,\
    \ but that won't change the fact that it's not an optimal algorithm.\n<|/ c |>\n\
    <| c |>\nWhat would be an optimal algorithm?\n<|/ c |>\n<| c |>\nA simple one,\
    \ which will run much faster than a sorting algorithm. If that's not possible\
    \ then it's probably going to be less efficient than sorting. If it's possible\
    \ then you can write it in a way that makes it easier to read.\n<|/ c |>\n<| a\
    \ tags=racket,scheme |>\nIf you know all the elements are positive, you can simply\
    \ reverse the list and sort it.\n<code>\n#lang racket\n", "  (if (empty? lst)\n\
    \      lst\n      (append (strange_sort_list (sort_list (first lst) (rest lst)))\
    \ (strange_sort_list (sort_list (first lst) (rest lst))))))\n", "  (define (partition\
    \ lst left right)\n    (cond ((null? lst) '())\n          ((= left right) (cons\
    \ (car lst) '()))\n          ((> left right) (cons (car lst) (partition (cdr lst)\
    \ (+ left 1) right)))\n          (else\n           (partition (cdr lst) (+ left\
    \ 1) right))))\n  (partition lst 0 length lst))\n", "  (let loop ([lst lst]\n\
    \             [sorted '()])\n    (cond [(empty? lst) sorted]\n          [else\
    \ (loop (rest lst)\n                      (cons (min lst)\n                  \
    \          (loop (rest lst)\n                                   (cons (max lst)\
    \ sorted))))])))\n</code>\n<|/ a tags=sorting,scheme,racket |>\n<| a dscore=3\
    \ |>\nHere's a solution using only a combination of map and filter\n<code>", " \
    \ (define (helper lst i)\n    (cond [(empty? lst) (lst)]\n          [(< (car lst)\
    \ (list-ref lst i))\n          (cons (list-ref lst i) lst)]\n          [else (helper\
    \ (cdr lst) i)]))\n  (helper lst 0))\n", "  (if (null? lst)\n      '()\n     \
    \ (append (list (car lst))\n               (strange_sort_list (cdr lst)))))\n",
  "  (let ([min (car (sort lst min))])\n    (define (next-min lst)\n      (cond [(empty?\
    \ lst)\n             (reverse empty-list)\n             lst]\n            [(<\
    \ min (first lst))\n             (cons min (reverse (next-min (rest lst))))]\n\
    \            [else (cons (first lst) (next-min (rest lst)))]))\n    (let ([max\
    \ (car (sort next-min max))]\n          [rest (cdr (sort lst max))])\n      (cons\
    \ min (cons max (cons rest empty-list))))))\n", "  (let loop ((lst lst)\n    \
    \         (rev false))\n    (cond\n      [(empty? lst) empty]\n      [(= 1 (length\
    \ lst)) (list lst)]\n      [else (let ([first-elem (first lst)])\n           \
    \    (loop (rest lst)\n                     (not rev))\n               (cons (first\
    \ lst)\n                     (loop rest (not rev))))]))))\n", "  (cond\n    [(empty?\
    \ lst)\n     (list lst)]\n    [else (cons (min lst)\n                (list (max\
    \ lst)\n                       (min lst)\n                       (max lst))\n\
    \               strange_sort_list (rest lst))]))\n", "  (if (empty? lst)\n   \
    \   lst\n      (let ([curr-min (first lst)\n             curr-max (second lst)]\n\
    \            [next (third lst)])\n        (if (< curr-min curr-max)\n        \
    \    (cons (cons curr-min next)\n                   (cons curr-max next))\n  \
    \          (cons next (cons curr-min next)))))\n  )\n", "  ;; Find min and max\
    \ of sublist with minimum steps of 2.\n  (define (min-max-list lst min max)\n\
    \    (cond [(empty? lst) `(,min ,max)]\n          [(> max lst) `(,min ,max)]\n\
    \          [(< min lst) `(,min ,max)]\n          [else `(,min (min (max lst)))]))\n\
    \  \n  (define (min-max-list lst min max)\n    (cond [(empty? lst) `(,min ,max)]\n\
    \          [(> max lst) `(,min ,max)]\n          [(< min lst) `(,min ,max)]\n\
    \          [else `(,min (min-max-list (rest lst) min (max lst)))]))\n  \n  (define\
    \ (min-max lst)\n    (min-max-list lst '(#f #f) '(#f #f)))\n  \n  ;; Find min\
    \ and max of sublist with maximum steps of 2.\n  (define (max-min-list lst min\
    \ max)\n    (cond [(empty? lst) `(,min ,max)]\n          [(> max lst) `(,min ,max)]\n\
    \          [(< min lst) `(,min ,max)]\n          [else `(,max (min (max lst)))]))\n\
    \  \n  (define (max-min-list lst min max)\n    (cond [(empty? lst) `(,min ,max)]\n\
    \          [(> max lst) `(,min ,max)]\n          [(< min lst) `(,min ,max)]\n\
    \          [else `(,max (max-min-list (rest lst) min (max lst)))]))\n  \n  (define\
    \ (max-min lst)\n    (max-min-list lst '(#f #f) '(#f #f)))\n  \n  ;; Find min\
    \ and max of sublist with minimum steps of 2 and maximum steps of 2.\n  (define\
    \ (min-max-max-list lst min max)\n    (cond [(empty? lst) `(,min ,max)]\n    \
    \      [(> max lst) `(,min ,max)]\n          [(< min lst) `(,min ,max)]\n    \
    \      [else `(,min (min-max-max-list (rest lst) min (max lst)))]))\n  \n  (define\
    \ (min-max-max-list lst min max)\n    (cond [(empty? lst) `(,min ,max)]\n    \
    \      [(> max lst) `(,min ,max)]\n          [(", "  (if (empty? lst)\n      '()\n\
    \      (let loop ((i 0) (head (car lst)) (tail (cdr lst)))\n        (if (empty?\
    \ tail)\n            (cons head (loop (+ i 1) head tail))\n            (loop (+\
    \ i 1) head (cons (car tail) tail))))))\n", "  (let ((lst (check-list lst strange_sort_list\
    \ \"Invalid argument\")))\n    (cond\n      [(empty? lst) (list)]\n      [(< (first\
    \ lst) (first lst)) (cons (first lst) (strange_sort_list (rest lst)))]\n     \
    \ [(< (first lst) (first lst)) (strange_sort_list (rest lst))]\n      [(<= (first\
    \ lst) (first lst)) (strange_sort_list (rest lst))]\n      [(> (first lst) (first\
    \ lst)) (strange_sort_list (rest lst))]\n      [(> first lst) (cons (first lst)\
    \ (strange_sort_list (rest lst)))]\n      [else\n       (cons (first lst) (strange_sort_list\
    \ (rest lst)))]\n     )\n  )\n)\n</cell>\n<code language=ocaml-jupyter>\n#lang\
    \ racket\n", "  (define (helper lst start end)\n    (cond\n      [(empty? lst)\
    \ empty]\n      [(> start end) (cons (first lst) empty)]\n      [else (helper\
    \ (rest lst) (+ start (first lst)) (+ end (first lst)))]\n      ))\n  (helper\
    \ (reverse lst) 0 -1))\n", "  (let ([i 0])\n    (if (null? (rest lst))\n     \
    \   (reverse lst)\n        (if (< (first lst) (rest lst))\n            (cons lst\
    \ (strange_sort_list (rest lst)))\n            (cons (first lst) (strange_sort_list\
    \ (rest lst)))))))\n", "  (if (null? lst) lst\n    (let ([first-element (car lst)])\n\
    \      (append (list (cons first-element (strange_sort_list\n                \
    \                       (cdr lst))))\n              (list (cons (car lst) first-element))))))\
    \ ;#lang racket\n", "  (cond\n    [(empty? lst) '()]\n    [else\n     (let* ([minx\
    \ (car lst)\n              maxx (cadr lst)\n              midx (car lst)\n   \
    \           midy\n              [lst1 (cons (car lst) (cons minx (cons maxx (cons\
    \ midy (cons midx (cons maxx (cons midx (cons minx '()))))))))]\n            \
    \  [lst2 (cons (cadr lst) (cons midx (cons maxx (cons midy (cons minx (cons midx\
    \ (cons maxx (cons minx '()))))))))]\n              [lst3 (cons (car lst) (cons\
    \ midx (cons minx (cons maxx (cons midy (cons minx (cons midx (cons maxx (cons\
    \ minx '()))))))))]\n              [lst4 (cons (cadr lst) (cons minx (cons maxx\
    \ (cons midy (cons midx (cons maxx (cons minx '()))))))])\n       (if (< (car\
    \ lst) minx) (cons (car lst) lst1) (cons (car lst) lst2) (cons (car lst) lst3)\
    \ (cons (car lst) lst4))])]))\n", "  (cond\n    [(empty? lst) empty]\n    [else\n\
    \     (let loop ([lst lst]\n                [idx 0]\n                [idx 0])\n\
    \       (if (> idx length) (reverse (reverse (list lst))) \n           (let ([smallest\
    \ (car lst)]\n                  [largest (cadr lst)]\n                  [minidx\
    \ idx])\n             (cond [(< smallest smallest) smallest]\n               \
    \    [(> smallest smallest) (loop smallest (+ idx 1) minidx)]\n              \
    \     [else\n                    (cond\n                     [(< largest largest)\
    \ largest]\n                     [(> largest largest) (loop largest (+ idx 1)\
    \ minidx)]\n                     [else\n                      (loop (append (cddr\
    \ lst) (car lst)) \n                            (+ idx 1) (+ minidx 1))]\n   \
    \                  )]))])))\n</code>\n<|/ a tags=lisp,scheme |>\n<| c |>\nThis\
    \ doesn't work for large lists... I'm working on how to solve the problem. Thank\
    \ you!\n<|/ c |>\n<| c |>\nYou are not supposed to change the original list here,\
    \ so that doesn't matter. The idea of having an auxiliary list is to sort them\
    \ in-place.\n<|/ c |>\n<| c |>\nI updated my answer with an implementation that\
    \ works on large lists.\n<|/ c |>\n<| c |>\nI really like the way you wrote the\
    \ code - it makes it much easier to see what's going on! :)\n<|/ c |>\n<| a dscore=1\
    \ tags=lisp,scheme |>\nThis can be done using only tail recursion.\n<code>", " \
    \ (if (null? lst)\n      lst\n      (let ([min (car lst)])\n        (let loop\
    \ ((lst lst) (min min))\n          (if (null? lst)\n              (list min)\n\
    \              (let ([min (car (cdr lst))])\n                (if (> min (car lst))\n\
    \                    (loop (cdr lst) min)\n                    (loop (cdr lst)\
    \ min)))))))\n", "  (if (empty? lst)\n      '()\n      (append (list (max lst))\n\
    \               (list (min lst))\n               (strange_sort_list (rest lst)))))\n",
  "  (if (empty? lst)\n      lst\n      (append (sort (min lst)) (sort (max lst))\n\
    \               (sort (min lst))))) ;'#lang racket\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a dscore=1 tags=racket,scheme |>\nIn Racket, using Racket built in functions\
    \ will take care of this. First find the minimum element in the list and put it\
    \ at its sorted position with the rest of the list being put in sorted order.\n\
    For eg:\n<code>", "  (if (empty? lst)\n      '()\n      (append (sub1 (strange_sort_list\
    \ (max_list (rest lst)))) (max_list (rest lst)))))\n", "  (cond\n    [(empty?\
    \ lst)\n     empty]\n    [(= 1 (length lst))\n     (list (first lst))]\n    [else\
    \ \n     (append (strange_sort_list (rest lst))\n               (list (first lst))\n\
    \               (strange_sort_list (rest lst)))]))\n", "  (if (null? lst)\n  \
    \    lst\n      (append (sort lst <)\n              (sort (sort lst >) >)\n  \
    \            lst)))\n</code>\nI hope this helps.\n<|/ a tags=racket,scheme,sorting\
    \ |>\n<| a dscore=2 |>\nHere is my solution:\n<code>", "  (sort lst <))\n", " \
    \ (cond [(null? lst) lst]\n        [(number? (car lst))\n         (list lst\n\
    \               (strange_sort_list (sort lst (lambda (x) (< x 5)))\n         \
    \                      (strange_sort_list (sort lst (lambda (x) (> x 5)))\n  \
    \                             )\n               (strange_sort_list (sort lst (lambda\
    \ (x) (< x 5) (> x 5)))\n                               (strange_sort_list (sort\
    \ lst (lambda (x) (< x 5) (> x 5)))\n                               )\n      \
    \         )\n         ]\n        [else (strange_sort_list (sort lst (lambda (x)\
    \ (< x 5)))\n                                (strange_sort_list (sort lst (lambda\
    \ (x) (> x 5)))\n                                 (strange_sort_list (sort lst\
    \ (lambda (x) (< x 5) (> x 5)))\n                                 (strange_sort_list\
    \ (sort lst (lambda (x) (< x 5) (> x 5)))\n                                 )\n\
    \               )\n         )\n        ])\n)\n", "  (define (loop lst)\n    (cond\
    \ [(null? lst)\n           (reverse (list lst))]\n          [(< (car lst) (car\
    \ (cdr lst)))\n           (loop (cdr lst))]\n          [(> (car lst) (car (cdr\
    \ lst)))\n           (loop (cdr lst))]\n          [else (loop (cdr lst))]\n  \
    \        ))\n  (loop lst))\n", "  (let loop ((lst lst)\n             (acc '()))\n\
    \    (cond\n      [(null? lst) acc]\n      [(<= (car lst) (car (cdr lst)))\n \
    \      (loop (cdr lst) (cons (car lst) acc))]\n      [else (loop (cdr lst) (cons\
    \ (car lst) acc))]))))\n", "  (sort lst < < #t))\n", "  (if (null? lst)\n    \
    \  '()\n      (let ([min (first lst)\n            max (second lst)\n         \
    \   min (first lst)])\n        (cond ((> min max) (cons (first lst) (strange_sort_list\
    \ (rest lst))))\n              ((< min max) (cons (second lst) (strange_sort_list\
    \ (rest lst))))\n              (else (cons (first lst) (strange_sort_list (rest\
    \ lst))))))))\n", "  (define (helper lst acc i)\n    (if (< i 5)\n        (helper\
    \ lst (cons lst acc) (+ i 1))\n        acc))\n  (helper lst '() 0))\n</code>\n\
    It works. But I wonder how efficient it is. It is O(n\xB2). Can it be improved?\n\
    <|/ a |>\n<| c |>\n`strange_sort_list` should return `'()` if `lst` is empty or\
    \ nil. Your code doesn't, and that could be a problem. Also, you have a typo in\
    \ your code: `(cons lst acc)` should probably be `lst` instead of `'()`. You also\
    \ have a typo in your explanation: `strange_sort_list` should return `lst` instead\
    \ of the empty list.\n<|/ c |>\n<| c |>\n, thanks for the comments. Fixed. Regarding\
    \ the empty list, you are right, my code doesn't. It should be `lst` because `strange_sort_list`\
    \ should return the sorted list.\n<|/ c |>\n<| a |>\nHere's a solution using only\
    \ built-in procedures that don't use any accumulators. It has two advantages over\
    \ Kevin's solution:\n\nIt uses lists for its input and output, so it's as efficient\
    \ as possible, since it uses lists to represent the data. It also uses lists instead\
    \ of strings for its input, because it's easier to compare with lists.\nIt doesn't\
    \ use any recursion, which is nice, because this solution would recurse with every\
    \ element of the list.\n\nIt would be possible to implement this solution using\
    \ an accumulator parameter, but I find it easier to write it this way.\n<code>",
  "  (let ([m (first lst)])\n    (if (empty? lst)\n        '()\n        (let ([m (first\
    \ lst)]\n               (rest lst))\n          (if (> (first lst) m)\n       \
    \       (cons (first lst) (cons (first lst) (strange_sort_list (rest lst)))) ;\
    \ max of remaining elem\n              (strange_sort_list (rest lst))))))\n",
  "  (if (null? lst)\n      '()\n      (cons (min lst)\n            (strange_sort_list\n\
    \             (append (sort (sort (sort lst)))\n                    (sort lst))))))\
    \ ;; Strange!\n", "  (if (null? lst)\n      '()\n      (append (strange_sort_list\
    \ (min lst (max lst (min lst (max lst)))))\n              lst)))\n</code>\n<|/\
    \ a |>\n<| c |>\nWhile this solution doesn't use `append` it's good because it\
    \ doesn't mutate its input, which is generally a good thing. Just in case it's\
    \ missed as a requirement and you're using `append` elsewhere in your solution.\n\
    <|/ c |>\n<| c |>\n: Thanks :-) I actually didn't know `append` mutates its argument,\
    \ just checked the language specification and it's written to me. But it's good\
    \ to know that I'm not alone on that, and it may help others reading the answer\
    \ :-)\n<|/ c |>\n<| c |>\n: Thanks for this solution! Very nice and efficient\
    \ code. I just want to add that you can use `min`, `max`, and `append` to implement\
    \ the *strange* sort by reversing the `append`: `(append (reverse lst) (append\
    \ lst '()))`.\n<|/ c |>\n<| c |>\nThis solution is just awesome! The explanation\
    \ is really good and I like that you also mentioned the usage of `min`, `max`\
    \ and `append`.\n<|/ c |>\n<| c |>\n: That's good to know. Although, I don't think\
    \ reversing `append` as you suggested would work because `append` returns the\
    \ tail of the list, so (append '(1 2 3) '()) will result in '(1 2 3 ()), not '().\
    \ I'm sure there's a more elegant way to reverse the result of `append`, but I\
    \ don't know it.\n<|/ c |>\n<| a tags=racket,scheme dscore=3 |>\nOne solution\
    \ is to use recursion to build up the result in the correct order:\n<code>", " \
    \ (if (null? lst)\n      '()\n      (append (append (sort lst <) (sort lst (lambda\
    \ (x y) (< x y)))) (sort lst (lambda (x y) (< y x))))))\n", "  (if (empty? lst)\n\
    \      '()\n      (let ([min (first lst)\n              max (rest lst)\n     \
    \         in-min (remove-if #(<= min %) lst)\n              in-max (remove-if\
    \ #(> max %) lst)])\n        (strange_sort_list in-min)\n        (append (in-max\
    \ min) in-max))))\n", "  (cond\n    [(empty? lst) lst]\n    [(< first (rest lst))\
    \ (cons (first (rest lst)) (cons (first lst) (strange_sort_list (rest lst))))]\n\
    \    [else (strange_sort_list (rest lst))]))\n", "  (define (helper lst idx)\n\
    \    (if (null? lst)\n        lst\n        (if (= idx 0)\n            (helper\
    \ (cdr lst) 0)\n            (helper (cdr lst) (- idx 1)))))\n  (helper lst 0))\n",
  "  (let ([minimum (car lst)]\n        [maximum (cdr lst)])\n    (if (or (= minimum\
    \ maximum)\n            (empty? lst))\n        '()\n        (append (list (list\
    \ minimum maximum))\n                (list (list maximum (car lst))\n        \
    \              minimum (cdr lst)))\n        strange_sort_list (rest lst))))\n",
  "  (if (null? lst)\n      '()\n      (cons (min-lst (sort lst #'<)) (sort lst (lambda\
    \ (x) (max-lst x))))))\n", "  (if (empty? lst)\n      '()\n      (append\n   \
    \    (append (sort (first lst) '<)\n              (first lst)\n              (sort\
    \ (first lst) '>)\n              (strange_sort_list (rest lst)))\n       '()))\n\
    </code>\nThe above solution uses the append function as it is more concise than\
    \ the other approaches.\nAnother solution is to use a list which has the characters\
    \ (in this case, numbers) reversed. For example, [1, 2, 3, 4, 5] is turned into\
    \ [51, 50, 49, 48, 47]. Then, we apply a sort. However, we need a helper function\
    \ to do this sorting:\n<code>", "  (if (null? lst)\n      '()\n      (append (sort\
    \ lst)\n              (strange_sort_list (sort lst))))) ;; <-- here\n</code>\n\
    <|/ a tags=racket,scheme dscore=1 |>\n<| c |>\nYour solution is pretty elegant.\
    \ However it uses O(n^2) time which is very inefficient.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is an O(n) solution:\n<code>", "  (if (empty? lst)\n      '()\n   \
    \   (append (sort lst)\n              (sort (sort (sort lst))))))\n</code>\n<|/\
    \ a dscore=4 tags=functional-programming,recursion,racket,scheme |>\n<| c |>\n\
    Thank you so much, this is very helpful.\n<|/ c |>\n<| c |>\nThis fails sometimes:\n",
  "  (cond\n    [(empty? lst) empty]\n    [else\n      (define first lst)\n      (define\
    \ second (rest lst))\n      (define third (rest (rest lst)))\n      (define fourth\
    \ (rest (rest lst)))\n      (cond\n        [(= (first lst) (first third))\n  \
    \       (cons (first lst)\n               (strange_sort_list second))]\n     \
    \   [(= (first third) (first fourth))\n         (cons (first third)\n        \
    \       (strange_sort_list fourth))]\n        [else (cons (first third)\n    \
    \                (strange_sort_list fourth))]\n        [else (cons (first fourth)\n\
    \                    (strange_sort_list second))]\n        [else (cons (first\
    \ fourth)\n                    (strange_sort_list third))]))]))\n", "  (strange-sort-helper\n\
    \   (list->tree\n    (sort lst (lambda (x y) (<= y x)))))) ;; Sort is stable\n\
    \  ", "  (if (null? lst)\n      lst\n      (strange_sort_list (sort (- lst (first\
    \ lst)) #'< :key #'cdr))))\n", "  (sort lst < < >))\n", "  (sort lst (lambda (x\
    \ y) (< x y))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a dscore=0 |>\nIn Racket\
    \ we have foldl and foldr for iterating over lists.\nIf you need to sort a list,\
    \ you just need to sort it with foldl:\n<code>", "  (if (null? lst)\n      '()\n\
    \      (append (strange_sort_list (remove (min lst) (max lst)) (remove (max lst)\
    \ (min lst)))\n              lst)))\n", "  (if (empty? lst)\n      '()\n     \
    \ (append (max_element lst)\n               (max_element (rest_of_list lst))\n\
    \               (min_element lst)\n               (min_element (rest_of_list lst))))))\n",
  "  (if (empty? lst)\n      '()\n      (append (list (caar lst))\n              \
    \ (list (cdr lst))\n               (list (min lst (car lst)))\n              \
    \ (list (max lst (car lst))))))\n", "  (if (null? lst)\n      '()\n      (append\
    \ (max_list (rest lst))\n               (append (rest_list (rest lst))\n     \
    \                 (min_list (rest lst))))))", "  (cond\n    [(empty? lst) lst]\n\
    \    [else\n     (append (cons (first (sort (reverse lst))) \n               \
    \     (list (first (sort lst)))\n                    (first (sort (reverse (rest\
    \ lst))))) \n            (strange_sort_list (rest lst))]))])\n", "  (if (null?\
    \ lst)\n      lst\n      (let* ([min (car lst)\n             rest (cdr lst)]\n\
    \             (max (sort rest strange_sort_list)))\n        (cons min (cons max\
    \ rest))))))\n", "  (let ((length (length lst))\n        (strange (make-array\
    \ (list length 3) (quote nil)))\n        (min (minimum lst))\n        (max (maximum\
    \ lst)))\n    (dotimes (i (length lst))\n      (let ((n (car lst)))\n        (set!\
    \ strange\n              (append strange (list (min max))\n                  \
    \    (list (list n min max))))\n        (set! min (min n))\n        (set! max\
    \ (max n))\n        (set! length (- length 1))))))\n", "  (sort (list min lst\
    \ max) <))\n", "  (if (empty? lst)\n      '()\n      (append (append (cons (car\
    \ lst) (sort lst (lambda (x) (- x 1))))\n                       (sort lst (lambda\
    \ (x) (- x -1))))))) ;; Strange sorting\n", "  (let loop ([lst lst]\n        \
    \     [head (first lst)]\n             [tail (rest lst)]))\n    (cond\n      [(empty?\
    \ lst) lst]\n      [(< (first tail) head) (loop (rest lst) (first tail) (rest\
    \ lst))]\n      [else (loop (rest lst) (first tail) (rest lst))])))\n", "  (if\
    \ (null? lst)\n      '()\n      (append\n       (list (car lst))\n       (strange_sort_list\n\
    \        (remove-if (lambda (x) (< x lst))\n                    (remove-if (lambda\
    \ (x) (> x lst))\n                                lst)))))\n", "  (if (empty?\
    \ lst) '()\n      (append (strange_sort_list (first lst)) (last lst) (strange_sort_list\
    \ (rest lst)))))\n", "  (sort lst (lambda (x y)\n             (< (expt x 2) (expt\
    \ y 2)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
