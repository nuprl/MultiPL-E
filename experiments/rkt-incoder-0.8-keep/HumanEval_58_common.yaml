name: HumanEval_58_common
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique common elements for two lists.\n\
  ;; >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n;; [1, 5, 653]\n\
  ;; >>> common([5, 3, 2, 8], [3, 2])\n;; [2, 3]\n(define (common l1 l2)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n\
  \    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\
  \ (list 1 5 653))\n    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list\
  \ 2 3))\n    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))\n\
  \    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(null? l1) l2]\n    [(null? l2) l1]\n    [(eq? (first\
    \ l1) (first l2)) (cons (first l1) (common (rest l1) (rest l2)))]\n    [else (common\
    \ (rest l1) (rest l2))]))\n", "  (sort (remove-duplicates \n           (remove-if\
    \ (lambda (x) (equal? (sort l1) (sort x)))\n                       (remove-if\
    \ (lambda (x) (equal? (sort l2) (sort x)))\n                                 l2))))))\n",
  "  (remove #(if (equal? (car %1) (car %2)) (car %2) #f) l1 l2))\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a |>\n<code>", "  (let ([f1 (lambda (x) (contains? x1 x2)) \n\
    \          f2 (lambda (x) (contains? x1 x2)) \n          x1 x2])\n    (cond ((or\
    \ (empty? l1) (empty? l2))\n           #f)\n          (#t (let ([h (first l1)\
    \ \n                      t (first l2)])\n                (cond ((or (empty? h)\
    \ (empty? t))\n                       #f)\n                      (#f\n       \
    \                (cond ((not (member h t))\n                               (cons\
    \ h t))\n                             ((not (member t h))\n                  \
    \             (cons t h))\n                             (else\n              \
    \                 (append (list (first l1) (first l2))\n                     \
    \                   (common (rest h) (rest t)))))))))\n          (#t (let ([h\
    \ (first l1)\n                      t (first l2)])\n               (cond ((or\
    \ (empty? h) (empty? t))\n                       #f)\n                      (#f\n\
    \                       (cond ((not (member h t))\n                          \
    \     (cons h t))\n                             ((not (member t h))\n        \
    \                       (cons t h))\n                             (else\n    \
    \                           (common (rest h) (rest t))))))))))\n</cell>\n<text>\n\
    Problem 2b\nWe have already solved the problem for lists with the same number\
    \ of elements, in the previous problem. However, now we might have a new interesting\
    \ problem. The problem states that two lists share at least two elements. For\
    \ example, given these two lists:\n", "  (sort (filter (lambda(x) (not (null?\
    \ l1)))\n                (filter (lambda(x) (not (null? l2)))\n              \
    \         (zip (reverse l1) (reverse l2))))))\n", "  (cond\n    ((null? l1) l2)\n\
    \    ((null? l2) l1)\n    ((eq? (first l1) (first l2)) (rest l1)\n     (cons (first\
    \ l1) (common rest (rest l2))))\n    ((eq? (first l2) (first l1)) (rest l2)\n\
    \     (cons (first l2) (common rest (rest l1))))\n    (else (common l1 (rest l2)))))\n",
  "  (sort (set l1 l2) '<))\n", "  (sort (remove-duplicates (sort l1) (sort l2))))\n",
  "  (sort l1 (lambda (a b) (< (length a) (length b)))))\n", "  (append (remove-duplicates\
    \ l1)\n          (remove-duplicates l2))\n  )\n", "  (filter \n   (lambda (x)\
    \ (member x l1)) (\n    filter (lambda (x) (member x l2)) l1))))\n", "  (remove-if-not\
    \ (lambda (x y)\n                    (or (null? x) (null? y))\n              \
    \      (and (>= x y)\n                         (= x (first y)))\n            \
    \        (and (>= y (car x))\n                         (= y (first x))))\n   \
    \           (partition 2 l1 l2)))\n", "  (apply append\n         (let (helper\
    \ x)\n           (cond (empty? l1) (l1->empty l2)\n                 (empty? l2)\
    \ (l1->empty l1)\n                 ((equal x l1) (cons (car l1) (helper (cdr l1))))\n\
    \                 ((equal x l2) (cons (car l2) (helper (cdr l2))))\n         \
    \        ((equal? (first l1) (first l2)) (append (helper (rest l1)) (car l2))\n\
    \                                       (append (car l1) (helper (rest l2))))\n\
    \                 (else (helper (rest l1) (car l2) l1 (cdr l2))))\n          \
    \ helper (first l1) (first l2))))\n", "  (let ((l1 (sort l1 '<))\n        ;; l1\
    \ now has unique elements\n        (l2 (sort l2 '>)))\n    (cond\n      [(empty?\
    \ l1) l2]\n      [(empty? l2) l1]\n      [(equal? (first l1) (first l2)) (common\
    \ (rest l1) (rest l2))]\n      [else (cons (first l1) (common (rest l1) (rest\
    \ l2)))])))\n", "  (let loop ((result '())\n             (l1 l2)\n           \
    \  (count 0))\n    (if (null? l1)\n        result\n        (loop (append result\
    \ (car l1))\n               (cdr l1)\n               (add1 count)))\n    (if (null?\
    \ l2)\n        result\n        (loop (append result (car l2))\n              \
    \ (cdr l2)\n               (add1 count))))\n</code>\n<|/ a |>\n<| a |>\nUsing\
    \ only Racket it looks like this:\n<code>", "  (let ([i (in-index l1 l2)])\n \
    \   (if (> i 0)\n        (subseq l1 i)\n        (subseq l2 i))))\n", "  (cond\
    \ [(empty? l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1) (first\
    \ l2)) (common (rest l1) (rest l2))]\n        [else (cons (first l1)\n       \
    \             (common (rest l1) l2))]))\n", "  (if (empty? l1)\n      (if (empty?\
    \ l2)\n          '()\n          l2)\n      (if (empty? l2)\n          l1\n   \
    \       (let ([c (first l2)])\n            (if (member c l1)\n               \
    \ (common (rest l1)\n                         (rest l2))\n                (car\
    \ l1)))))\n", "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal?\
    \ (car l1) (car l2)) (car l1))\n    (else (common l2 (cdr l1)))))\n", "  (sort\
    \ (filter (lambda (x) (member x l1)) (map list l1 l2))))\n", "  (if (null? l1)\
    \ l2\n      (if (equal? (car l1) (car l2))\n          (if (null? (cdr l1)) l2\n\
    \              (if (null? (cdr l2)) l1\n                  (if (> (car l1) (car\
    \ l2)) (cons (car l1) (common (cdr l1) (cdr l2))) (common (cdr l1) (cdr l2)))))\n\
    \          (if (> (car l1) (car l2)) (common (cdr l1) (cdr l2))\n            \
    \  (if (> (car l1) (car l2)) (common (cdr l1) (cdr l2))\n                  (if\
    \ (> (car l1) (car l2)) (common (cdr l1) (cdr l2))\n                      (cons\
    \ (car l1) (common (cdr l1) (cdr l2)))))))))\n", "  (sort (remove-duplicates\n\
    \          (remove-if equal? l1 l2)\n          #:key identity)))\n", "  (cond\
    \ [(null? l1) l2]\n        [(equal? (first l1) (first l2)) (rest (rest l1) (first\
    \ l2))]\n        [(equal? (first l2) (first l1)) (rest (first l2) (first l1))]))\n",
  "  (sort (remove-if (lambda (x) (not= x null?)) l1)\n        (remove-if (lambda\
    \ (x) (not= x null?)) l2)))\n", "  (sort (filter (lambda (x) (not (null? (cdr\
    \ x))) l1) l2))\n)\n", "  (sort\n   (sort l1 <)\n   (sort l2 <)\n   (lambda (a\
    \ b) (= a b))\n   (reverse (sort l1 <))))\n</code>\n<|/ a tags=racket,lisp,common-lisp,scheme\
    \ |>\n<| a tags=racket,lisp,common-lisp,scheme |>\nThe function you want is called\
    \ intersection. \nIn Scheme and Common Lisp, you can use sets:intersection to\
    \ get the intersection of two sets. In Racket, the function intersection exists\
    \ in the library racket/list. \nIn Lisp, if you want to get the intersection of\
    \ two lists, you can use the following (taken from http://www.lispworks.com/documentation/HyperSpec/Body/f_car.htm):\n\
    <code>", "  (filter (lambda (x) (member x l2)) (sort l1)))\n", "  (cond\n    [(null?\
    \ l1) l2]\n    [(member (car l1) l2) (common l2 (cdr l1))]\n    [else (cons (car\
    \ l1) (common l2 (cdr l1)))]))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for\
    \ your answer. Why did you put the second condition in cons though? Since both\
    \ l1 and l2 have at least 1 element, it should still work, shouldn't it? Also,\
    \ the last condition you added doesn't seem to do anything useful, since it checks\
    \ whether the element is present in both lists, not the other way around. Thanks!\n\
    <|/ c |>\n<| c |>\nYes, it should have worked just fine. However, the third condition\
    \ was used to check if the element was not already in the list. The first two\
    \ conditions just check if the first or second argument is null. The last condition\
    \ checks if the current element is in the list before the recursion.\n<|/ c |>\n\
    <| c |>\nOk, I see. I removed the last condition and it seems to be working fine,\
    \ thanks!\n<|/ c |>\n<| a tags=racket,scheme |>\nI would consider this a little\
    \ more of a hack than an answer but just for fun since I had a go at it: \n<code>",
  "  (define (sort lst cmp)\n    (sort lst (lambda (x) (compare-map cmp x))))\n  (if\
    \ (null? l1) (sort l2 #<))\n  (if (null? l2) (sort l1 #<))\n  (let ((l (apply\
    \ append (sort l1 #<) (sort l2 #<))))\n    (remove-if (lambda (x) (member x l))\
    \ l)))\n</code>\n<|/ a dscore=3 |>\n<| a tags=common-lisp,sorting,lisp,functional-programming\
    \ |>\nUsing lists:\n<code>", "  (remove-duplicates \n    (remove-if-not \n   \
    \  (lambda (x) (equal? x l2)) \n     (remove-if-not \n      (lambda (x) (equal?\
    \ x l1)) \n      l1))))\n", "  (sort l1 (lambda (l1 l2)\n             (equal?\
    \ (first l1) (first l2)))))\n</cell>\n<code language=racket-student>", "  (sort\
    \ (remove-duplicates l1) (< l2))))\n", "  (cond [(null? l1) l2]\n        [(null?\
    \ l2) l1]\n        [(equal? (car l1) (car l2))\n         (if (equal? (cdr l1)\
    \ (cdr l2))\n             (common (cdr l1) (cdr l2))\n             (common (cdr\
    \ l1) (cdr l2)))]\n        [else\n         (common (cdr l1) (cdr l2))]))\n", " \
    \ (sort (sort l1)(sort l2)))\n", "  (cond ((null? l1) l2)\n        ((member (car\
    \ l1) l2) (car l2))\n        (else (common (cdr l1) (cdr l2)))))\n", "  (sort\
    \ (distinct (remove (l1 l2) (intersect l1 l2)))))\n", "  (sort (remove-duplicates\
    \ (fold-right (lambda (x y)\n                                     (if (equal?\
    \ x y)\n                                         (append x (list y))\n       \
    \                                  (append y (list x)))) l1 l2) '()))\n</code>\n\
    <|/ a dscore=1 tags=racket,sorting |>\n<| a |>\nOne simple way is to use the \"\
    set-difference\" procedure. Here I define a new procedure (common?) that returns\
    \ a boolean to indicate whether two lists have the same elements but in a different\
    \ order.\n<code>", "  (cond [(or (null? l1)\n            (null? l2)) (list null)]\n\
    \        [(equal? (first l1) (first l2))\n         (common (rest l1) (rest l2))]\n\
    \        [else\n         (append (first l1)\n                 (common (rest l1)\
    \ l2))]))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n    [(equal?\
    \ (first l1) (first l2)) (cons (first l1) (common (rest l1) (rest l2)))]\n   \
    \ [else (common (rest l1) l2)]))\n", "  (cond\n    ((null? l1) l2)\n    ((equal?\
    \ (car l1) (car l2)) \n     (common (cdr l1) (cdr l2)))\n    (else (cons (car\
    \ l1) (common (cdr l1) l2)))))\n  ", "  (cond (empty? l1)\n        '()\n     \
    \   (cons (car l1) (common (cdr l1) l2))\n        (empty? l2))\n  (cond (empty?\
    \ l2)\n        '()\n        (cons (car l2) (common (cdr l1) l2))\n        (empty?\
    \ l1))))\n", "  (filter (lambda (x) (not (member? x l2)))\n          (sort-by\
    \ (lambda (x) (if (eq? l1 x) 0 -1)) l1)))\n", "  (sort (car (filter in-list? (car\
    \ l1) l2))\n        (lambda (x y)\n          (< (car l1) (car l2)) (in-list? x\
    \ y))))\n", "  (sort (remove-if (lambda (x) (member x l2)) l1) #'< ))\n", "  (remove-if\
    \ (lambda (x)\n              (equal? (first l1) (first x))\n               (equal?\
    \ (first l2) (first x)))\n             l2)\n  )\n)\n", "  (filter (\u03BB (x)\
    \ (member x l2)) (sort l1)))\n", "  (remove-if (lambda (x) (not (member x l1)))\
    \ l2))\n", "  (cond ((null? l1) l2)\n        ((member (car l1) l2)\n         (common\
    \ (cdr l1) l2))\n        (else\n         (common (cdr l1) (cdr l2)))))\n", " \
    \ (cond [(null? l1) l2]\n        [(member (car l1) l2)\n         (common (cdr\
    \ l1) l2)]\n        [else (cons (car l1) (common (cdr l1) l2))]))\n", "  (remove-if\
    \ (lambda (x) (equal? (first l1) x)) l2 (remove-if (lambda (x) (equal? (first\
    \ l2) x)) l1)))\n</code>\n<|/ a |>\n<| c |>\n`common` is an abbreviation of \"\
    commonest elements\". If two lists have the same number of elements, then they\
    \ are the same set. If two lists have different number of elements, then they\
    \ are different sets. If they have same number of elements, then they are equivalent\
    \ sets.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere's one way to write it using\
    \ sets!\n<code>", "  (let ((i1 0 (i2 0))\n        (i1q nil)\n        (i2q nil))\n\
    \    (if (null? l1)\n        (reverse i1q)\n        (if (null? l2)\n         \
    \   (reverse i2q)\n            (let ((c (aref l1 i1)))\n              (if (equal?\
    \ c c)\n                  (if (< (aref l2 i2) i1)\n                      (cons\
    \ c (common (cdr l1) (cdr l2))\n                         (set! i1 (+ i1 1))\n\
    \                         (set! i2 (+ i2 1)))\n                    (cons c (common\
    \ l1 (cdr l2))\n                           (set! i1 (+ i1 1))\n              \
    \             (set! i2 (+ i2 1)))))\n                (if (< (aref l2 i2) i1)\n\
    \                    (cons c (common l1 (cdr l2))\n                          \
    \ (set! i1 (+ i1 1))\n                           (set! i2 (+ i2 1))\n        \
    \                   (set! i1q (cons c (cons i1 (cdr i1q))\n                  \
    \                            (set! i1 (+ i1 1))))\n                    (cons c\
    \ (common l1 (cdr l2))\n                           (set! i1 (+ i1 1))\n      \
    \                     (set! i2 (+ i2 1))\n                           (set! i2q\
    \ (cons c (cons i2 (cdr i2q))\n                                              (set!\
    \ i2 (+ i2 1))))\n                    (cons c (common l1 (cdr l2))\n         \
    \                  (set! i1 (+ i1 1))\n                           (set! i2 (+\
    \ i2 1)))))))\n        (let ((c (aref l1 i1)))\n          (if (equal? c c)\n \
    \             (if (< (aref l2 i2) i1)\n                  (cons c (common (cdr\
    \ l1) (cdr l2))\n                         (set! i1 (+ i1 1))\n               \
    \          (set! i2 (+ i2 1)))\n              (cons c (common l1 (cdr l2))\n \
    \                    (set! i1 (+ i1 1))\n                     (set! i2 (+ i2 1)))))\n\
    \        (let ((c (aref l1 i2)))\n          (if (equal? c c)\n              (if\
    \ (< (aref l2 i2) i2)\n                  (cons c (common (cdr l1) (cdr l2))\n\
    \                         (set! i1 (+ ", "  (sort l1 (lambda (x y)\n         \
    \    (equal? x y\n                    (car l2)\n                    (cdr l2)))))\n\
    </textarea></form>\n\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-racket\"\n      });\n    </script>\n\n    <p>\n        Simple\
    \ mode that tries to handle Racket code as best as it can.\n    </p>\n\n    <p><strong>MIME\
    \ types defined:</strong> <code>text/x-racket</code>.</p>\n</article>\n\n<|/ file\
    \ dstars=2 source=github |>\n<| c |>\nThanks so much. That's exactly what I was\
    \ looking for!\n<|/ c |>\n<| a |>\nIn Racket you can use the sort routine to find\
    \ the common elements of two lists.\n<code>", "  (cond ((null? l1) l2)\n     \
    \   ((equal? (car l1) (car l2))\n         (common (cdr l1) (cdr l2)))\n      \
    \  (else (cons (car l1)\n                   (common (cdr l1) l2)))))\n", "  (let\
    \ ((lst (make-hash (hash-set (union (hash-keys l1) (hash-keys l2))))))\n    (do\
    \ ((i 0 (1+ i)))\n        ((< i (hash-size lst)))\n      (hash-ref lst (hash-key\
    \ i))))\n)\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| c |>\nThank you\
    \ for this! It helps a lot. Just a follow up question. How would you implement\
    \ the O(n log n) solution?\n<|/ c |>\n<| c |>\nThe `#lang racket` solution is\
    \ `O(n log n)` because it uses a hash table (hash-set, hash-ref, hash-keys). \
    \ It does not use `append` at all, which is `O(n)`, even for lists.\n<|/ c |>\n\
    <| c |>\nAhh that makes a lot of sense. So the O(n) solution is the O(n) hash-set\
    \ solution?\n<|/ c |>\n<| c |>\nO(n) is *not*. The O(n) solution is the O(n log\
    \ n) solution. The hash solution is `O(n)`, because it uses a hash table (hash-set,\
    \ hash-ref, hash-keys), which has `O(n)` lookups, even for lists.\n<|/ c |>\n\
    <| c |>\nAh ok, that makes sense. Thank you very much!\n<|/ c |>\n<| a dscore=0\
    \ |>\nAnother solution based on hash-set\n<code>", "  (sort\n   (remove-duplicates\
    \ ; Remove duplicates.\n     (remove-if-not ; Remove all elements that are not\
    \ in the other list.\n\t (lambda (x) (member x l2)))))) ; And then just remove\
    \ all duplicates.\n", "  (remove-duplicates (remove-duplicates l1 l2) (remove-duplicates\
    \ l2 l1)))\n</code>\n<|/ a tags=racket,scheme,list |>\n<| c |>\nThanks, that helped\
    \ me understand what's going on, and I now understand how it works\n<|/ c |>\n\
    <| a tags=racket,scheme,list |>\n<code>", "  (remove-if (lambda (x) (equal? (car\
    \ l1) x)) l2))\n</code>\n<|/ a dscore=1 tags=racket,scheme |>\n<| a dscore=1 |>\n\
    If you don't want use SRFI sets, you can define a sorted set and use the remove\
    \ procedure to remove an element.\n<code>\n#lang racket\n", "  (filter\n   (lambda\
    \ (x)\n    (includes? x (sort l2 <???)))\n   (sort l1 <???)))\n", "  (sort (remove-duplicates\
    \ (fold-left \n                             (\u03BB (a b) \n                 \
    \              (cond\n                                [(null? a) (cons (car b)\
    \ a)] \n                                [(null? b) (cons (car a) b)] \n      \
    \                          [(equal? (car a) (car b)) (cons (car b) a)]\n     \
    \                           [else (cons (car b) (cons (car a) b))])))\n      \
    \                       l1 l2)) 'asc))\n", "  (sort (remove #(equal? (car %) %)\
    \ l1) <))\n", "  (define (helper l1 l2)\n    (cond\n      [(or (empty? l1) (empty?\
    \ l2)) #f]\n      [(equal? (first l1) (first l2)) (helper (rest l1) (rest l2))]\n\
    \      [else (helper (rest l1) l2)]\n      ))\n  (helper l1 l2))\n", "  (if (null?\
    \ l1)\n      (reverse l2)\n      (cons (first l1) (common (rest l1) l2))))\n",
  "  (sort (remove-duplicates\n           (map (\u03BB (e) (equal? (first e) (string-ref\
    \ l1 0)\n                          (string-ref l2 0))) (sort l1 l2)))))\n</code>\n\
    As you can see, I used remove-duplicates to eliminate duplicates, because it's\
    \ faster than set-member. After that, I just used map to compare the first character\
    \ of both lists and map the rest of the elements to the lists.\n<|/ a dscore=2\
    \ tags=common-lisp,racket,lisp |>\n<| c |>\nAwesome solution.  It is a very good\
    \ exercise to try to work out why this works.  I do have two comments: 1. The\
    \ use of remove duplicates makes this solution O(n\xB2 log n) where n is the length\
    \ of the shorter list.  I would suggest using remove-duplicates on the two lists\
    \ first, then call common.  2. I would suggest not using sort and map like that\
    \ - this approach is O(n\xB2).  I would suggest using the fact that the length\
    \ of a list is a function of the number of elements in the list, or sorting using\
    \ a binary sort algorithm.\n<|/ c |>\n<| c |>\n: 1) Agreed. 2) Not sure I agree\
    \ with that. 3) Yes, this solution is O(n\xB2 log n) because the lists are first\
    \ sorted. How would you do the same with a sort and map operation? 4) I'm going\
    \ to edit my answer to reflect that.\n<|/ c |>\n<| a |>\nAs already pointed out\
    \ by Benjamin Wolf, the correct approach is to use set-member. Here's another\
    \ approach, which uses subseq:\n<code>", "  (sort\n   (remove-duplicates ; Remove\
    \ duplicates.\n    (cond ((or (eq? l1 '()) (eq? l2 '())) '()) ; Empty lists return\
    \ empty list.\n          ((and (number? (car l1)) ;; Non-numbers are disallowed.\n\
    \                (number? (car l2)) ;; Non-numbers are disallowed.\n         \
    \       (< car l1) ;; All number are ordered.\n                (< car l2)) ; All\
    \ number are ordered.\n          ((and (number? (car l1)) ;; Non-numbers are disallowed.\n\
    \                (number? (car l2)) ;; Non-numbers are disallowed.\n         \
    \       (> car l1) ;; All number are ordered.\n                (> car l2)) ; All\
    \ number are ordered.\n          ((and (number? (car l1)) ;; Non-numbers are disallowed.\n\
    \                (number? (car l2)) ;; Non-numbers are disallowed.\n         \
    \       (<= car l1) ;; All number are ordered.\n                (<= car l2)) ;\
    \ All number are ordered.\n          ((and (number? (car l1)) ;; Non-numbers are\
    \ disallowed.\n                (number? (car l2)) ;; Non-numbers are disallowed.\n\
    \                (>= car l1) ;; All number are ordered.\n                (>= car\
    \ l2)) ; All number are ordered.\n          ((and (pair? (car l1)) ;; Non-pairs\
    \ are disallowed.\n                (pair? (car l2)) ;; Non-pairs are disallowed.\n\
    \                (< (car l1) (car l2)) ;; All pairs are ordered.\n           \
    \     (> (car l1) (car l2))) ; All pairs are ordered.\n          ((and (pair?\
    \ (car l1)) ;; Non-pairs are disallowed.\n                (pair? (car l2)) ;;\
    \ Non-pairs are disallowed.\n                (<= (car l1) (car l2)) ;; All pairs\
    \ are ordered.\n                (>= (car l1) (car l2))) ; All pairs are ordered.\n\
    \          ((and (pair? (car l1)) ;; Non-pairs are disallowed.\n             \
    \   (pair? (car l2)) ;; Non-pairs are disallowed.\n                (>= (car l1)\
    \ (car l2)) ;; All pairs are ordered.\n                (< (car l1) (car l2)))\
    \ ; All pairs are ordered.\n          ((and (list? (car l1)) ;; Non-lists are\
    \ disallowed.\n                (list? (car l2)) ;; ", "  (filter (lambda (x) (member\
    \ x l2)) (sort l1)))\n", "  (cond\n    [(null? l1) l2]\n    [(null? l2) l1]\n\
    \    [(not (eq? (first l1) (first l2))) (cons (first l1) (common rest (rest l2)))]\n\
    \    [else (common rest (rest l1))]))\n", "  (let ((hash (make-hash (sort l1 string<)\
    \ string=?)))\n    (do ((x l1 (hash x) (hash (first x))))\n        ((endp l1)\n\
    \         (let ((x (rest l1)))\n           (if (hash (first x))\n            \
    \   (hash (first x))\n               (hash (first x))\n               (hash (first\
    \ x))\n               (hash (first x))\n               (hash (first x)))))))\n\
    </code>\nEDIT\n<code>\n#lang racket\n", "  (sort (remove-duplicates \n       \
    \    (map (\u03BB (el) (if (equal? (car l1) el) (car l2) el)) l2))))\n", "  (sort\
    \ (set l1) (lambda (x y) (not (null? (find-if #(equal? (car x) (car y)) #t) l2)))))\n",
  "  (remove-duplicates \n   (remove-if (lambda (x)\n                (not (equal?\
    \ (car l1) x)))\n            l2)\n   (remove-duplicates \n   (remove-if (lambda\
    \ (x)\n                (not (equal? (car l2) x)))\n            l1)\n   (remove-duplicates\
    \ \n   (remove-if (lambda (x)\n                (not (equal? (car l1) x)))\n  \
    \          (sort l2))\n   (remove-duplicates \n   (remove-if (lambda (x)\n   \
    \             (not (equal? (car l2) x)))\n            (sort l1)))))\n", "  (sort\
    \ (remove (set (sort l1)) (sort l2))))\n", "  (filter\n   (lambda (elt)\n    \
    \ (member (car l1) l2))\n   (remove-duplicates l1)))\n", "  (if (null? l1)\n \
    \     '()\n      (if (member l2 l1)\n          (member l2 l1)\n          (common\
    \ (remove l1 l2) l2)))) ; Remove common elements\n</code>\nThe function removes\
    \ elements from lists, while keeping them sorted. The function common, then, takes\
    \ the two lists and returns the sorted unique common elements. \nEDIT:\nAs a commenter\
    \ pointed out, the solution could have been written better using the following\
    \ idiom:\n<code>", "  (sort (remove-duplicates l1 (remove-duplicates l2)))\n \
    \ )", "  (cond\n    ((null? l1)\n     (reverse l2))\n    ((null? l2)\n     (reverse\
    \ l1))\n    ((eq? (car l1) (car l2))\n     (common (cdr l1) (cdr l2)))\n    (else\n\
    \     (cons (car l1) (common (cdr l1) l2)))\n    ))", "  (remove-if\n   (lambda\
    \ (x) (empty? l2))\n   (remove-if\n    (lambda (x) (empty? l1))\n    (cons (first\
    \ l1) (common (rest l1) (rest l2)))) ))\n", "  (cond [(null? l1) l2]\n       \
    \ [else (or (cdr (last l1)) (cdr (last l2)))]))\n", "  (sort (remove-duplicates\n\
    \          (map (lambda (el) (member (first l1) el))\n              (remove-duplicates\n\
    \               (map (lambda (el) (member (first l2) el))\n                  l2)))\n\
    \        > (lambda (a b) (< a b))\n        > (lambda (a b)\n            (< (length\
    \ (remove-duplicates a)) (length (remove-duplicates b)))\n            (< (length\
    \ a) (length b)))))\n  )\n</code>\n<|/ a tags=racket,algorithm |>\n<| a tags=racket,algorithm\
    \ |>\nI implemented a racket solution which runs in O(n) time and O(n log n) space,\
    \ while using hash-tables and is also very concise:\n<code>", "  (sort (remove\
    \ (set l1)\n                (remove (set l2)\n                         (append\
    \ (remove (set l1) l2)\n                                (remove (set l2) l1))))\n\
    \        > (lambda (x y) (= x y))))\n", "  (sort (remove-duplicates \n       \
    \   (remove-if-not (lambda (x) (equal? (car l1) x)) l2)\n          (remove-if-not\
    \ (lambda (x) (equal? (car l2) x)) l1))))\n</cell>\n<text>\nremove-if-not filters\
    \ elements from the list for which a predicate is true\n\n\n</text>\n<code language=racket-student>\n\
    #lang racket\n", "  (cond [(null? l1) l2]\n        [(member (car l1) l2)\n   \
    \      (common (cdr l1) l2)]\n        [(member (car l2) l1)\n         (common\
    \ (cdr l1) l2)]))\n", "  (cond\n    ((null? l1) l2)\n    ((member (car l1) l2)\n\
    \     (common (cdr l1) l2))\n    ((member (car l2) l1)\n     (common (cdr l1)\
    \ l2))\n    (else\n     (cons (car l1) (common (cdr l1) l2)))))\n", "  (sort (remove\
    \ (sort l1) l2)\n        (< identity)))\n", "  (cond [(empty? l1) l2]\n      \
    \  [(empty? l2) l1]\n        [else (let [smallest (least (car l1) l2)]\n     \
    \            (if (empty? l1)\n                     (reverse l2)\n            \
    \         (if (eq? (car l1) (car l2))\n                         (append (common\
    \ (cdr l1) l2)\n                                  (list (car l1)))\n         \
    \                (append (common (cdr l1) l2)\n                              \
    \    (list (car l2)))))]))))\n", "  (let ((s1 ())\n        (s2 ()))\n    (cond\
    \ [(null? l1) l1]\n          [(null? l2) l2]\n          [else (cons (first l1)\n\
    \                       (if (equal? (first l1)\n                             \
    \   (first l2))\n                          s1\n                          s2)))]\n\
    \    [else (cons (first l2)\n                (common s1\n                    \
    \     (append s2 (rest l1) (rest l2)))]))))\n", "  (cond ((null? l1)\n       \
    \  (reverse l2))\n        ((null? l2)\n         (reverse l1))\n        (else (cons\
    \ (first l1)\n                    (common (rest l1)\n                        \
    \  (rest l2))))))\n", "  (set! common (remove (sort (distinct-by (lambda (x) (=\
    \ x l1)) l2)) l1))\n  (remove l2 common))\n", "  (filter\n   (lambda (el)\n  \
    \    (member? el l1 l2))\n   (sort l1 <)))\n", "  (sort (set-intersection (set-difference\
    \ l1 l2) (set-difference l2 l1))))\n", "  (if (or (null? l1) (null? l2))\n   \
    \   '()\n      (if (equal? (car l1) (car l2))\n          (car l1)\n          (if\
    \ (equal? (car l1) (cadr l2))\n              (cons (car l1) (common (cdr l1) l2))\n\
    \              (cons (car l1) (common (cdr l1) (cdr l2)))))))\n", "  (remove-if\
    \ (lambda (e) (equal? (car l1) e)) l2))\n</code>\n<|/ a tags=scheme,racket,lisp,functional-programming\
    \ |>\n<| c |>\nIt would be interesting to see how you'd do this using `remove-if`,\
    \ as opposed to `remove`.  I expect that would require one to build an association\
    \ between each element and the positions of its predecessors, which is likely\
    \ to be very inefficient.\n<|/ c |>\n<| c |>\nYes, I agree that using `remove-if`\
    \ would require building a hash that maps each element to the positions of its\
    \ predecessors.  This can be inefficient (O(n^2)), particularly if you only need\
    \ to compare a few elements before deciding which one to remove.  I was thinking\
    \ of using `remove-if` and then removing the elements with indices from 0..n from\
    \ the original list, then merging the positions.  I'm not sure this would be any\
    \ faster though, since removing an element is O(n) and then inserting it afterward\
    \ would require O(n) anyway.\n<|/ c |>\n<| c |>\nI added a second solution that\
    \ uses `remove-if`, which I think is likely to be more efficient.\n<|/ c |>\n\
    <| a tags=scheme,racket,lisp,functional-programming |>\nIt can be done in racket.\n\
    <code>", "  (sort (remove (hash (sort l1) (sort l2))\n               (remove (hash\
    \ (sort l1) (sort l2) #:key (lambda (x) (length x))) l2)\n               #:key\
    \ (lambda (x) (length x)) l1))))\n</code>\nThe hash function takes the first element\
    \ of a list as the key, and returns the number of occurrences of the element as\
    \ a value. Then we sort all the elements in the list to get unique elements. Finally,\
    \ we remove all elements in the second list from unique elements list to remove\
    \ duplicate elements. Then we sort the unique elements again to get the sorted\
    \ common elements.\n<|/ a tags=racket,scheme dscore=2 |>\n<| a tags=racket,scheme\
    \ |>\nThe following is a solution using hash tables. \n<code>", "  (remove-if\
    \ (lambda (x) (or (member x l1) (member x l2))) l1))\n</code>\n<code>\n#lang racket\n",
  "  (let ((l1 (reverse l1))\n        (l2 (reverse l2)))\n    (if (or (empty? l1)\
    \ (empty? l2))\n        '()\n        (let* ((s1 (remove l1 (remove l2 l1)))\n\
    \               (s2 (remove l2 (remove l1 l2))))\n          (cond ((empty? s1)\
    \ s2)\n                ((empty? s2) s1)\n                (else (append (sort s1\
    \ lt?) s2))))))))\n", "  (cond\n    [(empty? l1) (empty? l2)] '()\n    [(not (list?\
    \ (first l1))) (not (list? (first l2))) (append l1 l2)] \n    [else (if (< (first\
    \ l1) (first l2)) (append l1 (common (rest l1) l2))\n               (append l2\
    \ (common (rest l2) l1)))]))\n", "  (sort (remove l1 (union l1 l2) #:key (lambda\
    \ (x y) (< x y))))\n  )\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,scheme\
    \ dscore=0 |>\nI solved this in O(n log n) time complexity, where n is the total\
    \ length of the lists. This is not the fastest solution, but I feel it could work\
    \ for this question, since a naive O(n^2) solution would have O(n log n) complexity\
    \ by sorting the list twice.\n<code>", "  (sort (remove-duplicates\n         \
    \ (lambda (x) (remove-if-not (member x l2) l1))\n          l2))\n)\n", "  (cond\n\
    \    [(null? l1) l2]\n    [(null? l2) l1]\n    [else (cons (car l1) (common (cdr\
    \ l1) l2))]))\n", "  (sort (remove-duplicates \n         (set-diff (set-intersection\
    \ l1 l2) \n                   (set-intersection l2 (set-intersection l1 l2))))\
    \ \n        >))\n", "  (sort (remove-duplicates (remove-if-not (lambda (x) (equal?\
    \ x l2))\n                               (remove-if-not (lambda (x) (equal? x\
    \ l1))\n                                           l1))) into-compare))\n", " \
    \ (filter (lambda (x) (memberx x l1)) (sort l2)))\n", "  (if (null? l1)\n    \
    \  (if (null? l2)\n          ()\n          l2)\n      (if (equal? l1 l2)\n   \
    \       l1 l2))\n  (let ([h1 (car l1)])\n    (if (null? l1)\n        l2\n    \
    \    (let ([h2 (car l2)])\n          (if (equal? h1 h2)\n              (if (null?\
    \ (cdr h1))\n                  (cons h1 (common h2 (cdr l2)))\n              \
    \    (common (cdr h1) (cdr h2)))\n              (if (null? (cdr h2))\n       \
    \           (cons h1 (common h2 (cdr l1)))\n                  (common (cdr h1)\
    \ (cdr h2)))\n              (common (cdr l1) (cdr l2))))))))\n", "  (cond [(empty?\
    \ l1) l2]\n        [(member (first l2) l1) (cons (first l1) (common (rest l1)\
    \ l2))]\n        [else (common (rest l1) l2)]))\n</code>\nEDIT:\nAs it turns out,\
    \ this implementation is sub-optimal. While it works with small lists, it fails\
    \ at larger ones. I decided to rewrite the algorithm in a more functional way:\n\
    <code>", "  (remove-duplicates (sort (filter (\u03BB (el) (eq? (first l1) (first\
    \ l2)) (second l1) (second l2))) insensitive?)))\n", "  (set\n   (filter\n   \
    \ (lambda (x)\n     (equal? (car l1) x)\n     (equal? (cdr l2) x))\n    l2)\n\
    \   (car l1)))\n", "  (sort (filter (lambda (el)\n                   (member el\
    \ l1 l2))\n                 l1)\n        ascending))\n", "  (cond\n    ((null?\
    \ l1) l2)\n    ((null? l2) l1)\n    ((equal? (car l1) (car l2)) (common (cdr l1)\
    \ (cdr l2)))\n    (else (cons (car l1) (common (cdr l1) l2)))\n  ))\n", "  (if\
    \ (null? l1)\n      (if (null? l2)\n          ()\n          l2)\n      (if (equal?\
    \ (car l1) (car l2))\n          (common (cdr l1) (cdr l2))\n          (if (member?\
    \ (car l1) l2)\n              (common (cdr l1) l2)\n              (common (cdr\
    \ l1) (cdr l2))))))\n", "  (remove-duplicates \n   (remove-if (lambda (x) (not\
    \ (equal? x null))) \n              (remove-if (lambda (x) (not (equal? x null)))\
    \ \n                          (remove-if (lambda (x) (not (equal? x null))) \n\
    \                                   l1)\n                          l2)\n     \
    \         (remove-if (lambda (x) (not (equal? x null))) \n                   \
    \       (remove-if (lambda (x) (not (equal? x null))) \n                     \
    \              l2)\n                          l1))))\n", "  (remove-if (\u03BB\
    \ (x) (equal? (first l1) x)) l2))\n", "  (remove-if (lambda (n) (equal? (first\
    \ l1) n)) l2))\n", "  (sort (remove-duplicates #(if (equal? (car %) (car %2))\
    \ (cons (car %) (car %2)) nil) l1) <))\n", "  (cond\n    [(empty? l1) l2]\n  \
    \  [(empty? l2) l1]\n    [else (let ((head (first l1)))\n            (let ((head\
    \ (first l2)))\n              (cond\n                [(member head l2)\n     \
    \            (cons head (common tail (rest l2)))]\n                [else (cons\
    \ head (common (rest l1) (rest l2)))]))]))) ;; #lang racket\n", "  (sort (interleave\
    \ l1 (remove-duplicates l2))))\n", "  (let loop ((l1 l1) (l2 l2)\n           \
    \  (common '() '()))\n    (if (null? l1)\n        (reverse common)\n        (if\
    \ (equal? l1 (car l2))\n            (loop (cdr l1) (cdr l2) (cons (car l1) common))\n\
    \            (loop (cdr l1) (cdr l2) common))))))\n</code>\nI used the Common\
    \ Lisp style of coding, in which the common part is separated from the loop body\
    \ by a newline. I also used the let loop construct to make it easier to read and\
    \ debug. This style makes the code more readable, maintainable, and concise.\n\
    <|/ a tags=list,common-lisp,algorithm dscore=1 |>\n<| a |>\nThe code below doesn't\
    \ return the desired output. I believe the output should contain elements that\
    \ are in both lists and then return the sorted elements. \n<code>", "  (cond (empty?\
    \ l1) l2)\n        (empty? l2) l1)\n  (cond\n    ((< (first l1) (first l2))\n\
    \      (common l2 (rest l1)))\n    ((< (first l2) (first l1))\n      (common l1\
    \ (rest l2)))\n    ((= (first l1) (first l2))\n      (common l2 (rest l2)))\n\
    \    (else\n      (cons l1 common (rest l1) (common l1 (rest l2)))))))\n", " \
    \ (sort (remove-duplicates l1) <))\n</code>\n<|/ a |>\n<| c |>\nHi, can you explain\
    \ how this works with an example? I am new to racket.\n<|/ c |>\n<| c |>\nThank\
    \ you for the example! How would I modify this function to return unique elements?\n\
    <|/ c |>\n<| c |>\nI updated my answer to include a function to remove duplicates.\n\
    <|/ c |>\n<| c |>\nYou don't need `sort` and `remove-duplicates`, a simple `(remove\
    \ (some (lambda (x) (null? x)) l2) l1)` will do.\n<|/ c |>\n<| c |>\nOh wow, that's\
    \ interesting. Never thought of that. I'll have to remember that one.\n<|/ c |>\n\
    <| a tags=scheme,racket,list |>\nHere's a variant which uses recursion, and doesn't\
    \ use set-car! (which is not tail recursive):\n<code>", "  (if (null? l1)\n  \
    \    (list*)\n      (let ([l1head (car l1)])\n        (cond [(not (member l1head\
    \ l2)) (cons l1head (common l2 (cdr l1)))]\n              [(member (car l2) l1)\
    \ (cons (car l2) (common l1 (cdr l2)))]\n              [else (common l1 (cdr l2))])))\n\
    </code>\n<|/ a |>\n<| c |>\nI thought about this solution, but I wasn't sure if\
    \ it would work and I wasn't sure if it would make things more efficient.\n<|/\
    \ c |>\n<| c |>\nActually, I am not sure that it will work for my purposes, although\
    \ I haven't tried it yet. I would like to get this method to work, but with the\
    \ possibility of using it for non-sorted lists.\n<|/ c |>\n<| c |>\n- It does\
    \ work.  And if you want it to be efficient, you would have to write it using\
    \ only `member`.\n<|/ c |>\n<| c |>\nI've just tested this and it works. I'll\
    \ have to test it with a large list to see how it performs over time, but I believe\
    \ this may be the most efficient method for my purposes.\n<|/ c |>\n<| a dscore=2\
    \ |>\nOkay, since none of the answers so far have worked for me, I've found a\
    \ way to do it.\nI've started writing a program that checks each number in the\
    \ first list against each number in the second list, then creates a new list that\
    \ is just the numbers that match. I can then use that list to compare against\
    \ the original list. My code is as follows:\n<code>", "  (let loop ((l1 l1) (l2\
    \ l2) (result '()))\n    (cond [(empty? l1) result]\n          [(empty? l2) result]\n\
    \          [(equal? (first l1) (first l2)) (loop (rest l1) (rest l2) (cons (first\
    \ l1) result))]\n          [(equal? (first l2) (first l1)) (loop (rest l1) (rest\
    \ l2) (cons (first l2) result))]\n          [(equal? (first l1) (first l2)) (loop\
    \ (rest l1) (rest l2) result)]\n          [(equal? (first l2) (first l1)) (loop\
    \ (rest l1) (rest l2) result)]\n          [else (loop (rest l1) (rest l2) (cons\
    \ (first l1) result))]))))\n", "  (sort (remove-duplicates l1)\n        (remove-duplicates\
    \ l2)))\n", "  (sort (remove-duplicates (flatten (intersect\n                \
    \                            (remove-duplicates l2\n                         \
    \                                     (remove-duplicates l1\n                \
    \                                                    (remove-duplicates l2\n \
    \                                                                 l1)))))))\n",
  "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    (else (if (< (car l1) (car\
    \ l2)) (car l1) (car l2)))))\n", "  (let loop ((l1 l1) (l2 l2) result (list* '()\
    \ '()))\n    (cond\n      ((null? l1)\n       (reverse result))\n      ((null?\
    \ l2)\n       (reverse result))\n      (else\n       (loop\n        (rest l1)\n\
    \        (rest l2)\n        (cons (if (< (first l1) (first l2))\n            \
    \       (first l1)\n                   (first l2))\n              (if (< (first\
    \ l1) (first l2))\n                   (loop (rest l1) l2 result)\n           \
    \        (loop (rest l1) l1 (cons (first l2) result)))))\n      )))\n", "  (define\
    \ sorted1 (sort l1 <))\n  (define sorted2 (sort l2 <))\n  (define i1 (first (filter\
    \ (\u03BB (e) (not (member e sorted1))) sorted2)))\n  (define i2 (first (filter\
    \ (\u03BB (e) (not (member e sorted2)) ) sorted1)))\n  (if (< i1 i2)\n      (cons\
    \ i1 (common sorted2 (drop i1 sorted2)))\n      (cons i2 (common sorted1 (drop\
    \ i2 sorted1)))))\n", "  (append (rest (sort (union l1 (sort l2))) l1)\n     \
    \     (remove-duplicates l2)))\n", "  (let loop ([l1 l2]\n             [s1 s2]\n\
    \             [len1 len2])\n    (if (null? l1)\n        (reverse s1)\n       \
    \ (loop (rest l1) (rest s1) (+ len1 len2) (rest len2)))\n    (if (null? l2)\n\
    \        (reverse s2)\n        (loop (rest l2) (rest s2) (+ len1 len2) (rest len2)))))\n",
  "  (remove (remove-duplicates l1)\n          (remove-duplicates l2)))\n", "  (sort\
    \ (remove-duplicates \n          (map (lambda (e) (member e l1)) l2)\n       \
    \  <))))\n</code>\nThis solution is probably the best one since it uses built-in\
    \ procedures (and it's shorter and easier to understand!).\n<|/ a |>\n<| c |>\n\
    Nice solution.  I didn't think about this sort of problem.\n<|/ c |>\n<| a tags=racket,set\
    \ |>\nAnother solution that doesn't use sets:\n<code>", "  (define (helper l1\
    \ l2 acc)\n    (cond\n      [(empty? l1)\n       (reverse acc)\n       ;; Nothing\
    \ left after l1 is exhausted.\n       ;; Return acc\n       ]\n      [(empty?\
    \ l2)\n       (reverse acc)\n       ;; Nothing left after l2 is exhausted.\n \
    \      ;; Return acc\n       ]\n      [else\n       (let ((a (first l1))\n   \
    \          (b (first l2)))\n         (if (equal? a b)\n             (helper (rest\
    \ l1) (rest l2) (cons a acc))\n             (helper (rest l1) (rest l2) acc))\n\
    \       )])\n  (helper l1 l2 #()))\n", "  (let ((l1 (sort l1 reverse))\n     \
    \   (l2 (sort l2 reverse)))\n    (cond [(or (= (length l1) (length l2)) ; If they\
    \ are equal, don't bother.\n              (and (empty? l1) (empty? l2))) ; If\
    \ they are both empty, return empty list.\n         empty]\n          [else\n\
    \           (if (> (length l1) (length l2))\n               (begin (set! l1 l2)\
    \ ; Reverse the order of the lists.\n                     (set! l2 (append l2\
    \ (list (first l1)))))\n               (begin (set! l1 l2) ; Reverse the order\
    \ of the lists.\n                     (set! l1 (append l1 (list (first l1))))))\n\
    \           (if (> (length l1) (length l2))\n               (begin (set! l1 l2)\n\
    \                     (set! l2 (append l2 (list (first l1)))))\n             \
    \  (begin (set! l1 l2))])\n           (if (< (length l1) (length l2))\n      \
    \         (begin (set! l1 l2)\n                     (set! l2 (append l2 (list\
    \ (first l1)))))\n               (begin (set! l1 l2))])))\n", "  (sort (remove\
    \ l1 l2)\n         (< <??>)))\n</code>\nThe remove function removes duplicates\
    \ from a list. the sort function sorts the list and returns it. the <??> is an\
    \ empty list that matches the sort function.\n<|/ a tags=racket,scheme |>\n<|\
    \ c |>\nThanks! I knew about the `remove` function, but I did not think of doing\
    \ it that way with `sort` and `<` !\n<|/ c |>\n<| c |>\nHow would you do it without\
    \ using remove?  You need sort and <.\n<|/ c |>\n<| c |>\n: You said \"without\
    \ using remove\". `remove` was just one way of doing it, but there are other ways\
    \ as well.\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution that doesn't require\
    \ remove, sort and <. Instead, it uses foldl which basically is a combination\
    \ of the map and foldr operations. map is used to transform a list to a list of\
    \ lists. foldr is used to traverse the list from end to start. Indeed, to map\
    \ a list to another list, we use map and to traverse a list from end to start,\
    \ we use foldr. Here it is:\n<code>", "  (cond [(empty? l1) l2]\n        [(empty?\
    \ l2) l1]\n        [(member l1\n                 (filter (lambda (x) (member x\
    \ l2))\n                         (reverse (reverse l1))))\n         (cons (first\
    \ l1)\n               (common rest (filter (lambda (x) (not (member x l2)) l1)))]\n\
    \        [else (common l1 (rest l2))]))\n</code>\n<|/ a |>\n<| a |>\nI assume\
    \ you want the result to be sorted so I've used a named let for clarity.\n<code>",
  "  (cond ((null? l1) l2)\n        ((null? l2) l1)\n        (else (let ([s1 l1 (set!\
    \ s1 '())\n                     s2 l2 (set! s2 '())\n                     l1 (remove-duplicates\
    \ s1)\n                     l2 (remove-duplicates s2)])\n                (if (empty?\
    \ s1) l2\n                    (if (empty? s2) l1\n                        (common\
    \ (rest s1) (rest s2))))))))\n", "  (sort (remove-if (lambda (e) (not (member\
    \ e l1))) l2) '<))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n\
    \    [else\n     (let* ([s1 #(hash (first l1) l2)]\n            [s2 #(hash (first\
    \ l2) l1)])\n       (cond\n         [(equal? s1 s2) '()]\n         [(equal? (hash\
    \ (first s1) s2) (hash (first s2) s1))\n          (cons (first s1) (common tail\
    \ l2))]\n         [else\n          (cons (first s2)\n                (common (rest\
    \ s1) (rest s2)))]))]))))\n", "  (filter\n   (\u03BB (x)\n     (member (car l1)\
    \ l2))\n   (sort l1 <))\n  )\n", "  (let ((len1 (length l1))\n        (len2 (length\
    \ l2)))\n    (let loop ((l1 (reverse l1))\n               (l2 (reverse l2)))\n\
    \      (cond ((= len1 len2)\n             (reverse l1))\n            ((null? l1)\n\
    \             (reverse l2))\n            ((null? l2)\n             (reverse l1))\n\
    \            (else\n             (cond\n               ((< len1 len2)\n      \
    \          (loop (rest l1)\n                       (rest l2)))\n             \
    \  ((< len2 len1)\n                (loop (rest l1)\n                       (rest\
    \ l2)))\n               ((= len1 len2)\n                (loop (rest l1)\n    \
    \                   (rest l2))\n               (else\n                (loop (rest\
    \ l1)\n                       (rest l2)))))))))", "  (sort (remove (set l1) l2)\
    \ <))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n    [else (let\
    \ ([smallest (car l1)])\n             (cond [(< smallest smallest)\n         \
    \           (let ([smallest (car l2)])\n                      (if (empty? l1)\n\
    \                          smallest\n                          (common (cdr l1)\
    \ (cdr l2))))]\n               [(< smallest (car l2))\n                    (let\
    \ ([smallest (car l1)])\n                      (if (empty? l2)\n             \
    \             smallest\n                          (common (cdr l1) (cdr l2))))]\n\
    \               [else (common (cdr l1) (cdr l2))])))]))\n</code>\n<|/ a tags=racket,scheme,functional-programming\
    \ |>\n<| a tags=racket,scheme,functional-programming |>\nI wrote a solution in\
    \ Racket, using sets to solve it. It's more efficient than the other solutions\
    \ listed here. I made it so that it returns a list of matching elements (instead\
    \ of just the first match), but you can easily change that to just return the\
    \ matched element.\n<code>", "  (cond [(empty? l1) l2]\n        [(empty? l2) l1]\n\
    \        [(eq? (first l1) (first l2)) (append (common (rest l1) (rest l2))\n \
    \                                     [(first l1)])]\n        [(eq? (first l2)\
    \ (first l1)) (append (common (rest l1) (rest l2))\n                         \
    \             [(first l2)])]\n        [else (append (common (rest l1) (rest l2))\n\
    \                      [(first l1)])]))\n</code>\n<|/ a tags=racket,scheme |>\n\
    <| c |>\nThanks, this is great. I wish I could vote up this answer a million times.\
    \ I'm fairly new to Racket and I didn't know how to do this with a while loop,\
    \ or recursion.\n<|/ c |>\n<| c |>\nThe key to this problem is recursion.  If\
    \ you don't know how to use that key word, you should be working through an introductory\
    \ tutorial on Racket first so you can learn it.\n<|/ c |>\n<| c |>\nThanks. I\
    \ tried a lot of the solutions here and none were good enough. Your solution works\
    \ great, thanks.\n<|/ c |>\n<| a tags=racket,scheme dscore=1 |>\nThis might be\
    \ a bit too advanced for you at this stage, but I thought I'd give it a go. I\
    \ think it's fairly simple, since you just want the unique items. You can do this\
    \ with recursion and a hash-table, and it'll be a bit faster than using sort.\
    \ I've added a few helper functions, since it helps to know how they work.\n<code>",
  "  (sort (remove-duplicates l1)\n        (remove-duplicates l2)))\n</code>\n<|/\
    \ a tags=scheme,lisp,racket,list |>\n<| c |>\nI wrote a simpler solution, which\
    \ is basically the same as the accepted answer, but with more comments on it.\
    \ Would you be interested in checking it? It's not necessarily better, it depends\
    \ on your personal preference.\n<|/ c |>\n<| a dscore=2 |>\nI ran into a similar\
    \ problem this morning. Here's my solution. It works pretty well and I think it's\
    \ easy to understand. \n<code>", "  (apply interleave (sort l1) (sort l2)))\n\
    </code>\n<|/ a tags=racket,sorting,algorithm,arrays,list |>\n<| c |>\nThe code\
    \ in this answer does not work correctly with empty lists. In particular `(common\
    \ (list #f '()) '(#f '(1 2 3)))` returns `(#f #f)` rather than `(#f 1 2 3)` as\
    \ desired.\n<|/ c |>\n<| c |>\nYeah. The original question had some examples of\
    \ what should happen in that case (no common elements). I just added a comment\
    \ to the answer that says `(common '() '(#f '()))` should return `(#f #f)` rather\
    \ than `'()` (no common elements).\n<|/ c |>\n<| a dscore=3 tags=racket,sorting,algorithm,arrays,list\
    \ |>\n<code>", "  (filter (lambda (i) (member i l1)) l2))\n", "  (cond [(null?\
    \ l1) l2]\n        [(null? l2) l1]\n        [(and (pair? l1) (pair? l2))\n   \
    \      (if (eq? (car l1) (car l2))\n             (common (cdr l1) (cdr l2))\n\
    \             (cons (car l1) (common (cdr l1) (cdr l2))))]\n        [else (append\
    \ (sort (car l1)) (sort (car l2)))]))\n", "  (cond (empty? l1) l2) ;; nothing\
    \ to do\n        (member (first l1) l2) ;; found an element: output it\n     \
    \   (else (cons (first l1)\n                    (common (rest l1) l2))))) ;; didn't\
    \ find an element: recurse\n", "  (cond [(or (empty? l1) (empty? l2)) #f]\n  \
    \      [else (member l1\n                     (sort (remove (subseq l1 (- (length\
    \ l1) 1) (length l2))\n                               (remove l1 (- l1 l2))))\n\
    \                     (sort (remove l2\n                               (remove\
    \ l1 (- l1 l2)))))]))\n</cell>\n<cell>\n#lang racket\n", "  (let loop ((l1 l1)\
    \ (l2 l2) (acc '()))\n    (if (empty? l1)\n        (reverse acc)\n        (loop\
    \ (rest l1) (rest l2)\n              (cons (first l1) acc)))))\n", "  (sort (filter\
    \ (lambda (x) (member (first x) l1)) l2)\n        (< \n         (lambda (x) (if\
    \ (null? x) (first x) (first x))) \n         (lambda (x) (if (null? x) (first\
    \ x) (first x)))))\n  )\n", "  (append (map car l1)\n          (filter #(eq? (car\
    \ %) (cdr %)) l2)))\n", "  (filter \n    (lambda (x) (not (member x l2))) \n \
    \   (sort l1 less)\n  )\n)\n", "  (sort (cycle l1) (lambda (x y) (equal? (first\
    \ l1) (first l2)))))\n", "  (cond ((null? l1)\n         (list->sort l2))\n   \
    \     (else\n         (list->sort (sort (union (subseq l1 0) (subseq l2 0)))))))\n\
    </code>\n<|/ a tags=scheme,racket |>\n<| c |>\n`sort` has some performance issues:\
    \ http://stackoverflow.com/questions/4375923/how-to-implement-a-custom-sort-for-my-own-data-structure-in-racket/\n\
    <|/ c |>\n<| a tags=scheme,racket |>\nHere's a version that uses tail-recursive\
    \ foldl instead of recur:\n<code>", "  (filter (lambda (x) (not (member x l2)))\
    \ (sort l1)))\n", "  (sort (filter (lambda (el) (member el l1)) (filter (lambda\
    \ (el) (member el l2)) l2))))\n", "  (sort (remove-duplicates \n           (remove-if\n\
    \            ;; Compare two lists element by element using #<\n            (lambda\
    \ (x) (< (count l1) (count l2)))\n            (map \n             (lambda (x)\
    \ (cons (car x) (car l2)))\n             (zip (remove-if-not (lambda (x) (empty?\
    \ l1)) (remove-if-not (lambda (x) (empty? l2)) l1)))))))\n", "  (sort (remove-duplicates\
    \ (append l1 l2) #:key (lambda (x) (compare x 0)))))\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis will not work if one list has duplicates.\n<|/ c |>\n<| c |>\nYou're\
    \ right.  It will work if you remove duplicates before sorting.  I updated my\
    \ answer.\n<|/ c |>\n<| a dscore=2 tags=scheme,racket,lisp,functional-programming\
    \ |>\nThe question asks to eliminate duplicate elements (and sort the remaining\
    \ elements), and here is a solution that does it in a functional manner (assuming\
    \ that the input lists are both already sorted):\n<code>", "  (sort l1 (lambda\
    \ (n1 n2)\n             (< (first n1) (first n2))))\n  (sort l2 (lambda (n1 n2)\n\
    \             (< (first n2) (first n1))))))\n", "  (sort (remove-duplicates (fold\
    \ (lambda (e acc) (cons e (filter #(= e %) acc)) l1 l2))))\n)\n", "  (let ((len1\
    \ (length l1))\n        (len2 (length l2)))\n    (cond\n      [(= len1 0) '()]\n\
    \      [(= len2 0) '()]\n      [(< len1 len2) (cons (car l1) (common l1 (cdr l1)))]\n\
    \      [else\n       (let* ([a (subseq l1 0 len1)\n              b (subseq l2\
    \ 0 len2)])\n         (cond\n           [(= (length a) (length b)) '()]\n    \
    \       [(= (length a) 0) (cons (car a) (common b (cdr a)))]\n           [(= (length\
    \ b) 0) (cons (car b) (common a (cdr b)))]\n           [else (cons (car a)\n \
    \                     (common (subseq b 0 (- (length a) len1))\n             \
    \                  (subseq a 0 (- (length b) len2)))]))])))\n", "  (cond [(empty?\
    \ l1) l2]\n        [(empty? l2) l1]\n        [(eq? (first l1) (first l2)) (common\
    \ (rest l1) (rest l2))]\n        [else (cons (first l1) (common (rest l1) l2))]))\n",
  "  (sort (sort l1 '<) l2 '<))\n", "  (remove (lambda (e) (member? e l2)) (remove\
    \ (lambda (e) (member? e l1)) l1)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for the answer. Although I didn't ask for it, I wanted a solution that doesn't\
    \ require using (#lang racket) since I realized in the end that I only need to\
    \ solve this problem in CL.\n<|/ c |>\n<| a |>\nHere's a solution that uses the\
    \ built-in Set (no imports needed):\n<code>", "  (if (or (null? l1) (null? l2))\n\
    \      '()\n      (let ([l (make-unique-sorted-list (cons (first l1) (first l2))))]\n\
    \        (if (empty? l)\n            (car l)\n            (let ((car1 (car l)))\n\
    \              (if (null? (cdr l))\n                  (car1)\n               \
    \   (let ((cdr1 (cdr l)))\n                    (if (= (car l) (cadr l))\n    \
    \                    (append (cons (car l) (car l)) (cdr1))\n                \
    \        (append (cons car1 (car)) (cons cdr1 cdr)))))\n              (append\
    \ (common (cdr l) (cdr l)))))))\n", "  (let ([len (length l1)\n\t     i (- len\
    \ (length l2))])\n    (if (= i 0)\n        '()\n        (let ([l1 (subseq l1 0\
    \ i)\n\t         l2 (subseq l2 0 i)])\n          (if (empty? l1)\n           \
    \   (if (empty? l2)\n                  (subseq l2 0 i)\n                  (common\
    \ (rest l1) (rest l2)))\n              (if (same? (car l1) (car l2))\n       \
    \           (common (rest l1) (rest l2))\n                  (common l1 (rest l2)))))))))\n\
    </cell>\n<text>\nProblem 3: Intersection of Two Linked Lists\nComplete the function\
    \ intersection that takes in two lists and returns a new list with the common\
    \ elements between them.\n\nFor example, for the lists below, the output should\
    \ be:\n\n'(1 2 4)\nBecause the common elements between them are 1 and 4.\n\n\n\
    </text>\n<code language=ocaml-jupyter>\n#lang racket\n", "  (sort (remove-duplicates\
    \ (flatten (remove-if (complement equal?)\n                                  \
    \         (map (lambda (el)\n                                                \
    \    (filter equal? l1 l2)\n                                                 \
    \   (cons el l2))\n                                           l1))))\n       \
    \  <))\n", "  (cond [(empty? l1) l2]\n        [(member? (first l1) l2) (common\
    \ (rest l1) l2)]\n        [else (append l1 (common (rest l1) l2))]))\n", "  (let\
    \ loop ((l1 (reverse l1)) (l2 (reverse l2)) (acc '()))\n    (cond [(empty? l1)\
    \ (append (reverse acc) (list (first l2)))]\n          [(empty? l2) (reverse acc)]\n\
    \          [(equal? (first l1) (first l2)) (append acc (list (first l1)))]\n \
    \         [else\n           (loop (rest l1) (rest l2) (append acc (list (first\
    \ l1))))]))))\n", "  (let ([len1 (length l1)\n\t       len2 (length l2)])\n  \
    \  (assert (or (= len1 0)\n\t\t  (= len2 0))\n\t    (list 'error \"Can only compare\
    \ lists with length > 0.\"))\n    (if (>= len1 len2)\n        (list (list 'error\
    \ \"Can't compare lists with different lengths\"))\n      (let ([index1 (if (null?\
    \ l1)\n\t\t\t      0\n\t\t\t      (- 1 (car l1)))])\n        (let ([index2 (if\
    \ (null? l2)\n\t\t\t      0\n\t\t\t      (- 1 (car l2)))])\n          (if (= index1\
    \ index2)\n              (let ([match (if (= index1 0)\n\t\t\t     (car l1)\n\t\
    \t\t     (cdr l1)))\n                (if (null? match)\n                  (let\
    \ ([match (if (= index2 0)\n\t\t\t\t (car l2)\n\t\t\t\t (cdr l2))])\n        \
    \            (if (null? match)\n                        (list 'error \"List is\
    \ not sublist\"))\n                    (if (< (car match) (car l2))\n        \
    \                (common (cdr l1)\n                               (cdr l2)))\n\
    \                    (if (< (car match) (cdr l1))\n                        (common\
    \ (cdr l1)\n                               (cdr l2)))\n                    (list\
    \ match))\n                (if (< (car l1) (cdr match))\n                    (common\
    \ (cdr l1)\n                           (cdr l2)))\n                (if (< (car\
    \ l1) (cdr l2))\n                    (common (cdr l1)\n                      \
    \     (cdr l2)))))))\n      (let ([match (if (= (- len1 index1) 0)\n\t\t     (car\
    \ l1)\n\t\t     (cdr l1))])\n        (if (null? match)\n          (let ([match\
    \ (if (= (- len2 index2) 0)\n\t\t\t     (car l2)\n\t\t\t     (cdr l2))])\n   \
    \         (if (null? match)\n                (list 'error \"List is not sublist\"\
    ))\n            (if (< (car match) (car l2))\n                (common (cdr l1)\n\
    \                       (cdr l2)))\n            (if (< (car match) (cdr l1))\n\
    \                (common (cdr l1)\n                       (cdr l2)))))))\n  (sort\
    \ (remove-duplicates \n\t   (remove-duplicates \n\t    (remove-duplicates \n\t\
    \       l1) \n\t    l2))))\n", "  (cond [(empty? l1) l2]\n        [(empty? l2)\
    \ l1]\n        [else (let ([a (first l1)]\n                    [b (first l2)]\n\
    \                    [l (rest l1)]\n                    [m (rest l2)]\n      \
    \              [found null])\n               (cond [(null? a) (cons b found)]\n\
    \                     [(null? b) (cons a found)]\n                     [(= a b)\
    \ found]\n                     [(null? l) (cons a found)]\n                  \
    \   [(null? m) (cons b found)]\n                     [else (if (equal? a b)\n\
    \                               (common l m)\n                             (if\
    \ (null? (first l))\n                                 (cons a found)\n       \
    \                          (common l (first m)))))]))]))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like the use of [tag:language-agnostic], but I think it needs\
    \ more explanation.  Are you familiar with [tag:scheme], perhaps?\n<|/ c |>\n\
    <| a tags=racket,common-lisp |>\nThis is more or less the standard merge-sort\
    \ algorithm, except that we have to return both the sorted list and also the indexes\
    \ of the elements in the original lists.  (The indexes can be computed with the\
    \ map function (in Racket but not in Common Lisp).)\n<code>", "  (if (null? l1)\
    \ '()\n      (append (first (sort (remove (car l1) l2)))\n              (common\
    \ (rest l1) l2))))\n", "  (sort (filter (lambda (x) (includes? x l1)) l2)\n  \
    \       (lambda (x) (compare (car x) (car l1)))))\n", "  (cond\n    [(empty? l1)\n\
    \     (cond\n       [(empty? l2)\n        empty]\n       [else l2]])\n     [else\n\
    \      (cond\n       [(equal? (car l1) (car l2))\n        (cons (car l1) (common\
    \ l2 (cdr l1)))]\n       [else (common l2 (cdr l1))])]])\n  ;; O(n log n)\n",
  "  (sort (remove-duplicates (fold-left \n                            (fold-right\
    \ \n                             #f\n                              (remove-if-not\
    \ (lambda (x) (equal? (first x) (fst x)) \n                                  \
    \                      (second x)))\n                                 l1 l2))\
    \ \n                   (remove-if-not (lambda (x) (equal? (first x) (second x)))\n\
    \                                 l1 l2))))\n", "  (sort (remove (\u03BB (x) (find\
    \ l1 x)) l2)\n        (fold-left (\u03BB (x y acc) (if (equal? (find x y) 0) x\
    \ acc)) '() l2))\n)\n", "  (filter (lambda (n) (member n l1)) (distinct l2))\n\
    )\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n    [else (let ([x\
    \ (first l1) y (first l2)])\n               (if (equal? (first l1) (first l2))\n\
    \                   (if (null? (rest l1) l2)\n                     (cons x y)\n\
    \                     (let ([y (common (rest l1) l2)])\n                     \
    \  (if (null? (rest l2) l1)\n                           (cons x y)\n         \
    \                  (let ([x (common (rest l2) l1)])\n                        \
    \     (cons x y))))))]))))\n", "  (sort (remove-duplicates \n          (cond ((null?\
    \ l1) l2)\n                ((member (first l1) l2) l1)\n                (else\
    \ (cons (first l1)\n                             (common (rest l1)\n         \
    \                              (rest l2)))) )))\n", "  (cond [(null? l1) l2]\n\
    \        [(member (car l1) l2) l1]\n        [else (common (rest l1) l2)]))\n",
  "  (if (null? l1)\n      (list) \n      (cons (first l1) (common rest (rest l2)))))\n",
  "  (let ([len1 (length l1)])\n    (let ([len2 (length l2)])\n      (cond [(= len1\
    \ 0) '()]\n            [(= len2 0) '()]\n            [(= len1 len2) (sort l1 l2)]\n\
    \            [else (cons (car l1) (common (sort l1 (rest l1)) l2))])))))\n", " \
    \ (filter distinct (sort (remove-duplicates l1)) (sort (remove-duplicates l2))))\n",
  "  (if (null? l1) l2\n      (if (member l1 (rest l2)) (rest l1) l2)))\n", "  (sort\
    \ (remove-duplicates \n          (remove-if\n           (lambda (x y)\n      \
    \       (equal? (car x) (car y)))\n           l1 l2))))\n", "  (filter not-in\
    \ (sort (set-intersection l1 l2))))\n", "  (sort (remove (lambda (x) (equal? (first\
    \ l1) x)) l2)\n        (lambda (x) (equal? (first l2) x))))\n", '  (sort l1 l2))',
  "  (cond\n    [(null? l1) l2]\n    [(null? l2) l1]\n    [(not (member (car l1) l2))\
    \ (common l1 (cdr l2))]\n    [(member (car l1) l2) (common c1 (cdr l2))]\n   \
    \ [else (cons (car l1) (common (cdr l1) l2))]))\n", "  (if (null? l1)\n      (append\
    \ (sort l2) l2)\n      (append (sort l1) (common (cdr l1) l2))))\n", "  (filter\
    \ (lambda (x)\n            (not (equal? (first x) (nth l1 0)))\n            (equal?\
    \ (first x) (nth l2 0)))\n          (sort l1 <))\n)\n", "  (sort (remove-duplicates\
    \ l1)\n        (remove-duplicates l2)))\n", "  (cond\n    ((null? l1)\n     (cond\n\
    \       ((null? l2)\n        (list null))\n       ((null? (cdr l2))\n        (list\
    \ null))\n       (else\n        (car l1)))\n    ((equal? (car l1) (car l2))\n\
    \     (cond\n       ((null? l2)\n        (list null))\n       ((null? (cdr l2))\n\
    \        (list null))\n       (else\n        (common (cdr l1) (cdr l2))))\n  \
    \  (else\n     (append (list (car l1))\n             (common (cdr l1) l2)))))\n",
  "  (sort (unique-elements (remove (lambda (x y) (memberx x y)) l1 l2))))\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for the answer! Could you maybe also help me with another\
    \ one? http://stackoverflow.com/questions/4255749/how-can-i-make-a-list-that-consists-of-the-elements-of-another-list\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is a solution using Racket Scheme:\n<code>",
  "  (sort (remove-duplicates l1) (lambda (e1 e2) (< (length e1) (length e2)))))\n",
  "  (cond (empty? l1) l2\n        (empty? l2) l1\n        ;; We use the tail when\
    \ they both have elements.\n        (or (null? (rest l1)) (rest (rest l2))\n \
    \            (= (first l1) (first l2))\n             (null? (rest (rest l1))))\n\
    \        (cons (first l1) (common (rest l1) (rest l2)))\n        (common l1 (rest\
    \ (rest l2))))))\n", "  (unique-set\n   (set-common-elements\n    (set-union l1\
    \ l2)\n    (set-intersection l1 l2)\n    ; sort for determinism\n    #:compare\
    \ (lambda (x y)\n              (< (< (first x) (y) (first y)) (second y)))\n \
    \   ))\n  )\n)\n", "  (sort (remove-duplicates (flatten (remove-duplicates (flatten\
    \ (set-intersect (sort l1) (sort l2)))))))\n)\n", "  (sort (remove-if (lambda\
    \ (x) (member x l1) l2) l1) '<))\n", "  (cond\n    ((empty? l1) l2)\n    ((empty?\
    \ l2) l1)\n    ((equal? (car l1) (car l2)) (cons (car l1) (common cdr l2)))\n\
    \    (else (common cdr l2))))\n", "  (filter (lambda (x) (not (member x l2)))\
    \ l1))\n", "  (sort (remove (lambda (x y)\n                  (member x y)))\n\
    \        (cond ((empty? l1) l2)\n              ((empty? l2) l1)\n            \
    \  ((equal? (first l1) (first l2)) (common (rest l1) (rest l2)))\n           \
    \   (else (cons (first l1) (common (rest l1) (rest l2)))) )))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
