name: HumanEval_155_even_odd_count
language: rkt
prompt: "#lang racket\n\n;; Given an integer. return a tuple that has the number of\
  \ even and odd digits respectively.\n;; Example:\n;; even_odd_count(-12) ==> (1,\
  \ 1)\n;; even_odd_count(123) ==> (1, 2)\n(define (even_odd_count num)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n\
  \    (check-equal? (candidate 7) (list 0 1))\n    (check-equal? (candidate -78)\
  \ (list 1 1))\n    (check-equal? (candidate 3452) (list 2 2))\n    (check-equal?\
  \ (candidate 346211) (list 3 3))\n    (check-equal? (candidate -345821) (list 3\
  \ 3))\n    (check-equal? (candidate -2) (list 1 0))\n    (check-equal? (candidate\
  \ -45347) (list 2 3))\n    (check-equal? (candidate 0) (list 1 0))\n))\n\n(test-humaneval)"
completions: ["  (let loop ([n num])\n    (cond [(= n 0) (list 1 1)]\n          [(even?\
    \ (modulo n 10)) (loop (quotient n 10))]\n          [else (loop (quotient n 10))])))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme |>\n<code>", " \
    \ (let ((count 0))\n    (if (= num 0)\n        ((even_odd_count 1) (odd_count\
    \ 0))\n      (let ((digits (string->list num)))\n        (if (> (length digits)\
    \ 2)\n            (begin (set! count 0)\n                    (begin (set! count\
    \ 0)\n                          (if (even? (first digits))\n                 \
    \             ((+ count 1)\n                               (even_odd_count (rest\
    \ digits)))\n                             ((+ count 0)\n                     \
    \        (odd_count (rest digits))))\n                          (if (odd? (first\
    \ digits))\n                              ((+ count 1)\n                     \
    \          (even_odd_count (rest digits)))\n                             ((+ count\
    \ 0)\n                             (odd_count (rest digits)))))\n            count)\n\
    \        (begin (set! count 0)\n               (begin (set! count 0)\n       \
    \               (if (even? (first digits))\n                          ((+ count\
    \ 1)\n                           (even_odd_count (rest digits)))\n           \
    \              ((+ count 0)\n                         (odd_count (rest digits))))\n\
    \                   count)\n               (even_odd_count (rest digits)))))))\n",
  "  (cond [(< num -10) `(,(even_odd_count (- num 10))) (,(num))]\n        [else `(,(even_odd_count\
    \ (/ num (expt 2 0))) (,(odds num)))]))", "  (cond ((< num 0) '())\n        ((=\
    \ (modulo num 2) 0) '((even_count num) (odd_count num)))\n        (else '())))",
  "  (let ([even_count 0]\n        [odd_count 0])\n    (cond [(= num 0) (list even_count\
    \ odd_count)]\n          [(= (num / 10) 0) (set! even_count (+ even_count 1))\n\
    \            (set! odd_count (+ odd_count 1))]\n          [(= (num / 10) 1) (set!\
    \ even_count (+ even_count 1))\n            (set! odd_count (+ odd_count 2))]\n\
    \          [else (set! even_count (+ even_count 1))\n               (set! odd_count\
    \ (+ odd_count 1))])))\n", "  (cond ((< 0 num) '())\n        ((even? num) (cons\
    \ (- num 2) (even_odd_count (- num 2))))\n        (else (cons (- num 1) (even_odd_count\
    \ (- num 1))))))\n", "  (let ((count (make-array 2 :initial-element 0)))\n   \
    \ (loop for i below num\n         for j below 10\n         for k below num\n \
    \        when (and (= (mod num i) (mod k j))\n                   (= (mod k i)\
    \ 0))\n         add1 count))\n  count)\n", "  (let loop ([number num] [even 0]\
    \ [odd 0])\n    (cond [(zero? number) (reverse (list even odd))\n          (equal?\
    \ (modulo-by-remainder number 10) 0) (loop (quotient number 10) (inc even) (add1\
    \ odd))\n          (equal? (modulo-by-remainder number 10) 10) (inc even) (loop\
    \ (quotient number 10) (inc even) (add1 odd))\n          (else (loop (quotient\
    \ number 10) (inc even) odd))]))))\n", "  (cond\n    [(zero? num) (values 0 1)]\n\
    \    [(= (remainder num 2) 0) (values (+ num 1) 2)]\n    [else (values (+ num\
    \ 1) 0)]))\n", "  (let ([even_count (/ num 10)\n         odd_count (/ num (sub1\
    \ num))])\n    (list even_count odd_count)))\n", "  (cond\n    ((= num 0) '()\
    \ )\n    ((odd? num) (cons (mod num 2) (even_odd_count (quot num 2))))\n    (else\
    \       (cons (mod num 2) (even_odd_count (quot num 2)))) ))\n", "  (cond\n  \
    \  ((zero? num) '())\n    ((even? num) (cons num even_odd_count (even_odd_count\
    \ (sub1 num))))\n    ((odd? num) (cons num even_odd_count (even_odd_count (sub1\
    \ num))))\n    (else (even_odd_count (sub1 num)))))\n", "  (cond\n    [(< num\
    \ 0)\n     (error 'even_odd_count \"Sorry, but this function only works with non-negative\
    \ numbers.\")]\n    [(= num 0)\n     (error 'even_odd_count \"Sorry, but this\
    \ function only works with non-zero numbers.\")]\n    [else\n     (let ((even\
    \ (/ num 2))\n           (odd (- num even)))\n       (if (< even 1)\n        \
    \   (error 'even_odd_count \"Sorry, but this function only works with positive\
    \ integers\")\n           (cons even (cons odd '())))]))\n", "  (let ([x (modulo\
    \ num (remainder num 10)) (quotient num 10)])\n    (cond\n      [(< x 10) '()]\
    \ [(< x 5) '()]\n      [(< x 0) (cons x '())]\n      [else (cons x (even_odd_count\
    \ (- x 10)))])))\n", "  (let ((even-count 0))\n    (let ((odd-count 0))\n    \
    \  (if (integer? num)\n          (cond\n            ((= num 0) (set! even-count\
    \ 0))\n            ((odd? (remainder num 2)) (set! odd-count 1))\n           \
    \ (else (set! even-count (add1 even-count)) (set! odd-count (add1 odd-count)))\n\
    \          )\n          (cond\n            ((= num 0) (set! even-count 0))\n \
    \           ((odd? (remainder num 2)) (set! odd-count 1))\n            (else (set!\
    \ even-count (add1 even-count)) (set! odd-count (add1 odd-count)))\n         \
    \ )\n      )\n      (cond\n        ((or (equal? even-count 0) (equal? odd-count\
    \ 0)) '())\n        ((and (= even-count 1) (= odd-count 0)) '())\n        ((or\
    \ (= even-count 0) (= odd-count 0)) '())\n        ((and (= even-count (sub1 (modulo\
    \ num 10)))\n             (= odd-count (sub1 (modulo num (quotient num 10))))\
    \ '())\n        ((or (= even-count 0) (= odd-count 0)) '())\n        ((and (=\
    \ even-count (sub1 (modulo num 10)))\n             (= odd-count (sub1 (modulo\
    \ num (quotient num 10)))) '())\n        ((or (= even-count 0) (= odd-count 0))\
    \ '())\n        ((and (= even-count 1) (= odd-count 1)) '())\n        ((or (=\
    \ even-count 0) (= odd-count 1)) '())\n        ((and (= even-count (sub1 (modulo\
    \ num 10)))\n             (= odd-count (sub1 (modulo num (quotient num 10))))\
    \ '())\n        ((or (= even-count 0) (= odd-count (sub1 (modulo num 10)))) '())\n\
    \        ((and (= even-count (sub1 (modulo num 10)))\n             (= odd-count\
    \ (sub1 (modulo num (quotient num 10)))) '())\n        ((or (= even-count 0) (=\
    \ odd-count (sub1 (modulo num 10)))) '())\n        ((and (= even-count 1) (= odd-count\
    \ (sub1 (modulo num 10)))) '())\n        ((or (= even-count 0) (= od", "  (cond\n\
    \    ((= num 0) (list 0 0))\n    ((< num 0) (list 0 0))\n    ((= (modulo num 2)\
    \ 0) (list 1 0))\n    ((= (modulo num 2) 1) (list 1 1))\n    (else (list* (even_odd_count\
    \ (quotient num 2)) (even_odd_count (- num 2))))\n  )\n)\n", "  (cond\n    [(<\
    \ num (* 2 1000000)) (even_odd_count (/ num 2))]\n    [else (even_odd_count (/\
    \ num 10))]\n   ))\n", "  (let loop ((n num) (ev 0) (ods 0))\n    (if (< n 0)\n\
    \        (list ev ods)\n        (loop (quotient n 10) \n               (+ ev (if\
    \ (even? n) 1 0)) \n               (+ ods (if (odd? n) 1 0)))))\n", "  (cond\n\
    \    [(zero? num) '()]\n    [(odd? num) (cons (- (mod num 2) 1) '())]\n    [else\
    \ (cons (- (mod num 2) 0) (even_odd_count (/ num 10)))]))\n", "  (cond\n    ((=\
    \ num 0) '())\n    ((even? (car num)) (cons (car num) (even_odd_count (cdr num))))\n\
    \    (odd? (car num)) (cons (car num) (even_odd_count (cdr num))))))\n", "  (if\
    \ (< num 0)\n      (error \"Negative numbers not allowed\" num)\n      (let ((odd\
    \ (/ num 10)))\n        (cond\n          ((= odd 0)\n           (error \"Division\
    \ by zero encountered\" num)\n           (even_odd_count (- num 1)))\n       \
    \   ((= odd 1)\n           (even? num))\n          (else\n           (even? num))))))\n",
  "  (if (= num 0)\n      (list 1 1)\n      (let ((remainder (mod num (expt 2 num)))\
    \ (even (- num remainder)) (odd (- remainder even)))\n        (list even (+ 1\
    \ odd))))))\n", "  (let loop ((n num) (ev 0) (od 0))\n    (cond\n      [(< n 0)\
    \ (list od od)]\n      [else (loop (quotient n 10) (+ ev (if (even? (remainder\
    \ n 10)) 1 0)) (remainder n 10))]\n    ))\n  )\n", "  (cond\n    ((number? num)\
    \ (even_odd_count (/ num 10)))\n    ((= 0 (mod num 10)) (cons (mod num 10) empty)))\n\
    \    (else (cons (mod num 10) empty))))\n", "  (cond\n    ((= num 0)\n      (list\
    \ 0 0))\n    ((odd? (remainder num 10))\n      (cons (+ (remainder num 10) 2)\
    \ (cons (+ 1 0) odd?)))\n    (else (cons (+ 1 0) (even?))))))\n", "  (let ([n\
    \ (modulo num (expt 10 #lang racket)))]\n        (cond\n          [(= n 0) (list\
    \ 0 1)]\n          [(= n 1) (list 1)]\n          [else (list (+ 1 (even_odd_count\
    \ (modulo n 10))) (+ 1 (even_odd_count (modulo (modulo n 10) 10))))]))) ;; (even_odd_count\
    \ 12) ==> (1 2)\n</code>\nNow you can count the number of even and odd digits\
    \ like so -\n<code>", "  (cond [(= num 0) '()]\n        [(= (mod num 2) 0) '(1\
    \ 1)]\n        [else (even_odd_count (/ num 10))]))\n", "  (cond\n    ((= num\
    \ 0) (list 0 0))\n    ((even? num) (list (length num) (length num)))\n    (else\
    \ (list (- 1 (remainder num 10)) (- 1 (remainder num (- 10 1)))))))\n", "  (cond\n\
    \    [(< num 0) (even_odd_count (-num))]\n    [else (cond\n            [(even?\
    \ num) (cons (+ 1 (length (remainder num 10)))\n                             (even_odd_count\
    \ (remainder num 10)))]\n            [(odd? num) (cons (+ 1 (length (quotient\
    \ num 10)))\n                             (even_odd_count (quotient num 10)))])]))\n",
  "  (cond\n    ((< num 0) '())\n    ((= (mod num 2) 0) '((cons 0 (even_odd_count\
    \ (/ num 2)))))\n    ((= (mod num 2) 1) '((cons 1 (even_odd_count (/ num 2)))))\n\
    \    (else '(()))))\n", "  (cond\n    [(< num 0) (list 1 1)]\n    [else (list\
    \ \n             (floor (/ num (- num 1))) (floor (/ (- num 1) 2)))]))\n", " \
    \ (cond\n    [(even? num) (cons num (even_odd_count (remainder num 2)))]\n   \
    \ [(odd? num) (cons num (even_odd_count (remainder num 1)))]\n    [else (even_odd_count\
    \ (remainder num 1))]\n  ))\n", "  (cond [(< 0 num) #f]\n        [(even? num (even_odd_count\
    \ (num / 10))) #t]\n        [else #f]))\n", "  (cond\n    ((= num 0)\n     (list\
    \ 0 (list 0)))\n    ((< num 0)\n     (list 0 (list 0)))\n    ((< num (/ num 2))\n\
    \     (even_odd_count (- num (/ num 2)))\n     (cons (- num (/ num 2)) (even_odd_count\
    \ (num (/ num 2)))))))\n", "  (define (even-odd-helper n even-count odd-count)\n\
    \    (if (negative? n)\n        (cond [(< n (abs (* 2 (car digits)))) (even-count\
    \ (+ 1 even-count))]\n              [else (odd-count (+ 1 odd-count))]))\n   \
    \ (even-odd-helper (/ n 10) 0 0))\n  (even-odd-helper num 0 0))\n", "  (let ((even\
    \ 0))\n    (let ((odd 0))\n      (if (= num 0)\n          (list even odd)\n  \
    \        (let ((num (- num 1)))\n            (cond ((and (< num 0) (even? (- num\
    \ num)))\n                    (even (+ even 1)))\n                   ((and (>\
    \ num 0) (odd? (- num num)))\n                    (odd (+ odd 1))))\n        \
    \        (else\n                    (even_odd_count num)))))))\n", "  (let loop\
    \ ((number num) (acc '()))\n    (cond\n      [(< 0 number) '()]\n      [(even?\
    \ (modulo number 10)) (loop (quotient number 10) acc)]\n      [else (loop (quotient\
    \ number 10) (ref acc))])))\n", "  (cond\n    [(= 0 (modulo num 2)) (cons 1 1)]\n\
    \    [(= 0 (modulo num 3)) (cons 2 1)]\n    [else (even_odd_count (/ num 10))]))\n",
  "  (cond\n    ((= num 0) '())\n    ((even? num) (cons 1 even_odd_count (num/10)))\n\
    \    (oddodd? num) (cons 2 even_odd_count (num/10)))\n  )\n)\n", "  (cond\n  \
    \  ((= num 0) (cons 0 0))\n    ((even? num) (cons (quotient num 2) (even_odd_count\
    \ (quotient num 2))))\n    ((odd? num) (cons (quotient num 2) (even_odd_count\
    \ (quotient num 2))))\n    (else (even_odd_count (quotient num 2)))))\n</code>\n\
    <|/ a |>\n<| c |>\nI think your approach is more efficient than mine. It is not\
    \ only about coding efficiency, it is also about correctness because of the use\
    \ of tail recursion. Anyway, thanks for your answer. :)\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is another solution which uses some standard library functions.\nThe\
    \ first function takes the integer as an argument and returns the number of even\
    \ and odd digits in it. The second function takes a number as an argument and\
    \ returns the number of digits in that number. The third function takes a number\
    \ as an argument and returns the remainder of a division operation between that\
    \ number and 10. \n<code>", "  (define (helper x count)\n    (cond ((= x 0) (cons\
    \ count (list 1)))\n          ((even? (remainder (* x 10) 10))\n           (helper\
    \ (quotient x 10) (inc count)))\n          (#t (helper (quotient x 10) count))))\n\
    \  (helper num 0))\n", "  (if (< 0 num)\n      (error \"Invalid Input: ~v\" num)\n\
    \      (let ((num-even (count num 'even? ))\n            (num-odd (- (count num\
    \ 'odd?))) ;; count returns 0 when count hits 0\n            (even-count (- (+\
    \ num-even num-odd))))\n        (list even-count num-odd))))\n", "  (cond\n  \
    \  [(< num 0) '()]\n    [(= (modulo num 2) 0) '()]\n    [else (append (even_odd_count\
    \ (quotient num 2))\n                 (list (modulo num 2))))]))\n", "  (let*\
    \ ((even (/ (quotient num 10) 2)) (odd (- (quotient num 10) 2)))\n         (evens\
    \ (cadr even)) (odds (cadr odd)))\n    (list evens odds)))\n", "  (cond [(< num\
    \ 0) (list 0 0)]\n        [(even? num) (cons num 1)]\n        [else (cons num\
    \ 2)]))\n", "  (let loop ([n num]\n             [odds 0]\n             [evens\
    \ 0])\n    (if (zero? n)\n      (list (even_count odds) even_count evens)\n  \
    \    (loop (quotient n 10) (+ odds (even_count (modulo n 10))) (+ evens (even_count\
    \ (quotient n 10)))))))\n", "  (let ((x num))\n    (if (< x 0)\n        (values\
    \ (quotient x 10) (quotient x 10))\n        (values 0 (- x 10)))))\n", "  (cond\n\
    \    [(or (< num 0) (= num 0)) '()]\n    [(= (modulo num 10) 0) '()]\n    [else\
    \ (cons (modulo num 10) \n            (even_odd_count (modulo num 10)))]))\n",
  "  (cond [(= num 0) (list 0 0)]\n        [(even? (remainder num 10)) (cons (- remainder\
    \ num 10) (remainder num 10))]\n        [else (cons (- remainder num 10) (remainder\
    \ num 10))]))\n", "  (cond\n    [(negative? num) (error \"Cannot find even and\
    \ odd number in negative number\")]\n    [(= 0 (modulo num 2)) (cons 1 (cons 2\
    \ (even_odd_count (/ num 2))))]\n    [else (cons 2 (even_odd_count (/ num 2)))]))\n",
  "  (cond\n    [(zero? num) '()]\n    [(positive? num) (cons (+ 2 (even_odd_count\
    \ (remainder num 10)))\n                        (even_odd_count (remainder num\
    \ 10)))]\n    [else (cons (- 1 (even_odd_count (remainder num 10)))\n        \
    \       (even_odd_count (remainder num 10)))]\n))\n", "  (let ([digits (string->list\
    \ (number->string num))]\n        [evens 0]\n        [odds 0])\n    (cond\n  \
    \    [(empty? digits) (list evens odds)]\n      [else (if (odd? (car digits))\n\
    \              (cons (+ evens (length digits))\n                    (cons (length\
    \ digits)\n                          (+ odds 1))))\n        (cons (+ evens 1)\
    \ (+ odds 1))]))))\n", "  (cond\n    [(< num 0) '()]\n    [(< num 10) '(1 2)]\n\
    \    [(even? num) '((even_count num) (odd_count num))]\n    [(odd? num) '((odd_count\
    \ num) (even_count num))]\n    [else '()]\n    ))\n", "  (let ((evens (list-ref\
    \ (even_digits num) 0))\n        (odds (list-ref (even_digits num) 1)))\n    (cond\
    \ ((null? evens)\n           (cond ((= (length odds) 2)\n                  (list\
    \ (+ odds 2) (+ evens 1)))\n                 ((= (length odds) 1)\n          \
    \        (list (+ odds 1) (+ evens 2))))\n             (else (list 1 1)))))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nI like your solution, however I\
    \ am required to only use racket. Would it be possible to implement this with\
    \ recursion?\n<|/ c |>\n<| c |>\nSure. I updated my answer to include the implementation\
    \ in Racket syntax.\n<|/ c |>\n<| a |>\nI'm answering my own question. Thanks\
    \ for all the help!\n<code>", "  (cond\n    [(or (= 0 (remainder num 2)) (= 0\
    \ (remainder num 5))) (list 1 1)]\n    [(= 0 (remainder num 2)) (list 1 2)]\n\
    \    [(= 0 (remainder num 5)) (list 1 1)]\n    [else (list 1 2)]\n  ))\n", " \
    \ (cond\n    ((= num 0) (list 0 0))\n    ((even? num) (list (length num) (length\
    \ num)))\n    ((odd? num) (list (length num) (- num 1)))\n    (else (even_odd_count\
    \ (/ num 10))))) ; Recursion: Divide num by 10 untill the quotient becomes non-zero\
    \ or num == 0\n</code>\n<|/ a dscore=2 |>\n<| c |>\nFor some reason this doesn't\
    \ work for negative numbers\n<|/ c |>\n<| c |>\nFor negative numbers, just replace\
    \ `(even? n)` with `(= n 0)`\n<|/ c |>\n<| c |>\nThe function `even?` doesn't\
    \ exist in the language that I'm using. Is there another way to check for even\
    \ numbers?\n<|/ c |>\n<| c |>\n, I am guessing this is for Racket.  `even?` is\
    \ available in the Racket interpreter and a number of other programming languages.\
    \ If you are using a different language try using the tags to specify that language.\n\
    <|/ c |>\n<| c |>\n, my apologies, `even?` is only available in Racket.\n<|/ c\
    \ |>\n<| a |>\nTo find out if a number is even, divide it by 2 and see if remainder\
    \ is 0, like so:\n<code>", "  (cond\n    [(< num 0) (error \"Non negative integer\
    \ is required\")]\n    [(even? num) (list 1 0)]\n    [else (list (even? (quotient\
    \ num 2)) (odd? (remainder num 2)))]))\n</code>\n<|/ a |>\n<| c |>\n\"You can't\
    \ use any library functions\" - this is incorrect, at least in Racket. There are\
    \ plenty of library functions available to the OP.\n<|/ c |>\n<| c |>\nIt depends\
    \ on where they are getting their input. In the question he says he has an input\
    \ as an integer and I made a comment in my code saying that it must be an integer.\n\
    <|/ c |>\n<| c |>\nYou said \"you can't use any library functions\", which is\
    \ not true. Sure, you can use a library function if it's a native language feature,\
    \ but it doesn't have to be. For example, you can implement your own library functions\
    \ in Lisp -- but then you're just implementing your own language without using\
    \ the language itself.\n<|/ c |>\n<| c |>\nThe example code in the question shows\
    \ that it's a `list` of length 3, not an integer.\n<|/ c |>\n<| c |>\nThe example\
    \ code in the question is using some library functions, specifically `even?` and\
    \ `odd?`.\n<|/ c |>\n<| a dscore=0 |>\nI solved this problem like this, which\
    \ I believe to be a very efficient solution:\n<code>", "  (cond\n    ((= num 0)\
    \ '())\n    ((even? (modulo num 10))\n     (list (quotient num 10) 1))\n    ((odd?\
    \ (modulo num 10))\n     (list (quotient num 10) 2))\n    (else\n     (even_odd_count\
    \ (quotient num 10))))) ; Recurse\n", "  (cond\n    ((= num 0) (list 0 0))\n \
    \   ((even? num) (cons (mod num 2) (even_odd_count (quotient num 2))))\n    (else\
    \ (cons (mod num 10) (even_odd_count (quotient num 10))))))\n", "  (cond [(= num\
    \ 0)\n         #t]\n        [(< num 0)\n         #f]\n        [(= (remainder num\
    \ 10) 0)\n         #t]\n        [else\n         (let ([even (even_odd_count (remainder\
    \ num 10)))]\n           (+ even 1))]))\n", "  (define (even-odd n)\n    (cond\n\
    \      [(= n 0) (list 0 0)]\n      [(even? (rem n 2)) (cons (+ 0 (even? (rem n\
    \ 2))) (even-odd (rem n 2)))]\n      [(odd? (rem n 2)) (cons (+ 1 (odd? (rem n\
    \ 2))) (even-odd (rem n 2)))]\n      [(even? n) (even-odd n)]\n      [(odd? n)\
    \ (even-odd n)]\n      [(= n -1) (even-odd n)]\n      [(= n 1) (even-odd n)]\n\
    \      [(= n 2) (even-odd n)]\n      [(= n 3) (even-odd n)]\n      [(= n 4) (even-odd\
    \ n)]\n      [(= n 5) (even-odd n)]\n      [(= n 6) (even-odd n)]\n      [(= n\
    \ 7) (even-odd n)]\n      [(= n 8) (even-odd n)]\n      [(= n 9) (even-odd n)]\n\
    \      [(= n 10) (even-odd n)]\n      [(= n 11) (even-odd n)]\n      [(= n 12)\
    \ (even-odd n)]\n      [(= n 13) (even-odd n)]\n      [(= n 14) (even-odd n)]\n\
    \      [(= n 15) (even-odd n)]\n      [(= n 16) (even-odd n)]\n      [(= n 17)\
    \ (even-odd n)]\n      [(= n 18) (even-odd n)]\n      [(= n 19) (even-odd n)]\n\
    \      [(= n 20) (even-odd n)]\n      [(= n 21) (even-odd n)]\n      [(= n 22)\
    \ (even-odd n)]\n      [(= n 23) (even-odd n)]\n      [(= n 24) (even-odd n)]\n\
    \      [(= n 25) (even-odd n)]\n      [(= n 26) (even-odd n)]\n      [(= n 27)\
    \ (even-odd n)]\n      [(= n 28) (even-odd n)]\n      [(= n 29) (even-odd n)]\n\
    \      [(= n 30) (even-odd n)]\n      [(= n 31) (even-odd n)]\n      [(= n 32)\
    \ (even-odd n)]\n      [(= n 33) (even-odd n)]\n      [(= ", "  (cond\n    [(null?\
    \ num) '()]\n    [(odd? num) (cons 1 (even_odd_count (quotient num 2)))]\n   \
    \ [else (cons 0 (even_odd_count (quotient num 2)))]))\n", "  (cond\n    ((= num\
    \ 0)\n     (list 0 0))\n    ((= num 1)\n     (list 0 0))\n    ((= num -1)\n  \
    \   (list 0 0))\n    (else\n     (let ((digits (string->list num)))\n       (cond\n\
    \         ((null? digits)\n          (list 0 0))\n         ((even? (car digits))\n\
    \          (cons (+ 2 (car digits)) (cdr digits)))\n         ((odd? (car digits))\n\
    \          (cons (+ 2 (car digits)) (cdr digits)))\n         ((odd? (car digits))\n\
    \          (cons (+ 2 (car digits)) (cdr digits)))\n         ((even? (car digits))\n\
    \          (cons (+ 2 (car digits)) (cdr digits)))\n         ((even? (car digits))\n\
    \          (cons (+ 2 (car digits)) (cdr digits)))\n         ((even? (car digits))\n\
    \          (cons (+ 2 (car digits)) (cdr digits)))))))) ;;#lang racket\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=scheme |>\nIn Racket you can use the built-in function\
    \ string->list to convert a string to a list of characters. Then it's very easy\
    \ to write a function that will convert your integer to a list of characters,\
    \ and then you can count the number of even and odd characters:\n<code>\n#lang\
    \ racket\n", "  (cond\n    [(equal? (modulo num 2) 0) (list (add1 num) (modulo\
    \ num 2))]\n    [(equal? (modulo num 2) 1) (list (add1 num) 1)]\n    [else (error!\
    \ #f \"Invalid integer. even_odd_count is expecting an integer\")]\n    )\n  )",
  "  (cond\n    [(< num 0) '()]\n    [(= (modulo num 10) (zero? 0)) '(1 0)]\n    [else\
    \ (cons (modulo num 10) (euclidian (quotient num 10)))]))\n", "  (cond\n    [(<\
    \ num 0)\n     (error \"num is negative\")\n     (error \"num is negative\")]\n\
    \    [(< num 100)\n     (even-odd-count-helper num 0 1)]\n    [else\n     (even-odd-count-helper\
    \ num (quotient num 10) 2)]\n  ))\n", "  (let* ((even (check-even? num))\n   \
    \      (odd (- (check-odd? num) even))\n         (result (list even odd)))\n \
    \   (cond\n      [(null? num) result]\n      [(= 0 (remainder num 2)) (cons 1\
    \ result)]\n      [else (cons (+ (* even 2) (* odd 2) (/ num 2))\n           \
    \       (even_odd_count (- num 2))))]))\n", "  (cond\n    [(negative? num) (cons\
    \ 0 '())]\n    [else (cons (length (list->string (num->string num))) '(1 1))]))\n",
  "  (cond\n    ((= num 0) '())\n    ((even? num) (cons num (even_odd_count (/ num\
    \ 2)))\n    (odd? num) (cons num (even_odd_count (* num 3)))\n    (else (even_odd_count\
    \ (- num (quotient num 2))))))\n", "  (cond [(< num 0) '()]\n        [(= num (truncate\
    \ num)) '()]\n        [(< num 1000000) (list (even_odd_count (quotient num 1000000))\n\
    \                               (append (list (even_count (quotient num 1000000)))\n\
    \                                       (list 'even)))]\n        [else (list (even_count\
    \ (truncate num))\n                    (append (list (even_odd_count (quotient\
    \ num 1000000))\n                                 (append (list (even_count (quotient\
    \ num 1000000)))\n                                           (list 'even))))]\n\
    \          ))) \n", "  (let ((odds-count (count-odds num))\n        (evens-count\
    \ (count-evens num)))\n    (list odds-count evens-count)))\n", "  (cond\n    [(zero?\
    \ num) '()]\n    [(oddp? num) (cons 1 '())]\n    [else (cons 2 (even_odd_count\
    \ (quotient num 10)))]))\n", "  (cond ((= num 0) '())\n        (#t (cons (even?\
    \ (number->string num)) (cons (odd? (number->string num)) (even_odd_count (quotient\
    \ num 10))))))))\n", "  (let ([result '()])\n    (if (= num 0)\n        (cond\
    \ [(= num 0) (if (= num 0) (list 1) (list 2))]\n              [else result]))))\n",
  "  (let-values ([(x y) (floor num 10)])\n    (cond\n      [(= x 0) '()]\n      [(even?\
    \ x) (cons (- x y) '())]\n      [(odd? x) (cons (- y x) '())])))\n</code>\n<|/\
    \ a tags=racket,scheme dscore=0 |>\n<| a dscore=0 |>\nHere's my solution with\
    \ Racket:\n<code>", "  (cond\n    [(= num 0) (list 0 0)]\n    [(odd? num) (list\
    \ ((- num 10) even?) (+ (- num 100) even?))]\n    [else (list ((- num 10) even?)\
    \ (+ (- num 100) even?) (even_odd_count (- num 10)))]))\n", "  (cond\n    ((=\
    \ num 0) '())\n    ((= num 1) (list 1))\n    ((even? (remainder num 2)) (cons\
    \ (remainder num 2) (list 2)))\n    (else (cons (remainder num (quotient num 2))\
    \ (list 3)))))\n", "  (cond\n    ((< num 0) (list 0 0))\n    ((> num 0) (map (lambda\
    \ (x) (+ 0 (mod x 10)))\n                     (filter (lambda (x) (even? x))\n\
    \                               (floor (/ num 10))))))\n</code>\n<|/ a |>\n<|\
    \ c |>\nThanks for the answer but your code is still wrong. It should return (2\
    \ 1) for the number 123 and not (1 2)\n<|/ c |>\n<| a |>\nHere is a solution using\
    \ recursion:\n<code>", "  (cond\n    ((< num 0) (error \"Invalid input: Input\
    \ must be greater or equal than 0\"))\n    (else (cond ((= (modulo num 2) 0) (cons\
    \ (+ (modulo num 10) 10) '()))\n                    (else (cons (+ (modulo num\
    \ 10) 10) '())))\n    ))\n", "  (let loop ((num num) (result ()))\n    (cond\n\
    \      [(= num 0) (return result)]\n      [else (loop (quotient num 10) \n   \
    \             (append (list num) result))])))\n", "  (if (= num 0)\n      (list\
    \ 0 0)\n      (let ((odd (/ num 10)))\n        (if (even? odd)\n            (list\
    \ 0 (add1 odd))\n            (list 1 (add1 odd))))))\n", "  (let loop ((num num)\
    \ (count 0) (eod (/ 0 0)) (od (/ 0 0)))\n    (if (= 0 num)\n      (list (reverse\
    \ odd) (reverse odd))\n      (let ((digit (modulo (remainder num 10) 10)))\n \
    \       (if (< digit 10)\n          (let ((even (= (eod (* 2 count)) 0)) (odd\
    \ 1))\n            (set! count (+ 1 count))\n            (set! eod (* 2 count))\n\
    \            (if (even)\n                (loop (quotient num 10) count (od (*\
    \ 2 count)) odd))\n            (set! od (* 2 count))\n            (list digit\
    \ odd))\n          (let ((even (= (eod (* 2 count)) 0)) (odd 1))\n           \
    \ (set! count (+ 1 count))\n            (set! eod (* 2 count))\n            (if\
    \ (even)\n                (loop (quotient num 10) count (eod 1) odd))\n      \
    \      (set! od (* 2 count))\n            (list digit odd)))))) ; end of let\n\
    \  ; end of loop\n  )\n", "  (cond\n    ((positive? num) ; Only allow positive\
    \ numbers\n     (cond\n      ((even? num) ; If the number is even\n       (list\
    \ (even? num) (odd? num)))\n      (else ; If the number is odd\n       (list 0\
    \ 1))))\n    (else ; Only allow negative numbers\n     (list 0 0))))\n</code>\n\
    <|/ a tags=racket,scheme,recursion |>\n<| a tags=racket,scheme,recursion dscore=2\
    \ |>\n<code>", "  (cond [(< 0 num) '()]\n        [(even? (car num)) (even_odd_count\
    \ (cdr num))]\n        [else (odd_count (car num)) (even_odd_count (cdr num))]\n\
    \    )\n)\n", "  (cond [(< num 0) (error \"Negative numbers are not allowed. Try\
    \ again.\")]\n        [(or (< num (/ num 2)) (< num (/ num 1)))\n         (cons\
    \ (- num (/ num 2)) (even_odd_count (/ num 2)))]\n        [else (cons (- num (/\
    \ num 2)) (even_odd_count (/ num 1)))]))\n", "  (if (zero? num)\n      (values\
    \ 0 0)\n      (let ((odd (/ num (floor (/ num 2))))\n            (even (/ num\
    \ (floor (/ num 2)))))\n        (values (+ odd even) (+ even odd))))) ;; #lang\
    \ racket\n", "  (cond\n    [(< num 0) (list -1 1)]\n    [else (even (truncate\
    \ num))]\n  ))\n", "  (cond [(= num 0) '()]\n        [(= (modulo num 10) (= 0\
    \ num)) '()]\n        [(= (modulo num 10) (= 2 num)) '((even) (odd))]\n      \
    \  [else (even_odd_count (/ num 10)) '(odd even)])\n  )\n", "  (let ([count-even\
    \ (count-even-digits (modulo-check num 0))])\n    (if (= count-even 0)\n     \
    \   (even_digit-count num) (odd_digit-count num))))\n", "  (let* ([a (/ num (floor\
    \ num 2))]\n         [b (remainder num (floor num 2))]\n         [even-count 0]\n\
    \         [odd-count 0])\n    (cond\n      [(< a 0) (cond\n                  [(<\
    \ b 0) (cond\n                            [(< a 0) (even-count even-count)\n \
    \                            [else (odd-count odd-count)])]\n                \
    \  [(< b 1) (even-count (+ even-count 1))\n                             [else\
    \ (odd-count (+ odd-count 1))])]\n                  [else (odd-count (+ odd-count\
    \ 1))])]\n      [(< b 1) (cond\n                  [(< a 0) (even-count (+ even-count\
    \ 1))\n                             [else (odd-count odd-count)])]\n         \
    \         [else (even-count (+ even-count 1))])]\n      [(< a 0) (cond\n     \
    \             [(< b 0) (even-count even-count)\n                             [else\
    \ (odd-count odd-count)])]\n                  [else (odd-count (+ odd-count 1))])]\n\
    \      [else (cond\n                  [(< b 0) (even-count (+ even-count 1))\n\
    \                             [else (odd-count odd-count)])]\n      [(< b 1) (cond\n\
    \                  [(< a 0) (even-count (+ even-count 1))\n                  \
    \           [else (odd-count (+ odd-count 1))])]\n                  [else (even-count\
    \ (+ even-count 1))])]\n      [else (odd->even odd->even\n                   (+\
    \ even-count odd-count)))]))\n", "  (let ([rem (modulo num 10)])\n    (cond\n\
    \      [(= rem 0) (list 0 1)]\n      [(= rem 2) (list 1 1)]\n      [(= rem 3)\
    \ (list 2 1)]\n      [else (list 1 2)])))\n", "  (cond\n    ((= num 0) (list 0\
    \ 0))\n    ((even? num) (list (+ 1 (even? (quotient num 2))) (+ 1 (odd? (quotient\
    \ num 2))))))\n    (else (list (+ 1 (even? (quotient num 2))) (+ 1 (odd? (quotient\
    \ num 2)))))))\n", "  (cond\n    [(< num 0) '()]\n    [else (cons (mod num (expt\
    \ 2 1)) (even_odd_count (/ num 2)))]))\n", "  ;; Use a loop to count the even\
    \ and odd digits separately.\n  (if (< num 0)\n      (list 0 0)\n      (let loop\
    \ ((count (/ num 10)) (num-rem num (/ num 10)))\n        (if (= count 0)\n   \
    \         (list 1 count)\n            (loop (+ count (if (even? num-rem) 1 (if\
    \ (odd? num-rem) -1 0))) (modulo num (/ 10 num-rem)))))) ;; <-- This is where\
    \ I stuck\n                                                                  \
    \                        ;; I have the idea of how to\n                      \
    \                                                                    ;; count\
    \ the number of even and odd\n                                               \
    \                                           ;; digits in the first step, but I\
    \ fail to implement\n                                                        \
    \                                  ;; it in the recursive step.\n</code>\n<|/\
    \ q |>\n<| a dscore=0 |>\nOne simple and easy to understand approach is to convert\
    \ the number to binary (base 2), add zeros on left side of numbers as long as\
    \ the number is odd, and add ones on left side of numbers as long as the number\
    \ is even. Below is one way of doing it (but there is certainly other ways):\n\
    <code>", "  (cond\n    [(= num 0)\n     (list 1 0)]\n    [(even? num) (list 1\
    \ (+ 2 (even_odd_count (/ num 2))))]\n    [(odd? num) (list 1 (+ 2 (even_odd_count\
    \ (/ (- num 1) 2)))) ]\n   )\n)\n", "  (cond\n    [(or (= num 0)) (list 1 1)]\n\
    \    [(> (abs (remainder num 10)) 2)\n     (cons (floor (/ num 10)) (even_odd_count\
    \ (/ num 10)))]\n    [else (cons (floor (/ num 10)) (even_odd_count (/ num 10)))]))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nI'm curious about `(/ (floor (/\
    \ x 10)) 10)` - is this some kind of rounding trick?\n<|/ c |>\n<| c |>\nyes,\
    \ it rounds a decimal number to an int\n<|/ c |>\n<| c |>\nThe second `else` clause\
    \ is wrong. It should just be `else`.\n<|/ c |>\n<| a dscore=2 tags=racket,scheme\
    \ |>\nHere's an easy way to do it in Racket using the built-in procedures:\n<code>",
  "  (let loop ((num num) (num-odd (* 2 num) (+ 1 num-odd)))\n    (if (< num 0)\n\
    \        (cons (car num-odd) (cons (car num) (loop (cdr num-odd) num)))\n    \
    \    (loop (cdr num) num)))))", "  (cond\n    ((= num 0)      0)\n    ((= num\
    \ 1)      0)\n    ((= num 2)      0)\n    ((even? num) 2)\n    ((odd? num)  1)\n\
    \    (else          (even? num) (odd? num))))\n", "  (cond [(zero? num) '()]\n\
    \        [(odd? (remainder num 10)) (cons 2 even_odd_count (remainder num 10))]\n\
    \        [else (cons 1 (even_odd_count (remainder num 10)))]))\n", "  (let ((evens\
    \ (make-array 1 2)))\n    (do\n      (set! evens (modulo (remainder num 10) (/\
    \ 10 2)))\n      (set! num (quotient num (/ 10 2)))\n    )\n    (cond\n      [(<\
    \ num 0) (set! evens evens)]\n      [(< num 0) (set! evens (list evens))]\n  \
    \    [else (set! evens (list evens (modulo (remainder num 10) (/ 10 2)))) (set!\
    \ num (quotient num (/ 10 2)))]\n    )\n    (list evens num)\n  )\n)\n</code>\n\
    <|/ a tags=numbers,scheme,racket,integer,functional-programming |>\n<| a dscore=1\
    \ |>\n<code>", "  (cond\n    [(< 0 num) '()]\n    [(= 0 (modulo num 2)) (list\
    \ 1)]\n    [else (cons 1 (even_odd_count (/ num 2)))]))\n", "  (cond\n    [(<\
    \ num 0) '()]\n    [(even? num) (cons 0 (even_odd_count (/ num 10)))]\n    [(odd?\
    \ num) (cons 1 (even_odd_count (/ num 10)))]\n    [else (even_odd_count (/ num\
    \ 10))]))\n", "  (let ((even (count-even-digits (number->string num))\n      \
    \    odd (count-odd-digits (number->string num))))\n    (list even odd)))\n",
  "  (let ((zeros '())\n        (num-length (string-length (string->list (number->string\
    \ num))))\n        (even-count (- even-count zeros)\n                   (odds-count\
    \ (- odds-count zeros))\n                   (odd-count num-length))\n        (even-digits\
    \ (string->list (number->string even-count)))\n        (odds-digits (string->list\
    \ (number->string odds-count)))\n        (odd-digits (string->list (number->string\
    \ odd-count))))\n    (if (> num-length 0)\n        (let ((odd-digits (string->list\
    \ '())))\n          (append! odds-digits zeros)\n          (append odds-digits\
    \ odd-digits))\n      (append even-digits odds-digits))))\n", "  (cond\n    [(=\
    \ 0 num) '()]\n    [(even? (car num)) (cons (car num) (even_odd_count (cdr num)))]\n\
    \    [(odd? (car num)) (cons (car num) (even_odd_count (cdr num)))]\n    [else\
    \ (even_odd_count (cdr num))]))\n", "  (cond ((< num 0) (error \"not positive\
    \ number\"))\n        ((even? num) (cons (even? num) (even_odd_count (/ num 2))))\n\
    \        (else (cons (odd? num) (even_odd_count (/ num 2))))))\n", "  (let ((result\
    \ (if (< num 0) \n                    (list 0 0)\n                    (list 1\
    \ 0))))\n    (do ((n num (- n 1)))\n        ((odd? n) (set! result (append (list\
    \ 1) result))\n         (even? n) (set! result (append (list 2) result))))\n \
    \   result))\n</code>\n<|/ a |>\n<| a tags=scheme,racket,lisp,functional-programming\
    \ |>\nHere is a solution using list comprehension:\n<code>", "  (cond\n    [(=\
    \ 0 num) '()]\n    [else (cons (/ (floor (/ num 10)) 2) (even_odd_count (* num\
    \ 10)))]))\n", "  (cond [(< num 0) (list 1 1)]\n        [(< num 10) (list (even_odd_count\
    \ (/ num 10)) (even? num))\n               (odd? num)]\n        [else (list 1\
    \ (even_odd_count (- num 10))\n                    (even? num) (odd? num)\n  \
    \                  (even_odd_count (- num 10))\n                    (even? num)\
    \ (odd? num)\n                    (even_odd_count (- num 10))\n              \
    \      (even? num) (odd? num)\n                    (even_odd_count (- num 10))\n\
    \                    (even? num) (odd? num)\n                    (even_odd_count\
    \ (- num 10)))]))\n", "  (cond\n    ((< num 0) (list 0 0))\n    ((even? num) (list\
    \ 1 0))\n    ((odd? num) (list 0 1)))\n)\n", "  (cond\n    [(< num (/ 10 num))\
    \ (even-digit-count num)]\n    [else (odd-digit-count num)]))\n", "  (let ((even\
    \ (remainder num 10)))\n    (cond\n      [(< even 0) (list 1 1)]\n      [(< even\
    \ 1) (list 1 2)]\n      [else (list 1 2)]))) ;;(even (quotient num 10))\n</code>\n\
    <|/ a dscore=0 tags=racket,scheme |>\n<| c |>\nPlease explain how this answers\
    \ the question.  Just posting code without an explanation is not helpful.\n<|/\
    \ c |>\n<| c |>\n: I have added explanations.\n<|/ c |>\n<| c |>\nThis is very\
    \ unreadable. Please, use proper indentation and whitespace to make it readable.\
    \ Also, you can make your code even more readable by replacing `(let ((even (remainder\
    \ num 10)))` with `(define even (remainder num 10))`, etc.\n<|/ c |>\n<| a |>\n\
    <code>", "  (cond\n    [(= 0 num) '()]\n    [(even? num) (list (length (even?\
    \ num)) 1)]\n    [(odd? num) (list (length (odd? num)) 2)]\n    [else (even_odd_count\
    \ (sub1 (remainder num 10)))]))\n", "  (cond\n    [(or (negative? num) zero? positive?)\n\
    \     (error \"num is not a number.\")]\n    [(zero? (remainder num 2)) #t]\n\
    \    [(even? (remainder num 2)) #t]\n    [(odd? (remainder num 2)) #f]\n    [else\
    \ (error \"num does not have an even or odd digit.\")]))\n", "  (cond\n    ((zero?\
    \ num) '() )\n    ((even? num) (cons (car num) '(even)) (cons (car num) '(odd))\
    \ ))\n    (else (even_odd_count (cdr num)))))\n", "  ;; returns number of even\
    \ and odd digits in the number\n  (let ((sum (- num (quotient num 10))))\n   \
    \ (if (= sum (- num 1))\n        0\n        (if (even? sum)\n            2\n \
    \           (+ 1 (even_odd_count sum))))))\n", "  (cond\n    ((< 0 num) '())\n\
    \    ((= 0 (remainder num 10)) (cons (remainder num 10) (even_odd_count (remainder\
    \ num 10))))\n    ((= 1 (remainder num 10)) (cons 1 (even_odd_count (remainder\
    \ num 10))))\n    ((= 2 (remainder num 10)) (cons 2 (even_odd_count (remainder\
    \ num 10))))\n    ((= 3 (remainder num 10)) (cons 3 (even_odd_count (remainder\
    \ num 10))))\n    ((= 4 (remainder num 10)) (cons 4 (even_odd_count (remainder\
    \ num 10))))\n    ((= 5 (remainder num 10)) (cons 5 (even_odd_count (remainder\
    \ num 10))))\n    ((= 6 (remainder num 10)) (cons 6 (even_odd_count (remainder\
    \ num 10))))\n    ((= 7 (remainder num 10)) (cons 7 (even_odd_count (remainder\
    \ num 10))))\n    ((= 8 (remainder num 10)) (cons 8 (even_odd_count (remainder\
    \ num 10))))\n    ((= 9 (remainder num 10)) (cons 9 (even_odd_count (remainder\
    \ num 10))))\n    ((= 10 (remainder num 10)) (cons 10 (even_odd_count (remainder\
    \ num 10))))\n    ((= 11 (remainder num 10)) (cons 11 (even_odd_count (remainder\
    \ num 10))))\n    ((= 12 (remainder num 10)) (cons 12 (even_odd_count (remainder\
    \ num 10))))\n    ((= 13 (remainder num 10)) (cons 13 (even_odd_count (remainder\
    \ num 10))))\n    ((= 14 (remainder num 10)) (cons 14 (even_odd_count (remainder\
    \ num 10))))\n    ((= 15 (remainder num 10)) (cons 15 (even_odd_count (remainder\
    \ num 10))))\n    ((= 16 (remainder num 10)) (cons 16 (even_odd_count (remainder\
    \ num 10))))\n    ((= 17 (remainder num 10)) (cons 17 (even_odd_count (remainder\
    \ num 10))))\n    ((= 18 (remainder num 10)) (cons 18 (even_odd_count (remainder\
    \ num 10))))\n    ((= 19 (remainder num 10)) (con", "  (cond\n    ((= num 0) '())\n\
    \    ((= num 1) '(1))\n    (else\n      (let ((nums (even_odd_count (num/ 10))\n\
    \            (evens (cons (mod num 10) nums))\n            (odds (cons num nums))))\n\
    \        (cons (cons evens odds) nums)))))\n", "  (cond\n    [(positive? (remainder\
    \ num 10))\n     (cons (- (remainder num 10) 10) '())]\n    [else (cons (- (remainder\
    \ num 10) 10) '())]\n    ))\n", "  (cond ((= num 0)\n         #f)\n        ((even?\
    \ num)\n         (let ((count 0))\n           (cond\n            ((= (modulo num\
    \ 10) 0)\n             (set! count (+ count 1)))\n            (else (set! count\
    \ (+ count 0))))\n         (cond\n           ((even? count) (list 1 count))\n\
    \           ((odd? count) (list 0 count))))))\n", "  (cond [(= num 0) ((even_odd_count\
    \ (- (/ num 10))))]\n        [(or (= (mod num 2) 0) (= (mod num 1) 0))\n     \
    \    (even_odd_count (/ num 10))]\n        [else (even_odd_count (/ num 10))]))\n",
  "  (define (even-digit? d)\n    (if (even? (- d 2)) (equal? d 2) (equal? d 1)))\n\
    \  (define (odd-digit? d)\n    (if (odd? (- d 2)) (equal? d 2) (equal? d 1)))\n\
    \  (list (length (filter (odd? num) (map (lambda (x) (digit-value x))\n      \
    \                          (list-ref (number->list num) 0)))\n        (length\
    \ (filter (even? num) (map (lambda (x) (digit-value x))\n                    \
    \                   (list-ref (number->list num) 0)))))\n  (if (odd? num) (even-digit?\
    \ num) (odd-digit? num)))\n", "  (cond\n    [(= num 0) (even_odd_count-helper\
    \ 0 1)]\n    [(odd? num) (even_odd_count-helper num (cond [(even? num) (add1 2)]\n\
    \                                               [(even? num) (add1 1)]))]\n  \
    \  [else (even_odd_count-helper num (+ 1))]))\n", "  (cond\n    ((= num 0) (list\
    \ 0 0))\n    ((= num 1) (list 0 1))\n    ((even? num) (even (- num 1))\n    (odd?\
    \ (- num 1))\n    (even? (odd? (- num 1))))))\n  ", "  (if (= num 0)\n      (list\
    \ 0 0)\n      (let ([odd (- num 1)\n            even (/ num 2)])\n        (list\
    \ (+ odd even) (+ even odd)))))\n", "  (eo-count-helper num 0 '() '()))\n", " \
    \ (cond [(< num 0) (error \"Need a positive number\")]\n        [(zero? num) (error\
    \ \"Need a non-zero number\")]\n        [(even? (remainder num 2)) (cons (even?\
    \ (remainder num 2)) (list 1))]\n        [else\n         (even? (remainder num\
    \ 2)) (cons (even? (remainder num 2)) (cons (odd (remainder num 2)) (list 1)))]\n\
    ))\n", "  (cond\n    ((< num 0) '()) ; handle negative numbers\n    ((< num (/\
    \ 10 0)) '() ; handle numbers with single digit\n    ((= 0 (/ num 10)) '() ; handle\
    \ numbers with single digit\n    (else (cond \n          ((= (modulo num 10) 0)\
    \ (cons (modulo num 10) '() ) ) \n          ((= (modulo num 10) 1) (cons (modulo\
    \ num 10) '(1))) \n          (else (cons (modulo num 10) '(1))) ) ) ) )\n    ))\n",
  "  (cond\n    [(number? num) (list (length num) (length num))]\n    [else (error?\
    \ (number->string num) \"even_odd_count expects a number.\")]\n  ))\n", "  (let\
    \ ((count 0)\n        (ev (make-vector 2 num)))\n    (loop\n       for num\n \
    \        when (= (mod num 10) 0)\n         for i\n         for odd\n         when\
    \ (even? (mod num 10)) collect (- count (- i 1))\n         collect num into count\n\
    \         finally (return (list count ev)))))\n", "  (let ((count 0))\n    (loop\n\
    \      (let ((r (remainder num 10)))\n        (cond\n          ((> r 0) (add1\
    \ (even? (- r 1))))\n          ((even? r) (add1 (odd? (- r 1))))\n          (else\
    \ (add1 count))\n        )\n      )\n      (return count))\n  )\n)\n\n#lang racket\n",
  "  (let loop ((num num) (ev 0) (od 0))\n    (cond ((= num 0) (list ev od))\n   \
    \       ((even? num) (loop (quotient num 10) (incf ev) (add1 od)))\n         \
    \ (else (loop (quotient num 10) (incf od) (add1 ev))))))\n", "  (cond\n    [(>\
    \ num 0) (even_odd_count (quotient num 10))]\n    [else (odd_count num)]\n   ))\n",
  "  (let loop ((x num) (even 0) odd 1))\n    (if (< x 0)\n        (reverse (list\
    \ even odd))\n        (loop (quotient x 10) (+ even (even? x)) (+ odd odd) (+\
    \ odd x))))) \n", "  (let ([num_as_string (number->string num)])\n    (cond\n\
    \      [(zero? num_as_string) #'()]\n      [(string=? \"even\" num_as_string)\
    \ #'((string->number \"even\") 1)]\n      [(string=? \"odd\" num_as_string) #'((string->number\
    \ \"odd\") 1)]\n      [(string=? \"0\" (string->number num_as_string)) #'((string->number\
    \ num_as_string) 0)]\n      [else (even_odd_count (string->number num_as_string))]))))\n",
  "  (let loop ((n num) (ev 0) (od 0))\n    (if (zero? n)\n        ev\n        (let\
    \ ((next (modulo (quotient n 10) 2)) (temp (quotient n 10)))\n          (loop\
    \ (quotient n 10) (incf ev) (incf od))\n          (if (= next 0)\n           \
    \   (cons od\n                    (cons ev od))\n              (cons od\n    \
    \                (cons ev\n                          (loop (* temp 2)\n      \
    \                           (+ ev (* temp 2))\n                              \
    \   (+ od temp)))))))))\n</code>\nA good solution can be found at How to count\
    \ the number of divisors in Racket (without using Sieve of Eratosthenes)\n<|/\
    \ a tags=racket,sieve dscore=2 |>\n<| a |>\nA solution in Racket.\n<code>", " \
    \ (cond\n    ((= num 0) (list 0 0))\n    ((even? (modulo-by-zero? num 2)) (cons\
    \ 1 (even_odd_count (quotient num 2))))\n    ((odd? (modulo-by-zero? num 2)) (cons\
    \ 2 (even_odd_count (quotient num 2))))\n    ((even? (modulo-by-zero? num 3))\
    \ (cons 1 (even_odd_count (quotient num 3))))\n    ((odd? (modulo-by-zero? num\
    \ 3)) (cons 2 (even_odd_count (quotient num 3))))\n    ((even? (modulo-by-zero?\
    \ num 4)) (cons 1 (even_odd_count (quotient num 4)))) \n    ((odd? (modulo-by-zero?\
    \ num 4)) (cons 2 (even_odd_count (quotient num 4)))) \n    ((even? (modulo-by-zero?\
    \ num 5)) (cons 1 (even_odd_count (quotient num 5)))) \n    ((odd? (modulo-by-zero?\
    \ num 5)) (cons 2 (even_odd_count (quotient num 5)))) \n    ((even? (modulo-by-zero?\
    \ num 6)) (cons 1 (even_odd_count (quotient num 6)))) \n    ((odd? (modulo-by-zero?\
    \ num 6)) (cons 2 (even_odd_count (quotient num 6)))) \n    ((even? (modulo-by-zero?\
    \ num 7)) (cons 1 (even_odd_count (quotient num 7)))) \n    ((odd? (modulo-by-zero?\
    \ num 7)) (cons 2 (even_odd_count (quotient num 7)))) \n    ((even? (modulo-by-zero?\
    \ num 8)) (cons 1 (even_odd_count (quotient num 8)))) \n    ((odd? (modulo-by-zero?\
    \ num 8)) (cons 2 (even_odd_count (quotient num 8)))) \n    ((even? (modulo-by-zero?\
    \ num 9)) (cons 1 (even_odd_count (quotient num 9)))) \n    ((odd? (modulo-by-zero?\
    \ num 9)) (cons 2 (even_odd_count (quotient num 9)))) \n    ((even? (modulo-by-zero?\
    \ num 10)) (cons 1 (even_odd_count (quotient num 10)))) \n    ((odd? (modulo-by-zero?\
    \ num 10)) (", "  (cond\n    [(= 0 (remainder num 2)) (+ 1 0)]\n    [else (+ 1\
    \ (even_odd_count (remainder num 10)))]))\n", "  (let loop ([num num]\n      \
    \       [count 0])\n    (cond\n      [(zero? num)\n       (list count 0)]\n  \
    \    [(even? num)\n       (loop (quotient num 10)\n             (+ count 1))]\n\
    \      [(odd? num)\n       (loop (quotient num 10)\n             (+ count 0))]\n\
    \      [else\n       (loop (quotient num 10)\n             (+ count 0))]))))\n",
  "  (if (= 0 num)\n      ()\n      (cond [(= (remainder num 10) 0) (cons 0 (even_odd_count\
    \ (remainder num 10)))]\n            [(= (remainder num 10) 1) (cons 1 (even_odd_count\
    \ (remainder num 10)))]\n            [else (even_odd_count (remainder num 10))])))\n",
  "  (let\n      ((even (number->list num (quotient num 10)))\n       (odd ((number->list\
    \ (- num 10) even))))\n    (list even (length odd))))\n", "  (let ((count 0)\n\
    \        (evens 0)\n        (odds 0))\n    (cond\n      [(= num 0) (list count\
    \ evens odds)]\n      [(even? (modulo num 2)) (cons count (+ evens 1)) (rest num)]\n\
    \      [(odd? (modulo num 2)) (cons count (+ odds 1)) (rest num)]\n      [else\
    \ (cons count (+ evens 1) (+ odds 1))]\n      )\n    )\n  )", "  (let\n    ([count1\
    \ 0]\n     [count2 0])\n    (if (< num 0)\n        (let ([new-count (even_odd_count\
    \ (quotient num 10))])\n          (if (even? new-count)\n              (begin\n\
    \                (set! count1 new-count)\n                (set! count2 (+ count2\
    \ new-count)))\n              (begin\n                (set! count2 (+ count1 new-count)))\n\
    \              (begin\n                (set! count1 (+ count1 new-count)))\n \
    \             (begin\n                (set! count1 (+ count1 new-count)))\n  \
    \            (begin\n                (set! count1 (+ count1 new-count))))\n  \
    \    (begin\n        (set! count1 (+ count1 num)))\n      (begin\n        (set!\
    \ count2 (+ count2 num)))\n      (begin\n        (set! count1 (+ count1 num))\n\
    \        (set! count2 (+ count2 num))\n        (set! count1 (+ count1 num))\n\
    \        (set! count2 (+ count2 num))))\n    (list (even_odd_count count1) (even_odd_count\
    \ count2))))\n", "  (cond\n    ((= num 0) '())\n    ((even? (car num)) (cons (car\
    \ num) (even_odd_count (cdr num)))) ; car num is a even digit\n    ((odd? (car\
    \ num)) (cons (car num) (even_odd_count (cdr num)))) ; car num is a odd digit\n\
    \    (else (cons (car num) (even_odd_count (cdr num)))))) ; car num is a number\n",
  "  (let loop ((count 1) (odds '(1 2 3 4 5 6 7 8 9 0)) (evens '(0 2 4 6 8 10 12 14\
    \ 16 18 20)))\n    (cond\n      [(< num 0) (printf \"%d is not an integer.\" num)\
    \ (exit)]\n      [(< 0 num) (printf \"%d is negative.\" num) (exit)]\n      [(<\
    \ count num) (printf \"Too many digits. Need more.\" num) (exit)]\n      [else\
    \ (cond\n        [(> (car odds) (car evens))\n         (printf \"%d has only odd\
    \ digits. Need more.\" num) (exit)]\n        [(< (car odds) (car evens))\n   \
    \      (printf \"%d has both even and odd digits. Need more.\" num) (exit)]\n\
    \        [else (cond\n          [(< (length num) 2)\n           (printf \"%d has\
    \ one digit. Need more.\" num) (exit)]\n          [else (loop (+ count 1) (cdr\
    \ odds) (cdr evens))]\n         )]]\n      )]\n    ))\n", "  (cond [(zero? num)\
    \ ()]\n        [(positive? num)\n         (even_odd_count\n          (quotient\
    \ num (remainder num 10)))]\n        [else\n         (even? (remainder num 10))\n\
    \         (odd? (remainder num 10))]))\n", "  (let ([count-even (count (even?\
    \ num)) count-odd (count (odd? num))])\n    (list (cond [(> count-even 0)\n  \
    \               (cons count-even even_odd_count (+ 1 count-even))\n          \
    \       (cons count-odd even_odd_count (+ 1 count-odd))])\n          count-even\n\
    \          count-odd)))\n", "  (cond\n    [(< num 0) (list 0 0)]\n    [(= 0 (remainder\
    \ num 2)) (list 1 (+ (* 2 num) (* 2 num)))]\n    [else (list 1 0)]))\n</code>\n\
    <|/ a tags=racket,scheme,recursion |>\n<| c |>\nThe question is tagged `racket`.\
    \ Are you saying that your code won't work there?\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing that out.  I added that code after I read and ran it without racket.\n\
    <|/ c |>\n<| c |>\nYou might want to change `(= 0 (remainder num 2)) (list 1 (+\
    \ (* 2 num) (* 2 num)))` to `(= (remainder num 2) 0) (list 1 (+ num num))`.\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out.  I changed it but the original\
    \ version was more readable.\n<|/ c |>\n<| c |>\n, do you know why the first if\
    \ statement is written like (= 0 \u2026)?  I can't find any documentation on this\
    \ (I'm new to scheme).\n<|/ c |>\n<| a tags=racket,scheme,recursion |>\nA simple\
    \ solution that doesn't use division:\n<code>", "  ;; Base cases\n  (if (= num\
    \ 0)\n      0\n      ;; Find even digits and odd digits\n      (let ([even-count\
    \ (even-digit-count num)])\n        (if (even-count)\n            (+ even-count\
    \ 1)\n            (+ odd-count 1)))))\n", "  (cond\n    [(positive? num) #(list\
    \ 0 (count-digits num (odd? num)))]\n    [(negative? num) #(list 1 (count-digits\
    \ num (even? num)))]))\n", "  (cond\n    [(<= num 0) (list (even_odd_count (-\
    \ num 1)))]\n    [(even? num) (list (+ num 1)(even_odd_count (/ num 2)))]\n  \
    \  [else (list (even_odd_count (- num 1))(even_odd_count (/ num 2)))]))\n", " \
    \ (cond\n    [(null? num) '()]\n    [(even? (car num)) (cons (even? (car num))\
    \ (even_odd_count (cdr num)))]\n    [(odd? (car num)) (cons (odd? (car num)) (even_odd_count\
    \ (cdr num)))]\n    [else (cons (car num) (even_odd_count (cdr num)))]\n    ))\n",
  "  (let ((zeros 0))\n    (let ((ones 0))\n      (let ((digits '()))\n        (let\
    \ loop ((num num) (digits digits) (zeros zeros) (ones ones))\n          (cond\n\
    \            ((> num 0)\n             (loop (quotient num 10) (rest digits) (+\
    \ zeros 1) (+ ones 1)))\n            ((< num 0)\n             (loop (quotient\
    \ num 10) (cons num digits) (+ zeros 0) (+ ones 1)))\n            (else\n    \
    \         (cond\n               ((or (< 0 num) (zero? num))\n                (cond\
    \ ((= zero zero) (cons (list num) digits))\n                       ((= zero one)\
    \ (cons (list num) digits))\n                       (else (cons digits nil))))\n\
    \               ((or (> 0 num) (zero? num))\n                (let ((tmp (quotient\
    \ num 10)))\n                  (loop (quotient tmp 10) (cons num digits) (+ zeros\
    \ 0) (+ ones 1))))))))))))\n", "  (cond\n    [(negative? (car num)) (error 'even_odd_count\
    \ \"negative number\")]\n    [(even? (car num)) (cons (car num) (even_odd_count\
    \ (cdr num)))]\n    [else (cons (car num) (even_odd_count (cdr num)))]))\n", " \
    \ (let ((odds 0))\n    (let ((evens 0))\n      (cond\n        ((< num 0) (list\
    \ evens odds))\n        (else\n          (cond\n            ((even? (remainder\
    \ num 10)) (evens + 1))\n            (else odds)\n            )\n          )\n\
    \        )\n      )\n    )\n  )\n</code>\nA recursive version that can deal with\
    \ negative numbers is as follows:\n<code>", "  (let ((digits (remainder (modulo\
    \ num 10) 10)))\n    (cond\n      [(zero? digits) (list 0 1)]\n      [else (cons\
    \ (+ 1 even_odd_count digits)\n                 (cond\n                  [(= 0\
    \ (modulo num 10)) (cons 1 2)]\n                  [else (cons 1 2)]))])))\n",
  "  (cond\n    [(number? num) 0]\n    [(< num 0) nil]\n    [else (expt 2 (- num)))]))\n",
  "  (cond\n    [(> num 0) (list 0 0)]\n    [(= num 0) (list 0 0)]\n    [else (cons\
    \ (mod num (expt 2 1))\n                (even_odd_count (mod num 2)))]))\n", " \
    \ (cond\n    [(zero? num) '()]\n    [(oddp? num) (list (+ 1 even? (number->list\
    \ num)))]\n    [(evenp? num) (list (+ 1 odd? (number->list num)))]))\n", "  (let\
    \ loop ((num num) (ev 0) (od 0))\n    (if (positive? num)\n      (let ((remainder\
    \ (mod num 10)))\n        (if (even? remainder)\n          (loop (remainder (+\
    \ ev 1))\n                (+ od 1))\n          (loop (quotient num 10)\n     \
    \           od\n                (+ od 1))))\n      (list ev od))))\n</code>\n\
    <|/ a tags=racket,scheme |>\n<| a |>\nA simple and elegant solution:\n<code>\n\
    #lang racket\n", "  (let ((count 0))\n    (for ([i num])\n      (cond\n      \
    \  ((= (rem i 2) 0) (set! count (+ count 1)))\n        (else (set! count (+ count\
    \ 0)))))))\n", "  (let loop ((x num (+ x 1))\n             (odds '(0) (evens '(1)))\n\
    \             (result '()))\n    (cond ((> x 0) (loop (- x 1) (cons (- x 1) evens)\
    \ (cons (- x 1) odds)))\n          ((= x 0) (cons 1 result))\n          (else\
    \ (cons (mod x 10) result)))\n    (reverse result)))\n", "  (cond\n    ((= num\
    \ 0) (cons 0 0))\n    ((= num 1) (cons 1 0))\n    ((< num 1) (error \"even_odd_count:\
    \ Cannot divide by zero\"))\n    (else\n      (let ((remainder (/ num (floor num))))\n\
    \        (cond\n          ((= remainder 0) (cons 0 0))\n          ((= remainder\
    \ 1) (cons 1 0))\n          ((< remainder 1) (even_odd_count remainder))\n   \
    \       (else\n            (even_odd_count remainder)))))))\n", "  (cond\n   \
    \ [(< 0 num)\n     (let ((even-count (modulo (modulo (* num 10) 10) (* 10 10))\
    \ 0))\n       (let ((odd-count (modulo (modulo (* num 10) 10) (* 10 10)) 1))\n\
    \         (list even-count odd-count))]\n    [(even? (remainder num 2)) (let ((even-count\
    \ (quotient num 2)) (odd-count 0))]\n    [(even? (remainder num 4)) (let ((even-count\
    \ 0) (odd-count (quotient num 4)))]\n    [else (let ((even-count (quotient num\
    \ 2)) (odd-count (quotient num 4)))])))\n", "  (let loop ((x num) (evens 0) (odds\
    \ 0))\n    (cond\n      [(= x 0) (list evens odds)]\n      [else (loop (sub1 x)\
    \ \n                (if (even? (remainder x 2)) \n                    (add1 (evens))\n\
    \                    (add1 (odds)))\n                (if (odd? (remainder x 2))\
    \ \n                    (add1 (odds))\n                    (add1 (evens)))])\n\
    \  )\n)\n", "  (cond\n    ((= num 0) (list 0 0))\n    ((even? num) (list 1 0))\n\
    \    (else (even? num) (list 0 (odd? num)))))\n", "  (cond\n    [(< 0 num) (error\
    \ \"Negative numbers not allowed\")]\n    [else (even-odd num (+ 1 2))]))\n",
  "  (cond\n    [(= num 0) (list 0 0)]\n    [(< num 0) (list 0 0)]\n    [(even? (modulo\
    \ num 2)) (cons (* 2 (modulo num 2)) even_odd_count (/ num 2))]\n    [else (list\
    \ 1 (+ 1 even_odd_count (/ num 2)))]))\n", "  (cond\n    [(number? num) (list\
    \ num 1)]\n    [else (even_odd_count (remainder num 10))]\n  )\n)\n", "  (cond\n\
    \    [(= 0 (remainder num 10)) (cons 1 (cons 0 (even_odd_count (quotient num 10))))]\n\
    \    [else (cons 1 (cons 2 (even_odd_count (quotient num 10))))]))\n", "  (cond\n\
    \    [(< num (/ num 2)) (even-digits num)]\n    [else (odd-digits num)]))\n",
  "  (cond\n    [(< num 0 (+ 1 num)) (list 1 1)]\n    [(= num 0) (list 1 1)]\n   \
    \ [else (cond (= (modulo num 2) 0 (+ 1 num))\n                [(< num (/ num 2))\
    \ (list 1 1)]\n                [else (cond (= (modulo num 2) 0 (+ 1 num))\n  \
    \                          [(< num (/ num 2)) (list 1 (+ 1 num))]\n          \
    \                  [else (cond (= (modulo num 2) 1 (+ 1 num))\n              \
    \                          [(< num (/ num 2)) (list 1 (+ 1 num))]\n          \
    \                              [(< num (/ num 2)) (list 1 2)]\n              \
    \                          [else (list 1 (+ 1 num))]))]))]))\n", "  (let loop\
    \ ([num (modulo num 10 10)])\n    (if (< num 0)\n      (list 0 0)\n      (loop\
    \ (quotient num 10 10)))))\n", "  (cond\n    [(zero? num) '()]\n    [(positive?\
    \ (remainder num 2)) '(1 1)]\n    [else (even_odd_count (remainder num 2))]))\n",
  "  (let ((even-cnt 0)\n        (odd-cnt 0))\n    (cond\n      [(< num 0) (even-cnt\
    \ (- num 0))]\n      [(= num 0) (odd-cnt (- num 0))]\n      [else (cond\n    \
    \          [(= (remainder num 10) 0) (set! odd-cnt (+ odd-cnt 1))]\n         \
    \     [(= (remainder num 10) 1) (set! even-cnt (+ even-cnt 1))]\n            \
    \  [else (cond [(even?) (set! even-cnt (+ even-cnt 1))]\n                    \
    \  [else (cond [(odd?) (set! odd-cnt (+ odd-cnt 1))]\n                       \
    \       [else (error 'even_odd_count \"unrecognized input\" num)]\n          \
    \                ))])]\n      [else (error 'even_odd_count \"unrecognized input\"\
    \ num)]\n      [else  (even-cnt (+ even-cnt 1))]\n      [else  (odd-cnt (+ odd-cnt\
    \ 1))]\n    )\n    (list (- even-cnt odd-cnt) (- odd-cnt even-cnt))))\n", "  (cond\n\
    \    [(= num 0) '()]\n    [(even? num) (list 1 2)]\n    [(odd? num) (list 1 1)]\n\
    \    [else (even_odd_count (quotient num 10))]))\n", "  (cond ((= num 0) (list\
    \ 0 0))\n        ((even? num) (cons (+ (modulo? num 2) 1) (cons 1 0)))\n     \
    \   (else (cons (+ (modulo? num 2) 1) (cons 1 0)))))\n", "  (cond\n    [(zero?\
    \ num) '()]\n    [(zero? (remainder num 10)) (list 1)]\n    [else (add1 (even_odd_count\
    \ (/ num 10)))]\n   ))\n", "  (cond\n    ((< num 0) (cons 0 0))\n    ((< num 20)\
    \ (cons 0 0))\n    ((even? (remainder num 2)) (cons (quotient num 2) (+ 1 even?)))\n\
    \    ((odd? (remainder num 2)) (cons (quotient num 2) (+ 1 odd?))))))\n", "  (let\
    \ loop ((n-count 0))\n    (if (< n 1)\n        (cons 0 (cons 1 (loop (sub1 n))))\n\
    \        (loop (sub1 n)))))\n", "  (cond [(< num 0) ((even_odd_count (- (expt\
    \ num 2)) 1) (even_odd_count num))]\n        [else (even? (quotient num 2)) (odd?\
    \ (quotient num 2))]))\n", "  (cond\n    [(and (number? num)\n          (positive?\
    \ (number->string num))) \n     (even_odd_count (sub1 (quotient num 10)))]\n \
    \   [else \n     (even_odd_count (quotient num 10))]))\n", "  (cond\n    ((= num\
    \ 0)\n     (list 1 1))\n    ((even? (mod num 2))\n     (+ (even_odd_count (/ num\
    \ 2)) (list (length num))))\n    (else\n     (+ (even_odd_count (/ num 2)) (list\
    \ (length num)))))\n", "  (letrec ([helper (lambda (n count)\n               \
    \     (cond\n                      [(zero? n) \n                       (if (zero?\
    \ (cdr count)) 0 (+ 1 (car count)))]\n                      [(not (zero? n)) \n\
    \                       (helper (quotient n 10) (cdr count))]])\n            \n\
    \               [even-counts [(quotient num 10)]]\n               [odd-counts\
    \ []]\n               [even-counts [((quotient num 10)) (quotient (quotient num\
    \ 10) 10) 0]]\n               [odd-counts [((quotient num 10)) (quotient (quotient\
    \ num 10) 10) 1]]\n               [even-counts [((quotient num 10)) (quotient\
    \ (quotient num 10) 10) 0]\n                             ((quotient (quotient\
    \ num 10) 10) 1)]]])\n    \n    (helper (quotient num 10) odd-counts)\n    (helper\
    \ (quotient num 10) even-counts)\n    (even-counts '())\n    (odd-counts '())\n\
    ))\n", "  (let ((even (/ (modulo num 10) (* 2 10 num))\n           (odd (/ (modulo\
    \ num 10) 2)))\n        (len (- 1 (expt even 2)))\n        (len (- 1 (expt odd\
    \ 2))))\n    (list len\n          even\n          odd)))\n</code>\n<|/ a tags=racket,scheme,numbers,integer\
    \ dscore=0 |>\n<| a |>\nA different solution that counts the digits in reverse.\n\
    <code>", "  (cond [(zero? num) '()]\n        [(even? num) (cons num 1)]\n    \
    \    [else (cons num 2)]))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nThanks\
    \ Christoph! Yes that was the approach I chose.\n<|/ c |>\n<| a dscore=0 |>\n\
    The other answers have a couple issues worth mentioning:", "  (cond\n    ((> num\
    \ 0)\n     (let* ((evens (quotient num 2)\n               (odds (remainder num\
    \ 2)))\n              (count\n               (if (evens? evens)\n            \
    \       (+ 1 evens)\n                   (+ 1 odds))))\n       (cons count count)))\n\
    \    ((< num 0)\n     (cons 0 (even_odd_count (- num 1)))))\n", "  (let loop ((odd\
    \ (exact->inexact num)) (even (exact->inexact num)))\n    (cond\n      [(< odd\
    \ even) (loop (+ odd 2) even)]\n      [else (loop (+ even 2) odd)]\n      )))\n",
  "  (cond\n    ((= num 0) (list 0 0))\n    ((even? (modulo num 10)))\n    ((odd?\
    \ (modulo num 10)))\n    (else (even_odd_count (quotient num 10)))))\n", "  (cond\n\
    \    [(= num 0)      (list 0 0)]\n    [(even? num)    (list (length num) (even?\
    \ num))]\n    [(odd? num)     (list (- length num) (odd? num))]\n    [else   \
    \      (list 0 0)]))\n", "  (let loop ((num num) (odds 0) (evens 0))\n    (cond\n\
    \      [(= num 0) (list (list evens odds))]\n      [(even? num) (loop (sub1 num)\
    \ (+ evens 1) evens)]\n      [else (loop (sub1 num) evens (+ odds 1))]))))\n",
  "  (cond\n    ((= num -1)  (error (in-range num 0 2)))\n    ((odd? num)  (cons (odd\
    \ (num)) (cons (even (num)) (even_odd_count (num - 1)))))\n    ((even? num) (cons\
    \ (even (num)) (even_odd_count (num - 1))))\n    (else (even_odd_count (num -\
    \ 1)))))\n", "  (cond\n    ((= num 0) '())\n    ((even? num) (cons (car num) (even_odd_count\
    \ (rest num))))\n    ((odd? num) (cons (car num) (even_odd_count (rest num))))\n\
    \    (else (even_odd_count (num-negate num))))) ;; #lang racket\n", "  (cond\n\
    \    [(number? num) (list (even_count_digit num) (odd_count_digit num))]\n   \
    \ [else (error \"Not a number\")]\n  )\n)\n", "  (cond\n    ((= num 0) '())\n\
    \    ((oddr? num) (list 1 (+ 1 num)))\n    (else (list 1 (+ 1 num) (even_odd_count\
    \ (div num 2))))))\n", "  (cond [(or (< num 0)\n             (= num 0))\n    \
    \     '()]\n        [(even? (modulo num 10))\n         (cons (modulo (modulo num\
    \ 10) 10) '())]\n        [(odd? (modulo num 10))\n         (cons (modulo (modulo\
    \ num 10) 10) '(1))]))\n", "  (cond\n    [(zero? num) '()]\n    [(even? num) (cons\
    \ (- num 2) (even_odd_count (/ num 2)))]\n    [(odd? num) (cons (- num 1) (even_odd_count\
    \ (/ num 1)))]\n    [else (error 'even_odd_count \"num is not a number.\")]))\n",
  "  (let loop ((num num)\n             (even_count 0)\n             (odd_count 0))\n\
    \    (cond\n      [(< num 0 (modulo num 10)\n             (modulo num 20) ; special\
    \ case for tens\n             (modulo num 30)) ; special case for hundreds\n \
    \      (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 2)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 8)\n \
    \      (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 10)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 16)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 20)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 24)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 28)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 30)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 32)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 36)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 40)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 42)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 46)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 48)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 50)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(< num 0 52)\n\
    \       (even_count (+ 1 (even_count (modulo num 10))))]\n      [(< num 0 54)\n\
    \       (odd_count (+ 1 (odd_count (modulo num 10))))]\n      [(", "  (let ((cnt\
    \ 0)\n        ((evens 0))\n        ((odds 0))\n        (count 0))\n    (check-expect\
    \ (even? num) (car odds))\n    (check-expect (odd? num) (car evens))\n    (if\
    \ (> num 0)\n        (begin (set! count 1)\n               (set! odds (cdr odds))\n\
    \               (set! evens (+ evens 1)))\n        (begin (set! odds 1)\n    \
    \           (set! evens (- evens 1))\n               (set! count 0))))\n    ((<\
    \ 0 num)\n     (set! count (+ count 1))\n     (begin\n       (set! count (+ count\
    \ 1))\n       (set! odds (+ odds 1))\n       (set! evens (- evens 1))\n      \
    \ (set! count 0)))\n    ((> 0 num)\n     (begin (set! count (+ count 1))\n   \
    \         (set! odds (+ odds 1))\n            (set! evens (- evens 1))\n     \
    \       (set! count 0))))\n    ((> num 0)\n     (begin (set! count (+ count 1))\n\
    \            (set! odds (+ odds 1))\n            (set! evens (- evens 1))\n  \
    \          (set! count 0))))\n    ((<= 0 num)\n     (begin\n       (set! count\
    \ (+ count 1))\n       (set! odds (+ odds 1))\n       (set! evens (- evens 1))\n\
    \       (set! count 0))))\n    ((= 0 num)\n     (begin\n       (set! count (+\
    \ count 1))\n       (set! odds (+ odds 1))\n       (set! evens (- evens 1))\n\
    \       (set! count 0))))\n    ((> 0 num)\n     (begin (set! count (+ count 1))\n\
    \            (set! odds (+ odds 1))\n            (set! evens (- evens 1))\n  \
    \          (set! count 0))))\n    ((<= 0 num)\n     (begin\n       (set! count\
    \ (+ count 1))\n       (set! odds (+ odds 1))\n       (set! evens (- evens 1))\n\
    \       (set! count 0))))\n    ((< 0 num)\n     (begin (set! count (+ count 1))\n\
    \            (set! odds (+ odds 1))\n            (set! evens (- evens 1))\n  \
    \          (set! count 0))))\n    ((= 0 num)\n     (begin (set! count (+ count\
    \ 1))\n            (set! odds (+ odds 1))\n            (set! evens (- evens 1))\n\
    \            (set! count 0))))\n", "  (cond\n    [(< num 0) (list -1 -1 -1)]\n\
    \    [(= num 0) (list -1 -1 -1)]\n    [else (cond [(= (modulo (expt num 2) 2)\
    \ 0) (cons 0 (even_odd_count (/ num 2))) (cons 1 (even_odd_count (- num 1)))])]))\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nIf anyone is looking for a recursive solution,\
    \ here is one in Scheme, based off of Alexander's post. The only difference is\
    \ I added a base case. \n<code>"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
