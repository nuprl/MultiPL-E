name: HumanEval_91_is_bored
language: rkt
prompt: "#lang racket\n\n;; You'll be given a string of words, and your task is to\
  \ count the number\n;; of boredoms. A boredom is a sentence that starts with the\
  \ word \"I\".\n;; Sentences are delimited by '.', '?' or '!'.\n;; For example:\n\
  ;; >>> is_bored(\"Hello world\")\n;; 0\n;; >>> is_bored(\"The sky is blue. The sun\
  \ is shining. I love this weather\")\n;; 1\n(define (is_bored S)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n\
  \    (check-equal? (candidate \"Hello world\") 0)\n    (check-equal? (candidate\
  \ \"Is the sky blue?\") 0)\n    (check-equal? (candidate \"I love It !\") 1)\n \
  \   (check-equal? (candidate \"bIt\") 0)\n    (check-equal? (candidate \"I feel\
  \ good today. I will be productive. will kill It\") 2)\n    (check-equal? (candidate\
  \ \"You and I are going for a walk\") 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    ((null? S) 0)\n    ((equal? (car S) \"I\") 1)\n    (else\
    \ (+ 1 (is_bored (cdr S))))))\n", "  (= (index 'I S)\n     (index '. S)))\n",
  "  ;; Return the number of times \"I\" occurs in a string, ignoring periods.\n \
    \ (let ((i 0))\n    ;; Scan the string until we get to 'I', and keep track of\
    \ the position\n    ;; of the 'I' in the string. We'll use this later when we\
    \ scan the\n    ;; string for '!' and '?'.\n    (loop for c across S until (char=?\
    \ c #\\I) (incf i) do\n      (cond ((char=? c #\\.) #f)\n            ((char=?\
    \ c #\\?) #f)\n            ((char=? c #\\!) #t)\n            (else #f))))\n  ;;\
    \ If we reach the end of the string, then return 0.\n  (= i (string-length S)))\n",
  "  ((not (null? S))\n  ((char=? (first S) ?\\.)\n  ((char=? (first S) ?!)\n  (char=?\
    \ (first S) ??)\n  (char=? (first S) ?I))))))\n", "  (count_if\n   (lambda (s)\
    \ (or (eq? (first s) 'I') (eq? (first s) '!') (eq? (first s) '.')))\n   (split-string\
    \ (last S) \".\")))\n</code>\n<|/ a tags=scheme,racket,string |>\n<| c |>\nHey\
    \ Joshua! I appreciate your answer. I would love some help figuring out why this\
    \ solution does not work. Why doesn't it find \"!\" as a boredom? How does the\
    \ boredom function work? What does split-string do? And why is it that the function\
    \ returns false for \"!\" and true for \"!\"? Thanks so much for answering!\n\
    <|/ c |>\n<| c |>\nThe function `split-string` splits a string into a list of\
    \ strings. For example, `(split-string \"hello.world\" \".\")` returns `'(\"hello\"\
    \ \"world\")`.\n\nThe `split-function` splits a string into a list of strings,\
    \ using a given delimiter. This function is the equivalent of [`split` in Python](https://docs.python.org/3/library/stdtypes.html#str.split).\n\
    \n`count_if` filters a list. `count_if` calls `f` on each element of the list\
    \ and returns a list of the results of `f`. That is, if the result of `f` equals\
    \ `#f`, then the element is removed.\n<|/ c |>\n<| c |>\nWhat happens if we try\
    \ to use \"!\" instead of \"I\" or \"!\" or \"!\"? I am having a hard time figuring\
    \ this out. I am thinking of using this function for a little project, and it\
    \ seems like this function works, except when I try to use \"!\" instead of \"\
    I\". I think my code should be fine to handle \"!\" correctly, since it is a boredom.\n\
    <|/ c |>\n<| c |>\nI see! Thank you for all the help!\n<|/ c |>\n<| a tags=scheme,racket,string\
    \ |>\nI didn't test the code but I think the problem is on the count_if function.\
    \ The problem is that you're not using the correct predicate function. As stated\
    \ in the docs:\n\nThe predicate is expected to be a function that takes exactly\
    \ one\n  argument, and is expected to return a boolean. The predicate must be\n\
    \  commutative and associative with respect to the base function. The predicate\n\
    \  should return #t if the base function yields a #f for any input.\n  Otherwise,\
    \ the predicate should return #f if the base function yields\n  a #t for any input.\n\
    \nSo your code should look like this:\n<code>", "  (let loop ((i 0) (S S) (seen\
    \ '(()))\n            (bored-count 0))\n    (if (< i 100)\n        (if (equal?\
    \ (char-code (car S)) 13) ; line feed\n            (loop (+ i 1) (cdr S) (cons\
    \ (car S) seen)\n                   (+ bored-count 1)))\n        (loop (+ i 1)\
    \ (cdr S) seen (+ bored-count 1)))))\n", "  (let loop ((S (make-string S :initial-element\
    \ #\\space))\n             (L (make-list 3 :initial-element #\\space)))\n    (cond\
    \ [(string=? (first S) #\\space) (length (rest S))\n           (begin (loop (rest\
    \ S) (first L)))]\n          [(string=? (first S) '!') (length (rest S))\n   \
    \        (begin (loop (rest S) (first L)))]\n          [(string=? (first S) '?')\
    \ (length (rest S))\n           (begin (loop (rest S) (first L)))]\n         \
    \ [(string=? (first S) '.') (length (rest S))\n           (begin (loop (rest S)\
    \ (first L)))]\n          [(string=? (first S) #\\newline) (length (rest S))\n\
    \           (begin (loop (rest S) (first L)))]\n          [(string=? (first S)\
    \ #\\tab) (length (rest S))\n           (begin (loop (rest S) (first L)))]\n \
    \         [(string=? (first S) #\\tab) (length (rest S))\n           (begin (loop\
    \ (rest S) (first L)))]\n          [else (begin (loop (rest S) (first L)))])))\n",
  "  (and (char=? (first S) 'I)\n       (char=? (rest S) '!') ;; The first two characters\
    \ must be I, and then the rest must be !\n       (char=? (rest S) '.') ;; Sentences\
    \ must end with '.'\n       (char=? (rest S) '?') ;; Sentences must end with '?'\n\
    \       (char=? (rest S) '!') ;; Sentences must end with '!'\n       (char=? (rest\
    \ S) '?') ;; Sentences must end with '?'\n       (char=? (rest S) '!') ;; Sentences\
    \ must end with '!'\n       (char=? (rest S) '?') ;; Sentences must end with '?'\n\
    \       (char=? (rest S) '!') ;; Sentences must end with '!'\n       (char=? (rest\
    \ S) '?') ;; Sentences must end with '?'\n       (char=? (rest S) '!') ;; Sentences\
    \ must end with '!'))) ;; Sentences must end with '.' or '!' or '?'\n", "  (string-match\
    \ \"^I[^.?!]*[.?!]\" S))\n", "  (cond ((empty? S) 0)\n        ((string-prefix?\
    \ \"I\" (car S))\n         (+ (is-bored (cdr S)) 1))\n        ((string-prefix?\
    \ \"!\" (car S))\n         (+ (is-bored (cdr S)) 1))\n        ((string-prefix?\
    \ \".\" (car S))\n         (+ (is-bored (cdr S)) 1))\n        ((string-prefix?\
    \ \"?\" (car S))\n         (+ (is-bored (cdr S)) 1))\n        (else 0)))\n", " \
    \ (if (starts-with? S \"I\")\n      (+ 1 (length (rest S)))))\n", "  (cond\n \
    \   ((null? S) #f)\n    ((not (is-word-start (car S))) #f)\n    (else (+ 1 (is_bored\
    \ (cdr S))))))\n", "  (cond [(string-match \"I\" S) 0]\n        [else 1]))\n",
  "  (bol S (lambda (V) (or (string=? V \"\") \"I\")) \".?!\"))\n", "  (define (helper\
    \ S)\n    (cond [(char=? (first S) \"I\") (helper (rest S))]\n          [(char=?\
    \ (first S) \".\")  (+ 1 (helper (rest S)))]\n          [(char=? (first S) \"\
    ?\") (+ 1 (helper (rest S)))]\n          [(char=? (first S) \"!\")  (+ 1 (helper\
    \ (rest S)))]\n          [else 0]))\n  (helper S))\n", "  (define boredom-p (string->list\
    \ (string->symbol \"boredom\")))\n  ; Split the sentence into two lists:\n  (define\
    \ words (split-string (string S) \" \"))\n  (define sentence-s (split-string (string-append\
    \ \"I\" words) \".?!\"))\n  ; Find the first element that is a boredom:\n  (define\
    \ first (car (filter (lambda (ss) (equal? (first ss) boredom-p)) sentence-s)))\n\
    \  (count-if eq? first boredom-p)\n)\n", "  ;; Convert to list of words, and remove\
    \ 'I' from list\n  (define W (remove-if #(and (equal? % \"I\") (not (equal? %\
    \ \"I\"))) (string-split S)))\n  ;; Count number of boredom sentences\n  (let\
    \ loop ((W (remove-if #(and (equal? % \"I\") (not (equal? % \"I\"))) W))\n   \
    \          (n 0))\n    (if (null? W)\n        n\n        (loop (remove-if #(and\
    \ (equal? % \"I\") (equal? % \"I\")) W) (add1 n)))))\n", "  (define bored-word\
    \ (substring S 0 1))\n  (define (loop (sub-str S start end)\n             bored-count\
    \ found)\n    (if (< start end)\n        (if (equal? (substr sub-str start 1)\
    \ bored-word)\n            (loop (substr sub-str 2 end)\n                  bored-count\
    \ (+ 1 found)))\n        (begin found)))\n  (loop '. 0 false))\n", "  (match S\n\
    \    ['.?!]\n    [(#\\i . #\\j (#\\l . #\\v (#\\w . #\\p)) #\\s (#\\c . #\\d)\
    \ #\\n) 0]))\n", "  (match-end (is-start S) S))\n", "  (define (is-bored S index)\n\
    \    (cond\n      [(string=? S \"I\" (+ index 1))\n       true]\n      [else\n\
    \       (is-bored (substring S index) (+ index 1))]))\n  (is-bored S 0))\n", " \
    \ (cond [(equal? S (substring S 0 (string-length S)))\n         0]\n        [(equal?\
    \ (substring S 0 (string-length S)) \"I\")\n         1]\n        [else (+ 0 (is_bored\
    \ (substring S (+ 0 (string-length S))))))]))\n", "  (= (length S)\n     (count\n\
    \      (lambda (w)\n        (= (position w \"I\")\n          0)\n      )\n   \
    \   S\n      )\n     )\n  )\n", "  (= (length (rest S)) 0)\n  (let\n      ((boredoms\
    \ '()))\n    (cond\n        ((string=? (car S) \"I\") (push S boredoms))\n   \
    \     ((string=? (car S) \"?\") (push S boredoms))\n        ((string=? (car S)\
    \ \"!\") (push S boredoms))\n        (else (push S boredoms))))\n  (length (filter\
    \ (lambda (x)\n                     (string=? (car x) \"I\"))\n              \
    \    boredoms))\n  )", "  (cond\n    ((empty? S) #f)\n    ((equal? (first S) \"\
    I\") 1)\n    (else\n     (+ (is_bored (rest S)) (is_bored (first (rest S)))))\n\
    \    ))\n", "  (local ((define (helper w bored)\n             (cond\n        \
    \      [(string=? (first w) \"I\") (+ 1 (helper (rest w) bored))]\n          \
    \    [(string=? (first w) \"?\") (+ 1 (helper (rest w) bored))]\n            \
    \  [(string=? (first w) \"!\") (+ 1 (helper (rest w) bored))]\n              [(string=?\
    \ (first w) \".\") (+ 1 (helper (rest w) bored))]\n              [(string=? (first\
    \ w) \"!\") bored]))))\n    bored\n    (helper S 0)))\n", "  (match S\n    ['\"\
    \" (0) ; empty string is zero\n    [\".\"(0) ; '.' is zero\n    [\"?\"(0) ; '?'\
    \ is zero\n    [\"!\"(0); '!' is zero\n    [\"I\"(1) ; 'I' occurs once\n    [\"\
    I \"(1) ; 'I' occurs once\n    [\"I.\"(1) ; 'I' occurs once\n    [\"I .\"(1) ;\
    \ 'I' occurs once\n    [\"? I\"(1) ; 'I' occurs once\n    [\"? I \"(1) ; 'I' occurs\
    \ once\n    [\"? I.\"(1) ; 'I' occurs once\n    [\"? I .\"(1) ; 'I' occurs once\n\
    \    [\"! I\"(1) ; 'I' occurs once\n    [\"! I \"(1) ; 'I' occurs once\n    [\"\
    ! I.\"(1) ; 'I' occurs once\n    [\"! I .\"(1) ; 'I' occurs once\n    [\"!? I\"\
    (1) ; 'I' occurs once\n    [\"!? I \"(1) ; 'I' occurs once\n    [\"!? I.\"(1)\
    \ ; 'I' occurs once\n    [\"!? I .\"(1) ; 'I' occurs once\n    [\"!? I?\"(1) ;\
    \ 'I' occurs once\n    [\"!? I? \" (1) ; 'I' occurs once\n    [\"!? I? \"(1) ;\
    \ 'I' occurs once\n    [\"!? I? \"(1) ; 'I' occurs once\n    [\"!? I? .\"(1) ;\
    \ 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!? I? .\"(1)\
    \ ; 'I' occurs once\n    [\"!? I? .\"(1) ; 'I' occurs once\n    [\"!", "  (if\
    \ (string-match \"^I\" S)\n      (length S)\n      0))\n", "  (let* ((words (map\
    \ (lambda (w) (char->int (w))) (split S #\\. #\\? #\\!)))\n         (first words)\n\
    \         (rest words))\n    (and (= first #\\I)\n         (or (> first #\\!)\n\
    \             (= first #\\.)))))\n", "  (let loop ((bored-counts #())\n      \
    \       (S (string->list S)))\n    (cond\n      [(empty? S) 0]\n      [(string=?\
    \ \"I\" (car S))\n       (loop (cons (car S) bored-counts) (cdr S))\n       bored-counts]\n\
    \      [else (loop (cons (car S) bored-counts)\n                 (cdr S))]))))\n",
  "  (and (>= (first S) \"I\") (< (length (rest S)) 2)))\n)\n", "  (cond [(or (eq?\
    \ (first S) \"I\") (eq? (first S) \".\") (eq? (first S) \"!\")) (add1 (length\
    \ (filter (lambda (x) (char=? (first x) \"I\")) (rest S)))) ]\n        [else 0]\n\
    \      )\n  )\n", "  (or (string-match \"^I.*\" S)\n      (string-match \"^I.*?\\\
    .\" S)\n      (string-match \"^I.*?\\?\" S)\n      (string-match \"^I.*?!\" S)))\n",
  "  (cond ((null? S) #f)\n        ((eq? (car S) \"I\") (+ 1 (is_bored (cdr S))))\n\
    \        (else (is_bored (cdr S)))))\n", "  (cond\n    ((null? S) #f)\n    ((equal?\
    \ (car S) 'I) (+ 1 (is_bored (cdr S))))\n    ((equal? (car S) '.') (+ 1 (is_bored\
    \ (cdr S))))\n    ((equal? (car S) '!') (+ 1 (is_bored (cdr S))))\n    (else (is_bored\
    \ (cdr S)))))\n", "  ;; Write your code below\n  (define (boredom S i)\n    (cond\n\
    \      [(equal? S \"I\") i]\n      [(equal? S \".\") (boredom (substring S i (+\
    \ 1 i)) (+ 1 i))]\n      [(equal? S \"?\") (boredom (substring S i (+ 1 i)) (+\
    \ 1 i))]\n      [(equal? S \"!\") (boredom (substring S i (+ 1 i)) (+ 1 i))]\n\
    \      [else (boredom (substring S i (+ 1 i)) (+ 1 i))]\n    )\n  )\n  (boredom\
    \ S 0)\n)\n", "  (< (length (string-split S \".\")) 2)\n  (and (equal? first S)\
    \ \"I\"))\n", "  (chars-match? #\\i S)\n)\n", "  ; TODO: write code here\n)\n",
  "  (let ([borem-sentences (split-sentences S\n                                 \
    \       #(lambda (s) (string-match #rx\"[\\.\\?!]\" s))\n                    \
    \                    #(lambda (w s) (string-match #rx\"I\" w)))])\n    (length\
    \ borem-sentences)))\n", "  (define (boredom sentence)\n    (cond\n      [(equal?\
    \ (substring sentence 0 3) \"I\") 1]\n      [(equal? (substring sentence 0 3)\
    \ \"the\") (+ 1 (boredom (substring sentence 4 7)))]\n      [else 0]))\n  (boredom\
    \ S))\n", "  (length (filter #(equal? (first %) \"I\") (explode S))))\n", "  (=\
    \ (car S)\n     (if (string-equal? \"I\" (car S)) \n         (+ 1 (is_bored (cdr\
    \ S))) 0))\n)\n</code>\nBe sure to try out your code before submitting it! I made\
    \ a couple of minor changes to it. You might want to think about how you would\
    \ handle a sentence with two boredoms!\nEDIT: Revised answer\n<code>", "  (cond\n\
    \    ((null? S) 0)\n    ((eq? (string-downcase (first S)) \"i\") 1)\n    (else\
    \ (+ 1 (is_bored (rest S))))))\n</code>\nNow that we've defined is_bored, let's\
    \ take a look at what we do with the boredom count.\n<code>", "  (if (string=?\
    \ S \"I.\")\n      (+ 1 (is_bored (substr S 2))))\n  (if (string=? S \".\") 0\n\
    \      (if (string=? S \"?\") 0\n          (if (string=? S \"!\") 0))))\n", " \
    \ (match (regexp-opt \"^[\\.?!]\") S\n    ((_ \".\")       0)\n    ((_ \"?\")\
    \       0)\n    ((_ \"!\")       0)\n    ((_ \"I.*\")     1)\n    ((_ \"I.*\"\
    )     1)\n    ((_ \"I love\") 1)\n    ((_ \"I love\")  1)\n    ((_ \"I.*love\"\
    ) 2)\n    ((_ \"I.*love\")  2)\n    ((_ \"I.*love. I.*love\")  2)\n    ((_ \"\
    I.*love. I.*love\")  2)\n    ((_ \"I.*love. I.*love. I.*love\")  3)\n    ((_ \"\
    I.*love. I.*love. I.*love. I.*love\")  3)\n    ((_ \"I.*love. I.*love. I.*love.\
    \ I.*love. I.*love\")  4)\n    ((_ \"I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love\")  4)\n    ((_ \"I.*love. I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love\") 4)\n    ((_ \"I.*love. I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love. I.*love.\
    \ I.*love. I.*love. I.*love. I.*lo", "  (cond ((= (length S) 0) 0)\n        ((equal?\
    \ (substring S 0 1) \"I\") 1)\n        (else (+ 1 (is_bored (substring S 0 -1))))))\n\
    </cell>\n<text>\nExercise\nUsing the function is_bored you defined above, write\
    \ a program that prints the number of boredoms in a given string.\n\n\n</text>\n\
    <cell>", "  (define (helper L i L)\n    (cond\n      [(equal? i-1 0) (count (substring\
    \ L 0 3) \"boredom\")]\n      [else (helper L (+ i 1) (substring L i 3))]))\n\
    \  (helper (string S) 0 \"\"))\n", "  (re-match (#rx (?:I .+)? \\.)\n        \
    \     S\n             :start\n             (#rx (?:I .+)? \\.)\n             :end\n\
    \             (#rx (?:I .+)? \\.))\n  0)\n", "  (local ((define (count-bored sent)\n\
    \            (cond\n             ((or (string=? (first sent) \"I\") (string=?\
    \ (first sent) \"I.\")\n                  (string=? (first sent) \"!\"))\n   \
    \            (+ 1 (count-bored (rest sent))))\n             (else 0)))\n     \
    \     (define (cons-bored S)\n            (cond\n             ((empty? S) 0)\n\
    \             ((string=? (first S) \"I\") (cons-bored (rest S)))\n           \
    \  (else (cons-bored (rest S))))\n          (define (rem-bored S)\n          \
    \  (cond\n             ((empty? S) '())\n             ((string=? (first S) \"\
    I\") (rem-bored (rest S)))\n             ((string=? (first S) \"I.\")\n      \
    \       (cons-bored (rest S)))\n             ((string=? (first S) \"!\")\n   \
    \          (cons-bored (rest S)))\n             (else (cons-bored (rest S)))))\n\
    \          (define (cons-bored-sentences sent)\n            (cond\n          \
    \   ((empty? sent) '())\n             ((string=? (first sent) \"I\") (cons-bored-sentences\
    \ (rest sent)))\n             (else (cons-bored-sentences sent)\n            \
    \       (cons-bored (rest sent)))))\n          (define (rem-bored-sentences sent)\n\
    \            (cond\n             ((empty? sent) '())\n             ((string=?\
    \ (first sent) \"I\") (rem-bored-sentences (rest sent)))\n             ((string=?\
    \ (first sent) \"I.\")\n             (cons-bored-sentences sent)\n           \
    \  ((string=? (first sent) \"!\")\n             (cons-bored-sentences sent)))\n\
    \             (else (cons-bored-sentences sent\n                             \
    \    (cons-bored (rest sent)))))))\n  (count-bored S))\n", "  (define (boredom\
    \ x count)\n    (if (equal? (substring x 0 1) \"I\")\n        (add1 count)\n \
    \       count))\n  (let ((count 0))\n    (for-each (lambda (x) (boredom x count))\
    \ (split S \"\\.|?|!\"))))\n", "  (match S\n    ((regex \"^I\") 1)\n    ((regex\
    \ \"^[\\.\\?!][\\.\\?!]\") 0)\n    ((regex \".\") 0)\n    ((regex \"[\\.\\?!]\"\
    ) 0)\n    ((regex \".?\") 0)\n    ((regex \"[.\\?!]?\") 0)\n    ((regex \".?!\"\
    ) 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n\
    \    ((regex \"[.\\?!]?\") 0)\n    ((regex \".?\") 0)\n    ((regex \".?!\") 0)\n\
    \    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n  \
    \  ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex\
    \ \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \"\
    .??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\"\
    ) 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n\
    \    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n  \
    \  ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex\
    \ \".!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \"\
    .!\") 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \".!\"\
    ) 0)\n    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n\
    \    ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n  \
    \  ((regex \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex\
    \ \".?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \"\
    .?!\") 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\"\
    ) 0)\n    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n\
    \    ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex \".?!\") 0)\n  \
    \  ((regex \".??\") 0)\n    ((regex \".!\") 0)\n    ((regex ", "  (cond\n    [(or\
    \ (= (string-length S) 0) (string-match \"^I.*\" S)) 0]\n    [else (+ 1 (is_bored\
    \ (string-replace \"[.,?!]\" \"\" (string-downcase S))))]))", "  (cond [(= (length\
    \ S) 0) 0]\n        [(= \"I\" (car S)) 1])\n  )\n", "  (let ((i 0))\n    (let\
    \ loop ((S S))\n      (if (equal? S \"\") 0\n          (if (equal? (char-type\
    \ (car S)) #\\? #\\.)\n              (if (equal? (char-type (car (cdr S)) #\\\
    ? #\\.) #\\! #\\?)\n                  (if (equal? (char-type (car (cdr (cdr S))\
    \ #\\? #\\.)) #\\!)\n                      (loop (append (cons (car S) '(i)) (cdr\
    \ S)))\n                      (loop (append (cons S '(i)) (cdr S)))))))\n    \
    \  (i))))\n", "  (match S\n    ['(. .) 0]\n    ['(. .? .!) 1]\n    ['(. .? .!)\
    \ 2]\n    ['(. .? .!) 3]\n    ['(. .? .!) 4]\n    ['(. .? .!) 5]\n    ['(. .?\
    \ .!) 6]\n    ['(. .? .!) 7]\n    ['(. .? .!) 8]\n    ['(. .? .!) 9]\n    ['(.\
    \ .? .!) 10]\n    ['(. .? .!) 11]\n    ['(. .? .!) 12]\n    ['(. .? .!) 13]\n\
    \    ['(. .? .!) 14]\n    ['(. .? .!) 15]\n    ['(. .? .!) 16]\n    ['(. .? .!)\
    \ 17]\n    ['(. .? .!) 18]\n    ['(. .? .!) 19]\n    ['(. .? .!) 20]\n    ['(.\
    \ .? .!) 21]\n    ['(. .? .!) 22]\n    ['(. .? .!) 23]\n    ['(. .? .!) 24]\n\
    \    ['(. .? .!) 25]\n    ['(. .? .!) 26]\n    ['(. .? .!) 27]\n    ['(. .? .!)\
    \ 28]\n    ['(. .? .!) 29]\n    ['(. .? .!) 30]\n    ['(. .? .!) 31]\n    ['(.\
    \ .? .!) 32]\n    ['(. .? .!) 33]\n    ['(. .? .!) 34]\n    ['(. .? .!) 35]\n\
    \    ['(. .? .!) 36]\n    ['(. .? .!) 37]\n    ['(. .? .!) 38]\n    ['(. .? .!)\
    \ 39]\n    ['(. .? .!) 40]\n    ['(. .? .!) 41]\n    ['(. .? .!) 42]\n    ['(.\
    \ .? .!) 43]\n    ['(. .? .!) 44]\n    ['(. .? .!) 45]\n    ['(. .? .!) 46]\n\
    \    ['(. .? ", "  (cond [(starts-with? S \"I\") 0]\n        [(starts-with? S\
    \ \".\") 1]\n        [(starts-with? S \"?\") 1]\n        [(starts-with? S \"!\"\
    ) 1]\n        [else 0]))\n", "  (cond [(empty? S) #f]\n        [(starts-with?\
    \ (car S) \"I\") 1]\n        [else 0]))\n", "  (cond\n    ((equal? S \"I\") 1)\n\
    \    ((equal? (rest S) \".\") (+ 1 (is_bored (rest S))))\n    ((equal? (rest S)\
    \ \"?\") (+ 1 (is_bored (rest S))))\n    ((equal? (rest S) \"!\")\n     (+ 1 (is_bored\
    \ (rest S))))\n    ((null? S) 0)\n    (else (is_bored (rest S)))))\n", "  (define\
    \ (loop s idx)\n    (cond ((eq? s (substring S idx idx '?)) (+ idx (loop (substring\
    \ S idx idx '.') idx))) ; dot or question mark\n          ((eq? s (substring S\
    \ idx idx '.')) ; dot or full stop\n           (loop (substring S idx idx '.')\
    \ idx)) ; start over with the next dot\n          ((eq? s '!') (loop (substring\
    \ S idx idx '.') idx)) ; full stop\n          (else (loop (substring S idx idx\
    \ '.') idx))) ; otherwise keep going\n  (loop 'I 0))\n", "  (if (or (char=? (car\
    \ S) ?'(. ? !))\n          (char=? (car S) ?'.'))\n      (+ 1 (is_bored (cdr S)))\n\
    \      0))\n", "  (if (empty? S)\n      0\n      (if (equal? (car S) \"I\") 1)))\n",
  "  (= (length S) 1)\n  (char=? (car S) #\\?))\n", "  (if (equal? (substring S 0\
    \ 0) \"I\")\n      (+ 1 (is_bored (substring S 1)))\n      (is_bored (substring\
    \ S 0)))) ;;(is_bored (substring S 0))\n</code>\n<|/ a |>\n<| a |>\nThis is probably\
    \ not what you're looking for, but I'm posting this anyway. As your first function\
    \ does something else, I have made it more general. \n<code>", "  (let loop ((count\
    \ 0) (strings '()) (word '()))\n    (cond\n      [(empty? S) (if (null? word)\
    \ count 0)]\n      [(char=? (first S) '?') (incf count)]\n      [(char=? (first\
    \ S) '.') (incf count)]\n      [(char=? (first S) '!') (incf count)]\n      [(char=?\
    \ (first S) 'I') (incf count)]\n      [else (incf count)]))\n  (loop 0 '() S))\n",
  "  (define str (string-split S (string-char '.? '? '!)))\n  (cond\n    [(empty?\
    \ str) 0]\n    [(equal? (first str) \"I\") 1]\n    [else (+ 1 (is_bored (rest\
    \ str)))]))\n", "  (cond [(empty? S) #t]\n        [(equal? (first S) \"I\") #t]\n\
    \        [(equal? (first S) \"!\") #t]\n        [else (is_bored (substring (next\
    \ S) 0 -1)) +1]))\n", "  (= (length S) (+ 1 (count (lambda (x) (= x \"I\"))\n\
    \                         (split S \"[.!?]\")))\n))\n", "  (< (length S)\n   \
    \  (string-length (first S) 1 \".\" 1 \".\" 1 \".\")))\n", "  (length (filter\
    \ (lambda (x) (equal? x (substring S 0 (string-length S) \"I\"))))\n         \
    \ (filter (lambda (x) (equal? x (substring S 0 (string-length S) \"I\"))))))\n",
  "  (count_bored? S \"I\"))\n", "  (let ((bored? 0))\n    (if (null? S)\n       \
    \ bored?\n        (if (string=? (first S) \"I\")\n            (set! bored? (add1\
    \ (equal (first S) 'I)))\n            (if (equal? (first S) \".\")\n         \
    \       (set! bored? (add1 (equal (first S) '.')))\n                (if (equal?\
    \ (first S) '?')\n                    (set! bored? (add1 (equal (first S) '!')))\n\
    \                    (if (equal? (first S) '!')\n                        (set!\
    \ bored? (add1 (equal (first S) '?')))\n                        (is_bored (cons\
    \ (first S) (cons (rest S) bored?)))\n                    )\n                )\n\
    \            )\n        )\n    )\n    bored?\n  )\n)\n", "  (if (string=? S \"\
    I.\")\n      (+ 1)))\n", "  (if (empty? S)\n      0\n      (if (equal? (first\
    \ S) 'I)\n          0\n          (+ 1 (is_bored (rest S)))))) ; increment counter\n",
  "  (count_boredoms S \"I\"))\n", "  (match S\n    [(#t (. (begins-with? 'I . #t))\
    \ _)\n     (- 1)]\n    [(_) #f]))\n", "  (cond [(starts-with? S  \"I\") (+ (length\
    \ (split-after \".\" S)) (length (split-after \"?\" S)) (length (split-after \"\
    !\" S)))]\n        [else 0]))\n", "  (cond [(equal? (char-after 'I S) \"I\")\n\
    \         (+ 1 (count-boredom S \".\"))]\n        [(equal? (char-after '? S) \"\
    ?\")\n         (+ 1 (count-boredom S \"?\"))]\n        [(equal? (char-after '!\
    \ S) \"!\")\n         (+ 1 (count-boredom S \"!\"))]\n        [else 0]))\n", " \
    \ (let ([L #[(sentence S) (token \"I\")]\n        count 0])\n    (cond\n     \
    \ [(null? L) count]\n      [(token? (first L)) (+ (count 1) (is_bored (rest L)))]\n\
    \      [else (is_bored (rest L))]))))\n", "  (cond\n    ((null? S) 0)\n    ((starts-with\
    \ S \"I\") 1)\n    (else\n     (+ (is_bored (substring S 1 ))\n        (is_bored\
    \ (substring S (+ 1 )))))))\n", "  (let ((l (string-length S))\n        (boredom\
    \ 0))\n    (loop for i from 0 to (- l 1)\n          when (char=? (string->char\
    \ c (+ i l)) ?. ?i)\n          do (incf boredom)\n          until (char=? S ?.\
    \ ?i))\n    boredom))\n", "  (cond [(empty? S) 0]\n        [(starts-with? S \"\
    I\") 1]))\n", "  (let ([L (string->list S)]\n        [start (first (take-while\
    \ string=? (rest L))) \"I\"]\n        [end (last (take-while string=? (rest L)))\
    \ \".\"])\n    (cond\n      [(or (string=? start end) (string=? (first L) \"I\"\
    ))\n       (+ 1 (count (rest (rest L))))]\n      [else 0])))\n", "  (define (find\
    \ S T)\n    (cond\n      [(string=? (first T) (first (first S)))\n       (+ 1\
    \ (find (tail S) T))]\n      [(equal? (first T) '?)\n       (+ 1 (find (tail S)\
    \ (tail (first S))))]\n      [(equal? (first T) '!)\n       (+ 1 (find (tail S)\
    \ (tail (first S))))]\n      [else 0]))\n  (find S '(\"I\" \"!\" \"?\" \".\")))\n",
  "  (match S\n    ((.? I)\n     (1+ (is-bored (substring S 0 (string-length S)))))\n\
    \    ((.? .)\n     (if (string-starts-with (substring S 0) \"I\")\n         (1+\
    \ (is-bored (substring S 0 (string-length S)))))\n     (1+ (is-bored (substring\
    \ S 0 (string-length S)))))\n    ((.? .)\n     (if (string-starts-with (substring\
    \ S 0) \"!\")\n         (1+ (is-bored (substring S 0 (string-length S)))))\n \
    \    (1+ (is-bored (substring S 0 (string-length S)))))\n    ((.? .?)\n     (if\
    \ (string-starts-with (substring S 0) \"I\")\n         (1+ (is-bored (substring\
    \ S 0 (string-length S)))))\n     (1+ (is-bored (substring S 0 (string-length\
    \ S)))))\n    ((.? .?)\n     (if (string-starts-with (substring S 0) \"!\")\n\
    \         (1+ (is-bored (substring S 0 (string-length S)))))\n     (1+ (is-bored\
    \ (substring S 0 (string-length S)))))\n    ((.? .)\n     (if (string-starts-with\
    \ (substring S 0) \"!\")\n         (1+ (is-bored (substring S 0 (string-length\
    \ S)))))\n     (1+ (is-bored (substring S 0 (string-length S)))))\n    ((.? .)\n\
    \     (if (string-starts-with (substring S 0) \"?\")\n         (1+ (is-bored (substring\
    \ S 0 (string-length S)))))\n     (1+ (is-bored (substring S 0 (string-length\
    \ S)))))\n    ((.? .)\n     (if (string-starts-with (substring S 0) \".\")\n \
    \        (1+ (is-bored (substring S 0 (string-length S)))))\n     (1+ (is-bored\
    \ (substring S 0 (string-length S)))))\n    ((.? .)\n     (if (string-starts-with\
    \ (substring S 0) \"!\")\n         (1+ (is-bored (substring S 0 (string-length\
    \ S)))))\n     (1+ (is-bored (substring S 0 (string-length S)))))\n    ((.? .)\n\
    \     (if (string-starts-with (substring S 0) \"?\")\n         (1+ (is-bored (substring\
    \ S 0 (string-length S)))))\n     (1+ (is-bored (substring S 0 (string-length\
    \ S)))))\n    ((.? .)\n     (if (string-starts-with (substring S 0) \".\")\n \
    \        (1+ (is-bo", "  (define (loop0 S)\n    (cond\n      [(empty? S) 0]\n\
    \      [(string=? (car S) \"I\") (+ 1 (loop0 (cdr S)))]\n      [else (loop0 (cdr\
    \ S))]))\n  (loop0 S))\n", "  (let ((boredoms (count)))\n    (if (and (char=?\
    \ (first S) 'I) (string-match \".*\\.|.*\\?|.*!\" S))\n        (add1 boredoms)\n\
    \        boredoms)))\n", "  (define (bored S)\n    (cond\n      [(equal? S \"\
    I\") 0]\n      [(equal? S \".\") 0]\n      [(equal? S \"?\") 0]\n      [(equal?\
    \ S \"!\") 0]\n      [(equal? (substring S 0 1) \"I\") 1]\n      [else 0]))\n\
    \  (bored S))\n", "  (= (str-indexof \"I \" (str S)) 0))\n", "  (cond\n    [(equal?\
    \ (first S) \"I\") 1]\n    [else 0]))\n", "  (cond [(string=? (first S) \"I\"\
    ) 1]\n        [else 0]))\n", "  (define (helper S)\n    (cond\n      [(empty?\
    \ S) 0]\n      [(equal? first (first S)) (+ 1 (helper (rest S)))]\n      [(equal?\
    \ (first S) \".\") (+ 1 (helper (rest S)))]\n      [(equal? (first S) \".?\")\
    \ (+ 1 (helper (rest S)))]\n      [(equal? (first S) \"!\") (+ 1 (helper (rest\
    \ S)))]))\n  (helper S))\n", "  (let ([L (string->list S)])\n    (cond\n     \
    \ [(or (null? L) (equal? L '())) 0]\n      [(equal? (first L) 'I) (+ 1 (is_bored\
    \ (rest L)))]\n      [else (is_bored (rest L))]))))\n", "  (match\n    ((begin\
    \ \"I\" . rest)\n     (begin \"!\" . rest)\n     (begin \".\" . rest))\n    (S\
    \ #:count 1)\n    (else #:count 0)))\n", "  (let ((bored (find (lambda(x) (=?\
    \ (first x) 'I)) S)))\n    (cond\n      ((null? bored) 0)\n      (else (+ 1 (is_bored\
    \ (rest bored)))))\n  )\n)\n", "  ;; split the string by space\n  (define sentences\
    \ (string->list S))\n  (define (count-bored S k)\n    (cond\n      [(and (list?\
    \ S) (null? S)) 0]\n      [(and (equal? S (car S)) (string-match-p \"^I\" (cdr\
    \ S))) k]\n      [(and (equal? S (car S)) (string-match-p \"^[.?!]\" (cdr S)))\
    \ k (+ k (count-bored (cdr S) k))]))\n  (count-bored sentences 0))\n", "  (cond\n\
    \    [(null? S)                          (0)]\n    [(starts-with? S \"I\")   \
    \           (1)]\n    [(starts-with? S \"I.\")              (1)]\n    [(starts-with?\
    \ S \"I?\")              (1)]\n    [(starts-with? S \"I!\")              (1)]\n\
    \    [else                             (0)]))\n", "  (count-bored-words (first\
    \ S)))\n", "  (define (count-boredom sentence)\n    (if (string-match \"^I\" sentence)\n\
    \        0\n        (+ 1 (count-boredom (string-tail sentence))))\n  (count-boredom\
    \ S))\n", "  (letrec\n    ([bored (lambda (sentence . words)\n             (cond\n\
    \              [(or (equal? (first words) 'I) (equal? (first words) 'my)) 0]\n\
    \              [(or (equal? (first words) 'A) (equal? (first words) 'my)) 0]\n\
    \              [else (+ 1 (bored (second sentence) (rest words)))]))]\n    [sentence\
    \ (split S #\\\".\\\")]\n    [words (split (first sentence) #\\\".\\\")]\n   \
    \ )\n    (bored sentence words)))\n", "  (cond\n    ((string-match \"^I\" S)\n\
    \     (string-match \"^I\" S))\n    ((string-match \"^I\" S)\n     (string-match\
    \ \"^I\" S))\n    ((string-match \"^I\" S)\n     (string-match \"^I\" S))\n  \
    \  (else\n     (string-match \"^I\" S))))\n", "  (cond\n    [(empty? S) 0]\n \
    \   [(starts-with? S \"I\") 1]))\n", "  (if (empty? S) #f\n      (if (equal? first\
    \ \"I\" (first S)) #t #f)))\n", "  (define (find S i L)\n    (cond\n      [(equal?\
    \ S (car L)) i]\n      [else (find S (+ i 1) (cdr L))]))\n  (define (bored S)\n\
    \    (if (char? S)\n        (if (equal? \"I\" (substring S 0 1))\n           \
    \ (+ 1 (find S 0 S)))\n        (+ 1 (find S 0 S))))\n  (bored S))\n", "  (letrec\
    \ (\n          ([is-bored (lambda (S)\n                        (or (char-type\
    \ (car S)) #\\?\n                               (char-type (cadr S)) #\\.\n  \
    \                             (char-type (caddr S)) #\\!)\n                  \
    \       #f))])\n    (cond [(is-bored S)\n           0]\n          [else 1])))\n",
  "  (if (= (string-length S)\n         (string-length #\"i\"))\n      0\n      1))\n",
  "  (match S\n      ((\"\") 0)\n      ((#\\. #\\? #\\!) (if (equal? S \"I\") (+ 1\
    \ (is_bored (rest S)))\n                         (is_bored (rest S)))))\n    \
    \  ((#\\. #\\? #\\!) (is_bored (rest S)))\n      ((#\\. #\\? #\\!) (is_bored (rest\
    \ S)))))\n", "  (define (helper S acc n)\n    (cond\n      [(empty? S) n]\n  \
    \    [(equal? (first S) 'I) (helper (rest S) acc (+ n 1))]\n      [(equal? (first\
    \ S) '?) (nth (rest S) n)]\n      [(equal? (first S) '!) (nth (rest S) n)]\n \
    \     [else (helper (rest S) (+ acc (if (equal? (first S) 'I) 1 0)) n)]\n    )\n\
    \  )\n  (helper S 0 0))\n", "  (cond\n    [(empty? S) #f]\n    [(equal? (first\
    \ S) \"I\") #t]\n    [else #f]))\n", "  (define (boredom-counter string)\n   \
    \ (define (boredom-counter i string)\n      (cond [(char=? string \"I\" i) 0]\n\
    \            [(char=? string \".\" i) 0]\n            [(char=? string \"?\" i)\
    \ 0]\n            [(char=? string \"!\" i) 0]\n            [else (+ boredom-counter\
    \ (boredom-counter i (string-tail string))))]))\n  (boredom-counter '() S))\n",
  "  (cond [(starts-with S \"I\") 0]\n        [(starts-with S \"I.\") 0]\n       \
    \ [(starts-with S \"I.!\") 0]\n        [(starts-with S \"I.?\") 0]\n        [(starts-with\
    \ S \"I!\") 0]\n        [(starts-with S \"I?\") 0]\n        [else 1]))\n", " \
    \ (let ([lst (split-string S \" \")])\n    (and (equal? (substring lst (first\
    \ (rest lst)) 0) \"I\")\n         (>= (length lst) 2))))\n", "  (< (length S)\
    \ 2)\n  (= (substring S 0 1) \"I\"))\n", "  (let loop ((count 0) (sentence S))\n\
    \    (cond ((string=? (substring S 0 3)\n                     \"I\") (inc count))\n\
    \          ((string=? (substring S 0 7)\n                     \"I\") (inc count))\n\
    \          ((string=? (substring S 0 9)\n                     \"I\") (inc count))\n\
    \          ((string=? (substring S 0 11)\n                     \"I\") (inc count))\n\
    \          (else (inc count)))\n    (loop count sentence)))\n", "  (cond [(string=?\
    \ (string=? \"I\" S) \"I\") 1]\n        [(string=? (string=? \"I\" S) \"!\") 0]\n\
    \        [(string=? (string=? \"?\" S) \"?\") 0]\n        [(string=? (string=?\
    \ \"!\" S) \"!\") 0]\n        [else 0]))", "  (cond\n    [(equal? (first S) \"\
    I\") 0]\n    [else 1]))\n", "  (match ((S . bore))\n    ((bore . bored) 0)\n \
    \   ((bore . unbored) 1)\n    ((bore . unbore) 0)))\n", "  (length (filter (lambda\
    \ (x) (equal? x \"I\")) S)))\n", "  (cond\n    [(equal? (first S) \"I\") 0]\n\
    \    [(equal? (first S) \"!\") 0]\n    [(equal? (first S) \".\") 0]\n    [else\
    \ 1]))\n", "  (let ([I (substring (first S) 0 1)] ;; Get the first word of S\n\
    \t   [rest (rest S)])\n    (cond\n      [(= I \"I\") (+ 1 (is_bored rest))]\n\
    \      [(not (member? I [\".\" \"?\" \"!\"])) 0]\n      [else (is_bored rest)])))\n",
  "  (let loop ((S S) (i 0))\n    (cond\n      ((equal? S \"\") i)\n      ((equal?\
    \ (string-ref S 0) \"I\") i)\n      ((equal? (string-ref S 0) \".\") (loop (substring\
    \ S 1) (+ i 1)))\n      ((equal? (string-ref S 0) \"?\") (loop (substring S 1)\
    \ (+ i 1)))\n      ((equal? (string-ref S 0) \"!\") (loop (substring S 1) (+ i\
    \ 1)))\n      (else (loop (substring S 1) i))))))\n", "  (cond [(equal? (string-match\
    \ \"I (.*)\" S) 1) 1]\n        [(equal? (string-match \"\\. (.*)\" S) 1) 1]\n\
    \        [(equal? (string-match \"! (.*)\" S) 1) 1]\n        [else 0]))\n", " \
    \ (let ((bored 0))\n    (define (loop (S str)\n              (if (= (length S)\
    \ 0)\n                  (cond ((string=? (substring S 0) str)\n              \
    \           (+ 1 (substring S 0 1)))\n                        (else (cond ((string=?\
    \ (substring S 1) str)\n                                  (loop (substring S 1\
    \ -1)\n                                        (substring S 0 1)))\n         \
    \                         (else 0)))))\n    (loop (reverse S)\n          (cond\
    \ ((string=? (substring S 0) \"I\")\n                 (loop (substring S 1 -1)\n\
    \                        (substring S 0 1)))\n              (else 0)))\n    bored)))\n",
  "  (define (bored-state str)\n    (cond ((eq? (first str) \"I\") 0)\n          ((eq?\
    \ (first str) \".\") 0)\n          ((eq? (first str) \".?\") 0)\n          ((eq?\
    \ (first str) \".!\") 0)\n          (else 0)))\n  (reduce bored-state (explode\
    \ S) 0))\n", "  (length (filter #(begins-with \"I\" . _) #(string->list S))))\n",
  "  (define (is-bored word)\n    (cond\n      [(empty? word) #t]\n      [(equal?\
    \ (first word) \"I\") #t]\n      [else (and (equal? (first word) \"I\")\n    \
    \           (equal? (rest word) \".\")\n               (equal? (rest word) \"\
    ?\")\n               (equal? (rest word) \"!\"))]))\n  (count\n   (for [word (split\
    \ S \".\")\n         if (is-bored word)]\n    word))\n)\n", "  (define (helper\
    \ S) (match S\n                             [(#regex #\"\\bI\\b\") 1]\n      \
    \                       [(#regex #\"[.?!]\") 0]\n                            \
    \ [(#regex #\"\\b[Ii]\\b\") 0]\n                             [(#regex #\"\\b[iI]\\\
    b\") 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n         \
    \                    [(#regex #\"\\b[!i]\\b\") 0]\n                          \
    \   [(#regex #\"\\b[!i]\\b\") 0]\n                             [(#regex #\"\\\
    b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n  \
    \                           [(#regex #\"\\b[i!]\\b\") 0]\n                   \
    \          [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]\n                             [(#regex\
    \ #\"\\b[i!]\\b\") 0]\n                             [(#regex #\"\\b[i!]\\b\")\
    \ 0]\n                             [(#regex #\"\\b[i!]\\b\") 0]\n            \
    \                 [(#regex #\"\\b[i!]\\b\") 0]", "  (cond\n    [(equal? (first\
    \ S) \"I\") 1]\n    [else 0]))\n</cell>\n<cell>\n# Exercise: implement a predicate\
    \ called \"is_bored_with\"\n#lang racket\n", "  (let* ((L (length S))\n      \
    \   (S1 (substring S 0 L)))\n    (cond\n      [(eq? S1 \"I\") 0]\n      [else\
    \ (+ 1 (is_bored S1))])))\n", "  (count (lambda (x) (regexp-match #rx\"I\\w*\"\
    \ x)))\n  S)\n", "  (let ([chars (split S \"[.?!]\" 0)])\n    (and (= (first chars)\
    \ \"I\")\n         (< 1 (length chars)))))\n", "  (cond\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"you\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 1)\n    ((string=? (substring (first S) \"I\") \"You\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"You\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I\"\
    ) 0)\n    ((string=? (substring (first S) \"I\") \"I\") 0)\n    ((string=? (substring\
    \ (first S) \"I\") \"I\") 0)\n    ((string=? (substring (first S) \"I\") \"I",
  "  (count\n   (lambda (x)\n      (and (= (first x) \"I\")\n           (rest x)))\n\
    \   S))\n", "  (cond\n    [(equal? S (substring S 0 2)) #t]\n    [(equal? S (substring\
    \ S 0 5)) #f]\n    [else (is_bored (substring S 1 3))]))\n", "  ;; Write your\
    \ code here\n  (check-expect (length S) (= 0 (count-words S)))\n  (check-expect\
    \ (count-words S) (= 1 (count-bored-sentence S)))\n  (check-expect (count-bored-sentence\
    \ S) (= 1 (count-bored-sentence S (substring S 0 1))))\n  (check-expect (count-bored-sentence\
    \ S (substring S 0 1)) 0))", "  (define (is-bored S i)\n    (cond [(null? S) 0]\n\
    \          [(eq? (substring S i i) 'I) (+ 1 (is-bored (rest S) (i+1)))]\n    \
    \      [else (is-bored (rest S) (i+1))]))\n  (is-bored S 0))\n", "  (count (lambda\
    \ (w) (beginswith w \"I\"))\n          (explode S) 0))\n", "  (let loop ((index\
    \ 0))\n    (cond ((null? S) index)\n          ((char=? (first S) \"I\") (loop\
    \ (add1 index)))\n          (else (loop (add1 index))))))\n", "  (cond ((null?\
    \ S) 0)\n        ((char-lower? (car S)) (let ((bored 0))\n                   \
    \            (cond ((char-upper? (car S)) (set! bored 1))\n                  \
    \                    ((char-lower? (car S)) (set! bored 0))\n                \
    \                      (else (set! bored (- bored 1)))))\n        (else (+ (is_bored\
    \ (cdr S)) 1))))\n", "  (= (count \"I\" S) 0))\n", "  (or (equal? (first S) \"\
    I\") (equal? (first S) \"!\") (equal? (first S) \".\") (equal? (first S) \"?\"\
    ) (equal? (first S) \"!\") (equal? (first S) \"?\")))\n)\n", "  (cond ((empty?\
    \ S) #f)\n        ((equal? (car S) \"I\") 1)\n        (else (+ 1 (is_bored (cdr\
    \ S)))))\n  )\n", "  (let ([S (string->list S)])\n    (cond\n      [(string=?\
    \ (car S) \"I\") (+ 1 (string-count \"I\" (string->list S)))]\n      [else 0])))\n",
  "  ;; Return a list containing the number of boredoms in each sentence\n  (define\
    \ boredoms '())\n  (define (count-boredoms sentence)\n    (if (string=? (substring\
    \ sentence 0 1) \"I\")\n        (+ 1 (count-boredoms (substring sentence 1 string=?)))\n\
    \      (+ 1 (count-boredoms))))\n\n  (count-boredoms S))\n", "  (cond [(string=?\
    \ (car S) 'I)\n         (add1 in-bored)]\n        [(string=? (car S) '!)\n   \
    \      (add1 in-bored)]\n        [(string=? (car S) '.)\n         (add1 in-bored)]))\n",
  "  (let ((boredom 0) (s S))\n    (if (string-match \"^I\" s)\n        boredom\n\
    \        (begin\n          (if (string-match \"^[.!?]\" s)\n              (if\
    \ (string-match \"^I\" s)\n                  (begin\n                    (if (string-match\
    \ \"[.!?]\" s)\n                        (begin\n                          (if\
    \ (string-match \"[.!?]\" s)\n                              (begin\n         \
    \                       (if (string-match \"[.!?]\" s)\n                     \
    \               (begin\n                                      (if (string-match\
    \ \"[.!?]\" s)\n                                          (begin\n           \
    \                                 (if (string-match \"[.!?]\" s)\n           \
    \                                     (begin\n                               \
    \                   (if (string-match \"[.!?]\" s)\n                         \
    \                             (begin (set! boredom (+ boredom 1))\n          \
    \                                            (begin (set! s (substring s (+ 3\
    \ (string-length s)))))))\n                                                  (begin\
    \ (set! s (substring s (+ 1 (string-length s)))))))\n                        \
    \                      (begin (set! s (substring s (+ 2 (string-length s)))))))\n\
    \                                          (begin (set! s (substring s (+ 3 (string-length\
    \ s)))))))\n                                      (begin (set! s (substring s\
    \ (+ 4 (string-length s)))))))\n                                (begin (set! s\
    \ (substring s (+ 5 (string-length s)))))))))))))))\n", "  (cond\n    ((null?\
    \ S) 0)\n    ((equal? (substring (first S) \"I\") \"I\") 1)\n    ((equal? (substring\
    \ (first S) \"I\") \".\") (is_bored (substring (rest S) 0)))\n    ((equal? (substring\
    \ (first S) \"I\") \"?\") (is_bored (substring (rest S) 0)))\n    ((equal? (substring\
    \ (first S) \"I\") \"!\") (is_bored (substring (rest S) 0)))))\n", "  (cond [(string=?\
    \ S (substring \"I \" 0)) (length S)]\n        [else 0]))\n", "  (count (lambda\
    \ (x)\n           (and (starts-with? x \"I\")\n                (equal? (rest x)\
    \ \".\")\n                (equal? (rest x) \"?\")\n                (equal? (rest\
    \ x) \"!\")))))\n", "  (match S\n    [(#\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\. #\\\
    . #\\", "  ;; Write your code below this line\n  (cond\n    [(or (char-equal?\
    \ (first S) \"I\") (char-equal? (first S) \"!\")) 0]\n    [(and (char-equal? (first\
    \ S) \".\") (char-equal? (first S) ?\"?)\n            (char-equal? (first S) \"\
    !\")) 1]))\n", "  (cond [(string-starts-with \"I \" (first S)) 1]\n        [(string-ends-with\
    \ \". ?!\" (first S)) 0]\n        [T 0]))\n", "  ;; The bored count is 0 if it\
    \ does not start with \"I\", 1 if it starts with it.\n  (cond\n    ((empty? S)\
    \ 0)\n    ((string-equal? (substring (first S) 0 1) \"I\") 1)\n    (else (is_bored\
    \ (rest S)))))\n", "  (count-bored S))\n", "  (let ((boredom-count 0))\n    (loop\
    \ for word <- S\n          while word\n          if (equal? (first word) 'I)\n\
    \          collect (+ 1 (boredom-count))\n          else collect 0\n         \
    \ finally (return boredom-count))))\n", "  ;; Implement your solution here!\n\
    \  (let ((bored-word \"I\"))\n    (cond\n      [(string-equal S \".\") 0]\n  \
    \    [(string-equal S \"?\") 0]\n      [(string-equal S \"!\") 0]\n      [(string-equal\
    \ (substring-before S \".\") bored-word) 1]\n      [else 0])))\n", "  (cond [(empty?\
    \ S) #f]\n        [(equal? (first S) \"I\") 1]\n        [else 0]))\n", "  (let\
    \ ([chars (char-list S)])\n    (cond\n      [(string=? chars \"I.\")\n       (length\
    \ (filter (lambda (c) (string=? c \".\")) chars))]\n      [(string=? chars \"\
    ?\")\n       (length (filter (lambda (c) (string=? c \"!\")) chars))]\n      [(string=?\
    \ chars \"!\")\n       (length (filter (lambda (c) (string=? c \".\")) chars))]\n\
    \      [else 0])))\n</code>\nIn response to the comments, here is a solution that\
    \ uses mapcat:\n<code>", "  (let ((boredom-list ()))\n    (loop\n       for str\
    \ = (tokenize S)\n       for str = (tokenize str)\n       for str = (tokenize\
    \ str)\n       if (eqv? str #\\.)\n       append boredom-list\n       else (if\
    \ eqv? str #?)\n       append boredom-list\n       else (if eqv? str #!)\n   \
    \    append boredom-list)))\n", "  (cond [(and (empty? S) (string-match \"^I.\"\
    \ S)) 0]\n        [(and (empty? S) (string-match \"^!.\" S)) 0]\n        [else\
    \ 1]))\n", "  (length (substring-no-case#\n            (string->list S)\n    \
    \        \"I\"))\n  )\n", "  (let ((bored 0))\n    (cond\n      [(string-match\
    \ \"^I\" S) (incf bored)]\n      [(string-match \"[?.!]\" S) (incf bored)]\n \
    \     [else 0])))\n", "  (match (S \"I.*\" ?) (bored-count))\n  (match (S \"!.*\"\
    \ ?) (bored-count))\n  (match (S \".*\" ?) (bored-count))\n  (match (S \"?.*\"\
    \ ?) (bored-count))\n  (match (S \"!.*\" ?) (bored-count)))\n", "  (let ((boredom\
    \ 0))\n    (loop :for c :in S\n          :collect (if (string=? (first c) \"I\"\
    ) (+ boredom 1))\n          :finally (return boredom))))\n", "  ...)\n</cell>\n\
    <cell>\n#lang racket\n", "  (let ([pos-boredoms (assoc #f 'I)]\n        [neg-boredoms\
    \ (assoc #t 'I)])\n    (define (go S)\n      (cond [(not (empty? S)) (length (filter\
    \ (lambda (x)\n                                             (= (car x) ?I))\n\
    \                                               (rest S)))]\n            [(empty?\
    \ S) 0]\n            [else (+ 1 (go (cdr S)))]))\n    (go S)))\n", "  (or (= (substring\
    \ S 0 3) \"I\")\n      (and (substring S 0 2) \"!!\"))\n  )", "  (match S\n  \
    \  [(\"I\" .?? _)        0]\n    [(\"I\" .!? _)        1]\n    [(\"I\" .!? _ \"\
    .\" _)    1]\n    [(_ \".\" .)          1]\n    [(_ \".\" _)          0]\n   \
    \ [(_ \".\" .!? _)        1]\n    [(_ \".\" .!? _ \".\" _)    1]\n    [(_ \".\"\
    \ _ \".\" _)      0]\n    [(_ \".\" .!? _ \".\" _)    1]\n    [(_ \".\" .!? _\
    \ \".\" _ \".\" _)  0]\n    [(_ \".\" .!? _ \".\" _ \".\" _ \".\" _)    1]\n \
    \   [(_ \".\" _ \".\" _ \".\" _)    0]\n    [(_ \".\" .!? _ \".\" _ \".\" _ \"\
    .\" _)    1]\n    [(_ \".\" _ \".\" _ \".\" _ \".\" _)    0]\n    [(_ \".\" .!?\
    \ _ \".\" _ \".\" _ \".\" _ \".\" _)    1]\n    [(_ \".\" _ \".\" _ \".\" _ \"\
    .\" _)    0]\n    [(_ \".\" .!? _ \".\" _ \".\" _)    1]\n    [(_ \".\" _ \".\"\
    \ _)        0]\n    [(_ \".\" .!? _ \".\" _)    1]\n    [(_ \".\" .!? _ \".\"\
    \ _ \".\" _)    1]\n    [(_ \".\" _ \".\" _ \".\" _)    0]\n    [(_ \".\" .!?\
    \ _ \".\" _ \".\" _ \".\" _)    1]\n    [(_ \".\" _ \".\" _ \".\" _ \".\" _) \
    \   0]\n    [(_ \".\" .!? _ \".\" _ \".\" _)    1]\n    [(_ \".\" _ \".\" _) \
    \       0]\n    [(_ \".\" .!? _ \".\" _)    1]\n    [(_ \".\" .!? _ \".\" _ \"\
    .\" _)    1]\n    [(_ \".\" _ \".\" _ \".\" _)    ", "  (if (starts-with? S \"\
    I\")\n      (+ 1 (count_boredoms S))\n      0))\n", "  (let ((boredom 0))\n  \
    \  (loop\n       for c across S\n       when (char=? (c) ?. ?? ?!)\n       if\
    \ (string=? (string=# \"I\" c) c)\n       then boredom\n       else (+ boredom\
    \ 1)\n       finally (return boredom))))\n</cell>\n<cell>\n%%racket", "  (define\
    \ (loop index bored bored-index)\n    (cond ((null? S)\n           (if (or (null?\
    \ bored) (null? bored-index))\n               (equal? 0 (length bored))\n    \
    \           (equal? (length bored) (length bored-index)))\n               (equal?\
    \ bored bored-index))\n          ((char=? (car S) (car (cdr bored)))\n       \
    \    (loop (+ 1 index)\n                   (append bored (cdr bored))\n      \
    \             (+ 1 index)))\n          ((char=? (car S) (car (cdr (cdr bored))))\
    \ ; Is 'S' a boredom sentence?\n           (loop (+ 1 index)\n               \
    \    (append bored\n                          (cdr (cdr bored)))\n           \
    \        (+ 1 index)))\n          (else (loop (+ 1 index)\n                  \
    \    bored\n                      bored-index)))))\n  (loop 0 '() 0))\n</code>\n\
    Note that loop is tail recursive, so it's easy to rewrite it to not use it, but\
    \ I find it cleaner this way.\nI suggest you take a look at Racket's string library;\
    \ it contains lots of useful string manipulation functions, e.g. string-length\
    \ and string-subset; for finding substrings in strings. If you decide to implement\
    \ your is_bored function, you can do it with one line:\n<code>", "  (match (regexp-matches\
    \ S #\"\\A[I]+\\z\") 0\n        (#f (error \"Sentence does not start with 'I'.\"\
    ))\n        (#t (+ 1 (is_bored (regexp-replace S #\"\\A\\..+?\\?\\z\" \"\"))))))\n",
  "  (cond\n    [(empty? S) (error \"empty string\")] \n    [(starts-with? (car S)\
    \ 'I) (+ 1 (is_bored (cdr S)))]\n    [else 0]))\n", "  (cond ((equal? (car S)\
    \ 'I) 0)\n        (else (+ 1 (is_bored (cdr S))))))\n", "  (define (count S k)\n\
    \    (cond\n      [(= S \"\") k]\n      [(equal? (substring S 0 1) \"I\") (+ 1\
    \ (count (substring S 1) k))]))\n  (count S 0))\n", "  ;; split the sentences\
    \ by '.', '?' or '!'\n  (map (fn [w]\n         (string->list w))\n       (string->list\
    \ S)))\n", "  (bol (match (find 'I S) ?. ?!. '.) 0))\n", "  (let loop ((S S) (count\
    \ 0))\n    (cond ((empty? S) count)\n          ((starts-with S \"I\")\n      \
    \     (loop (cdr S) (+ count 1)))\n          (else\n           (loop (cdr S) (+\
    \ count 0))))))\n", "  (count-bored? S '(. ? !)))\n", "  (cond\n    [(equal? (first\
    \ (first S)) 'I) (+ 1 (is_bored (rest S)))]\n    [else 0]))\n</code>\nNow, all\
    \ you have to do is count all the boredoms in your list of sentences, and print\
    \ out the answer. Remember that you're not printing the boredoms in order from\
    \ lowest to highest. Instead, you'll have to maintain two variables - one to keep\
    \ track of the current number of boredoms seen, and one to keep track of the number\
    \ of sentences in your list. You can then just add (is_bored (first s)) to your\
    \ boredom count.\nEDIT: Here's a way to do this with the \"functional\" programming\
    \ style you're familiar with:\n<code>", "  (cond [(= (string-length S) 0) 0]\n\
    \        [(string-equal? \"I\" (first S)) 1]\n        [(string-equal? \"bore\"\
    \ (first S)) 1]\n        [else 0]))\n", "  (let loop ((boreds 0))\n    (cond ((string=?\
    \ \"I.\" S) boreds)\n          ((string=? \"!.\" S) boreds)\n          ((string=?\
    \ \"?.\" S) boreds)\n          (else (loop (+ boreds (length (string-match \"\
    I.*\" S)))))))\n", "  (cond [(string-match-p #rx\"^I\" S) 0]\n        [else 1]))\n",
  "  (= (first S) \"I\"))\n", "  (let ((i 0) (j 0))\n    (cond\n      [(empty? S)\
    \ #t]\n      [(char=? (first S) 'I) 1]\n      [(char=? (first S) '!) 1]\n    \
    \  [(char=? (first S) '.') 1]\n      [(char=? (first S) '?') 1]\n      [(char=?\
    \ (first S) '!') 1]\n      [else 0]\n      (set! i (+ i 1))\n      (set! j (+\
    \ j 1))\n      (cond [(or (char=? (first S) '!') (char=? (first S) '?') (char=?\
    \ (first S) '.')) (set! i (+ i 1))]\n            [(char=? (first S) '.') (set!\
    \ i (+ i 1))]\n            [(char=? (first S) '?') (set! i (+ i 1))]\n       \
    \     [(char=? (first S) '!') (set! i (+ i 1))]\n            [else (set! i (+\
    \ i 1))]))))\n", "  (match S\n    (((\"I\") . 0) ((\".\") . 0))\n    (((\"I\"\
    ) . 1) ((\".\") . 1))\n    (((\"I\") . 2) ((\".\") . 2))\n    (((\"I\") . 3) ((\"\
    .\") . 3))\n    (((\"I\") . 4) ((\".\") . 4))\n    (((\"I\") . 5) ((\".\") . 5))\n\
    \    (((\"I\") . 6) ((\".\") . 6))\n    (((\"I\") . 7) ((\".\") . 7))\n    (((\"\
    I\") . 8) ((\".\") . 8))\n    (((\"I\") . 9) ((\".\") . 9))\n    (((\"I\") . 10)\
    \ ((\".\") . 10))\n    (((\"I\") . 11) ((\".\") . 11))\n    (((\"I\") . 12) (\"\
    !\"))\n    (((\"I\") . 13) (\"!\"))\n    (((\"I\") . 14) (\"!\"))\n    (((\"I\"\
    ) . 15) (\"!\"))\n    (((\"I\") . 16) (\"!\"))\n    (((\"I\") . 17) (\"!\"))\n\
    \    (((\"I\") . 18) (\"!\"))\n    (((\"I\") . 19) (\"!\"))\n    (((\"I\") . 20)\
    \ (\"!\"))\n    (((\"I\") . 21) (\"!\"))\n    (((\"I\") . 22) (\"!\"))\n    (((\"\
    I\") . 23) (\"!\"))\n    (((\"I\") . 24) (\"!\"))\n    (((\"I\") . 25) (\"!\"\
    ))\n    (((\"I\") . 26) (\"!\"))\n    (((\"I\") . 27) (\"!\"))\n    (((\"I\")\
    \ . 28) (\"!\"))\n    (((\"I\") . 29) (\"!\"))\n    (((\"I\") . 30) (\"!\"))\n\
    \    (((\"I\") . 31) (\"!\"))\n    (((\"I\") . 32) (\"!\"))\n    (((\"I\") . 33)\
    \ (\"!\"))\n    (((\"I\") . 34) (\"!\"))\n    (((\"I\") . 35) (\"!\"))\n    (((\"\
    I\") . 36) (\"!\"))\n    (((\"I\") . 37) (\"!\"))\n    (((\"I\") . 38) (\"!\"\
    ))\n    (((\"I\") . 39) (\"!\"))\n    (((\"I\") . 40) (\"!\"))\n    (((\"I\")\
    \ . 41) (\"!\"))\n    (((\"I\") . 42) (\"!\"))\n    (((\"I\") . 43) (\"!\"))\n\
    \    (((\"I\") . 44) (\"", "  (cond\n    ((or (char-set S '?) (char-set S '.'))\
    \ (= (length S) 5))\n    ((char= S \"I\") (+ 1 (count-boredom S)))))\n", "  (cond\n\
    \    [(empty? S) 0]\n    [(= (first S) \"I\") (+ 1 (is_bored (rest S)))]\n   \
    \ [else (is_bored (rest S))]))\n", "  (= (length (string-match #rx\"^I\" S)) (length\
    \ (string-match #rx\"\\.\\.?\" S))))\n", "  (let loop ((S S)\n             (count\
    \ 0))\n    (if (null? S)\n        count\n        (loop (cdr (cdr S))\n       \
    \       (+ 1 (if (string=? S \"I\") count 0))))))\n", "  (let* ((sentences (tokenize-sentence\
    \ S))\n         (bored-sentences (filter boredp sentences))\n         (bored-counts\
    \ (map (lambda (S) (count S \"I\"))\n                              bored-sentences)))\n\
    \    (length (filter boredp sentences)) ; ignore the empty sentence at the start\n\
    \    (length bored-sentences) ; ignore the empty sentences at the end\n    (length\
    \ bored-counts)))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you so much! I'm\
    \ still learning recursion, and I was wondering how you would go about creating\
    \ functions that use recursion. I've tried several different ways, but I keep\
    \ getting stuck on how to use recursion.\n<|/ c |>\n<| c |>\n: it's hard to know\
    \ where to start when you're still trying to learn recursion; I'd recommend first\
    \ reading up on it. I'd also recommend taking a look at [the Racket docs](https://docs.racket-lang.org/reference/recursion.html).\
    \ If you get stuck, I think it would be best to post a new question, and to try\
    \ and give an example of what you're trying to do. As is, it looks like you have\
    \ some good ideas of how to solve the problem (just not 100% sure about recursion!).\n\
    <|/ c |>\n<| a |>\n<code>", "  (let ((count 0)\n        (index 0))\n    (loop\
    \ while (subseq S index) index\n      (if (and (subseq S index) \"I\" subseq S\
    \ index \".\" subseq S index \"!?\")\n          (set! count (add1 count))\n  \
    \      (set! index (add1 index))\n        )))\n  count)\n", "  (= (length S)\n\
    \     (length (substring S 0 (string->length (first S)) #\\.)))\n  S)\n", "  (define\
    \ (count-bored S)\n    (let loop ((n 0)\n               (S S))\n      (cond ((=\
    \ n 0)\n             (string-match (string-ref S 0) \"^I\"))\n            (else\n\
    \             (string-append\n               (loop (+ n 1)\n                 \
    \    (string-rest (string-ref S 1)))\n               (if (string-match (string-ref\
    \ S 1) \".\") \".\")\n               (if (string-match (string-ref S 1) \"?\"\
    ) \"?\")\n               (if (string-match (string-ref S 1) \"!\") \"!\")))))\n\
    \    (count-bored S)))\n", "  (match (regexp-match #rx (string \"^I.*[.!?]\"))\n\
    \    [(string '()) (match-str S 0)]\n    [else (match-str S 1)]))\n", "  (cond\n\
    \    ((string-match \"^I\" S) (+ 1 (length S)))\n    ((string-match \"\\.|?|!\"\
    \ S) 0)\n    (else (display \"Unrecognized sentence\"))))\n", "  (define (helper\
    \ S index)\n    (if (equal? (substring S index 1) \"I\")\n        (if (equal?\
    \ (substring S index 2) \".\")\n            (if (equal? (substring S index 3)\
    \ \".\")\n                (if (equal? (substring S index 4) \".\")\n         \
    \           (if (equal? (substring S index 5) \".\")\n                       \
    \ (if (equal? (substring S index 6) \".\")\n                            (if (equal?\
    \ (substring S index 7) \".\")\n                                (if (equal? (substring\
    \ S index 8) \".\")\n                                    (if (equal? (substring\
    \ S index 9) \".\")\n                                        (if (equal? (substring\
    \ S index 10) \".\")\n                                            (if (equal?\
    \ (substring S index 11) \".\")\n                                            \
    \    (if (equal? (substring S index 12) \".\")\n                             \
    \                       (if (equal? (substring S index 13) \".\")\n          \
    \                                              (if (equal? (substring S index\
    \ 14) \".\")\n                                                            (if\
    \ (equal? (substring S index 15) \".\")\n                                    \
    \                            (if (equal? (substring S index 16) \".\")\n     \
    \                                                               (if (equal? (substring\
    \ S index 17) \".\")\n                                                       \
    \                 (if (equal? (substring S index 18) \".\")\n                \
    \                                                            (if (equal? (substring\
    \ S index 19) \".\")\n                                                       \
    \                         (if (equal? (substring S index 20) \".\")\n        \
    \                                                                            (if\
    \ (equal? (substring S index 21) \".\")\n                                    \
    \                                                    (if (equal? (substring S\
    \ index 22) \".\")\n                                                         \
    \                                   (if (equal? (substring S index 23) \".\")\n\
    \                                                                            \
    \                    (if (equal? (substring S index 24) \".\")\n             \
    \                                                                            \
    \           (if (equal? (substring S index 25) \".\")\n                      \
    \                                                                            \
    \      (if (equal? (substring S index 26) \".\")\n                           \
    \                                                                            \
    \     (if (equal? (substring S index 27) \".\")\n                            \
    \                                                                            \
    \        (if (equal? (substring S index 28) \".\")\n                         \
    \                                                                            \
    \               (if (equal? (substring S index 29) \".\")\n                  \
    \                                                                            \
    \                          (if (equal? (substring S index 30) \".\")\n       \
    \                                                                            \
    \                                         (if (equal? (substring S index 31) \"\
    .\")\n                                                                       \
    \                                                         (if (equal? (substring\
    \ S index 32) \".\")\n                                                       \
    \                                                                            \
    \ (if (equal? (substring S index 33) \".\")\n                                \
    \                                                                            \
    \                            (if (equal? (substring S index 34) \".\")\n     \
    \                                                                            \
    \                                                           (if (equal? (substring\
    \ S index 35) \".\")\n                                                       \
    \                                                                            \
    \             (if (equal? (substring S index 36) ", "  (and (or (null? S)\n  \
    \         (char-equal #\\? (first S)))\n       (char-equal #\\. (rest S))))\n",
  "  (cond\n    [(equal? (first S) 'I) (+ 1 (is_bored (rest S)))]\n    [else 0]))\n",
  "  (cond\n    [(equal? (first S) \"I\") 1])"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
