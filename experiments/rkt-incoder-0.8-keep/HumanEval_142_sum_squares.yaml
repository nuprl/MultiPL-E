name: HumanEval_142_sum_squares
language: rkt
prompt: "#lang racket\n\n;; \"\n;; This function will take a list of integers. For\
  \ all entries in the list, the function shall square the integer entry if its index\
  \ is a \n;; multiple of 3 and will cube the integer entry if its index is a multiple\
  \ of 4 and not a multiple of 3. The function will not \n;; change the entries in\
  \ the list whose indexes are not a multiple of 3 or 4. The function shall then return\
  \ the sum of all entries. \n;; Examples:\n;; For lst = [1,2,3] the output should\
  \ be 6\n;; For lst = []  the output should be 0\n;; For lst = [-1,-5,2,-1,-5]  the\
  \ output should be -126\n(define (sum_squares lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n\
  \    (check-equal? (candidate (list 1 2 3)) 6)\n    (check-equal? (candidate (list\
  \ 1 4 9)) 14)\n    (check-equal? (candidate (list )) 0)\n    (check-equal? (candidate\
  \ (list 1 1 1 1 1 1 1 1 1)) 9)\n    (check-equal? (candidate (list -1 -1 -1 -1 -1\
  \ -1 -1 -1 -1)) -3)\n    (check-equal? (candidate (list 0)) 0)\n    (check-equal?\
  \ (candidate (list -1 -5 2 -1 -5)) -126)\n    (check-equal? (candidate (list -56\
  \ -99 1 0 -2)) 3030)\n    (check-equal? (candidate (list -1 0 0 0 0 0 0 0 -1)) 0)\n\
  \    (check-equal? (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35\
  \ 37)) -14196)\n    (check-equal? (candidate (list -1 -3 17 -1 -15 13 -1 14 -14\
  \ -12 -5 14 -14 6 13 11 16 16 4 10)) -1448)\n))\n\n(test-humaneval)"
completions: ["  (if (empty? lst)\n      0\n      (+ (* lst (car lst)) (sum-squares\
    \ (cdr lst))))))\n", "  (let loop ((lst lst) (acc 0))\n    (if (null? lst)\n \
    \       acc\n        (loop (rest lst) (+ acc (* lst (* lst lst)))))))\n", "  (cond\n\
    \    [(empty? lst) 0]\n    [(even? (first lst)) (* 3 (first lst))] \n    [(even?\
    \ (rest lst)) (* 4 (first lst)) (sum-squares (rest lst))]\n    [else (sum-squares\
    \ (rest lst))]))\n</code>\n<|/ q tags=scheme,racket |>\n<| c |>\nThis sounds like\
    \ a homework question. What have you tried? Do you know where you're failing?\
    \ What don't you understand? Where are you stuck? SO isn't a teaching resource\
    \ - what have you done to solve the problem?\n<|/ c |>\n<| c |>\nHi, I'm new to\
    \ Racket. I'm learning by myself and I'm stuck on this exercise - that's why I'm\
    \ asking for some help. I have been thinking about how to solve it but I couldn't\
    \ find anything helpful. I think my code will work if I understand how to solve\
    \ this particular exercise. I just can't figure out how to go through the list\
    \ once and check all the numbers. I'm a beginner in Scheme and I just started\
    \ learning it, so I would appreciate some guidance on how to go through the list.\n\
    <|/ c |>\n<| c |>\nOK - I take it you know how to use cond, right? So the trick\
    \ is to use it twice. First to check if an element is multiple of 3 and then to\
    \ check if it isn't. That's how you do it. Now how do you *add* to the sum if\
    \ it is? That's just like adding to the sum, but you only want to do it if the\
    \ element isn't a multiple of 3 or the next element is. How do you do that in\
    \ Scheme and Racket? That's what's wrong with your code.\n<|/ c |>\n<| c |>\n\
    I'm sorry but I'm new to Racket and don't understand what do you mean with 'add\
    \ it to the sum'. This is my first exercise and I couldn't find any guides on\
    \ the internet, so I hope somebody can give me a hint or something. If it's not\
    \ the right place to ask this sort of question, please tell me what to do. Thank\
    \ you in advance.\n<|/ c |>\n<| a tags=scheme,racket |>\nYour code has many problems,\
    \ some of which can have easily be solved by looking at a simple example. Here's\
    \ the first problem:\n<code>", "  (cond\n    [(empty? lst) 0]\n    [(= (modulo\
    \ (car lst) 3) 0)\n     (+ (car lst) (sum_squares (cdr lst)))]\n    [(= (modulo\
    \ (car lst) 4) 0)\n     (+ (car lst) (sum_squares (cdr lst)))]\n    [else (+ (*\
    \ car lst) (sum_squares (cdr lst)))]))\n", "  (if (null? lst)\n      0\n     \
    \ (+ (* (car lst) (car lst)) (sum-cubes (cdr lst))))))\n", "  (let loop ((lst\
    \ lst)\n             (result 0))\n    (if (null? lst)\n        result\n      \
    \  (loop (cdr lst)\n              (+ (* car lst) result)))))\n", "  (cond ((empty?\
    \ lst) 0)\n        (else \n         (+ (if (even? (car lst)) (* car lst) (* car\
    \ lst)) \n            (sum-cubes (cdr lst)))))) \n              ", "  (cond\n\
    \    [(empty? lst) 0]\n    [(cons? lst) (+ (square (first (first lst))) \n   \
    \                  (sum-squares (rest lst)))]\n    [else (error 'sum-squares \"\
    Not a list\")]))\n", "  (if (empty? lst)\n    0\n    (+ \n      (if (even? (car\
    \ lst)) (car (cdr lst)) (cdr (cdr lst)))\n      (sum-cubes (cdr lst))))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(even? (car lst)) (+ (* (car lst) (car lst))\
    \ (sum-squares (cdr lst)))]\n    [else (+ (* 3 (car lst)) (sum-squares (cdr lst)))]))\n",
  "    (cond\n        ((null? lst) 0)\n        ((= (remainder car lst) 0) (+ (* car\
    \ lst) (sum-cube lst)))\n        (else (sum-cube lst))))\n", "  (cond\n    [(empty?\
    \ lst) (sum (map square lst))]\n    [(= (modulo lst 3) 0) (sum (map cube lst))]\n\
    \    [else (sum (map square lst))]))\n", "  (let ((sum 0))\n    (for-each (lambda\
    \ (x) (if (or (modulo x 3) (modulo x 4)) (+ x (* x x)) (+ x (* x x)))) (list lst))\n\
    \    sum))", "  (cond\n    [(empty? lst) 0]\n    [(modulo lst 3)\n     (+ lst\
    \ (* lst (* lst lst)))]\n    [else (* lst (* lst lst))]))\n", "  (cond\n    ((empty?\
    \ lst)\n     0)\n    ((and (even? (car lst))\n         (even? (car lst))\n   \
    \      (even? (car lst))) \n     (+ (* 1 (car lst))\n        (sum_squares (cdr\
    \ lst)))\n    ((and (even? (car lst))\n         (odd? (car lst))\n         (even?\
    \ (car lst))) \n     (+ (* 1 (car lst))\n        (sum_squares (cdr lst)))\n  \
    \  ((and (even? (car lst))\n         (odd? (car lst))\n         (odd? (car lst)))\n\
    \     (+ (* 1 (car lst))\n        (sum_squares (cdr lst)))\n    ((and (odd? (car\
    \ lst))\n         (even? (car lst))\n         (even? (car lst))) \n     (+ (*\
    \ 1 (car lst))\n        (sum_squares (cdr lst)))\n    ((and (odd? (car lst))\n\
    \         (odd? (car lst))\n         (odd? (car lst)))\n     (+ (* 1 (car lst))\n\
    \        (sum_squares (cdr lst)))\n    ((and (even? (car lst))\n         (odd?\
    \ (car lst))\n         (even? (car lst))) \n     (+ (* 1 (car lst))\n        (sum_squares\
    \ (cdr lst)))\n    ((and (even? (car lst))\n         (odd? (car lst))\n      \
    \   (odd? (car lst)))\n     (+ (* 1 (car lst))\n        (sum_squares (cdr lst)))\n\
    \    ((and (odd? (car lst))\n         (even? (car lst))\n         (even? (car\
    \ lst))) \n     (+ (* 1 (car lst))\n        (sum_squares (cdr lst)))\n    ((and\
    \ (odd? (car lst))\n         (odd? (car lst))\n         (odd? (car lst)))\n  \
    \   (+ (* 1 (car lst))\n        (sum_squares (cdr lst))))))\n", "  (let loop ((lst\
    \ lst) (sum 0))\n    (if (empty? lst)\n      sum\n      (loop (cdr lst) (+ sum\
    \ ((modulo lst 3) 4)))))\n", "  (cond\n    [(null? lst) 0]\n    [(even? (car lst))\
    \ (+ (car lst) (sum_squares (cdr lst)))]\n    [(odd? (car lst)) (+ (sum_squares\
    \ (cdr lst)) (* 3 (car lst)))]\n    [else (+ (sum_squares (cdr lst)) (* 4 (car\
    \ lst)))]))\n", "  \n  (define (sum lst acc)\n    (if (null? lst) acc\n      (sum\
    \ (cdr lst) (+ acc lst)))\n  )\n  (sum\n   (map\n    (lambda (i)\n      (if (zero?\
    \ i) '()\n        (if (mod i 3) '(* i i)\n          '(* i i))))\n    lst\n   \
    \ 0)\n  )\n)\n", "  (let loop ((lst lst)\n             (sum 0))\n    (cond\n \
    \     [(empty? lst) (sum 0)]\n      [else (loop (rest lst) (+ (car lst) sum))])))\n",
  "  (cond\n    [(null? lst) 0]\n    [(= (mod lst 3) 0)\n     (+ (* lst lst) (* lst\
    \ lst))] \n    [else (+ (* lst lst) (* lst lst))]))\n</code>\n<|/ q tags=racket,lisp\
    \ |>\n<| c |>\nThis question is better suited to [Code Review](https://codereview.stackexchange.com)\
    \ than StackOverflow because it doesn't provide an example of what you've already\
    \ tried.\n<|/ c |>\n<| c |>\nI didn't really try anything because I did not know\
    \ where to start. I was thinking of using a list to store the numbers, and then\
    \ a function that goes through the list to check if the index is multiple of 3\
    \ and 4, and add the numbers in that index to a variable that i will add later\
    \ on.\n<|/ c |>\n<| c |>\nI wouldn't say it's better suited there because it isn't\
    \ a specific programming problem. It's more of a \"how would you do this\" type\
    \ of question.\n<|/ c |>\n<| c |>\nBut what about \"how would I do this in Racket\"\
    ? The idea is to learn how to solve this kind of problem using either Racket or\
    \ Common Lisp.\n<|/ c |>\n<| c |>\nI wasn't suggesting that they post this on\
    \ CR. The question isn't a very specific programming problem, but it's not a duplicate.\n\
    <|/ c |>\n<| a tags=racket,lisp |>\nOne approach would be to write a function\
    \ that generates all pairs of 3 numbers that you can then sum:\n<code>", "  (if\
    \ (empty? lst)\n      0\n      (+ (* \n          (if (even? (car lst))\n     \
    \         (* (car lst) (car lst))\n              (* 4 (car lst))\n           \
    \   )\n          (sum_squares (cdr lst))\n          )\n       )\n     )\n  )\n",
  "  (cond\n    [(empty? lst) 0]\n    [(empty? (rest lst)) 0]\n    [(mod-3-or-not?\
    \ (car lst) lst) (car (square (rest lst)))]\n    [else (+ (car lst) (sum-squares\
    \ (rest lst)))]))\n", "  (if (null? lst)\n      0\n      (+ \n       (* \n   \
    \     (if (= (rem (length lst) 3) 0) (* 2 (first lst))) \n        (if (= (rem\
    \ (length lst) 4) 0) (* 4 (first lst))) \n        lst) \n       sum-squares (rest\
    \ lst))))\n", "  (if (null? lst)\n      0\n      (+ (* lst (square (mod lst 3)))\
    \ (* lst (cube (mod lst 4))))))\n", "  (if (empty? lst)\n      0\n      (+ (*\
    \ lst (first lst)) (sum-squares (rest lst))))))\n", "  (define (cube x)\n    (*\
    \ x x))\n\n  (define (mod x y z)\n    (cond\n      [(= x y) (mod x y z)]\n   \
    \   [(= x z) (mod x y z)]\n      [(= y z) (mod x y z)]\n      [else 0]))\n\n \
    \ (define (add x y z)\n    (cond\n      [(= x y) (+ x y z)]\n      [(= x z) (+\
    \ x y z)]\n      [(= y z) (+ x y z)]\n      [else 0]))\n\n  (cond\n    [(empty?\
    \ lst) 0]\n    [(pair? lst) (add (first lst) (add* (second lst) (mod 3 lst)) (mod*\
    \ (third lst) (mod 4 lst))) ]\n    [else 0]))\n", "  (cond [(empty? lst) 0]\n\
    \        [(even? (length lst)) (+ (car lst) (sum-squares (cdr lst)))]\n      \
    \  [else      (+ (* 3 (car lst)) (sum-squares (cdr lst)))]))\n", "  (define (helper-procedure\
    \ lst i)\n    (if (= (modulo i 3) 0)\n      (* lst (* lst (* lst i)))\n      (*\
    \ lst (* lst i))))\n  (+ (reduce helper-procedure lst 0))\n)\n", "  (if (or (null?\
    \ lst) (= 0 (length lst)))\n    0\n    (+ (* (car lst) (car lst))\n       (sum-cubes\
    \ (cdr lst)))))\n", "  (let loop ((lst lst) (acc 0))\n    (cond\n      [(empty?\
    \ lst) acc]\n      [(even? (car lst)) (loop (cdr lst) (+ acc (* (car lst) (car\
    \ lst))))]\n      [else (loop (cdr lst) (+ acc (* (car lst) (car lst))))])))\n",
  "  (define (test n m)\n    (if (= (modulo n m) 0)\n        1\n        0))\n  (if\
    \ (null? (cdr lst))\n      0\n      (+ (* (car lst) (car lst)) (sum-squares\n\
    \                                       (cdr lst)\n                          \
    \             (test (car lst) 3)\n                                       (test\
    \ (car lst) 4)))) )", '  (sum-squares lst 0))', "  (define (helper lst idx acc)\n\
    \    (cond\n      [(zero? idx) (add1 acc)]\n      [(modulo idx 3) (helper (sub1\
    \ lst) idx acc (* idx idx) (* idx idx))]\n      [(modulo idx 4) (helper (sub1\
    \ lst) idx acc (* idx idx) (* idx idx))]\n      [else (helper (sub1 lst) idx (*\
    \ idx idx))]))\n  (helper lst 0 (add1 0)))\n\n#lang racket\n", "  (define (inner-function\
    \ current-index lst)\n    (cond ((= current-index 0) (sum lst))\n          ((=\
    \ current-index 3) (* current-index current-index))\n          (else (inner-function\
    \ current-index (rest lst)))))\n  (define (inner-function current-index lst)\n\
    \    (cond ((= current-index 0) (sum lst))\n          ((= current-index 3) (*\
    \ current-index current-index))\n          (else (inner-function current-index\
    \ (rest lst)))))\n  (inner-function 0 (reverse lst)))\n", "  (if (empty? lst)\n\
    \      0\n      (+ (square (car lst)) (sum-squares (cdr lst)))))\n", "  (cond\n\
    \    [(empty? lst) 0]\n    [(= (modulo (car lst) 3) 0) (cdr (map (lambda (x) (*\
    \ x x)) (rest lst)))]\n    [else (+ (car lst) (sum_squares (cdr lst)))]))\n</code>\n\
    <|/ a |>\n<| a tags=racket,scheme |>\nThis is not an answer, but an improvement\
    \ on the already accepted answer by Matthieu M. Medina:\n<code>", "  (cond [(empty?\
    \ lst)\n         0]\n        [(empty? (rest lst))\n         (car lst)]\n     \
    \   [else\n         (+ (if (modulo?\n                  (+ (car lst)\n        \
    \             (car lst)) \n                  3)\n             (+ (car lst)\n \
    \             (car lst))\n             (if (modulo?\n                  (+ (car\
    \ lst)\n                     (car lst)) \n                  4)\n             \
    \ (+ (car lst)\n              (car lst))\n             (+ 0 (car lst)))))\n  \
    \       (sum_squares (rest lst))]))\n", "  (cond\n    [(empty? lst) 0]\n    [(=\
    \ (modulo lst 3) 0)(+ lst (* lst lst))]\n    [(= (modulo lst 4) 0)(+ lst (* lst\
    \ lst))]\n    [else (+ lst (* lst lst))]))\n", "  (if (null? lst) 0 \n      (if\
    \ (= (mod (car lst) 3) 0) (+ lst (* lst (car lst))) \n          (if (= (mod (car\
    \ lst) 4) 0) (+ lst (* lst (* lst (car lst)))) \n              (+ lst (* lst (*\
    \ lst (car lst)))))))\n", "  (define (square n)\n    (* n n))\n  (define (cube\
    \ n)\n    (* n n n))\n  (define (make-index-list lst)\n    (map (lambda (n) (if\
    \ (zero? (modulo n 3) 0) (if (zero? (modulo n 4) 0) n n)) lst))\n  (define (squares-indices\
    \ (lst)\n    (if (null? lst)\n        0\n        (+ \n          (map (lambda (n)\
    \ (if (zero? (modulo n 3) 0) (if (zero? (modulo n 4) 0) square cube)) lst)\n \
    \         squares-indices (rest lst)))))\n  (sum-squares (make-index-list lst)))\n",
  "  (cond\n    ((empty? lst) 0)\n    ((even? (modulo lst (- 3 4)))\n     (+ lst (*\
    \ lst lst)))\n    ((odd? (modulo lst (- 3 4)))\n     (* lst lst)\n    )\n    (else\n\
    \     (sum_squares(remove lst [#t #f #t #t])) \n  )\n)\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [else (+ (* (car lst) (car lst)) \n           (sum-cubes \n   \
    \         (append (list 'car (cdr lst)) \n                    (sum-squares (cons\
    \ 'cdr (cdr lst))))))]))\n", "  (if (empty? lst)\n    0\n    (+ (square (car lst))\
    \ (sum_squares (cdr lst)))))\n", "  (let loop ((sum (list 0)) (r (list lst)))\n\
    \    (cond ((null? r) sum)\n          ((= (car r) (quotient (car r) 3)) \n   \
    \        (loop (add1 sum) (cdr r)))\n          ((= (car r) (quotient (car r) 4))\
    \ \n           (loop (add1 sum) (cdr r)))\n          (else (loop (add1 sum) (cdr\
    \ r)))))\n  ", "  (let loop ((lst lst)\n             (sum (lambda (x) (* x x)))\
    \ \n             (cnt 0))\n    (cond\n      [(null? lst) sum]\n      [(= cnt 4)\
    \ sum]\n      [(= cnt 3) (+ sum (car lst))(loop (cdr lst) sum 1)]\n      [else\n\
    \       (loop (cddr lst) (+ sum (car lst))(+ cnt 1) 2)])))\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [(and (even? (modulo lst (- 3 (length lst)))) (even? (modulo (first\
    \ lst) (- 4 (length lst))))) (+ (* lst (first lst)) (sum_squares (rest lst)))]\n\
    \    [else (sum_squares (rest lst))]))", "  (if (empty? lst)\n      0\n      (+\
    \ (* lst (square (car lst))) (sum-squares (cdr lst))))))\n", "  (define (sum lst)\n\
    \    (cond ((null? lst) 0)\n          ((even? length) (+ (car lst) (car lst)))\n\
    \          ((odd? length) (+ (car lst) (* 3 car lst)))\n          (else (sum (cdr\
    \ lst)))))\n\n  (define (sq lst)\n    (cond ((null? lst) 0)\n          ((even?\
    \ length) (+ (car lst) (* car lst)))\n          ((odd? length) (+ (car lst) (*\
    \ 4 car lst)))\n          (else (sq (cdr lst)))))\n\n  (define (cub lst)\n   \
    \ (cond ((null? lst) 0)\n          ((even? length) (+ (car lst) (* car lst)))\n\
    \          ((odd? length) (+ (car lst) (* 4 car lst)))\n          (else (cub (cdr\
    \ lst)))))\n\n  (cond ((null? lst) 0)\n        ((odd? length) (+ (car lst) (*\
    \ 2 car lst)))\n        (else (sum (lst))))\n  (sq (lst))\n  (cub (lst))\n)\n\n\
    #lang racket\n", "  (cond\n    [(empty? lst) 0]\n    [(not (even? (first lst)))\
    \ (* (first lst) (first lst))])\n    [else (+ (sum-squares (rest lst)) (sum-squares\
    \ (rest lst)))]))\n", "  (define (squares-mod n lst)\n    (cond\n      [(zero?\
    \ n) 0]\n      [else\n       (cond\n         [(even? (modulo n 2)) (* n (squares-mod\
    \ (n-1) lst))]\n         [(even? (modulo n 4)) (* n (* n lst))]\n         [else\
    \ (* n (* n (squares-mod (n-1) lst)))])]))\n  (define (cubes-mod n lst)\n    (cond\n\
    \      [(zero? n) 0]\n      [else\n       (cond\n         [(even? (modulo n 2))\
    \ (* n (cubes-mod (n-1) lst))]\n         [(even? (modulo n 4)) (* n (* n lst))]\n\
    \         [else (* n (* n (cubes-mod (n-1) lst)))])]))\n  (sum-reduce lst 0 squares-mod\
    \ cubes-mod)\n  )\n", "  (if (empty? lst)\n      '(0)\n      (if (even? (car lst))\n\
    \          (+ (square (car lst)) (sum_squares (cdr lst)))\n          (+ (square\
    \ (car lst)) (sum_squares (cdr lst))))))\n", "  (if (null? lst)\n      0\n   \
    \   (+ (* (car lst) (car lst))\n         (sum-cubes (cdr lst)))))\n", "  (if (null?\
    \ lst)\n      0\n      (+ (square (car lst)) (sum-squares(cdr lst)))))", "  \n\
    \  (cond\n    [(empty? lst) 0]\n    [(= (mod (car lst) 3) 0)\n     (+ 0 (square\
    \ (car lst)))]\n    [(= (mod (car lst) 4) 0)\n     (+ 0 (cube (car lst)))]\n \
    \   [else\n     (+ (sum-squares (cdr lst))\n       (sum-squares (cdr lst)))]))",
  "  (sum-helper (lst) 0 0))\n", "  (if (null? lst)\n      0\n      (let ((sum (+\
    \ (* (first lst) (* (mod lst 3) 2)) (* (mod lst 4) 2))))\n        (sum (cdr lst))))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(even? (cdr lst)) (+ 2 (square (car lst)))]\n\
    \    [else (+ (cube(car lst))\n            (sum-squares (cdr lst)))]))\n", " \
    \ (if (empty? lst)\n      0\n      (+ (* 2 (car lst))\n         (sum-cubes (cdr\
    \ lst)))))\n", "  (define (square i)\n    (* i i))\n  (define (cube i)\n    (*\
    \ i i *i)\n  (define (mod i)\n    (remainder i 3))\n  (define (mod3 i)\n    (remainder\
    \ i 4))\n  (define (mod4 i)\n    (remainder i 4))\n  (define (mod5 i)\n    (remainder\
    \ i 5))\n  (define (mod6 i)\n    (remainder i 6))\n  (define (mod7 i)\n    (remainder\
    \ i 7))\n  (define (mod8 i)\n    (remainder i 8))\n  (define (mod9 i)\n    (remainder\
    \ i 9))\n  (define (mod10 i)\n    (remainder i 10))\n  (define (mod11 i)\n   \
    \ (remainder i 11))\n  (define (mod12 i)\n    (remainder i 12))\n  (define (mod13\
    \ i)\n    (remainder i 13))\n  (define (mod14 i)\n    (remainder i 14))\n  (define\
    \ (mod15 i)\n    (remainder i 15))\n  (define (mod16 i)\n    (remainder i 16))\n\
    \  (define (mod17 i)\n    (remainder i 17))\n  (define (mod18 i)\n    (remainder\
    \ i 18))\n  (define (mod19 i)\n    (remainder i 19))\n  (define (mod20 i)\n  \
    \  (remainder i 20))\n  (define (mod21 i)\n    (remainder i 21))\n  (define (mod22\
    \ i)\n    (remainder i 22))\n  (define (mod23 i)\n    (remainder i 23))\n  (define\
    \ (mod24 i)\n    (remainder i 24))\n  (define (mod25 i)\n    (remainder i 25))\n\
    \  (define (mod26 i)\n    (remainder i 26))\n  (define (mod27 i)\n    (remainder\
    \ i 27))\n  (define (mod28 i)\n    (remainder i 28))\n  (define (mod29 i)\n  \
    \  (remainder i 29))\n  (define (mod30 i)\n    (remainder i 30))\n  (define (mod31\
    \ i)\n    (remainder i 31))\n  (define (mod32 i)\n    (remainder i 32))\n  (define\
    \ (mod33 i)\n    (remainder i 33))\n  (define (mod34 i)\n    (remainder i 34))\n\
    \  (define (mod35 i)\n    (remainder i 35))\n  (define (mod36 i)\n    (remainder\
    \ i 36))\n  (define (mod37 i)\n", "  (sum (map square lst \n\t\t\t[((= (car lst)\
    \ 0) #t)\n\t\t\t ((= (car lst) 1) #t)\n\t\t\t ((= (car lst) 2) #t)\n\t\t\t ((=\
    \ (car lst) 3) #f)\n\t\t\t ((= (car lst) 4) #f)\n\t\t\t ((= (car lst) 5) #f)\n\
    \t\t\t ((= (car lst) 6) #f)\n\t\t\t ((= (car lst) 7) #f)\n\t\t\t ((= (car lst)\
    \ 8) #f)\n\t\t\t ((= (car lst) 9) #f)\n\t\t\t ((= (car lst) 10) #f)\n\t\t\t ((=\
    \ (car lst) 11) #f)\n\t\t\t ((= (car lst) 12) #f)\n\t\t\t ((= (car lst) 13) #f)\n\
    \t\t\t ((= (car lst) 14) #f)\n\t\t\t ((= (car lst) 15) #f)\n\t\t\t ((= (car lst)\
    \ 16) #f)\n\t\t\t ((= (car lst) 17) #f)\n\t\t\t ((= (car lst) 18) #f)\n\t\t\t\
    \ ((= (car lst) 19) #f)\n\t\t\t ((= (car lst) 20) #f)\n\t\t\t ((= (car lst) 21)\
    \ #f)\n\t\t\t ((= (car lst) 22) #f)\n\t\t\t ((= (car lst) 23) #f)\n\t\t\t ((=\
    \ (car lst) 24) #f)\n\t\t\t ((= (car lst) 25) #f)\n\t\t\t ((= (car lst) 26) #f)\n\
    \t\t\t ((= (car lst) 27) #f)\n\t\t\t ((= (car lst) 28) #f)\n\t\t\t ((= (car lst)\
    \ 29) #f)\n\t\t\t ((= (car lst) 30) #f)\n\t\t\t ((= (car lst) 31) #f)\n\t\t\t\
    \ ((= (car lst) 32) #f)\n\t\t\t ((= (car lst) 33) #f)\n\t\t\t ((= (car lst) 34)\
    \ #f)\n\t\t\t ((= (car lst) 35) #f)\n\t\t\t ((= (car lst) 36) #f)\n\t\t\t ((=\
    \ (car lst) 37) #f)\n\t\t\t ((= (car lst) 38) #f)\n\t\t\t ((= (car lst) 39) #f)\n\
    \t\t\t ((= (car lst) 40) #f)\n\t\t\t ((= (car lst) 41) #", "  (cond [(null? lst)\
    \ 0]\n        [(zero? idx) (sum-squares lst)]\n        [(even? (modulo-by 3 idx))\
    \ (sum-squares lst)]\n        [(even? (modulo-by 4 idx)) (sum-squares lst)]\n\
    \        [else (+ idx (* idx (idx idx)))]\n       )\n  )\n  \n  ", "  (cond\n\
    \    [(empty? lst) 0]\n    [(empty? (rest lst)) (+ 0 (sum_squares (rest lst)))]\n\
    \    [(even? (first lst))\n     (+ (* 3 (first lst)) (sum_squares (rest lst)))]\n\
    \    [(odd? (first lst))\n     (+ (* 4 (first lst)) (sum_squares (rest lst)))]\n\
    \    [else\n     (sum_squares (rest lst))]))\n", "  (define (square i)\n    (if\
    \ (even? i) (* i i) (* i i))\n  )\n  (define (cube i)\n    (if (even? i) (* i\
    \ i) (* i i) (* i i))\n  )\n  (define (sum-all-entries entries lst)\n    (if (null?\
    \ lst)\n        0\n        (+ 0 (apply + entries)))\n  )\n  (define (cube i)\n\
    \    (if (even? i) (* i i) (* i i) (* i i) (* i i) (* i i))\n  )\n  (define (cub-only\
    \ lst)\n    (apply + lst)\n  )\n  (sum-all-entries \n    (map square lst)\n  \
    \  (map cube lst)\n  )\n  (cub-only lst)\n)\n</cell>\n<code language=dyalog-kernel>",
  "  (if (empty? lst)\n      0\n      (+ (* (car lst) (car lst))\n         (sum-squares\
    \ (cdr lst)))))\n", "    (if (null? lst)\n        0\n        (+ (* (car lst) (car\
    \ lst)) (sum-cube (cons (car lst) (cdr lst))))))\n", "  (if (null? lst)\n    \
    \  0\n      (+ (* (car lst) (car lst))\n         (sum-squares (cdr lst)))))\n",
  "  (if (null? lst)\n      '()\n      (+ (* (square (car lst)) (car lst))\n     \
    \    (* (cube (car lst)) (car lst))\n         (sum_squares (cdr lst))))))\n",
  "  (if (empty? lst)\n      0\n      (+ (* 2 (car lst)) (sum-cube (cdr lst)))))",
  "  (if (null? lst)\n      0\n      (+ (* (car lst) (car lst))\n         (sum_squares\
    \ (cdr lst)))))\n", "  (cond [(empty? lst) empty]\n        [(even? (car lst))\
    \ (+ lst (square lst))]\n        [(odd? (car lst)) (+ lst (cube lst))]\n     \
    \   [else (+ lst (sum_squares lst))]))\n", "  (cond\n    [(empty? lst) 0]\n  \
    \  [(empty? (rest lst)) 0]\n    [else \n     (cond\n       [(= (mod (car lst)\
    \ 3) 0) (+ car lst)]\n       [(= (mod (car lst) 4) 0) (* car lst)]\n       [else\
    \ (sum_squares (cdr lst))]\n       ]\n     )]))\n", "  (cond ((or (null? lst)\
    \ (= (length lst) 0)) (error \"cannot sum up an empty list\"))\n        ((even?\
    \ lst) (+ lst (* (car lst) (car lst)))\n        (odd? lst) (+ lst (* (car lst)\
    \ (car lst))\n                  (* (car lst) (* 4 (car lst))))))\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\n`((even? lst) (+ lst (* (car lst) (car lst)))` should\
    \ probably be `(+ (+ lst (* (car lst) (car lst))) (* (car lst) (* 4 (car lst))))`\n\
    <|/ c |>\n<| c |>\nThis was my first post on stackoverflow. Thank you for your\
    \ help and feedback. Unfortunately I couldn't make it work because of my lack\
    \ of experience with racket.\n<|/ c |>\n<| c |>\nWhat do you mean? I am new with\
    \ racket.\n<|/ c |>\n<| a tags=scheme,racket,lisp |>\nA simple solution would\
    \ be:\n<code>", "  (define (f i j)\n    (if (zero? (modulo i 3)) \n        (if\
    \ (zero? (modulo j 4))\n            (* i j)\n            (* i j))\n        (if\
    \ (zero? (modulo j 3))\n            (* i j)\n            (* i j))\n    ))\n  (let\
    \ loop ((lst lst))\n    (if (null? lst)\n        0\n        (+ (f (first lst)\
    \ (second lst))\n          (loop (rest lst)))))) ", "  (cond\n    [(empty? lst)\
    \ 0]\n    [else (+ (* (car lst) (car lst)) (sum-cubes lst))]))\n", "  (if (null?\
    \ lst)\n      0\n      (+ (squares (car lst))\n         (sum_squares (cdr lst)))))\
    \ \n", "  (define (check_index index) \n    (cond\n      [((mod index 3) = 0)\
    \ index]\n      [((mod index 4) = 0) (* index index)]\n      [else (* index index)]))\n\
    \  (if (null? lst)\n      0\n      (+ (* (check-index 0) (check-index 1)) \n \
    \        (* (check-index 2) (check-index 3)) \n         (* (check-index 4) (check-index\
    \ 5)))))\n</code>\n<|/ q tags=racket,scheme |>\n<| c |>\nYou should take a look\
    \ at `map` and `filter`. I think they will help you get your program working.\n\
    <|/ c |>\n<| c |>\nThis seems like homework so I suggest you try it yourself first.\
    \ Do you know how to do an `if`? Do you know how to `define`? Do you know how\
    \ to `cond`? Do you know how to `null?`? Do you know how to `add`? Do you know\
    \ how to `+`? Do you know how to `(*)`? Do you know how to `(+)`?\n<|/ c |>\n\
    <| c |>\nThe only thing I haven't done is implement an `add` function. It's homework\
    \ so I'm not asking for a solution, just for someone to help me get started and\
    \ show me what to do.\n<|/ c |>\n<| c |>\nSo how do you implement add? Do you\
    \ know how to define it? Do you know how to call it? Do you know how to implement\
    \ `+` ? Do you know how to implement `*`? Do you know how to call `+`? Do you\
    \ know how to call `*`?\n<|/ c |>\n<| c |>\nI've done all my other functions.\n\
    <|/ c |>\n<| a dscore=0 |>\nA couple problems:\n\nWhen you call check-index, you\
    \ need to call it with an integer argument. As written, check-index only works\
    \ with vectors and numbers.\nThe second problem is that you have the wrong conditions.\
    \ If the index is 0, you just return the original index.\nThe third problem is\
    \ that you have the wrong test in the second condition. You want to test for multiples\
    \ of 3 or 4.\nThe fourth problem is that you test the wrong variable. While you\
    \ call check_index, you need to test the index argument, not the original index.\n\
    The fifth problem is that you return the wrong value.\n\nHere's a fix:\n<code>",
  "  (if (or (empty? lst) (null? lst))\n      '()\n      (let ([square 0 (cube 0)\n\
    \             squares (list)]\n             ;; This for loop will perform the\
    \ squaring and cubing process for all the indexes in lst\n            (for/list\
    \ ([i (in-range (length lst))]\n                       [j (in-range (length lst))]\n\
    \                       [k (in-range (length lst))])\n               (when (even?\
    \ j) ; Since j will be a multiple of 3 \n                 (set! square (* square\
    \ lst))\n                 (set! squares (cons square squares)))\n            \
    \   (when (even? k)\n                 (set! cube (* cube lst))\n             \
    \    (set! squares (cons cube squares)))\n               ;; The sum of the squares\n\
    \               (set! squares (apply + squares)))\n          ;; The total sum\n\
    \          (apply + squares))))\n", "  (if (empty? lst) \n      (error \"The given\
    \ list must not be empty\")\n      (if (empty? (cdr lst))\n          (+ (car lst)\
    \ (car lst))\n          (if (and (not (even? (car lst))) (even? (car lst)))\n\
    \              (+ (* (car lst) (car lst)) (sum_squares (cdr lst)))\n         \
    \     (if (and (not (odd? (car lst))) (odd? (car lst)))\n                  (+\
    \ (* (car lst) (car lst)) (sum_squares (cdr lst)))\n                  (+ (* (car\
    \ lst) (car lst)) (sum_squares (cdr lst))))))))\n", "  (if (empty? lst)\n    \
    \  0\n      (+ (* lst (square (car lst)))\n         (sum-cube (cdr lst)))))\n",
  "  (cond\n    [(empty? lst)\n      0]\n    [else\n      (let\n        ((temp-lst\
    \ (map #(if (even? %) (* (car %) (car %)) (* % (car %))) lst)))\n        (cond\n\
    \          [(empty? temp-lst)\n            0]\n          [(even? (length temp-lst))\
    \ \n            (+ (first temp-lst) (sum-squares (rest temp-lst)))]\n        \
    \  [(odd? (length temp-lst))\n            (+ (sum-squares (first temp-lst)) (sum-squares\
    \ (rest temp-lst)))]\n          [else\n            (+ (sum-squares (first temp-lst))\
    \ (sum-squares (rest temp-lst)))]))]))\n", "  (define (square n)\n    (* n n))\n\
    \  (define (cube n)\n    (* n n n))\n  (define (filter lst func)\n    (if (null?\
    \ lst)\n        0\n        (if (func (car lst))\n            (+ (filter (cdr lst)\
    \ func) \n               ((cube (square (car lst))) \n                (car lst))\n\
    \            (filter (cdr lst) func))))\n  (filter (reverse lst) (lambda (x) (=\
    \ (modulo x 4) 0)) \n    (filter (reverse lst) (lambda (x) (= (modulo x 3) 0))\
    \ \n      (filter (reverse lst) (lambda (x) (= (modulo x 4) 0)) \n        0)))\n\
    \      ", "  (if (empty? lst)\n      0\n      (+ (if (even? (first lst))\n   \
    \           (* 3 (first lst))\n              (* 4 (first lst)))\n         (sum-squares\
    \ (rest lst)))))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| c |>\nThank\
    \ you so much for your help\n<|/ c |>\n<| c |>\nDon't forget to mark an answer\
    \ as accepted if it solved your problem.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  (define (square-and-cube x)\n    (if (and (integer? x) (even? x))\n        x\n\
    \        (if (even? x)\n            (* x x)\n            (* x (* x x))))\n  (define\
    \ (helper x)\n    (if (zero? x)\n        0\n        (+ (square-and-cube (car x))\
    \ \n          (helper (cdr x)))))\n  (helper lst))\n", "  (if (null? lst)\n  \
    \    0\n      (+ (* lst (car lst)) (sum-cubes (cdr lst)))))\n", "  (if (null?\
    \ lst)\n      0\n      (+ (* 2 (car lst)) (sum-squares  (cdr lst)))))\n", "  (cond\
    \ ((null? lst) 0)\n        (else (+ (square (car lst)) (sum-squares (cdr lst)))))\n\
    \  )\n", "  (cond\n    [(empty? lst) 0]\n    [(= (% 3 lst) 0)\n     (* lst (sum_squares\
    \ (rest lst)))]\n    [(= (% 3 lst) 1)\n     (* lst (sum_squares (rest lst)))]\n\
    \    [else\n     (+ (* lst (* lst (* lst lst))) (sum_squares (rest lst)))]))\n",
  "  (if (empty? lst)\n      0\n      (+ (squares (first lst)) (sum_squares (rest\
    \ lst)))))\n", "  (if (null? lst)\n      0\n      (if (even? (modulo lst 3))\n\
    \          (+ (* lst lst) (* lst lst))\n          (+ (* lst lst) (* lst lst) (*\
    \ lst lst)))))\n", "  (sum-squares (map-indexed (lambda (x i) \n             \
    \               (if (= (mod i 3)\n                                 (mod i 4))\n\
    \                                (* x (* x x))\n                             \
    \   (* x (* x x))))\n                            lst)))\n", "  (define (square\
    \ n)\n    (if (= (rem n 3) 0)\n        n (* n n)))\n\n  (define (cube n)\n   \
    \ (if (= (rem n 4) 0)\n        n (* n n)))\n\n  (define (sum lst)\n    (cond\n\
    \      [(null? lst) 0]\n      [else (+ (square n) (cube n)) \n        ]\n    \
    \  ))\n\n  (sum lst))\n", "  (cond\n    [(empty? lst)                        \
    \    0]\n    [(pair? (car lst))                      (+ sum_squares (square (car\
    \ lst)))]\n    [else                                (+ sum_squares (cube   (car\
    \ lst)))]))\n", "  (cond\n    [(empty? lst) 0]\n    [(equal? (modulo lst (- 3\
    \ 4)) 0) (+ lst (* lst (* lst (lst (- 3 4)))))]\n    [else (+ lst (* lst (* lst\
    \ (- 3 4))))]))\n</code>\n<|/ q |>\n<| c |>\nPlease [format your code properly](https://meta.stackexchange.com/a/22189/248777).\n\
    <|/ c |>\n<| c |>\n[How to debug small programs](https://ericlippert.com/2014/03/05/how-to-debug-small-programs/).\
    \  Have you run your code in DrRacket to see if there are any error messages?\n\
    <|/ c |>\n<| c |>\nI reformatted the code so it can be read easier, and yes, I\
    \ run my code in DrRacket. I also ran my code in an online compiler and the program\
    \ does not work. Do you have any suggestions on how I can fix my program?\n<|/\
    \ c |>\n<| a dscore=0 |>\nThis looks pretty similar to your previous question.\
    \ Your problem is that you are only calling square-list once for each element\
    \ in your list. One way to fix this is to call square-list on each element in\
    \ the list after it is done with the rest of the list.\n<code>", "  (define (helper\
    \ index sum)\n    (cond ((= index 0) sum)\n          ((= index 1) (helper (sub1\
    \ index) sum))\n          ((= (mod index 3) 0) (helper (sub1 index) (* (+ sum\
    \ 1) sum)))\n          ((= (mod index 4) 0) (helper (sub1 index) (* (+ sum 1)\
    \ (* (+ sum 1) sum)))\n          ((= (mod index 3) 1) (helper (sub1 index) (*\
    \ (+ sum (* sum 1)) sum)))\n          ((= (mod index 4) 1) (helper (sub1 index)\
    \ (* (+ sum (* sum 1) (* (+ sum 1) sum)))))\n    (helper (sub1 index) sum))\n\
    \  (helper lst 0))\n</code>\n<|/ q dscore=2 |>\n<| c |>\nWelcome to StackOverflow!\
    \ This is not a free homework completion service, it's a place for people asking\
    \ questions when they're stuck on a specific programming problem or don't know\
    \ how to do something specific. Questions asking for code or recommendations for\
    \ a site are considered [off-topic](https://stackoverflow.com/help/on-topic) here\
    \ and [should be asked on Code Review](https://codereview.stackexchange.com/help/on-topic).\
    \ I would suggest reading [How to Ask](https://stackoverflow.com/help/how-to-ask)\
    \ which covers how to ask questions best and what the types of questions we ask\
    \ on SO look like when asked on Code Review. Good luck!\n<|/ c |>\n<| c |>\nIn\
    \ addition to what said, I would recommend taking a look at [Academy of Software\
    \ Testing](https://careers.acm.org/) which has courses on test-driven programming\
    \ and automated testing in general, and their [Programming Languages](https://www.academia.edu/47617)\
    \ course on Scheme. As others have said, though, StackOverflow isn't a free code\
    \ writing service, so this is really more of a place to ask questions while you\
    \ learn the basics of the language and write your own code.\n<|/ c |>\n<| c |>\n\
    This problem can be solved using one pass and one `if` statement, no need for\
    \ a helper function. A very simple solution is `(define (sum-squares lst) (let\
    \ ((sum (cadr lst)))\n                                 (if (null? (cddr lst))\n\
    \                                     (+ sum 0)\n                            \
    \         (let ((square (if (even? (car lst)) (* (car lst) (car lst))\n      \
    \                                                 1))\n                      \
    \                    ", "  (cond\n    [(empty? lst) 0]\n    [(or (= (modulo lst\
    \ 3) 0) (= (modulo lst 4) 0)) 0]\n    [else (+ (* lst (list 1 (* lst lst))) (*\
    \ (list 1 (* lst lst)) (* lst lst)))]\n  ))\n", "  (cond\n    [(empty? lst) 0]\n\
    \    [(= (mod (car lst) 3) 0) (+ lst (* lst (car lst)))]\n    [(= (mod (car lst)\
    \ 4) 0) (+ lst (* lst (car lst)))]\n    [else (+ lst (* lst (car lst)))]))\n",
  "  (if (null? lst)\n      '()\n      (if (and\n             (mod (car lst) 3) \n\
    \             (mod (cadr lst) 4)\n             (not (mod (caddr lst) 3)))\n  \
    \        (+ (* car lst)\n             (sum_squares (cdr lst)))\n          (+ (*\
    \ car lst)\n             (* 3\n                   (sum_squares (cdr lst)))))))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nThank you for this thorough explanation.\
    \ One question though, why did you switch the positions of sum and square?\n<|/\
    \ c |>\n<| c |>\nThat's a good question. I didn't notice I made that mistake (I\
    \ tested it before posting). It's fixed now. Thanks for catching it.\n<|/ c |>\n\
    <| c |>\nI've added an answer with a simpler implementation of `sum-squares`\n\
    <|/ c |>\n<| a dscore=1 |>\nA bit of an extended comment: I would recommend you\
    \ to read up on abstractions (data structures) before tackling recursion. \nLet's\
    \ start by refactoring your sum_squares function by splitting it into several\
    \ smaller functions, one for each of the steps that make up your recursion (in\
    \ this case a sum-square function and a sub-sum-square function). \n<code>", " \
    \ (cond\n    [(empty? lst) 0]\n    [(= (length lst) 0) 0]\n    [(= (mod (car lst)\
    \ 3) 0) (+ (* (car lst) (car lst))\n            (sum_squares (cdr lst)))]\n  \
    \  [else (+ (* (car lst) (car lst)) \n            (sum_squares (cdr lst)))]))\n",
  "  (cond\n    [(empty? lst) (empty)]\n    [else\n     (+ (* (car lst)(car lst))\
    \ (sum_squares (cdr lst)))]))\n", "  (if (null? lst)\n      '()\n      (if (=\
    \ (mod (car lst) 3) 0)\n          (+ lst (* lst (* lst lst)))\n          (+ lst\
    \ (* lst (* lst lst))))))\n", "  (if (null? lst)\n      0\n      (if (= (modulo\
    \ (first lst) 3)\n              0 \n              (* \n                (first\
    \ lst) \n                (sum-squares (rest lst)))\n              (if (= (modulo\
    \ (first lst) 4)\n                  (* \n                   (first lst) \n   \
    \                (sum-squares (rest lst)))\n                  (+ \n          \
    \          (first lst) \n                    (sum-squares (rest lst))))))))\n",
  "  (let loop ((sum (list 0))\n             (lst (copy lst))\n             (i 0))\n\
    \    (if (= i llength)\n        sum\n        (loop (+ (car sum) (car (cdr sum)))\
    \ (cdr lst) (+ i 1)))))\n", "  (cond\n    [(empty? lst) (sum #f lst)]\n    [(number?\
    \ lst) (sum #f (map (lambda (i) (* i i)) lst))]\n    [else (cons (sum (map (lambda\
    \ (i) (* i i)) lst))\n                (sum_squares (map #(* % %) lst))\n     \
    \           )]))\n</code>\n<|/ q |>\n<| c |>\nThe function should return a list,\
    \ not an integer. Also, why not using `cond` to test if the list is empty and\
    \ return a list with the sum of all numbers in the list?\n<|/ c |>\n<| c |>\n\
    How would you do this in scheme?\n<|/ c |>\n<| c |>\nA list is a type of data\
    \ structure that is a sequence of elements. The elements in a list are usually\
    \ symbols or integers. The list type is a type of data structure that is usually\
    \ represented as an array (a fixed size array). Lists are often represented using\
    \ square brackets [ ] or parentheses (). The function should return a list of\
    \ numbers, one for every element in the input list. For example (sum-squares '(3\
    \ 4 8 5 7 3 2 6)) should return (31 33 31 71 50 65 63 62).\n<|/ c |>\n<| c |>\n\
    I see that you posted your solution, but why do you think your solution is better\
    \ than the one I posted below? Can you explain yourself?\n<|/ c |>\n<| c |>\n\
    The way I see it, your solution is more elegant because it has fewer arguments.\
    \ I haven't learned how to make my function more general yet. Thus I'm interested\
    \ on finding more optimal ways to solve these kinds of problems in scheme\n<|/\
    \ c |>\n<| a tags=scheme,racket,lisp,functional-programming |>\nYou can simplify\
    \ the case where you have a multiple of 3 by using the mod function.  (mod (+\
    \ a b) c) will return b if a is multiple of c, and a otherwise.  So, you can just\
    \ check to see if your index mod 3 is 0.\n<code>", "  (define (even? x) (= (remainder\
    \ x 2) 0))\n  (define (cube x) (* x x))\n  (define (sum x)\n    (+ (sum (cube\
    \ x)) (sum (even? x)))))\n  (map sum lst))\n", "  (cond\n    ((null? lst) 0)\n\
    \    ((modulo? (car lst) 3) (* (car lst) (car lst))) \n    (else (sum-cubes (cdr\
    \ lst)))))\n", "    (if (null? lst)\n        0\n        (+ (* lst (car lst))\n\
    \           (sum-squares (cdr lst)))))\n            \n            ", "  (define\
    \ (go lst acc)\n    (cond\n      [(empty? lst) (acc + 0)]\n      [(even? (car\
    \ lst)) (go (cdr lst) (go (cdr lst) (+ acc (* car lst))))]\n      [(odd? (car\
    \ lst)) (go (cdr lst) (+ acc (* car lst)))]))\n  (go lst (+ 0 (* 0 (length lst)))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(and (mod? (first lst) 3) (mod? (first lst)\
    \ 4)) (* first (first lst) (first lst))]\n    [(and (mod? (first lst) 4) (mod?\
    \ (first lst) 3)) (* first (first lst) (* first (first lst) (first lst)))]\n \
    \   [else (+ first (sum_squares (rest lst)))]))\n", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(not (pair? (rest lst)))\n     (+ (car (first lst)) (sum_squares (rest\
    \ lst)))]\n    [else (+ (square (first lst)) (sum_squares (rest lst)))]))\n",
  "  (if (empty? lst) 0\n      (+ (square (car lst)) (sum-squares (cdr lst)))))\n",
  "  (define (make-squares lst)\n    (if (empty? lst)\n        (error \"empty list\
    \ supplied\")\n        (define (iter index result)\n          (cond ((= index\
    \ 1) (+ result (* index index)))\n                ((= index 2) (+ result (* index\
    \ index)))\n                ((= index 3) (+ result (* index index)))\n       \
    \         (else (iter (add1 index) (+ result (* index index))))))\n    (iter 0\
    \ 0)))\n  (define (make-cubes lst)\n    (if (empty? lst)\n        (error \"empty\
    \ list supplied\")\n        (define (iter index result)\n          (cond ((= index\
    \ 1) (+ result (* index index)))\n                ((= index 2) (+ result (* index\
    \ index)))\n                ((= index 3) (+ result (* index index)))\n       \
    \         (else (iter (add1 index) (+ result (* index index))))))\n    (iter 0\
    \ 0)))\n  (define (square-cubes lst)\n    (if (empty? lst)\n        (error \"\
    empty list supplied\")\n        (define (iter index result)\n          (cond ((=\
    \ index 1) (+ result (* index index)))\n                ((= index 2) (+ result\
    \ (* index index)))\n                ((= index 3) (+ result (* index index)))\n\
    \                (else (iter (add1 index) (+ result (* index index))))))\n   \
    \ (iter 0 0)))\n  (if (empty? lst)\n      (error \"empty list supplied\")\n  \
    \    (define (iter index)\n        (cond ((= index 1) (+ result (* index index)))\n\
    \              ((= index 2) (+ result (* index index)))\n              ((= index\
    \ 3) (+ result (* index index)))\n              (else (iter (add1 index) (+ result\
    \ (* index index))))))\n      (iter 0))\n  (define (iter index result)\n    (cond\
    \ ((= index 1) (+ result (* index index)))\n          ((= index 2) (+ result (*\
    \ index index)))\n          ((= index 3) (+ result (* index index)))\n       \
    \   (else (iter (add1 index) (+ result (* index index))))))\n  (iter 0 0))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(member? (modulo lst 3) 0) (* lst lst)]\n \
    \   [(member? (modulo lst 4) 0) (* lst lst)]\n    [else (+ lst (* lst lst))]))\n",
  "  ((define (square x)\n         (* x x))\n   (define (cube x)\n         (* x x\
    \ x))\n   (define (sum-entries lst )\n     (if (null? lst)\n       0\n       ((if\
    \ (or (modulo lst 3) (modulo lst 4))\n             (+ (square lst)\n         \
    \       (cube lst))\n           (+ (cube lst)\n               (square lst))))\n\
    \       (sum-entries (remove-last (rest lst) lst))))\n  ((sum-entries lst )))\n",
  "  (sum (map (lambda (x y) (if (= (mod x 3) 0) (* x x) (* x y))) lst lst)))\n",
  "  (let loop ((lst lst)\n             (acc 0))\n    (if (null? lst)\n        acc\n\
    \        (loop (cdr lst)\n              (+ (car lst)\n                 (if (even?\
    \ (car lst))\n                     (* car lst (car lst))\n                   \
    \  (* car lst (car lst) (car lst))))))))\n", "  (cond\n    [(empty? lst)\n   \
    \  0]\n    [(member (car lst) '(3 4))\n     (+ (* 2 (car lst))\n        (sum-squares\
    \  (sub1 (cdr lst)))]\n    [else\n     (+ 0 (* (car lst) (sum-squares (sub1 (cdr\
    \ lst))))])))\n", "  (let* ([sq1 (squares lst (mod 3 #t))\n          sq2 (squares\
    \ lst (mod 4 #t))\n          sum (+ (reduce + sq1) (reduce + sq2))])\n    sum))\n",
  "  (define (square n)\n    (* n n))\n  (define (cube n)\n    (* n n))\n  (define\
    \ (check x y z)\n    (= (mod x 3) (mod y 3)))\n  (define (loop l acc)\n    (cond\n\
    \      [(null? l) acc]\n      [(and (integer? (car l)) (= (mod (car l) 3) 0))\
    \ \n       (loop (cdr l) (+ acc (square (car l))))]\n      [(and (integer? (car\
    \ l)) (= (mod (car l) 4) 0)) \n       (loop (cdr l) (+ acc (cube (car l))))]\n\
    \      [else (loop (cdr l) acc)]\n      ))\n  (loop (reverse lst) 0))\n", "  (if\
    \ (null? lst)\n      0\n      (+ (*\n          (if (even? (car lst)) \n      \
    \        (car lst) \n              (* 3 car lst)))\n         (*\n          (if\
    \ (even? (cdr lst)) \n              (cdr lst) \n              (* 4 cdr lst)))\n\
    \         (sum-squares (cdr lst))))))\n", "  (cond\n    [(null? lst) 0]\n    [else\
    \ (cond (= (modulo lst 3) 0)\n                (= (modulo lst 4) 0)\n         \
    \       (= (modulo lst 3) 0)\n                (= (modulo lst 4) 0)\n         \
    \       (= (modulo lst 3) 1)\n                (= (modulo lst 4) 1)\n         \
    \       (= (modulo lst 3) 1)\n                (= (modulo lst 4) 1)\n         \
    \       (= (modulo lst 3) 2)\n                (= (modulo lst 4) 2)\n         \
    \       (= (modulo lst 3) 2)\n                (= (modulo lst 4) 2)\n         \
    \       (= (modulo lst 3) 3)\n                (= (modulo lst 4) 3)\n         \
    \       (= (modulo lst 3) 3)\n                (= (modulo lst 4) 3)\n         \
    \       (= (modulo lst 3) 4)\n                (= (modulo lst 4) 4)\n         \
    \       (= (modulo lst 3) 4)\n                (= (modulo lst 4) 4)\n         \
    \       (= (modulo lst 5) 1)\n                (= (modulo lst 5) 1)\n         \
    \       (= (modulo lst 5) 1)\n                (= (modulo lst 5) 2)\n         \
    \       (= (modulo lst 5) 2)\n                (= (modulo lst 5) 2)\n         \
    \       (= (modulo lst 5) 3)\n                (= (modulo lst 5) 3)\n         \
    \       (= (modulo lst 5) 3)\n                (= (modulo lst 5) 4)\n         \
    \       (= (modulo lst 5) 4)\n                (= (modulo lst 5) 4)\n         \
    \       (= (modulo lst 5) 5)\n                (= (modulo lst 5) 5)\n         \
    \       (= (modulo lst 5) 5)\n                (= (modulo lst 5) 6)\n         \
    \       (= (modulo lst 5) 6)\n                (= (modulo lst 5) 6)\n         \
    \       (= (modulo lst 5) 7)\n                (= (modulo lst 5) 7)\n         \
    \       (= (modulo lst 5) 7)\n                (= (modulo lst 5) 8)\n         \
    \       (= (modulo lst 5) 8)\n                (= (modulo lst 5) 8)\n         \
    \       (= (modulo lst 5) 9)\n                (= (modulo lst 5) 9)\n         \
    \       (= (modulo lst 5) 9)\n                (= (modulo lst 5) 10)\n        \
    \        (= (modulo lst 5) 10)\n                (= (modulo lst ", "  (let loop\
    \ ((lst lst)\n             (sum 0)\n             (n (length lst)))\n    (cond\
    \ ((< n 0) sum)\n          ((even? (modulo lst 3)) (+ sum (* 2 lst)))\n      \
    \    ((even? (modulo lst 4)) (+ sum (* 3 lst)))\n          (else (loop (rest lst)\
    \ sum (1+ n))))))\n", "  (let loop ((lst lst) (acc 0))\n    (cond \n      ((empty?\
    \ lst) acc)\n      (else (loop (rest lst) (+ acc (square (car lst))))))))\n",
  "  (cond\n    ((null? lst) 0)\n    ((or (= (modulo lst (length lst)) 3)\n      \
    \   (= (modulo lst (length lst)) 4)) (squares (rest lst)))\n    (else (cubes (rest\
    \ lst))))))\n", "  (define (helper lst acc)\n    (cond\n      [(null? lst) acc]\n\
    \      [(even? (car lst)) (helper (cdr lst) (* acc (* lst (car lst))))]\n    \
    \  [(odd? (car lst)) (helper (cdr lst) (* acc (* lst (car lst))))]\n      [else\
    \ (helper (cdr lst) (+ acc (* lst (car lst))))]))\n  (helper lst 0))\n", "  (cond\
    \ [(null? lst) 0]\n        [(= (modulo lst (- 4)) 3) (* (square (modulo lst (-\
    \ 4))) (modulo lst (- 4)))]\n        [(= (modulo lst (- 3)) 4) (* (square (modulo\
    \ lst (- 3))) (modulo lst (- 3)))]\n        [else (+ lst (sum_squares (rest lst)))]))\n",
  "    (if (null? lst)\n        0\n        (+ (* 2 (car lst)) (sum-squares (cdr lst)))))\n\
    </code>\n<|/ q dscore=1 tags=scheme |>\n<| c |>\nPlease do not ask multiple questions\
    \ in one post. Instead post each question as a separate post.\n<|/ c |>\n<| c\
    \ |>\nOk i will remember this for the next time. Thanks for the advice!\n<|/ c\
    \ |>\n<| c |>\nJust a suggestion: don't use \"-\" in your variable names. If you\
    \ use \"-\" it's pretty easy to mess up when reading code because \"-\" is a special\
    \ symbol in Scheme and it's used to separate positive numbers from negatives.\n\
    <|/ c |>\n<| c |>\nOk i changed it now but my problem remains the same so i didnt\
    \ get to change the name of my variable :) Thanks anyways\n<|/ c |>\n<| a dscore=1\
    \ |>\nA bit of advice, use \"DrRacket\" for your homeworks and you'll see that\
    \ it is actually easier to work with than \"Racket\".\nIn a lot of cases, the\
    \ \"problem\" is to see the problem and to solve it step by step, instead of doing\
    \ everything at once.\nThe good news is that DrRacket has two environments - \"\
    scripting\" and \"normal\" - where you can write code and see it run. \nTry this:\n\
    <code>", "  (if (null? lst)\n      0\n      (+ (square (modulo lst (list 3 4)))\n\
    \         (sum-sq (rest lst)))))\n", "  (cond\n    ((empty? lst) 0)\n    ((= (modulo\
    \ lst 3) 0) (square (car lst)))\n    ((= (modulo lst 4) 0) (cube (car lst)))\n\
    \    (else (+ (sum-squares (cdr lst))) (sum-squares (cdr lst)))))\n", "  (if (null?\
    \ lst)\n      '()\n      (if (even? (modulo lst 3))\n          (+ (* lst lst)\n\
    \             (* lst lst)\n             (* lst lst))\n          (if (even? (modulo\
    \ lst 4))\n              (+ (* lst lst)\n               (* lst lst)\n        \
    \       (* lst lst))\n              (+ (* lst lst)\n               (* lst lst)\n\
    \               (* lst lst))))))", "  (cond\n    ((null? lst) 0)\n    ((= (remainder\
    \ lst 3) 0) (+ (* lst (* lst lst)) (* lst (* lst lst)))\n    ((= (remainder lst\
    \ 4) 0) (+ (* lst (* lst lst)) (* lst (* lst lst)))\n    (else (+ lst (* lst (*\
    \ lst lst))))))\n", "  (let loop ((lst (map list lst '(0 1 2 3 4 5 6 7 8 9 10\
    \ 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\
    \ 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62\
    \ 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88\
    \ 89 90 91 92 93 94 95 96 97 98 99 100))\n             (sum (+ (* n n) (* n n)\
    \ (* n n))))\n    (cond ((null? lst) sum)\n          ((= (nth 0 lst) (mod (nth\
    \ 0 lst) 3))\n           (loop (cdr lst) (+ sum n)))\n          ((= (nth 0 lst)\
    \ (mod (nth 0 lst) 4))\n           (loop (cdr lst) (+ sum (* 3 n))))\n       \
    \   (else (loop (cdr lst) (+ sum (* 4 n)))))))\n", "  (define squares (filter\
    \ (lambda (x) (mod x 3 = 0)) lst))\n  (define cubes (filter (lambda (x) (mod x\
    \ 4 = 0)) lst))\n  (define sum (apply + squares))\n  (if (null? lst)\n      0\n\
    \      (if (empty? cubes)\n          sum\n          (+ (first lst) (sum_squares\
    \ cubes)))))\n", '  ;; (define square_if_pm3 #(if (modulo %2 0) (square (modulo
    %2 0)) 0)) ;; (define square_if_pm4 #(if (modulo %2 0) (cube (modulo %2 0)) 0))
    ;; (define cube_if_pm3 #(if (modulo %2 0) (cube (modulo %2 0)) 0)) ;; (define
    cube_if_pm4 #(if (modulo %2 0) (square (modulo %2 0)) 0)) ;; (define square_if_pm3
    #(if (modulo %2 0) (square (modulo %2 0)) 0)) ;; (define square_if_pm4 #(if (modulo
    %2 0) (square (modulo %2 0)) 0)) ;; (define cube_if_pm3 #(if (modulo %2 0) (cube
    (modulo %2 0)) 0)) ;; (define cube_if_pm4 #(if (modulo %2 0) (cube (modulo %2
    0)) 0)) ;; (define square_if_pm3 #(if (modulo %2 0) (square (modulo %2 0)) 0))
    ;; (define square_if_pm4 #(if (modulo %2 0) (square (modulo %2 0)) 0)) ;; (define
    cube_if_pm3 #(if (modulo %2 0) (cube (modulo %2 0)) 0)) ;; (define cube_if_pm4
    #(if (modulo %2 0) (cube (modulo %2 0)) 0)) ;; (define square_if_pm3 #(if (modulo
    %2 0) (square (modulo %2 0)) 0)) ;; (define square_if_pm4 #(if (modulo %2 0) (square
    (modulo %2 0)) 0)) ;; (define cube_if_pm3 #(if (modulo %2 0) (cube (modulo %2
    0)) 0)) ;; (define cube_if_pm4 #(if (modulo %2 0) (cube (modulo %2 0)) 0)) ;;
    (define square_if_pm3 #(if (modulo %2 0) (square (modulo %2 0)) 0)) ;; (define
    square_if_pm4 #(if (modulo %2 0) (square (modulo %2 0)) 0)) ;; (define cube_if_pm3
    #(if (modulo %2 0) (cube (modulo %2 0)) 0)) ;; (define cube_if_pm', "    (cond\n\
    \        [(empty? lst) (empty? lst)]\n        [(even? (modulo lst (- 3 1)))\n\
    \            (+ lst (* lst (* lst (- 3 1))))]\n        [else (+ lst (* lst (*\
    \ lst (- 4 1))))]\n    )\n)\n", "  (cond\n    [(empty? lst) 0]\n    [(equal? (modulo\
    \ 2 (first lst)) 0) (+ 0 (first lst) (second lst) (third lst) (fourth lst) (fifth\
    \ lst) (sixth lst) (seventh lst) (nineth lst) (tenth lst) (eleventh lst) (twelveth\
    \ lst) (thirteenth lst) (fourteenth lst) (fifteenth lst) (sixteenth lst) (seventeenth\
    \ lst) (eighteenth lst) (nineteenth lst) (twentieth))\n    [else (+ 0 (first lst)\
    \ (sum_squares (rest lst))))]))\n", "  (define (my-mod m n)\n    (if (= m 0) 0\
    \ \n      (if (= m n) (mod n n) \n        (if (= (mod m n) 0) (mod m n) \n   \
    \       (if (= (mod m n) n) n \n            (if (= (mod m n) n) \n           \
    \   (mod m n) \n              (mod m n)))))\n    (mod m n)))\n  (define (my-mult\
    \ m n)\n    (if (= m 0) 1 \n      (if (= m n) 1 \n        (if (= (mod m n) 0)\
    \ (* n n)\n          (if (= (mod m n) n) (* n 1)\n            (if (= (mod m n)\
    \ n) (* 1 n)\n              (if (= (mod m n) n) 1\n                (* 1 n)))))\n\
    \    (mod m n)))\n  (define (my-add m n)\n    (if (= m 0) (n) \n      (if (= n\
    \ 0) 0 \n        (if (= n m) (* m (* n n))\n          (if (= (mod n m) m) (* n\
    \ m)\n            (if (= (mod n m) m) (* m n)\n              (if (= (mod n m)\
    \ m) (* m 1)\n                (* 1 m)))))))\n  (define (my-square m)\n    (if\
    \ (= m 0) 1\n      (if (= m 1) m\n        (if (= (mod m 1) 1) (* m m)\n      \
    \    (if (= (mod m 1) m) (* m (* m m))\n            (if (= (mod m 1) m) (* m (*\
    \ 1 m))\n              (if (= (mod m 1) m) (* 1 (* m m))\n                (* 1\
    \ (* m 1)))))))\n  (define (my-mod m n)\n    (if (= m 0) 0 \n      (if (= m n)\
    \ 0 \n        (if (= (mod m n) 0) (mod m n) \n          (if (= (mod m n) n) n\
    \ \n            (if (= (mod m n) n) \n              (mod m n) \n             \
    \ (mod m n)))))\n  (define (my-mult m n)\n    (if (= m 0) 1 \n      (if (= m n)\
    \ 1 \n        (if (= (mod m n) 0) (* n n)\n          (if (= (mod m n) n) (* n\
    \ 1)\n            (if (= (mod m n) n) (* 1 n)\n              (if (= (mod m n)\
    \ n", "  (let ((result 0))\n    (for ([x lst])\n      (if (= (remainder x 3) 0)\n\
    \          (set! result (+ result (* x x)))\n          (set! result (+ result\
    \ (* x x))))\n    result))\n", "  (cond\n    [(empty? lst) 0]\n    [(mod (car\
    \ lst) 3)\n     (+ square (car lst))\n     (sum_squares (cdr lst))]\n    [else\
    \ (* 3 (sum_squares (cdr lst)))]))\n", "  (if (null? lst)\n      '()\n      (cond\
    \ ((= (modulo lst 4) 0)\n             (* lst lst))\n            (else (+ (* lst\
    \ lst) (* lst lst) (* lst lst)))))) ;; #lang racket\n", "  (cond [(empty? lst)\
    \ 0]\n        [(even? (modulo lst 3)) (square (modulo lst 3))]\n        [(even?\
    \ (modulo lst 4)) (cube (modulo lst 4))]\n        [else (+ (first lst) (sum_squares\
    \ (rest lst)))]))\n", "  (define (go lst acc)\n    (cond\n      [(empty? lst)\
    \ acc]\n      [(even? (car lst)) (go (cdr lst) (+ (car lst) acc))]\n      [else\n\
    \       (go (cdr lst) (+ (car lst) acc))])))\n  (go lst (0))) ;; end of function\n\
    </code>\n<|/ a |>\n<| a |>\nI like Raman's solution. However, there are a couple\
    \ of things that I would like to point out:", "  (if (null? lst)\n      0\n  \
    \    (+ (* (car lst)\n            (* 3 (car lst)))\n         (* (car lst)\n  \
    \          (* 4 (car lst))))))\n", "  (if (null? lst)\n      0\n      (+ (* lst\
    \ (square (car lst)))\n         (sum-squares (cdr lst)))))\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [(= (modulo lst 3) 0)\n     (+ lst (* lst lst))]\n    [(= (modulo\
    \ lst 4) 0)\n     (+ lst (* lst lst))]\n    [else\n     (+ lst (* lst (* lst lst)))]))\n",
  "  (if (empty? lst)\n      0\n      (+ (* (cdr lst) (car lst)) (sum-cubes (cdr lst)))))\n",
  "  (cond\n    ((empty? lst) 0)\n    (else (+ (square (first lst)) (sum_squares (rest\
    \ lst))))))\n", "  (cond\n    [(empty? lst) 0]\n    [(member? (modulo lst 3) 0)\
    \ (* lst lst)]\n    [(member? (modulo lst 4) 0) (* lst lst)]\n    [else (+ (sum-squares\
    \ (rest lst)))]))", "  (if (null? lst)\n      0\n      (+ (* (car lst) (car lst))\
    \ (sum-squares (cdr lst)))))\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is a simple\
    \ solution that doesn't use recursion. It also works well with negative numbers\
    \ and works with lists of even length as well.\n<code>", "  (cond [(empty? lst)\
    \ 0]\n        [(cons? (car lst)) (+ (* car lst) (sum_squares (cdr lst)))]\n  \
    \      [else\n         (if (modulo (length lst) 3) == 0 \n             (+ (* 3\
    \ (car lst)) (sum_squares (cdr lst)))\n             (+ (* 4 (car lst)) (sum_squares\
    \ (cdr lst)))\n             (sum_squares (cdr lst)))))\n", "  (cond [(null? lst)\
    \ 0]\n        [(even? (car lst)) (+ 0 (* 1 (car lst)))]\n        [(odd? (car lst))\
    \ (+ 0 (* 1 (car lst)))]\n        [else\n         (+ 0 (* 2 (sum_squares (cdr\
    \ lst))))]))\n", "  (let loop ((lst lst)\n             (acc 0))\n    (if (null?\
    \ lst)\n        acc\n        (loop (cdr lst)\n               (+ acc (* lst lst))))))\n",
  "  (let loop ((lst lst) (sum '()))\n    (cond\n      [(null? lst) sum]\n      [(not\
    \ (even? (car lst))) (loop (cdr lst) sum)]\n      [(even? (car lst)) (loop (cdr\
    \ lst) (+ (* car lst) (* sum (car lst))))]\n      [else (loop (cdr lst) (+ (*\
    \ car lst) (* sum (car lst))))]))) \n", "  (if (null? lst)\n      0\n      (+\
    \ (square (car lst))\n         (sum-squares (cdr lst)))))\n", "  (if (empty? lst)\n\
    \      0\n      (+ (*\n            (if (= (mod (car lst) 3) 0)\n             \
    \ (* (car lst) (car lst))\n              (* (* car lst) (car lst)))))\n      (+\
    \ (sum-squares\n          (filter (\u03BB (x) \n                    ((= (mod (car\
    \ lst) 3) 0)\n                     (= (mod (car lst) 4) 0)\n                 \
    \    (= (mod (car lst) 3) 0))\n                   (rest lst)))\n         (sum-squares\n\
    \          (filter (\u03BB (x)\n                    ((= (mod (car lst) 4) 0)\n\
    \                     (= (mod (car lst) 3) 0)\n                     (= (mod (car\
    \ lst) 4) 0))\n                   (rest lst))))))\n", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(= (first lst) 3) (* 3 (first lst))]\n    [(= (first lst) 4) \n   \
    \  (* (first lst) (first lst))]\n    [else (+ 0 (sum_squares (rest lst)))]))\n",
  "  (let ((summ 0))\n    (for ((i 0) (j lst)) \n      (if (= (modulo i 3) 0)\n  \
    \        (set! summ (+ summ (* i i)))\n          (set! summ (+ summ (* j j)))\n\
    \      )\n    )\n    summ\n  )\n)\n", "  (let loop ((lst lst) (acc 0))\n    (cond\
    \ \n      [(empty? lst) acc]\n      [(null? (cdr lst)) acc]\n      [else (loop\
    \ (cdr lst) (+ acc (* lst (list 'square (modulo-3 lst))))]\n    )\n  )\n)\n",
  "  (if (null? lst) \n      0 \n      (+ (* (expt (car lst) 2) (expt (car lst) 2))\
    \ (sum-squares (cdr lst)))))\n", "  (define (isOdd number)\n    (cond\n      [(=\
    \ (mod number 4) 0) #t]\n      [(= (mod number 3) 0) #f]\n      [else #t]))\n\
    \  (cond\n    [(empty? lst) 0]\n    [else (+ (map (lambda (x) (if (isOdd x) (x\
    \ * x) (x * x * x))) lst)]))\n", "  (let* ((lst2 (filter odd?(map list->list (interleave\
    \ lst lst)))) (sum (foldl sum-square-helper 0 lst2)))\n    (reverse (map list-ref\
    \ lst2 sum))))\n", "  (sum-squares-helper (length lst) lst))\n", "  (cond\n  \
    \  ((empty? lst) 0)\n    ((even? index) (* index index))\n    ((odd? index) (*\
    \ index index) \n      (+ (first lst) (sum_squares (rest lst))))))\n", "  (cond\n\
    \    [(empty? lst) 0]\n    [(not (= (mod lst 3) 0)) (* (cadr lst) (cdr lst))]\n\
    \    [(not (= (mod lst 4) 0)) (* (caddr lst) (caddr lst))]\n    [else (+ (caddr\
    \ lst) (caddr lst))]))\n", "  (cond\n    ;; If the list is empty or if all entries\
    \ are 0 then return 0\n    [(or (empty? lst)\n           (null? lst))\n     0]\n\
    \    ;; Else for all entries in the list, if the entry is a multiple of 3 then\
    \ square it and add it to our total\n    [(list? (car lst))\n     (+ (* (car lst)\
    \ (car lst))\n        (sum_squares (cdr lst)))]\n    ;; Otherwise if the entry\
    \ is a multiple of 4 and not a multiple of 3, then cube it and add it to our total\n\
    \    [else \n     (+ (* 4 (car lst))\n        (sum_squares (cdr lst)))]))\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI really don't understand this at all. I understand\
    \ the algorithm for calculating the sum. But I don't understand how you define\
    \ the \"square\" and \"cube\" procedures. How do they make sense? How do you define\
    \ these procedures that operate on integers?\n<|/ c |>\n<| c |>\n`square` takes\
    \ an integer as argument. `cube` takes a number as argument. `square` returns\
    \ the same value if its argument is a multiple of 3, while `cube` returns the\
    \ same value if its argument is a multiple of 4, and otherwise returns the same\
    \ value if its argument is not a multiple of 3 or 4. But I see how you came up\
    \ with the idea of using modulo and that seems to work very well.\n<|/ c |>\n\
    <| c |>\nI guess I got confused because my professor said that he was using integers\
    \ and he said he was using the modulo function when he was doing examples and\
    \ I thought that was what he was using. He had just started using Racket this\
    \ past week and he only told us what functions we were to use.\n<|/ c |>\n<| c\
    \ |>\nAh I see. That makes sense. Glad you figured it out :D\n<|/ c |>\n<| a tags=scheme,racket\
    \ |>\n<code>", "  (if (empty? lst)\n      0\n      (let ((sum (+ (square (car\
    \ lst)) (square (cdr lst)))))\n        (if (even? sum)\n            (+ sum sum_squares\
    \ (- sum (car lst)) (- sum (cdr lst)))\n            sum))))", "  (define (helper\
    \ lst num)\n    (cond\n      [(empty? lst)\n       num]\n      [(= (num) (modulo\
    \ (car lst) 3))\n       (helper (cdr lst) (* num num))\n       (helper (cdr lst)\
    \ (* num num))\n       ]\n      [(= (num) (modulo (car lst) 4))\n       (helper\
    \ (cdr lst) (* num num))\n       (helper (cdr lst) (* num num))\n       (helper\
    \ (cdr lst) (* num num))\n       ]\n      [else\n       (helper (cdr lst) (* num\
    \ num))\n       (helper (cdr lst) (* num num))\n       (helper (cdr lst) (* num\
    \ num))\n       (helper (cdr lst) (* num num))\n       ]))\n  (helper lst 0))\n\
    </code>\n<|/ a dscore=0 tags=racket,scheme,racket-student-languages |>\n<| c |>\n\
    Thank you for the response. I have only been studying for 4 weeks and am not sure\
    \ if I am supposed to use this kind of approach. Our professor is just looking\
    \ at different ways of doing things. I have not learned how to do any sort of\
    \ functional programming yet.\n<|/ c |>\n<| c |>\nThen I would suggest you read\
    \ up on Scheme and functional programming in general. There are plenty of resources\
    \ out there for you to find out. The [Racket Guide](https://docs.racket-lang.org/guide/)\
    \ is a great one to start with.\n<|/ c |>\n<| a dscore=0 |>\nHere's another option.\
    \ I didn't get any feedback about the complexity of the solution so I thought\
    \ I'd post it.\n<code>", "  (if (null? lst) 0\n      (+ (* 2 (car lst))\n    \
    \     (sum-cubes (cdr lst)))))\n", "  (if (null? lst) 0\n      (if (and (= (modulo\
    \ lst (- 3 4)) 0)\n               (= (modulo lst (- 3 4)) 4))\n          (+ lst\
    \ (* lst (* lst (- 3 4))))\n          (+ lst (* lst (* lst (- 4 3))))\n      \
    \    (+ lst (* lst (* lst (- 5 4))))\n          (+ lst (* lst (* lst (- 5 3))))\n\
    \          (+ lst (* lst (* lst (- 6 4))))\n          (+ lst (* lst (* lst (-\
    \ 6 3))))\n          (+ lst (* lst (* lst (- 7 4))))\n          (+ lst (* lst\
    \ (* lst (- 7 3))))\n          (+ lst (* lst (* lst (- 8 4))))\n          (+ lst\
    \ (* lst (* lst (- 8 3))))\n          (+ lst (* lst (* lst (- 9 4))))\n      \
    \    (+ lst (* lst (* lst (- 9 3))))\n          (+ lst (* lst (* lst (- 10 4))))\n\
    \          (+ lst (* lst (* lst (- 10 3))))\n          (+ lst (* lst (* lst (-\
    \ 11 4))))\n          (+ lst (* lst (* lst (- 11 3))))\n          (+ lst (* lst\
    \ (* lst (- 12 4))))\n          (+ lst (* lst (* lst (- 12 3))))\n          (+\
    \ lst (* lst (* lst (- 13 4))))\n          (+ lst (* lst (* lst (- 13 3))))\n\
    \          (+ lst (* lst (* lst (- 14 4))))\n          (+ lst (* lst (* lst (-\
    \ 14 3))))\n          (+ lst (* lst (* lst (- 15 4))))\n          (+ lst (* lst\
    \ (* lst (- 15 3))))\n          (+ lst (* lst (* lst (- 16 4))))\n          (+\
    \ lst (* lst (* lst (- 16 3))))\n          (+ lst (* lst (* lst (- 17 4))))\n\
    \          (+ lst (* lst (* lst (- 17 3))))\n          (+ lst (* lst (* lst (-\
    \ 18 4))))\n          (+ lst (* lst (* lst (", "  (define (sum_squares_helper\
    \ lst acc)\n    (cond [(null? lst)\n           acc]\n          [(modulo (car lst)\
    \ 3)\n           (sum_squares_helper (cdr lst) (+ acc (* acc (car lst))))]\n \
    \         [(modulo (car lst) 4)\n           (sum_squares_helper (cdr lst) (+ acc\
    \ (* acc (car lst))))]\n          [else\n           (sum_squares_helper (cdr lst)\
    \ acc)]\n          ))\n  (sum_squares_helper lst 0))\n", "  (cond\n    [(empty?\
    \ lst)\n     0]\n    [(= (length lst) 2)\n     (+ (first lst)\n        (second\
    \ lst))\n    ]\n    [else\n     (+ (* (first lst)\n           (first lst))\n \
    \       (sum-squares (rest lst))\n      )\n    ]\n  )\n)", "  (cond\n    [(empty?\
    \ lst) 0]\n    [(not (even? (car lst)))\n     (+ (* lst (car lst))\n        (sum-squares\
    \ (cdr lst)))]\n    [(even? (car lst))\n     (+ (* lst (car lst))\n        (sum-squares\
    \ (cdr lst)))]\n    [else (+ (* lst (car lst))\n             (sum-squares (cdr\
    \ lst)))]))\n", "  (define (inner-loop lst)\n    (cond ((null? lst) 0)\n     \
    \     ((even? (length lst))\n           (+ (* (car lst) (car lst)) (inner-loop\
    \ (cdr lst))))\n          (else (+ (* (car lst) (car lst)) (inner-loop (cdr lst)))))\n\
    \  (inner-loop lst))\n</code>\n<|/ a dscore=0 tags=racket,scheme |>\n<| a dscore=0\
    \ tags=racket,scheme |>\n<code>", "  (if (null? lst)\n      0\n      (+ (square\
    \ (car lst))\n         (sum-squares (cdr lst)))))\n", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(zero? (car lst)) 0]\n    [(even? (car lst)) (+ 0 (* lst (car lst)))]\n\
    \    [(odd? (car lst)) (+ 0 (* lst (car lst)))]\n    [else (+ 0 (sum-cubes lst))]))\n",
  "  (if (empty? lst)\n      0\n      (+ \n        (if (even? (length lst))\n    \
    \       (* lst (* lst (length lst)))\n           (* lst (* lst (length lst))))))\n\
    \  )\n", "  (if (empty? lst)\n      '()\n      (cons\n        (if (= (mod (car\
    \ lst) 3) 0)\n            (+ 4 (car lst))\n            (+ 4 (* (car lst) (car\
    \ lst)))\n            (+ 4 (* (* (car lst) (car lst)) (car lst)))\n        )\n\
    \        (sum_squares (cdr lst)))))\n", "  (define (iter lst i s)\n    (cond\n\
    \      [(empty? lst) (+ s s)]\n      [(= i (car lst)) (iter (cdr lst) (+ i (car\
    \ lst)) s)]\n      [else (iter (cdr lst) (+ i (car lst)) (+ (* s car lst) (* s\
    \ (cdr lst))))]))\n  (iter lst 0 0))\n", "  (if (null? lst)\n      0\n      (+\
    \ (square (first lst)) (sum_squares (rest lst)))))", "  (cond\n    ((null? lst)\
    \ 0)\n    ((= (mod (car lst) 3) 0)  (+ (* car lst) (* car lst) (* car lst)))\n\
    \    ((= (mod (car lst) 4) 0)  (+ (* car lst) (* car lst) (* car lst)))\n    (else\
    \ (+ car lst))))\n", "  (let loop ((lst lst) (sum 0))\n    (if (empty? lst) \n\
    \        sum\n        (loop (rest lst) (+ (square-each-index lst) (sum))))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(= (modulo lst 3) 0)\n     (+ (sq (first lst))\n\
    \        (sum-squares  (sub1 lst)))]\n    [(= (modulo lst 4) 0)\n     (+ (sq (first\
    \ lst))\n        (sum-squares (sub2 lst)))]\n    [else (sum-squares (sub3 lst))]))\n",
  "  (cond ((null? lst) 0)\n        ((even? (car lst))\n         (* 3+ (sum_squares\
    \ (cdr lst))))\n        (else \n         (* 4+ (sum_squares (cdr lst)))))) ; use\
    \ else here to distinguish between 3d and 4d numbers\n", "  (if (empty? lst)\n\
    \      0\n      (+ (square (modulo lst 3))\n         (square (modulo lst 4))\n\
    \         (sum-squares (remove-if (lambda (x) (modulo x 3)) lst)))))\n", "  (define\
    \ (helper lst n result)\n    (if (null? lst)\n        result\n        (helper\
    \ (cdr lst) (add1 n) (+ result (* n (car lst)))))\n  (helper lst 0 (+ 0 (* 0 (length\
    \ lst)))))\n</code>\n<|/ a |>\n<| c |>\nThanks, I understand the solution now,\
    \ I just need to figure out how to implement that in scheme\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution in Racket:\n<code>", "  (if (empty? lst)\n      0\n  \
    \    (+ (* (first lst) (* (first lst) (first lst))) (* (sum_squares (rest lst))\
    \ (sum_squares (rest lst))))))\n", "  (define (isOdd n)\n    (if (= n 0)\n   \
    \     #t\n        (odd? (sub1 n))))\n  (define (cube n)\n    (if (= n 0)\n   \
    \     0\n        (* n n)))\n  (define (square n)\n    (if (= n 0)\n        0\n\
    \        (* n n)))\n  (define (sum-squares-aux\n           lst acc odds)\n   \
    \ (if (null? lst)\n        acc\n        (sum-squares-aux\n         (cdr lst)\n\
    \         (cond\n           ((odd? odds) (+ (car lst) acc))\n           (else\
    \ (sum-squares-aux\n                   (cdr lst)\n                   (cons (cube\
    \ odds) odds))))))\n  (sum-squares-aux lst 0 #f)\n)\n", "  (cond\n    [(empty?\
    \ lst)\n     (error '(sum_squares lst) \"List cannot be empty\")]\n    [else\n\
    \     (cond\n       [(mod? (car lst) 3)\n        (+ sqr (car lst))]\n       [(mod?\
    \ (car lst) 4)\n        (+ sqr (* car lst))]\n       [(mod? (cdr lst) 3)\n   \
    \     (+ (sum_squares (cdr lst)))]\n       [(mod? (cdr lst) 4)\n        (+ (sum_squares\
    \ (cdr lst)))]\n       [(mod? (cdr lst) 3)\n        (+ (sum_squares (cdr lst)))]\n\
    \       [(mod? (cdr lst) 4)\n        (+ (sum_squares (cdr lst)))]\n       [else\
    \ (+ (sum_squares (cdr lst)))]))]))\n", "  (cond\n    [(empty? lst) 0]\n    [(even?\
    \ (length lst)) (+ (* lst (car lst)) (sum_squares (cdr lst)))]\n    [else (+ (*\
    \ lst (car lst)) (sum_squares (cdr lst)))]))\n", "  (cond ((null? lst)\n     \
    \    0)\n        ((or (= (modulo nth lst) 3)\n             (= (modulo nth lst)\
    \ 4))\n          (+ nth nth))\n        (else\n          (sum_squares (cdr lst)))))\n",
  "  (cond\n    [(empty? lst)\n     (add1 (first lst))]\n    [else\n     (add1 (sum-sq\
    \ (first lst) (sum-sq (rest lst))))]))\n", "  (cond\n    ((null? lst) 0)\n   \
    \ ((= (modulo (first lst) 3) 0)\n     (+ (second lst) (* (second lst) (* (second\
    \ lst) (* (second lst) (* (second lst) (* (second lst) (* (second lst) (second\
    \ lst)))))\n      (sum_squares (rest lst))\n      (first lst)))\n    ((= (modulo\
    \ (first lst) 4) 0)\n     (+ (second lst)\n      (* (second lst)\n      (* (second\
    \ lst)\n      (* (second lst)\n      (* (second lst)\n      (* (second lst)\n\
    \      (* (second lst)\n      (* (second lst)\n      (* (second lst)\n      (*\
    \ (second lst)\n      (* (second lst) (* (second lst) (second lst)))))\n     \
    \ (sum_squares (rest lst))\n      (first lst)))\n    ((not (= (modulo (first lst)\
    \ 3) 0)) \n     (+ (second lst)\n      (* (second lst)\n      (* (second lst)\n\
    \      (* (second lst)\n      (* (second lst)\n      (* (second lst)\n      (*\
    \ (second lst)\n      (* (second lst)\n      (* (second lst) (second lst)))))\n\
    \      (sum_squares (rest lst))\n      (first lst)))\n    ((not (= (modulo (first\
    \ lst) 4) 0)) \n     (+ (second lst)\n      (* (second lst)\n      (* (second\
    \ lst)\n      (* (second lst)\n      (* (second lst)\n      (* (second lst)\n\
    \      (* (second lst)\n      (* (second lst)\n      (* (second lst) (second lst)))))\n\
    \      (sum_squares (rest lst))\n      (first lst)))\n    (else\n     (+ (second\
    \ lst)\n      (* (second lst)\n      (* (second lst)\n      (* (second lst)\n\
    \      (* (second lst)\n      (* (second lst)\n      (* (second lst)\n      (*\
    \ (second lst)\n      (* (second lst) (second lst))))\n      (sum_squares (rest\
    \ lst))\n      (first lst))))))\n", "  \n  (define (helper lst acc)\n    (cond\
    \ [(empty? lst) acc]\n          [(= (remainder lst 3) 0) (helper (rest lst) (+\
    \ acc (* lst lst)))]\n          [(= (remainder lst 4) 0) (helper (rest lst) (+\
    \ acc (* lst lst)))]\n          [else (helper (rest lst) (+ acc (* lst lst)))]))\n\
    \  \n  (helper lst 0))\n", "  (if (null? lst)\n      '()\n      (if (even? (car\
    \ lst))\n          (+ (car lst) (square (car lst)))\n          (if (even? (cdr\
    \ lst))\n              (+ (cdr lst) (cube (cdr lst)))\n              (sum_squares\
    \ (cdr lst)))))) ;; #lang racket\n", "  (if (null? lst)\n      0\n      (+ (square\
    \ (car lst))\n         (sum-squares (cdr lst)))))\n</code>\n<|/ a dscore=2 tags=scheme,racket,recursion\
    \ |>\n<| c |>\nFor those who want to solve this problem without using `map`, you\
    \ could use `apply` instead of `map`.\n<|/ c |>\n<| a dscore=2 |>\nA simple solution\
    \ that I came up with is:\n<code>", "  (cond [(null? lst) 0]\n        [(= (remainder\
    \ lst 4) 0) (remainder (* lst lst) 4)]\n        [(= (remainder lst 3) 0) (remainder\
    \ (* lst lst) 3)]\n        [else (+ lst lst)]))", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(member? (car lst) '(3 4)) (+ lst lst)]\n    [else (sum-squares-helper\
    \ (cdr lst))]))", "  (foldr + 0 (map (lambda (n) (if (modulo n 4) (* (* n n) (*\
    \ n n)) (* n n))) lst)))\n", "  (let ((sum (0))\n        (index (0))\n       \
    \ (mul (0))\n        (square (0))\n        (cube (0)))\n    (for ((i lst))\n \
    \     (if (= index 0)\n          (set! sum (+ sum (* i i)))\n          (set! index\
    \ (+ index 1))\n          (if (= (mod index 3) 0)\n              (set! mul (+\
    \ mul (* i i)))))\n      (if (= (mod index 4) 0)\n          (set! cube (+ cube\
    \ (* i i)))\n          (set! index (+ index 1))\n          (if (= (mod index 4)\
    \ 0)\n              (set! mul (+ mul (* i i)))))\n      (if (and (= index 1) (and\
    \ (= mul 3) (= cube 4)))\n          (set! mul (+ mul 1))\n          (set! cube\
    \ (+ cube 1))))\n    (set! sum (+ sum sum)\n          (set! mul (+ mul mul))\n\
    \          (set! cube (+ cube cube))\n          (set! index (+ index 1))\n   \
    \       (set! sum (+ sum sum)))\n    sum))\n", "  (if (empty? lst)\n      0\n\
    \      (+ (* lst (square (first lst)))\n         (sum-cube (sub1 (length lst)))\n\
    \         (sum-cube (sub1 (length lst))))))\n", "  (cond\n    [(empty? lst) 0]\n\
    \    [(even? head) (* (head head) (sum-squares\n                           (sub1\
    \ head)))]\n    [else       (* 3 (sum-squares (sub1 head)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
