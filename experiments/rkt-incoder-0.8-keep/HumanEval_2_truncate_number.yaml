name: HumanEval_2_truncate_number
language: rkt
prompt: "#lang racket\n\n;; Given a positive floating point number, it can be decomposed\
  \ into\n;; and integer part (largest integer smaller than given number) and decimals\n\
  ;; (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n\
  ;; >>> truncate_number(3.5)\n;; 0.5\n(define (truncate_number number)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n\
  \    (check-equal? (candidate 3.5) 0.5)\n    (check-equal? (candidate 1.25) 0.25)\n\
  \    (check-equal? (candidate 123.0) 0.0)\n))\n\n(test-humaneval)"
completions: ["  (/ (- number 1) number))\n", "  (/ (- number) (floor number)))\n",
  "  (let loop ((x number) (y 1.0) (n 0.0))\n    (cond\n      ((< x 0.0) 0.0)\n  \
    \    ((< (- x) 1.0) (- y))\n      ((< y 0.0) 0.0)\n      (else (let ((m (truncate\
    \ x)))\n                (loop (- x m) (- y (m * n)) n))\n      )\n    )\n  )\n\
    )\n", "  (/ (- number) 1))\n", "  (let ([number (floor number)])\n    (/ (number\
    \ 1.0) number)))\n", "  (quotient number 1.0 1.0))\n", "  (/ number 1))\n", " \
    \ (/ (- number 1)\n     (floor number))\n  )\n", "  (/ number 100))\n", "  (letrec\n\
    \    ((divide-by-one\n      (lambda (n)\n        (if (zero? n)\n            (/\
    \ 1 number)\n            (* n number))))\n     (decimal\n      (lambda (p q)\n\
    \        (if (zero? p)\n            (/ 1 q)\n            (* p q))))\n    ; Compute\
    \ integer part\n    (let ((integer 0))\n      (for ((i integer) (n number))\n\
    \        (let ((quotient\n               (divide-by-one n)))\n          (if (zero?\
    \ quotient)\n              (begin\n                (set! n quotient)\n       \
    \         (set! i quotient)\n                (set! integer quotient))\n      \
    \        (set! n quotient)))\n      ;; Compute decimal part\n      (let ((decimal\
    \ 0))\n        (for ((i integer) (n number))\n          (let ((quotient\n    \
    \             (divide-by-one n)))\n            (if (zero? quotient)\n        \
    \        (begin\n                  (set! n quotient)\n                  (set!\
    \ decimal quotient))\n                (set! n quotient)))\n        (set! decimal\
    \ decimal))\n      decimal)))\n", "  (/ number (floor number)))\n", "  (let ((integer\
    \ (floor (* number 1.0))))\n    (+ integer 1.0)))\n", "  (quotient number (floor\
    \ number)))\n", "  (floor (- number 1) (floor (/ number 1))))\n", "  (truncate_number_iter\
    \ number 0))\n", "  (let ([integer (ceiling number)])\n    (floor number truncated)))\n",
  "  (let* ((integer-part (floor (/ number 1))) (decimal-part (- number integer-part)))\n\
    \    (* integer-part decimal-part)))\n", "  (- number (floor number)))\n", " \
    \ (/ (- number 1) (floor number)))\n", "  (modulo (floor (/ number 10)) 10))\n",
  "  (floor number))\n", "  (truncate number 0.0))\n", "  (let ([integer (floor (/\
    \ number 1))])\n    (if (< integer 0)\n        0\n        (/ integer 1)\n    \
    \  )\n  )\n)\n", "  (/ (- number) 1))\n", "  (let ([integer (floor (/ number 1))])\n\
    \    (cond [(> number integer) integer]\n          [else number])))\n", "  (/\
    \ (- number 1) 1))\n", "  (let ([ipart (floor number)])\n    (if (= ipart number)\n\
    \        number\n        (truncate_number (- ipart (floor number)))))\n", "  (truncate\
    \ number 1.0))\n", "  (/ (- number 1) (expt 10 number)))\n", "  (if (< number\
    \ 1)\n      (/ number 1)\n      number))\n", "  (/ (- number) (- 1.0)))\n", " \
    \ (cond ((= number 0.0) 0.0)\n        (#t (/ (- number 1) (- number 1)))))\n",
  "  (if (> number 0)\n      (truncate (- number 1) 2)\n      0))\n", "  (floor number))\n",
  "  (if (>= number 0)\n      (remainder number 1)\n      number))\n", "  (floor (/\
    \ number 1)))\n", "  (/ (- number 1) (- number 1.0)))\n", "  (truncate number\
    \ 1.0))\n", "  (truncate (/ number 1) 2))\n", "  (truncate_number_helper\n   (truncate_number_helper\
    \ number 0 number)\n   number 1 0))\n", "  (if (< number (- infinity))\n     \
    \ number\n      (/ (+ 1 number) 10)))\n", "  (floor number (* 10 exponent)))\n",
  "  (truncate_number number 0.1))\n", "  (truncate_number_helper number 0 0))\n",
  "  (floor (/ (- number 1) number)))\n", "  (truncate number))\n", "  (let ((remainder\
    \ (- number 1)))\n    (* number remainder)))\n", "  (check-type number number)\n\
    \  (check-type number number)\n  (let ([int-part (floor number 10)])\n    (check-type\
    \ int-part number)\n    (check-type int-part number)\n    (check-type number number)\n\
    \    (check-type number number)\n    (floor number 10)\n    (floor number 10)\n\
    \    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number\
    \ 10)\n    (floor number 10)\n    (floor number 10)\n    (floor number 10)\n \
    \   (floor number 10)\n    (floor number 10)\n    (floor number 10)\n    (floor\
    \ number 10)\n    (floor ", "  (/ (float number) 10^18))\n", "  (check-type number\
    \ real?)\n  (let ((integer-part (floored (/ number 1)))\n        (decimal-part\
    \ (- number (floored number))))\n    (check-type decimal-part real?)\n    (/ decimal-part\
    \ (floored (expt 10 decimal-part))))))", "  (/ (- number 1) (floor number)))\n",
  "  (truncate (- number 1) 0.0))\n", "  (cond\n    [(< (float number) 1) number]\n\
    \    [else (/ (float number) 10)]))\n", "  (/ (+ number 1) number))\n", "  (floor\
    \ number (* 10 remainder)))\n", "  (/ (- number 1) number))\n", "  (truncate (/\
    \ number 1) 1.0))\n", "  (let* ((integer (floor (number))))\n    (cond\n     \
    \ [(< integer number) number]\n      [else (/ integer 10)]))))\n", "  (if (negative?\
    \ number)\n    (/ number 10)\n    (/ number 1)))\n", "  (modulo number 1.000000000000000000000)\n\
    )\n", "  (- number number))\n", "  (/ number 10))\n", "  (cond [(< number 1)\n\
    \         number]\n        [(= 0 (remainder number 1))\n         (truncate (quotient\
    \ number 1))]\n        [else (truncate (quotient number 1))]))\n", "  (- number\
    \ number))\n", "  (let ((integer-part (floor number))\n        (fraction-part\
    \ (expt number 1)))\n    (/ (- (expt integer-part 100) fraction-part) 100)))",
  "  (truncate_number_part number 0))\n", "  (define (truncate decimal length)\n \
    \   (cond [(< decimal 1) decimal]\n          [else (truncate (- decimal 1) length)]))\n\
    \  (truncate number 100))\n</code>\n<code>\n#lang racket\n", "  (modulo (floor\
    \ number) 1))\n", "  (/ (* number 1)\n     number)\n  )\n", "  (/ number\n   \
    \  (floor number))\n  )\n", "  (truncate number 10))\n", "  (/ number 100))\n",
  "  (floor number))\n", "  (let ((quotient (/ number 1)))\n    (if (>= quotient 1)\n\
    \        number\n        (truncate_number (- number quotient)))))\n", "  (if (<=\
    \ number (- 1.0))\n      number\n      (truncate_float (- 1.0) (- 1.0) number)))\n",
  "  (/ (- number 1) (abs number)))\n", "  (let ([integer (floor number)])\n    (let\
    \ ([remainder (- number integer)])\n      (/ remainder 1))))\n", "  (/ number\
    \ 1.0))\n", "  (if (= (length number) 0)\n      0\n      (/ number\n         (floor\
    \ number (ceiling (- number (floor number)))))\n      ))", "  (/ (floor number)\
    \ 100))\n", "  (cond [(< number 0.0)\n         number]\n        [(> number 0.0)\n\
    \         (round number)]\n        [else\n         (sub1 (truncate (* number 1.0)))]\n\
    \        [(> (sub1 (truncate (* number 1.0))) 0)\n         (sub1 (truncate (*\
    \ number 1.0)))]\n        [else\n         (round (truncate (* number 1.0)))]\n\
    \        [(< number (abs number))\n         (truncate (* number (abs number)))]\n\
    \        [else\n         (truncate (* number 1.0))]))\n", "  (quotient\n   (remainder\
    \ number\n              (- number (- 1.0 (remainder number 1.0))))))\n", "  (let\
    \ ([integer 0]\n        [fractional (floor number)])\n    (if (> number 1)\n \
    \       (/ fractional (floor number))\n        number)))\n", "  (let ([digits\
    \ (- number 1)])\n    (if (= digits 0) number\n      (truncate_number (quotient\
    \ number digits)))))\n", "  (if (integer? number)\n      (truncate number 256)\n\
    \      (truncate number (/ (- number 1) 1000000))))\n", "  (let loop ((count 0))\n\
    \    (let ((left (- number 1)))\n      (if (> count 2)\n          left\n     \
    \     (let ((decimal (- number (- left 1))))\n            (+ count 1)\n      \
    \      (loop decimal)))))\n", "  (let ([intpart (floor number)])\n    (cond\n\
    \      [(< number intpart)\n       (expt number intpart)\n       ]\n      [(=\
    \ number intpart)\n       number\n       ]\n      [else\n       intpart\n    \
    \   ])))\n", "  (let ((integer (floor number))\n        (decimal (- number integer)))\n\
    \    (cond\n      [(< integer 0) decimal]\n      [else (/ decimal 10)]))", " \
    \ (let ([intpart (/ number 1)])\n    (if (> intpart number)\n        number\n\
    \        (truncate_number (- number intpart)))))\n", "  (truncate number (- (expt\
    \ number 10) 10)))\n", "  (if (number? number)\n      (floor (/ number 1.0))\n\
    \      number))\n", "  (check-type number real?)\n  (let ([integer (floor (* number\
    \ 1.0))])\n    (cond\n      [(< number 1.0)\n       (truncate integer)]\n    \
    \  [else\n       (/ (- number integer) 1.0)])))\n", "  (truncate number *1000.0))\n",
  "  (/ (- number 1) (expt 2 0)))\n", "  (cond ((= (- number 1) 0) number)\n     \
    \   ((= number 0) 0)\n        (else (/ (- number 1) 10))))\n", "  (floor number\
    \ .5))\n", "  (let ((integer (floor (- number 1))))\n    (+ (/ integer 10) (-\
    \ (floor (/ number 10)) (floor (/ number 10))))))\n", "  (truncate number 0.0))\n",
  "  (let ((integer (floor (/ number 1))))\n    (if (< integer number)\n        (truncate\
    \ number integer)\n        (truncate number 0)))\n  )\n", "  (/ number 1))\n",
  "  (truncate number *10*))\n", "  (let ([integer (ceil (/ number 1.0))]\n      \
    \  [decimals (remainder (- number integer) 1.0)])\n    (cond\n      [(equal? decimal\
    \ 0.0) 0]\n      [(equal? decimal 1.0) number]\n      [(< integer decimal) (-\
    \ integer (floor (* 0.5 decimals)))]\n      [else (- number)]))\n)\n", "  (check-type\
    \ number number)\n  (let ((remainder 0))\n    (set! remainder (modulo number 10.0))\n\
    \    (check-type remainder number)\n    (set! number (floor number))\n    (check-type\
    \ number number)\n    number))\n", "  (truncate_number_helper number '() 0))\n",
  "  (if (= number 0)\n      0\n      (/ (- number) 10.0)))\n", "  (let ([int-part\
    \ (floor (/ number 1.0))]\n         [decimal-part (floor number)])\n    (round\
    \ (* 0.5 decimal-part)\n          (ceil (* 0.5 int-part) decimal-part))))\n",
  "  (/ (- number 1) (floor number)))\n", "  (if (> (abs number) 0.0) number\n   \
    \   (/ (abs number) 10.0)))\n", "  (let ([dec (modulo (floor number) 1)])\n  \
    \  (if (<= dec 1)\n        number\n        (/ number (- dec (floor dec))))))\n",
  "  (truncate number))\n", "  (/ (remainder number 1) (floor number 1)))\n", "  (truncate\
    \ number 1.0))\n", "  (floor (/ number 1)))\n", "  (if (< number 1.0)\n      (ceiling\
    \ (/ number 1.0))\n      (floor number)))\n", "  (/ (floor number) 10.))\n", " \
    \ (truncate number 10^(-(floor number 10))))\n", "  (truncate number 10))\n",
  "  (/ number (truncate number)))\n", "  (cond [(zero? number)\n         number]\n\
    \        [(zero? (floor number))\n         (floor number)]\n        [else\n  \
    \       (remainder (truncate number) 10)]))\n", "  (let ([integer (floor (/ number\
    \ 1))])\n    (+ (- number integer) (/ number integer))))\n", "  (if (< number\
    \ 0.0)\n      number\n      (truncate_number (floor (- number 1)))))\n", "  (truncate\
    \ (quotient number 1.0) 10))\n", "  (let ([i (floor (/ number 1)))\n\tr (modulo\
    \ number 1))]\n    (cond [(= r 0) 0]\n          [(< r 1) r]\n          [else 0])))\n",
  "  (truncate number\n            (floor number\n                   (floor-quotient\
    \ number 1.0))))\n", "  (truncate number 1.0))\n", "  (check-type number real?)\n\
    \  (let ([integer 0])\n    (while (< number 1)\n      (let ([remainder (modulo\
    \ number 1)])\n        (check-type remainder real?)\n        (set! integer (+\
    \ integer 1))\n        (set! number (- remainder 1)))\n      (check-type integer\
    \ real?)\n      (check-type number real?)\n      number))\n  integer)\n", "  (modulo\
    \ (floor number) 10.0))\n", "  (/ (float number) 10))\n", "  (let ([integer (floor\
    \ number)])\n    (cond\n      [(< number 0) (- integer (- number 0))]\n      [else\
    \ number]))\n)\n", "  (let ([integer (floor number)]\n        [decimal (truncate\
    \ number)])\n    (if (< decimal 1)\n        number\n        (/ integer decimal))))\n",
  "  (quotient number 1.0))\n", "  (/ (- number 1) (floor number)))\n", "  (/ (expt\
    \ number 1) 10))\n", "  (let ([exp (floor (math-exp number))])\n    (let ([remainder\
    \ (remainder number 1.0)])\n      (cond ((> exp 0)\n             (let ([remainder\
    \ (remainder remainder 1.0)])\n               remainder)))\n          ((> exp\
    \ -1)\n           (cons 0 number))\n          (else\n           (cons remainder\
    \ number))))))\n", "  (truncate number -integer-precision))\n", "  (let ([integer\
    \ (floor (/ number 1.0))])\n    (cond [(< number 1.0) 0] [else (floor number)])))\n",
  "  (cond [(number? number) (round number)]\n        [(< number 1.0) (floor (- number\
    \ 1.0))]\n        [else number]))\n", "  (truncate (/ number 1) 10^(-(bitwise-zero?\
    \ number))))\n", "  (/ number 2))\n", "  (/ number 1))\n", "  (/ (number 1) (round\
    \ (* number (- (* number (round (sqrt number))) 2)))))\n", "  (expt number 1.0))\n",
  "  (let ([exp (floor (log (- number 1)) (floor log (log (floor log (- number 1))\
    \ 10))))\n        decimal (- number exp)])\n    (/ (- number exp) decimal)))\n",
  "  (truncate_float (number . 1)))\n", "  (if (< number 1)\n      number\n      (truncate\
    \ number 1.0)))\n", "  (/ (- number 1) (expt 2 32)))\n", "  (/ number 1.0))\n",
  "  (/ (- number 1) (abs number)))\n", "  (let loop ([number number] [i 0] [r 0])\n\
    \    (if (<= i 10)\n        (loop (/ (float number) 10) (incf i) (incf r))\n \
    \       (loop (+ (/ number 10) (incf i))\n              (incf i) (incf r))))))\n",
  "  (if (<= number 1) number 0.5))\n", "  (let ((integer-part (floor (* number 1)))\n\
    \        (decimal-part (* number (expt number -integer-part)))\n        (leftover-part\
    \ (expt number -integer-part)))\n    (if (<= decimal-part 1.0)\n        decimal-part\n\
    \        (truncate_number (- leftover-part (floor decimal-part))))))\n", "  (let\
    \ ((digits (string->list number)))\n    (check-type digits list)\n    (let ((remainder\
    \ 0.0) (integer 0.0))\n      (for digit in digits\n        (cond ((not (list?\
    \ digit))\n               (error \"Expected a number but got a ~S\" digit))\n\
    \              (else (remainder (remainder * 10) (floor digit))\n            \
    \        (integer (+ integer (* 10 digit)))))\n      (/ integer remainder))))\n",
  "  (let ([integer (truncate number)])\n    (* integer number)))\n", "  (let ([integer\
    \ (floor number)\n         decimals (remainder number 1.0)])\n    (cond [(< decimal\
    \ 0.0) integer]\n          [else (- integer decimals)])))\n", "  (floor number\
    \ -. 1))\n", "  (floor number - number%))\n", "  (floor number .5))\n", "  (/\
    \ (floor number) 10))\n", "  (floor (/ (* number 1) number)))\n", "  (cond [(<\
    \ number 1.0) (* number 1.0)]\n        [else number]))\n", "  (- number (floor\
    \ number)))\n", "  (let ([integer-part (floor number 1)])\n    (let ([decimal-part\
    \ (modulo number 1)])\n      (if (>= decimal-part 0)\n          decimal-part\n\
    \          integer-part))))\n", "  (let ([remainder (remainder (* number 1.0)\
    \ 10.0)]\n        [result (truncate number 10.0)])\n    (if (< result 0.0)\n \
    \       (truncate result 10.0)\n        result)))\n", "  (if (zero? number)\n\
    \      0\n      (/ (- number 1) 10)))\n", "  (let ([integer (truncate number)]\n\
    \        [decimal (modulo number 1)]\n        [result (quotient number 1.0)])\n\
    \    (if (> decimal 0)\n        (/ (- decimal 1) result)\n        result)))\n",
  "  (if (= number 0.0)\n      (/ number 1.0)\n      (let ([integer floor (floor number)]\n\
    \            [decimal (truncate (- number floor) -10)])\n        (/ decimal 10.0))))\n",
  "  (floor number -1))\n", "  (/ (- number) 1))\n", "  (let ([integer (floor (/ number\
    \ 1))])\n    (if (= integer 0)\n        number\n        (truncate_number (- number))))\n\
    \  ;; >>> truncate_number(3.5)\n  ;; 0.5\n  )\n", "  (ceiling (/ number 1)))\n",
  "  (/ (- number 1) (Math/floor number)))\n", "  (floor number))\n", "  (let ((integer\
    \ (ceiling number)))\n    (cond [(zero? integer) number]\n          [else (float\
    \ integer)])))\n", "  (let ((decimal-part (expt number 10)))\n    (/ number decimal-part)))\n",
  "  (cond ((= 0 (modulo number 1)) #t)\n        ((= (modulo number 1) 0) #f)\n  \
    \      (#t number)))\n", "  (cond [(> number 1.0) (- number)]\n        [else (floor\
    \ (/ number 1.0))]))\n", "  (if (< number 0)\n    0\n    (floor (/ number 1e+0)\
    \  100)))\n", "  (let ([integer (floor number)] [decimals (remainder number 1.0)])\n\
    \    (if (< decimal 1)\n        decimal\n        (truncate_number decimals))))\n",
  "  (let ([integer (floor number)]\n        [decimals (remainder number integer)])\n\
    \    (if (= integer 0)\n        decimals\n        integer)))\n", "  (cond ((=\
    \ number 0) 0)\n        ((even? (modulo number 10)) (truncate_number (/ number\
    \ 10)))\n        (else number)))\n", "  (/ (truncate number) 1.0))\n", "  (truncate\
    \ number 0.0))\n", "  (truncate number integer))\n", "  (/ (- number) (expt 2\
    \ -floor-logof number)))\n", "  (/ (expt number -2)\n     (expt number 1))\n \
    \ )\n", "  (- number (floor number)))\n", "  (/ number 1.0))\n", "  (/ number\
    \ 1))\n", "  (cond ((= number 0) 0)\n        ((< number 1) number)\n        (else\
    \ (quotient number 1.0))))\n", "  (if (< number 1)\n      (- number)\n      (floor\
    \ number)))\n", "  (truncate number -))\n", "  (/ number 1.0))\n", "  (truncate_number_internal\
    \ number 1.0))\n", "  (quotient number 1.0))\n", "  (let ([integer (floor (* number\
    \ 1.0))]\n        [decimal (remainder (- number 1.0) 1.0)])\n    (if (> number\
    \ 1.0)\n        number\n        (truncate_number_helper integer decimal))))\n",
  "  (let ((integer (floor (/ number 1.0))))\n    (let ((decimal (/ number integer)))\n\
    \      (if (> decimal 0)\n          decimal\n          0))))\n", "  (let ((integer\
    \ (floor (/ number 10))))\n    (if (> integer 9)\n        (truncate_number (-\
    \ integer 10))\n        number)))\n", "  (floor number\n        (/ (- number 1)\
    \ 10)))\n", "  (floor (/ number 1.0)))\n", "  (let ((integer (round number)))\n\
    \    (let ((decimal (- number integer)))\n      (floor decimal))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
