name: HumanEval_131_digits
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the product of the\
  \ odd digits.\n;; Return 0 if all digits are even.\n;; For example:\n;; digits(1)\
  \  == 1\n;; digits(4)  == 0\n;; digits(235) == 15\n(define (digits n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n\
  \    (check-equal? (candidate 5) 5)\n    (check-equal? (candidate 54) 5)\n    (check-equal?\
  \ (candidate 120) 1)\n    (check-equal? (candidate 5014) 5)\n    (check-equal? (candidate\
  \ 98765) 315)\n    (check-equal? (candidate 5576543) 2625)\n    (check-equal? (candidate\
  \ 2468) 0)\n))\n\n(test-humaneval)"
completions: ["  (cond [(= n 0) 1]\n        [(even? (remainder n 10)) (remainder n\
    \ 10) (* 10 n)]\n        [else (* 10 n) (* 10 n) (* 10 n)]))\n", "  (if (odd?\
    \ n) (* n n) (* 0 (digits (remainder n 10))))) ;; (* n n) ~ (* n (digits (remainder\
    \ n 10))) ~ (* n (* 0 (digits (remainder n 10))))\n", "  (cond\n    [(= n 0) 1]\n\
    \    [(odd? n) (* n (digits (quotient n 2)))]\n    [else 0]))\n", "  (let ((result\
    \ 1))\n    (if (< n 10)\n        (* result n)\n        (if (odd? n)\n        \
    \    (set! result (* result 2))\n            (set! result (* result 3))\n    \
    \        (set! result (* result 4))\n            (set! result (* result 5))\n\
    \            (set! result (* result 6))\n            (set! result (* result 7))\n\
    \            (set! result (* result 8))\n            (set! result (* result 9))\n\
    \            (set! result (* result 10))\n            (set! result (* result 11))\n\
    \            (set! result (* result 12))\n            (set! result (* result 13))\n\
    \            (set! result (* result 14))\n            (set! result (* result 15))\n\
    \            (set! result (* result 16))\n            (set! result (* result 17))\n\
    \            (set! result (* result 18))\n            (set! result (* result 19))\n\
    \            (set! result (* result 20))\n            (set! result (* result 21))\n\
    \            (set! result (* result 22))\n            (set! result (* result 23))\n\
    \            (set! result (* result 24))\n            (set! result (* result 25))\n\
    \            (set! result (* result 26))\n            (set! result (* result 27))\n\
    \            (set! result (* result 28))\n            (set! result (* result 29))\n\
    \            (set! result (* result 30))\n            (set! result (* result 31))\n\
    \            (set! result (* result 32))\n            (set! result (* result 33))\n\
    \            (set! result (* result 34))\n            (set! result (* result 35))\n\
    \            (set! result (* result 36))\n            (set! result (* result 37))\n\
    \            (set! result (* result 38))\n            (set! result (* result 39))\n\
    \            (set! result (* result 40))\n            (set! result (* result 41))\n\
    \            (set! result (* result 42))\n            (set! result (* result 43))\n\
    \            (set! result (* result 44))\n            (set! result (* result 45))\n\
    \            (set! result (* result 46))\n            (set! result (* result 47))\n\
    \            (set! result (* result 48))\n            (set! result (* result 49))\n\
    \            (set! result (* result 50))\n            (set! result (* result 51))",
  "  (let loop ((n n) (result 1))\n    (if (= n 0)\n        result\n        (loop\
    \ (quotient n 10)\n              (* result (remainder n 10)))))\n  (if (even?\
    \ n)\n      0\n      (digits n)))\n", "  (if (odd? n) (* 2 (digits (rest n)))\n\
    \      (* 1 (digits (rest n))))\n</code>", "  (cond\n    [(zero? n) 0]\n    [(odd?\
    \ n) (* 10 (digits (remainder n 10)))]\n    [else (* 10 (digits (quotient n 10)))]))\n",
  "  (if (= n 0)\n      0\n      (* n (digits (remainder n 2)))))\n", "  (cond ((=\
    \ n 0) 0)\n        ((odd? n) (* n (digits (remainder n 10))))\n        (else (digits\
    \ (remainder n 10)))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't answer\
    \ the question at all.\n<|/ c |>\n<| c |>\nI agree, it doesn't directly solve\
    \ the problem, but does illustrate how to go about it. It doesn't address the\
    \ question about performance, but it doesn't require much more effort to solve\
    \ the problem than other solutions do.\n<|/ c |>\n<| a dscore=1 |>\n<code>", " \
    \ (if (= n 0)\n      0\n      (* n (digits (quotient n 10))))) ;; n is positive\n",
  "  (cond [(= (mod n 10) 0)\n         1]\n        [else (* 2 (digits ((quotient n\
    \ 10)))]))\n)\n", "  (check-type n (positive? integer))\n  (loop for x from 0\
    \ to (- n 1) while ((< x 10) collect (modulo (modulo n 10) (quotient n 10))))\n\
    \  (modulo n 10)\n)\n", "  (if (even? n)\n      (* n (digits (rest n)))\n    \
    \  0))\n", "  (if (even? n)\n      0\n      (* 1 (digits (quotient n 10))))) ;\
    \ recurse\n</code>\nIt doesn't matter too much how you name the helpers; it makes\
    \ them more readable.  But if you don't like them, you can rename them to something\
    \ else.  Or put them in a different module and use a named let binding to rename\
    \ the bindings to something more readable.\nYou might also consider using the\
    \ #:pre and #:post directives so you can put things in an order you like and get\
    \ warnings if you accidentally do something you didn't intend.  For example, you\
    \ might want to start with the even-digit factorial and then add the odds-and-their\
    \ factorials together.  But if you're careful, you can just add everything together\
    \ as you go:\n<code>", "  (if (< n 10)\n      n\n      (* n (digits (quotient\
    \ n 10))))) ;; <--- here\n</code>\nBut if you were going to use your digit procedure\
    \ anyway, then you don't need to define it separately from digits:\n<code>", " \
    \ (cond [(= n 1) 1]\n        [(= (modulo n 10) 1)\n         (* n (digits (quotient\
    \ n 10)))]\n        [else 0]))\n", "  (if (even? n) (* n 2))\n  (if (odd? n) (*\
    \ n 3))))\n", "  (let loop ((num n)\n             (product 1))\n    (if (even?\
    \ num)\n        (loop (quotient num 2) product)\n        (loop (quotient num 2)\
    \ (* product num))))))\n", "  (check-type n int)\n  (let loop ((n n) (c 0))\n\
    \    (cond\n      [(= n 0) (if (even? c) (* c c) 0)]\n      [(even? (expt n 2))\
    \ (+ c 3)]\n      [else (loop (- n 2) c)])))\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the product of the even digits in a positive integer.\
    \ For example:", "  (if (even? n)\n      0\n      (* n (digits (quotient n 2)))))\n",
  "  (cond [(= n 1) 1]\n        [else (* 2 (digits (remainder n 10)))]))\n", "  (if\
    \ (< n 0)\n      0\n      (* n (digits (/ n 2)))))\n", "  (if (= n 0) 1\n    \
    \  (* n (digits (quotient n 10))))))\n", "  (if (zero? n)\n      0\n      (* n\
    \ (digits (quotient n 10))))) ;; #lang racket\n", "  (let loop ((i n)\n      \
    \       (res 1))\n    (if (= i 0)\n        res\n        (loop (- i 2)\n      \
    \         (* res (modulo (modulo (modulo i 10) (modulo (modulo i 10) (modulo i\
    \ 10)) 10) (modulo i 10)))))))\n", "  (cond\n    ((= n 1) 1)\n    ((even? n) (*\
    \ n (digits (remainder n 2))))\n    (else (* 1 (digits (remainder n 2))))))\n",
  "  (cond [(zero? n) 0]\n        [else (+ 1 (* (digits (remainder n 10)))\n     \
    \                 (digits (remainder n 10)))]))\n", "  (if (even? n)\n      0\n\
    \      (* n (digits (quotient n 10)))))\n", "  (cond\n    ((= n 0) 0)\n    ((=\
    \ n 1) 1)\n    (else (* 0 (digits ((/ n 2) 1)))))\n", "  (if (even? (remainder\
    \ n 10))\n      (remainder n 10)\n      (* 3 (digits (remainder n 10))))\n  )\n",
  "  (if (zero? n)\n      '0\n      (let ((result '0))\n        (for ([i n])\n   \
    \       (if (odd? (modulo i 10))\n              (set! result (+ result (quotient\
    \ i 10)))\n              result)))\n      (modulo n 10)))\n", "  (if (= n 0)\n\
    \      0\n      (* n (digits (remainder n 10))))) ;; (* n (digits (remainder n\
    \ 10)))\n", "  (if (even? n)\n      (* 2 (digits (rest n)))\n      (* n (digits\
    \ (rest n))))) ;; call itself recursively on the rest of n\n", "  (if (zero? n)\n\
    \      0\n      (* n (digits (quotient n 10)))\n))\n", "  (cond [(= n 0) 1]\n\
    \        [(even? (modulo n 10)) (* n 10)]\n        [else 0]))\n", "  (check-type\
    \ n (integer-or-symbol))\n  (if (negative? n)\n      '(-)\n      (cond [(= (remainder\
    \ n 10) 0) 1]\n            [(= (remainder n 10) 10) 0]\n            [else (* 10\
    \ (digits (remainder n 10)))])))\n", "  (cond [(= n 0)\n         1]\n        [(even?\
    \ (remainder n 10))\n         (* 2 (digits (remainder n 10)))]\n        [else\n\
    \         (digits (remainder n 10))]))\n", "  (if (odd? n)\n      (* n (odd? (quotient\
    \ n 10)))\n      0))\n", "  (let loop ((n n) (result 1))\n    (cond [(= n 0)\n\
    \           (if (even? n)\n               0\n               (* result (digits\
    \ (remainder n 10))))]\n          [(even? n)\n           (loop (remainder n 10)\
    \ (* result (digits (quotient n 10))))]\n          [else\n           (loop (quotient\
    \ n 10) (* result (digits (remainder n 10))))])))\n", "  ;; If `n` is 0, then\
    \ 0 even, else return 1.\n  (remainder (remainder n 10) 2))\n", "  (cond\n   \
    \ [(= n 0) 1]\n    [(odd? n) (* n (digits (remainder n 2)))]\n    [else 0]))\n",
  "  (cond\n    [(< n 1) 0]\n    [(zero? (remainder n 2)) (* n 3)]\n    [else (* n\
    \ 4)]))\n", "  (if (even? n)\n      (/ n (* 2 digits))\n      0))\n", "  (if (=\
    \ n 0)\n      0\n      (* n\n          (digits (quotient n 10))))))\n", "  (if\
    \ (even? n)\n      (* 0 (digits (rem n 10)))\n      (* 1 (digits (rem n 10))))))\n",
  "  (if (zero? n) 0\n      (* 3 (digits (rem n 2)))))\n", "  (cond\n    [(< n 10)\
    \ 0]\n    [else (* 10 (odd? n) (digits (remainder n 10)))]))\n", "  (if (= n 0)\n\
    \      0\n      (* n (digits (n-1)))))\n", "  (cond ((< n 0) 0)\n        ((even?\
    \ n) (* n n))\n        (else (* 2 (digits (remainder n 10)))))) \n", "  (if (even?\
    \ n)\n      (/ n 2)\n      (* n 3)))\n", "  (cond\n    [(= n 1) 1]\n    [(= (odd?\
    \ n) true) 0]\n    [else (* n (digits (quotient n 2))))]))\n", "  (cond [(= n\
    \ 0) 1]\n        [(= (modulo n 10) 0) 0]\n        [else (* 2 (digits (remainder\
    \ n 10)))]))\n", "  (if (even? n) 0\n      (* n (digits (remainder n 10))))) ;;\
    \ #lang racket\n</cell>\n<cell>", "  (if (= n 0)\n      0\n      (if (even? (remainder\
    \ n 10)\n               (remainder n (remainder n 10)))\n          (* n (remainder\
    \ n (remainder n 10))\n             (remainder n 10))\n          (* n (remainder\
    \ n (remainder n 10))\n             (remainder n (remainder n 10))))))\n", " \
    \ (if (= n 0)\n      0\n      (* n (digits ((quotient n 10) 2)))))", "  (let digits\
    \ (result 1)\n    (if (= n 0)\n        result\n        (digits 0 (quotient n 10)\
    \ (* result (modulo n 10))))))\n", "  (if (= n 0) 0\n      (* 10 (digits (cdr\
    \ n))))) ;; #lang racket\n", "  (cond ((= n 0) 0)\n        ((even? (remainder\
    \ n 2)) (remainder n 2))\n        (else (digits (quotient n 2)))))\n", "  (define\
    \ (loop n m)\n    (cond [(= (modulo n 10) 0)\n           (cond [(= m 0)\n    \
    \               (* n n)]\n                 [else (loop (quotient n 10)\n     \
    \                      m)]])\n          [else (loop (quotient n 10)\n        \
    \             m)]]))\n  (loop n 0))\n", "  (let loop ((n n) (product 1))\n   \
    \ (if (even? n)\n        (loop (/ n 2)\n              (* product (quotient n 2)))\n\
    \        product)))\n", "  (if (= n 0)\n      0\n      (cond [(even? (modulo n\
    \ 10))\n             0]\n            [(odd? (modulo n 10))\n             (* 10\
    \ (digits (remainder n 10)))]\n            [else\n             (* 10 (digits (remainder\
    \ n 10)))]\n           )\n       )\n     )\n", "  (let loop ((n n))\n    (cond\n\
    \      [(= n 1) 1]\n      [(even? (modulo n 2)) 0]\n      [else (loop (quotient\
    \ n 2))])))\n", "  (cond ((= n 0) 1)\n        ((even? (remainder n 10)) (remainder\
    \ n 10))\n        (else (digits (remainder n 10)))))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 1]\n    [else\n     (* n (digits (quotient n 10 2))))]))\n",
  "  (* (modulo n 10) (modulo n 10)))\n", "  (let loop ((n n) (acc 1))\n    (cond\
    \ [(= 0 n) acc]\n          [(even? (remainder n 10))\n           (loop (quotient\
    \ n 10) (remainder n 10))]\n          [else (loop (quotient n 10) acc)])))\n",
  '  (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo n 10) (* (modulo
    n 10) (*', "  (if (= n 0)\n      0\n      (* n (digits (quotient n 2)))))\n",
  "  (if (= n 0)\n      0\n      (* n (digits ((sub1 n) 2)))))\n", "  (cond [(= n\
    \ 1) 1]\n        [(even? (modulo n 10)) (* 10 (digits (rem n 10))]\n        [else\
    \ 0]))\n", "  (if (= n 0)\n      0\n      (* n (digits (rem n 2)))))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(even? (car n)) (* 1 (digits (cdr n)))]\n    [else (* 1\
    \ (digits (cdr n)))]))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n       \
    \ [else\n         (* (mod n 10) \n             (digits (floor (/ n 10)))]))\n",
  "  (check-type n int)\n  (check-not (even? n) 'zero)\n  (check-not (odd? n) 'zero)\n\
    \  (if (zero? n)\n      1\n      (* 10 (digits (remainder n 10)))))\n", "  (if\
    \ (even? n)\n      (* 2 (digits (rem n 10)))\n      0))", "  (cond [(= n 0) 1]\n\
    \        [(even? (modulo n 10)) (digits (quotient n 10))]\n        [else 0]))\n",
  "  (cond [(= n 0) 1]\n        [(even? (remainder n 10)) (* (digits (remainder n\
    \ 10)) 2)]\n        [else 0]))\n", "  (if (= n 0)\n      0\n      (if (even? n)\
    \ (* n (digits (remainder n 2))) (remainder n 2))))\n", "  (cond ((= n 0) 1)\n\
    \        ((even? (remainder n 10)) (* 10 n))\n        (else (+ (digits (quotient\
    \ n 10))\n                 (digits (remainder n 10))))))\n", "  (* n 10))\n",
  "  (cond\n    ((= n 0) 0)\n    ((odd? (modulo n 10)) (* (digits (cdr n)) 10))\n\
    \    (else (digits (cdr n))))\n  )\n)\n", "  (if (= n 0)\n      0\n      (* n\
    \ (digits (- n 1)))))\n", "  (if (even? n)\n      (* 2 (digits (rem n 2))) (if\
    \ (= (rem n 2) 0) 0 (* 2 (digits (rem n 2)))))\n      0))\n", "  (cond [(= n 0)\
    \ 0]\n        [(even? (remainder n 10)) (* (digits (remainder n 10))\n       \
    \                         (digits (quotient n 10)))]\n        [else (digits (remainder\
    \ n 10))]))\n</code>\n<|/ a tags=racket,scheme |>\n<| a |>\nI wanted to write\
    \ a function and was looking at this problem. \nI thought the solutions would\
    \ be very elegant but they were not working well on bigger numbers such as \"\
    123123123123\" so I made a little improvement on the code by replacing the quotient\
    \ with the modulo function, which gives me the desired result of \"12312312312\"\
    .\n<code>", "  (if (even? n)\n      (/ n (round n))\n      0))\n", "  (cond [(=\
    \ n 0) 1]\n        [else (* 3 (digits (remainder n 10)))]))\n", "  (cond ((= n\
    \ 0)\n         1)\n        (else \n         (* \n          (digits (quotient n\
    \ 10))\n          (digits (quotient (quotient n 10) 10))\n         )\n       \
    \ )\n    )\n  )\n", "  (if (= n 0)\n      0\n      (* 2 (digits (remainder n)))))\
    \ ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",
  "  ; Initialize sum to 0.\n  (define sum (make-atom 0))\n  ; Initialize products\
    \ to the empty list.\n  (define products (list))\n  ; Iterate n times.  If n is\
    \ even, add the previous product to the sum.\n  (for [i (in-range n)]\n    (when\
    \ (even? i)\n      (add (get-value sum) products)\n      (set! sum (make-atom\
    \ 0))\n      (set! products nil))\n    (set! sum (+ (get-value sum) (* i (get-value\
    \ sum))))\n    ; Add this digit's product to the list of products.\n    (set!\
    \ products (cons (get-value sum) products))))\n  ; Return the last product, or\
    \ zero if all digits are even.\n  (if (null? (reverse products))\n      0\n  \
    \    (first (reverse products))))\n", "  (if (= n 0)\n      0\n      (* n (digits\
    \ (quotient n 10))))) ; n / 10\n</cell>\n<code language=racket-kernel>", "  (cond\
    \ [(< n 0) 0]\n        [(= (modulo n 10) 0) (* n 10)]\n        [else         \
    \     (+ n (* (digits 0 (modulo n 10))))]))\n", "  (cond\n    [(= n 0) 1]\n  \
    \  [else (* 2 (digits (remainder n 10)))]))\n", "  (if (even? n)\n      (floor\
    \ (/ n 10)) \n      0))\n", "  (if (= n 0)\n      0\n      (let ((sum (* 2 (digits\
    \ (n-1))))))\n        (if (= (mod n 10) 0)\n            sum\n            (* sum\
    \ (expt 10 n)))))) ;;#lang racket\n", "  (let loop ((n n)\n             (res 1))\n\
    \    (cond ((< n 10)\n           (* n n))\n          ((even? n)\n           (loop\
    \ (/ n 10)\n                 (+ res\n                     (* 3 (digits n))))))\n\
    \    (loop (quotient n 10)\n          res)))\n", "  (cond [(zero? n) 1]\n    \
    \    [(odd? n) (* n (digits (quotient n 2)))]\n        [else 0]))\n", "  (let\
    \ loop ((x n) (acc 1))\n    (if (zero? x)\n        acc\n        (loop (quotient\
    \ x 10)\n              (* x acc))))))\n", "  (if (= n 0)\n      1\n      (* n\
    \ (digits quot n))))\n", "  (let loop [p 1]\n    (if (= 0 p)\n      0\n      (*\
    \ p (loop (+ p 1) (modulo-2 n))))))\n", "  (cond [(= n 0)\n         1]\n     \
    \   [(even? (quotient n 10))\n         (* n (digits (remainder n 10)))]\n    \
    \    [else\n         (* n (digits (remainder n 10))) (* 10 n))))\n", "  (* 3 (modulo\
    \ (quotient n 10) 10) ))\n", "  (if (even? n)\n      (* 2 (digits (rem n 10)))\n\
    \      0))\n", "  (if (< n 0) 0\n      (if (< n (floor (/ n 10)))\n          (*\
    \ n (floor (/ n 10)))\n          (digits n (- n 1)))))\n", "  (cond [(= n 0) 1]\n\
    \        [(odd? (remainder n 10)) (* (digits (remainder n 10)) 2)]\n        [else\
    \ 0]))\n", "  (if (= n 0)\n      0\n      (* 1 (digit (quotient n 10))))))\n",
  "  (if (= n 0)\n      0\n      (+ (modulo (even? (modulo (* 10 (expt n 2))) 10)\
    \ (expt n 2)) 1)))\n", "  (cond\n    [(< n 0) 0]\n    [(< n 1) 1]\n    [(= (mod\
    \ n 10) 0) (* 3 (digits (rem n 10)))]\n    [else (* 3 (digits (rem n 10)))]\n\
    \  ))\n", "  (cond [(= n 0) 1]\n        [(even? (remainder n 2)) (* 2 (digits\
    \ (remainder n 2)))]\n        [else 0]))\n", "  (if (even? n)\n      0\n     \
    \ (* n (digits (remainder n 10))))) ;; recur down through the digits\n</code>\n\
    We now have a function that will calculate the digits of any number we pass it:\n\
    <code>\n> (digits 4)\n0\n> (digits 234)\n15\n> (digits 235)\n15\n> (digits 2000000000)\n\
    15\n> (digits 2147483646)\n0\n> (digits 999999999999999999999999999999999)\n0\n\
    > (digits 1000000000000000)\n0\n</code>\nWe could also write a function that will\
    \ calculate the sum of all digits in the number:\n<code>", "  (cond [(= n 0) 1]\n\
    \        [(even? n) (* n (digits (quotient n 2)))]\n        [else 0]))\n", " \
    \ (if (= n 0)\n      0\n      (* n (digits (quotient n 10))))) \n", "  (cond\n\
    \    ((= n 0) 0)\n    ((= n 1) (modulo (/ n 10) (* 2 10))))\n  (cond\n    ((=\
    \ (modulo n 10) 0)\n     (* 2 (digits ((/ n 10) 2))))\n    ((= (modulo n 10) 1)\n\
    \     (* 2 (digits ((/ n 10) 2))))\n    (else (digits ((/ n 10) 2)))))\n", " \
    \ (cond\n    ((= n 0) 0)\n    ((odd? n) (* n (digits (rem n 2))))\n    (else (digits\
    \ (rem n 1)))))\n", "  (cond\n    ((= n 0) 0)\n    ((odd? n) (even? (- n 1))\n\
    \      (* 2 (digits (quotient n 2)))))\n  )\n)\n", "  ((odd? n) (* n (digits (remainder\
    \ n 2)))))\n", "  (if (= n 0)\n      0\n      (* n (digits (rem n 2)))))\n", " \
    \ (if (= n 0) 0\n      (* n (digits (quotient n 10))))) ;; #lang racket\n", " \
    \ (if (= 0 (remainder n 10))\n      (* 10 (digits (remainder n 10)))\n      (*\
    \ n (digits (remainder (quotient n 10) 10)))))\n", "  (* 2 n))\n", "  (cond [(=\
    \ n 0) 1]\n        [(even? n) (* n digits (/ n 2))]))\n", "  (if (= n 0)\n   \
    \   0\n      (* n (digits (- (quotient n 10))))))\n", "  (if (= n 0) 0\n     \
    \ (* 10 (digits (n/ 10))))\n)\n", "  (if (> n 0)\n      (* n (digits (remainder\
    \ n 10)))\n      0))", "  (if (= n 0)\n      0\n      (* n (digits (quotient n\
    \ 10))))) ;; #lang racket\n", "  (if (= n 0)\n      0\n      (* 3 (digits (remainder\
    \ n 10))))) ; Multiply the last digit by 3, then carry.\n", "  (if (= n 0)\n \
    \     0\n      (* n (digits (quotient n 2)))))\n", "  (* 1 n))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(= (remainder n 10) 0) 0]\n    [else (* 10 (digits (remainder\
    \ n 10))]))\n  )\n", "  (cond [(< n 10) 0]\n        [(even? (quotient n 10)) (*\
    \ 10 n)]\n        [else (digits (quotient n 10))]))\n", "  (let ([dig 0])\n  \
    \  (while (< n 10)\n      (set dig (* dig n) (quotient n 10))\n      (set n (quotient\
    \ n 10)))\n    dig))\n", "  (if (= n 0)\n      0\n      (even? (remainder n 10)\n\
    \             (+ (remainder n 10) 1))))\n", "  (cond [(= (modulo n 10) 0) (* n\
    \ n)]\n        [(= (modulo n 10) 1) (* n n)]\n        [else (digits n-1)]))\n",
  "  (cond [(< n 10)      n]\n        [(even? (- n 10)) (* n (digits (quotient n 10)))]))\n",
  "  (if (< n 0)\n      0\n      (* n (digits (remainder (quotient n 10))))))\n",
  "  (if (= n 0)\n      0\n      (let loop ((n-mod n) (digits-mod n))\n        (if\
    \ (zero? n-mod)\n            0\n            (* n-mod digits-mod)))))\n", "  (cond\
    \ [(zero? n) 0]\n        [(odd? n) (* n (digits-odd n))]\n        [else (digits\
    \ n-1)]))\n", "  (cond [(= n 0) 1]\n        [(odd? (modulo n 10)) (* n (digits\
    \ (quotient n 10)))]\n        [else\n         (* n (digits (quotient n 10)))]))\n",
  "  (if (zero? n)\n      0\n      (* 10 (digits (remainder n 10)))))\n", "  (cond\
    \ [(= n 0) 1]\n        [else (* n (digits (quotient n 10)))]))\n</code>\nThe second\
    \ part of the program is to define a procedure to perform the multiplication.\
    \ To do this, we define (define (* (x y) (x y)) (* x y)) and perform the multiplication\
    \ using (* (digits n) (digits m)); we make use of the fact that we can use an\
    \ anonymous function to define the function. So we can write the function like\
    \ this:\n<code>", "  (if (= n 0)\n      0\n      (* n (digits (quotient n 10))))))\n",
  "  (if (< n 10)\n      n\n      (* 3 (digits (- (modulo n 10) 10))))) ;; Number\
    \ of the digits of n.\n", "  (if (zero? n)\n      0\n      (* n (digits (cdr n)))))\n",
  "  (let loop ((digits 1) (sum 0) (product 1) (i 0))\n    (cond\n      [(zero? n)\
    \ (if (even? sum) sum 0)]\n      [else (loop (add1 digits) (* sum 2) product (+\
    \ i 1))]\n     )))\n</code>\n<|/ a tags=racket,recursion,factorial |>\n<| c |>\n\
    Nice work. Just a tip: you could use [tail recursion](https://en.wikipedia.org/wiki/Tail_call#Tail_recursion_on_the_main_stack)\
    \ to avoid the stack overflow, if you don't want your program to blow the stack.\
    \ For example, you could do `[else (loop (add1 digits) (* sum 2) product (+ i\
    \ 1))]` as `(loop (add1 digits) (* sum 2) product (+ i 1)) (+ i 1)`.\n<|/ c |>\n\
    <| a dscore=0 |>\nOne way to do this would be to divide the input by ten, then\
    \ multiply it by itself twice:\n<code>", "  (if (zero? n) 0\n      (+ (remainder\
    \ n 10) (- (remainder n 10) 10))))\n", "  (cond [(= n 0) 1]\n        [else (*\
    \ 2 (digits (/ n 10)))]))\n", "  (if (even? n)\n      (* 2 (digits (rem n 10)))\n\
    \      0))\n", "  (remainder (* n 10) 0))\n", "  (cond\n    [(= n 0) 0]\n    [(even?\
    \ n) (* n (digits (remainder n 10)))]\n    [else (* n (digits (remainder n 10)))]))\n",
  "  (if (even? n)\n      0\n      (* n (digits (remainder n 2)))))\n", "  (if (=\
    \ n 0)\n      0\n      (even? n)))\n", "  (if (zero? n)\n      0\n      (* n (digits\
    \ (quotient n 10))))\n  )\n", "  (cond\n    [(zero? n) 1]\n    [(even? (remainder\
    \ n 10)) (* 10 (digits (remainder n 10)))]\n    [else 0]))\n", "  (if (= n 0)\n\
    \      0\n      (* n (digits (- (modulo n 10) 10))))\n  )\n", "  (if (< n 9)\n\
    \      (* n (digits (inc (remainder n 10))))\n      (* n (digits (quotient n 10)))))\
    \ ;; #lang racket\n", "  (let ((res 1))\n    (for ([i n])\n      (if (even? (-\
    \ i 1))\n          (* res i)\n          (set! res (* i (- res 1))))))\n  res)",
  "  (cond\n    [(= n 0) 1]\n    [(= (mod n 10) 0) 0]\n    [else (* 10 n)]\n  ))\n",
  "  (if (zero? n) 0\n      (* n (digits (quotient n 2)))))\n", "  (cond [(= n 0)\
    \      1]\n        [(odd? n) (* n (digits (quotient n 10)))]\n        [else  \
    \    0]))\n", "  (cond\n    [(= n 0) 1]\n    [else (* n (digits (remainder n 10)))]))\n",
  "  (cond [(< n 0) 0]\n        [else (mod n (* 3 (digits (remainder n 2))))]\n))\n",
  "  (if (< n 0)\n      0\n      (* 10 (digits (quotient n 10)))\n      )\n  )\n",
  "  (if (= n 0)\n      0\n      (* n (digits (remainder n 10))))) \n", "  (cond [(=\
    \ n 1) 1]\n        [(= (mod n 10) 0)\n         (* n (digits (quotient n 10)))]\n\
    \        [else\n         (* n (digits (quotient n 10))\n              (digits\
    \ (quotient (quotient n 10) 10)))]))\n", "  (let loop ((n n)\n             (result\
    \ 1))\n    (cond ((zero? n) (/ result 2))\n          (else (loop (quotient n 10)\
    \ (incf result))))))\n", "  (if (zero? n)\n      0\n      (* (remainder n 10)\
    \ (remainder (quotient n 10) 10))))\n", "  (let loop ((n n) (acc 1))\n    (cond\
    \ [(= n 0)\n           (cond\n            [(= (modulo n 10) 0)\n             acc]\n\
    \            [else\n             (loop (quotient n 10)\n                   (*\
    \ acc 10))])]\n          [else\n           (loop (quotient n 10)\n           \
    \      (* acc 10))]))))\n", "  (cond [(= n 0) 1]\n        [(= (modulo n 10) 2)\
    \ (* n (digits (remainder n 10)))]\n        [else 0]))\n", "  (* n (modulo n 10)))\n",
  "  (if (even? n)\n      0\n      (* 10 (digits (quotient n 10))))) ;; #lang racket\n",
  "  (if (even? n)\n      (* n (digits (rem n 2))) (* 0 (digits (rem n 1)))))\n",
  "  (assert (= n 0))\n  (if (even? n)\n      0\n      (* n (digits (/ n 2)))))\n",
  "  (cond\n    [(zero? n) 0]\n    [(zero? (remainder n 10)) 0]\n    [else (* n (digits\
    \ (remainder n 10)))))\n", "  (if (odd? n) 0 (* (modulo n 10) (* (modulo (- n\
    \ 1) 10) (digits (quotient n 10))))))\n", "  (if (positive? n)\n      (* n (odd?\
    \ (digits (/ n 2)))\n        (digits (/ n 2)))\n      0))\n", "  (* n (quotient\
    \ n 10 2)))\n", "  (cond ((= n 0)0)\n        ((odd? (modulo n 10)))\n        (else\n\
    \         (* 10 (digits (modulo n 10)))))\n", "  (cond [(= n 0) 1]\n        [(=\
    \ (modulo n 10) 0) (* n (digits (quotient n 10)))]\n        [else 0]))\n  ", " \
    \ (cond\n    [(> n 10) 0]\n    [(= (mod n 10) 0) (* 10 n)]\n    [else        \
    \ (+ 1 n (digits (/ n 10)))]))\n", "  (if (<= n 0)\n      0\n      (* n (digits\
    \ ((quotient n 10))))))\n", "  (cond [(= n 0)\n         0]\n        [(even? (modulo\
    \ n 10))\n         (* n 10)]\n        [else\n         (* 10 (digits (quotient\
    \ n 10)))]))\n", "  (* 10 (expt n 2)))\n", "  (cond [(zero? n) 0]\n        [(even?\
    \ n) (* n (digits (quotient n 2)))]\n        [else (* n (digits (quotient n 2)))]))\n",
  "  (cond\n    ((= n 0) 1)\n    ((even? (modulo n 10)) (* 10 (digits (remainder n\
    \ 10))))\n    (else (digits (quotient n 10))))))\n", "  (if (even? n)\n      0\n\
    \      (* n (digits (/ n 2)))))\n", "  (if (even? n)\n      (* n (digits (quotient\
    \ n 2)))\n      0))\n", "  (if (even? n)\n      (* 0 (mod n 10)) ; multiply by\
    \ 0 and take the modulus\n      (* 1 (mod n 10)))) ; multiply by 1 and take the\
    \ modulus\n", "  (cond [(= n 0) 1]\n        [(odd? n) (* n (digits (quotient n\
    \ 2)))]\n        [else 0]))\n", "  (cond [(= n 0) 1]\n        [(even? (modulo\
    \ n 10)) (* 3 (digits (remainder n 10)))]\n        [else (digits (remainder n\
    \ 10))]))\n", "  (cond [(< n 10) 1]\n        [else (* 10 (digits (quotient n 10)))]))\n",
  "  \n  (cond\n    ((= n 0) 0)\n    ((even? n) (* n (digits (/ n 2)))\n    ((odd?\
    \ n) (* n (digits (/ n 2))))\n    (else (error 'digits: 'n 'is odd?))))\n", " \
    \ (if (= n 0)\n      0\n      (if (even? (modulo n 10))\n          (* 10 n) (*\
    \ 10 n))\n          (digits ((quotient n 10))))))\n", "  (cond [(= n 0) 0]\n \
    \       [(even? (remainder n 2)) (remainder n 2)]))\n", "  (if (even? n)\n   \
    \   (* n (digits (rem n 2)))\n      0))\n", "  (cond [(= n 0) 1]\n        [(odd?\
    \ n) (* n (digits (quotient n 10)))]\n        [else 0]))\n", "  (if (= n 0)\n\
    \      0\n      (* n (digits-helper (- n 1)))))\n", "  (cond\n    ((= n 0) 0)\n\
    \    ((= n 1) 1)\n    ((even? (mod n 2)) (* n (digits (/ n 2))))\n    (else (*\
    \ n (digits (/ n 2))))))\n", "  (cond\n    [(= n 0) 1]\n    [(even? (modulo n\
    \ 10)) (* n (digits (quotient n 10)))]\n    [else (digits n-1)]))\n", "  (let\
    \ loop ((n n) (acc 1))\n    (if (> n 0)\n        (loop (quotient n 10) (remainder\
    \ n 10))\n        acc)))\n", "  (let ((product-digits (loop\n                \
    \          (k 0) (d 0) (product 1))))\n    (if (= d 0)\n        (- product 1)\n\
    \        (set! product-digits (cons d product-digits))\n        (set! k (+ k 1))\n\
    \        (set! d (mod n d))\n        (set! product (* product d))))\n  product-digits)\n",
  "  (cond\n    ((= n 0) 1)\n    ((= n 1) 1)\n    ((even? n) 0)\n    (else (* 10 (digits\
    \ ((- n 1)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
