name: HumanEval_102_choose_num
language: rkt
prompt: "#lang racket\n\n;; This function takes two positive numbers x and y and returns\
  \ the\n;; biggest even integer number that is in the range [x, y] inclusive. If\
  \ \n;; there's no such number, then the function should return -1.\n;; For example:\n\
  ;; choose_num(12, 15) = 14\n;; choose_num(13, 12) = -1\n(define (choose_num x y)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n\
  \    (check-equal? (candidate 12 15) 14)\n    (check-equal? (candidate 13 12) -1)\n\
  \    (check-equal? (candidate 33 12354) 12354)\n    (check-equal? (candidate 5234\
  \ 5233) -1)\n    (check-equal? (candidate 6 29) 28)\n    (check-equal? (candidate\
  \ 27 10) -1)\n    (check-equal? (candidate 7 7) -1)\n    (check-equal? (candidate\
  \ 546 546) 546)\n))\n\n(test-humaneval)"
completions: ["  (cond [(> x y) -1]\n        [(even? (remainder x y))\n         (+\
    \ (remainder x y) 1)]\n        [else (choose_num (+ x 1) y)]))\n", "  (let ([smaller\
    \ (min x y)]\n        [greater(max x y)]\n        [even (= x y)]\n        [biggest\
    \ (if even (- x y) -1)])\n    (cond\n      [(= small greater) biggest]\n     \
    \ [(= smaller even) (if (even? small) biggest biggest)]\n      [(= smaller even)\
    \ (if (even? small) biggest (choose_num smaller even))]\n      [(= smaller even)\
    \ (if (even? small) -1 (choose_num smaller even))]\n      [else (if (even? small)\
    \ -1 (choose_num smaller even))])))\n</code>\n<|/ a dscore=0 |>\n<| a tags=scheme,racket\
    \ dscore=0 |>\nI am going to leave my solution here, because it is not the one\
    \ I asked for and it can help some people who read this later.\n<code>", "  (cond\
    \ ((> x y) -1)\n        (even? (expt x 2)) (* 2 x))\n        (even? (expt y 2))\
    \ (* 2 y)))\n", "  (cond ((< x y) -1)\n        (else\n         (cond ((< y x)\
    \ (+ x y))\n               (else\n               (if (even? (mod x y))\n     \
    \              (choose_num x (- y 1))\n                   (choose_num (+ x 1)\
    \ y)))))))\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe simplest recursive solution\
    \ is to use a pair of (simple) predicates:\n<code>", "  (cond [(= x y) x]\n  \
    \      [(even? (modulo x y)) (modulo x y)])\n        [else -1]))\n", "  (cond\n\
    \    [(or (= x y) 0)\n     (if (= x y) -1 (+ (- x) (* 2 y)))]\n    [(or (= x y)\
    \ 0)\n     (if (even? x)\n         (cond [(even? (+ x y))\n                (if\
    \ (even? y)\n                    (- y (* 2 x))\n                    (- x (* 2\
    \ y)))]\n               [else\n                (- x (* 2 y)))]\n         [else\n\
    \          (- y (* 2 x))])]))\n", "  (cond [(<= x y) -1]\n        [(even? (modulo\
    \ x y)) (modulo x y)]\n        [else (choose_num (+ x 1) y)]))\n", "  (cond ((>=\
    \ x y) (error \"x must be lesser than y\")) (even? (remainder x 2)) (even? (remainder\
    \ y 2)) (even? (quotient x 2) (quotient y 2)) (> (quotient x 2) (quotient y 2))\
    \ (> (quotient x 3) (quotient y 3))\n        (else (error \"x must be lesser than\
    \ y\")) (>= (quotient x 2) (quotient y 2)) (> (quotient x 2) (quotient y 2)) (>\
    \ (quotient x 3) (quotient y 3))\n        (else (error \"x must be lesser than\
    \ y\")) (even? (quotient x 2) (quotient y 2)) (even? (quotient x 3) (quotient\
    \ y 3))\n        (else (error \"x must be lesser than y\")) (even? (quotient x\
    \ 2) (quotient y 2)) (even? (quotient x 3) (quotient y 3)) (even? (quotient x\
    \ 2) (quotient y 2)) (even? (quotient x 3) (quotient y 3))\n        (else (error\
    \ \"x must be lesser than y\")) (even? (quotient x 2) (quotient y 2)) (even? (quotient\
    \ x 3) (quotient y 3)) (even? (quotient x 2) (quotient y 2)) (even? (quotient\
    \ x 3) (quotient y 3))\n        (else (error \"x must be lesser than y\")) (even?\
    \ (quotient x 2) (quotient y 2)) (even? (quotient x 3) (quotient y 3)) (even?\
    \ (quotient x 2) (quotient y 2)) (even? (quotient x 3) (quotient y 3))\n     \
    \   (else (error \"x must be lesser than y\")) (even? (quotient x 2) (quotient\
    \ y 2)) (even? (quotient x 3) (quotient y 3)) (even? (quotient x 2) (quotient\
    \ y 2)) (even? (quotient x 3) (quotient y 3))\n        (else (error \"x must be\
    \ lesser than y\")) (even? (quotient x 2) (quotient y 2)) (even? (quotient x 3)\
    \ (quotient y 3)) (even? (quotient x 2) (quotient y 2)) (even? (quotient x 3)\
    \ (quotient y 3))\n        (else (error \"x must be lesser than y\")) (even? (quotient\
    \ x 2) (quotient y 2)) (even? (quotient x 3) (quotient y 3)) (even? (quotient\
    \ x 2) (quotient y 2)) (even? (quotient x 3) (quotient y 3))", "  (cond\n    ((>\
    \ x y) -1)\n    ((= x y) 0)\n    ((= x y) 0)\n    ((= y 0) 0)\n    ((= x y) (*\
    \ x y))\n    ((< x y) -1)\n    ((< y 0) -1)\n    ((< x y) -1)\n    ((< y 0) -1)\n\
    \    (else (max (ceil (/ x y)) (ceil (/ y x))) (/ x y))))\n", "  (cond ((>= x\
    \ y) -1)\n        ((even? x) x)\n        (else (choose_num (+ x 1) y))))\n</code>\n\
    <|/ a tags=racket |>\n<| a dscore=1 |>\n<code>\n#lang racket\n", "  (cond [(<\
    \ x y) -1]\n        [(= x y) 0]\n        [(even? x) x]\n        [(even? y) y]\n\
    \        [else (choose_num (+ x 2) (+ y 1))]))\n", "  (if (= x y)\n      x\n \
    \     (if (even? (modulo x y))\n          (modulo x y)\n          -1))))\n", " \
    \ (cond\n    [(> x y) -1]\n    [(= x y) x]\n    [(= y 0) -1]\n    [(even? x) (*\
    \ x 2)\n     (even? y) (* y 2)]\n    [else (max (choose_num (- x 1) (- y 1)) (choose_num\
    \ (- x 1) y))]))\n</code>\n<|/ a dscore=0 tags=scheme,lisp |>\n<| a tags=scheme,lisp\
    \ |>\nHere is my solution in Racket. The input list must be sorted (ascending)\
    \ before calling my function.\n<code>", "  (cond ((= x y) #t)\n        ((even?\
    \ x) (= (/ x 2) y))\n        (else (- x (+ x 1)))))\n", "  (if (or (< x y) (<\
    \ y x)) -1 x))\n", "  (cond ((or (= x y) (= y 0)) (- 1))\n        ((= x 0) -1)\n\
    \        ((= y 0) -1)\n        ((= (- x 1) (- y 1))\n         (cond ((= (modulo\
    \ x 2) 0) (- 1))\n              ((= (modulo x 2) 1)\n               (cond ((=\
    \ (modulo y 2) 0) (- 1))\n                     ((= (modulo y 2) 1)\n         \
    \            (= x y)\n                     (else (- x))))))\n        (else (-\
    \ x)))\n  )\n", "  (cond [(< x y) -1\n         (= x y) 0]\n        [(< x y) 0]\n\
    \        [else (max x (max y \n                       (max -1 (+ x (/ x 2))) \n\
    \                       (max -1 (+ y (/ y 2))))))]))", "  (cond [(= x y) -1]\n\
    \        [(= (modulo x 2) 0)\n         (if (= (modulo y 2) 0)\n             x\n\
    \             (- y))]\n        [(= (modulo y 2) 0)\n         (if (= (modulo x\
    \ 2) 0)\n             y\n             (- x))]\n        [else (* x y)]))\n", " \
    \ (cond\n    [(and (positive? x) (positive? y)) (if (even? (- x y)) (- x y) -1)]\n\
    \    [(and (positive? x) (even? y)) (- x)]\n    [(and (positive? y) (even? x))\
    \ (- y)]\n    [(negative? x) (- x)]\n    [(negative? y) (- y)]\n    [else (* -1\
    \ -1)])))\n", "  (cond\n    [(= x y) 0]\n    [(even? x) (cons x y)] \n    [else\
    \ (cons (- x) (- y))]))\n", "  (cond\n    ((< x y) -1)\n    ((= (mod x 2) 0) 0)\n\
    \    ((= (mod x 2) 1) (+ x 1))\n    (else (choose_num (+ x 1) y))))\n", "  (let\
    \ ([z (+ x y)]\n        [a (floor x)\n        b (floor y)])\n    (cond [(< z a)\n\
    \           -1]\n          [(< z b)\n           -1]\n          [(= (mod z 2) 0)\n\
    \           (+ a b)]\n          [else\n           (choose_num x b)]))\n  )\n",
  "  (cond ((and (integer? x) (integer? y)) \n         (if (= x 0)\n             (-\
    \ y 1)\n             (max (- x 1) (- y 1))))\n        ((or (= x 0) (= y 0))\n\
    \         (- x 1))\n        ((integer? x) x)\n        ((integer? y) y)\n     \
    \   (else\n         (max (choose_num (- x 1) x) (choose_num x \n             \
    \                                  (- y 1))))))\n", "  (cond ((= x y) 0)\n   \
    \     ((and (positive? x) (positive? y)) (if (even? (- x y)) (- x y) (- x y)))))\n\
    \    ", "  (cond [(= x y) -1 (= (floor (/ x y)) 0) (/ x y) y]\n        [(and (=\
    \ x y) (= (floor (/ x y)) 0)) 0 (/ x y)]\n        [else (/ x y) (choose_num (+\
    \ x 1) (+ y 1))]))\n", "  (cond [(> x y) -1]\n        [(= (mod x 2) 0) (* x y)]))\n",
  "  (cond ((< x y) -1)\n        ((= x y) x)\n        (else (cond ((= (mod x y) 0)\n\
    \                     (+ (/ x y) (* 2 y)))\n                    (else (choose_num\
    \ (+ x 1) y))))))\n", "  (cond [(= x y) x]\n        [(= x y) (modulo-integer (-\
    \ (quotient x y) 2))]\n        [else -1]))\n", "  (cond\n    [(and (<= x y) (-\
    \ (quotient x 2) (- (quotient y 2))))\n      (* 2 (quotient x 2))]\n    [(and\
    \ (<= y x) (- (quotient y 2) (- (quotient x 2))))\n      (- (quotient y 2) (*\
    \ 2 (quotient x 2)))]\n    [(and (<= x y) (- (quotient y 2) (- (quotient x 2))))\n\
    \      (- (quotient x 2) (* 2 (quotient y 2)))]\n    [(and (<= y x) (- (quotient\
    \ x 2) (- (quotient y 2))))\n      (- (quotient y 2) (* 2 (quotient x 2)))]\n\
    \    [else\n      -1]))", "  (if (>= x y)\n      -1\n      (if (even? x)\n   \
    \       (if (even? y)\n              (max (min x y) y)\n              (max (min\
    \ x y) y))\n          (if (even? y)\n              (max (min x y) y)\n       \
    \       (max (min x y) y)))\n      (max (min x y) y)))\n  )\n", "  (cond ((> x\
    \ y) -1)\n        ((= (modulo x 2) 0) (+ (modulo y 2) 1))\n        ((= (modulo\
    \ x 2) 1) (choose_num (+ y 1) x))\n        (else -1)))\n", "  (cond\n    [(< x\
    \ y) (-1 (car biggest))]\n    [(= x y) (-1 (car biggest))]\n    [else (cons (floor\
    \ (* (floor x y) (floor x y)))\n                (choose_num (+ x 1) y))]))\n",
  "  (cond [(< x y) -1]\n        [(= x y) x]\n        [else (max (expt x 2)\n    \
    \              (expt y 2))]))\n", "  (cond\n    [(and (<= x y) x) (+ x 1)]\n \
    \   [(and (<= y x) x) x]\n    [else -1]))\n", "  (cond [(or (< x y) \n       \
    \      (< y x))\n         -1\n         (or (= (modulo x 2) 0)\n             (=\
    \ (modulo y 2) 0))]\n        [(or (> x y) \n             (> y x))\n         (+\
    \ x y)\n         (+ (modulo x 2)\n            (modulo y 2))]\n        [else x]))\n",
  "  (cond [(<= y x) -1 (if (even? (- x y)) (- x y) (* x y))])\n        [ else (choose_num\
    \ (- x y) (- x y))]\n))\n", "  (cond\n    [(< x y) -1]\n    [(< y x) -1]\n   \
    \ [else (+ (- x y) (- y x) (* y x))]))\n", "  (cond [(= x y) x]\n        [(= y\
    \ x) y]\n        [(even? (- x y)) (cond (> x y) -1 (< y x))]\n        [else (error\
    \ \"Not a valid range\")]\n   )\n)\n", "  (cond\n    [(and (> x 0) (< x y)) x]\
    \ \n    [(and (> x y) (- (- x y) (* 2 y)))]\n    [else -1]))\n", "  (cond [(or\
    \ (= x y) (= y x)) -1]\n        [(= (mod x 2) 0) (+ x 2)]\n        [(= (mod x\
    \ 2) 1) (+ x 1)]\n        [else (+ x 1)]))\n", "  (cond ((= x y) (if (even? x)\
    \ (- x y) x))\n        ((even? x) (- x y))\n        (else (- x y))))\n", "  (cond\
    \ ((= x y) -1)\n        ((even? x)\n         (let ((z (max x (- x y))))\n    \
    \       (cond\n             ((even? z) (+ x y))\n             ((even? (- z 2))\
    \ (- x y))\n             (else z)))))\n        ((even? y) (+ x y)))\n</code>\n\
    <|/ a |>\n<| c |>\nThis answer is very good.  However, if you look at it carefully,\
    \ you'll notice that this function uses `even?` for its predicate.  It is best\
    \ practice to only define `even?` as either `even? #t` or `even? #f`, and not\
    \ both.\n<|/ c |>\n<| c |>\n`even?` is defined as a boolean macro in the SRFI-1\
    \ spec.  The second form is used for `odd?`, which *is* a boolean.\n<|/ c |>\n\
    <| a dscore=0 |>\nThe solution by Kyle E. Burton is very elegant, and I agree\
    \ with him and his explanation of how it works. However I believe it can be made\
    \ even more elegant by making some improvements to his implementation:\n<code>",
  "  (cond [(even? (modulo x 2)) (modulo x 2)]\n        [(even? (modulo y 2)) (modulo\
    \ y 2)]\n        [else -1]))\n", "  (cond [(< x y) -1 (> x y) 1] [else (+ 1 (/\
    \ (- x y) 2))]))\n", "  (cond [(or (< x y) (- (abs x) (abs y)) (< y 0)) -1]\n\
    \        [else (max (floor (/ (+ x y) 2))\n                   (choose_num (+ x\
    \ 2) (+ y 1))\n                   (choose_num (- x 2) y))]))\n", "  (if (< x y)\n\
    \      -1\n      (max \n        (/ (mod x 2)\n           (modulo-helper x y))\n\
    \        (modulo-helper y x))\n  )\n)\n", "  (cond ((> x y) -1)\n        ((even?\
    \ x) x)\n        ((even? (- x y)) (- x))\n        (else (choose_num (- x 1) (-\
    \ y 1)))))\n", "  (cond ((>= x y) -1)\n        ((even? y) (* y x))\n        (else\
    \ (choose_num (+ x 1) (- y 1)))))\n", "  (cond\n    [(<= x y) -1]\n    [(even?\
    \ x) (+ x 1)]\n    [else (choose_num (+ x 1) y)]))\n", "  (if (or (= x y)\n  \
    \        (= x 0))\n      -1\n      (if (even? (modulo x 2))\n          (modulo\
    \ x 2)\n          (if (odd? (modulo x 3))\n              (modulo x 3)\n      \
    \        (if (odd? (modulo x 4))\n                  (modulo x 4)\n           \
    \       (if (odd? (modulo x 5))\n                      (modulo x 5)\n        \
    \              (if (odd? (modulo x 6))\n                          (modulo x 6)\n\
    \                          (if (even? (modulo x 7))\n                        \
    \      (modulo x 7)\n                              (if (even? (modulo x 8))\n\
    \                                  (modulo x 8)\n                            \
    \      (if (even? (modulo x 9))\n                                      (modulo\
    \ x 9)\n                                      (if (even? (modulo x 10))\n    \
    \                                      (modulo x 10)\n                       \
    \                   (if (even? (modulo x 11))\n                              \
    \                (modulo x 11)\n                                             \
    \ (if (even? (modulo x 12))\n                                                \
    \  (modulo x 12)\n                                                  (if (even?\
    \ (modulo x 13))\n                                                      (modulo\
    \ x 13)\n                                                      (if (even? (modulo\
    \ x 14))\n                                                          (modulo x\
    \ 14)\n                                                          (if (even? (modulo\
    \ x 15))\n                                                              (modulo\
    \ x 15)\n                                                              (if (even?\
    \ (modulo x 16))\n                                                           \
    \       (modulo x 16)\n                                                      \
    \            (if (even? (modulo x 17))\n                                     \
    \                                 (modulo x 17)\n                            \
    \                                          (if (even? (modulo x 18))\n       \
    \                                                                   (modulo x\
    \ 18)\n                                                                      \
    \    (if (even? (modulo x 19))\n                                             \
    \                                 (modulo x 19)\n                            \
    \                                                  (if (even? (modulo x 20))\n\
    \                                                                            \
    \      (modulo x 20)\n                                                       \
    \                           (if (even? (modulo x 21))\n                      \
    \                                                                (modulo x 21)\n\
    \                                                                            \
    \          (if (even? (modulo x 22))\n                                       \
    \                                                   (modulo x 22)\n          \
    \                                                                            \
    \    (if (even? (modulo x 23))\n                                             \
    \                                                 (modulo x 23)\n            \
    \                                                                            \
    \      (if (even? (modulo x 24))\n                                           \
    \                                                       (modulo x 24)\n      \
    \                                                                            \
    \                (if (even? (modulo x 25))\n                                 \
    \                                                                     (modulo\
    \ x 25)\n                                                                    \
    \                                  (if (even? (modulo x 26))\n               \
    \                                                                            \
    \               (modulo x 26)\n                                              \
    \                                                            (if (even? (modulo\
    \ x 27))\n                                                                   \
    \                                           (modulo x 27)\n                  \
    \                                                                            \
    \                (if (even? (modulo x 28))\n                                 \
    \                                                                            \
    \     (modu", "  (cond [(= x y) x]\n        [(and (= (mod x 2) 0) (= y x)) x]\n\
    \        [(and (= (mod x 2) 0) (< (mod x y) 0)) x]\n        [else (-1 (- x y)))]))\n",
  "  (cond [(>= x y) (- 1)]\n        [(even? (rem x 2)) (max (rem x 2) (choose_num\
    \ (+ x 1) y))]))\n", "  (if (< (+ x y) y) -1\n      (let ((val (floored (+ x y)))\
    \ (diff (- x y)))\n        (if (zero? val) -1\n            (if (even? (modulo\
    \ val 2)) \n                val\n                (choose_num val diff)\n     \
    \       )\n        )\n      )\n  )\n)\n", "  (cond\n    [(<= x y) -1]\n    [(<\
    \ x y) 0]\n    [(even? x) (+ 1 (floor (sqrt ((- x y))))) ]\n    [else (choose_num\
    \ (+ x 2) y) ]\n  )\n)\n", "  (let ((\n          (a (remainder x y)) ;; a is even-divided-by-x\
    \ and remainder of x/y\n          (b (quotient x y))) ; b is odd\n        (even-divider?\
    \ b) ; b is even-divided-by-x\n        (even-number? a))) ; a is even-number\n\
    \    (cond\n      [(even-divider? a)\n       (if (even-number? b)\n          (-\
    \ b a)\n          -1)]\n      [else \n       (- a b)]))) ; otherwise\n</code>\n\
    <|/ a dscore=0 tags=scheme,racket,lisp |>\n<| c |>\n`b` is not even divided by\
    \ `x`, but it is odd.\n<|/ c |>\n<| c |>\nI edited my answer and added more comments\
    \ to the code.\n<|/ c |>\n<| a |>\n<code>", "  (if (or (< x y) (= y 0))\n    \
    \  -1\n      (+ x (* y y) (/ (- x y) 2))))\n", "  (cond\n    [(zero? x) (if (zero?\
    \ y) -1 (make-instance 'positive-integer-constructor))\n                 (make-instance\
    \ 'negative-integer-constructor))\n     ((zero? y) -1 (make-instance 'positive-integer-constructor))\n\
    \     (else (cond [(even? (modulo x y)) (make-instance 'even-integer-constructor)]\n\
    \               [else (make-instance 'odd-integer-constructor)]))]))\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=numbers,functional-programming,racket,scheme |>\n\
    Here's another option:\n<code>", "  (cond ((>= x y) (-1))\n        ((= x y) (+\
    \ x y))\n        ((even? (- x y))\n         (if (= x y)\n             (- x y)\n\
    \             (- x y)))\n        (else (+ x y))))\n", "  (cond\n    [(< x y) -1\n\
    \     (if (even? y)\n         (- y\n           (+ (- x y)\n               (remainder\
    \ x y))\n          )\n         (even? x)\n         (- x\n           (+ (- x y)\n\
    \               (remainder x y))\n          ))\n     (even? x)\n     (+ (- x y)\n\
    \        (- (remainder x y)\n            (remainder x y)))]\n    [else x]\n  \
    \ )\n  )", "  (cond ((>= x y) -1)\n        ((even? x) (max x (choose_num (+ x\
    \ 1) y)))\n        ((even? y) (max y (choose_num (+ x 1) y)))\n        (else (max\
    \ x y))))\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAn alternate solution:\n<code>",
  "  (cond ((= x y) (-1))\n        ((= (modulo x 2) 0)\n         (modulo x 2))\n \
    \       (else\n         (choose_num (+ x 1) y))))\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=racket,functional-programming |>\n<code>", "  (cond [(= x y) -1]\n \
    \       [(and (< x y) \n               (even? x))\n         (+ x 2)] \n      \
    \  [else x]))\n", "  (let ((max (biggest x y)))\n    (cond\n      [(zero? max)\
    \ -1]\n      [else max])))\n", "  (cond [(zero? x)\n         (if (zero? y)\n \
    \            -1\n             (car y))\n         ]\n        [(zero? y)\n     \
    \    (if (zero? x)\n             -1\n             (car x))\n         ]\n     \
    \   [(equal? x y)\n         (if (even? x)\n             (car x)\n            \
    \ (car y))\n         ]\n        [else\n         (if (even? x)\n             (choose_num\
    \ (car x) (car y))\n             (choose_num (car y) (cons (car x) (cdr y))))\n\
    \         ]\n        )\n)\n", "  (cond ((> x y) -1)\n        ((= y x) (+ x x))\n\
    \        ((even? (modulo x y))\n         (choose_num (+ x 1) y))\n        (else\n\
    \         (choose_num (+ x 1) y))))\n", "  (cond\n    ((< (- x) (y)) -1)\n   \
    \ ((even? (modulo x y)) (modulo x y))\n    ((even? (modulo (+ x) (- y)))\n   \
    \  (choose_num (+ x) (- y)))\n    (else -1)))\n", "  (cond\n    ((> x y) (if (even?\
    \ x) y x))\n    ((even? (modulo x 2)) (modulo x 2))\n    (else -1)))\n</code>\n\
    <|/ a tags=racket,scheme |>\n<| a tags=racket,scheme |>\n<code>", "  (cond ((=\
    \ x y) -1)\n        ((even? x) (if (> x y) x y))\n        (else (if (= x y) x\
    \ y))))\n", "  (cond\n    [(< x y) -1]\n    [(< y 0) -1]\n    [(< x y) x]\n  \
    \  [(< y y) (+ x 2)]\n    [else (+ x 2)]))\n", "  (if (or (= x 0) (= y 0))\n \
    \     -1\n      (cond\n        ((< x y) \n         (max 0 (min x y)))\n      \
    \  ((< y x) \n         (max 0 (min x y)))\n        (else \n         (max 0 (min\
    \ x (- y)))))))\n</code>\nI hope it's clear enough.\n<|/ a |>\n<| a dscore=1 tags=racket,scheme,math\
    \ |>\nI like to solve a problem like this using two approaches.\nFirst I like\
    \ to solve a problem using mathematical induction and to try to solve it using\
    \ recursion. Here is a solution that uses induction to find the maximum in an\
    \ interval:\n<code>", "  (cond\n    [(<= x y) (sub1 (add1 (even? x)))]\n    [(even?\
    \ x) (sub1 (add1 (even? y)))]\n    [else          (sub1 (add1 (even? (sub1 x))))]))\n",
  "  (cond [(= x y) -1]\n        [(and (number? x) (number? y)) (if (even? x)\n  \
    \                                    (+ x y)\n                               \
    \       (- x y))]\n        [else (- x y)]))\n", "  (cond [(<= x y) (add1 (sub1\
    \ (mult x y)))]\n        [else (sub1 (mult y x))]\n        ))\n", "  (cond\n \
    \   [(and (< x y) \n          (even? x))\n     (- x)]\n    [(and (< y x) \n  \
    \        (even? y))\n     (- y)]\n    [else\n     (- -1)]))\n", "  (cond\n   \
    \ [(or (= x y) (- (abs x) (abs y)))\n     (abs x)]\n    [(and (positive? x)\n\
    \          (positive? y))\n     (max (- x y) -1)]\n    [(and (negative? x)\n \
    \         (positive? y))\n     (max (- x y) 1)]\n    [(and (positive? x)\n   \
    \       (negative? y))\n     (max (- x y) -1)]\n    [(and (negative? x)\n    \
    \      (negative? y))\n     (max (- x y) 1)]\n    [else\n     (max (- x y) -1)]))\n",
  "  (cond\n    [(= x y) y]\n    [(< x y) x]\n    [(even? (modulo x y))\n     (cond\
    \ \n       [(= y x) x]\n       [(< y x) y]\n       [else (choose_num y x)]\n \
    \    )]\n    [else -1]))\n", "  (cond\n    [(= x y) x]\n    [(= x 0) -1]\n   \
    \ [(even? x) x]\n    [else (* x (choose_num (- x 1) y))]\n  )\n)\n", "  (cond\n\
    \    [(or (= x y) (- (+ x y) 2)) (/ x 2)]\n    [(= x y) (/ x 2)]\n    [else (/\
    \ x 2)]))\n", "  (cond ((> x y) -1)\n        ((even? x) x)\n        ((even? y)\
    \ y)\n        (else (choose_num (+ x 1) (+ y 1)))))\n", "  (cond\n    [(zero?\
    \ x) (if (zero? y) -1 -1)]\n    [(zero? y) x]\n    [else (if (even? (modulo x\
    \ y))\n               (choose_num (quotient x y) (quotient y x))\n           \
    \    (choose_num (quotient x y) y))]\n))\n", "  (cond [(and (>= x y) \n      \
    \        (= (remainder x y) 0)) \n         (remainder x y)] \n        [(and (>=\
    \ x y) \n              (= (remainder x y) 1)) \n         (- x)]))\n", "  (cond\n\
    \    ((< x y) -1)\n    ((> x y) 0)\n    ((= x y) 0)\n    (else (max (floor (*\
    \ x y)) (floor (+ (* x x) (* y y)))) )))\n", "  (let ([evens \n          (cond\
    \ ((= y x) (add1 x))\n                ((< x y) (sub1 x))\n                ((<\
    \ y x) (sub1 y))\n                (else \n                 (let ([tmp (+ (modulo\
    \ x 2) (modulo y 2))])\n                   (cond\n                    ((= tmp\
    \ 1) (add1 y))\n                    ((> tmp 1) (add1 x))\n                   \
    \ (else (choose_num x tmp))))))])\n    (cond\n      [(number? evens) evens]\n\
    \      [else -1])))\n", "  (cond ((and (>= x y) (< y 0)) -1)\n        ((= x y)\
    \ 0)\n        (else (+ 1 ((* y 2) (modulo (quotient x y) (* y y)))))\n       \
    \ ))\n", "  (cond\n    [(and (>= x y) y) y]\n    [(and (>= y x) x) x]\n    [else\
    \ -1]))\n", "  (cond [(= x y) x]\n        [(and (not (even? (- x y)))\n      \
    \         (> x y))\n         (choose_num (- x y) y)]\n        [else -1]))\n",
  "  (cond\n    [(= x y) (- 1)]\n    [(= (- x y) (quotient x y)) (* y (+ x y))]\n\
    \    [else (cons (quotient x y) \n                (choose_num (+ x y) (quotient\
    \ x y)))]))\n", "  (cond\n    ((<= x y) -1)\n    ((= x y) x)\n    ((even? x) (cond\
    \ ((= x y) (+ x y)) ((= (- x y) y) -1)))\n    (else (cond ((= (* x y) y) -1) (else\
    \ (choose_num (+ x 1) y))))))\n", "  (cond ((and (= (mod x 2) 0)\n           \
    \   (= (mod y 2) 0))\n         x)\n        ((and (= (mod x 2) 0)\n           \
    \   (= (mod y 2) 1))\n         y)\n        ((and (= (mod x 2) 1)\n           \
    \   (= (mod y 2) 0))\n         x)\n        ((and (= (mod x 2) 1)\n           \
    \   (= (mod y 2) 1))\n         y)\n        (else\n         -1))\n  )\n", "  (cond\n\
    \    [(or (= x y) (- (abs (- x y)) (abs y))) -1]\n    [else (cond [(even? (+ x\
    \ y))\n                  (cond [(<= x y) x]\n                        [(> x y)\
    \ y]\n                        [else (choose_num (+ x y) (+ y 1))])]\n        \
    \      [else (choose_num (+ x 1) (+ y 1))]))]))\n", "  (if (<= x y)\n      (if\
    \ (= (mod x 2) 0)\n          (ceiling (/ x 2))\n          (ceiling (/ x 2)))\n\
    \      (if (= (mod y 2) 0)\n          (ceiling (/ y 2))\n          (ceiling (/\
    \ y 2)))))\n", "  (cond\n    ((= x y) (-1))\n    ((= x 0)  (1))\n    ((= y 0)\
    \  (-1))\n    ((< x 0)  -1)\n    ((< y 0)  -1)\n    ((< x y)  (- (* x y)))\n \
    \   ((> x y)  (- (* y x)))\n    (else      (let ((m  (cond \n                \
    \  ((< x y)  (- (* x y)))\n                  ((> x y)  (- (* y x)))\n        \
    \          ((= x y) (/ x y))\n                  ((= y 0) (/ x y)) \n         \
    \         ((< x y) (/ y x)) \n                  (else       (/ x y))))))\n  )\n\
    )\n", "  (cond\n    ((>= x y) -1)\n    ((even? (modulo x 2)) x (modulo x 2))\n\
    \    (else (choose_num (modulo x 2) y))))\n", "  (cond ((> x y) -1)\n        ((=\
    \ (mod x 2) 0) (if (<= y x) (+ x y) y))\n        (else (choose_num (+ x 1) y))))\n",
  "  (cond ((< x y) -1)\n        ((even? x)\n         (max (floor (/ (+ x y) 2) x)))\n\
    \        ((even? y)\n         (max (floor (/ (+ x y) 2) y)))\n        (else\n\
    \         (max (floor (/ (+ x y) 2))))\n        )))\n", "  (cond\n    [(zero?\
    \ x) (negative? (+ x y))]\n    [(zero? y) (negative? (+ x y))]\n    [else (max\
    \ y (+ x y))]\n  )\n)\n</cell>\n<cell>", "  (cond ((and (>= x 0) (>= y 0))\n \
    \        (if (even? (remainder x y))\n             (remainder x y)\n         \
    \    (recur (quotient x y) y))\n         -1))\n        (else -1)))\n", "  (cond\n\
    \    [(<= x y) -1]\n    [(even? x) x]\n    [else (choose_num (add1 x) (add1 y))]\n\
    \  )\n)\n", "  (cond [(>= x y)\n         -1]\n        [(= x 0)\n         -1]\n\
    \        [(= y 0)\n         -1]\n        [(= x y)\n         (/ x 2)]\n       \
    \ [else\n         (cond\n           [(zero? (remainder x y))\n            (/ x\
    \ 2)]\n           [else\n            (choose_num (quotient x y) y)]))]))\n", " \
    \ (let ((result 0))\n    (cond\n      [(and (= x 0) (= y 0)) (return -1)]\n  \
    \    [(= x 0) (return y)]\n      [else\n       (cond [(and (> x y) \n        \
    \       (= (modulo x 2) 0)) (return (+ result 1))]\n             [(and (> y x)\n\
    \               (= (modulo y 2) 0)) (return (+ result 2))]\n             [else\
    \ (return (+ result 3))]])]))\n</code>\n<|/ a tags=scheme,function,racket dscore=1\
    \ |>\n<| a dscore=1 |>\nI took John D. Carpenter's answer but changed it to something\
    \ that is a bit easier to read, easier to understand, and easier to write for\
    \ new programmers.\n<code>", "  (cond [(> x y) -1 ]\n        [(= (modulo x 2)\
    \ 0) (modulo x 2)] \n        [(= (modulo y 2) 0) (modulo y 2)]\n        [else\
    \ x]))\n", "  (cond ((and (>= x y) (= x y)) x)\n        ((and (< x y) (= x y))\
    \ -1)\n        (else (max (+ x (quotient x y)) (max (+ y (- (quotient x y) 2))))))\n",
  "  (cond\n    [(or (= x y) (and (< x y) (< y x)))\n     (error \"The arguments should\
    \ be positive numbers\")]\n    [else\n     (let ([m1 (floor (/ x 2))\n       \
    \    m2 (floor (/ y 2))])\n       (cond\n         [(or (= m1 m2) (and (< m1 m2)\
    \ (< m2 m1))) (* -1 -1)]\n         [(= m1 m2) (* -1 m1)]\n         [else\n   \
    \       (cond [(and (= m1 0) (= m2 0))\n                  (error \"The arguments\
    \ should be positive numbers\")]\n                [(and (= m1 1) (= m2 1))\n \
    \                (* -1 1)]\n                [(and (= m1 0) (= m2 1))\n       \
    \          (* 1 -1)]\n                [(and (= m1 1) (= m2 0))\n             \
    \    (* 1 1)]\n                [else\n                 (cond [(= m1 m2)\n    \
    \                    (* (* -1 1) (+ m1 m2))]\n                       [else\n \
    \                       (* m1 m2)]))])))]))\n", "  (cond\n    ((< x y) -1)\n \
    \   ((and (even? (- x y)) (odd? (- x y)))\n     (if (odd? (- x y))\n         (-\
    \ x y)\n         (- x y)))\n    ((even? (- x y)) (- x y))\n    ((odd? (- x y))\
    \ (- x y))))\n", "  (cond\n    ((zero? x) -1)\n    ((zero? y) -1)\n    ((even?\
    \ y) (cond \n                 ((< x y) -1) (even? (- y x)))\n                \
    \ ((> x y) -1) (even? (- x y))))\n    ((odd? y) (cond \n                 ((< x\
    \ y) -1) (odd? (- y x)))\n                 ((> x y) -1) (odd? (- x y))))\n   \
    \ ((>= x y) -1)\n    ((<= x y) -1)))\n)\n</code>\n<|/ a tags=racket,scheme |>\n\
    <| c |>\nNice solution! I thought of doing the same thing, but I didn't get around\
    \ to writing it.\n<|/ c |>\n<| c |>\nWow! That is a very nice solution! I used\
    \ it as a base. Thanks for the help!\n<|/ c |>\n<| c |>\nIf you find this answer\
    \ helpful, please upvote it.  :)\n<|/ c |>\n<| c |>\nJust for fun, here's a tail-recursive\
    \ version that doesn't use any explicit recursion, just for fun: \n", "  (cond\
    \ ((= x y) -1)\n        ((even? x) (even? y))\n        (else (choose_num (+ x\
    \ 1) y))))\n", "  (cond ((and (integer? x) (integer? y)) (if (even? (car x))\n\
    \                                       (car x)\n                            \
    \           (choose_num (car x) (- y 1))))\n        ((and (integer? x) (integer?\
    \ y) (positive? x) (positive? y)) (if (even? (car x))\n                      \
    \                                           (car x)\n                        \
    \                                         (choose_num (car x) (- y 1))))\n   \
    \     ((and (integer? x) (integer? y) (positive? x) (positive? y) (positive? z))\
    \ (if (even? (car x))\n                                                      \
    \           (car x)\n                                                        \
    \         (choose_num (car x) (- y 1))))\n        ((and (integer? x) (integer?\
    \ y) (positive? x) (positive? y) (positive? z) (positive? p)) (if (even? (car\
    \ x))\n                                                                 (car x)\n\
    \                                                                 (choose_num\
    \ (car x) (- y 1))))\n        ((and (integer? x) (integer? y) (positive? x) (positive?\
    \ y) (positive? z) (positive? p) (positive? n)) (if (even? (car x))\n        \
    \                                                         (car x)\n          \
    \                                                       (choose_num (car x) (-\
    \ y 1))))\n        ((and (integer? x) (integer? y) (positive? x) (positive? y)\
    \ (positive? z) (positive? p) (positive? n) (positive? m)) (if (even? (car x))\n\
    \                                                                 (car x)\n  \
    \                                                               (choose_num (car\
    \ x) (- y 1))))\n        ((and (integer? x) (integer? y) (positive? x) (positive?\
    \ y) (positive? z) (positive? p) (positive? n) (positive? m) (positive? l)) (if\
    \ (even? (car x))\n                                                          \
    \       (car x)\n                                                            \
    \     (choose_num (car x) (- y 1))))\n        ((and (integer? x) (integer? y)\
    \ (positive? x) (positive? y) (positive? z) (positive? p) (positive? n) (positive?\
    \ m) (positive? l) (positive? x)) (if (even? (car x))\n                      \
    \                                           (car x)\n                        \
    \                                         (choose_num (car x) (- y 1))))\n   \
    \     ((and (integer? x) (integer? y) (positive? x) (positive? y) (positive? z)\
    \ (positive? p) (positive? n) (positive? m) (positive? l) (positive? x) (positive?\
    \ y)) (if (even", "  (cond ((>= x y) (error 'choose_num))\n        (else (let\
    \ ((b (+ (modulo x 2) (modulo y 2))))\n                 (if (< b 2) b (error 'choose_num)))))\n",
  "  (cond\n    [(> (modulo x y) 0) x]\n    [(< (modulo x y) y) y]\n    [else -1]))\n",
  "  (cond\n    [(zero? x) (if (zero? y) -1 -1)]\n    [(even? (- x y)) x]\n    [else\
    \ (choose_num (- x y) y)]))\n", "  (let ([z (* x y)]\n        [a 1]\n        [b\
    \ x])\n    (if (>= z y)\n        -1\n        (if (even? z)\n            (+ a z)\n\
    \            (if (= (- z y) z)\n                (+ a b)\n                (- a\
    \ b))))))\n", "  (cond\n    ((= x y) -1)\n    ((odd? x) x)\n    ((odd? y) y)\n\
    \    ((> x y) -1)\n    ((< x y) -1)\n    ((= x y) (+ 1 (/ x y)))\n    ((< x y)\
    \ (choose_num (- x y) y))))\n", "  (cond\n    ((or (>= x y) (- (- y x) 1))\n \
    \    (if (even? x)\n         (min x y)\n         (- y)))\n    (else\n     (if\
    \ (even? x)\n         (- y)\n         (- x)))))\n", "  (cond\n    ((and (positive?\
    \ x) (positive? y)) (max x y))\n    ((and (positive? x) (negative? y)) (min x\
    \ y))\n    ((and (negative? x) (positive? y)) (max x y))\n    ((and (negative?\
    \ x) (negative? y)) (min x y))\n    ((and (negative? x) (positive? y)) -1)\n \
    \   ((and (positive? x) (negative? y)) -1)\n    ((and (positive? x) (positive?\
    \ y)) (max x y))\n    ((and (negative? x) (negative? y)) (min x y))\n    ((and\
    \ (negative? x) (positive? y)) -1)\n    ((and (negative? x) (negative? y)) -1)\n\
    \    ((and (positive? x) (positive? y)) (max x y))\n    ((and (negative? x) (positive?\
    \ y)) (min x y))\n    ((and (positive? x) (negative? y)) (max x y))\n    ((and\
    \ (negative? x) (positive? y)) (min x y))\n    ((and (negative? x) (negative?\
    \ y)) (max x y))\n    ((and (negative? x) (positive? y)) -1)\n    ((and (positive?\
    \ x) (negative? y)) -1)\n    ((and (negative? x) (negative? y)) -1)\n    ((and\
    \ (positive? x) (positive? y)) (max x y))\n    ((and (negative? x) (positive?\
    \ y)) (min x y))\n    ((and (positive? x) (negative? y)) (max x y))\n    ((and\
    \ (negative? x) (negative? y)) (min x y))\n    ((and (negative? x) (positive?\
    \ y)) -1)\n    ((and (positive? x) (negative? y)) -1)\n    ((and (negative? x)\
    \ (positive? y)) -1)\n    ((and (positive? x) (positive? y)) (max x y))\n    ((and\
    \ (negative? x) (negative? y)) (min x y))\n    ((and (negative? x) (positive?\
    \ y)) (max x y))\n    ((and (positive? x) (negative? y)) (min x y))\n    ((and\
    \ (negative? x) (negative? y)) (max x y))\n    ((and (negative? x) (positive?\
    \ y)) -1)\n    ((and (positive? x) (negative? y)) -1)\n    ((and (negative? x)\
    \ (positive? y)) -1)\n    ((and (positive? x) (positive? y)) (max x y))\n    ((and\
    \ (negative? x) (negative? y)) (min x y))\n    ((and (positive? x) (negative?\
    \ y)) (max x y))\n    ((and (negative? x) (positive? ", "  (if (= x y)\n     \
    \ x\n      (if (even? (- x y))\n          (if (= x 0)\n              -1\n    \
    \          (* x (choose_num (- x y) y)))\n          (if (= y 0)\n            \
    \  -1\n              (* y (choose_num (- x y) y))))))\n", "  (cond\n    [(> x\
    \ y) #f]\n    [(even? x) (even? y)]\n    [(< x y) (+ 1 (choose_num (- x y) (y)))]\n\
    \    [else -1]))\n", "  (cond ((< x y) -1)\n        ((= x y) x)\n        ((< x\
    \ y) y)\n        (else (max (+ (* x 2)\n                       (if (even? (- y\
    \ x))\n                           (max (- y x) (- x 2))\n                    \
    \       (- x 2)))))))\n", "  (cond\n    ((or (< x 0) (< y 0))  -1)\n    ((<= x\
    \ y)  (/ x y))\n    ((and (<= x y) (= (mod (+ x y) 2) 0))  (+ 1 (choose_num (+\
    \ x y) y)))\n    ((and (<= x y) (= (mod (+ x y) 2) 0))  (+ 1 (choose_num (+ x\
    \ y) y))) \n    (else (choose_num (- x 1) y))))", "  (cond\n    ((> x y) -1)\n\
    \    ((even? y) x)\n    (else (choose_num (+ y 1) x))))\n", "  (cond\n    [(<\
    \ (+ x y) 2)\n     (* (/ x 2) 2)\n     x]\n    [else (cond\n             [(< (+\
    \ y x) 2)\n              (* (/ x 2) 2)\n              y]\n             [else (-\
    \ 1)])]))\n", "  (if (< x y)\n      (+ 1 (if (even? (- x y)) (- x y) (- y x)))\n\
    \      -1))\n</code>\nIt works as follows, firstly it checks whether x and y are\
    \ in the range. If they are not, then it returns -1. Then it checks whether x\
    \ is an even number. If it is not, then it returns x. If x is an even number,\
    \ then it checks whether y is an even number. If they are not, then it returns\
    \ y. If y is an even number, then it checks whether x is less than y. If they\
    \ are not, then it returns x + 1. If x is less than y, then it checks whether\
    \ y is a multiple of x and y is a multiple of x. If they are not, then it returns\
    \ -1. If x and y are in the same range, they are both the even numbers, and none\
    \ of them is less than the other number, then it returns the bigger of the two\
    \ numbers.\n<|/ a tags=racket,scheme dscore=1 |>\n<| a |>\nThe simplest solution\
    \ I came up with is to use \"fold\" to generate a list of numbers that are in\
    \ that range. Then, take that list and find the largest number in it.\n<code>",
  "  (cond ((= x y) -1)\n        ((= x 0) 0)\n        ((= x y) 0)\n        ((= y 0)\
    \ 0)\n        (else (cond ((< x y) 1)\n                  ((< x 0) 0)\n       \
    \           ((< y 0) 0)\n                  ((< (< (- x) (- y)) 2) 2)\n       \
    \           (else (- x))))))\n", "  (cond\n    ((> x y) -1)\n    ((= x y) x)\n\
    \    ((even? x) (max (+ x y) x))\n    ((even? y) (max (+ y x) y))))\n", "  (if\
    \ (> x y)\n      (if (< x 0)\n          (if (= x 0)\n              (if (= y 0)\n\
    \                  (if (= x y)\n                      y\n                    \
    \  -1)\n                  -1)\n              -1)\n          -1)\n      (if (>\
    \ x 0)\n          (if (> y 0)\n              (if (= x y)\n                  y\n\
    \                  -1)\n              -1)\n          -1)))\n", "  (if (or (< x\
    \ y) (- (- x y) y))\n      (- -1)\n      (/ (- y x) (- y (- (- x y) y))))))\n",
  "  (cond\n    [(= x y) 0]\n    [(= x 0) 1]\n    [(< x y) 2]\n    [else (- x y)]))\n",
  "  (cond ((> x y)\n         (error \"x must be greater than y\"))\n        ((even?\
    \ x)\n         (cond ((< y x)\n                (error \"y must be greater than\
    \ x\"))\n               (else (error \"x is not even and y is not even\"))))\n\
    \        (else (cond ((< y x)\n                    (error \"y must be greater\
    \ than x\"))\n                   (else (cond ((even? y)\n                    \
    \            (error \"x is not even and y is not even\"))\n                  \
    \            (else (error \"x is not even and y is not even\")))))))\n", "  (cond\
    \ ((or (< x y) (< y x))\n         -1)\n        (else (expt (- x y) 2))))\n", " \
    \ (if (and (integer? (- x y)) (not (= x y)))\n      (+ 1 (find-min (- x y) y))\n\
    \      -1))\n  )\n", "  (cond [(< x y) -1]\n        [(< y x) (cond [(even? (-\
    \ x y)) x] [(even? (- y x)) y])]\n        [else -1]))", "  (cond ((< x y) -1)\n\
    \        (else\n         (floor (max (+ (* 2 x) (floor x y)) (floor y y)))\n \
    \       )\n      )\n)\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n<| c |>\n\
    Thank you for helping out a noob! Unfortunately, I am still having trouble making\
    \ this work because I keep getting an error with your code. Can you please edit\
    \ your answer to include my code and my error? That way I can see where I am making\
    \ mistakes. Thank you very much.\n<|/ c |>\n<| c |>\nYour code works fine, but\
    \ I still keep getting an error with yours when I try to run it. I edited my original\
    \ post to include my code and error. Thanks.\n<|/ c |>\n<| c |>\nLooks like you're\
    \ using an old version of racket? The code looks fine to me. Try to update racket.\n\
    <|/ c |>\n<| c |>\nI fixed the error that I was getting, but now it says my 'choose_num'\
    \ is not defined. Is there a special thing I have to include to define it?\n<|/\
    \ c |>\n<| c |>\nYes, the problem is that you need to put your function definition\
    \ inside the definition of the module where you define `choose_num`. I've edited\
    \ the code so now it has the right indentation.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (cond [(> x y) (- 1)]\n        [(= x y) (+ x)]\n        [(even?\
    \ (- x y)) (choose_num (- x y) y)]\n        [else (choose_num (- x y) y)]))\n",
  "  (cond ((< x y) -1)\n        (else (cond ((even? (remainder x y)) (remainder x\
    \ y))\n                     (else -1)))\n  )\n)\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a |>\nHere is my solution.\n<code>\n#lang racket\n", "  (cond\n    [(<=\
    \ x y) -1]\n    [(> x y) 0]\n    [(= (mod x 2) 0) (+ x (* y (/ x 2)))]\n    [else\
    \ (* x (* y (/ x 2))) ]))\n", "  (cond\n    ((= x y) -1)\n    ((> x y) -1)\n \
    \   ((= (modulo x 2) 0) (modulo y 2) (modulo x 2))\n    ((> x y) (- (modulo x\
    \ 2) (modulo y 2)))\n    (else x)))\n", "  (cond ((or (< x y) (- (- x y) y))\n\
    \         (error \"Invalid range.\"))\n        ((even? y)\n         (if (equal?\
    \ y x)\n             (error \"Not the same number.\")\n             (if (< y (-\
    \ x y)) (- x y)))\n         (if (even? x) (- x y) (if (< x (- y)) (- x y))))\n\
    \        (else (error \"Not even.\"))))\n", "  (cond ((and (number? x) (number?\
    \ y)) \n         (if (or (>= (modulo x y) 0) \n                 (>= (modulo y\
    \ x) 0))\n             (+ (modulo x y) 1)\n             -1))\n        (else -1)))\n",
  "  (cond ((and (integer? x) \n               (>= x y))\n         (integer? x))\n\
    \        ((and (integer? y)\n               (<= y x))\n         (integer? y))\n\
    \        (else (-1))))\n", "  (cond [(or (<= x y) (< y 0)) -1]\n        [(and\
    \ (not (even? (modulo x y)))\n              (= x y))\n         (+ x (modulo x\
    \ y))\n         ]\n        [else (- x (modulo x y))]))\n", "  (if (or (< x y)\
    \ (- (+ x y) y)) -1\n      (+ (* x x) (log (/ y y))))) \n", "  (cond\n    ((<\
    \ (- x y) 2) -1)\n    ((even? (modulo x 2) (modulo y 2)) (max x y))\n    (else\
    \ (choose_num (+ x 2) y))))\n", "  (cond\n    ((or (= x 0) (= y 0))\n     (error\
    \ \"x or y cannot be zero.\"))\n    ((>= x y) -1)\n    ((even? x) (even? y))\n\
    \    ((even? (+ x 1))\n     (choose-num (+ x 1) y)\n     (+ (- x 1) (choose_num\
    \ (+ x 1) y)))\n    ((even? (+ x 2))\n     (choose-num (+ x 2) y)\n     (+ (-\
    \ x 2) (choose_num (+ x 2) y)))\n    ((even? (+ x 3))\n     (choose-num (+ x 3)\
    \ y)\n     (+ (- x 3) (choose_num (+ x 3) y)))\n    ((even? (+ x 4))\n     (choose-num\
    \ (+ x 4) y)\n     (+ (- x 4) (choose_num (+ x 4) y)))\n    ((even? (+ x 5))\n\
    \     (choose-num (+ x 5) y)\n     (+ (- x 5) (choose_num (+ x 5) y)))\n    ((even?\
    \ (+ x 6))\n     (choose-num (+ x 6) y)\n     (+ (- x 6) (choose_num (+ x 6) y)))\n\
    \    ((even? (+ x 7))\n     (choose-num (+ x 7) y)\n     (+ (- x 7) (choose_num\
    \ (+ x 7) y)))\n    ((even? (+ x 8))\n     (choose-num (+ x 8) y)\n     (+ (-\
    \ x 8) (choose_num (+ x 8) y)))\n    ((even? (+ x 9))\n     (choose-num (+ x 9)\
    \ y)\n     (+ (- x 9) (choose_num (+ x 9) y)))\n    ((even? (+ x 10))\n     (choose-num\
    \ (+ x 10) y)\n     (+ (- x 10) (choose_num (+ x 10) y)))\n    ((even? (+ x 11))\n\
    \     (choose-num (+ x 11) y)\n     (+ (- x 11) (choose_num (+ x 11) y)))\n  \
    \  ((even? (+ x 12))\n     (choose-num (+ x 12) y)\n     (+ (- x 12) (choose_num\
    \ (+ x 12) y)))\n    ((even? (+ x 13))\n     (choose-num (+ x 13) y)\n     (+\
    \ (- x 13) (choose_num (+ x 13) y)))\n    ((even? (+ x 14))\n     (choose-num\
    \ (+ x 14) y)\n     (+ (- x 14) (choose_num (+ x 14) y", "  (if (< x y) -1\n \
    \     (if (even? x) (+ x y)\n          (choose_num (+ x 2) y))))\n", "  (cond\
    \ [(< x y) -1]\n        [(or (= 0 (rem x 2)) (= 0 (rem y 2))) x]\n        [else\
    \ y]))\n", "  (cond ((or (< x y) (- (+ x y) y)) -1)\n        (else (max (+ x y)\
    \ ((/ x y) y)))))\n", "  (cond [(> x y) -1]\n        [(< x y) 0]\n        [(even?\
    \ y) (if (even? (modulo x y))\n                         (modulo x y)\n       \
    \                  -1)]))\n", "  (cond [(>= x y) -1]\n        [(and (= (modulo\
    \ x 2) 0)\n               (= (modulo y 2) 0))\n         (quotient x 2)]\n    \
    \    [else\n         (quotient x 1)]))\n", "  (cond\n    ((and (integer? x) (integer?\
    \ y)) \n      (if (< (expt x 2) (expt y 2))\n          (expt x 2)\n          (expt\
    \ y 2))\n      (if (= x 0)\n          -1\n          (if (= y 0)\n            \
    \  -1\n              (+ x y))))\n    ((and (integer? x) (= x 1))\n      (if (<\
    \ y 1)\n          -1\n          (+ 1 (expt x y))))\n    ((and (integer? y) (=\
    \ y 1))\n      (if (< x 1)\n          -1\n          (+ 1 (expt x y))))\n    ((and\
    \ (integer? x) (= x 2)) (if (< y 2)) -1)\n    ((and (integer? y) (= y 2)) (if\
    \ (< x 2)) -1)\n    ((and (integer? x) (= x 2)) (if (< y 2)) (if (= x 1)) -1)\n\
    \    ((and (integer? y) (= y 2)) (if (< x 2)) (if (= y 1)) -1)\n    ((and (integer?\
    \ x) (= x 2)) (if (< y 2)) (if (= x 1) (= y 1))) \n    ((and (integer? y) (= y\
    \ 2)) (if (< x 2)) (if (= y 1) (= x 1))) \n    ((and (integer? x) (= x 2)) (if\
    \ (< y 2)) (if (= x 1) (= y 1)) (if (= y 1) (= x 1))) \n    ((and (integer? y)\
    \ (= y 2)) (if (< x 2)) (if (= y 1) (= x 1) (= y 1)) (if (= y 1) (= x 1) (= y\
    \ 1))) \n    ((and (integer? x) (= x 2)) (if (< y 2)) (if (= x 1) (= y 1) (= x\
    \ 1) (= y 1)) (if (= y 1) (= x 1) (= y 1) (= x 1))) \n    ((and (integer? y) (=\
    \ y 2)) (if (< x 2)) (if (= y 1) (= x 1) (= y 1) (= x 1) (= y 1) (= x 1))) (if\
    \ (= y 1) (= x 1) (= y 1) (= x 1) (= y 1) (= x 1))) \n    ((and (integer? x) (=\
    \ x 2)) (if (< y 2)) (if (= x 1) (= y 1) (= x 1) (= y 1) (= x 1) (= y 1)) (if\
    \ (= y 1) (= x 1) (= y 1) (= x 1) (= y 1) (= x 1))) (if (= ", "  (cond\n    [(or\
    \ (= x y) (x = y -1))  x]\n    [(= x y)  (- x 1)]\n    [(even? x) (+ x y)]\n \
    \   [else -1]))\n", "  (if (< (+ x y) 2)\n      (+ x y)\n      -1\n    )\n)\n",
  "  (cond ((= x y) (error \"The first number can't be greater than the second.\"\
    )) \n        ((= y 0) (error \"The second number can't be zero.\")) \n       \
    \ ((even? (+ x y))\n         (max x y)) \n        (else \n         (choose x y\
    \ '()))) ; The third argument is the initial 'stack' of numbers. The fourth argument\
    \ is a\n                    ;; predicate, that checks if a number is greater or\
    \ equal to x and \n                    ;; lesser than y. This predicate can be\
    \ changed to any other predicate\n                    ;; that returns true or\
    \ false (e.g. (>= x y) or (< x y)).\n", "  (cond ((> x y) (-1))\n        ((even?\
    \ x) (if (even? y)\n                      x\n                      (choose_num\
    \ (+ x 1) y)))\n        (else (choose_num (+ x 1) y))))\n", "  (cond\n    [(and\
    \ (>= x y) (- (modulo y x) 0)) x]\n    [else -1]))", "  (cond\n    [(or (> x y)\
    \ (-> x y))\n     -1]\n    [(< x y)\n     (if (= (mod x 2) 0)\n         (max x\
    \ y)\n         (- y x))]\n    [else\n     (if (= (mod x 2) 1)\n         (max x\
    \ y)\n         (- x y))]))\n", "  (cond [(> x y)\n         (-1)]\n        [(=\
    \ x 0)\n         (+ 1 y)] \n        [(= y 0)\n         (+ x 1)] \n        [(=\
    \ x y)\n         (if (even? (modulo x 2)) (* 2 x)\n             (if (even? (modulo\
    \ y 2)) (* 2 y)\n                   (if (even? (modulo x 3) (modulo y 3)) (* 3\
    \ x)\n                       (if (even? (modulo x 4) (modulo y 4)) (* 4 x)\n \
    \                          (if (even? (modulo x 5) (modulo y 5)) (* 5 x)\n   \
    \                            (if (even? (modulo x 6) (modulo y 6)) (* 6 x)\n \
    \                                  (if (even? (modulo x 7) (modulo y 7)) (* 7\
    \ x)\n                                       (if (even? (modulo x 8) (modulo y\
    \ 8)) (* 8 x)\n                                          (if (even? (modulo x\
    \ 9) (modulo y 9)) (* 9 x)\n                                              (if\
    \ (even? (modulo x 10) (modulo y 10)) (* 10 x)\n                             \
    \                     (if (even? (modulo x 11) (modulo y 11)) (* 11 x)\n     \
    \                                                 (if (even? (modulo x 12) (modulo\
    \ y 12)) (* 12 x)\n                                                          (if\
    \ (even? (modulo x 13) (modulo y 13)) (* 13 x)\n                             \
    \                                 (if (even? (modulo x 14) (modulo y 14)) (* 14\
    \ x)\n                                                                  (if (even?\
    \ (modulo x 15) (modulo y 15)) (* 15 x)))))))))))]))", "  (let ((z (modulo (+\
    \ x y) 2))\n        (max (+ x y) 0))\n    (if (= z 0)\n        -1\n        (if\
    \ (= max z)\n            (modulo max 2)\n            (max max z))))\n)\n", " \
    \ (if (or (= x y)\n          (= x 0))\n      -1\n      (if (even? (remainder x\
    \ y))\n          (mod x y)\n          (choose_num (+ x 1) y))))\n", "  (cond ((and\
    \ (>= x y) \n               (>= y 0))\n         x)\n        ((and (>= y 0)\n \
    \              (< (- x y) y))\n         y)\n        (else\n         (error \"\
    Choose numbers are out of range.\")))\n          ", "  (if (>= x y)\n      -1\n\
    \      (if (even? (modulo x y))\n          (modulo x y)\n          (+ 1 (choose_num\
    \ (+ x 1) y)))))\n", "  (cond [(or (< x y) (- (- x y) y))\n         #]\n     \
    \   [(= x y)\n         (+ x y)\n         ]\n        [(= x (/ y 2))\n         (+\
    \ (* y 2)\n             (- x y))\n         ]\n        [else\n         (max \n\
    \          (choose_num (/ x 2) y)\n          (choose_num (- (* x 2) y)\n     \
    \                (/ y 2))\n         )\n         ]\n      )\n  )\n", "  (cond\n\
    \    [(= y 0) -1]\n    [(zero? (remainder x 2)) (* x y)]\n    [else (choose_num\
    \ (sub1 x) (sub1 y))]\n  )\n)\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", " \
    \ (cond\n    ((>= x y) -1)\n    ((and (>= x 0) (< x y)) (min x y))\n    ((and\
    \ (>= y 0) (< y x)) (min x y))\n    ((and (>= y 0) (< y 0)) (max x y)))\n  )\n",
  "  (if (< x y)\n      (if (even? y)\n          (if (<= x y)\n              (- y\
    \ x)\n              -1)\n          -1)\n      -1))\n", "  (cond\n    ((< (- x\
    \ y) 2) -1)\n    ((even? x) (even? (- x y)))\n    ((even? y) (even? (- x y)))\n\
    \    ((even? (- x y)) (- x y))\n    ((even? (- x y)) (- x y))))\n", "  (cond [(=\
    \ x y)    ; If they're equal, return y\n         y]         ; Otherwise, return\
    \ the biggest even number in range\n    [(= (modulo x 2) 0)\n     (max (+ x y)\
    \ 1)]])) ; If x is odd, return (max x y)\n", "  (cond\n    ((> x y) -1)\n    ((=\
    \ x y) x)\n    ((even? x) (max (x y) (choose_num (+ x y) y)))\n    ((even? y)\
    \ (max (x y) (choose_num (+ x y) y)))\n    (else (choose_num (+ x y) y))))\n",
  "  (cond ((and (<= x y) 0) -1)\n        ((even? y) y)\n        (else (choose_num\
    \ (+ x 1) y))))\n", "  (if (< x y)\n      (if (even? (modulo x 2))\n         \
    \ (- x)\n          (choose_num (+ x 1) y))\n      (if (even? (modulo y 2))\n \
    \         (- y)\n          (choose_num (+ y 1) x)))\n  )\n)", "  (cond ((< x y)\
    \ -1)\n        ((< y x) -1)\n        (else (cond\n              ((zero? x) (<\
    \ y x))\n              ((even? (- x y)) (- x y))\n              (else (choose_num\
    \ (- x y) y))))))\n", "  (cond\n    [(= x y) (cond [(= x 0) -1] [else (+ 1 (choose_num\
    \ (- x 1) y))])]\n    [(< x y) (cond [(= y 0) -1] [else (choose_num (- x 1) (-\
    \ y 1))])]\n    [else (if (even? (modulo x 2)) (choose_num (- x 2) y) (-1))]))\n",
  "  (cond ((= y x) #f)\n        ((= (modulo x 2) (modulo y 2)) #t)\n        (else\
    \ (choose_num (+ x 1) y))\n    )\n)\n", "  (if (= x y)\n      x\n      (if (even?\
    \ y)\n          (max x y)\n          (if (even? (+ x y))\n              (max x\
    \ y)\n              -1))))\n", "  (let loop ((x x) (y y))\n    (if (> x y)\n \
    \       -1\n        (if (even? x)\n            x\n            (loop (+ x 1) (-\
    \ y 1))))))", "  (cond ((= x y) (if (even? x) x y))\n        (else (if (< x y)\
    \ -1 (choose_num (+ x 1) y)))))", "  (cond\n    [(and (integer? (mod x 2)) (integer?\
    \ (mod y 2)))\n     (if (> (mod x 2) (mod y 2))\n         (* x y)\n         (*\
    \ y x))]\n    [(integer? (mod x 2)) (* x y)]\n    [(integer? (mod y 2)) (* y x)]\n\
    \    [else -1]))\n", "  (if (= x y) -1\n      (if (even? (modulo x y))\n     \
    \     (modulo x y)\n          (choose_num (+ x 1) y))\n      (choose_num (+ x\
    \ 1) y)))\n", "  (if (or (< x y)\n          (= x (- y)))\n      (error \"Not found\"\
    )\n      (x\n       (+ (/ x (mod x 2))\n          (/ y (mod y 2))))))\n", "  (cond\n\
    \    [(= y x) (* x x)]\n    [else (cond\n             [(= (mod y 2) 0)\n     \
    \         (if (even? (- x y))\n                  (* x y)\n                  -1)]\n\
    \             [else (if (even? (- x y))\n                  (* y x)\n         \
    \         -1)]]) ]))", "  (cond\n    ((and (number? x) (number? y)) (max x y))\n\
    \    ((and (number? x) (number? y))\n     (if (or (> x y) (x = y))\n         (let\
    \ ((x (+ x 1)))\n           (cond\n             ((even? x) (choose_num x y))\n\
    \             (else x)))))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((number?\
    \ x) (if (even? x) y x))\n    ((number? x) (if (even? x) y x))\n    ((", "  (cond\n\
    \    ((>= x y) -1)\n    ((= x 0) 0)\n    ((= y 0) 0)\n    ((even? y) (remainder\
    \ x y))\n    ((even? (quotient x y)) (choose_num (quotient x y) y))\n    (else\
    \ (choose_num (quotient x y) (remainder x y))))\n  )\n)\n", "  (cond [(and (=\
    \ x y) -1)\n         -1]\n        [(= (mod x 2) 0)\n         (* x (choose_num\
    \ (/ x 2) y))]\n        [else\n         (* x (choose_num (+ x 1) y))]))\n</code>\n\
    <|/ a tags=recursion,lisp,racket,scheme dscore=1 |>\n<| c |>\nThis doesn't seem\
    \ to work properly.  It's supposed to return 12 for choose_num(12, 15), and 12\
    \ for choose_num(12, 12), but instead it returns 24 for choose_num(12, 15) and\
    \ 13 for choose_num(12, 12).\n<|/ c |>\n<| c |>\nIt was an issue with the modulo\
    \ operator, I rewrote the solution and it should work now.\n<|/ c |>\n<| a tags=recursion,lisp,racket,scheme\
    \ |>\nTo add to the previous answers, there is a standard library function to\
    \ compute a power, which would be great for this kind of problem:\n<code>", " \
    \ (if (< (+ x y) 2)\n      (- 1)\n      (let ((x (/ x 2)))\n        (if (even?\
    \ (+ x y))\n            (- 1)\n            (+ 1 (choose_num (+ x y) y) ))))) \n",
  "  (cond\n    [(and (< x y) \n          (> x 0)\n          (> y 0)\n          (<\
    \ y x)) \n     (- x)]\n    [(and (< x y) \n          (> x 0)\n          (< y 0)\n\
    \          (> y x)) \n     (- y)]\n    [(and (< x y) \n          (> x 0)\n   \
    \       (< y 0)\n          (> y 0)) \n     (- -1)]\n    [(and (< x y) \n     \
    \     (> x 0)\n          (< y 0)\n          (> y 0)) \n     (- -1)]\n    [(and\
    \ (< x y)\n          (> x 0)\n          (< y 0)\n          (< y 0)) \n     (-\
    \ -1)]\n    [(and (< x y)\n          (> x 0)\n          (< y 0)\n          (<\
    \ y 0)) \n     (- -1)]\n    [(and (< x y)\n          (> x 0)\n          (< y 0)\n\
    \          (< y 0)) \n     (- -1)]\n    [(and (< x y)\n          (> x 0)\n   \
    \       (< y 0)\n          (< y 0)) \n     (- -1)]\n    [else (- -1)]))\n", " \
    \ (cond [(> x y) (if (= x y) -1 -1)]\n        [else (if (even? (- x y)) (- x y))]))\n",
  "  (cond\n    ((> x y) -1)\n    ((even? y) (y))\n    ((< x y) (even? (- x y)))\n\
    \    (else (even? (- x y)) (- x y))\n  ))\n", "  (cond [(> x y) -1]\n        [(=\
    \ (odd? x) (odd? y)) x]\n        [else (- x (max (ceiling y) (ceiling x))))]))\n",
  "  (if (= y x) -1\n      (if (= (modulo x 2) 0)\n          (if (= (modulo y 2) 0)\n\
    \              (- x)\n              (- y))\n          (if (= (modulo x 2) 0)\n\
    \              (- x)\n              (- y)))\n      (if (= (modulo x 2) 0)\n  \
    \        (- x)\n          (- y))))\n", "  (let ([m (+ (mod (- x y) 10) 1)])\n\
    \    (if (and (<= m x) \n             (<= m y))\n        m\n        -1)))\n",
  "  (let ([m (- x y)]\n        [d (/ x y)]\n        [m (floor m)]\n        [a (+\
    \ m d)])\n    (if (= (mod m 2) 0) (+ (- m) (- d)) -1)))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis is so much simpler than the code i wrote! I really didn't\
    \ know you could do let statements like that in Scheme. Thanks so much!\n<|/ c\
    \ |>\n<| c |>\nI added a version for general numbers, you can probably use it\
    \ as a start for your homework :)\n<|/ c |>\n<| c |>\nIf you're allowed to use\
    \ `if` instead of `cond`, you can simplify this down to `(define (choose_num x\
    \ y) (let ([m (- x y)]) (- (if (= (mod m 2) 0) (+ (- m) (- d)) -1)))`.\n<|/ c\
    \ |>\n<| c |>\nI didn't know `let` could take a list like that. But thanks for\
    \ teaching me something new!\n<|/ c |>\n<| c |>\nThank you so much! I really appreciate\
    \ it!\n<|/ c |>\n<| a tags=racket,scheme |>\nUsing Racket's #lang racket, here's\
    \ a solution that uses recursion:\n<code>", "  (cond ((> x y) -1)\n        ((=\
    \ x y) 0)\n        ((even? (modulo x 2) x) (choose_num x (+ y 1)))\n        ((even?\
    \ (modulo y 2) y) (choose_num (+ x 1) y))\n        (else (choose x y))))", " \
    \ (cond\n    ((or (< x y) (< y x)) -1)\n    ((even? (modulo x 2)) (modulo x 2))\n\
    \    (else (choose_num (+ x 2) y))))\n", "  (cond\n    [(> x y)         ; x is\
    \ greater than y\n     (if (even? x)      ; x is even?\n         (- x)       \
    \ ; return x-1 since x is even\n         -1)]        ; x is odd\n    [(even? y)\
    \         ; y is even?\n     (+ y)]        ; return y-1 since y is even\n    [else\
    \             ; both x and y are odd\n     (max (- x) (- y))]) ; return the biggest\
    \ even number in the range [x,y]\n  )\n)\n", "  (cond\n    [(= x y) -1\n     (if\
    \ (< y x) -1 -1)]\n    [(= x 0)\n     (if (= y 0) 0 (+ x 2))]\n    [(= y 0)\n\
    \     (if (= x 0) 0 (+ y 2))]\n    [(even? (- x y))\n     (if (= x y) -1\n   \
    \    (+ x 2)\n       (+ y 1))]\n    [(even? (- y x))\n     (if (= x y) -1\n  \
    \     (+ x 1)\n       (+ y 2))]\n    [else (max x y)]\n  )\n)\n", "  (cond\n \
    \   [(<= x y) -1]\n    [(= (mod x 2) 0)\n     (if (= (mod y 2) 0)\n         (+\
    \ x y)\n         -1)]\n    [else\n     (if (= (mod x 2) (mod y 2))\n         (+\
    \ x y)\n         -1)]\n   )\n  )\n", "  (if (or (= x 0) (= y 0))\n      -1\n \
    \     (cond ((< y x) -1)\n            ((< x y) -1)\n            ((= (mod x y)\
    \ 0)\n             (if (= (mod x y) (/ x y)) (* y y) (* x y))\n             (if\
    \ (= (mod x y) 1)\n                 (if (= (mod y x) (/ y x)) (* x x) (* y y))\n\
    \                 (if (= (mod y x) 1)\n                     (if (= (mod x y) (/\
    \ x y)) (* y x) (* x y))\n                     (if (= (mod x y) 1)\n         \
    \                (if (= (mod y x) (/ y x)) (* x y) (* y x))\n                \
    \         (if (= (mod y x) 1)\n                             (if (= (mod x y) (/\
    \ x y)) (* y x) (* x y))\n                             (if (= (mod x y) 1)\n \
    \                                (if (= (mod y x) (/ y x)) (* x y) (* x x))\n\
    \                                 (if (= (mod y x) 1)\n                      \
    \               (if (= (mod x y) (/ x y)) (* x x) (* x y))\n                 \
    \                    (if (= (mod x y) 1)\n                                   \
    \      (if (= (mod y x) (/ x y)) (* x y) (* x x))\n                          \
    \               (if (= (mod y x) 1)\n                                        \
    \    (if (= (mod x y) (/ x y)) (* x x) (* x y))\n                            \
    \                (if (= (mod x y) 1)\n                                       \
    \         (if (= (mod y x) (/ x y)) (* x y) (* x x))\n                       \
    \                         (if (= (mod y x) 1)\n                              \
    \                      (if (= (mod x y) (/ x y)) (* x x) (* x y))\n          \
    \                                          (if (= (mod x y) 1)\n             \
    \                                           (if (= (mod y x) (/ x y)) (* x y)\
    \ (* x x))\n                                                        (if (= (mod\
    \ y x) 1)\n                                                            (if (=\
    \ (mod x y) (/ x y)) (* x y) (* x x))\n                                      \
    \                      (if (= (mod x y) 1)\n                                 \
    \                               (if (= (mod y x) (/ x y)) (* x y) (* x x))\n \
    \                                                               (if (= (mod y\
    \ x) 1)\n                                                                    (if\
    \ (= (mod x y) (/ x y)) (* x x) (* x y))\n                                   \
    \                                 (if (= (mod x ", "  (cond [(< x y) (- 1)]\n\
    \        [(even? x)\n         (if (even? (+ x y))\n             (+ x y)\n    \
    \         (if (even? (- x y))\n                 (- x y)\n                 (* -1\
    \ -1)))]\n        [else\n         (cond [(even? (+ x y)) (+ x y)]\n          \
    \     [(even? (- x y)) (- x y)]\n               [(even? (+ y x)) (+ y x)]\n  \
    \             [(even? (- y x)) (- y x)]\n               [else (* -1 -1)])]))\n",
  "  (cond [(= y 0) -1]\n        [(and (even? (modulo x 2)) (= (modulo x y) 0)) x]\n\
    \        [else (choose_num (+ x 1) y)]))\n", "  (cond ((or (>= x y) (-not (<=\
    \ x y)))\n         (if (>= x y) y x))\n        ((even? (car x))\n         (choose_num\
    \ (car x) y))\n        ((odd? (car x))\n         (choose_num (car x) (- y)))\n\
    \        (else -1)))", "  (cond ((> (* x y) y) -1)\n        ((< y x) -1)\n   \
    \     (else (quotient x y))))\n", "  (let ([m (floor (/ (- x y) 2))]\n       \
    \ [ms (floor (* m 2))]\n        [p (/ x 2)]\n        [ps (/ y 2)]\n        [n\
    \ (- (+ x y) 2)]\n        [ns (* (- n 2) m)]\n        [es (if (= x y)\n      \
    \         (+ 1 (floor (* x y)))\n               -1)\n        ]\n        [es (if\
    \ (> x y)\n               (+ 1 (floor (* x y)))\n               -1)\n        ]\n\
    \        [r (if (> x y)\n               (* m (* p (+ 1 m)))\n               (*\
    \ m (* p (- 1 m)))\n               0)\n        ]\n        [rs (if (> x y)\n  \
    \              (* ms r (+ 1 (floor (* x y)))\n                  (* ms r (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es r (+ 1 (floor (* x y)))\n                  (* es r (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ (* x y))))\n                0)\n        ]\n        [rs (if (> x y)\n       \
    \         (* es rs (+ 1 (floor (* x y)))\n                  (* es rs (- 1 (floor\
    \ ("]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
