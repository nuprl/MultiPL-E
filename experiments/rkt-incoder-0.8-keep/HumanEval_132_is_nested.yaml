name: HumanEval_132_is_nested
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a string as input which contains\
  \ only square brackets.\n;; The function should return True if and only if there\
  \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
  \ is nested.\n;; is_nested('[[]]') \u279E True\n;; is_nested('[]]]]]]][[[[[]') \u279E\
  \ False\n;; is_nested('[][]') \u279E False\n;; is_nested('[]') \u279E False\n;;\
  \ is_nested('[[][]]') \u279E True\n;; is_nested('[[]][[') \u279E True\n(define (is_nested\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n\
  \    (check-equal? (candidate \"[[]]\") #t)\n    (check-equal? (candidate \"[]]]]]]][[[[[]\"\
  ) #f)\n    (check-equal? (candidate \"[][]\") #f)\n    (check-equal? (candidate\
  \ \"[]\") #f)\n    (check-equal? (candidate \"[[[[]]]]\") #t)\n    (check-equal?\
  \ (candidate \"[]]]]]]]]]]\") #f)\n    (check-equal? (candidate \"[][][[]]\") #t)\n\
  \    (check-equal? (candidate \"[[]\") #f)\n    (check-equal? (candidate \"[]]\"\
  ) #f)\n    (check-equal? (candidate \"[[]][[\") #t)\n    (check-equal? (candidate\
  \ \"[[][]]\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate\
  \ \"[[[[[[[[\") #f)\n    (check-equal? (candidate \"]]]]]]]]\") #f)\n))\n\n(test-humaneval)"
completions: []
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
