name: HumanEval_132_is_nested
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a string as input which contains\
  \ only square brackets.\n;; The function should return True if and only if there\
  \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
  \ is nested.\n;; is_nested('[[]]') \u279E True\n;; is_nested('[]]]]]]][[[[[]') \u279E\
  \ False\n;; is_nested('[][]') \u279E False\n;; is_nested('[]') \u279E False\n;;\
  \ is_nested('[[][]]') \u279E True\n;; is_nested('[[]][[') \u279E True\n(define (is_nested\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n\
  \    (check-equal? (candidate \"[[]]\") #t)\n    (check-equal? (candidate \"[]]]]]]][[[[[]\"\
  ) #f)\n    (check-equal? (candidate \"[][]\") #f)\n    (check-equal? (candidate\
  \ \"[]\") #f)\n    (check-equal? (candidate \"[[[[]]]]\") #t)\n    (check-equal?\
  \ (candidate \"[]]]]]]]]]]\") #f)\n    (check-equal? (candidate \"[][][[]]\") #t)\n\
  \    (check-equal? (candidate \"[[]\") #f)\n    (check-equal? (candidate \"[]]\"\
  ) #f)\n    (check-equal? (candidate \"[[]][[\") #t)\n    (check-equal? (candidate\
  \ \"[[][]]\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate\
  \ \"[[[[[[[[\") #f)\n    (check-equal? (candidate \"]]]]]]]]\") #f)\n))\n\n(test-humaneval)"
completions: ["  ;; Write a recursive function that checks if the string consists\
    \ of at least two brackets \n  ;; If it does then the function should return True.\
    \ Otherwise, return False.\n)", "  \n  (if (empty? string) #t\n    (if (equal?\
    \ (char string 0) #\\[)\n      (if (equal? (char string 1) #\\]) (is_nested (rest\
    \ string))\n      (and (equal? (char string 1) #\\])\n         (is_nested (rest\
    \ string))\n         (is_nested (rest (rest string)))))))\n", "  (or (boolean?\n\
    \          (sequence-contains? string '[[])\n          (sequence-contains? string\
    \ '[[[])\n          (sequence-contains? string '[][])\n          (sequence-contains?\
    \ string '[]\n                              (sequence-contains? string '[[])))\n\
    \      (equal? string empty)))\n", "  (define (iter stack)\n    (cond\n      [(empty?\
    \ stack)\n        (= 0 (length (rest stack)))]\n      [(= (length stack) (length\
    \ (rest stack)))\n        (equal? (car stack) '(') (iter (rest stack) (cons (cdr\
    \ stack) stack))]\n      [(< 1 (length stack))\n        (equal? (car stack) '(')\
    \ (iter (cons (car stack) stack) stack)]\n      [(< (length stack) (length (rest\
    \ stack)))\n        (equal? (car stack) (substring (second stack) (length stack)))\
    \ (iter (cons (car stack) stack) (rest stack))]\n      [else (iter (cons (car\
    \ stack) stack) (rest stack))]))\n  (iter '() string))\n</code>\nThis solution\
    \ will accept any number of brackets, but as I mentioned, you only need to encapsulate\
    \ square brackets, and then you can just check for the presence of nested brackets\
    \ in the string. You don't have to worry about checking if there are any nested\
    \ brackets elsewhere in the string.\n<|/ a tags=scheme,racket,nested-loops |>\n\
    <| a tags=scheme,racket,nested-loops dscore=0 |>\nScheme and Racket both have\
    \ looping, although Racket has much more complex syntax (a lot more control structures),\
    \ but both have looping.\nThe simplest way to loop through a list of things in\
    \ Scheme is to write an inner procedure and call that in a loop to do the looping.\
    \  So in Scheme you would write:\n<code>", "  (define (find-nested sub)\n    (let\
    \ loop ((i 0)\n               (found false)\n               (sub sub))\n     \
    \ (cond [(< i length-of-string)\n             (or (find sub string) found)\n \
    \            found]\n            [(equal? (+ i (length sub)) (length-of-string))\n\
    \             (equal? (find sub string) found)\n             found]\n        \
    \    [else\n             (loop (+ i 1) (find sub string) (sub (cdr sub)))]))\n\
    \  (loop () true string))\n", "  (cond [(= string \"\") false]\n        [(string-match\
    \ \"(?<open>\\\\[\\\\[)(?<close>\\\\]\\\\])\" string) false]\n        [(eq? (string-match\
    \ \"(?<open>\\\\[\\\\[)\" string) (string-match \"(?<close>\\\\]\\\\])\" string))\
    \ true]\n        [else (or (is_nested (string-replace \"\\\\[\\\\[\" \"\" (string-replace\
    \ \"\\\\]\\\\]\" \"\" (string->list string)))) (is_nested (string-replace \"\\\
    \\[\\\\[\" \"[]\" (string-replace \"\\\\]\\\\]\" \"[]\" (string->list string))))]))\n",
  "  (cond\n    [(empty? string) #f]\n    [(subsequence? '(') true]\n    [(subsequence?\
    \ '[') true]\n    [(subsequence? '{) true]\n    [else #f]\n  ))\n", "  (cond\n\
    \    [(string-match? '[[] string) true]\n    [(string-match? '[]] string) false]\n\
    \    [(string-match? '[] string) false]\n    [else false]))\n", "  (cond ((null?\
    \ string) #f)\n        ((equal? string '())\n         (= (length string) 0) #t)\n\
    \        ((equal? (first string) '()) (is_nested (string))) #t)\n        ((equal?\
    \ (second string) '()) (is_nested (string))) #t)\n        (else (and (is_nested\
    \ (string)) (or (equal? (first string) '[) (equal? (first string) '{')))))))\n",
  "  (define (helper string depth opening-depth)\n    (cond [(null? string)\n    \
    \       #t]\n         [else\n           (and (char-class? (first string) (first\
    \ opening-depth)) \n                (helper (rest string) depth (+ depth 1)))]\n\
    \          [else false]))\n  (helper string 0 0))\n", '  (boolean? (string->list
    string)))', "  (let loop ((pos 0) (result #f))\n    (cond ((or (char=? string\
    \ #\\) (string-length string))\n           (not result))\n          ((char=? (string\
    \ pos) '[)\n           (loop (+ pos (char-index '[' (string pos))))\n        \
    \   (loop (+ pos (char-index ']' (string pos))))\n          (else\n          \
    \ (loop (+ pos (char-index '[' (string pos)))\n                   (+ pos (char-index\
    \ ']' (string pos))))\n          ((char=? (string pos) '[)\n           (loop (+\
    \ pos (char-index '[' (string pos))))\n           #f)\n          ((char=? (string\
    \ pos) ']')\n           (loop (+ pos (char-index ']' (string pos))))\n       \
    \   (else\n           (loop (+ pos (char-index ']' (string pos))))\n         \
    \ ((char=? (string pos) '[)\n           (loop (+ pos (char-index '[' (string pos))))\n\
    \           #f)\n          ((char=? (string pos) ']')\n           (loop (+ pos\
    \ (char-index ']' (string pos))))\n          (else\n           (loop (+ pos (char-index\
    \ ']' (string pos))))\n          ((char=? (string pos) '[)\n           (loop (+\
    \ pos (char-index '[' (string pos))))\n           #f)\n          ((char=? (string\
    \ pos) '[')\n           (loop (+ pos (char-index ']' (string pos))))\n       \
    \   (else\n           (loop (+ pos (char-index ']' (string pos))))\n         \
    \ ((char=? (string pos) '[)\n           (loop (+ pos (char-index '[' (string pos))))\n\
    \           #f)\n          ((char=? (string pos) '[')\n           (loop (+ pos\
    \ (char-index ']' (string pos))))\n          (else\n           (loop (+ pos (char-index\
    \ ']' (string pos))))\n          ((char=? (string pos) '[)\n           (loop (+\
    \ pos (char-index '[' (string pos))))\n           #f)\n          ((char=? (string\
    \ pos) '[')\n           (loop (+ pos (char-index ']' (string pos))))\n       \
    \   (else\n           (loop (+ pos (char-index ']' (string pos))))\n         \
    \ ((char=? (string pos) '[')\n", "  (cond\n    [(empty? string) #t]\n    [(not\
    \ (eq? (first string) #\\[)) #f]\n    [else (is_nested1 (rest string))]\n  ))",
  "  (check-type string string)\n  (let ((i 0)\n        (found false))\n    (loop\
    \ [i 0]\n      (if (> i string.length)\n          found\n          (let ((char\
    \ (substring string i (1- (length (string string) i)))))\n            (if (equal?\
    \ (char ']') char)\n                (begin\n                  (set! found true)\n\
    \                  (if (equal? (substring string i (1- (length (string string)\
    \ i))) ']')\n                      (set! i (1+ i)))\n                  (set! i\
    \ (1+ i)))\n                (set! i (1+ i)))\n            (set! i (1+ i)))\n \
    \       (set! i (1+ i)))))\n  found))\n", "  (cond [(or (null? string) (equal?\
    \ (car string) '[])\n             (equal? (car string) '())\n             (equal?\
    \ (car string) '[))\n         #f]\n        [(equal? (car string) '[]\n       \
    \            )\n         (and (equal? (car string) '[) (equal? (cdr (cdr (cdr\
    \ (cdr string))) '[])))\n         #f]\n        [(equal? (car string) '()\n   \
    \                )\n         (and (equal? (car string) '[]) (equal? (cdr (cdr\
    \ (cdr (cdr string))) '[])))\n         #f]\n        [else\n         (and (equal?\
    \ (car string) '[]) (equal? (cdr (cdr (cdr (cdr string))) '[)))\n         #f]\n\
    \      )\n)\n", "  (let ((found 'false))\n    (cond\n      [(equal? (string-length\
    \ (substring string 0 1)) 2)\n       (equal? (string-length (substring string\
    \ 0 2)) 0)\n       (equal? (string-length (substring string 0 3)) 0)\n       (equal?\
    \ (string-length (substring string 0 4)) 0)\n       (equal? (string-length (substring\
    \ string 0 5)) 0)\n       (equal? (string-length (substring string 0 6)) 0)\n\
    \       (equal? (string-length (substring string 0 7)) 0)\n       (equal? (string-length\
    \ (substring string 0 8)) 0)\n       (equal? (string-length (substring string\
    \ 0 9)) 0)\n       (equal? (string-length (substring string 0 10)) 0)\n      \
    \ (equal? (string-length (substring string 0 11)) 0)\n       (equal? (string-length\
    \ (substring string 0 12)) 0)\n       (equal? (string-length (substring string\
    \ 0 13)) 0)\n       (equal? (string-length (substring string 0 14)) 0)\n     \
    \  (equal? (string-length (substring string 0 15)) 0)\n       (equal? (string-length\
    \ (substring string 0 16)) 0)\n       (equal? (string-length (substring string\
    \ 0 17)) 0)\n       (equal? (string-length (substring string 0 18)) 0)\n     \
    \  (equal? (string-length (substring string 0 19)) 0)\n       (equal? (string-length\
    \ (substring string 0 20)) 0)\n       (equal? (string-length (substring string\
    \ 0 21)) 0)\n       (equal? (string-length (substring string 0 22)) 0)\n     \
    \  (equal? (string-length (substring string 0 23)) 0)\n       (equal? (string-length\
    \ (substring string 0 24)) 0)\n       (equal? (string-length (substring string\
    \ 0 25)) 0)\n       (equal? (string-length (substring string 0 26)) 0)\n     \
    \  (equal? (string-length (substring string 0 27)) 0)\n       (equal? (string-length\
    \ (substring string 0 28)) 0)\n       (equal? (string-length (substring string\
    \ 0 29)) 0)\n       (equal? (string-length (substring string 0 30)) 0)\n     \
    \  (equal? (string-length (substring string 0 31)) 0)\n       (equal? (string-length\
    \ (substring string 0 32)) 0)\n       (equal? (string-length (substring string\
    \ 0 33)) 0)\n       (equal? (string-length (substring string 0 34)) 0)\n     \
    \  (equal? (string-length (substring string 0 35)) 0)\n       (equal? (string-length\
    \ (substring string 0 36", "  (cond\n    [(empty? string) #t]\n    [(equal? (first\
    \ string) ']) #t]\n    [else (or (equal? (first string) '[') (equal? (first string)\
    \ '('))]))\n</code>\n<|/ a |>\n<| c |>\nThank you for all the suggestions. I realize\
    \ I'm missing something simple here. I added a couple of examples I forgot to\
    \ show in my question.\n<|/ c |>\n<| a tags=racket,scheme |>\nI would use recursion\
    \ for this problem. \n<code>", "  (for/or ([i string])\n    (and (number? (char-code\
    \ i))\n         (= 2 (square-count i))))))\n", "  (cond\n    [(empty? string)\
    \ #f]\n    [(equal? (car string) '[) #t]\n    [else (and (is_nested (cdr string))\
    \ (or (equal? (car string) '[') (equal? (car string) '{')))]))) ; #lang racket\n",
  "  (and (or (char-equal? string (substring string 0 0))\n            (char-equal?\
    \ string (substring string 0 1))\n            (char-equal? string (substring string\
    \ 0 2))\n            (char-equal? string (substring string 0 3))\n           \
    \ (char-equal? string (substring string 0 4))\n            (char-equal? string\
    \ (substring string 0 5))\n            (char-equal? string (substring string 0\
    \ 6))\n            (char-equal? string (substring string 0 7))\n            (char-equal?\
    \ string (substring string 0 8))\n            (char-equal? string (substring string\
    \ 0 9))\n            (char-equal? string (substring string 0 10))\n          \
    \  (char-equal? string (substring string 0 11))\n            (char-equal? string\
    \ (substring string 0 12))\n            (char-equal? string (substring string\
    \ 0 13))\n            (char-equal? string (substring string 0 14))\n         \
    \   (char-equal? string (substring string 0 15))\n            (char-equal? string\
    \ (substring string 0 16))\n            (char-equal? string (substring string\
    \ 0 17))\n            (char-equal? string (substring string 0 18))\n         \
    \   (char-equal? string (substring string 0 19))\n            (char-equal? string\
    \ (substring string 0 20))\n            (char-equal? string (substring string\
    \ 0 21))\n            (char-equal? string (substring string 0 22))\n         \
    \   (char-equal? string (substring string 0 23))\n            (char-equal? string\
    \ (substring string 0 24))\n            (char-equal? string (substring string\
    \ 0 25))\n            (char-equal? string (substring string 0 26))\n         \
    \   (char-equal? string (substring string 0 27))\n            (char-equal? string\
    \ (substring string 0 28))\n            (char-equal? string (substring string\
    \ 0 29))\n            (char-equal? string (substring string 0 30))\n         \
    \   (char-equal? string (substring string 0 31))\n            (char-equal? string\
    \ (substring string 0 32))\n            (char-equal? string (substring string\
    \ 0 33))\n            (char-equal? string (substring string 0 34))\n         \
    \   (char-equal? string (substring string 0 35))\n            (char-equal? string\
    \ (substring string 0 36))\n            (char-equal? string (substring string\
    \ 0 37))\n            (char-equal? string (substring string 0 38))\n         \
    \   (char-equal? string (substring string 0 39))\n            (char", "  (cond\n\
    \    ((empty? string) '())\n    ((equal? (car string) '[) (is_nested (cdr string)))\n\
    \    ((equal? (car string) '(') (is_nested (cdr string)))\n    (else (is-nested\
    \ string))))\n", "  (memq '[[] string))\n</code>\n<|/ a dscore=1 |>\n<| a tags=functional-programming,scheme,racket,algorithm\
    \ |>\nA simple recursive solution using only map and length functions:\n<code>",
  "  (cond\n    [(empty? string) empty]\n    [else (\n      (andmap (lambda (bracket_string)\
    \ \n                 (equal? string bracket_string))\n            (map (lambda\
    \ (bracket_string) \n                   (substring bracket_string 1 (string-length\
    \ bracket_string)))\n                 (map (lambda (bracket_string) (substring\
    \ bracket_string 0 2))\n                      (string-split string #\\])))\n \
    \     (or (or (equal? (substring string 0 1) '[)\n              (equal? (substring\
    \ string 0 2) '])))]))\n", "  (cond \n    [(empty? string) true]\n    [(member\
    \ (car string) '(())) true]\n    [else (is_nested (cdr string))]))\n", "  (define\
    \ i 0)\n  (define j 0)\n  (define count 0)\n  (define stack ())\n  (define valid-nested-brackets\
    \ ())\n  (while (< i string)\n    (define char (char string i))\n    (if (char?\
    \ '(' (char string j))\n      (define char (char string j))\n      (begin\n  \
    \      (define stack (cons (char string j) stack))\n        (define valid-nested-brackets\
    \ (cons (char string j) valid-nested-brackets))\n        (define j (+ j 1))\n\
    \        (define i (+ i 1))\n        (set! count (+ count 1))\n        (begin\
    \ (set! j (+ j 1))\n              (set! i (+ i 1))\n              (set! count\
    \ (+ count 1))\n              (set! stack (cons (char string j) stack))\n    \
    \          (set! valid-nested-brackets (cons (char string j) valid-nested-brackets))\n\
    \              (define valid (and (< (- j 1) j)\n                            \
    \     (< (- i 1) i)\n                                 (= (- count 1) 0)))\n  \
    \            (cond\n              [(or (char? '[' (char string j))\n         \
    \         (char? ']' (char string j))\n                  (char? ')' (char string\
    \ j))\n               (begin (set! j (+ j 1))\n                     (set! i (+\
    \ i 1))\n                     (set! count (+ count 1))\n                     (set!\
    \ stack (cons (char string j) stack))\n                     (set! valid-nested-brackets\
    \ (cons (char string j) valid-nested-brackets))\n                     valid\n\
    \                    )]\n              [(char? ']' (char string j))\n        \
    \       (begin (set! j (+ j 1))\n                     (set! i (+ i 1))\n     \
    \                (set! count (+ count 1))\n                     (set! stack (cons\
    \ (char string j) stack))\n                     (set! valid-nested-brackets (cons\
    \ (char string j) valid-nested-brackets))\n                     valid\n      \
    \              )]\n              [(char? '[' (char string j))\n              \
    \ (begin (set! j (+ j 1))\n                     (set! i (+ i 1))\n           \
    \          (set! count (+ count 1))\n                     (set! stack (cons (char\
    \ string j) stack))\n                     (set! valid-nested-brackets (cons (char\
    \ string j) valid-nested-brackets))\n                     valid\n            \
    \        )]\n              [(char? '[' (char ", "  (cond\n    [(= 0 (string-length\
    \ string)) true]\n    [(string-ref string 0) (string-ref string 0)]\n    [else\
    \ (cond\n      [(string-ref (substring (string 1) 1) '[') (is_nested string)]\n\
    \      [else false])]))\n", "  (cond\n    [(empty? string) true]\n    [(or (char=\
    \ #\\[ car string)\n          (char= #\\] car)) false]\n    [else\n     (not (or\
    \ (is_nested (cdr string))\n              (is_nested (car string))))]))\n", " \
    \ (let loop ()\n    (cond\n      [(empty? string) #false]\n      [(char=? (car\
    \ string) '[)\n       (loop)]\n      [(char=? (car string) ']) \n       (loop)]\n\
    \      [else (loop)])))\n", "  (cond\n    ((empty? string) #f)\n    ((char=? (car\
    \ string) '[)\n     (is_nested (cdr string))\n     (or (is_nested (car string))\n\
    \         (is_nested (cdr string))))\n    (else #t)))\n", "  (let ((last-brackets\
    \ '()))\n    (loop for char across string\n         while char\n         collect\
    \ (char (check-brackets char last-brackets))\n         into last-brackets\n  \
    \       finally (return (> (count last-brackets) 0))))\n", "  (cond\n    [(string=?\
    \ (first string) '[]) True]\n    [(string=? (rest string) '[]) False]\n    [(and\
    \ (list? (first string)) (null? (rest string)))\n     (is_nested (first string))]\n\
    \    [(and (list? (first string))\n          (null? (rest string))\n         \
    \ (string=? (first string) '[))\n     (is_nested (first string))]\n    [(and (list?\
    \ (first string))\n          (null? (rest string))\n          (string=? (first\
    \ string) '[][))\n     (is_nested (first string))]\n    [(and (list? (first string))\n\
    \          (null? (rest string))\n          (string=? (first string) '[]]))\n\
    \     (is_nested (first string))]\n    [(and (list? (first string))\n        \
    \  (null? (rest string))\n          (string=? (first string) '[](]))\n     (is_nested\
    \ (first string))]\n    [(and (list? (first string))\n          (null? (rest string))\n\
    \          (string=? (first string) '[][])])\n     (is_nested (first string))]\n\
    \    [(and (list? (first string))\n          (null? (rest string))\n         \
    \ (string=? (first string) '[][])])\n     (is_nested (first string))]\n    [(and\
    \ (list? (first string))\n          (null? (rest string))\n          (string=?\
    \ (first string) '[](]))\n     (is_nested (first string))]\n    [(and (list? (first\
    \ string))\n          (null? (rest string))\n          (string=? (first string)\
    \ '[][])])\n     (is_nested (first string))]\n    [(and (list? (first string))\n\
    \          (null? (rest string))\n          (string=? (first string) '[][])])\n\
    \     (is_nested (first string))]\n    [(and (list? (first string))\n        \
    \  (null? (rest string))\n          (string=? (first string) '[](]))\n     (is_nested\
    \ (first string))]\n    [(and (list? (first string))\n          (null? (rest string))\n\
    \          (string=? (first string) '[])]])\n     (is_nested (first string))]\n\
    \    [(and (list? (first string))\n          (null? (rest string))\n         \
    \ (string=? (first string) '[](]))\n     (is_nested (first string))]\n    [(and\
    \ (list? (first string))\n          (null? (rest string))\n          ", "  (let\
    \ loop ([str string] [i 0] [temp 0])\n    (cond [(< i 0) false]\n          [(=\
    \ (length str) 0) true]\n          [(= (str.char-at-i i) #\\]) (loop (str #\\\
    ] i) temp)\n          [(= (str.char-at-i i) #\\[) (loop (str #\\[ i) i temp)]\n\
    \          [else (loop (str str i) i (+ temp 1))]))))\n", "  (let ((found (subseq?\
    \ string #\\[)))\n    (not (or (not found) (not (subseq? string (lambda (x) (not?\
    \ (equal x #\\]))))))))\n", "  (memq '[ (memq '] string))\n)\n", "  (define (valid-bracket\
    \ string)\n    (let ((count 0))\n      (cond\n        [(equal? string '[]) (equal?\
    \ count 0)]\n        [(equal? (car string) '[) (+ 1 (valid-bracket (cdr string)))]\n\
    \        [(equal? (car string) '(') (+ 1 (valid-bracket (cdr string)))]\n    \
    \    [else (+ count 1)]))))\n  (let ((count 0))\n    (cond\n      [else (or (equal?\
    \ (valid-bracket (car string)) 0)\n                (equal? count 0))]))))\n",
  "  (cond [(empty? string) #f]\n        [(not (equal? (car string) '[')) #f]\n  \
    \      [(not (equal? (car string) ']')) #f]\n        [(is_nested (cdr string))\
    \ #t]\n        [else\n         (and (is_nested (car string))\n               (is_nested\
    \ (cdr string)))]))\n", "  (if (string=? string '[])\n      (true) \n      (if\
    \ (string-match '[\\\\[][]]' string)\n          true\n          (if (string-match\
    \ '[\\\\[]' string)\n              true\n              false))))\n</code>\n<|/\
    \ a dscore=0 tags=string,racket,sequence,regex,recursion |>\n<| c |>\nI like your\
    \ solution! But as you say, `string=?` does not work because I cannot assume that\
    \ all characters are in \"[a-z]\". My solution is simpler: just test `string-match`\
    \ against the desired pattern. Can you modify your answer to take this into account?\n\
    <|/ c |>\n<| c |>\nYou can easily use `string=?` to match any character, including\
    \ all lowercase letters. It's just a matter of which characters you choose.\n\
    <|/ c |>\n<| c |>\nOh I see! I always forget the `string=?` function... Thanks\n\
    <|/ c |>\n<| c |>\nI modified your solution slightly to allow for brackets to\
    \ be embedded in each other: `(define (is_nested string)\n  (cond \n    ((string-match\
    \ '([[][[]]))\n     (string-match '([[]])\n     (string-match '([[[]]))\n    \
    \ (string-match '([][[[]]))\n     (string-match '([]))\n     (string-match '([])\n\
    \     (string-match '[[]])))\n    (else false)))`\n<|/ c |>\n<| c |>\nI modified\
    \ your solution slightly to allow for brackets to be embedded in each other: `(define\
    \ (is_nested string)\n  (cond \n    ((string-match '([[][[]]))\n     (string-match\
    \ '([[]])\n     (string-match '([[[]]))\n     (string-match '([][[[]]))\n    \
    \ (string-match '([]))\n     (string-match '([])\n     (string-match '[[]])))\n\
    \    (else false)))`\n<|/ c |>\n<| a dscore=0 tags=string,racket,sequence,regex,recursion\
    \ |>\nI would use regexp-match\n<code>\n#lang racket\n", "  (or (= (string-length\
    \ string) 0)\n      (null (string-substring string 0 (string->length (substring\
    \ string 0 1))))\n      (null (string-substring string 0 (string->length (substring\
    \ string 0 (string->length (substring string 1 (string->length string)))))))))\n",
  "  (= (length string) 0)\n  (or (equal? (char string 0) '[') (equal? (char string\
    \ 0) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+ 1\
    \ 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (equal? (char string (+ 1 0)) '[') (equal? (char string (+\
    \ 1 0)) ']'))\n  (or (", "  (cond [(empty? string) #false]\n        [(= (remainder\
    \ string #\\] 0) #\\]) #true]\n        [(= (remainder string #\\[) 0)\n      \
    \    (cond [(= (remainder string #\\] 0) #\\]) \n                [else (is_nested\
    \ (remainder string #\\]))]\n               ]\n        [else false]))", "  (letrec\
    \ ([is_nested (lambda (string) (= (memq #\\[ (string)) (memq #\\] (string))))])\n\
    \    (cond\n      [(or (not (string? string))\n           (char-equal #\\[ string\
    \ (char-before string))\n           (char-equal #\\] string (char-after string)))\n\
    \       (#t '#f)\n       ]\n      [(is_nested string)\n       (#t '#t)\n     \
    \  ]\n      [else\n       (#f '#f)\n       ])))\n</code>\nThis checks whether\
    \ the substring [[]] exists in the string as substring. \nIf it exists, then it\
    \ checks whether there are any [] next to each other in the string. \nIf it exists,\
    \ it checks if the sequence has at least one nested.\nIf it exists and if the\
    \ sequence has at least one nested, then it checks whether the sequence has at\
    \ least one nested square-bracket.\n<code>\n#lang racket\n", "  ...)\n</code>\n\
    And now we're done with the is_nested function! We can now define the is_nested_sequence\
    \ function using the same strategy:\n<code>", "  (cond ((equal? (length (find-nested-brackets\
    \ string '())) 0)\n         #t)\n        ((equal? (length (find-nested-brackets\
    \ (string-upcase string) '())) 1)\n         #t)\n        (else (is_nested))))\n",
  "  (let loop ([index 0])\n    (cond\n      [(string=? (string-ref string index)\
    \ '[]) true]\n      [(string=? (string-ref string index) '[) (loop (add1 index))\n\
    \       (loop (add1 index))\n       true]\n      [else false]))))\n", "  (cond\n\
    \    [(empty? string) #f]\n    [(not (equal? (first (first (car string)))) '(')\
    \ (is_nested (rest string))]\n    [(not (equal? (first (first (cdr string))))\
    \ '[') (is_nested (rest string))]\n    [(equal? (first (first (cdr string))))\
    \ '(') (equal? (first string) (is_nested (rest string))]\n    [(equal? (first\
    \ (first (car string)))) '[') (equal? (first string) (is_nested (rest string))]\n\
    \    [else (is_nested (rest string))]))\n", "  (and (> (string-length string)\
    \ 0)\n       (and (= (string-ref string 0) ']')\n            (= (string-ref string\
    \ (- 1 (string-length string)))) ']')))\n", "  (let loop ((nest-count 0)\n   \
    \          (cur-char (string-ref string 0))\n             (rest-string (rest string)))\n\
    \    (cond\n      ((null? rest-string)\n       (equal? cur-char '[])\n       #t)\n\
    \      ((null? (cdr rest-string))\n       (equal? cur-char '[])\n       #t)\n\
    \      ((char= cur-char '[)\n       (loop (+ nest-count 1)\n             (string-ref\
    \ rest-string 0)\n             (rest rest-string)))\n      ((char= cur-char '[)\n\
    \       (loop (+ nest-count 1)\n             (string-ref rest-string 0)\n    \
    \         (rest rest-string)))\n      (else\n       (loop (+ nest-count 1)\n \
    \            (char (car rest-string))\n             (cdr rest-string))))))\n",
  "  (if (empty? string) false\n      (let ((c (char string)))\n        (and (= (char\
    \ string 0) '[')\n             (= (char string 1) '['))\n        (and (= (char\
    \ string (cadr string)) '[')\n             (= (char string (caddr string)) '['))\n\
    \        (and (= (char string (caddr string)) (caddr string))\n             (is_nested\
    \ (caddr string)))))) \n", "  (let loop ((s string) (t #f))\n    (cond ((= (length\
    \ s) 0) (or (not t) (not (= '[] (subseq s 0 (- (length s) 1)))))) ; no nesting\n\
    \          ((eqv? (char (substring s 0 (- (length s) 1)) '[') (char (substring\
    \ s 0 (- (length s) 1)) ']')) ; single level nesting\n          ((or (eqv? (char\
    \ (substring s 0 (- (length s) 1)) '[')\n                (eqv? (char (substring\
    \ s 0 (- (length s) 1)) ']'))\n                (or (eqv? (char (substring s 0\
    \ (- (length s) 1)) '(')\n                      (eqv? (char (substring s 0 (-\
    \ (length s) 1)) ')'))))\n          (t (loop (substring s (+ 1 (- (length s) 1))\
    \ (not (= (substring s '[' 0) (substring s 0 (- (length s) 1)))))))) ; recurse\n\
    \  ))\n", "  (cond [(empty? string) #false]\n        [(= '([])\n           (count-nested-brackets\
    \ (substring string 1 -1))) #true]\n        [else #f]))\n", "  (cond\n    ((or\
    \ (equal? string '') (equal? string '[]')) #t)\n    ((char= (first string) '[')\
    \ \n     (is_nested (string-ref string 1))\n     (is_nested (string-ref string\
    \ 2))\n     (is_nested (string-ref string 3))\n     (is_nested (string-ref string\
    \ 4))\n     (is_nested (string-ref string 5))\n     (is_nested (string-ref string\
    \ 6))\n     (is_nested (string-ref string 7))\n     (is_nested (string-ref string\
    \ 8))\n     (is_nested (string-ref string 9))\n     (is_nested (string-ref string\
    \ 10))\n     (is_nested (string-ref string 11))\n     (is_nested (string-ref string\
    \ 12)))\n    ((char= (first string) '[') \n     (equal? string '[[]]'))\n    ((char=\
    \ (first string) '(') \n     (equal? string '([[]]'))\n    ((char= (first string)\
    \ '(') \n     (equal? string '([[]'))\n    ((char= (first string) '(') \n    \
    \ (equal? string '([['))\n    ((char= (first string) '[') \n     (equal? string\
    \ '[[]'))\n    ((char= (first string) '[') \n     (equal? string '[[]]'))\n  \
    \  ((char= (first string) '(') \n     (equal? string '([[]]'))\n    ((char= (first\
    \ string) '(') \n     (equal? string '([[]'))\n    ((char= (first string) '(')\
    \ \n     (equal? string '([['))\n    ((char= (first string) '[') \n     (equal?\
    \ string '[[]'))\n    ((char= (first string) '[') \n     (equal? string '[[]]'))\n\
    \    ((char= (first string) '(') \n     (equal? string '([[]]'))\n    ((char=\
    \ (first string) '(') \n     (equal? string '([[]'))\n    ((char= (first string)\
    \ '(') \n     (equal? string '([['))\n    ((char= (first string) '[') \n     (equal?\
    \ string '[[]'))\n    ((char= (first string) '[') \n     (equal? string '[[]]'))\n\
    \    ((char= (first string) '(') \n     (equal? string '([[]]'))\n    ((char=\
    \ (first string) '(') \n     (equal? string '([[]'))\n    ((char= ", "  (cond\
    \ [(string? string)\n         (string=? string \"[\")\n         (string=? string\
    \ (substring \"[\" 0 (string-length string) string))\n         (string=? (substring\
    \ string 1 \n                          (string-length string) (substring string\
    \ 1 \n                                                      (string-length string))))\n\
    \         (string=? (substring string 1 \n                          (string-length\
    \ string) (substring string 2 \n                                             \
    \         (string-length string)))) ; ]\n         (string=? (substring string\
    \ 1 \n                          (string-length string) (substring string 2 \n\
    \                                                      (string-length string))))\
    \ ; [\n         (string=? (substring string 1 \n                          (string-length\
    \ string) (substring string 2 \n                                             \
    \         (string-length string)))) ; [\n         (string=? (substring string\
    \ 1 \n                          (string-length string) (substring string 3 \n\
    \                                                      (string-length string))))\
    \ ; ]]\n         (string=? string (substring \"]\" 0 (string-length string) string))\n\
    \         (string=? (substring string 1 \n                          (string-length\
    \ string) (substring string 2 \n                                             \
    \         (string-length string)))) ; ]\n         (string=? (substring string\
    \ 1 \n                          (string-length string) (substring string 2 \n\
    \                                                      (string-length string))))\
    \ ; [\n         (string=? (substring string 1 \n                          (string-length\
    \ string) (substring string 2 \n                                             \
    \         (string-length string)))) ; [\n         (string=? (substring string\
    \ 1 \n                          (string-length string) (substring string 3 \n\
    \                                                      (string-length string))))\
    \ ; ]]\n         (else false)\n        ])\n", "  (define (helper stack)\n    (cond\n\
    \      [(empty? stack) #t]\n      [(equal? (car stack) ']) #t]\n      [(equal?\
    \ (car stack) '[) #t]\n      [else (helper (cdr stack))]))\n  (helper string))\n",
  "  (< (length string)\n     (length #{\\[})\n     #f))\n", "  (let loop ((string-to-check\
    \ string))\n    (if (null? string-to-check)\n        #f\n        (let ((next-to-check\
    \ (char->integer (string-to-check 0))))\n          (if (null? next-to-check)\n\
    \              #f\n              (loop (cdr string-to-check)))))\n    (loop '[])))\n",
  "  (let loop ((i 0) (brackets 0))\n    (if (or (char-not (string-ref string i))\n\
    \            (char-not (string-ref string i))\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref string\
    \ i)\n            (char-not (string-ref string i)\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref string\
    \ i)\n            (char-not (string-ref string i)\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref string\
    \ i)\n            (char-not (string-ref string i)\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref string\
    \ i)\n            (char-not (string-ref string i)\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref string\
    \ i)\n            (char-not (string-ref string i)\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref string\
    \ i)\n            (char-not (string-ref string i)\n            (char-not (string-ref\
    \ string i)\n            (char-not (string-ref string i)\n            (char-not\
    \ (string-ref string i)\n            (char-not (string-ref string i)\n       \
    \     (char-not (string-ref string i)\n            (char-not (string-ref ", " \
    \ (= (string-count string \"[[\")\n     (string-count string \"[]]]))]))\n</code>\n\
    <|/ a dscore=1 tags=string,racket,functional-programming,scheme |>\n<| a tags=string,racket,functional-programming,scheme\
    \ |>\nMy answer is based on a previous one by David B. Rankin. My previous answer\
    \ used the string-count function but this has since been removed. \n<code>", " \
    \ (= (length string) (length string)))\n</code>\nMy problem is I'm not sure how\
    \ to make the function work. I've already defined nested brackets, but I'm not\
    \ sure how to test whether the brackets are nested or not. \nI tried doing the\
    \ following:\n<code>", "  ; Find a substring of brackets\n  (define (find_substring\
    \ string start)\n    ; Stop if there is no bracket\n    (if (null? string) \n\
    \      ; Return a boolean false to indicate the substring is not found\n     \
    \ false\n      ; Keep finding a closing bracket while there are unclosed brackets\n\
    \      (let loop ((index start) (char '[') (found false))\n        (cond\n   \
    \       ((char? char) (loop (+ index 1) (char (char #\\'])))\n          ((char\
    \ (char #\\]) #f)\n          ((char (char #\\]) #t)\n          ((char (char #\\\
    ]) #f) (let ((found true)) found)\n          (#f #f)\n          (#t #t) (let ((found\
    \ false)) found)\n          (else #f))))\n\n    ; If the substring is not found,\
    \ return false\n    (not (find_substring (substring string 0 index) index)))\n\
    \n  ; Find the first unclosed bracket\n  (let loop ((index 0) (char '[') (found\
    \ false))\n    (cond\n      ((char? char) (loop (+ index 1) (char (char #\\'])))\n\
    \      ((char (char #\\]) #f)\n      ((char (char #\\]) #t)\n      ((char (char\
    \ #\\]) #f) (let ((found true)) found)\n      (#f #f)\n      (#t #t) (let ((found\
    \ false)) found)\n      (else #f))))\n\n  ; If the substring is not found, return\
    \ false\n  (not (find_substring (substring string 0 index) index)))\n", "  (define\
    \ (loop (string index stack)\n            (result #f))\n    (cond [(empty? string)\
    \ result]\n          [(equal? (char string 0) '[') (loop (substring string 1)\
    \ (+ index 1) (cons (car stack) (list '(#f #f))))]\n          [(equal? (char string\
    \ 0) ']') (loop (substring string 1) (+ index 1) (cons (car stack) (list #f #f))))]\n\
    \          [(equal? (char string 0) '(#')\n           (if (null? (cdr stack))\n\
    \               (loop (substring string 1) (+ index 1) (cons (car stack) (list\
    \ #f #f))))\n           (loop (substring string 1) (+ index 1) (cons (car stack)\
    \ (list (car stack) #f))))]\n          [(equal? (char string 0) '(#')\n      \
    \     (if (null? (cdr stack))\n               (loop (substring string 1) (+ index\
    \ 1) (cons (car stack) (list #f #f))))\n           (loop (substring string 1)\
    \ (+ index 1) (cons (car stack) (list (car stack) #f)))]\n          [else (loop\
    \ (substring string 1) (+ index 1) (cons (car stack) (list #f #f))))])\n    (loop\
    \ (substring string 1) 0 '()))\n", "  (cond\n    [(empty? string)] #t\n    [(equal?\
    \ (first (tail string)) '(')\n     (if (is_nested(substring (tail string) 1))\n\
    \         #f\n         (is_nested(substring (tail string) 1)))]\n    [else #f\
    \ ]))\n", "  (define (loop i char)\n    (cond\n      [(empty? string) #false]\n\
    \      [(equal? (car string) char) (loop (add1 i) (next-char string))]\n     \
    \ [else (and (loop (add1 i) char) (loop (add1 i) (cdr string)))]))\n  (loop (length\
    \ string) (car string)))\n", "  (cond\n    [(empty? string) #t]\n    [(not (equal?\
    \ (car string) #\\])) (is_nested (rest string))]\n    [else (is_nested (rest string))]\n\
    \  )\n)\n", "  (match-let ((brackets '([)]) \n                (nested-brackets\
    \ (rest brackets))\n                ((current ?e) '())\n                (nesting\
    \ ?'()\n                   (cond ((eq current ?e) true)\n                    \
    \     [else (is_nested-match current nesting)]))\n                (nested-open\
    \ ?'() \n                  (cond ((eq current ?e) true)\n                    \
    \     [else (is_nested-open current nesting)]))\n                (nested-close\
    \ ?'() \n                  (cond ((eq current ?e) true)\n                    \
    \     [else (is_nested-close current nesting)]))\n                (nested-match\
    \ ?'()\n                  (cond ((eq current ?e) true)\n                     \
    \    [else (is_nested-match current nesting)]))))\n    (match-case (string-match\
    \ string nested-brackets all)\n      [((any ?e ?'() (cond [(eq ?e ?'()) true]\n\
    \                                    [(and [(rest (rest brackets)) (rest (rest\
    \ nested-brackets))]\n                                          (eq? ?e ?e)))]\n\
    \               (cond [(and [(rest (rest brackets)) (rest (rest nested-brackets))]\n\
    \                                    (eq? ?e ?e)))]\n               (cond [(and\
    \ [(rest (rest brackets)) (rest (rest nested-brackets))]\n                   \
    \                 (eq? ?e ?e))])\n       ((any ?e ?'() (cond [(eq ?e ?'()) true]\n\
    \                                    [(or (rest (rest brackets)) (equal? ?e ?e))])\n\
    \               (cond [(or (rest (rest brackets)) (equal? ?e ?e))])\n        \
    \       (cond [(or (rest (rest brackets)) (equal? ?e ?e))])])\n      (cond [(and\
    \ (empty? all) (not (empty? (rest (rest nested-brackets))))) true]\n         \
    \   [else false]))))\n", "  (cond\n    [(= (string-length string) 0) false]\n\
    \    [(string= (first string) '[') true]\n    [(= (length string) 0) false]\n\
    \    [(string= (first string) '(#\\)) true]\n    [else (is_nested(substring (next\
    \ string) 1 -1))]\n    )\n  )\n", "  (not (equal? (subseq-string\n           \
    \   string\n              0\n              (+ (string-length string)\n       \
    \            (min (string-length string)\n                        (subseq-string\
    \ string 0 0)))))\n         #f))\n", "  (cond\n    [(empty? string) #t]\n    [(member\
    \ (car string) '[[[']) #t]\n    [else (is_nested (cdr string))]\n   )\n  )\n)\n",
  "  (cond\n    ((empty? string) #f)\n    ((char? string) (string=? '[' (car string)))\n\
    \    (else #t)))\n", "  (cond ((null? string) #f)\n        ((equal? (char-at-pos\
    \ (car string) string) ']') #t)\n        ((equal? (char-at-pos (car string) string)\
    \ '[') #t)\n        (else (is_nested\n                 (substring (del-char (car\
    \ string) string))))))", "  (let loop ((count 0)\n             (stack '()))\n\
    \    (cond ((equal? count 0)\n           (equal? (first stack) '()))\n       \
    \   ((equal? count (length string))\n           (equal? (first stack) (first string)))\n\
    \          ((equal? (first stack) '())\n           (equal? (first string) '()))\n\
    \          ((equal? (first string) '())\n           (loop (+ count 1)\n      \
    \           (cons (first stack)\n                      stack))\n          ((equal?\
    \ (first string) '(()))\n           (loop (+ count 1)\n                 (cons\
    \ '()\n                      stack))\n          ((equal? (first string) '([()))\n\
    \           (loop (+ count 1)\n                 (cons (first stack)\n        \
    \              stack))\n          ((equal? (first string) (']]))\n          ((equal?\
    \ (first string) '[]])\n          ((equal? (first string) '[]])\n          ((equal?\
    \ (first string) ']]])\n          ((equal? (first string) ']]]]]]][[[[[]')\n \
    \         (loop (+ count 1)\n                (cons (first stack)\n           \
    \           stack))\n          ((equal? (first string) '[][]])\n          ((equal?\
    \ (first string) '[][]])\n          ((equal? (first string) '[]])\n          ((equal?\
    \ (first string) '[]])\n          ((equal? (first string) '][])\n          ((equal?\
    \ (first string) '][])\n          ((equal? (first string) ']])\n          ((equal?\
    \ (first string) ']])\n          ((equal? (first string) '[][])\n          ((equal?\
    \ (first string) '[][])\n          ((equal? (first string) '[]])\n          ((equal?\
    \ (first string) '[]])\n          ((equal? (first string) '[[]])\n          ((equal?\
    \ (first string) '[[]])\n          ((equal? (first string) '[[])\n          ((equal?\
    \ (first string) '[[])\n          ((equal? (first string) '[]])\n          ((equal?\
    \ (first string) '[]])\n          ((equal? (first string) '())\n           (equal?\
    \ (first stack) '()))\n          ((equal? (first string) '(()())())\n        \
    \   (equal? (first stack)\n                '(()())())\n          ((equal? (first\
    \ string) '([(())())\n           (equal? (first stack)\n                '([(())())\n\
    \          ((equal? (first string) '([(())", "  (cond\n    [(empty? string) true]\n\
    \    [(equal? (first string) '[) true]\n    [else (or (equal? (first string) '[')\
    \ (equal? (first string) '{') (equal? (first string) '(') (equal? (first string)\
    \ '{')))]))\n", "  (cond ((empty? string) #f)\n        ((char=? (car string) '[)\
    \ (is_nested (cdr string)))\n        (else (is_nested (cdr string)))))\n", " \
    \ (= (length string) (* 2 (count '([] [])]) (count '([] [')) \n              \
    \         (count '([] ])) (count '([] [][')) \n                       (count '([]\
    \ []]'))\n     (count '([])))))\n", "  (let loop ((stack '())\n             (current\
    \ (substring string 0 (length string))))\n    (cond ((= (length stack) 0) #t)\n\
    \          ((and (= (first stack) '[) (= (first current) ']'))\n           (loop\
    \ (rest stack) (substring current (+ 1 (length current))))\n          ((and (=\
    \ (first stack) '[) (= (first current) '('))\n           (loop (rest stack) (substring\
    \ current (+ 1 (length current))))\n          ((and (= (first stack) '[) (= (first\
    \ current) '{'))\n           (loop (rest stack) (substring current (+ 1 (length\
    \ current))))\n          ((and (= (first stack) '(') (= (first current) '('))\n\
    \           (loop (rest stack) (substring current (+ 1 (length current))))\n \
    \         ((and (= (first stack) '(') (= (first current) '{'))\n           (loop\
    \ (rest stack) (substring current (+ 1 (length current))))\n          ((and (=\
    \ (first stack) '{') (= (first current) '{'))\n           (loop (rest stack) (substring\
    \ current (+ 1 (length current))))\n          ((and (= (first stack) '{') (= (first\
    \ current) ']'))\n           (loop (rest stack) '())\n          ((and (= (first\
    \ stack) '[) (= (first current) '['))\n           (loop (rest stack) (substring\
    \ current (+ 1 (length current))))\n          ((and (= (first stack) '[') (= (first\
    \ current) '['))\n           (loop (rest stack) (substring current (+ 1 (length\
    \ current))))\n          ((and (= (first stack) '[') (= (first current) '('))\n\
    \           (loop (rest stack) (substring current (+ 1 (length current))))\n \
    \         ((and (= (first stack) '(') (= (first current) '('))\n           (loop\
    \ (rest stack) (substring current (+ 1 (length current))))\n          ((and (=\
    \ (first stack) '(') (= (first current) '['))\n           (loop (rest stack) (substring\
    \ current (+ 1 (length current))))\n          ((and (= (first stack) '[') (= (first\
    \ current) '['))\n           (loop (rest stack) '())\n          ((and (= (first\
    \ stack) '[') (= (first current) ']'))\n           (loop (rest stack) '())", " \
    \ (string-match? string-match-patter string))\n</code>\n<code>\n#lang racket\n",
  "  (= (length string) 2)\n  (let loop ((stack '())\n             (result false))\n\
    \    (cond ((string-char? string #\\[)\n           (cond ((string=? string #\\\
    ])\n                  (set! result (and (eq? (peek stack) #\\]) (not (empty? stack))))\n\
    \                  (set! stack (cons (peek stack) #\\[)))\n                 ((eq?\
    \ (peek stack) #\\]) (set! stack (cdr stack)))\n                 (else (set! stack\
    \ (cons (peek stack) #\\[))))\n           (else (set! result (and (empty? stack)\
    \ (not (empty? stack))))\n                 (set! stack (cons (peek stack) #\\\
    ]))))\n    (set! result (not result))\n    result))\n", "  (cond [(empty? string)\
    \                         ;; end of string\n         #t]\n        [(list? (first\
    \ string))                   ;; starts with brackets\n         (is_nested (second\
    \ string))           ;; recursively search inner brackets\n         #f]\n    \
    \    [else false]))                         ;; other characters\n            \
    \                                            ;; not an open bracket or end of\
    \ string\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for sharing your solution!\
    \ It seems good but i still have some problems understanding it. I will have to\
    \ learn more of racket in order to use it. But anyway, thanks alot ! :)\n<|/ c\
    \ |>\n<| c |>\nIn racket, everything is an expression, and a list is a sequence\
    \ of expressions. To test if an expression is a list, we could use `equal?` or\
    \ `eq?`, but then we'd have to convert the list to string and then compare the\
    \ strings. This would be rather inefficient. I think `equal?` is the right solution.\n\
    <|/ c |>\n<| c |>\nThank you for pointing this out, it makes a lot of sense, although\
    \ it makes you feel a bit stupid because it's hard to realize it. I will fix the\
    \ typo\n<|/ c |>\n<| c |>\nWhat do you mean by \"converting the list to string\"\
    ? The function `string?` would be more useful if it could be used without having\
    \ to convert it to string.\n<|/ c |>\n<| c |>\nI mean that `(list 'a 'b 'c)` is\
    \ just `'(a b c)`, so if we compare two expressions, we could use `equal?` to\
    \ compare them, which would convert them to strings. We could also use `(list->string`\
    \ instead of `(list->string x)` to convert them to strings, but this would convert\
    \ them to strings with parentheses, which might be undesirable.\n<|/ c |>\n<|\
    \ a |>\nYour problem is very similar to counting the number of open and close\
    \ parentheses in a nested list. My solution was to implement a state machine,\
    \ where each state is responsible for counting the parentheses depth:\n<code>",
  "  (cond [(empty? string)\n         #t]\n        [(equal? (car string) '[')\n  \
    \       (cond [(equal? (cdr string) ']')\n                (cond [(equal? (cdr\
    \ string) '[')\n                      #t]\n                    [else\n       \
    \               #f]])]\n         [else\n          (cond [(equal? (cdr string)\
    \ ']')\n                 (cond [(equal? (cdr string) '[')\n                  \
    \     #t]\n                   [else\n                    #f]])]\n          [else\n\
    \           #f]]))) \n", "  (cond\n    ((null? string) #f)\n    ((null? (rest\
    \ string)) #t)\n    ((char? (car string)) (is_nested (cdr string)))\n    ((char?\
    \ (car string)) #f)\n    ((char? (car string)) #t)\n    ((list? (car string))\
    \ (and (is_nested (car string)) (is_nested (cdr string))))\n    (else #t)))\n\
    </code>\n<|/ a tags=racket,scheme,lisp |>\n<| c |>\nthank you for helping me write\
    \ this program. I tried to understand your code, but I'm having trouble to understand\
    \ it. I tried to use it with my previous programming languages, and the one I'm\
    \ currently using (Racket in this case) doesn't work when I copy and paste your\
    \ program into it. Can you please write down the steps you take to solve the problem?\n\
    <|/ c |>\n<| c |>\nI updated the code so it should now be correct in Racket too.\n\
    <|/ c |>\n<| a dscore=1 |>\nI have written a program to validate brackets in racket.\
    \ The code is as follows:\n<code>\n#lang racket\n", "  (match string\n    [(empty?\
    \ string) #t]\n    [else (let ([head (car string)])\n             (match head\n\
    \               [(#\\[ #\\]) true]\n               [else (or (is_nested head)\
    \ (is_nested (cdr string)))]))]))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(equal? (car string) '[) (is_nested (cdr string))]\n    [(equal? (car string)\
    \ ']') (is_nested (cdr string))]\n    [else (is_nested (cdr string))]))\n", " \
    \ (let loop ((i 0))\n    (if (= i string-length)\n        #t\n        (let ((j\
    \ (+ i (string-length string)))\n              (a (car string))\n            \
    \  (b (cdr string))\n              (nested #t))\n          (cond\n           \
    \ ((= j i) nested)\n            ((or (equal? (car string) a) (equal? (cdr string)\
    \ b)) nested)\n            (else (loop (+ j 1) (cond ((equal? (car string) b)\
    \ nested) (else (loop (+ j 1) a))))))))))\n", "  (let ((stack '())\n        (opens\
    \ '()))\n    (check-type string string)\n    (loop\n       (cond ((equal? (string-ref\
    \ string 0) '')\n              (equal? (string-ref string 1) '')\n           \
    \   (equal? (string-ref string 2) '')\n              (equal? (string-ref string\
    \ 3) '[')\n              (equal? (string-ref string 4) '[')\n              (equal?\
    \ (string-ref string 5) '['))\n              ((equal? (string-ref string 4) '[')\n\
    \               (cond ((null? stack)\n                     (boolean? (null? opens)))\n\
    \                     ((equal? (string-ref stack ') '[)\n                    \
    \  (equal? (string-ref stack ') '('))\n                      (equal? (string-ref\
    \ opens '()) '())))\n                   ((equal? (string-ref opens '() '()) '())\n\
    \                    (equal? (string-ref stack ') '('))\n                    (equal?\
    \ (string-ref stack ') '[)\n                    (equal? (string-ref opens '()\
    \ '()) '())))\n                  ((equal? (string-ref opens '() '()) '[)\n   \
    \                (cond ((null? stack)\n                        (equal? (string-ref\
    \ stack ') '('))\n                        (equal? (string-ref stack ') '[))\n\
    \                      ((equal? (string-ref stack ') '[)\n                   \
    \    (cond ((null? stack)\n                              (equal? (string-ref stack\
    \ ') '('))\n                              (equal? (string-ref stack ') '('))\n\
    \                              (equal? (string-ref opens '() '()) '())))\n   \
    \                    ((equal? (string-ref stack ') '(')\n                    \
    \    (equal? (string-ref opens '() '()) '())\n                        (equal?\
    \ (string-ref stack ') '[))\n                       ((equal? (string-ref stack\
    \ ') '(')\n                        (equal? (string-ref opens '() '()) '[)\n  \
    \                      (equal? (string-ref opens '() '()) '(')))))\n         \
    \          ((equal? (string-ref opens '() '()) '[)\n                   (cond ((null?\
    \ stack)\n                        (equal? (string-ref stack ') '('))\n       \
    \                 (equal? (string-ref stack ') '[))\n                      ((equal?\
    \ (string-ref stack ') '[)\n                       (cond ((null? stack)\n    \
    \                          (equal? (string-ref stack ') '('))\n              \
    \                (equal? (string-ref stack '", "  \n  ;; A helper function to\
    \ find whether a nested sequence has at least 1 nested bracket.\n  ;; The nested\
    \ sequence is defined to be a sequence in which the first and last\n  ;; brackets\
    \ are nested, with the final bracket being an unmatched bracket \n  ;; with no\
    \ matching open bracket.\n  (define (nested-seq? sequence)\n    (and (= (length\
    \ sequence) 2)\n         (let ((first-open? (rest sequence)))\n           (and\
    \ (= (length first-open?) 1)\n                (equal? (first first-open?) '[)))\n\
    \           (nested-seq? (rest sequence))))\n  \n  ;; We first check if the string\
    \ is empty.\n  (not (empty? string))\n  \n  ;; If the string is empty, return\
    \ true.\n  (or (empty? string)\n      (let ((sequence (gensym \"sequence\")))\n\
    \        (define (nested-seq?-loop sequence)\n          (let ((first-open? (rest\
    \ sequence)))\n            (or (empty? first-open?)\n                (nested-seq?-loop\
    \ (rest first-open?)))))\n        (nested-seq?-loop sequence))\n      \n     \
    \ ;; If there are multiple nested brackets, it could be a nested bracket.\n  \
    \    (and (nested-seq? (rest string)))))\n", "  (cond \n    [(string-match? \"\
    \\\\[\\\\[\\\\[\" (string-ref string 0))]\n    [(string-match? \"\\\\]\\\\]\\\\\
    ]\" (string-ref string 0))]\n    [else\n     (string-match? \"\\\\[\\\\[\\\\[\"\
    \ (string-ref string 0))]\n   )\n  )\n)\n", "  (define (helper i j)\n    (cond\
    \ ((and (char= (car string) '[) (= i j))\n           (helper 0 (add1 (car string)))\n\
    \           (helper i (add1 (car string))))\n          ((and (char= (car string)\
    \ '[) (= i (add1 (car string))))\n           (helper (add1 (car string)) j)\n\
    \           (helper (add1 (car string)) (add1 (car string)))))\n  (and (helper\
    \ 0 0)\n       (= (length string) 0)))\n", "  (cond [(or (char-not (first string))\
    \ (char-not (last string))) (equal? string \"[]\")]\n        [(char-equal? (first\
    \ string) '[) ((equal? (last string) ']') (or (char-not (last string)) (equal?\
    \ (first string) '[')))]\n        [(char-equal? (first string) '(') (equal? (last\
    \ string) ']') (or (char-not (last string)) (equal? (first string) '[')))]\n \
    \       [(char-equal? (first string) '[') (equal? (last string) '(') (or (char-not\
    \ (last string)) (equal? (first string) '(')))]\n        [else false]))\n", " \
    \ (define (is-nested subseq)\n    (let loop ((start 0) (end subseq) (found #f))\n\
    \      (cond\n        ((null? end) found)\n        ((eq? start end) (set! found\
    \ #f))\n        ((string=? (char-before (string-char subseq start)) '[') (set!\
    \ found (or (not found) (loop (+ start 1) end (set! found (or (not found) (string=?\
    \ (char-before (string-char subseq start)) '['))))))\n        ((string=? (char-before\
    \ (string-char subseq start)) '(') (set! found (or (not found) (loop (+ start\
    \ 1) end (set! found (or (not found) (string=? (char-before (string-char subseq\
    \ start)) '('))))))\n        (else (set! found (or (not found) (loop (+ start\
    \ 1) end (set! found (or (not found) (loop (+ start 1) end found))))))))\n   \
    \ (set! found (or (not found) (loop (+ start 1) end found))))\n  (is-nested string))\n",
  "  (cond [(null? string) #t]\n        [(equal? (char-after string 0) #\\[) #t]\n\
    \        [(equal? (char-after string 0) #\\]) #t]\n        [else #f]))\n", " \
    \ (check-negative? string #t)\n  (< (length string) 3) \n  (= (string-length (substring\
    \ (string 0) 2) string) #f)\n  (< (string-length (substring (string 1) 2) string)\
    \ #f)\n  (< (string-length (substring (string 2) 2) string) #f)\n  (= (string-length\
    \ (substring (string 3) 2) string) #f)\n  (= (substring string 1 2) '[])))\n",
  "  (let ((open (count-open-brackets string))\n        (closed (count-close-brackets\
    \ string)))\n    (and (> open closed)\n         (equal (count-open-brackets (substring\
    \ string open)) closed)\n         (equal (count-close-brackets (substring string\
    \ open)) (- open closed)))))\n", "  (or (char=? (car string) '[')\n      (char=?\
    \ (car string) '(')\n      (char=? (car string) '[')))\n", '  (= (string-match-p
    #rx"\[+\]" string) #t)) ;; Matching the square brackets.', '  (= (length string)
    2))', "  (let ([index (char-index string '[)])\n        (stack (make-stack [index\
    \ 0])))\n    (let loop ([index index] [stack (stack-top stack)])\n      (cond\n\
    \        ;; No brackets found so there is no nesting.\n        [(and (not (stack-has-values\
    \ stack)) (string-char-match? string #\\]))\n         (and (stack-has-values stack)\
    \ (or (= index index) (= (string-char string index) '#\\]))\n         (stack-top\
    \ stack)\n         #t]\n        ;; The stack isn't empty so there is a nesting\
    \ so push the string to the stack.\n        [(and (not (stack-has-values stack))\
    \ (string-char-match? string #\\]))\n         (push (string-char string index)\n\
    \                stack)\n         (loop (char-index string index) stack)\n   \
    \      #f]\n        ;; The stack isn't empty so there is a nesting so push the\
    \ string to the stack.\n        [(and (not (stack-has-values stack)) (string-char-match?\
    \ string #\\]))\n         (push (string-char string index)\n                stack)\n\
    \         (loop (char-index string index) stack)\n         #f]\n        [#t (loop\
    \ (char-index string index) stack)]))))\n", "  (cond ((empty? string) #f)\n  \
    \      ((equal? (char-after (first string) string) #'[) #t)\n        (else (is_nested(string)))))\n",
  "  (cond\n    [(empty? string) false]\n    [(equal? (first string) '[) (contains?\
    \ string (first string) string)]\n    [else false]))\n", "  (cond\n    [(empty?\
    \ string) #t]\n    [(not (eq? (car string) ']')) #f]\n    [(is_nested(substring\
    \ (next string) 1))]\n    [else #f]))\n</code>\n<|/ a tags=common-lisp |>\n<|\
    \ c |>\nI think I like the idea of using an accumulator.  What I don't like about\
    \ this solution is that it makes it a little more complicated.  Also, this solution\
    \ does not take care of nesting, which is what OP has asked for.  I might just\
    \ as well post a recursive solution to solve the OP's problem, though, for those\
    \ interested.\n<|/ c |>\n<| c |>\nThe idea behind this solution is to use an accumulator\
    \ to keep track of what level we're at.  Then we can test and see if the level\
    \ matches.\n<|/ c |>\n<| c |>\nYeah, I agree.  I like the idea of using an accumulator,\
    \ though.  It does make the code a little more complicated, though I like the\
    \ simplicity of the accumulator's approach. The only thing I'd say is that it\
    \ isn't very elegant.  One could easily write a more elegant solution using the\
    \ same idea.\n<|/ c |>\n<| c |>\nI agree that this is elegant. Thanks for the\
    \ solution!\n<|/ c |>\n<| a tags=common-lisp |>\nIf you're using Clojure and have\
    \ access to some Lisp goodness, you might consider using a regular expression\
    \ to test whether the string contains any nested brackets.", "  (define (is-open\
    \ substring stack)\n    (cond\n      [(not (= substring \"\"))\n       (if (or\
    \ (is-open substring (substring #:stack '()))\n              (empty? stack))\n\
    \           (let ((open-brackets (substring #:stack '())))\n             (is-open\
    \ substring (cons (substring #:stack '()) stack))\n           (else\n        \
    \     (is-open substring (substring #:stack '())))]\n        [(empty? stack)\n\
    \         (false)]\n        [else\n         (is-open substring (substring #:stack\
    \ '()))]\n      ))\n    (is-open string '()))\n\n  (is-open string '()))\n", " \
    \ (cond [(empty? string) #f]\n        [(equal? string ']) #t]\n        [(equal?\
    \ string '[') #t]\n        [(equal? (car string) '(') (is_nested (cdr string))]))\n",
  "  (cond [(empty? string) empty]\n        [(equal? (first string) '[) (is_nested\
    \ (rest string))]\n        [else false]))\n", "  (cond\n    ((empty? string) #f)\n\
    \    ((symbol? string) #f)\n    ((string=? (substring string 0 1) '[') (substring\
    \ string 2 3))\n    (else (string=? (substring string 0 1) '[') (substring string\
    \ 1 2)))\n  ))\n</code>\n<|/ a dscore=3 tags=racket,scheme |>\n<| c |>\nHmm, your\
    \ solution has `is_nested('[[][')` returning `true`, which is not what the OP\
    \ wanted. Also, this doesn't take into account that `is_nested('[[]]') \u279E\
    \ false` and `is_nested('[[][[]]') \u279E true`. I was hoping to find something\
    \ that didn't require a `let`, so this isn't helpful.\n<|/ c |>\n<| c |>\nOops,\
    \ sorry. My solution assumes nested brackets. `is_nested('[[][[]]') \u279E true`.\n\
    <|/ c |>\n<| c |>\nAhh, I missed that part about not needing a let. Thanks for\
    \ the solution.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  (cond \n    [(string->char-sequence\
    \ (string->list string)) #t]\n    [else #f]\n  )\n)\n", "  (= (string-match '(#\\\
    [ #\\]) (substring string 0 (string-length string)))))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(list? (car string)) (or (is_nested (car string)) (is_nested\
    \ (cdr string)))]\n    [else (is_nested (cdr string))]))\n</code>\nThe code above\
    \ works with all of your examples. But it won't work if the brackets are nested\
    \ indefinitely. For instance:\n<code>", '  (< (length) (string-length string)
    6))', "  (if (or (string? (car string))\n          (empty? string))\n      '#t\n\
    \      (let ((char (car string)))\n        (cond\n          ((and (eq? char ']')\
    \ (string? (cdr string)))\n           (is_nested (cdr string)))\n          ((and\
    \ (eq? char ']')\n               (not (or (string? (car string))\n           \
    \              (empty? string))))\n           '#f)\n          (else (and (not\
    \ (eq? char ']'))\n                     (is_nested (cdr string)))))))\n", "  (check-type\
    \ string string)\n  (let loop ()\n    (if (empty? string)\n        false\n   \
    \     (loop (substring string 0 (length (first string))))))\n  (string-match (regex\
    \ \"(?'open' \\\\[)(?'close' \\\\])\") string))\n", "  (or (member (car string)\
    \ '())\n      (member '[ (car string))\n      (member (cadr string) '())\n   \
    \   (member (caddr string) '())\n      (member (cadddr string) '())\n      (member\
    \ (caddr string) '())\n      (member (cadddr string) '())\n      (member (cadddr\
    \ string) '())\n      (member (cadddr string) '())\n      (member (cadddr string)\
    \ '())\n      (member (cadddr string) '())\n      (member (cadddr string) '())\n\
    \      (member (cadddr string) '())\n      (member (cadddr string) '())\n    \
    \  (member (cadddr string) '())\n      (member (cadddr string) '())\n      (member\
    \ (cadddr string) '())\n      (member (cadddr string) '())\n      (member (cadddr\
    \ string) '())\n      (member (cadddr string) '())\n      (member (cadddr string)\
    \ '())\n      (member (cadddr string) '())\n      (member (cadddr string) '())\n\
    \      (member (cadddr string) '())\n      (member (cadddr string) '())\n    \
    \  (member (cadddr string) '())\n      (member (cadddr string) '())\n      (member\
    \ (cadddr string) '())\n      (member (cadddr string) '())\n      (member (cadddr\
    \ string) '())\n      (member (cadddr string) '())\n      (member (cadddr string)\
    \ '())\n      (member (cadddr string) '())\n      (member (cadddr string) '())\n\
    \      (member (cadddr string) '())\n      (member (cadddr string) '())\n    \
    \  (member (cadddr string) '())\n      (member (cadddr string) '())\n      (member\
    \ (cadddr string) '())\n      (member (cadddr string) '())\n      (member (cadddr\
    \ string) '())\n      (member (cadddr string) '())\n      (member (cadddr string)\
    \ '())\n      (member (", "  (let loop ((s string) (brackets '())\n          \
    \   (i 0))\n    (cond\n      [(= i 0)\n       (eq? (first s) '[])\n       true]\n\
    \      [(= i 2)\n       (eq? (first s) '[)]\n       true]\n      [(= i 3)\n  \
    \     (eq? (first s) '[())]\n       true]\n      [(eq? (first s) '[[])\n     \
    \  (if (= i 2)\n           (loop (cdr s) '())\n           (loop (cdr s) (bcons\
    \ brackets (cdr (cdr s)))))]\n      [(eq? (first s) '[])]\n      [(eq? (first\
    \ s) '())]\n      [else\n       (loop (cdr s) (bcons brackets (cdr (cdr s))) (+\
    \ i 1))])))\n", "  ;; Replace all [ by [ and ] by ]\n  (replace string\n     \
    \     `(,(lambda (c)\n              (if (eq? c #\\[)\n                  #\\[\n\
    \                  #\\]))\n            `,\n          `]\n          `,\n      \
    \    `[\n          `)\n  ;; Replace all ] by ] and [ by [\n  (replace string\n\
    \          `(,(lambda (c)\n              (if (eq? c #\\])\n                  #\\\
    ]\n                  #\\]))\n            `,\n          `]\n          `,\n    \
    \      `]\n          `,\n          `]\n          `)\n  ;; Replace all ] by ] and\
    \ [ by [\n  (replace string\n          `(,(lambda (c)\n              (if (eq?\
    \ c #\\])\n                  #\\]\n                  #\\]))\n            `,\n\
    \          `]\n          `,\n          `[\n          `)\n  ;; Replace all [ by\
    \ [ and ] by ]\n  (replace string\n          `(,(lambda (c)\n              (if\
    \ (eq? c #\\[)\n                  #\\[\n                  #\\]))\n           \
    \ `,\n          `[\n          `,\n          `]\n          `)\n  ;; Replace all\
    \ ] by ] and [ by ]\n  (replace string\n          `(,(lambda (c)\n           \
    \   (if (eq? c #\\])\n                  #\\]\n                  #\\]))\n     \
    \       `,\n          `[\n          `,\n          `]\n          `,\n         \
    \ `]\n          `)\n  ;; Replace all ] by ] and [ by ]\n  (replace string\n  \
    \        `(,(lambda (c)\n              (if (eq? c #\\])\n                  #\\\
    ]\n                  #\\]))\n            `,\n          `[\n          `,\n    \
    \      `]\n          `,\n          `]\n          `,\n          `]\n          `))\n",
  "  (let ((brackets (string->list string)))\n    (cond\n      [(empty? brackets)\
    \ true]\n      [(every (lambda (b) (char=? (first b) '[')) brackets)\n       (every\
    \ (lambda (b) (char=? (first b) '[')) (rest brackets))]\n      [(every (lambda\
    \ (b) (char=? (first b) '[')) (rest brackets))\n       (every (lambda (b) (char=?\
    \ (first b) '[')) (rest brackets))]\n      [(every (lambda (b) (char=? (first\
    \ b) '[')) (rest brackets))\n       (every (lambda (b) (char=? (first b) '['))\
    \ (rest brackets))]\n      [(every (lambda (b) (char=? (first b) '[')) (rest brackets))\n\
    \       (every (lambda (b) (char=? (first b) '[')) (rest brackets))]\n      [(every\
    \ (lambda (b) (char=? (first b) '[')) (rest brackets))\n       (every (lambda\
    \ (b) (char=? (first b) '[')) (rest brackets))]\n      [else\n       (every (lambda\
    \ (b) (char=? (first b) '[')) (rest brackets))]\n    )))\n", "  (if (null? string)\n\
    \      #t\n      (let loop ((i 0) (result #f))\n        (cond\n          [(char=?\
    \ (string=char string i) '[)\n           (set! result (or (loop (+ i 1) #t)\n\
    \                           (char=? (string=char string i) '])))]\n          [(char=?\
    \ (string=char string i) '])]\n          [(char=? (string=char string i) '[)\n\
    \           (set! result (or (loop (+ i 1) #f)\n                           (char=?\
    \ (string=char string i) '])))]\n          [else\n           (set! result #f)]))))\n",
  "  (and (char=? string '[')\n       (char=? string '[')\n       (char=? string '[')))\n",
  "  (match string\n    ['[' (and (is-bracket (char string (+ 0 (length (string-ref\
    \ string 0)))))\n             (is_nested (substring (string 1 0) 0))]\n    [']'\
    \ (and (not (is-bracket (char string (+ 0 (length (string-ref string 0)))))\n\
    \               (is_nested (substring (string 1 (length (string-ref string 0))\
    \ - 1)))]\n    [else false]))\n", "  (cond\n    [(or (char-equal? string #\\]\
    \ #\\]) (char-equal? string #\\] #\\]) (char-equal? string #\\] #\\]) (string-equal?\
    \ string #\\] #\\])\n    [(char-equal? string #\\] #\\]) (char-equal? string #\\\
    ] #\\]) (char-equal? string #\\] #\\]) (string-equal? string #\\] #\\])\n    [(or\
    \ (char-equal? string #\\] #\\]) (char-equal? string #\\] #\\]) (char-equal? string\
    \ #\\] #\\]) (string-equal? string #\\] #\\])\n    [(or (char-equal? string #\\\
    ] #\\]) (char-equal? string #\\] #\\]) (char-equal? string #\\] #\\]) (string-equal?\
    \ string #\\] #\\])\n    [(char-equal? string #\\] #\\]) (char-equal? string #\\\
    ] #\\]) (char-equal? string #\\] #\\]) (string-equal? string #\\] #\\])\n    [(char-equal?\
    \ string #\\] #\\]) (char-equal? string #\\] #\\]) (char-equal? string #\\] #\\\
    ]) (string-equal? string #\\] #\\])\n    [(char-equal? string #\\] #\\]) (char-equal?\
    \ string #\\] #\\]) (char-equal? string #\\] #\\]) (string-equal? string #\\]\
    \ #\\])\n    [(or (char-equal? string #\\] #\\]) (char-equal? string #\\] #\\\
    ]) (char-equal? string #\\] #\\]) (string-equal? string #\\] #\\])\n    [(char-equal?\
    \ string #\\] #\\]) (char-equal? string #\\] #\\]) (char-equal? string #\\] #\\\
    ]) (string-equal? string #\\] #\\])\n    [(char-equal? string #\\] #\\]) (char-equal?\
    \ string #\\] #\\]) (char-equal? string #\\] #\\]) (string-equal? string #\\]\
    \ #\\])\n    [(char-equal? string #\\] #\\]) (char-equal? string #\\] ", "  (let\
    \ ((char (car string)))\n    (cond\n      [(char (eq? char #\\[)) (is_nested (cdr\
    \ string))]\n      [(char (eq? char #\\])) (is_nested (car string))]\n      [(char\
    \ (eq? char #\\])) false]\n      [else true])))\n", "  (define (helper string\
    \ depth i)\n    (cond [(= i 0)\n           true]\n          [else\n          \
    \ (= (char-equal? (char string i) (char string 0))\n             (helper string\
    \ (+ depth 1) (+ i 1))]\n          )\n          )\n  (helper string 0 0))\n",
  "  (cond ((string? string) (string-match-p \"\\\\[\\\\[\\\\[\\\\]\\\\]\\\\]\\\\\
    ]\\\\]\\\\]\\\\]\\\\]\" string))\n        ((string? string) (string-match-p \"\
    \\\\[\\\\[\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\" string))\n        ((string?\
    \ string) (string-match-p \"\\\\[\\\\[\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\" string))\n\
    \        ((string? string) (string-match-p \"\\\\[\\\\[\\\\]\\\\]\\\\]\\\\]\\\\\
    ]\\\\]\" string))\n        (else false)))\n", "  (match string\n    [(_) false]\n\
    \    [(#\\[ #\\[\\[ #\\[\\[\\[ (equal? (count-open-pairs string) 1) (equal? (count-close-pairs\
    \ string) 1) true)\n    [else false]))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    That's a lot more verbose than I expected. I'm still new to racket and I've been\
    \ trying to figure this stuff out for days. I'm still trying to figure out why\
    \ this works. But thanks for the help.\n<|/ c |>\n<| c |>\nYeah, I agree, that\
    \ part is a bit convoluted. But I still think that it's useful to keep track of\
    \ brackets in strings (and even more useful to know when a string is valid). The\
    \ `equal?` condition is used to determine whether the last element in a string\
    \ is a closing bracket. The `match` keyword is used because `if` and `cond` don't\
    \ work on strings.\n<|/ c |>\n<| c |>\nYes, that part is useful. `equal?` is used\
    \ to determine whether the last element in a string is a closing bracket. `match`\
    \ keyword is used because `if` and `cond` don't work on strings.\n<|/ c |>\n<|\
    \ c |>\n\"The `match` keyword is used because `if` and `cond` don't work on strings.\"\
    \n<|/ c |>\n<| c |>\nThe `match` keyword is not for use with strings in Racket\
    \ -- it is for use with pattern matching and recursion.\n<|/ c |>\n<| a |>\nRacket\
    \ has a built-in procedure called count-pairs which counts how many times pairs\
    \ of characters are consecutive. So you can write a function that tests whether\
    \ the string contains at least one pair of brackets at position i where i goes\
    \ from 1 to string-length and count-pairs returns 2. Otherwise it returns false.\n\
    <code>\n#lang racket\n", "  (cond\n    [(empty? string) #t]\n    [(not (equal?\
    \ (peek string) ']')) #f]\n    [else (if (equal? (peek string) '[')\n        \
    \      (and (equal? (peek string (+ 1 0)) '[')\n                  (equal? (peek\
    \ string (+ 1 1)) (if (equal? (peek string (+ 1 2)) ']')\n                   \
    \                      ']'\n                                         '[')\n  \
    \                           (is_nested string (+ 1 3))))\n              (is_nested\
    \ string (+ 1 1))]))]))\n", "  (cond\n    [(equal? string \"\") false]\n    [(equal?\
    \ string \"[]\") false]\n    [(equal? string \"()\") false]\n    [(equal? string\
    \ \"{}\") false]\n    [(equal? string \"[[]\") false]\n    [else (and (char-indexed?\
    \ (string->list\n                             (string->symbol (string->list string))))\n\
    \               (nested-square-brackets string))]))\n", "  (cond\n    [(null?\
    \ string) #f]\n    [(= (car string) '[') (is_nested (rest string))]\n    [else\
    \ (is_nested (rest string))]\n  ))\n", "  (string-match-p #rx\"\\[\\[(\\[[^\\\
    ]]*\\])*\\]\\]\" string))\n", "  (cond \n    ((empty? string) false)\n    ((equal?\
    \ (first string) '[') (is_nested (rest string)))\n    (else false)))", "  (cond\
    \ [(empty? string) #f]\n        [(equal? (peek-char) '[') (is_nested-helper (string)\
    \ (+ 0 (count '[')))]\n        [else #f]))\n", "  (cond\n    ((null? string) #t)\n\
    \    ((char=? (car string) '[)\n     (is_nested\n      (substring string 0 1)\n\
    \      (substring string 1 0))\n    (else #f)))\n", "  (cond\n    [(or (string=?\
    \ (string-ref string 0) '[')\n          (string=? (string-ref string 0) '('))\
    \ ; string=? doesn't work as expected with symbols so using string-ref instead\
    \ here\n     (cond\n       [(or (string=? (string-ref string 1) '[')\n       \
    \     (string=? (string-ref string 1) '('))\n        (cond\n          [(or (string=?\
    \ (string-ref string 2) '[')\n              (string=? (string-ref string 2) '('))\n\
    \           (cond\n             [(or (string=? (string-ref string 3) '[')\n  \
    \                (string=? (string-ref string 3) '('))\n               (cond\n\
    \                 [(or (string=? (string-ref string 4) '[')\n                \
    \      (string=? (string-ref string 4) '('))\n                   (cond\n     \
    \                [(or (string=? (string-ref string 5) '[')\n                 \
    \         (string=? (string-ref string 5) '('))\n                      (cond\n\
    \                        [(or (string=? (string-ref string 6) '[')\n         \
    \                   (string=? (string-ref string 6) '('))\n                  \
    \      (cond\n                          [(or (string=? (string-ref string 7) '[')\n\
    \                              (string=? (string-ref string 7) '('))\n       \
    \                   (cond\n                            [(or (string=? (string-ref\
    \ string 8) '[')\n                                (string=? (string-ref string\
    \ 8) '('))\n                            (cond \n                             \
    \ [(or (string=? (string-ref string 9) '[')\n                                \
    \  (string=? (string-ref string 9) '('))\n                              (cond\
    \ \n                                [(or (string=? (string-ref string 10) '[')\n\
    \                                    (string=? (string-ref string 10) '('))\n\
    \                                (cond \n                                  [(or\
    \ (string=? (string-ref string 11) '[')\n                                    \
    \  (string=? (string-ref string 11) '('))\n                                  (cond\n\
    \                                    [(or (string=? (string-ref string 12) '[')\n\
    \                                        (string=? (string-ref string 12) '('))\n\
    \                                    (cond\n                                 \
    \     [(or (string=? (string-ref string 13) '[')\n                           \
    \               (string=? (string-ref string 13) '('))\n                     \
    \                 (cond\n                                        [(or (string=?\
    \ (string-ref string 14) '[')\n                                            (string=?\
    \ (string-ref string 14) '('))\n                                        (cond\n\
    \                                          [(or (string=? (string-ref string 15)\
    \ '[')\n                                              (string=? (string-ref string\
    \ 15) '('))\n                                          (cond\n", "  (match string\n\
    \    [(#\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\\
    [ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\[ #\\", "  (cond [(empty? string)\
    \ #f]\n        [(= (length string) 1) #t]\n        [(or (char=? (first string)\
    \ '[)\n             (char=? (first string) '])) #f]\n        [else\n         (let\
    \ ([(head (first string))\n                 (tail (rest string))])\n         \
    \  (and (is_nested head)\n                (or (is_nested tail)\n             \
    \       (is_nested (subseq tail 1)))))))\n", "  (cond [(null? string) #f]\n  \
    \      [(equal? (substring string 0 (string-length string) '[])\n            \
    \        (substring string 0 (string-length string) '[]]'))\n         (cond [(equal?\
    \ (substring string 1 (string-length string) '[]]') #t) #f]\n               [else\
    \ #f])\n         [else (is_nested (substring string 1 (string-length string) '[]]'))]))\n\
    </code>\n<|/ a tags=string,racket,recursion |>\n<| a tags=string,racket,recursion\
    \ |>\nI think this problem could be solved easily with regular expressions.  \n\
    <code>", "  ;; (string-length string) is a convenient function to get string length\n\
    \  ;; We want at least 1 open bracket and at least 1 close bracket.\n  ;; If (and\
    \ (>= (string-length string) 3) (string-match \"[*]\" string))\n  ;; is true then\
    \ we know that we have at least 3 open and close brackets.\n  ;; If (and (string->boolean\
    \ (substring string 0 2))\n  ;; is true then we know that we have at least 2 open\
    \ and close brackets.\n  (and (>= (string-length string) 3)\n       (string-match\
    \ \"[*]\" string)\n       (string->boolean (substring string 0 2))))", "  (cond\
    \ \n    [(empty? string) #t]\n    [(equal? (char-ref string 0) '[') #f]\n    [else\
    \ (or (equal? (char-ref string 0) '[') (equal? (char-ref string 0) ']'))]\n  )\n\
    )\n", "  (equal? (substring-count (string-to-chars string) '[') (string-to-chars\
    \ string) #t)) \n", "  (define (loop string)\n    (cond\n      [(empty? string)\
    \ #f]\n      [(char=? string '[') #t]\n      [(char=? string ']') #t]\n      [else\
    \ (and (loop (substring string 1 (char-index string '[')))\n                 \
    \ (loop (substring string (char-index string '[') (inc (char-index string ']')))))]))\n\
    \  (loop string))\n", "  (cond\n    [(equal? string '[]) true]\n    [else\n  \
    \   (equal? (rest string) '[) true\n     (equal? (rest string) ']) true\n    \
    \ (equal? (rest string) '(') true\n     (equal? (rest string) ')') true\n    \
    \ (equal? (rest string) '[') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) '(') true\n     (equal? (rest string) '[') true\n    \
    \ (equal? (rest string) '(') true\n     (equal? (rest string) ')') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) '[') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) '(') true\n    \
    \ (equal? (rest string) '[') true\n     (equal? (rest string) '[') true\n    \
    \ (equal? (rest string) '(') true\n     (equal? (rest string) ')') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest string) ']') true\n     (equal? (rest string) ']') true\n    \
    \ (equal? (rest ", "  (memq (car string) '[#t (cadr string) #t (caddr string)\
    \ #t (car string) #t (caddr string) #t (cadr string) #t (caddr string) #t (cadr\
    \ string) #t (caddr string) #t (cadr string) #t (caddr string) #t (cadr string)\
    \ #t (caddr string) #t (cadr string) #t (caddr string) #t (caddr string) #t (cadr\
    \ string) #t (caddr string) #t (caddr string) #t (cadr string) #t (caddr string)\
    \ #t (caddr string) #t (cadr string) #t (caddr string) #t (cadr string) #t (caddr\
    \ string) #t (caddr string) #t (cadr string) #t (caddr string) #t (caddr string)\
    \ #t (cadr string) #t (caddr string) #t (caddr string) #t (caddr string) #t (cadr\
    \ string) #t (caddr string) #t (caddr string) #t (caddr string) #t (cadr string)\
    \ #t (caddr string) #t (caddr string) #t (cadr string) #t (caddr string) #t (caddr\
    \ string) #t (caddr string) #t (cadr string) #t (caddr string) #t (caddr string)\
    \ #t (caddr string) #t (cadr string) #t (caddr string) #t (caddr string) #t (caddr\
    \ string) #t (caddr string) #t (cadr string) #t (caddr string) #t (caddr string)\
    \ #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr\
    \ string) #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr string)\
    \ #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr\
    \ string) #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr string)\
    \ #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr\
    \ string) #t (caddr string) #t (caddr string) #t (caddr string) #t (caddr string)\
    \ #t (caddr ", "  (cond ((string? string) (andmap string? #(or (is_nested %) [false])))\
    \ ; no more brackets\n        ((or (char= (car string) '[) (char= (car string)\
    \ '(')) (string? (cdr string)) )\n        ((or (char= (car string) '[) (char=\
    \ (car string) '('))\n         (or (is_nested (cdr string)) (is_nested (cdr (cdr\
    \ string))))) ; recurse down into string\n        (else (is_nested (cdr string)))))\
    \ ; recurse down into string\n", "  (cond ((null? string) #f)\n        (\n   \
    \       (member '[()] string) #t\n        )\n        (\n          (member '[[]]\
    \ string) #t\n        )\n        (\n          (member '[[][]] string) #t\n   \
    \     )\n        (\n          (member '[[[][]] string) #t\n        )\n       \
    \ (\n          (member '[][] string) #t\n        )\n        (\n          (member\
    \ '[] string) #t\n        )\n        (\n          (member '[[]]] string) #t\n\
    \        )\n        (\n          (member '[[]][[' #t\n        )\n        (\n \
    \         (member '[]] string) #t\n        )\n        (\n          (member '[]]]\
    \ string) #t\n        )\n        (\n          (member '[[]]]] string) #t\n   \
    \     )\n        (\n          (member '[[]]][[' #t\n        )\n        (\n   \
    \       (member '[]] string) #t\n        )\n        (\n          (member '[]]]\
    \ string) #t\n        )\n        (\n          (member '[[]][[]] string) #t\n \
    \       )\n        (\n          (member '[[]][]] string) #t\n        )\n     \
    \   (\n          (member '[[]][[]]] string) #t\n        )\n        (\n       \
    \   (member '[][[]] string) #t\n        )\n        (\n          (member '[][]]\
    \ string) #t\n        )\n        (\n          (member '[][[]]] string) #t\n  \
    \      )\n        (\n          (member '[][[]][[]] string) #t\n        )\n   \
    \     (\n          (member '[][][[]] string) #t\n        )\n        (\n      \
    \    (member '[][][]] string) #t\n        )\n        (\n          (member '[][][[]]]\
    \ string) #t\n        )\n        (\n          (member '[][][[]][[]] string) #t\n\
    \        )\n        (\n          (member '[][[]][[]] string) #t\n        )\n \
    \       (\n          (member '[][[]]] string) #t\n        )\n        (\n     \
    \     (member '[][[]][[]]] string) #t\n        )\n        (\n          (member\
    \ '[][[]][[]][[]] string) #t\n        )\n        (\n          (member '[[]][[]]\
    \ string) #t\n        )\n        (\n          (member '[][[]][[]] string", " \
    \ (cond\n    ((empty? string) #f)\n    ((equal? (char-after (car string) '[) '[')\
    \ #t)\n    ((equal? (char-after (car string) '[') #t) (is_nested (string-rest\
    \ (cdr string))))\n    ((equal? (char-after (car string) '[') #t) (is_nested (string-rest\
    \ (cdr string))))\n    ((equal? (char-after (car string) '(') #t) (is_nested (string-rest\
    \ (cdr string))))\n    ((equal? (char-after (car string) '(') #t) (is_nested (string-rest\
    \ (cdr string))))\n    ((equal? (char-after (car string) '#') #t)\n    ((equal?\
    \ (char-after (car string) '$') #t)\n    ((equal? (char-after (car string) '!')\
    \ #t)\n    ((equal? (char-after (car string) '@') #t)\n    ((equal? (char-after\
    \ (car string) '#') #t)\n    ((equal? (char-after (car string) '$') #t)\n    ((equal?\
    \ (char-after (car string) '!') #t)\n    ((equal? (char-after (car string) '@')\
    \ #t)\n    ((equal? (char-after (car string) '-') #t)\n    ((equal? (char-after\
    \ (car string) '-') #t)\n    ((equal? (char-after (car string) '-') #t)\n    ((equal?\
    \ (char-after (car string) '-') #t)\n    ((equal? (char-after (car string) '-')\
    \ #t)\n    ((equal? (char-after (car string) '-') #t)\n    ((equal? (char-after\
    \ (car string) '-') #t)\n    ((equal? (char-after (car string) '-') #t)\n    ((equal?\
    \ (char-after (car string) '-') #t)\n    ((equal? (char-after (car string) '-')\
    \ #t)\n    ((equal? (char-after (car string) '-') #t)\n    ((equal? (char-after\
    \ (car string) '-') #t)\n    ((equal? (char-after (car string) '-') #t)\n    ((equal?\
    \ (char-after (car string) '-') #t)\n    ((", "  (for/or ([i string] [j string])\n\
    \    (and (empty? j) (not (eq? (car i) (car j))))))\n", "  (or (string=? (string-ref\
    \ string 1) '[')\n      (string=? (string-ref string 1) ']')))\n", "  (cond\n\
    \    ((string? string) #t)\n    ((empty? string) #f)\n    ((equal? (car string)\
    \ '[') #t)\n    ((equal? (car string) '[')\n     (and (is_nested (cdr string)))\n\
    \     (or (is_nested (cdr string)) (is_nested (cdr string))))\n    (else (is_nested\
    \ (cdr string)))))\n", "  (cond ((or (equal? string \"\") #t)\n         #f)\n\
    \        ((equal? (char-after string '[') '[')\n         (equal? (char-after string\
    \ ']') ']')\n         (equal? (char-after string '(') '(')\n         (equal? (char-after\
    \ string ')') ')')\n         (equal? (char-after string '{') '{')\n         (equal?\
    \ (char-after string '}') '}')\n         (equal? (char-after string '\\'')\n \
    \                 '[')\n         (equal? (char-after string ']')\n           \
    \      ']')\n         (equal? (char-after string '(')\n                 '(')\n\
    \         (equal? (char-after string ')')\n                 ')')\n         (equal?\
    \ (char-after string '[')\n                 '[')\n         (equal? (char-after\
    \ string '\\'')\n                 ']')\n         (equal? (char-after string ']')\n\
    \                 ']')\n         (equal? (char-after string '[')\n           \
    \      ']')\n         (equal? (char-after string '(')\n                 ')')\n\
    \         (equal? (char-after string '}')\n                 '}')\n         (equal?\
    \ (char-after string '[')\n                 ']')\n         (equal? (char-after\
    \ string '[')\n                 '(')\n         (equal? (char-after string ')')\n\
    \                 ']')\n         (equal? (char-after string '(')\n           \
    \      ')')\n         (equal? (char-after string '[')\n                 ']')\n\
    \         (equal? (char-after string '(')\n                 '{')\n         (equal?\
    \ (char-after string '[')\n                 ']')\n         (equal? (char-after\
    \ string '[')\n                 ']')\n         (equal? (char-after string '{')\n\
    \                 '{')\n         (equal? (char-after string '[')\n           \
    \      ']')\n         (equal? (char-after string '[')\n                 ']')\n\
    \         (equal? (char-after string '[')\n                 ']')\n         (equal?\
    \ (char-after string '[')\n                 ']')\n         (equal? (char-after\
    \ string '[')\n                 '[')\n         (equal? (char-after string '[')\n\
    \                 ']')\n         (equal? (char-after string '[')\n           \
    \      ']')\n         (equal? (char-after string '[')\n                 ']')\n\
    \         (equal? (char-after string '[')\n                 '(')\n         (equal?\
    \ (", "  (= (length string) 4)\n  (memq (char string 0) '[])\n  (memq (char string\
    \ 1) '[][])\n  (memq (char string 2) '[]])\n  (memq (char string 3) '[][])\n \
    \ (memq (char string 4) '[[[]'))\n", "  (match string\n    ('[] #f)\n    (([[]])(#t\
    \ #f))\n    (([()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()[()",
  "  (or (equal? (length string) 0)\n      (equal? (substring string 0 1) (substring\
    \ string 1 0))))\n", "  (let ((brackets '([])) (instructions string))\n    (cond\
    \ ((null? instructions)\n           #f)\n          ((equal? (car instructions)\
    \ '[)\n           (set! brackets (append (cdr brackets) (list '(]))))\n      \
    \    ((equal? (car instructions) ']')\n           (set! brackets (append (cdr\
    \ brackets) '(')))\n          ((equal? (car instructions) '[[])\n           (cond\n\
    \             ((equal? (car brackets) '(])\n              (set! instructions (cdr\
    \ instructions))\n              (cond\n                ((null? instructions)\n\
    \                #t)\n                (else\n                (cond\n         \
    \         ((equal? (car instructions) '(')\n                   (cond\n       \
    \             ((equal? (car brackets) '(])\n                     (set! instructions\
    \ (cdr instructions))\n                     (cond\n                       ((null?\
    \ instructions)\n                       (set! instructions string))\n        \
    \               (else\n                       (cond\n                        \
    \ ((equal? (car instructions) '[)\n                         (cond\n          \
    \                 ((equal? (car brackets) '(])\n                           (set!\
    \ instructions (cdr instructions))\n                           (cond\n       \
    \                      ((equal? (car instructions) '[)\n                     \
    \        (cond\n                               ((equal? (car brackets) '(])\n\
    \                               (set! instructions (cdr instructions))\n     \
    \                          (cond\n                                 ((equal? (car\
    \ instructions) '[)\n                                 (cond\n                \
    \                   ((equal? (car brackets) '(])\n                           \
    \        (set! instructions (cdr instructions))\n                            \
    \       (cond\n                                     ((equal? (car instructions)\
    \ '[)\n                                     (cond\n                          \
    \             ((equal? (car brackets) '(])\n                                 \
    \      (set! instructions (cdr instructions))\n                              \
    \         (cond\n                                         ((equal? (car instructions)\
    \ '[)\n                                         (cond\n                      \
    \                     ((equal? (car brackets) '(])\n                         \
    \                  (set! instructions (cdr instructions))\n                  \
    \                         (cond\n                                            \
    \ ((equal? (car instructions) '[)\n                                          \
    \   (cond\n                                               ((equal? (car brackets)\
    \ '(])\n                                               (set! instructions (cdr\
    \ instructions))\n                                               (cond\n     \
    \                                            ((equal? (car instructions) '[)\n\
    \                                                 (cond\n                    \
    \                               ((equal? (car brackets) '(])\n               \
    \                                    (set! instruction", "  (string-match? #rx\"\
    \\[(\\[]*\\)\\]\" string))\n", "  (cond ((= (length string) 0) #t)\n        ((string=?\
    \ (substring string 0 0)\n                    '[[]])\n         (is_nested (substring\
    \ string 1 0))\n         (= (length (substring string 0 0)) (length (substring\
    \ string 1 0)))))\n</code>\n<|/ a dscore=2 tags=recursion,racket,scheme |>\n<|\
    \ a |>\n<code>", "  (let ((brackets (regexp-opt '\\[ (regexp-opt ']) string #t)))\n\
    \    (or (null? brackets) (= (car brackets) '(#t #t)))))\n", "  (< (length) (string-length\
    \ string) 2)\n  (< (string=? string '[[]]) (string=? string '[]]]]]]][[[[[])))\n",
  "  (let loop ((i 0)\n             (string string))\n    (cond ((null? string) false)\n\
    \          ((= (length string) i) true)\n          ((char=? (char-code (substring\
    \ string i 1)) (char-code (substring string 0 i)))\n           (loop (+ i 1) (substring\
    \ string i 1)))\n          (else (loop (+ i 1) string)))))\n", "  (loop for char\
    \ (string->list (string-ref string 0)) \n        until (or (string? char) (char->string?\
    \ char)) \n        collect (and (or (string? char) (char->string? char)) \n  \
    \                  (char->string? (string-ref string 1)))))\n", "  (if (null?\
    \ string) #t\n      (let* ((ch (first string))\n             (chs (rest string))\n\
    \             (inner (is_nested chs)))\n        (cond\n          [(and (list?\
    \ chs) (eq? chs '[])) #t]\n          [(and (list? chs) (eq? chs '[)) (or (eq?\
    \ ch (first chs)) (eq? ch (first chs))\n                (is_nested (first chs))))\n\
    \           (and (list? chs) (eq? chs '(')) (or (eq? ch (first chs)) (eq? ch (first\
    \ chs))\n                (is_nested (first chs))))\n           (and (list? chs)\
    \ (eq? chs '])) (or (eq? ch (first chs)) (eq? ch (first chs))\n              \
    \  (is_nested (first chs))))\n           (and (list? chs) (eq? chs ']')) (or (eq?\
    \ ch (first chs)) (eq? ch (first chs))\n                (is_nested (first chs))))\n\
    \          [else #f]\n          [(and (list? chs) (eq? chs '('))\n           (and\
    \ (list? (first chs)) (is_nested (first chs)))]\n          [(and (list? chs) (eq?\
    \ chs ']'))\n           (and (list? (first chs)) (is_nested (first chs)))]\n \
    \         [else #f]))))\n", "  (cond\n    [(empty? string) #f]\n    [(not (pair?\
    \ string))\n     (not (equal? (first string) '('))\n     (not (equal? (first string)\
    \ '['))\n     (not (equal? (first string) '{'))\n     (not (equal? (first string)\
    \ '|'))\n     (not (equal? (first string) '<'))\n     (not (equal? (first string)\
    \ '>'))]\n    [(equal? (first string) '(') (is_nested (rest string))]\n    [(equal?\
    \ (first string) '[') (is_nested (rest string))]\n    [(equal? (first string)\
    \ '{') (is_nested (rest string))]\n    [(equal? (first string) '|') (is_nested\
    \ (rest string))]\n    [(equal? (first string) '<') (is_nested (rest string))]\n\
    \    [(equal? (first string) '>') (is_nested (rest string))]\n    [(equal? (first\
    \ string) '|') (is_nested (rest string))]\n    [(equal? (first string) '<') (is_nested\
    \ (rest string))]\n    [(equal? (first string) '>') (is_nested (rest string))]\n\
    \    [else (is_nested (rest string))]\n   )\n  )\n)\n", "  (define (find i string)\n\
    \    (cond\n      [(empty? string) #t]\n      [(equal? #\\[ symbol) (or (find\
    \ (+ i 1) (substring string 0 i)))]\n      [(equal? #\\] symbol) (or (find (+\
    \ i 1) (substring string i (+ i 1))))]))\n  (find 0 (substring string 0 0))))\n\
    </code>\n<|/ a tags=subsequence,scheme,recursion,racket |>\n<| c |>\nNice.  I\
    \ didn't know about `substring`, but that's useful. My answer is based on this\
    \ answer: http://stackoverflow.com/a/2832206/893780\n<|/ c |>\n<| c |>\nThanks\
    \ for your answers. I appreciate them. I am new to Scheme so I want to try all\
    \ things I can think of to do it myself. It turns out this was a problem of mine.\
    \ Thanks again.\n<|/ c |>\n<| a tags=subsequence,scheme,recursion,racket dscore=0\
    \ |>\nI would say something like this:\n<code>", "  (cond ((null? string) #f)\n\
    \        ((equal? (car string) '(') (is_nested (cdr string)))\n        (else (is_nested\
    \ (cdr string))))) ;; cond will short circuit here if any of it's branches return\
    \ #f\n", "  (let ([open-brackets '()])\n    (cond [(equal? (char-syntax (car string))\
    \ '(') (set! open-brackets (cons (car string) open-brackets))]\n          [(equal?\
    \ (char-syntax (car string)) '[) (let ([match (substring string 0 (cdr (length\
    \ string)))])\n                                                 (if (equal? (char-syntax\
    \ (car match)) '[) (set! open-brackets (cons (car match) open-brackets))\n   \
    \                                                  (if (equal? (char-syntax (car\
    \ match)) '(') (set! open-brackets (cons (car match) open-brackets))\n       \
    \                                                  (return (= (length open-brackets)\
    \ 0))))])\n          [(equal? (char-syntax (car string)) '\\') (return (= (length\
    \ open-brackets) 0))]\n          [(equal? (char-syntax (car string)) ')') (return\
    \ (= (length open-brackets) 0))]\n          [else (return (= (length open-brackets)\
    \ 0))]))))\n", "  (let loop ((count 0))\n    (cond ((and (char=? #\\[ (string-ref\
    \ string count))\n                (char=? #\\] (string-ref string count)))\n \
    \         (loop (add1 count))\n          (else\n           (loop (add1 count)))))\n\
    \  (and (>= count 1)\n       (= (string-ref string 0) #\\]))))\n", "  (cond [(string=?\
    \ (substring string 0 (string-length string)) '([])') #t]\n        [else #f]))\n",
  "  (let loop ((string string) (brackets '(()))\n            (valid #f))\n    (cond\
    \ ((null? string) #f)\n          ((char? string)\n           (loop (string-tail\
    \ string) (append brackets (char-square-bracket-position string)) valid))\n  \
    \        ((char? string-tail (string-tail string))\n           (loop (string-tail\
    \ string) brackets valid))\n          (else (and (pair? (car-rest brackets))\n\
    \                    (loop (car-rest brackets) (brackets (cdr brackets)) valid)))))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\n: thank you! I didn't know about\
    \ `string-tail`. I'm going to use that in my answer.\n<|/ c |>\n<| a tags=racket,scheme\
    \ dscore=0 |>\nI have found that my solution below works with nested brackets.\
    \ I will add my solution for nested parentheses below in case it is helpful to\
    \ anyone.\n<code>", "  (cond\n    [(empty? string) #t]\n    [(eq? (first string)\
    \ '(#\\]) #f] \n    [(eq? (first string) '(#\\]) #t]\n    [else\n     (is_nested(substring\
    \ (next string) 0 -1))]))\n", "  (or (equal? (length (subseq string 0 0)) (length\
    \ string))\n      (member (subseq string 0 0) '([]))))\n", "  (cond \n    [(=\
    \ 0 (string-length string)) #t]\n    [(= 1 (string-length string)) #f]\n    [(string-ref\
    \ string 0) (cond \n                            [(string=? (string= #\\( string))\
    \ #t]\n                            [(string=? (string= #\\[ string)) #f]\n   \
    \                         [(string=? (string= #\\{ string)) #f]\n            \
    \                [(string=? (string= #\\[ string)) #f]\n                     \
    \       [(string=? (string= #\\{ string)) #t]\n                            [else\
    \ #f])]\n    [else (cond \n             [(string=? (string= #\\( string)) #t]\n\
    \             [(string=? (string= #\\[ string)) #f]\n             [(string=? (string=\
    \ #\\{ string)) #f]\n             [(string=? (string= #\\[ string)) #f]\n    \
    \         [(string=? (string= #\\{ string)) #t]\n             [else #f])]\n  \
    \ )\n  )\n)\n", "  (cond [(empty? string) #t]\n        [(equal? (car string) '[')\
    \ #t]\n        [(equal? (car string) '(') #f]\n        [(equal? (car string) '[')\
    \ #f]\n        [else (and (is_nested(substring (next string) 1) #f)\n        \
    \           (is_nested(substring (next string) (- next (string))) #t))]))\n",
  "  (= (string-match '\\[' string #\\[\\])\n     (string-match '\\[' string #\\[\\\
    [)\n     (string-match '\\[' string #\\[\\[[])))\n", "  (cond [(empty? string)\
    \ #f]\n        [(equal? (car (cdr string)) '[') (is_nested(cdr (cdr string)))]\n\
    \        [else #f]))\n", "  (and (= '() (count-nest '[] string))\n       (= 0\
    \ (count-nest '((c)) string))\n       (= 1 (count-nest '((c (d (e f))) g) string))))\n",
  "  (define valid (or (null? string) (equal? (car string) '[') (equal? (car string)\
    \ ']')))\n  (if (null? string) (not valid) \n      (or (is_nested (cdr string))\n\
    \          (or (not (valid))\n              (or (equal? (car string) '(') (equal?\
    \ (car string) '{')))))\n  )\n)\n", "  (cond\n    [(null? string) #t]\n    [(equal?\
    \ (car string) '(') #f)\n     (if (and (equal? (cdr string) '[')\n           \
    \   (equal? (cdr (cdr string)) ']'))\n         #t\n         (if (and (equal? (cdr\
    \ string) '[')\n                  (equal? (cdr (cdr string)) '('))\n         \
    \    #t\n             #f))]\n    [(equal? (car string) '[') #t]\n    [else (is_nested\
    \ (cdr string))]))\n", "  (cond\n    ((null? string) #f)\n    ((char=? (car string)\
    \ '[) (is_nested (cdr string))\n    ((char=? (car string) ']') #t)\n    (else\
    \ (is_nested (cdr string))))))\n", "  (match string\n    ((string (char (char-code\
    \ #\\[]) (char-code #\\]))) #t)\n    ((string (char (char-code #\\[]) (char-code\
    \ #\\]) (char-code #\\])))\n    (else #f)))\n</cell>\n<cell>\n#lang racket\n",
  "  (if (or (empty? string)\n          (equal? string '()))\n      #t\n      (let\
    \ loop ((cur string)\n                 (result #t))\n        (cond\n         \
    \ ((char=? (car cur) '[') #t)\n          ((char=? (car cur) '(lambda (\n     \
    \                            (lambda (\n                                     (lambda\
    \ (\n                                         (lambda (\n                    \
    \                         (lambda (\n                                        \
    \       (lambda (\n                                                   (lambda\
    \ (\n                                                      (lambda (\n       \
    \                                                  (lambda (\n               \
    \                                              (lambda (\n                   \
    \                                            (lambda (\n                     \
    \                                              (lambda (\n                   \
    \                                                 (lambda (\n                \
    \                                                     (lambda (\n            \
    \                                                         (lambda (\n        \
    \                                                               (let ((lambda\
    \ (\n                                                                        \
    \   (lambda (\n                                                              \
    \               (let ((lambda (\n                                            \
    \                                       (lambda (\n                          \
    \                                                           (let ((lambda (\n\
    \                                                                            \
    \               (lambda (\n                                                  \
    \                                           (let ((lambda (\n                \
    \                                                                            \
    \       (lambda (\n                                                          \
    \                                           (let ((lambda (\n                \
    \                                                                            \
    \             (lambda (\n                                                    \
    \                                                       (let ((lambda (\n    \
    \                                                                            \
    \                               (lambda (\n                                  \
    \                                                                            \
    \   (let ((lambda (\n                                                        \
    \                                                             (lambda (\n    \
    \                                                                            \
    \                                       (let ((lambda (\n                    \
    \                                                                            \
    \                          (lambda (\n                                       \
    \                                                                            \
    \          (let ((lambda (\n                                                 \
    \                                                                            \
    \  (lambda (\n                                                               \
    \                                                                    (let ((lambda\
    \ (\n                                                                        \
    \                                                             (let ((lambda (\n\
    \                                                                            \
    \                                                             (lambda (\n    \
    \                                                                            \
    \                                                           (let ((lambda (\n\
    \                                                                            \
    \                                                                   (lambda (\n\
    \                                                                            \
    \                                                                     (let ((lambda\
    \ (\n                                                                        \
    \                                                                            \
    \   (lambda (\n                                                              \
    \                                                                            \
    \               (let ((lambda (\n                                            \
    \                                                                            \
    \                                   (lambda (\n                              \
    \                                                                            \
    \                                                  (let ((lambda (\n         \
    \                                                                            \
    \                                                                         (lambda\
    \ (\n                                                                        \
    \                                                                            \
    \             (let ((lambda (\n                                              \
    \                                                                            \
    \                                            (lambda (\n                     \
    \                                                                            \
    \                                                                        (let\
    \ ((lambda (\n                                                               \
    \                                                                            \
    \                                    (lambda (\n                             \
    \                                                                            \
    \                                                                        (let\
    \ ((lambda (\n                                                               \
    \                                                                            \
    \                                       (let ((lambda (\n                    \
    \                                                                            \
    \                                                                            \
    \         (lambda (\n                                                        \
    \                                                                            \
    \                                                   (let ((lambda (\n        \
    \                                                                            \
    \                                                                            \
    \                        (let ((lambda (\n                                   \
    \                                                                            \
    \                                                                            (let\
    \ ((lambda (\n                                                               \
    \                                                                            \
    \                                                  (let ((lambda (\n         \
    \                                                                            \
    \                                                                            \
    \                              (lambda (\n                                   \
    \                                                                            \
    \                                                                            \
    \      (let ((lambda (\n                                                     \
    \                                                                            \
    \                                                                  (let ((lambda\
    \ (\n                                                                        \
    \                                                                            \
    \                                                                (let ((lambda\
    \ (\n                                                                        \
    \                                                                            \
    \                                                                   (lambda (\n\
    \                                                                            \
    \                                                                            \
    \                                                                 (let ((lambda\
    \ (\n                                                                        \
    \                                                                            \
    \                                                                       (lambda\
    \ (\n                                                                        \
    \                                                                            \
    \                                                                        (let\
    \ ((lambda (\n                                                               \
    \                                                                            \
    \                                                                            \
    \       ", "  (cond\n    [(empty? string) #f]\n    [(equal? (car string) '[')\
    \ #t]\n    [else (is_nested (cdr string))]))\n", "  (if (= 0 (string-length string))\n\
    \      #f\n      (let ((stack '())\n            (bracket 0))\n        (for ((char\
    \ (string-ref string 0)))\n          (cond ((char= char #\\]) stack)\n       \
    \         ((char= char #\\[]) (if (<= (length stack) 0) #f (cons (car stack) (push\
    \ (cdr stack) bracket)))\n                (else\n                 (let ((nest_length\
    \ (string-length stack))\n                      (nest_char (cadr stack)))\n  \
    \                (cond ((= (char= nest_char #\\]) nest_length)\n             \
    \            (push (car stack) bracket))\n                        ((char= nest_char\
    \ #\\)) #t\n                        (else\n                         (push (car\
    \ stack) bracket)\n                         (push (car stack) nest_char))))))))))\n",
  "  (cond [(empty? string) #f]\n        [(string-match? '[[]] (car string) #t) #t]\n\
    \        [else #f]))\n", "  (or (string= string \"\")\n      (subsequence? (remove-brackets\
    \ string))))\n", "  (cond\n    [(null? string) False]\n    [(equal? (car string)\
    \ '[') (is_nested\n                                (append (append (append '[)\
    \ (cdr string))\n                                        (append (cdr string)\
    \ ']'))) True]\n    [else (is_nested (cdr string))]))\n", "  (let loop ((i 0))\n\
    \    (if (or (= i string.length) (= (string-length string) 0))\n        #f\n \
    \       (loop (add1 i))\n        ; If we're at the end of a substring and we still\
    \ have an open bracket,\n        ; then we're not nested.\n        (or (string->char\
    \ (substring string i i))\n            (string->char (substring string (add1 i)\
    \ i))\n            (string->char (substring string (add1 i) (add1 i)))))))\n",
  "  (= (length string) 2)\n  (= (car string) '[)\n  (= (cadr string) '[)\n  (= (caddr\
    \ string) ']])\n  (= (cadddr string) ']])\n  (= (cadddr string) '[)\n  (= (cadddr\
    \ string) ']]))\n</code>\nThen it is easy to see that is_nested would behave as\
    \ expected:\n<code>", "  (define (count-open-brackets s)\n    (cond\n      [(empty?\
    \ s) 0]\n      [(equal? (char-code (car s)) open-paren) (+ 1 (count-open-brackets\
    \ (cdr s)))]\n      [(equal? (char-code (car s)) close-paren) (+ 1 (count-open-brackets\
    \ (cdr s)))]\n      [else (+ 1 (count-open-brackets (cdr s)))]))\n  (<= 1 (count-open-brackets\
    \ string))\n)\n", "  (cond [(equal? (string-match? '([]) string) #t)\n       \
    \  (equal? (string-match? '(()) string) #f)\n         (equal? (string-match? '([])\
    \ (string-match? '(()) string) #t)\n         (equal? (string-match? '(()) (string-match?\
    \ '([]) string) #f)\n         :else #f)\n         ]\n        (#t #t)))\n", " \
    \ (cond [(empty? string) #t]\n        [(equal? (char-at-pos? string (length (string-ref\
    \ string 0))) ']) #t]\n        [(char-at-pos (stringref string 0) 0) #t]\n   \
    \     [else (= (string-length (substring string 0 (char-index (char-at-pos? string\
    \ 1) (length (string-ref string 0)))))\n                (char-index (char-at-pos?\
    \ string 0) (string-length (substring string 0 (char-index (char-at-pos? string\
    \ 1) (length (string-ref string 0)))))))]))\n", "  ;; Write a Boolean function\
    \ using only 'if' that takes a single string as input\n  ;; and returns True if\
    \ and only if there is a valid subsequence of\n  ;; brackets containing at least\
    \ one bracket in the subsequence\n  (define (is-bracket-valid string index)\n\
    \    (cond\n      [(equal? string \"[]\") (equal? (substring string index index)\
    \ \")]\") #t]\n      [(equal? string \"[[]\") (equal? (substring string index\
    \ index) \"[]\") #t]\n      [else #f]))\n\n  (cond [(equal? (length string) 0)\
    \ #t]\n        [else (and (equal? (car string) '(') (and (is-bracket-valid string\
    \ (+ index 1))))\n                (is-bracket-valid (string) (+ index 1)))]))\n",
  "  (cond\n    [(equal? string \"\") false]\n    [(equal? string '[]) false]\n  \
    \  [else (cond\n            [(equal? (car string) '[) (is_nested(substring (string\
    \ 1) 2))]\n            [else (is_nested(substring (string 1) 1))])]))\n", "  (define\
    \ (check-nesting current-open-bracket found-open-brackets)\n    (cond\n      [(and\
    \ (= (car current-open-bracket) (car found-open-brackets))\n            (not (null?\
    \ (cdr current-open-bracket)))\n            (not (null? (cdr found-open-brackets)))\n\
    \            (= (car found-open-brackets) (car current-open-bracket))\n      \
    \      (= (car (cdr found-open-brackets)) (car (cdr current-open-bracket)))\n\
    \            (not (null? (cdr (cdr found-open-brackets))))\n            (not (null?\
    \ (cdr (cdr current-open-bracket))))\n            (= (cdr found-open-brackets)\
    \ (cdr current-open-bracket))\n            (= (cdr (cdr found-open-brackets))\
    \ (cdr (cdr current-open-bracket)))\n            (not (null? (cdr (cdr (cdr found-open-brackets)))))\n\
    \            (not (null? (cdr (cdr (cdr current-open-bracket))))\n           \
    \ (check-nesting (cdr current-open-bracket) (cdr found-open-brackets))\n     \
    \       true) false\n      [(null? found-open-brackets) false\n       true]\n\
    \      [else (check-nesting (cdr current-open-bracket) (cdr found-open-brackets))]))\n\
    \  (check-nesting string '()))\n", "  (cond [(empty? string) #t]\n        [(or\
    \ (char-bracket (car string)) (char-bracket (cdr string))) #f]\n        [(or (char-bracket\
    \ (car string)) (char-bracket (car string))) #f]\n        [else (or (is_nested\
    \ (car string)) (is_nested (cdr string)))]))\n", "  (cond\n    [(string-match?\
    \ '([[])' string) true]\n    [(string-match? '([[[[[[]])' string) true]\n    [(string-match?\
    \ '([[]])' string) true]\n    [else false]))\n", "  (let-values ([(a b) (index?\
    \ string #\\[[)])\n             ((c (substring string 1 index?))\n           \
    \    (length? (substring string length? c)))])\n    (and (not (or (zero? a) (zero?\
    \ b) (zero? c)))\n         (or (= a b)\n             (= a c)\n             (=\
    \ b c)))))\n", "  (or\n   (string-contains \"[[]]\" (substring string 0 string-length\
    \ string)) \n   (string-contains \"[[]\" string) \n   (string-contains \"[\" string)\
    \ \n   (string-contains \"]\" string) \n   (string-contains \"][]]\" string) \n\
    \   (string-contains \"[]]\" string) \n   (string-contains \"][]\" string) \n\
    \   (string-contains \"]\" string) \n   (string-contains \"[[]\" string) \n  \
    \ (string-contains \"[[][]]\" string) \n   (string-contains \"[][]\" string) \n\
    \   (string-contains \"[]\" string)))\n", "  (cond\n    [(= (length string) 0)\
    \ #f]\n    [(string-char-b? (car string)) (is_nested (cdr string))]\n    [else\
    \ (or (is_nested (car string)) (is_nested (cdr string)))]))\n", "  ; Iterate through\
    \ the string and check whether there is nested square brackets.\n  (define (iter\
    \ remaining-string)\n    (cond [(empty? remaining-string) #t]\n          [(equal?\
    \ (first remaining-string) '[)\n           (iter (rest remaining-string))]\n \
    \         [(equal? (first remaining-string) '(]) (iter (rest remaining-string))]))\n\
    \  ; Check whether the string is valid.\n  (iter string))\n", "  (cond\n    [(null?\
    \ string) #f]\n    [(= '[] string) #f]\n    [else (and (equal? (car string) (caar\
    \ string)) \n               (equal? (cadr string) (caar string)))]))\n", "  (cond\n\
    \    ((or (string? string) (null? string)) (error \"is_nested: Argument should\
    \ be a string\"))\n    ((string? (substring string 0 0))\n     (if (or (string?\
    \ (substring string 1 1)) (string? string)) (is_nested string) false))\n    ((string?\
    \ (substring string 0 1))\n     (if (or (string? (substring string 0 2)) (string?\
    \ string)) (is_nested string) false))\n    ((string? (substring string 0 2))\n\
    \     (if (or (string? (substring string 0 3)) (string? string)) (is_nested string)\
    \ false))\n    ((string? (substring string 0 3))\n     (if (or (string? (substring\
    \ string 1 3)) (string? string)) (is_nested string) false))\n    ((string? (substring\
    \ string 1 4))\n     (if (or (string? (substring string 2 4)) (string? string))\
    \ (is_nested string) false))\n    ((string? (substring string 2 4))\n     (if\
    \ (or (string? (substring string 3 4)) (string? string)) (is_nested string) false))\n\
    \    ((string? (substring string 3 4))\n     (if (or (string? (substring string\
    \ 4 4)) (string? string)) (is_nested string) false))\n    (else (is_nested string))))\n",
  "  \n  (let ((brackets '()))\n    (loop \n      (let ((char (char-code string)))\n\
    \        (if (or\n              (= char #\\[])\n              (brackets '())\n\
    \              (cond \n                ((char= char #\\[) (set! brackets (cons\
    \ char brackets))\n                 (char= char #\\]) \n                 (or (char=\
    \ char #\\]]) \n                     (= (length brackets) 0)\n               \
    \      (not (= (substring string 0 (- (length string) 1)) #\\[]))\n          \
    \           (not (= (substring string 1 (- (length string) 1)) #\\[])))))\n  \
    \      (recur (char-code string))))))\n", "  (= #t (foldr (lambda (c acc)\n  \
    \                 (if (and (= c '[) (= c '('))\n                       (add-to-acc\
    \ '())\n                       (add-to-acc '())))\n                 '(#t #f) string)))\n",
  "  (cond [(empty? string) #f]\n        [(equal? (first string) '[') (is_nested (substring\
    \ (second string) 0 (- (length string) 1)))]\n        [else (is_nested (substring\
    \ (first string) 0 (- (length string) 1)))]))\n", "  (cond\n    [(empty? string)\
    \ true]\n    [(string-match? '[[]]' string) true]\n    [(string-match? '[]][][][]'\
    \ string) true]\n    [(string-match? '[][]' string) false]\n    [(string-match?\
    \ '[[][]]' string) true]\n    [(string-match? '[[]]' string) false]\n    [else\
    \ false]))\n", "  (or (equal? (length string) 0) \n      (= (length string) (-\
    \ 2 (length \n                             (remove-prefix (remove-suffix string\
    \ '[') '[[['))))))\n  "]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
