name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n;; Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\n;; such that the smallest number will become\
  \ 0 and the largest will become 1\n;; >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
  ;; [0.0, 0.25, 0.5, 0.75, 1.0]\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (apply map (lambda (number) \n               (/ (- number number)\
    \ 2))\n         numbers))\n", "  (let ((min-max (min-max numbers)))\n    (if (eq?\
    \ min-max '())\n        '()\n        (cons (/ (- (car numbers) min-max) min-max)\
    \ (remainder-to-unit numbers)))))\n", "  (let ((min (min-of numbers)))\n    (let\
    \ ((max (max-of numbers)))\n      (/ (map minus numbers max) 2))))\n", "  (let\
    \ loop ((numbers '())\n             (min (min numbers))\n             (max (max\
    \ numbers)))\n    (if (null? numbers)\n        '()\n        (if (and (number?\
    \ (car numbers))\n                 (< min (car numbers)))\n            (append\
    \ (loop (cdr numbers) min max)\n                    (cdr numbers))\n         \
    \   (cons (/ (- (car numbers) max) (- (car numbers) min)) \n                 \
    \ (loop (cdr numbers) min max)))))\n", "  (let ((min-max min-max-init))\n    (loop\
    \ for num in numbers min-max min-max-init\n          for min-max-init = (if (<\
    \ num min-max) min-max num) min-max min-max-init\n          collect num))\n  )\n",
  "  (apply map rescale numbers))\n", "  (rescale_to_int numbers 1.0))\n", "  (apply\
    \ min-max numbers))\n", "  (if (null? numbers)\n      '()\n      (let ([smallest\
    \ (car numbers)])\n        (rescale_to_unit (rest numbers)\n                 \
    \      (- smallest\n                          (* 1\n                         \
    \   (+ (car numbers)\n                              (* smallest\n            \
    \                         (car numbers)))))))))\n", "  (if (null? numbers)\n \
    \     numbers\n      (let ([min (car numbers)\n            max (cdr numbers)])\n\
    \        (if (< min 0)\n            (- min (/ (max min) max))\n            max))))\n",
  "  (if (or (= 0 (min numbers)) (= 1 (max numbers)))\n      numbers\n      (apply\
    \ map\n             #(/ (- %1 %2) (min numbers))\n             (range numbers))))\n",
  "  (let ([min-num (minimum numbers)])\n    (let ([max-num (maximum numbers)])\n\
    \      (map (lambda (n)\n             (* n min-num max-num))\n           numbers))))\n",
  "  (let ((min (apply min numbers)))\n    (if (null? numbers)\n        numbers\n\
    \        (let ((max (apply max numbers)))\n          (map (lambda (n)\n      \
    \           (/ (- n min)\n                   (- max min))\n                 min))\n\
    \              numbers))))\n", "  (let ([min (min numbers)\n         max (max\
    \ numbers)])\n    (cond\n      [(empty? numbers) numbers]\n      [(< (first numbers)\
    \ min) (cons 0 (rescale_to_unit (cons (first numbers) (cons (first numbers) (cons\
    \ (first numbers) (cons 1 (rest numbers))))))]\n      [(> (first numbers) max)\
    \ (cons 1 (rescale_to_unit (cons (first numbers) (cons (first numbers) (cons (first\
    \ numbers) (cons 0 (rest numbers))))))]\n      [(= (first numbers) min) (cons\
    \ 0 (rescale_to_unit (cons (first numbers) (rest numbers))))]\n      [else (rescale_to_unit\
    \ (cons (first numbers) (rest numbers)))]\n      )))\n", "  (let* ((smallest (first\
    \ numbers))\n         (largest (last numbers)))\n    (cond\n      [(< smallest\
    \ smallest) 0]\n      [(< largest largest) 1]\n      [else (/ (- largest smallest)\
    \ largest)])))\n", "  (let ((smallest #f) (largest #f))\n    (for ((n numbers))\n\
    \      (if (= n smallest)\n          (set! smallest 0)\n          (if (> n largest)\n\
    \              (set! largest n)\n              (set! largest n)))\n      (set!\
    \ n (/ (- (square n) smallest)\n                 (square largest))))))\n", " \
    \ (let ([min (minimum numbers)])\n    (let ([max (maximum numbers)])\n      (/\
    \ (- max min) 1.0))))\n", "  (define max #f (min-max numbers))\n  (define min\
    \ (- max 0.0))\n  (map / numbers [min max]))\n", "  (if (null? numbers)\n    \
    \  '()\n      (let ((min-value (first numbers))\n            (max-value (second\
    \ numbers)))\n        (cons 0 (apply + (map (lambda (x) (* x max-value)) numbers))))))\n",
  "  (cond [(empty? numbers) numbers]\n        [(< (car numbers) (cadr numbers)) (car\
    \ numbers)\n         (rescale_to_unit (cddr numbers))]\n        [else (/ (car\
    \ numbers) (cadr numbers))\n               (rescale_to_unit (cddr numbers))]))\n",
  "  (apply apply (map #(/ % 1.0) (map min numbers))))\n", "  (apply map (lambda (n)\
    \ (* n scale)) numbers))\n", "  (min-max numbers (/ (min numbers) (max numbers))))\n",
  "  (cond [(null? numbers) numbers]\n        [(> (min numbers) 0) (min-value (numbers))]\n\
    \        [else (max-value (numbers))]))\n", "  (apply map (lambda (x) (/ x 100))\
    \ numbers))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt's not quite right though\
    \ - you're still getting negative numbers because you're doing a map of (/ x 100)\
    \ but then you're dividing by 100 afterwards. A better solution would be to just\
    \ multiply by 100 and map to `(/ x 100)`.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme,functional-programming\
    \ |>\nAn alternative is to use map to calculate the range and then multiply that\
    \ with your percentage.\n<code>", "  (let ((min (apply min numbers)))\n    (let\
    \ ((max (apply max numbers)))\n      (list 0 (- min max))))))\n", "  (let ([min\
    \ (min numbers)\n         max (max numbers)])\n    (/ (- min max) 2))\n  )", " \
    \ (let ((min (apply min numbers)))\n    (map (lambda (number) (/ number max))\
    \ numbers)\n    ;; This step makes the smallest number become 0, not 1\n    (map\
    \ abs numbers)\n    ;; This step makes numbers that have been scaled down to 0\
    \ become 1\n    (map / numbers))\n", "  (let loop ((numbers (rest numbers))\n\
    \             (result '()))\n    (if (null? numbers)\n        result\n       \
    \ (loop (rest numbers)\n              (cons (- #min\n                      (/\
    \ (first numbers)\n                         (max 0 1.0))\n                   \
    \  (first numbers))\n                    result))))))\n", "  (apply min-max (map\
    \ min-max (number-list numbers))))\n", "  (reverse\n   (let [max-mins (max-min\
    \ numbers)\n         min-maxs (min-max numbers)\n         max (max-k max-mins)\n\
    \         min (min-k min-maxs)\n         k (- max min)]\n     (map + (map / min\
    \ numbers)\n           (map - (map / max numbers)\n                  (map / k\
    \ numbers))\n           (map / k numbers))))\n", "  (apply map (lambda (n)\n \
    \              (if (zero? n)\n                   0\n                   (/ (- (min\
    \ numbers) n) 1 (- n 1))))\n         numbers))\n", "  (apply apply \n        \
    \ (map (lambda (number)\n                 (/ (- number 1)\n                  \
    \   (min (length numbers) 2))))\n         numbers))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (if (< (min number) 0)\n        (/ 0 (- (min\
    \ number) max))\n        (/ 0 (+ (min number) max)))))\n", "  (if (null? numbers)\n\
    \      '()\n      (let ([smallest (car numbers)\n             largest (car numbers)])\n\
    \        (append (map (lambda (num)\n                        (/ (- num smallest)\
    \ largest))\n                     numbers)\n                (rescale_to_unit (remove-duplicates\
    \ (map + (rest numbers))))))))\n", "  (let ([minval (min numbers)\n         maxval\
    \ (max numbers)])\n    (map (lambda (x)\n           (/ (- x minval) (- maxval\
    \ (- minval x)))) numbers)))\n", "  (cond [(empty? numbers) [empty-set]]\n   \
    \     [(> (first numbers) 0.0) (set-add! numbers (- 1.0))]\n        [else (set-add!\
    \ (first numbers) (/ (first numbers) 2.0))]))\n", "  (if (null? (car numbers))\
    \ (car numbers) (rescale_to_unit (cdr numbers))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (let ([smallest (car numbers)\n             largest (caddr numbers)])\n\
    \        (cond [(>= smallest 0)\n               (/ largest (- smallest))]\n  \
    \            [else (cons smallest [(fst . smallest) (fst . largest)\n        \
    \                           (snd . smallest) (- largest (snd . smallest))]\n \
    \                         (rescale_to_unit (rest numbers))])))))\n", "  (cond\
    \ [(< numbers (caar numbers)) (rescale_to_unit (cons (- 0 (car numbers)) (cdr\
    \ numbers)))]\n        [else (cons (- (car numbers) (min (caar numbers) (max (car\
    \ numbers) (cdr numbers))))\n                    rescale_to_unit (cdr numbers))]))\n",
  "  (let loop ((numbers (sort numbers))\n             (sum (first numbers))\n   \
    \          (min (first numbers)))\n    (cond\n      ((null? numbers) (list min))\n\
    \      ((= sum 0) (list min))\n      (else\n       (let ((next (/ next sum)))\n\
    \         (cons (* min next) (loop (rest numbers) next min)))))\n</code>\n<|/\
    \ a tags=racket,scheme dscore=2 |>\n<| a tags=racket,scheme |>\nThe solution was\
    \ posted by Eli in the Racket IRC channel. Here it is, expanded with some commentary:\n\
    <code>", "  (if (empty? numbers)\n      '()\n      (let ([min (minimum numbers)]\n\
    \            [max (maximum numbers)])\n        (map (\u03BB (x) (/ x max-min))\n\
    \              numbers\n              :key min))))\n", "  (let* ((min-max min\
    \ max) (min-max) (max) (new-min) (new-max) (nums)\n         (list (lambda (x)\n\
    \                 (if (< x min-max)\n                     (cons x (+ min (/ (-\
    \ x max-min) max-max)))\n                     (cons x min-max)))))\n    (do ((i\
    \ numbers (cdr i))\n         (min-max (car i)))\n        ((null? i) (reverse min-max))\n\
    \      (let ((new-min) (new-max))\n        (if (< (car i) min-max)\n         \
    \   (set! min (car i)) (set! min (+ (car i) min-max)))\n        (if (> (car i)\
    \ min-max)\n            (set! max (car i)) (set! max (+ (car i) max-min))))))\n",
  "  (let ((min (first numbers))\n        (max (rest numbers)))\n    (map #(/ % max)\
    \ numbers min)))\n", "  (define (helper nums)\n    (if (null? nums)\n        nums\n\
    \        (let ([smallest (car nums)]\n              [largest (cadr nums)])\n \
    \         (cond (smallest < (if (null? largest) smallest largest) largest)\n \
    \               smallest (helper nums)))))\n  (helper numbers))\n", "  (let loop\
    \ ((n numbers)\n             (result empty))\n    (if (empty? n) result\n    \
    \    (loop (rest n)\n              (cons 0 (first n)))\n        (loop (rest n)\
    \ (cons (* (first n) 1.0) (first n))))))\n", "  (map (lambda (x) (min x 1.0))\n\
    \       (map (lambda (x) (/ (- x 1.0) (max x 0.0)))\n            numbers))))\n",
  "  (if (null? numbers)\n      '()\n      (let ([smallest (car numbers)\n       \
    \     largest (caddr numbers)])\n        (cond ((> smallest 0) 0)\n          \
    \    ((> smallest largest) (- largest))\n              (else (- smallest)))))\n",
  "  (cond [(empty? numbers) numbers]\n        [(empty? (rest numbers)) (number-of\
    \ 1.0 numbers)]\n        [else (if (< (first numbers) (first numbers)) (rescale_to_unit\
    \ (rest numbers)) \n                (+ number-of 1.0 numbers)))]))\n", "  (apply\
    \ map rescale numbers))\n", "  (min (max 0.0 numbers) 1.0))\n", '  (apply rescale
    numbers (min numbers 1.0) (max numbers 1.0)))', "  (cond [(null? numbers) numbers]\n\
    \        [(>= (min numbers) 0.0) (map #(/ % 1.0) (map min numbers))]\n       \
    \ [else (map #(/ (- 1.0) (- %)) numbers)]))\n", "  (rescale_min (rescale_max (-\
    \ numbers (min numbers)) 1)))\n</code>\nEDIT: I didn't realize you wanted it to\
    \ be the other way around, so here is the other way around (as suggested in comments):\n\
    <code>", "  (/ (min numbers) (max numbers)))\n", "  (reverse (map (lambda (x)\n\
    \                  (/ (- x 1) (apply min numbers))\n                  x)\n   \
    \           numbers)))\n", "  (let ((smallest (min numbers numbers))\n       \
    \ (largest (max numbers numbers)))\n    (set! numbers (map (lambda (n) (/ n largest))\
    \ numbers))\n    (set! numbers (map #(if (< (* n smallest) largest) #t (/ n largest))\
    \ numbers))\n    numbers))\n</code>\n<|/ a dscore=2 tags=scheme,racket |>\n<|\
    \ a tags=scheme,racket |>\nJust for fun, how about this version:\n<code>", " \
    \ (let ([min (apply min numbers)])\n    (apply map + (map / numbers\n        \
    \            (lambda (x)\n                      (- x min)))))\n", "  (cond\n \
    \   [(empty? numbers) numbers]\n    [else (cons (/ minimum numbers)\n        \
    \        (rescale_to_unit (rest numbers)))]))\n", "  (let ([min (min-element numbers)])\n\
    \    (let ([max (max-element numbers)])\n      (let ([units (/ min max)])\n  \
    \      (/ numbers units)))))\n", "  (apply map rescale-to-unit numbers))\n", " \
    \ (cond [(empty? numbers)\n         numbers]\n        [(zero? (first numbers))\n\
    \         (cons (first numbers) \n              (rescale_to_unit (rest numbers)))]\n\
    \        [(zero? (rest (first numbers)))\n         (cons (first numbers)\n   \
    \           (rescale_to_unit (rest (first numbers))))]\n        [else\n      \
    \   (cons (/ (first numbers) \n                  (+ (first numbers)\n        \
    \             (second numbers))) \n               (rescale_to_unit (rest (rest\
    \ numbers))))]))\n", "  (apply min-max numbers))\n", "  (apply map (lambda (x)\
    \ (x/min (max-number numbers) (min-number numbers))) numbers))\n", "  (rescale_to_unit\
    \ numbers 1))\n", "  (if (null? numbers)\n      '()\n      (let ((smallest (car\
    \ numbers))\n            (largest (caddr numbers)))\n        (if (< smallest largest)\n\
    \            (cons smallest (rescale_to_unit (sub1 numbers))) (cons largest (rescale_to_unit\
    \ (sub1 numbers))))))\n  )\n</code>\nI decided to keep the function names consistent\
    \ with the solution I presented in the previous lecture; I chose the name rescale_to_unit\
    \ to better indicate the fact that the function performs a rescaling operation.\
    \ \nTo better understand the procedure, let's see how it is applied to the example\
    \ given in the question above. The first argument to the function is [1.0, 2.0,\
    \ 3.0, 4.0, 5.0] and that is passed to the procedure. \nThe procedure is decomposed\
    \ into two parts, the body of the procedure and the tail of the procedure. \n\
    The body of the procedure consists of two lines of code. The first line is the\
    \ if statement that checks whether numbers is empty or not. If it is, the procedure\
    \ returns an empty list. Otherwise, we assign smallest and largest elements of\
    \ the list to the variable smallest and largest.\nThe second line is the let statement.\
    \ The let statement is a procedure that declares a local binding which we refer\
    \ to later in the procedure.\nIn the body of the procedure, the local binding\
    \ smallest (the value 1) is assigned to the car binding of smallest and largest\
    \ (the value 5). \nThe car binding is the value of the smallest element (that\
    \ is, the value 1). \nThe local binding largest (the value 5) is assigned to the\
    \ caddr binding of smallest and largest (the value 2, the second value in the\
    \ list).\nThe caddr binding is the value of the second value in the list. \nFinally,\
    \ the if statement checks whether the smallest and largest values are equal or\
    \ not. If they are equal, then the function returns an empty list. Otherwise,\
    \ it returns the list with the smallest value and the list with the largest value.\
    \ \n<code>", "  (cond [(null? numbers) numbers]\n        [(< (car numbers) 0)\
    \ (/ 0 (car numbers))]\n        [(> (car numbers) 1) (/ (- 1 (car numbers)) (car\
    \ numbers))]\n        [else (rescale_to_unit (cdr numbers))]))", "  (apply #'/\
    \ numbers\n        (apply min-key (map (lambda (n) (- n 1)) (numbers))\n     \
    \           [(lambda (n) (* n n)) (lambda (n) (* n n))]))) ;; min-key assumes\
    \ comparable\n  ;; Now do the same for maximum number also\n  (apply #'/ numbers\n\
    \        (apply max-key (map (lambda (n) (- n 1)) (numbers))\n               \
    \ [(lambda (n) (* n n)) (lambda (n) (* n n))]))) ;; max-key assumes comparable\n",
  "  (if (<= (length numbers) 2)\n      (apply + (map (lambda (n) (* n 0.0)) numbers))\n\
    \      (error (list->string (list \"Wrong input: expects a list of at least two\
    \ elements\")))\n    )\n  )\n", "  (apply / numbers 1.0))\n", "  (map #(/ % 1.0)\
    \ (apply minmax numbers 0.0)))\n", "  (define min-max min-max-list)\n  (define\
    \ (min-max-list)\n    (if (empty? numbers)\n        (list min max)\n        (min-max-list\
    \ #(first numbers) (first numbers))))\n  (define (min x)\n    (if (< x min)\n\
    \        min\n        (min x)))\n  (define (max x)\n    (if (> x max)\n      \
    \  max\n        (max x)))\n  (min-max-list)\n  (apply map min numbers))\n", " \
    \ (/ (apply + numbers) (length numbers)))\n", "  (let* ((length (length numbers))\n\
    \         (min (min numbers))\n         (max (max numbers)))\n    (if (< min max)\n\
    \        numbers\n        (map divide-by-one (map (lambda (x) (/ x max)) numbers)))))\n",
  "  (let ([min-value (car (min-max numbers numbers))]\n        [max-value (car (max-min\
    \ numbers numbers))])\n    (map\n     (lambda (x) (/ x max-value))\n     (cons\
    \ (- min-value max-value) numbers))))\n", "  (let ([(min x) (min numbers)]\n \
    \       [(max x) (max numbers)])\n    (if (< min max)\n        (list min)\n  \
    \      (let ([x (/ (- max min) 2.)])\n          (if (< x 1.)\n              (list\
    \ 0)\n              (let ([y (* x x)]\n                    (if (< y 2.)\n    \
    \                    (list x)\n                        (list 1.))))))))\n", " \
    \ (if (empty? numbers)\n      numbers\n      (rescale_to_unit (rest (sort-by (lambda\
    \ (n) (abs (- n 1))) numbers)) 1.0)))\n</cell>\n<text>\nQuestion 1.3: Write a\
    \ function that finds the maximum value in a list. You can use Python's built-in\
    \ max function.\nQuestion 1.4: Write a function that finds the minimum value in\
    \ a list. You can use Python's built-in min function.\nQuestion 1.5: Write a function\
    \ that applies a certain function to a list to create a new list. You can use\
    \ Python's map function.\n\n\n</text>\n<cell>", "  (let ([smallest (car numbers)]\n\
    \        [largest (cdr numbers)])\n    (apply map #(/ smallest largest) numbers)))\n",
  "  (let loop ((numbers numbers)\n             (result (make-array (array-length\
    \ numbers) 'real)))\n    (set! result (map #(/ % 2) result))\n    (if (null? numbers)\n\
    \        (reverse result)\n        (let ((minval (array-min numbers))\n      \
    \         (maxval (array-max numbers)))\n          (loop\n             (map #(*\
    \ % maxval) numbers)\n             (map #(/ % minval) result)))))\n</code>\n<|/\
    \ a |>\n<| c |>\nYes, but this solution is too slow.  It has O(n^2) performance.\n\
    <|/ c |>\n<| c |>\nWell, that depends a lot on what you're actually doing with\
    \ the data.  It's very easy to come up with better algorithms for specific problems,\
    \ but that doesn't change the complexity of the algorithm.\n<|/ c |>\n<| c |>\n\
    I see what you mean. I think the O(n^2) complexity is because for each iteration\
    \ through the loop, the list has to be scanned again, and also it's O(n^2) because\
    \ there are `n` iterations, each of which has a `log(n)` complexity.\n<|/ c |>\n\
    <| c |>\n: In your inner loop (`loop`), you're doing `n` multiplications and `n`\
    \ divisions.  That's not O(n^2), it's just O(n).\n<|/ c |>\n<| c |>\nWhat about\
    \ `(#(* % maxval) numbers)` as `(map #(* % maxval) numbers)`?\n<|/ c |>\n<| a\
    \ |>\nHere's a solution using Racket procedures which performs about as fast as\
    \ the other solutions. I'm sure there are ways to improve this, but this at least\
    \ runs as fast as my solution:\n<code>", "  (fold-right (lambda (x acc)\n    \
    \            (* x (/ (- acc 1) x)))\n              numbers numbers))\n", "  (let\
    \ loop ((numbers '())\n             (min (-1.0))\n             (max (1.0)))\n\
    \    (cond\n      [(empty? numbers) '()]\n      [else\n       (loop (rest numbers)\n\
    \             (min min)\n             (max (max (first numbers) max)))]\n    \
    \  [else\n       (cons min\n             (loop (rest numbers)\n              \
    \     (min (min (first numbers) min))\n                   (max (max (first numbers)\
    \ max)))]))))\n", "  ;; first find smallest number in the list of numbers\n  ;;\
    \ smallest will be 0, because rescaling all numbers to [0, 1]\n  (let ([smallest\
    \ (min numbers)])\n    ;; find largest number in the list of numbers\n    ;; largest\
    \ will be 1, because rescaling all numbers to [0, 1]\n    (let ([largest (max\
    \ numbers)])\n      ;; normalize all numbers to [0, 1]\n      (map [- smallest]\
    \ numbers)\n      ;; rescale all numbers to [0, 1]\n      (map [/ largest] numbers)\n\
    \      ;; return list of normalized numbers\n      numbers)))\n", "  (let ([min\
    \ (min numbers)\n         max (max numbers)])\n    (if (< min 0)\n        (* 0\
    \ max)\n        (* 0 min))))\n", "  (apply append\n         (map (lambda (x) `(,(min-max\
    \ 0 1 x))) numbers)))\n", "  (let ((min (car numbers))\n        (max (cadr numbers)))\n\
    \    (let loop ((numbers (list min))\n               (result (list 0))\n     \
    \          (next (min)))\n      (cond\n        ((empty? numbers) result)\n   \
    \     ((< min max) (loop (rest numbers)\n                         (cons (/ (car\
    \ numbers) next) result) next)\n                         (car numbers))\n    \
    \    (else (loop (rest numbers)\n                   (cons (+ (car numbers) next)\
    \ result)\n                   (+ next (max numbers))))))))\n", "  (if (null? (rest\
    \ numbers))\n      numbers\n      (append (scale_to_unit(first numbers) (first\
    \ numbers))\n              (rescale_to_unit (rest numbers)))))\n", "  (foldl (lambda\
    \ (n acc)\n           (- acc (* (min n) (max n)))\n           (* n acc))\n   \
    \      1.0\n         numbers))\n", "  (cond [(empty? numbers) 0]\n        [(=\
    \ (min numbers) 0) 1]\n        [else (/ (min numbers) (max numbers))]))\n", " \
    \ (apply map \n         (lambda (number) \n           (/ number \n           \
    \   (apply min numbers (- number 1))))\n         numbers))\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=scheme,racket dscore=1 |>\nTo answer your original question of\
    \ \"how to find the largest number among multiple numbers in scheme\".\nThe simplest\
    \ way is to use built-in max and apply to find all of the numbers you want to\
    \ compare\n<code>", "  (/ (apply min numbers) (apply max numbers)))\n", "  (apply\
    \ map (lambda (x)\n              (/ (- x) (- numbers))))\n          numbers))\n",
  "  (let loop ((numbers numbers)\n             (result (first numbers)))\n    (cond\
    \ [(empty? numbers) result]\n          [(< result 0.0) (loop (rest numbers) (/\
    \ result 2.0))])\n          [(> result 1.0) (loop (rest numbers) (/ result 2.0))]\n\
    \          [else (loop (rest numbers) result)]))))\n</cell>\n<cell>\n#lang racket\n",
  "  (let ([smallest (min numbers numbers)\n\t       largest (max numbers numbers)])\n\
    \    (if (> smallest largest)\n        (list largest)\n        (cons smallest\
    \ (/ (- smallest largest) largest))))))\n", "  (apply map #(/ (- % 1) 1) numbers))\n",
  "  (define (transform x)\n    (/ (- x 1) (- x x)))\n\n  (define (iter numbers)\n\
    \    (let ([min (first numbers)])\n      (if (null? numbers)\n          (list\
    \ min)\n          (iter (rest numbers)\n                 (transform min))))))\n",
  '  (map #(/ (min numbers) (max numbers)) (take numbers (rest numbers))))', "  (apply\
    \ + (map (lambda (n) (min 0 (/ n 1.0))) numbers)))\n", "  (let loop ([x 0] [n\
    \ numbers])\n    (if (null? n)\n        '()\n        (if (< (car n) x)\n     \
    \       (cons x n) (loop (+ x 1) (cdr n))\n            (loop (+ x 1) (cdr n))))))\n",
  "  (let ((min (first numbers)))\n    (cond [(> (first numbers) min) 0]\n       \
    \   [else 1]\n          [else (/ (+ (first numbers) min) max)]))\n", "  (let ((m\
    \ (min numbers)))\n    (map / numbers\n         (lambda (n)\n           (if <\
    \ (- m n) 0)\n           (- m n))))))\n", "  (let ([min (apply min numbers)]\n\
    \        [max (apply max numbers)])\n    (/ (apply + numbers) max-min)))\n", " \
    \ (foldr (\u03BB (current prev) (+ (- prev current) 1) current) 0 numbers))\n",
  "  (cond\n    [(empty? numbers) (list 0.0)]\n    [else (let ((min (first numbers))\n\
    \                 (max (last numbers)))\n            (make-vector (- (length numbers)\
    \ 1) (/ max 1.0)))\n           (apply map vector numbers\n                   [(lambda\
    \ (x) (- x min))\n                    (lambda (x) (/ x max))]))]))\n", "  (let\
    \ ((min-val (first numbers))\n        (max-val (second numbers)))\n    (map (lambda\
    \ (n) (/ n max-val)) numbers)))\n", "  (min (map f numbers) (map f (range numbers))))\n",
  "  (min-max numbers (make-list 1 numbers))) ; The smallest number will become 0\
    \ and the largest will become 1\n</cell>\n<code language=racket-tutorial>", " \
    \ (rescale numbers 0 1))\n", "  (let ([min (min-of numbers)])\n    (if (zero?\
    \ min)\n        numbers\n        (let ([max (max-of numbers)])\n          (/ (-\
    \ max min) 2)))))\n", "  (apply map (lambda (n) (/ n 2))\n          numbers))\n",
  "  (let ((min1 (min numbers 0.0))\n        (max1 (max numbers 1.0)))\n    (map #(/\
    \ %1 max1) numbers)))\n", "  (let ((smallest (min numbers)))\n    (map (\u03BB\
    \ (x) (- (/ x smallest) 1)) numbers)))\n", "  (cond\n    [(empty? numbers) 0.0]\n\
    \    [(> numbers (first numbers)) (/ numbers 1.0)]\n    [else (* numbers 1.0)]))\n",
  "  (let ([min-to-zero nil\n         max-to-one nil])\n    (if (null? numbers)\n\
    \        #f\n        (let ([current (car numbers)])\n          (if (< current\
    \ min)\n              (if (not min-to-zero)\n                  (set! min-to-zero\
    \ current)\n                  (set! max-to-one (/ current 1.0)))\n           \
    \   (if (< current max) min-to-zero)\n              (if (> current max)\n    \
    \              (set! max-to-one (/ current 1.0))\n                  min-to-zero)))))))\n",
  "  (let loop ((accumulator 0)\n             (numbers numbers)\n             (i 0))\n\
    \    (if (null? numbers)\n        accumulator\n        (loop\n         (+ accumulator\
    \ (min (reverse numbers) numbers))\n         (rest numbers)\n         (+ i (length\
    \ numbers))))))\n", "  (min (/ numbers (min numbers (list 1)))))\n", "  (min (/\
    \ numbers (length numbers)) 1.0))\n", "  (foldl (\u03BB (x y)\n          (/ (-\
    \ y x) 2))\n         0 numbers))\n", "  (let ([min\n          (min numbers)\n\
    \          max\n          (max numbers)])\n    (lambda (x)\n      (/ x (min x)\
    \ (max x))))\n</code>\n<|/ a dscore=4 |>\n<| a |>\nJust to add one more answer,\
    \ with higher precision arithmetic:\n<code>", "  (let ((min-number (car numbers))\n\
    \        (max-number (cdr numbers)))\n    (if (<= min-number max-number)\n   \
    \     numbers\n        (list\n         (/ min-number (- max-number min-number))\n\
    \         (map float numbers)))))\n", "  (define (rescale-to-unit-iter numbers\
    \ acc i)\n    (if (null? numbers)\n        acc\n        (rescale-to-unit-iter\
    \ (rest numbers) (cons (/ numbers (first numbers)) (cons i acc))\n           \
    \               (+ i 1))))\n  (rescale-to-unit-iter numbers '() 0))\n", "  (let\
    \ loop ((numbers (reverse numbers))\n             (smallest 1.0)\n           \
    \  (largest 1.0))\n    (cond ((null? numbers) '())\n          ((< smallest numbers)\
    \ (cons (- smallest numbers) numbers))\n          ((> largest numbers) (cons smallest\
    \ numbers))\n          (else (loop (rest numbers)\n                       (min\
    \ smallest numbers)\n                       (max largest numbers))))))\n", " \
    \ (cond [(null? numbers) 0]\n        [(> head numbers) (min numbers)] \n     \
    \   [else (+ (- head numbers) (/ (first numbers) (max numbers)))]))\n", "  (min-max\
    \ (/ numbers (- numbers (first numbers))) 0 1))\n", "  (let ([nums\n         \
    \ (lambda (x)\n            (cond\n              [(< x 0) 0]\n              [(>\
    \ x 1) 1]\n              [else x]))\n          (min #min)\n          (max #max)\n\
    \          (sum #+)\n          (quotient quotient\n                    (lambda\
    \ (x)\n                      (cond\n                        [(< x 0) 0]\n    \
    \                    [(> x 1) 1]\n                        [else x]))])\n    (if\
    \ (>= (length numbers) 2)\n        (apply (lambda (x y)\n                (quotient\
    \ (+ (nums x) y)\n                         (quotient (max nums y)\n          \
    \                           (quotient (min nums y)\n                         \
    \                       (quotient (sum nums y)\n                             \
    \                           (quotient (length numbers y)\n                   \
    \                                             (quotient (length numbers x)\n \
    \                                                                       (length\
    \ numbers)))\n                                                )\n            \
    \                             )\n                         )\n                \
    \       )\n               (list 0 0))\n        (apply (lambda (x y)\n        \
    \        (quotient (+ (nums x) y)\n                         (quotient (max nums\
    \ y)\n                                     (quotient (min nums y)\n          \
    \                                      (quotient (sum nums y)\n              \
    \                                          (quotient (length numbers y)\n    \
    \                                                            (quotient (length\
    \ numbers x)\n                                                               \
    \         (length numbers)))\n                                               \
    \ )\n                                         )\n                         )\n\
    \                       )\n               (list (min numbers) 0)))))\n", "  (if\
    \ (empty? numbers)\n      numbers\n      (let ([min (minimum numbers)])\n    \
    \    (map (lambda (x)\n               (+ (- x (min x)) (/ 1.0 (max x)))) numbers))))\n",
  "  (define (helper xs i)\n    (cond [(null? (rest xs)) 0]\n          [(< i (car\
    \ xs)) (helper (cdr xs) (cdr i))]\n          [(>= i (car xs)) (helper (cdr xs)\
    \ (cdr i))]\n          [else (+ (/ i (car xs)) (rest (cdr xs)))]))\n  (helper\
    \ numbers 0))", "  (if (empty? numbers)\n      '()\n      (min 0 (/ (car numbers)\
    \ (max-list(cdr numbers))))))\n", "  ;; (define min-val (min numbers))\n  ;; (define\
    \ max-val (max numbers))\n  (define min-val (min numbers numbers))\n  (define\
    \ max-val (max numbers numbers))\n\n  (define scale\n    (let ([scale max-val]\n\
    \          [num (make-array (- 1 (array-length numbers)) (reverse (array-reverse\
    \ numbers)))])\n      (do ([i 0 (+ i (array-length numbers))])\n          ((>\
    \ i 0)\n           (set! scale (/ scale (- i 1))))\n          (set! num (make-array\
    \ (- i (array-length numbers)) (reverse (array-reverse numbers)))))\n      (do\
    \ ([i 0 (+ i (array-length numbers))])\n          ((> i 0)\n           (set! num\
    \ (- num scale)))\n          (set! scale (/ scale (- i 1)))))))\n\n  (reverse\n\
    \   (map (lambda (n)\n          (/ (- n min-val) scale))\n       numbers)))\n",
  "  (let loop ((x numbers)\n             (y '()))\n    (if (null? x)\n        y\n\
    \        (loop (cdr x) (car x) (cons y (car x)))))\n</code>\nTo apply the function\
    \ above to a list of integers, we can use:\n<code>", "  (cond [(null? numbers)\
    \ numbers]\n        [else (min-max (map into-range numbers) (map into-range (-\
    \ numbers (min numbers)))) numbers]))\n", "  ((min numbers 0.0) (/ (max numbers\
    \ 1.0) 2.0)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (for ((n numbers))\n      (/ (- max n) (- min n))\n      0))))\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=lisp,scheme,racket,functional-programming |>\nHere's\
    \ a very simple solution that I used when I needed to apply the function\n<code>\n\
    f : (List Number -> Number)\n</code>\nto a list of numbers of arbitrary length.\
    \ The first argument is the list of numbers and \n<code>", "  (rescale_helper\
    \ numbers 1.0 1.0))\n", "  (if (= (length numbers) 2)\n      (cond ((< (car numbers)\
    \ (cdr numbers))\n             (set! numbers (map (lambda (x) (* x x)) numbers)))\n\
    \            (t\n             (set! numbers (map (lambda (x) (- x x)) numbers)))\n\
    \          (else (set! numbers (map (lambda (x) (/ x x)) numbers))))\n      numbers))\n",
  "  (let ((min (apply min numbers)))\n    (map (lambda (x) (/ (- x min) 1.0))\n \
    \        numbers)))\n", "  (let loop ((numbers numbers)\n             (result\
    \ '()))\n    (if (null? numbers)\n        result\n        (let ((smallest (car\
    \ numbers))\n               (largest (car numbers)))\n          (loop (cdr numbers)\n\
    \                ;; Scale smallest number to 0\n                (append (list*\
    \ smallest '())\n                        (list* smallest result))\n          \
    \      ;; Scale largest number to 1\n                (append (list* largest '())\n\
    \                        (list* largest result)))))\n    result))\n", "  (let\
    \ loop ([numbers numbers]\n             [result (first numbers)]\n           \
    \  [i 1])\n    (if (< i length(numbers))\n        (loop (rest numbers)\n     \
    \         (+ result (* result (first numbers))) (i + 1))\n        result)))\n",
  "  (let ((min (min numbers numbers))\n        (max (max numbers numbers)))\n   \
    \ (map (\u03BB (x) (* x max))\n         (- numbers min))))\n", "  (if (null? numbers)\n\
    \      '()\n      (append\n       (map (\u03BB (x) (* x 1.0))\n            (take-last\
    \ (- (length numbers) 1))\n            numbers)\n       '())))\n", "  (let ((min-value\
    \ numbers (sort numbers (< numbers)))\n        (max-value numbers (sort numbers\
    \ (> numbers))))\n    (apply map (lambda (x)\n              (/ (- x (min min-value\
    \ max-value)) (- max-value (min min-value max-value))))\n            numbers)))\n",
  "  (foldl (lambda (x y) (/ x y)) (max-min numbers) numbers))\n", "  (cond [(null?\
    \ numbers) numbers]\n        [(null? (rest numbers)) numbers]\n        [else (+\
    \ (/ (car numbers) (min (car numbers) (max (car numbers) (first (rest numbers)))))\
    \ (rest (rescale_to_unit (rest numbers))))]))\n", "  (define (rescale-to-min-max\
    \ number)\n    (min (max number 0) 1))\n  (map rescale-to-min-max numbers))\n",
  "  (define (rescale x)\n    (- 1.0 (/ (sum numbers) x)))\n  (define (multiply a)\n\
    \    (/ (apply + a) (length a)))\n  (apply (map rescale numbers)))\n", "  (if\
    \ (null? numbers)\n      '()\n      (if (< (car numbers) (car (reverse numbers)))\n\
    \          (rescale_to_unit (reverse numbers))\n          (cons (car numbers)\
    \ (rescale_to_unit (cdr numbers))))))\n", "  (let ([smallest (car numbers)\n \
    \        largest (car numbers)])\n    (cond [(< smallest largest) (map - numbers)]\n\
    \          [(> smallest largest) (map - numbers)]\n          [else numbers])))\n",
  "  (if (null? numbers) numbers\n      (let ((smallest (first numbers))\n       \
    \     (largest (rest numbers)))\n        (list 0 (- smallest largest)))))\n",
  "  (let loop ((min-value numbers)\n             (max-value numbers)\n          \
    \   (sum-sum min-value) (sum-sum max-value) (nums numbers))\n    (if (null? nums)\n\
    \        (/ 1 max-value)\n        (let ((number (car nums)))\n          (let ((min-diff\
    \ (- number sum-sum))\n                (max-diff (- number sum-sum)))\n      \
    \      (cond\n              [(< min-diff max-diff)\n               (loop (- number\
    \ min-diff)\n                     (/ number max-value)\n                     (+\
    \ sum-sum min-diff)\n                     (+ sum-sum max-diff)\n             \
    \        (append nums (list number))]\n              [(> min-diff max-diff)\n\
    \               (loop (/ number min-value)\n                     (+ sum-sum max-diff)\n\
    \                     (+ sum-sum min-diff)\n                     (append nums\
    \ (list number))]\n              [else\n               (loop (+ sum-sum min-diff)\n\
    \                     (+ sum-sum max-diff)\n                     (+ sum-sum min-diff)\n\
    \                     (+ sum-sum max-diff)\n                     (append nums\
    \ (list number))]\n              ])))))\n  (reverse nums)))\n", "  (if (empty?\
    \ numbers)\n      '()\n      (let ((min-v (car numbers))\n            (max-v (cadddr\
    \ numbers)))\n        (append (map (lambda (number) (/ (- number min-v) max-v))\n\
    \                     (cdr numbers))\n                (list min-v)))))\n</code>\n\
    <|/ a tags=scheme,racket,lisp |>\n<| c |>\nYou still need to handle the case where\
    \ `numbers` is empty.\n<|/ c |>\n<| c |>\nThe example I gave in my original post\
    \ is from my own code. Anyway, thanks for the suggestion.\n<|/ c |>\n<| c |>\n\
    Yes, but that's not a very good example for someone who hasn't read the question.\n\
    <|/ c |>\n<| a dscore=1 |>\nI needed a function that would rescale all numbers\
    \ in a list to fit within [0,1]. Here is what I came up with:\n<code>", "  (let\
    \ ([smallest (car numbers)\n         largest (cdr numbers)])\n    (cond [(< smallest\
    \ largest)\n           (map (\u03BB (x) (/ (- x smallest) largest))\n        \
    \         numbers)]\n          [else (cons (/ (- smallest smallest) largest)\n\
    \                        numbers)]))))\n</code>\n<|/ a dscore=0 tags=scheme,racket,lisp\
    \ |>\n<| c |>\nThe \"divide by zero\" error should *not* be caught by a \"try\
    \ ... catch\" block. The language allows this to be done, and it is the only way\
    \ to prevent uncaught errors from crashing your program in some situations. Racket\
    \ does this when they generate exceptions. They are thrown when an exception is\
    \ detected, and an exception object can be thrown.\n<|/ c |>\n<| a tags=scheme,racket,lisp\
    \ dscore=0 |>\nHere is another approach using only racket's \"normal\" functions:\n\
    <code>", "  (let ((max 1.0))\n    (if (null? numbers) numbers\n        (let ((diff\
    \ (min (apply min numbers))))\n          (if (< diff 0) (/ diff max)\n       \
    \       (/ (- diff max) max)))))\n", "  (if (null? numbers)\n      '()\n     \
    \ (let ([smallest (car numbers)\n             largest (cdr numbers)])\n      \
    \  (if (> (- smallest) 0)\n            (cons (/ (- smallest largest) largest)\n\
    \                   (rescale_to_unit (- largest (- smallest largest)))\n     \
    \              (rescale_to_unit (- smallest largest)))))\n        numbers))\n",
  "  (let ((min (first numbers))\n        (max (last numbers)))\n    (map (lambda\
    \ (x)\n           (let ((x_new x))\n             (if (< x_new min)\n         \
    \        (/ (- x_new min) max)\n                 x_new))\n           numbers))))\n",
  "  (let ((max-min (maximum-minimum numbers))\n        (max-unit (/ max-min 1.0)))\n\
    \    (let ((min-unit (/ max-min 1.0)))\n      (map + (map make-vector (- (length\
    \ numbers) 2) max-unit) min-unit))))\n", "  (if (null? numbers)\n      '()\n \
    \     (let ([min/max (min-max numbers)])\n        (cons (/ (- min/max min) (-\
    \ min/max min)) numbers))))\n", "  (if (null? numbers)\n      '()\n      (if (<\
    \ (first numbers) 0)\n          (cons (/ (first numbers) (min 1 (first numbers)))\
    \ (rest numbers))\n          (cons (/ (first numbers) (max 0 (first numbers)))\
    \ (rest numbers)))))\n</cell>\n<code language=dyalog-kernel>", "  (let ((minmax\
    \ (apply minmax numbers)))\n    (apply map #(/ % 1.0) minmax)))\n", "  (let ([smallest\
    \ (first numbers)\n          largest (rest numbers)])\n    (let ([min (min smallest\
    \ largest)])\n      (map (lambda (x)\n              (/ (- x min) max))\n     \
    \       numbers))))\n", "  (cond\n    [(empty? numbers) 0]\n    [else (/ (car\
    \ numbers) (- 1.0 (min numbers)))]))\n", "  (if (<= (length numbers) 2)\n    \
    \  (cons 0 (/ (- (car numbers) (cadr numbers)) 2))\n      (error \"This implementation\
    \ requires at least 2 numbers, got ~d\"\n             (length numbers)))\n  )\n\
    </cell>\n<code language=dyalog-kernel>", "  (let ((min (first numbers))\n    \
    \    (max (last numbers)))\n    (map #(/ (- %1 max) (- (min %2) max)) numbers)))\n",
  "  (define min-value (first numbers))\n  (define max-value (first numbers))\n  (define\
    \ (loop current-min current-max new-min new-max)\n    (cond\n      [(empty? numbers)\
    \ (list new-min new-max)]\n      [(< current-min max-value) (loop (min current-min\
    \ max-value) (max current-max min-value) min-value (first numbers))]\n      [(<\
    \ current-max min-value) (loop (min current-min max-value) max-value new-min (first\
    \ numbers))]\n      [else (loop (min current-min max-value) max-value (min new-min\
    \ new-max) max-value)]\n    ))\n  (loop (min min-value max-value) min-value (max\
    \ min-value max-value) max-value))\n", "  (if (null? numbers)\n      '()\n   \
    \   (if (< (car numbers) (cadr numbers))\n          (cons (- (car numbers) (cadr\
    \ numbers)) (reverse (cddr numbers)))\n          (cons (- (car numbers) (cadr\
    \ numbers)) (reverse (cddr numbers))))))\n", "  (if (or (null? numbers) (null?\
    \ (cdr numbers)))\n      '()\n      (append (min-value (map min-value numbers))\
    \ \n               (map / (map max-value numbers)) \n               (map max numbers)\n\
    \               )\n      )\n  )\n", "  (apply \n   (lambda (x) \n     (if (< (car\
    \ x) (car numbers)) \n         (cons 0.0 (/ (car x) (car numbers)) (car numbers))\n\
    \         (cons 1.0 (/ (car x) (car numbers)) (car numbers))))))\n", "  (define\
    \ (rescale number min)\n    (/ (number min) 1))\n  (apply map rescale numbers))\n",
  "  (min 0 (/ numbers (max numbers (- numbers 1)))))\n", "  (let ((min (reduce (lambda\
    \ (x y)\n                      (if (< (first y) x)\n                         \
    \ (first y)\n                          x))\n                    numbers\n    \
    \                (first numbers))))\n    (apply map (lambda (x)\n            \
    \   (/ (- (car numbers) x)\n                   (expt (- min x) (car-length numbers))))))))\n\
    </cell>\n<code language=racket-transformer>\n#lang racket\n", "  (let* ((smallest\
    \ (first numbers))\n         (largest (last numbers))\n         (diff (- largest\
    \ smallest))\n         (scaling (/ diff 2.0)))\n    (map (lambda (x) (* x scaling))\
    \ numbers)))\n", "  (if (null? numbers)\n      '()\n      (append (/ (car numbers)\
    \ (min numbers numbers))\n              (rescale_to_unit (rest numbers)))))\n",
  "  (map % (map / numbers [1 numbers])))\n", "  (let ((min (first numbers))\n   \
    \     (max (rest numbers)))\n    (lambda (x)\n      (let ((x0 (min x))\n     \
    \       (x1 (max x)))\n        (/ x0 x1)))))\n", "  (let loop ((numbers (sort\
    \ numbers))\n             (n 0)\n             (x (first numbers))\n          \
    \   (y (first numbers)))\n    (cond ((or (null? numbers)) (list x))\n        \
    \  ((< x y) (rest numbers))\n          (else (loop (rest numbers) (+ n 1) (* x\
    \ y)))\n          )))\n", "  (let ((min (min numbers numbers))\n        (max (max\
    \ numbers numbers)))\n    (map / numbers (- max min))))\n", "  (let ([minn (first\
    \ numbers)\n         maxx (rest numbers)])\n    (if (= minn maxx)\n        (map\
    \ double numbers)\n        (map (lambda (x) (x-minn) / (maxx-minn))\n        \
    \     numbers))))", "  (let loop ((numbers (map first numbers)) (rest numbers))\n\
    \    (if (null? rest)\n        (cons (first numbers) (map second numbers))\n \
    \       (loop (rest numbers)\n               (cons (first numbers)\n         \
    \            (loop (rest numbers)\n                           (cons (first numbers)\n\
    \                                 (map second numbers))))))))\n", "  (cond [(empty?\
    \ numbers) numbers]\n        [else (let* ([minimum (first numbers)\n         \
    \           maximum (last numbers)]\n                  [min-rescale (- (min numbers)\
    \ minimum)\n                    max-rescale (- (max numbers) maximum)]\n     \
    \             [rescaled (/ (- numbers minimum max-rescale) (- numbers maximum\
    \ min-rescale))])\n              (cons rescaled numbers))]))\n", "  (apply append\n\
    \         (map rescale-to-unit\n               (partition 2 1 numbers))))\n",
  "  (let loop ((min (first numbers)) (max (second numbers)))\n    (if (< (first numbers)\
    \ (second numbers))\n        (loop (first numbers) max)\n        (loop (first\
    \ numbers) (min))))))\n", "  (if (empty? numbers)\n      '()\n      (append (map\
    \ (\u03BB (x) (/ x 1.0))\n                    (filter positive? numbers))\n  \
    \            (map -\n                     (\u03BB (x) (/ x 1.0))\n           \
    \          (filter negative? numbers)))))\n", "  (apply (\u03BB (n) (/ (- n 1)\
    \ 1.0))\n         (cond [(< 1 (min numbers)) (- 1.0)]\n               [(> (max\
    \ numbers) (min numbers)) (+ 1.0)]\n               [else numbers])))\n", "  (define\
    \ (min-max x y)\n    (if (< (x y) (abs x))\n        (cons y x)\n        (cons\
    \ x y)))\n  (define (min x y) (if (< y x) y x))\n  (define (max x y) (if (< y\
    \ x) x y))\n  (min-max (min (max 0 (car numbers)) (max (car numbers) (cadr numbers)))\
    \ (cadr numbers))\n)\n", "  (if (< 2 (length? numbers))\n      (map '+ (map '*\
    \ (map '/ numbers (reverse numbers))\n                   [1 -2])\n           \
    \ (reverse numbers))\n      '()))\n", "  (apply min-max numbers))\n", "  (cond\n\
    \    ;; If the list contains only zeroes, the answer is zero\n    ((null? numbers)\
    \ '())\n    ;; If the list contains only ones, the answer is one\n    ((equal?\
    \ 1 (length numbers)) numbers)\n    ;; If the list contains both positive and\
    \ negative numbers, find the middle one\n    ((> (length numbers) 2) numbers)\n\
    \    ((= (length numbers) 2) (/ (car numbers) (length numbers)))\n    ;; Otherwise\
    \ compute the midpoint of the two numbers and rescale them\n    (else (/ (+ (*\
    \ (car numbers) (/ (car numbers) (length numbers)))\n                   (* (car\
    \ numbers) (/ (car numbers) (length numbers))))\n               (length numbers)))))\n",
  "  (define (transform x low)\n    (/ x (- low low)))\n  (min-max '() (transform\
    \ numbers 0))\n  ;; ^ min and max of transformed list\n  (apply map transform\
    \ numbers))\n", "  (let loop ((numbers numbers)\n             (min (min numbers))\n\
    \             (max (max numbers)))\n    (cond [(= (length numbers) 1) numbers]\n\
    \          [(= (length numbers) 2) (let ((smallest (min numbers)))\n         \
    \                            (let ((largest (max numbers)))\n                \
    \                       (if (= smallest largest)\n                           \
    \                (cons largest '())\n                                        \
    \   (loop (rest numbers)\n                                                  (cons\
    \ smallest '())\n                                                  (cons largest\
    \ '())))\n                                       numbers)\n                  \
    \                   (loop (rest numbers)\n                                   \
    \       (cons smallest '())\n                                          (cons largest\
    \ '())))]\n          [(> (length numbers) 2) numbers]\n          [else (let ((smallest\
    \ (car numbers))\n                     (largest (car numbers)))\n            \
    \    (let ((smallest-scaled (- smallest min))\n                       (largest-scaled\
    \ (- largest max)))\n                  (if (< smallest-scaled largest-scaled)\n\
    \                      (loop (rest numbers)\n                            (cons\
    \ smallest '())\n                            (cons largest '()))\n           \
    \           (let ((smallest-scaled (* smallest smallest-scaled))\n           \
    \                 (largest-scaled (* largest largest-scaled)))))\n           \
    \       (loop (rest numbers)\n                        (cons smallest smallest-scaled)\n\
    \                        (cons largest largest-scaled))))])))\n</code>\n<|/ a\
    \ dscore=1 tags=racket,lisp |>\n<| a |>\n<code>", "  (rescale_to_unit numbers\
    \ 1.0))\n", "  (apply min-max numbers))\n", "  (let loop ((numbers numbers)\n\
    \             (min (first numbers))\n             (max (second numbers)))\n  \
    \  (if (null? (rest numbers))\n        (reverse (reverse numbers))\n        (let\
    \ ((x (first numbers))\n              (y1 (rescale_to_unit (rest numbers))))\n\
    \          (set! numbers\n                (map rescale\n                     (lambda\
    \ (x)\n                       (min (- x x) (max x y))\n                      \
    \ (+ (- y y1) (- x x))\n                       (- x x))))))))\n", "  (let ((x\
    \ 0))\n    (for-each (lambda (n) (set! x (+ x n))) (numbers))\n    x))\n", " \
    \ (define (helper numbers current result-list)\n    (if (null? numbers)\n    \
    \    result-list\n        (helper (rest numbers) (min current (car numbers)) (cons\
    \ (min current (car numbers)) result-list))))\n  (helper numbers -inf '()))\n",
  "  (apply / (append numbers [1.0])))\n", "  (let ((min\n         (min numbers)\n\
    \         (max\n          (if (null? (rest numbers))\n              (first numbers)\n\
    \              (max (rest numbers))))))\n    (map #(/ (- % (- min max)) (- max\
    \ min)) numbers)))\n</cell>\n<cell>\n#lang racket\n", "  (cond [(null? numbers)\
    \ numbers]\n        [else (let ((n (car numbers)))\n                 (cond [(<\
    \ (first numbers) n) 0]\n                       [(> (first numbers) n) 1]\n  \
    \                     [else (rescale_to_unit (rest numbers))]))]))\n", "  (let\
    \ ([m1 (min numbers #f)])\n    (map #(/ (- %1 m1) %2) numbers)))\n", "  (let loop\
    \ ((smallest #f) (largest #f) (numbers numbers) (current #t))\n    (cond ((null?\
    \ numbers) '())\n          ((not current) (reverse numbers))\n          ((< number\
    \ (car numbers)) (loop (car numbers) (assoc largest number) (cdr numbers) (set!\
    \ current #f)))\n          ((< number (cdr numbers)) (loop (car numbers) (assoc\
    \ smallest number) numbers current))\n          ((not (set! current #f)) (loop\
    \ (car numbers) (cdr numbers) (cdr numbers) (set! current #f)))\n          (t\
    \ (loop (assoc smallest number) largest numbers current)))))\n", "  ((lambda (numbers)\n\
    \     (let ((min_value (min numbers)))\n       (let ((max_value (max numbers)))\n\
    \         (map\n          (\u03BB (number) (- (* min_value max_value) (/ number\
    \ max_value)))\n          numbers)))))\n", "  (let loop ([numbers numbers]\n \
    \            [smallest numbers]\n             [largest numbers])\n    (if (empty?\
    \ numbers)\n        numbers\n        (let ([smallest (min numbers)])\n       \
    \   (let ([largest (max numbers)])\n            (cond (\n                (= smallest\
    \ largest)\n                (loop (rest numbers) [smallest] numbers)\n       \
    \         (else (loop (rest numbers) [smallest] largest))\n              )\n \
    \             (else (loop numbers (rest smallest) largest))\n            )\n \
    \         )\n        )\n      )\n  )\n", "  (apply rescale_to_unit numbers))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
