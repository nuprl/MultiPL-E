name: HumanEval_15_string_sequence
language: rkt
prompt: "#lang racket\n\n;; Return a string containing space-delimited numbers starting\
  \ from 0 upto n inclusive.\n;; >>> string_sequence(0)\n;; '0'\n;; >>> string_sequence(5)\n\
  ;; '0 1 2 3 4 5'\n(define (string_sequence n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n\
  \    (check-equal? (candidate 0) \"0\")\n    (check-equal? (candidate 3) \"0 1 2\
  \ 3\")\n    (check-equal? (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\")\n))\n\n(test-humaneval)"
completions: ["  (cond [(< n 0) '0]\n        [(= n 1) '1]\n        [else (append (string_sequence\
    \ (sub1 n)) (list '(sub1 n)))]))\n", "  (if (< n 0)\n      '()\n      (let ([ss\
    \ (string-seq n)]\n            [str (interleave ss '')])\n        (reverse str))))\n",
  "  (if (= n 0)\n      '0\n      (append (string_sequence (sub1 n)) (list n))))\n",
  "  (let ([digits (string->list \n              (number->string \n              \
    \ (sub1 (string->number \n                        (number->string \n         \
    \                (sub1 n))))))])\n    (string-join\n     (map string->string digits)\n\
    \     \" \"))\n", "  (if (= n 0)\n      '0'\n      (string-append (string_sequence\
    \ (- n 1))\n                    (number->string n))))", "  (if (< n 20)\n    \
    \  (append (list '0)\n              (string_sequence (sub1 n))\n             \
    \ (string_sequence (sub1 n 2))\n              (string_sequence (sub1 n 4))\n \
    \             (string_sequence (sub1 n 6))\n              (string_sequence (sub1\
    \ n 8))\n              (string_sequence (sub1 n 10))\n              (string_sequence\
    \ (sub1 n 12))\n              (string_sequence (sub1 n 14))\n              (string_sequence\
    \ (sub1 n 16))\n              (string_sequence (sub1 n 18))\n              (string_sequence\
    \ (sub1 n 20))\n              (string_sequence (sub1 n 20))\n              (string_sequence\
    \ (sub1 n 20))))\n      '?))\n", "  (for/list ([i (in-range n)]) (string-append\
    \ (number->string i) \" \"))\n)\n", "  (if (< n 0)\n      '()\n      (cons (string-ref\
    \ (substring #:default (* n 10) 10) 0) (string_sequence (- n 1)))))\n", "  (list\
    \ n (string-sequence (sub1 n))\n        (string-sequence (sub1 n))))\n", "  (let\
    \ loop ((seq seq))\n    (cond\n      [(= n 0) (if (empty? seq) '() (reverse (first\
    \ (rest seq))))]\n      [(= n 1) (first (rest seq))]\n      [(< n 1) (loop (rest\
    \ seq))]\n      [else (cons n (loop (rest seq)))])))\n", "  (if (= n 0)\n    \
    \  (list)\n      (append (string_sequence (sub1 n))\n              (list n))))\n",
  "  (if (< n 0) (error \"n must be non-negative\") (append (string_sequence (- n))\
    \ (cons n (string-sequence n)))))\n", "  (let loop ((n n) (acc '()))\n    (if\
    \ (< n 0)\n        acc\n        (loop (- n 1)\n              (cons n (append acc\
    \ '()))))))\n</code>\n<|/ a |>\n<| c |>\nHmmm, this looks like an exponential\
    \ time solution... (The first one is O(1)). I'm sure there must be something I\
    \ can do to achieve this in O(n)\n<|/ c |>\n<| c |>\nYes, that appears to be true.\
    \  I didn't think to check the `append` implementation - it takes linear time.\
    \  My guess is that it does a similar thing as `append` itself but is unrolled\
    \ in some way.\n<|/ c |>\n<| c |>\nOh, so it's linear in the length of the string\
    \ you're appending to? That seems pretty bad, especially for large strings\n<|/\
    \ c |>\n<| c |>\nNo.  Since `append` itself is linear in the length of the first\
    \ list, it's not linear time at all.  The complexity of `append` itself is O(n).\n\
    <|/ c |>\n<| c |>\nOkay, yeah I misread that. Thanks I'll give this a shot!\n\
    <|/ c |>\n<| a tags=racket,list,scheme |>\n<code>", "  (let ([lst (list 0)])\n\
    \    (cond\n      [(= n 0) (list '0)]\n      [(< n 0) (list '0 string_sequence(0))]\n\
    \      [else (cons ((car lst) (car lst)) (string_sequence (sub1 n)))]\n      [(<\
    \ n 1) (string_sequence (sub1 n))]))))", "  (loop\n    for x in (range n) collect\
    \ (string x)))\n", "  (cond\n    ((= n 0) '0)\n    ((= n 1) '1)\n    ((= n 2)\
    \ '1 2)\n    ((= n 3) '1 2 3)\n    ((= n 4) '1 2 3 4)\n    ((= n 5) '1 2 3 4 5)\n\
    \    ((= n 6) '1 2 3 4 5 6)\n    ((= n 7) '1 2 3 4 5 6 7)\n    ((= n 8) '1 2 3\
    \ 4 5 6 7 8)\n    ((= n 9) '1 2 3 4 5 6 7 8 9)\n    ((= n 10) '1 2 3 4 5 6 7 8\
    \ 9 10)\n    ((= n 11) '1 2 3 4 5 6 7 8 9 10 11)\n    ((= n 12) '1 2 3 4 5 6 7\
    \ 8 9 10 11 12)\n    ((= n 13) '1 2 3 4 5 6 7 8 9 10 11 12 13)\n    ((= n 14)\
    \ '1 2 3 4 5 6 7 8 9 10 11 12 13 14)\n    ((= n 15) '1 2 3 4 5 6 7 8 9 10 11 12\
    \ 13 14 15)\n    ((= n 16) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)\n    ((= n\
    \ 17) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)\n    ((= n 18) '1 2 3 4 5 6\
    \ 7 8 9 10 11 12 13 14 15 16 17 18)\n    ((= n 19) '1 2 3 4 5 6 7 8 9 10 11 12\
    \ 13 14 15 16 17 18 19)\n    ((= n 20) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\
    \ 17 18 19 20)\n    ((= n 21) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\
    \ 20 21)\n    ((= n 22) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\
    \ 22)\n    ((= n 23) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\
    \ 23)\n    ((= n 24) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\
    \ 23 24)\n    ((= n 25) '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\
    \ 22 23 24 25)\n    ((= n 26) '1 2 3 ", "  (list '(string->number (string-append\
    \ \"0\" '(string n)))))\n</code>\n<|/ a tags=racket,sequence,scheme,string dscore=1\
    \ |>\n<| c |>\nThe answer above does work, though it isn't the cleanest solution.\
    \ There isn't a built-in procedure that does this but it's easy enough to write\
    \ one that takes advantage of rackets list manipulations (list->string) which\
    \ takes a list as a parameter. `(string->number (string-append \"0\" '(string\
    \ n)))` is just building the string from list n to string->number converting the\
    \ string to a number.\n<|/ c |>\n<| c |>\nI agree. I had just edited the answer\
    \ to incorporate the same solution while you posted this. Sadly my racket installation\
    \ doesn't have that procedure or string->number, so I didn't bother to look up\
    \ how it works.\n<|/ c |>\n<| a tags=racket,sequence,scheme,string |>\nI believe\
    \ this question is a duplicate of \"How to return a sequence of integers from\
    \ 0 to n\", but this answer seems to work much better:\n<code>", "  (make-string\
    \ (- n 10) (append (list-string (make-list n #\\space)) (list 'string))))", " \
    \ (if (< n 0)\n      '()\n      (append (string_sequence (sub1 n)) (list n))))\n",
  "  (let ([s (make-string)]\n        [i (string-length s)])\n    (cond [(> i n) (append\
    \ s (string->list n))]\n          [else (append s (string->list (sub1 i)))]\n\
    \          [else (string_sequence (sub1 i))])))\n", "  (map string ((range n))))\n",
  "  (if (zero? n) '(0)\n      (append (string_sequence (sub1 n)) (append (map number->string\
    \ (reverse (range n 0))) \" \"))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ answer is wrong. `string_sequence` returns numbers, not strings. `(map number->string\
    \ (reverse (range n 0)))` will map numbers to strings. In fact, it works in Common\
    \ Lisp, where `'(0 1 2 3 4 5)` can be passed to `append` instead of `'(0 (1 2\
    \ 3 4 5))`.\n<|/ c |>\n<| c |>\n, you're right, my bad. I just wanted to point\
    \ the reason why `(map number->string (reverse (range n 0)))` works in Lisp but\
    \ not in Racket. But in reality it does not. `(number->string 10)` gives me `'(\"\
    10\")`, while `(number->string 100)` gives me `'(\"100\")`. So it seems that in\
    \ Lisp the function `number->string` is being applied to the number `10` instead\
    \ of it's string representation.\n<|/ c |>\n<| c |>\n, you're right, my bad. I\
    \ just wanted to point the reason why `(map number->string (reverse (range n 0)))`\
    \ works in Lisp but not in Racket. But in reality it does not. `(number->string\
    \ 10)` gives me `'(\"10\")`, while `(number->string 100)` gives me `'(\"100\"\
    )`. So it seems that in Lisp the function `number->string` is being applied to\
    \ the number `10` instead of it's string representation. However it seems to be\
    \ a common Lisp idiom to convert the number to a string and therefore `number->string`\
    \ should work both in Lisp and Racket.\n<|/ c |>\n<| c |>\n`number->string` should\
    \ work on both Lisp and Racket, just as `number->integer` should work on both.\n\
    <|/ c |>\n<| c |>\n`number->string` only works in Racket, not in Common Lisp.\
    \ Common Lisp does not implement `number->string` (although it does implement\
    \ `number->integer`).\n<|/ c |>\n<| a |>\nThe other answers have given you a good\
    \ way to write your sequence, but they don't really address the reason why your\
    \ code doesn't work. Here's why: in Racket, map only works one way (from input\
    \ to output), so you get an error if you try to pas", "  (if (= n 0)\n      '0'\n\
    \      (concat '(string_sequence (sub1 n)) (list #\\space))))\n", "  (let loop\
    \ ((i 0) (s \"\"))\n    (if (< i n)\n        (loop (+ i 1) (cons i s))\n     \
    \   s)))\n</code>\n<|/ a dscore=0 tags=scheme,racket |>\n<| a tags=scheme,racket\
    \ dscore=0 |>\nHere is a solution in Racket without recursion.\n<code>", "  (cond\n\
    \    [(equal? n 0) '0]\n    [(equal? n 1) '1]\n    [else (string-sequence (sub1\
    \ n) (concat ' ' string_sequence (sub1 n)))))\n</code>\n#lang racket\n", "  (if\
    \ (< n 0)\n      '()\n      (cons n (string_sequence (sub1 n)))))\n", "  (if (=\
    \ n 0)\n      '0\n      (concat '(string_sequence (sub1 n)) \" \" (string-sequence\
    \ (sub1 n)))))\n", "  (if (= n 0)\n      '0\n      (append (string_sequence (sub1\
    \ n))\n              (list n))))\n", "  (let loop ((n n)\n             (string\
    \ '())\n             (i 0))\n    (cond [(= i n) (string)]\n          [(< i n)\
    \ (loop (+ n 1) (string (cdr string)) (+ i 1))]\n          [else (loop (+ n 1)\
    \ (cons i string) (+ i 1))])))\n", "  (build-string n (lambda (x) (+ x 1)) (lambda\
    \ (x) (+ x 2))))\n</cell>\n<code language=racket-language>", "  (list n (string->list\
    \ n)))\n", "  (if (>= n 0)\n      (cons n (string_sequence (sub1 n)))\n      (error\
    \ \"Out of range\")))\n", "  (format #f \"~a~a\" (quotient n 10)\n          (modulo\
    \ n 10)))\n", "  (cond ((= n 1) '0)\n        (else '(cons (string-sequence (-\
    \ n 1))\n                    (space-delimited-numbers (+ n 1))))))\n", "  (if\
    \ (= n 0)\n      '0'\n      (append (string_sequence (sub1 n))\n             \
    \ (list n))))\n", "  (if (= n 0)\n      '0'\n      (cond [(= n 1) (string-append\
    \ '0 '1)\n             (= n 2) (string-append '0 '1 '2)\n             (= n 3)\
    \ (string-append '0 '1 '2 '3)\n             (= n 4) (string-append '0 '1 '2 '3\
    \ '4)\n             (= n 5) (string-append '0 '1 '2 '3 '4 '5)\n             (=\
    \ n 6) (string-append '0 '1 '2 '3 '4 '5 '6)\n             (= n 7) (string-append\
    \ '0 '1 '2 '3 '4 '5 '6 '7)\n             (= n 8) (string-append '0 '1 '2 '3 '4\
    \ '5 '6 '7 '8)\n             (= n 9) (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8\
    \ '9)\n             (= n 10) (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 '10)\n\
    \             (= n 11) (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 '10 '11)\n\
    \             (= n 12) (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 '10 '11 '12)\n\
    \             (= n 13) (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 '10 '11 '12\
    \ '13)\n             (= n 14) (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 '10\
    \ '11 '12 '13 '14)\n             (= n 15) (string-append '0 '1 '2 '3 '4 '5 '6\
    \ '7 '8 '9 '10 '11 '12 '13 '14 '15)\n             (= n 16) (string-append '0 '1\
    \ '2 '3 '4 '5 '6 '7 '8 '9 '10 '11 '12 '13 '14 '15 '16)\n             (= n 17)\
    \ (string-append '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 '10 '11 '12 '13 '14 '15 '16 '17)\n\
    \             (= n 18) (string-append '0 '1 '2 '3", "  (cond [(< n 1)\n      \
    \   \"\"]\n        [(= n 0)\n         \"\"]\n        [else\n         (string->char\
    \ (string-append (number->string (sub1 (- n 1))) \" \" (n-string->string n)))]))\n",
  "  (if (= n 0)\n      '0\n      (string-append (string_sequence (sub1 n)) \" \"\
    \ (string-to-int (modulo (expt 2 n) 10)))))\n", "  (build-string n (\u03BB (x)\
    \ (+ (char->digit x) (* 10 x))))\n)\n", "  (if (>= n 0)\n      (append (string_sequence\
    \ (sub1 n))\n              (list 'n))\n      '()))\n", "  (for-each\n   (lambda\
    \ (x)\n     (string-append x \" \"))\n   (range 0 (add1 n))))\n", "  (let ([n\
    \ (modulo n 10)])\n    (if (= n 0)\n        '0'\n        (string-append (string_sequence\
    \ (sub1 n)) \" \" (string_sequence (sub1 n))))))\n", "  (if (= n 0)\n      '0\n\
    \      (concat (string_sequence (sub1 n)) \" \" '(0 ) (string_sequence (sub1 n)))))\n",
  "  (define (loop i s)\n    (if (< i n)\n        (cons (modulo (+ i 1) 10) s)\n \
    \       s))\n  (loop (+ (- n 1) 1) '()))\n", "  (let ([s (make-string n)]\n  \
    \      [n (string-length s)])\n    (for-each \n      (lambda (char)\n        (set!\
    \ s (substring s 0 n) (+ n 1) s))\n      (reverse s))))\n", "  (if (= n 0)\n \
    \     '()\n      (append (string_sequence (sub1 n))\n              (string n)\n\
    \              (string_sequence (sub1 n)))))\n", "  (if (= n 0)\n      '0\n  \
    \    (append (string_sequence (sub1 n)) (list n))))\n", "  (cond\n    ((= n 0)\
    \ '0)\n    ((= n 1) '1)\n    (else (cons (string-append (substring n 1) \" \"\
    ) (string_sequence (- n 1))))))\n", "  (if (= n 0) (string '0)\n    (cond ((<\
    \ n 0) (throw 'exn:bad \"n must be positive\"))\n          (#t (make-string n\
    \ #\\space))\n          (else (string (string-append (string_sequence (sub1 n))\
    \ #\\space (string_sequence (sub1 n))))))))\n", "  (map (lambda (x) (number->string\
    \ x))\n       (range 0 n)))\n", "  (apply str (range->list n)))\n", "  (lambda\
    \ ()\n    (let loop ([count 0])\n      (if (zero? count)\n          (list count)\n\
    \          (loop (add1 count)\n                (if (= count n) (rest count) '()))))))\n",
  "  (cond\n    ((= n 0) '0')\n    ((= n 1) '1')\n    (else\n     (string-join (lambda\
    \ (x acc)\n                    (if (= (modulo n x) 0)\n                      \
    \  (string-join (map string-append acc x) \" \" acc)\n                       \
    \ (string-append x acc))\n                    (map string-append (list x) acc))\n\
    \                   (range (+ 0 n))))))\n", "  (cond\n    [(< n 0)\n     '0]\n\
    \    [(> n 0)\n     (string-append (string_sequence (sub1 n)) (list n))]\n   \
    \ [else (list n)]))\n", "  (let loop ([i '0])\n    (if (< i n)\n        (append\
    \ (string-append (number i) \" \")\n                (loop (add1 i))))))\n", " \
    \ (if (>= n 0)\n      (apply append (map number->string\n                    \
    \   (range (- n 1))))\n      '()))\n", "  (let loop ((i 0))\n    (cond\n     \
    \ [(= i n) (list n)]\n      [(even? (+ i 2)) (cons (+ i 1) (loop (+ i 2)))]\n\
    \      [(odd? (+ i 2)) (cons (+ i 1) (loop (+ i 2)))]\n      [else (loop (+ i\
    \ 2))]\n    )\n  )\n)\n", "  (let ([s (string->char-list (number->string n)))\n\
    \        m (length (string->char-list (number->string n)))\n        result (if\
    \ (= m 0)\n                  '0\n                  (string-append (subseq-ref\
    \ s 0) (subseq-ref s 1)))])\n    (string->char-list (number->string n)) result))\n",
  "  (cond ((= n 0) '0)\n        ((= n 1) '1)\n        ((= n 2) '(0 1))\n        ((=\
    \ n 3) '(1 2))\n        ((= n 4) '(0 1 2))\n        ((= n 5) '(1 2 3))\n     \
    \   ((= n 6) '(0 1 2 3))\n        ((= n 7) '(1 2 3 4))\n        ((= n 8) '(0 1\
    \ 2 3 4))\n        ((= n 9) '(1 2 3 4 5))\n        ((= n 10) '(0 1 2 3 4 5))\n\
    \        ((= n 11) '(1 2 3 4 5 6))\n        ((= n 12) '(0 1 2 3 4 5 6))\n    \
    \    ((= n 13) '(1 2 3 4 5 6 7))\n        ((= n 14) '(0 1 2 3 4 5 6 7))\n    \
    \    ((= n 15) '(1 2 3 4 5 6 7 8))\n        ((= n 16) '(0 1 2 3 4 5 6 7 8))\n\
    \        ((= n 17) '(1 2 3 4 5 6 7 8 9))\n        ((= n 18) '(0 1 2 3 4 5 6 7\
    \ 8 9))\n        ((= n 19) '(1 2 3 4 5 6 7 8 9 10))\n        ((= n 20) '(0 1 2\
    \ 3 4 5 6 7 8 9 10))\n        ((= n 21) '(1 2 3 4 5 6 7 8 9 10 11))\n        ((=\
    \ n 22) '(0 1 2 3 4 5 6 7 8 9 10 11))\n        ((= n 23) '(1 2 3 4 5 6 7 8 9 10\
    \ 11 12))\n        ((= n 24) '(0 1 2 3 4 5 6 7 8 9 10 11 12))\n        ((= n 25)\
    \ '(1 2 3 4 5 6 7 8 9 10 11 12 13))\n        ((= n 26) '(0 1 2 3 4 5 6 7 8 9 10\
    \ 11 12 13))\n        ((= n 27) '(1 2 3 4 5 6 7 8 9 10 11 12 13 14))\n       \
    \ ((= n 28) '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14))\n        ((= n 29) '(1 2 3\
    \ 4 5 6 7 8 9 10 11 12 13 14 15))\n        ((= ", "  (let loop ((n n)\n      \
    \       (s \"\"))\n    (if (zero? n)\n        s\n        (loop (sub1 n) \n   \
    \           (append s (string->list n)))))\n  )\n", "  (if (= n 0)\n      '0\n\
    \      (append (string_sequence (sub1 n))\n              (cons n (string_sequence\
    \ (sub1 n))))))\n", "  (let loop ((s \"\")\n             (i 0))\n    (cond ((>\
    \ i n) (list s))\n          (else (loop (append s \" \" i)\n                 \
    \      (+ i 1))))))\n", "  (cond\n    [(= n 0) '0]\n    [(odd? n) (string 0 n)]\n\
    \    [(= n 1) (string 0 n)]\n    [else (append (string_sequence (/ n 2)) (string\
    \ 0 n (string->int (quotient n 2))))]\n  ))\n", "  (if (= n 0) '0' \n      (append\
    \ (string_sequence (- n 1)) \n              (append (list n) \n              \
    \        (string_sequence (- n 1)))\n              (string_sequence (- n 1)))\n\
    \      )\n  )\n", "  (if (>= n 0)\n      (map string-append (list '(0) (range\
    \ n)))\n      '()))\n", "  (if (< n 0)\n      '()\n      (append (string_sequence\
    \ (sub1 n))\n              (list n))))\n", "  (if (< n 0)\n      '()\n      (append\
    \ (string_sequence (sub1 n))\n              (list n n))))\n", "  (let loop ((i\
    \ 0)\n             (acc '()))\n    (if (< i n)\n        (cons (string->symbol\
    \ (modulo (+ n i) 10)) acc)\n        acc)))\n", "  (if (< n 0)\n      '()\n  \
    \    (append (cons n (string_sequence (- n 1)))\n              (string_sequence\
    \ n))))\n", "  (let loop ([i 0])\n    (cond\n      [(= i n) '()]\n      [else\
    \ (cons (number->string i) space)])))\n", "  (if (< n 0)\n      '()\n      (cons\
    \ (string-append (substring n 0))\n            (string-sequence (- n 1)))))\n",
  "  (let ([acc ''])\n    (cond [(< n 0)\n           (if (zero? (car acc))\n     \
    \          (append acc '0)\n               (append acc (car acc)))]\n        \
    \  [(< n 10)\n           (append acc (string-append \" \" (number->string n)))]\n\
    \          [else\n           (string-append acc (string-append \" \" (number->string\
    \ n)))]\n          (else (string_sequence (sub1 n)))])))\n", "  (if (< n 0)\n\
    \      '()\n      (append (string_sequence (- n 1))\n              (list n)\n\
    \              (string_sequence n))))\n", "  (string-append (list (string-ref\
    \ \"0123456789\" n))\n                   (list (substring (string n) 0 n))\n \
    \                  (string (substring (string n) 0 n))))\n", "  (format #t \"\
    ~a\" (loop for i from 0 to (sub1 n) collect i)))\n", "  (if (= n 0)\n      '0'\n\
    \      (cons (string-append (string_sequence (- n 1)) \" \" (number->string n)))))\n",
  "  (let loop ((i n (+ i 1)))\n    (cond\n      [(<= i 0) '']\n      [(even? i) (string\
    \ i \" \")]\n      [else (string i \" \") (loop (+ i 1))])))\n", "  (if (< n 0)\n\
    \      '()\n      (cons n (string-sequence (sub1 n))))) ; string<->seq<->seq",
  "  (cond\n    [(zero? n) \"\"]\n    [(odd? n) (string-append (string_sequence (sub1\
    \ n)) \" \")]\n    [else (string_append (string_sequence (sub1 n)) \" \"))]))\n",
  "  (let loop ((i 0)\n             (s #(~a ~a)))\n    (cond ((= i n) s)\n       \
    \   ((= i 0) (reverse s))\n          ((< i n) (loop (+ i 1) (cons (- i 1) s))))))\n",
  "  (if (> n 0)\n      (cons (number->string n)\n            (string-sequence (sub1\
    \ n)))\n      '()))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| c |>\n\
    I upvoted this, but for completeness it's important to say that `string-sequence`\
    \ is not part of the base language, only in the `racket-lib` package.\n<|/ c |>\n\
    <| c |>\nYou're absolutely right. Thanks for pointing that out. I think I'm getting\
    \ old and should stop answering questions when I am.\n<|/ c |>\n<| c |>\nI think\
    \ that's a very important point to make, because if you answer in a language other\
    \ than Racket (say Scheme) without mentioning the specific package, the OP may\
    \ be tempted to use that package's `string-sequence`, which may not work as expected\
    \ when working with Racket as a whole.\n<|/ c |>\n<| c |>\nThanks for your efforts,\
    \ this is much more advanced and helpful. I understand that the Racket Lib package\
    \ is part of the base language but I have not seen this package before.\n<|/ c\
    \ |>\n<| c |>\n, you're quite welcome.  I love using Racket for my daily work\
    \ and I like how easy it is to extend Racket in as many ways as I can.  I'm really\
    \ enjoying this language and I thought it would be fun to try Racket again.  :)\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  (let* ((seq (string->list \"0123456789\"\
    ))\n         (i (string-length seq))\n         (c (substring seq i n)))\n    (substring\
    \ seq 0 i)\n    (list c)))\n", "  (if (= n 0)\n      '0\n      (+ (string-sequence\
    \ (sub1 n)) (if (odd? n) ' ' ','))))\n", "  (if (< n 0)\n      '()\n      (let\
    \ iter ((n n))\n        (if (zero? n) '()\n            (cond ((= n 0) (string-append\
    \ '0 (string-sequence (- n 1))))\n                  ((even? n) (append (iter (quotient\
    \ n 2)) (cons '1 iter)))\n                  (else (append (iter (quotient n 2))\n\
    \                              (iter (quotient n 2)))))))))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nWhat a beautiful solution! But this looks like a recursive solution\
    \ when actually it is not (for lack of better word). Recursion can be done in\
    \ many ways, here is a good article http://en.wikipedia.org/wiki/Recursion_%28computer_science%29.\
    \ I'll try to come up with another answer that does not use recursion.\n<|/ c\
    \ |>\n<| a |>\nHere is another solution that does not use recursion.\nIt uses\
    \ iteration and has a nice abstraction to it.\n<code>", "  (define (iter i)\n\
    \    (if (< i n) (string-append (symbol->string i) (symbol->string (i + 1))) \"\
    \"))\n  (iter 0))\n", "  (map (\u03BB (n) (- n 1)) \n       (string->list n)))\n",
  "  (let-values ([(start end rest)]\n               (map append '() \n          \
    \             (map list \n                             (number->string start)\n\
    \                             (number->string (n-sub1 end)) \n               \
    \              rest)))\n    (string->number start)))\n", "  (if (< n 0)\n    \
    \  '()\n      (append (string_sequence (sub1 n)) (list n))))\n", "  (append (list\
    \ '0)\n          (map (lambda (i)\n                 (format \"~a \" (- n i)))\n\
    \              (range n))))\n", "  (let* ((s (cons '0 '()))\n         (i (- n\
    \ 1)))\n    (if (> i 0)\n        (cons (string-append s (string-sequence i))\n\
    \              s)\n        (s)))\n", "  (let loop ((s \"\")\n             (i 0))\n\
    \    (cond ((= i n) s)\n          (else (loop (cons (string i) s) (inc i)))\n\
    \      )\n  )\n)\n", "  (let ([xs (string->list n)]\n        [i (string-length\
    \ xs)])\n    (cond [(= i 0)\n           '']\n          [(= i (string-length xs))\n\
    \           ']\n          [(= i 2)\n           (cons '(cons 0 (string-append '(cons\
    \ (first xs) (string_sequence (second xs))) ))\n                   (cons (second\
    \ xs) (string_sequence (sub1 (third xs)))))]\n          [else\n           (cons\
    \ (first xs) (cons (second xs) (string_sequence (sub1 (third xs)))))])))\n</code>\n\
    <|/ a tags=scheme,racket,recursion dscore=1 |>\n<| a dscore=1 tags=scheme,racket,recursion\
    \ |>\nTry this:\n<code>", "  (if (<= n 0) \n      '0\n      (append (string_sequence\
    \ (- n 1)) (list n))))\n", "  (if (= n 0)\n      '0\n      (append (string_sequence\
    \ (sub1 n)) (list n))))\n", "  (let* ((s (make-string 1 #\\space))\n         (result\
    \ (make-string 0 #\\space)))\n    (loop for i below n\n         for j from i by\
    \ -1\n         collect (set! s (string-append s (number->string j)))\n       \
    \  into result\n         finally (return result))))\n", "  (cond [(= n 0)\n  \
    \       \"\"]\n        [(= n 1)\n         \"0\"]\n        [(= n 2)\n         \"\
    0 1\"]\n        [(= n 3)\n         \"0 1 2\"]\n        [(= n 4)\n         \"0\
    \ 1 2 3\"]\n        [(= n 5)\n         \"0 1 2 3 4\"]\n        [else\n       \
    \  (string-join (list \"0\"\n                           (string-sequence (sub1\
    \ n))\n                           (string-sequence (sub2 n)))]))) ; #lang racket\n",
  "  (let ([x 0])\n    (lambda ()\n      (set! x (+ x 1))\n      (cond [(= x n) (cons\
    \ (- n x) (string_sequence x))]\n            [(= x 0) '0]\n            [else (cons\
    \ (- x 1) (string_sequence x))]))))\n</code>", "  (cond [(= n 0)\n         '0]\n\
    \        [(< n 10)\n         (string-append \" \" (string-sequence (- n 1)))]\n\
    \        [else\n         (string-append \" \" (string-sequence (- n 10)))]\n \
    \       (else\n         (string-append \" \" (string-sequence (- n 100)))))\n",
  "  (let loop ((n (modulo n 10)))\n    (cond\n      [(= n 0) '0]\n      [(= n 1)\
    \ '1]\n      [(= n 2) '2 1]\n      [(= n 3) '3 2 1]\n      [(= n 4) '4 3 2 1]\n\
    \      [(= n 5) '5 4 3 2 1]\n      [(= n 6) '6 5 4 3 2 1]\n      [(= n 7) '7 6\
    \ 5 4 3 2 1]\n      [(= n 8) '8 7 6 5 4 3 2 1]\n      [(= n 9) '9 8 7 6 5 4 3\
    \ 2 1]\n      [(= n 10) '10 9 8 7 6 5 4 3 2 1]\n      [else (loop (sub1 n))])))\n",
  "  (let ([ss (make-string)]) (set! ss (string-append ss \"0\")) (loop (- n 1) ss)))\n",
  "  (map string->symbol\n       (reverse (range-seq (- n 1) n)))) ; reverse so as\
    \ to put in order 0,1,2,3...", "  (if (zero? n)\n      '()\n      (cons (string-ref\
    \ \"0123456789\" n) (string_sequence (sub1 n))))))\n", "  (let loop ([i 0])\n\
    \    (if (= n 0)\n        '0\n        (+ (string-append (number->string i) \"\
    \ \") (loop (add1 i)))))\n  (loop n))\n", "  (let loop ([acc '0] [n n] [i 0])\n\
    \    (cond\n      [(= i n) (string-append acc '\\n)]\n      [(< n 0) (loop)\n\
    \        (loop (string-append acc '\\n)\n               (+ n i)\n            \
    \   (+ i 1))]\n      [else (loop (string-append acc '\" \")\n                \
    \   (+ n i)\n                   (+ i 1))])))\n", "  (let loop ([acc '0])\n   \
    \ (cond ((< n 0) acc)\n          ((= n 0) '0)\n          (else\n           (loop\
    \ (cons n (string_sequence (- n 1))))\n           (cons acc '\n              \
    \   )))))\n", "  (if (= n 0)\n      '0\n      (append (string_sequence (sub1 n))\n\
    \              (cons (string->number (char->string (char->integer n))) \" \"))))\n\
    </code>\n<|/ a tags=racket,scheme,functional-programming dscore=1 |>\n<| a dscore=0\
    \ |>\nApart from answers already posted above, you can also use mapcar from racket\n\
    <code>\n#lang racket", "  (let loop ((n n) (result '()))\n    (cond\n      [(=\
    \ n 0) (append result '0)]\n      [(< n 0)\n       (error \"string_sequence: n\
    \ must be non-negative.\")]\n      [else\n       (loop (sub1 n) (cons (string->number\
    \ result) result))])))\n</code>\n<|/ a dscore=3 tags=racket,scheme |>\n<| a |>\n\
    The most simple solution is as following:\n<code>", "  (let loop ((n (in-range\
    \ n)))\n    (if (<= n 0)\n        (newline)\n        (cons (string-to-int (number\
    \ n)) (loop (sub1 n))))))\n</code>\nAnd of course, with Racket we can use the\
    \ built-in string procedures, such as string-join:\n<code>", "  (if (= n 0)\n\
    \      '0'\n      (append (string-sequence (- n 1)) (list n))))\n", "  (if (<=\
    \ n 0)\n      '()\n      (append (string-sequence (sub1 n)) (list n))))\n", " \
    \ (let loop ((i 0))\n    (if (= i n)\n      (cons (concat \"0\" (rest i)) '())\n\
    \      (cons (concat i \" \") (loop (+ i 1))))))\n", "  (if (<= n 0)\n      '()\n\
    \      (cons (string->list (number->string n)) (string_sequence (sub1 n)))))\n",
  "  (define (loop i s)\n    (cond ((= i n) s)\n          ((even? i) (reverse (append\
    \ s (list i)))))\n          (else (loop (+ i 1) (append s (list i)))))\n  (loop\
    \ (+ n 1) '()))\n", "  (map string->symbol (range n)))\n", "  (if (<= n 0)\n \
    \     '()\n      (append (cons (modulo-arithmetic 0 n 100))\n              (string_sequence\
    \ (- n 100))))))\n", "  (cond [(= n 0)\n         '']\n        [else\n        \
    \ (string-append (string_sequence (sub1 n))\n                        (string n))]\n\
    \        ))\n", "  (if (< n 0)\n      '()\n      (string-append\n       (substring\
    \ '(0) (+ 1 n))\n       (string-append\n        '(\n          (number->string\
    \ . )\n          (number->string . )\n          (number->string . )\n        \
    \  (number->string . )\n          (number->string . )\n          (number->string\
    \ . )\n          (number->string . )\n          (number->string . )\n        )\n\
    \        (string-sequence (- n 1))\n       (string-append\n        (substring\
    \ '(0) (+ 1 n))\n        (substring '(0 1 2 3 4 5) 0 n)\n       )\n      )\n \
    \     )\n  )\n", "  (let loop ((n n) (str (make-string n)))\n    (if (< n 0)\n\
    \        str\n        (loop (sub1 n) (append-string \" \" (string->list str)))))\n\
    </code>\n<|/ a tags=racket,scheme,racket-student-languages |>\n<| a tags=racket,scheme,racket-student-languages\
    \ |>\nTo avoid using set!, using only recursion:\n<code>", "  (if (< n 0)\n  \
    \    \"\"\n      (apply append (map string-char (range n)))))\n", "  (string->list\n\
    \   (lambda () (range n))))\n", "  (let loop ([result ''])\n    (if (> n 0)\n\
    \        (loop (string-append result (string-append ' ' n))))\n    result))\n",
  "  (map list '(0) '(0 1) '(0 1 2) '(0 1 2 3) '(0 1 2 3 4) '(0 1 2 3 4 5)))\n", " \
    \ (let ([i 0])\n    (if (< i n)\n        (concat \n         (append (list '(0)\
    \ (string i))\n                  (string_sequence (+ i 1)))\n        '()))))\n\
    </code>\n<|/ a |>\n<| c |>\nIt's a good idea to include a description of what\
    \ you did and how you did it. Just a good idea for future readers, IMO.\n<|/ c\
    \ |>\n<| c |>\nThanks Joshua, this was really useful.\n<|/ c |>\n<| c |>\nNo problem.\n\
    <|/ c |>\n<| a tags=racket,scheme,lisp dscore=0 |>\nI find this a bit more elegant,\
    \ but it is probably less efficient:\n<code>", "  (let loop ((n n) (acc '()))\n\
    \    (if (= n 0)\n        (string-append acc '0)\n        (loop (sub1 n) (cons\
    \ (string->number n) acc)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\n\
    Nice!  I didn't know about the `string-append` function.  Very useful.\n<|/ c\
    \ |>\n<| c |>\nI added a solution that uses `append` instead of `string-append`\
    \ to my answer, thanks for your suggestion. :)\n<|/ c |>\n<| c |>\nThat would\
    \ be very cool!  Thanks for sharing.  I wouldn't have thought of it without your\
    \ solution.\n<|/ c |>\n<| c |>\nI realized that the solution to my question had\
    \ already been provided before your answer.  Therefore, I've deleted my answer\
    \ and accepted the solution to my question.\n<|/ c |>\n<| c |>\nI'm glad you realised\
    \ that.  I think it would be better if you could delete your own answer so that\
    \ people don't see it and then come back after an hour or so to see what you did.\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nI came up with this solution: \n<code>",
  "  (if (= n 0)\n      '0'\n      (append (string_sequence (sub1 n)) \" \" (string_sequence\
    \ (sub1 n)))))\n", "  (let* ((a (build-list n #\\space))\n         (i (make-integer\
    \ 0))\n         (s \"\"))\n    (dotimes (i n)\n      (set! s (cons a s))\n   \
    \   (set! a (cons (number->string i) (subseq a (+ i 1)))))\n    s))\n", "  (let\
    \ ([s (make-string) (i (string-length s))]\n        [ss (make-string) (i (string-length\
    \ ss))])\n    (set! s (string-append s (string->string (n-th n '()))))\n    (set!\
    \ ss (string-append ss (string->string (n-th n '()))))\n    s))\n", "  (if (<\
    \ n 0)\n      '()\n      (cons '0 (string-sequence (sub1 n)))\n    )\n)\n", " \
    \ (apply join (map (lambda (x) (list number->string x))\n                   (range\
    \ (- n 1)))))\n", "  (if (< n 0)\n      '()\n      (append (cons n (string_sequence\
    \ (- n 1))) ' ))))\n", "  (let loop ((i 0) s)\n    (if (<= i n) (concat s ' ')\
    \ (loop (add1 i) '()))))\n", "  (string->symbol\n   (string->list \n    (loop\
    \ for i from 0 to (* n 5) (+ i 1)\n         collect \n           (if (= i n) \n\
    \               i\n               (+ i 1)))))\n", "  (define (iter i s)\n    (cond\n\
    \      [(< i n) s]\n      [else (iter (+ i 1) (cons (mod i 10) s))]))\n  (iter\
    \ 0 ''))\n", "  (if (= n 0)\n      '0\n      (cons (string-append (string_sequence\
    \ (sub1 n)) \" \") (string-sequence (sub1 n)))))\n", "  (define (inner)\n    (string-append\
    \ (cons n (string-sequence (+ n 1))) \" \"))\n  (inner))\n", "  (if (= n 0)\n\
    \      '0'\n      (append (string_sequence (sub1 n))\n              (string-append\
    \ ' ' n)))))\n", "  (let loop ((s \"\")\n             (i 0))\n    (cond\n    \
    \  [(or (< i n) (null? s)) (list s)]\n      [else (loop (append s (list i))\n\
    \                   (+ i 1))]))\n  ", "  (let loop ((n n) (s \"\"))\n    (if (=\
    \ n 0)\n        (reverse s)\n        (loop (sub1 n) (append s (list n))))))\n",
  "  (let loop ([i 0])\n    (cond [(< i n) (string i)]\n          [else (loop (+ i\
    \ 1))])))\n</code>\n<|/ a |>\n<| c |>\nThat is how I ended up doing it, I was\
    \ just hoping there was a better way like one that doesn't involve recursion.\n\
    <|/ c |>\n<| c |>\nThe only thing I can think of is to use `fold-right` with a\
    \ combinator that does your `string_sequence` but in reverse. Not sure if that's\
    \ any better.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme,recursion |>\nIt's not\
    \ a good use of fold to do it, since you're not actually folding (but you might\
    \ be able to use a fold to do the iteration), but here's my attempt, which I think\
    \ is about as clean as it gets without using loop:\n<code>", "  (if (= n 0)\n\
    \      '0\n      (cons (string-append (substring n 0) (substring n 1) \" \") (string_sequence\
    \ (substring n 1)))))\n", "  (if (= n 0)\n      '0\n      (let loop ((n n) (s\
    \ ''))\n        (if (= n 0)\n            (append s s)\n            (loop (sub1\
    \ n) (cons (modulo n 10) s)))))))\n</code>\n<|/ a tags=scheme,racket,numbers,sequence,string\
    \ dscore=1 |>\n<| c |>\nThanks a lot for the help! I actually did have a go at\
    \ it myself but had no idea how to implement it in scheme since I'm still very\
    \ new to it.\n<|/ c |>\n<| c |>\nHi, sorry to bother again, but I've now encountered\
    \ another problem. What should I do if I want the sequence to be of length n?\
    \ I tried changing the code by changing the modulo lines to (modulo n 10) and\
    \ (modulo n 100), but then the program doesn't even run. Thanks!\n<|/ c |>\n<|\
    \ c |>\nYou don't need to change the modulo lines. Just replace the `0` with `n`\
    \ in the call to `string_sequence`.\n<|/ c |>\n<| a |>\nTry this code, I used\
    \ a helper function:\n<code>\n#lang racket", "  (let loop ((i 0) (s \"\"))\n \
    \   (if (<= i n)\n        (loop (+ i 1) (cons i s))\n        s)))\n", "  (for-each\
    \ (lambda (i)\n             (printf \"~a \" i))\n           range-from 0 (add1\
    \ n)))\n", "  (make-string n (string->number n) (string->number n)\n         \
    \      (string->number n) (string->number n) 'space\n               #f '(0 1 2\
    \ 3 4 5)))\n", "  (if (< n 0)\n      '()\n      (append (string_sequence (sub1\
    \ n)) (list n))))\n", "  (if (< n 0)\n      '()\n      (append (string_sequence\
    \ (sub1 n))\n              (cons (sub1 n)\n                    (string-sequence\
    \ (sub1 n)))\n              (string_sequence (sub1 n))))) \n", "  (map string->number\
    \ \n       (range 0 (add1 n))))\n", "  (for-each (lambda (x) (write-char x output-stream))\
    \ (range-from 0 n)))\n", "  (map string->symbol (range n)))\n", "  (let loop ((n\
    \ n) (acc '()))\n    (if (< n 0)\n        acc\n        (loop (- n) (cons (number->string\
    \ (number->int n)) acc)))))\n", "  (if (<= n 0)\n      '(0)\n      (cons (string->number\
    \ (number->string n)) (string_sequence (sub1 n))))))\n", "  (map (lambda (n) (list\
    \ n)) (range# n)))\n", "  (if (= n 1)\n      '0\n      (cons '0\n            (string_sequence\
    \ (sub1 n))\n            (string_sequence (sub1 n))))) ;; cons is the same as\
    \ append\n", "  (let ([digits '(())])\n    (loop for i from 0 to (- n 1) while\
    \ digits[i] <> '()\n          collect (cond ((= i 0) (cons i digits))\n      \
    \                 ((= i n) (cons i digits)\n                       (else digits)))))\n\
    </code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| c |>\nOkay, the code works fine.\
    \ But why does it always return `(()())` instead of `'(0 1 2 3 4 5)`?\n<|/ c |>\n\
    <| c |>\nMy mistake; I didn't realize that the problem was that I had previously\
    \ written `(string_sequence 5)` which returns `(()())`.\n<|/ c |>\n<| c |>\nIf\
    \ it had been `(string_sequence 1)` instead, it would have returned `'(0)` rather\
    \ than `'(0 1 2 3 4 5)`. It looks like my solution was designed to avoid that\
    \ kind of situation. The final `else` clause would have been `(else (cons i digits)))`\
    \ instead of `digits` so that it would return `(0 1 2 3 4 5)` instead of `'(0\
    \ 1 2 3 4 5)`.\n<|/ c |>\n<| a tags=racket,scheme dscore=0 |>\nHere's one possible\
    \ solution:\n<code>", "  (cond [(= n 0) '0]\n        [(>= n 1) (append (string_sequence\
    \ (sub1 n)) '1)]))\n", "  (if (= n 0)\n      '0\n      (cons '0 (string-sequence\
    \ (sub1 n)))))\n", "  (let loop ([i 0] [s \"\"])\n    (if (= i n)\n        (reverse\
    \ s)\n        (loop (+ i 1) (cons i s)))))\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    Here's an answer using a lambda function.\n<code>", "  (if (< n 0)\n      '()\n\
    \      (append (string_sequence (- n)) (list n))))\n", "  (for/fold ((acc '(0))\
    \ (inc)) (i n)\n    (set! acc (cons (string->number i) acc))\n    acc))\n", " \
    \ (cond [(= n 0) '0]\n        [(< n 10) (string-sequence (sub1 n)) (cons (number->string\
    \ n) (string-sequence (sub1 n)))]\n        [else (cons (number->string n) (cons\
    \ (number->string n) (string-sequence (sub1 n)))) (cons (number->string n) (cons\
    \ (number->string n) (string-sequence (sub1 n))))]))\n", "  (let ([x (make-string\
    \ n #\\0))\n        y\n        f (lambda (i)\n             (let ([a (substring\
    \ x i (+ i 1))\n                    b (substring x i (- i 1))])\n            \
    \   (string-append a (f (+ i 1)) b))))])\n  (string-append\n   (f 0)\n   (string-append\
    \ \" \" (string_sequence n))))\n", "  (if (= n 0)\n      '0\n      (append (string_sequence\
    \ (sub1 n))\n              (list n)\n              (string_sequence (sub1 n)))))\n",
  "  (if (= n 0)\n      '0'\n      (append (string_sequence (sub1 n)) (list n))))\n",
  "  (if (= n 0)\n      '0\n      (concat (string-sequence (sub1 n)) (list n))))\n",
  "  (if (zero? n) '0 ()\n      (append (append '(string_sequence (sub1 n))\n    \
    \              (cons (number->string n) '())))))\n", "  (if (< n 0)\n      '()\n\
    \      (append (string n)\n              (string_sequence (sub1 n))))) ;; <---\
    \ HERE\n", "  (let ([res (make-string n #\\space)])\n    (set! res (reverse res))\n\
    \    (concat (reverse res) res)))\n", "  (define str (make-string))\n  (define\
    \ i (make-iter))\n  (define nstr (make-string))\n  (define n (+ n 1))\n\n  (iter\
    \ i (for i 0 (< n 0) (+ 1 (+ i 1))))\n\n  (iter (for-each str (lambda (i) (set!\
    \ str (append str (format '% d i)))) (+ i 1))\n        (lambda (i s)\n       \
    \   (set! str (append str (format '% d i))\n                      (set! nstr (append\
    \ nstr (format '% d i))))\n          (set! n (+ i 1)))\n      (str nstr))\n)\n",
  "  (if (zero? n)\n      '()\n      (append (list n)\n               (string_sequence\
    \ (- n 1)))))\n", "  (let loop ((i n (string-append \"0\"))\n             (s ''))\n\
    \    (if (= i 0)\n        (reverse s)\n        (loop (sub1 i) (cons i s)))))\n\
    </code>\n<|/ a tags=scheme |>\n<| c |>\nThanks for this answer and the effort\
    \ to write it. It really helped. I learned a lot from it.\n<|/ c |>\n<| c |>\n\
    No worries, glad to help. It would be nice if you marked my answer as correct\
    \ ;-) I'm glad it was helpful.\n<|/ c |>\n<| c |>\nNo problem. I had a very similar\
    \ challenge last week. I was doing it for a class so I thought I'd give it a shot\
    \ just for the challenge. The question was very similar to mine so I thought I'd\
    \ give it a shot. :)\n<|/ c |>\n<| a tags=scheme |>\nA simple solution would be\
    \ to take advantage of the modulo operator:\n<code>", "  (let loop ((i 0) (acc\
    \ '()))\n    (if (< i n)\n        (loop (+ i 1) (cons i (reverse acc)))\n    \
    \    acc)))\n", "  (cond [(< n 0)\n         \"\"]\n        [(= n 1)\n        \
    \ \"\"]\n        [else\n         (string-append (string_sequence (sub1 n)) #\"\
    \ \" (string_sequence (sub1 n))\n             )]))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a dscore=0 |>\nA recursive solution that works in any version of Racket:\n\
    <code>", "  (let loop ((i 0))\n    (if (= i n) '()\n        (cons (string->number\
    \ (string->list i))\n              (loop (+ i 1)))))))\n", "  (if (<= n 0)\n \
    \     '()\n      (cons (string-append (number n) (string \" \")) (string_sequence\
    \ (sub1 n))))) ;; #lang racket\n", "  (list n (string->list (number->string n))))\n\
    </code>\nThe other answers don't really work correctly when n > 16 (which happens\
    \ quite often in real-world code where we're trying to avoid the exponential case\
    \ and we're using number->string).\n<|/ a dscore=5 |>\n<| c |>\nI like this one\
    \ the best.  It's a more flexible solution, one that doesn't require any type\
    \ declaration, etc.  It doesn't require to declare a new type just to get number->string.\n\
    <|/ c |>\n<| c |>\nI like it.  It's elegant, clear, and simple.\n<|/ c |>\n<|\
    \ c |>\nGreat solution! I love that it doesn't require a type declaration.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work for large numbers, e.g., `string_sequence 16`\
    \ yields `'0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16'`.\n<|/ c |>\n<| c |>\nI didn't\
    \ realize that number->string had such an inconsistency in the output. That's\
    \ a very helpful thing to know!\n<|/ c |>\n<| a tags=lisp,scheme,racket dscore=4\
    \ |>\nI prefer \"string-append\", which works nicely for numbers:\n<code>", " \
    \ (for/range (x n)\n    (string-append (format #f (add x (sub (length str) 1)))\
    \ \" \"))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI believe you should be able\
    \ to use this with `#lang racket` by changing the `let` and `define` to `define`\
    \ and `let`, respectively.\n<|/ c |>\n<| c |>\nI thought of this, but I didn't\
    \ want to import Racket just for this function. My first thought was `racket/string`\
    \ and then I was thinking if one could write `#lang racket` just for one function\
    \ that could probably be done in some `string` library.\n<|/ c |>\n<| c |>\nBut\
    \ I suppose that might be the only way without an external module. One can write\
    \ modules in `#lang racket` and they can have their own `define` and `let`, but\
    \ there isn't a way to do it without an external module (unless one is using a\
    \ `racket` version which supports it).\n<|/ c |>\n<| c |>\nI wonder if one could\
    \ write `#lang racket` just for this function to get away with not using an external\
    \ module. As far as I can tell, there's no `racket/string` module to import anyway,\
    \ so I'm wondering if that's really the only way.\n<|/ c |>\n<| c |>\nI guess\
    \ the `racket/string` module does depend on Racket and thus requires it, so it's\
    \ not really a problem. But the `racket` version only works on Racket (as far\
    \ as I can tell) so if you can't use Racket for some reason it may not be feasible.\n\
    <|/ c |>\n<| a |>\nHere's a very simple implementation:\n<code>", "  (for/list\
    \ ([i n] ([c '0'])) (lambda ()\n    (cond\n      [(< i 0) c]\n      [(= i (- n\
    \ 1)) c (string-append \" \" (string-seq c))]\n      [else (string_sequence (-\
    \ n 1)) (set! c (string-append \" \" (string-seq c))) (set! i (- n 1))]\n    \
    \  ))))\n", "  (if (= n 0)\n      '0\n      (concat (string_sequence (sub1 n))\
    \ (map string '(0 1 2 3 4 5 6 7 8 9))))\n  )\n", "  (if (= n 0)\n      '()\n \
    \     (append (string_sequence (sub1 n))\n              (list n)))))\n", "  (cond\
    \ [(= n 0) \"0\"]\n        [(= n 1) (string 0)]\n        [(< n 1) (append (string_sequence\
    \ (sub1 n)) (list n))]))\n</cell>\n<cell>", "  (let loop ((i 0) (s \"\"))\n  \
    \  (if (> i n)\n        s\n        (loop (add1 i) (concat s \" \" (number->string\
    \ i))))))\n", "  (list 'string\n        (for/list ([i (in-range n)]) (number->string\
    \ i))))\n</code>\n<|/ a tags=racket,scheme,lisp dscore=3 |>\n<| c |>\nHi, can\
    \ you help me understand why the 'number->string' call needs two arguments?\n\
    <|/ c |>\n<| c |>\nI guess that `i` is the index of each element of the list,\
    \ as opposed to the actual element itself. So, the `number->string` call is basically\
    \ converting `i` into a string representation of that element.\n<|/ c |>\n<| c\
    \ |>\nIt might be easier to use `(number->string i)` instead of `(list 'string\
    \ i)`, as this would also handle `0` properly. Also, it would handle the empty\
    \ list as well.\n<|/ c |>\n<| c |>\nGood point! I updated the answer to include\
    \ the suggestion.\n<|/ c |>\n<| a dscore=2 tags=racket,scheme,lisp |>\nI wrote\
    \ another answer for a different question. It is a slight variation on what was\
    \ already suggested.\n<code>", "  (let loop ((seq (string->list (string-append\n\
    \                                      (string->string n)\n                  \
    \                    \" 0\"))))\n    (if (= n 0)\n        (string->string seq)\n\
    \        (loop (cdr seq)))))\n</code>\n<|/ a |>\n<| c |>\nI'm pretty sure you\
    \ can do this without loops at all.  You just need a simple function to concatenate\
    \ two strings.  It's not very efficient (quadratic time), but it'll work.\n<|/\
    \ c |>\n<| c |>\n- I did a little benchmarking to make sure it wasn't just me\
    \ being slow, but I didn't find it to be the case. I did find `string-append`\
    \ to be much faster than looping in Racket than using `+` with a string. Though\
    \ I must admit I'm not an expert so I could be wrong (the docs don't seem to suggest\
    \ it would be any faster).\n<|/ c |>\n<| c |>\nI guess I was just making a point\
    \ that `string-append` is more efficient than a loop.  I didn't realize it would\
    \ be any better than a `loop` though, given that it's written in Racket rather\
    \ than JS.\n<|/ c |>\n<| c |>\nA recursive function is a more common pattern in\
    \ Lisp than a loop. Loops make it hard to reason about the code. Recursion is\
    \ a key part of Lisp. It has it's place. It's just not *the* most common form\
    \ of recursion (though it's often used the most).\n<|/ c |>\n<| c |>\n- Thanks\
    \ for your comments. I'm quite new at Lisp myself and I wasn't aware that `loop`\
    \ was more common than recursion. I did find it to be a bit slower though, even\
    \ on small inputs. I also did not know that `string-append` was faster either.\n\
    <|/ c |>\n<| a tags=scheme,racket,lisp dscore=2 |>\nI believe you can do this\
    \ in one line using some fairly advanced list operations:\n<code>", "  (if (zero?\
    \ n)\n      '0\n      (append (string_sequence (sub1 n))\n              (list\
    \ number->string n))))\n", "  (if (< n 0)\n      '()\n      (cons (- n (string-sequence-length\
    \ n)) (string_sequence (- n 1)))))\n", "  (make-string (sub (* n 10) 10) (+ n\
    \ 10) 0))\n</code>\n<|/ a dscore=0 tags=string,racket,list,lisp |>\n<| c |>\n\
    Please add some explanation as well. Just posting code is not very helpful.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a very simple solution using the string package:\n\
    <code>\n#lang racket\n", "  (let loop ((s '') (i 0))\n    (if (< i n)\n      \
    \  (loop (append s (number->string i))\n               (+ i 1))\n        (reverse\
    \ s))))\n", "  (if (<= n 0)\n      '()\n      (append (string_sequence (sub1 n))\
    \ (list n))))\n", "  (if (= n 0)\n      '()\n      (cons (number->string n) (string_sequence\
    \ (sub1 n))))))\n", "  (cond\n    ((= n 0) '0)\n    ((< n 0) 'nil)\n    (else\
    \ (append (string_sequence (sub1 n)) (list n))))\n", "  (if (or (zero? n) (negative?\
    \ n))\n      '()\n      (append (map string-sequence (range n)) (if (even? n)\
    \ (concat \" \" (string-sequence (sub1 n)))))))\n", "  (list n))\n", "  (make-string-builder\n\
    \   (string->list\n    (lambda ()\n     (for ([x n])\n      (number->string x)))))\n",
  "  (let loop ([n n]\n             [n 0])\n    (cond [(= n 0) (list '0)]\n      \
    \    [(= n 1) (list '1)]\n          [(< n 1) (loop (- n 1) (cons (- n 1) n))]\n\
    \          [else (loop (- n 1) (cons (- n 1) n) (+ n 1))])))\n", "  (let ([s (make-string)]\n\
    \        [result (make-string)])\n    (if (< n 0)\n        (string-append s result)\n\
    \        (begin (append (list-ref s 0) (list n)) (append result (substring s 0\
    \ (+ n 1))))))))\n", "  (if (< n 0)\n      '()\n      (append (string_sequence\
    \ (sub1 n))\n              (list n))))\n", "  (define (concat s1 s2)\n    (if\
    \ (= n 0)\n        s1\n        (concat s1 (string-append \" \" s2))))\n  (concat\
    \ \"0\" (reverse (take-while #(not (= 0 (modulo n 5))) (range))))\n)\n", "  (let\
    \ loop ((result '')\n             (n n))\n    (if (= n 0)\n        result\n  \
    \      (loop (append result (number n))\n               (sub1 n))))))\n", "  (let\
    \ loop ((i 0)\n             (s \"\")\n             (acc \"\") (cur (+ i 1)))\n\
    \    (if (< i n)\n        (cond ((= i n) s)\n              ((string? (car cur))\
    \ (loop (+ i 1) s (car cur) (+ i 1)))\n              (else (loop (+ i 1) (+ acc\
    \ i) cur (+ i 1))))\n        (cond ((string? acc) (loop (+ i 1) (+ acc i) \"\"\
    \ (+ i 1)))\n              ((string? (car cur)) (loop (+ i 1) s (car cur) \"\"\
    \ (+ i 1)))\n              (else (loop (+ i 1) \"\" (+ acc i) cur (+ i 1))))))\n",
  "  (if (< n 0)\n      '()\n      (append (string_sequence (sub1 n))\n          \
    \    (list n))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
