name: HumanEval_63_fibfib
language: rkt
prompt: "#lang racket\n\n;; The FibFib number sequence is a sequence similar to the\
  \ Fibbonacci sequnece that's defined as follows:\n;; fibfib(0) == 0\n;; fibfib(1)\
  \ == 0\n;; fibfib(2) == 1\n;; fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
  ;; Please write a function to efficiently compute the n-th element of the fibfib\
  \ number sequence.\n;; >>> fibfib(1)\n;; 0\n;; >>> fibfib(5)\n;; 4\n;; >>> fibfib(8)\n\
  ;; 24\n(define (fibfib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n\
  \    (check-equal? (candidate 2) 1)\n    (check-equal? (candidate 1) 0)\n    (check-equal?\
  \ (candidate 5) 4)\n    (check-equal? (candidate 8) 24)\n    (check-equal? (candidate\
  \ 10) 81)\n    (check-equal? (candidate 12) 274)\n    (check-equal? (candidate 14)\
  \ 927)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))))\n", "  (cond [(zero? n) 0]\n        [(one? n) 0]\n     \
    \   [else (+ (fibfib (sub1 n)) (fibfib (sub2 n)))]))\n\n#lang racket\n", "  (cond\
    \ [(= n 0)      0]\n        [(= n 1)      1]\n        [(= n 2)      1]\n     \
    \   [else         (+ (fibfib (- n 1)) (fibfib (- n 2))) (fibfib (- n 3))]))\n",
  "  (define (fib x y) (if (= y 0) x y))\n  (fib (if (= n 0) 0 (fib (+ x 1) (fib (+\
    \ x y) n))) (fib (+ x y) 0)))\n", "  (if (< n 2)\n      0\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n  \
    \      [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))]))\n", "  (cond\n    [(= n 0)  0]\n    [(= n 1)  1]\n    [(= n 2)\
    \  1]\n    [else      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond [(= n 0)\n         0]\n        [(= n 1)\n         1]\n        [(= n 2)\n\
    \         1]\n        [else\n         (+ (fibfib (- n 1))\n            (fibfib\
    \ (- n 2))\n            (fibfib (- n 3))))))\n", "  ;; Base cases: if fibfib =\
    \ 0 or fibfib(1) = 0 return 0.\n  (cond\n    ;; if fibfib(0) is 0, fibfib(1) =\
    \ 0, else fibfib(1) = fibfib(0)\n    ((= n 0) 0)\n    ;; if fibfib is 1, fibfib(1)\
    \ = 0, else fibfib(1) = fibfib(1)\n    ((= n 1) 0)\n    ;; else fibfib(n) = fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n    ((= n 2) 1)\n    ;; else fibfib(n) = fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n    ((= n 3) (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))))\n)\n", "  (if (= n 1)\n      0\n      (+ (fibfib (sub1 n))\
    \ (fibfib (sub1 n)) (fibfib (sub1 n))))))\n", "  (cond [(= n 0) 0]\n        [(=\
    \ n 1) 0]\n        [else (+ (fibfib (sub1 n)) (fibfib (sub2 n)))]))\n", "  (if\
    \ (= n 0) 0\n      (+ (fibfib (sub1 n)) (fibfib (sub2 n)))))\n", "  (cond [(=\
    \ n 0)\n         0]\n        [(= n 1)\n         1]\n        [(= n 2)\n       \
    \  1]\n        [else\n         (+ (fibfib (- n 1)) \n            (fibfib (- n\
    \ 2)) \n            (fibfib (- n 3)))]))\n", "  (cond\n    ((= n 0) 0)\n    ((=\
    \ n 1) 0)\n    ((= n 2) 1)\n    (else (+ (fibfib (- n 2)) (fibfib (- n 1)) (fibfib\
    \ n))))) \n", "  (cond [(< n 0)\n         (error 'fibfib: negative number)\n \
    \        0]\n        [(< n 1)\n         (cons 0 '())]\n        [else\n       \
    \  (let ([a (fibfib (- n 1))\n                b (fibfib (- n 2))\n           \
    \     c (fibfib (- n 3))])\n           (cons (+ a (+ b (+ c 0))) '()))]))\n",
  "  (if (< n 0) \n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n</code>\n\
    <|/ q |>\n<| c |>\nPlease edit your question and add code instead of screenshots.\
    \  Screenshots are hard to read and impossible to copy/paste.  Thanks!\n<|/ c\
    \ |>\n<| c |>\nYour problem is \"What are the rules for my code to find the sum\
    \ of the first 10 fibonacci numbers up to N?\" It is not \"What is the formula\
    \ for computing the sum of N fibonacci numbers\".  (Hint: it's not even a \"formula\"\
    \ in a classical sense.  It's a sequence of expressions that you have to evaluate.)\
    \  You have to write code that evaluates the sequence (a procedure) and then sums\
    \ the ten elements of the sequence.\n<|/ c |>\n<| c |>\nIf you don't want the\
    \ answers to your problem, then the question is not suitable for Stack Overflow,\
    \ but for [**Code Review**](http://codereview.stackexchange.com).\n<|/ c |>\n\
    <| c |>\nI have already written the code for computing the sum of N fibonacci\
    \ numbers but it gives me the wrong numbers. I'm confused on how to compute all\
    \ the numbers in the sequence. I could use some help on how to get the sequence\
    \ and add all those numbers up. Thanks so much for the help!\n<|/ c |>\n<| c |>\n\
    Thanks for your help I really appreciate it.\n<|/ c |>\n<| a tags=fibonacci,racket,scheme\
    \ |>\nThe reason that your code doesn't work is that your recursion doesn't work.\
    \  It recurses down to fib(10) and then fib(9) and you end up with a big mess\
    \ of numbers.  You need to break this up into two steps:\nCompute the Fibonacci\
    \ sequence up to a certain number n\nSum the first n elements of the Fibonacci\
    \ sequence\nHere's a working version of your code:\n<code>", "  (if (= n 0) 0\n\
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (cond\n    ((= n 0) 0)\n\
    \    ((= n 1) 0)\n    (else (+ (fibfib (- n 1)) (fibfib (- n 2))))))\n", "  (cond\
    \ [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)))]))\n", "  (if (< n 2)\n      0\n      (+ (fibfib (- n 2)) (fibfib\
    \ (- n 3)))))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= n 2) 1)\n\
    \    (else (+ (fibfib (- n 2)) (fibfib (- n 1)) (fibfib (- n 3))))))\n", "  (let\
    \ ([f (lambda (x) (if (<= n 2) 0 1))])\n    (lambda (n)\n      (if (<= n 0)\n\
    \          0\n          (f (+ (f (f (- n 1))) (f (- n 2)))\n            )\n  \
    \      )\n    )\n  )\n)\n</cell>\n<cell>\n#lang racket\n", "  ;; Return fibonacci\
    \ number. \n  ;; If n is 0, return 0\n  ;; If n is 1, return 0\n  ;; If n is 2,\
    \ return 1.\n  (if (= n 0) 0 (if (= n 1) 1 (+ (fibfib (- n 2)) (fibfib (- n 1))))))\n",
  "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= n 2) 1)\n    (else\n     (+\
    \ (fibfib (sub1 n)) (fibfib (sub2 n)) (fibfib (sub3 n)))))\n  )\n)\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=scheme,racket,fibonacci,computer-science |>\n<code>",
  "  (if (= n 1)\n      0\n      (+ (fibfib (- n 1)) \n         (fibfib (- n 2))\n\
    \         (fibfib (- n 3)))))\n", "  (fibbonaci n (lambda (x) (fibfib (- n 1)))\
    \ (lambda (x) (fibfib (- n 2)))))\n", "  (if (= n 0)\n      0\n      (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)))))\n", "  (if (= n 1)\n      0\n      (+ (fibfib (-\
    \ n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n</code>\n<|/\
    \ a dscore=2 tags=scheme,racket,fibonacci,recursion |>\n<| c |>\nWhile this link\
    \ may answer the question, it is better to include the essential parts of the\
    \ answer here and provide the link for reference.  Link-only answers can become\
    \ invalid if the linked page changes. - [From Review](/review/low-quality-posts/26832397)\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  (if (zero? n)\n      0\n      (+ (fibfib\
    \ (sub1 n)) (fibfib (sub2 n)) (fibfib (sub3 n))))))", "  (if (< n 2)\n      0\n\
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (< n 2) 0 \n      (+\
    \ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 2)) (fibfib (- n 1))) (fibfib (- n 2))]))\n", "  (define (fib x y)\n  \
    \  (cond\n      [(= y 0) x]\n      [(< y 1) (fib (+ x y) ((- x y) (- x y))) ])\n\
    \  (fib 0 1))\n  )\n  ", "  (if (< n 2) 0\n      (+ (fibfib (- n 1)) (fibfib (-\
    \ n 2)))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        (else (+ (fibfib\
    \ (sub1 n))\n                  (fibfib (sub2 n))\n                  (fibfib (sub3\
    \ n))))))\n", "  (if (= n 0) 0\n      (+ (fibfib (- n 1))\n         (fibfib (-\
    \ n 2))\n         (fibfib (- n 3)))))\n", "  (if (= n 0) 0\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2))\n           (fibfib (- n 3)))))\n", "  (if (<= n 2)\n\
    \      0\n      (+ (fibfib (- n 1)) \n         (fibfib (- n 2))\n         (fibfib\
    \ (- n 3)))))\n</code>\n<|/ a |>\n<| a tags=scheme,racket,functional-programming,lisp\
    \ |>\nHere is a short solution, if you have the library \"racket/base\" installed:\n\
    <code>", "  (cond\n    [(< n 0) 0]\n    [(= n 1) 1]\n    [else (+ fibfib (- n)\
    \ (fibfib (- n 2))))))\n", "  (if (= n 1)\n      0\n      (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)))))\n", "  (define fibfib (lambda (i) (if (= i n) i \n     \
    \                                (fibfib (sub1 i) (+ (fibfib (sub1 i)) \n    \
    \                                                              (fibfib (sub2 i)))))))\n\
    \  (fibfib (sub1 n)))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((=\
    \ n 2) 1)\n        (else (+ (fibfib (- n 2)) (fibfib (- n 1)) (fibfib (- n 0))))))\n",
  "  (if (zero? n)\n      0\n      (+ (fibfib (- n 1)) \n         (fibfib (- n 2))\
    \ \n         (fibfib (- n 3)))))\n", "  (define (aux i m)\n    (cond\n      [(=\
    \ i 0) m]\n      [(= i n) (aux n (+ m m m))]\n      [else (aux (- i 1) (+ m m\
    \ m))]))\n  (aux n (+ m m m)))\n", "  (if (= n 0)\n      0\n      (+ n (fibfib\
    \ (- n 1)))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks. I like your solution and it seems\
    \ that this isn't quite as fast as what I've been trying.\n<|/ c |>\n<| a |>\n\
    I realized that the problem is actually not too bad. Here is my solution using\
    \ tail recursion. I would welcome any improvements/suggestions.\n<code>", "  (if\
    \ (< n 0) 0\n      (if (< n 1) 1\n          (+ (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  ;; Your code here\n)\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(=\
    \ n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n\
    </code>\n<|/ a dscore=0 tags=racket,scheme,factorial |>\n<| c |>\nThanks for the\
    \ response. I tried your solution, and it still produces a \"The function definition\
    \ requires a body\".\n<|/ c |>\n<| c |>\nYour solution does not produce the correct\
    \ result for n=9 (it gives 25, but it should give 4).\n<|/ c |>\n<| a |>\nThis\
    \ is a more efficient solution, which is both simpler and more efficient in the\
    \ sense that it avoids the recursive call overhead.\n<code>", "  (cond\n    ((=\
    \ n 0)\n     0)\n    ((= n 1)\n     0)\n    (else\n     (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (let ((fibfibs (make-fibfibs n)))\n   \
    \ (loop :for i :from 0 :to n\n          :collect (fibfibs i) into result)\n  \
    \  (first result)))", "  (if (> n 0)\n      (+ (fibfib (- n 1))\n         (fibfib\
    \ (- n 2))\n         (fibfib (- n 3)))))\n", "  (if (zero? n)\n      0\n     \
    \ (+ (fibfib (sub1 n)) (fibfib (sub2 n))))\n  )\n", "  (cond [(= n 0)  0]\n  \
    \      [(= n 1) 1]\n        [(= n 2)  1]\n        [else  (+ (fibfib (- n 1)) \n\
    \                 (fibfib (- n 2)) \n                 (fibfib (- n 3))))]))\n",
  "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (sub1\
    \ n)) (fibfib (sub1 n)) (fibfib (sub1 n)))]))\n", "  (if (= n 1)\n      0\n  \
    \    (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (zero? n)\n      0\n \
    \     (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n",
  "  (let ([a (fibfib (- n 1))]\n        [b (fibfib (- n 2))]\n        [c (fibfib\
    \ (- n 3))])\n    (+ (car a)\n       (if (> n 3)\n           (+ (car (cdr a))\n\
    \               (+ (car (cdr (cdr a)))\n                   (+ (car (cdr (cdr (cdr\
    \ a))))\n                      (car (cdr (cdr (cdr (cdr a)))))))))\n    (if (>\
    \ n 3)\n        (+ (car (cdr a))\n           (+ (car (cdr (cdr a)))\n        \
    \       (+ (car (cdr (cdr (cdr (cdr a))))\n                      (car (cdr (cdr\
    \ (cdr (cdr (cdr a))))))))\n        (car a))))\n", "  (if (= n 0)\n      0\n \
    \     (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n</code></pre>\n<p>\n\t\t\t\t\t\
    </details>\n\t\t\t\t</section>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"col-4\
    \ col-menu menu-sticky-wrap menu-highlight\">\n\t\t\t<nav class=\"tsd-navigation\
    \ primary\">\n\t\t\t\t<ul>\n\t\t\t\t\t<li class=\"globals  \">\n\t\t\t\t\t\t<a\
    \ href=\"globals.html\"><em>Globals</em></a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li class=\"\
    \ tsd-kind-external-module\">\n\t\t\t\t\t\t<a href=\"modules/_coq_library_8cs.html\"\
    >Coq.Library</a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li class=\" tsd-kind-external-module\"\
    >\n\t\t\t\t\t\t<a href=\"modules/_coq_primitives_8cs.html\">Coq.Primitives</a>\n\
    \t\t\t\t\t</li>\n\t\t\t\t\t<li class=\" tsd-kind-external-module\">\n\t\t\t\t\t\
    \t<a href=\"modules/_n_e_fixed_8cs.html\">N.E.Fixed</a>\n\t\t\t\t\t</li>\n\t\t\
    \t\t\t<li class=\" tsd-kind-external-module\">\n\t\t\t\t\t\t<a href=\"modules/_n_e_u_a_fixed_8cs.html\"\
    >N.E.U.A.Fixed</a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li class=\" tsd-kind-external-module\"\
    >\n\t\t\t\t\t\t<a href=\"modules/_n_e_fixed_8cs_opencv_wrapper.html\">N.E.Fixed.opencv</a>\n\
    \t\t\t\t\t</li>\n\t\t\t\t\t<li class=\" tsd-kind-external-module\">\n\t\t\t\t\t\
    \t<a href=\"modules/_n_e_u_a_fixed_8cs_opencv_wrapper.html\">N.E.U.A.Fixed.opencv</a>\n\
    \t\t\t\t\t</li>\n\t\t\t\t\t<li class=\"current tsd-kind-external-module\">\n\t\
    \t\t\t\t\t<a href=\"modules/_n_e_g_e_m_m_8cs.html\">N.E.G.E.M.M.8cs</a>\n\t\t\t\
    \t\t\t<ul>\n\t\t\t\t\t\t\t<li class=\"current tsd-kind-module tsd-parent-kind-external-module\"\
    >\n\t\t\t\t\t\t\t\t<a href=\"modules/_n_e_g_e_m_m_8cs.html#api\" class=\"tsd-kind-icon\"\
    >API</a>\n\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t<li class=\" tsd-kind-function\
    \ tsd-parent-kind-external-module tsd-has-type-parameter\">\n\t\t\t\t\t\t\t\t\t\
    \t<a href=\"modules/_n_e_g_e_m_m_8cs.html#buildfibintegral\" class=\"tsd-kind-icon\"\
    >build<wbr>Fibintegral</a>\n\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t</ul>\n\t\
    \t\t\t\t\t\t</li>\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li class=\"\
    \ tsd-kind-external-module\">\n\t\t\t\t\t\t<a href=\"modules/_n_e_g_e_m_m_lowp_8cs.html\"\
    >N.E.G.E.M.M.Lowp</a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li class=\" tsd-kind-external-module\"\
    >\n\t\t\t\t\t\t<a href=\"modules/_n_e_image_8cs.html\">N.E.Image", '  (fib 0 1
    2 3 4 5 6 7 8 9))', "  (if (= n 0)\n      0\n      (+ n (fibfib (- n 1)))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1))\n            (fibfib (- n 2))\n            (fibfib (- n 3)))]))\n",
  "  (cond\n    [(< n 1)\n     0]\n    [(= n 2)\n     1]\n    [else\n     (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2))(fibfib (- n 3)))]))\n", "  (if (= n 0)\n      0\n\
    \      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n",
  "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (fibfib (sub1 n))\n         (fibfib (sub1 n))\n \
    \        (fibfib (sub1 n))))) \n", "  (cond [(zero? n) 0]\n        [(even? n)\
    \ (+ (fibfib (sub1 n)) (fibfib (sub2 n)))]\n        [else (fibfib (sub1 n)) (fibfib\
    \ (sub2 n)) (fibfib (sub3 n))]))\n", "  (if (= n 0)\n      0\n      (+ (fibfib\
    \ (sub1 n)) (fibfib (sub1 n-1)))))\n", "  (if (< n 2)\n      0\n      (+ 1 (+\
    \ (fibfib (- n 1)) (fibfib (- n 2))))))\n", "  (cond\n    [(= n 0) 0]\n    [(=\
    \ n 1) 1]\n    [(= n 2) 2]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))) ]))\n", "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1))\n     \
    \    (fibfib (- n 2))\n         (fibfib (- n 3)))))\n", "  (if (<= n 0)\n    \
    \  0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\
    \ ((= n 0) 0)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2))\n          \
    \           (fibfib (- n 3))))))\n</code>\n<|/ a dscore=0 tags=racket,scheme |>\n\
    <| a dscore=0 tags=racket,scheme |>\n<code>", "  (if (= n 0)\n      0\n      (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond [(= n 0)\
    \ 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n\
    \ 2)) (fibfib (- n 1))) (fibfib (- n 3))]))\n", "  (cond [(= n 1) (constant)]\
    \ [(= n 2) 1] [else (+ (fibfib (- n 1)) ((fibfib (- n 2)) 1)))]))\n", "  (define\
    \ (fibfib-helper n a b c)\n    (if (= n 0)\n        a\n        (fibfib-helper\
    \ (- n 1) b (+ b c) c)))\n  (fibfib-helper n 0 1 1))\n", "  (cond [(zero? n) 0]\n\
    \        [(odd? n) (+ (fibfib (- n 1)) (- (fibfib (- n 2)) 0))]\n        [else\
    \ (+ (fibfib (- n 3)) (- (fibfib (- n 2)) 0))]))\n", "  (if (= n 0)\n      0\n\
    \      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (sub1 n)) (fibfib (sub2 n)) (fibfib (sub3 n))))))\n", "  (cond [(= n\
    \ 0)      0]\n        [(= n 1)      0]\n        [(= n 2)      1]\n        [(=\
    \ n 3)      1]\n        [else\n         (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))]))\n\n#lang racket\n", "  (define (fib n)\n    (if (< n 3)\n    \
    \    (* n (fib (- n 2)))\n        (+ (fib (- n 1)) (fib (- n 2)) (fib (- n 3)))))\n\
    \  (fib n))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [(= n 3) (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]\n  \
    \      [else (+ (fibfib (- n 2)) (fibfib (- n 3)) (fibfib (- n 1)))]))\n", " \
    \ (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1))\n                    (fibfib (- n 2))\n   \
    \                 (fibfib (- n 3))))]))\n", "  (if (>= n 0)\n      (+ (fibfib\
    \ (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n", "  (if\
    \ (< n 3) \n      (- 1)\n      (- \n       (+ (fibfib (- n 1)) (fibfib (- n 2)))\
    \ (fibfib (- n 3)))))\n", "  (cond [(< n 0)\n         0]\n        [(= n 1)\n \
    \        0]\n        [else\n         (+ (fibfib (- n 1)) (fibfib (- n 2)))]))\n",
  "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n\
    \         (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 2)) (fibfib (- n 1))) (fibfib n)]))\n",
  "  (cond\n    [(<= n 0) 0]\n    [(= n 1) 0]\n    [else (+ fibfib (- n 2))]))\n",
  "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= n 2) 1)\n    ((= (fibfib (-\
    \ n 3)) (+ n 2)) (+ n 3))\n    (else (+ n ((fibfib (- n 2)) (fibfib (- n 1)))))))\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (sub1 n)) (fibfib (sub1 n))\n                   (fibfib (sub1 n))))))\
    \ ;; (fibfib (sub1 n)) (#lang racket)\n", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 2)) (fibfib (- n 3)) (fibfib\
    \ (- n 4))))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 1]\n        [(= n 3) (fibfib (sub1 n)) (fibfib (sub2 n)) (fibfib (sub3 n))]))\n",
  "  (if (<= n 0)\n      (error \"fibfib: n must be positive\")\n      (let ([f (lambda\
    \ (n) (lambda (n) (lambda (n) (lambda (n) (lambda (n) (lambda (n) (lambda (n)\
    \ (lambda (n) (lambda (n) 0)))) (lambda (n) (lambda (n) (lambda (n) (lambda (n)\
    \ (lambda (n) (lambda (n) (lambda (n) (lambda (n) 1))) (lambda (n) (lambda (n)\
    \ (lambda (n) (lambda (n) (lambda (n) (lambda (n) (lambda (n) 2))) (lambda (n)\
    \ (lambda (n) (lambda (n) (lambda (n) (lambda (n) (lambda (n) 3))) (lambda (n)\
    \ (lambda (n) (lambda (n) (lambda (n) (lambda (n) 4))) (lambda (n) (lambda (n)\
    \ (lambda (n) (lambda (n) 5))) (lambda (n) (lambda (n) (lambda (n) 6))) (lambda\
    \ (n) (lambda (n) 7))) (lambda (n) 8)))))))))))))))))))))))))", "  (if (<= n 0)\n\
    \      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (= n 0)\n \
    \     0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib\
    \ (- n 3)))))\n", "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1))\n       \
    \  (fibfib (- n 2))\n         (fibfib (- n 3)))))\n", "  (if (= n 0)\n      0\n\
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (let ((fibfib-table (make-array\
    \ (+ n 3) #:element-type 'int)))\n    (if (= n 0)\n        0\n        (set! fibfib-table\
    \ (make-array (+ n 3) #:element-type 'int))\n        (set! fibfib-table (+ fibfib-table\
    \ (make-array 3 #:element-type 'int))))\n    fibfib-table))\n", "  (if (= n 1)\n\
    \      0\n      (+ (fibfib (- n 1)) (n + fibfib (- n 2)))))\n", "  (cond\n   \
    \ [(< n 0) (error \"The argument to fibfib is out of range!\")]\n    [(< n 2)\
    \ 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (let loop ((i 0)\n             (fib (\u03BB (x) x))\n             (result 0))\n\
    \    (if (< i n)\n        result\n        (loop (+ i 1) (+ fib (\u03BB (x) x))\
    \ (+ result fib)))\n    (\u03BB () result)))\n", "  (cond [(= n 0) 0]\n      \
    \  [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))]))\n", "  (cond\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))]))\n", "  (cond\
    \ [(zero? n) 0]\n        [(= n 1) 1]\n        [(= n 2) 1]\n        [else\n   \
    \      (+ (fibfib (- n 2)) (fibfib (- n 1))) (fibfib n)]\n))\n", "  (cond\n  \
    \  [(<= n 0)\n      0]\n    [(= n 1)\n      1]\n    [else (+ (fibfib (- n 1))\
    \ (fibfib (- n 2))) (fibfib (- n 3))]))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2))))\n        ))\n",
  "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n\
    \         (fibfib (- n 3)))))\n", "  (cond [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ fibfib (- n 1) (- n 2) (- n 3))]))\n", "  (cond ((= n 0) 0)\n\
    \        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) \n\
    \                  (fibfib (- n 2)) \n                  (fibfib (- n 3))))))\n",
  "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) ((fibfib (- n 2)) ((fibfib (-\
    \ n 3)) (+ (fibfib (- n 4)) (fibfib (- n 5)))))))) ;; #lang racket\n</code>\n\
    I ran your program through DrRacket and got a stack overflow error:\n<code>\n\
    fibfib: out of stack space (infinite loop?)\n</code>\nThe issue is that your function\
    \ has very deep recursion. Consider fibfib(1). The function calls itself with\
    \ fibfib(0). The function calls itself with fibfib(-1). Since fibfib(0) = 0 and\
    \ fibfib(-1) = fibfib(0), the function calls itself with fibfib(1). Since the\
    \ function calls itself with fibfib(0), fibfib(1) = fibfib(0). Since the function\
    \ calls itself with fibfib(1), fibfib(1) = fibfib(0). Since the function calls\
    \ itself with fibfib(2), fibfib(1) = fibfib(1). Since the function calls itself\
    \ with fibfib(3), fibfib(1) = fibfib(2). Since the function calls itself with\
    \ fibfib(4), fibfib(1) = fibfib(3). Since the function calls itself with fibfib(5),\
    \ fibfib(1) = fibfib(4).\nIt's not clear what the intended result was supposed\
    \ to be, but your function doesn't correctly compute fibfib(0). I'm not sure what\
    \ the intent was, but perhaps you're looking for this solution:\n<code>", "  (let\
    \ ([a 0])\n    (if (= n 0)\n        a\n        (fibfib (- n 1))\n        (+ a\
    \ (foldl + a (- n 1) (- n 2) (- n 3))))))\n", "  (define (fibfib-helper n result\
    \ accum n)\n    (cond\n      [(= n 0) result]\n      [(= n 1) (+ accum result)]\n\
    \      [(= n 2) (fibfib-helper (- n 1) result (+ accum result) n)]\n      [else\n\
    \       (fibfib-helper (- n 1) (+ accum result) (+ accum result) (- n 1))]\n \
    \   ))\n  (fibfib-helper n 0 0 n))\n", "  (fib-fib (- n 1) (- n 2) (- n 3)))\n",
  "  (define (helper index acc stack)\n    (cond ((= index n) (stack acc))\n     \
    \     ((< index n) (helper (+ index 1) (cons index (cdr acc)) stack))\n      \
    \    (else (helper (+ index 1) (cons index (cdr acc)) (cons index stack))))\n\
    \  (helper 0 '() (list 0)))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n \
    \   ((= n 2) 1)\n    (else (+ (fibfib (- n 2)) (fibfib (- n 1)) (fibfib (- n 3))))))\n",
  "  (define (go n a)\n    (if (= n 0)\n        a\n        (go (- n 1) (+ a (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2))))))))\n  (go n 0))\n", "  (if (zero? n)\n      0\n\
    \      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))",
  "  (if (= n 0)\n      0\n      (+ (fibfib (sub1 n)) (fibfib (sub2 n))))) ;; #lang\
    \ racket", "  (cond ((= n 0)0)\n        ((= n 1)0)\n        ((= n 2)1)\n     \
    \   (else (+ (fibfib (- n 1)) (fibfib (- n 2))(fibfib (- n 3))))))\n", "  (if\
    \ (< n 1)\n      0\n      (+ (fibfib (- n 2)) (* (fibfib (- n 1)) n))))", "  (if\
    \ (= n 0)\n      0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n   \
    \      (fibfib (- n 3)))))\n", "  (if (= n 0) 0\n      (+ (fibfib (- n 1))\n \
    \        (fibfib (- n 2))\n         (fibfib (- n 3)))))\n\n#lang racket\n", " \
    \ (define (fibfib-helper a b c)\n    (cond ((= n 0) 0)\n          ((= n 1) 0)\n\
    \          ((= n 2) c)\n          ((fibfib-helper (- n 1) (+ b a) c))\n      \
    \    (else (fibfib-helper (+ b a) b (+ a c)))))\n  (fibfib-helper 0 1 1))\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 2)) (fibfib (- n 1)) (fibfib (- n 3))))))\n", "  (if (= n 0)\n\
    \      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (< n 2) 0\n\
    \      (+ (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (let loop ((i 0) (fib (if\
    \ (<= i n) 0 (+ (fibfib (- i 1)) (fibfib (- i 2))))))\n    (if (< i n) fib 0)))\n",
  "  (cond\n    ((= n 1) 0)\n    ((= n 2) 1)\n    ((= n 0) (fibfib n-1))\n    (else\
    \ (fibfib (- n 1)) (+ fibfib (- n 2)) (+ fibfib (- n 3)))))\n", "  (if (= n 0)\n\
    \      0\n      (+ (fibfib (sub1 n)) (fibfib (sub2 n)))))\n</cell>\n<cell>", " \
    \ (if (= n 0)\n      0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n\
    \         (fibfib (- n 3)))))", "  (if (= n 0)\n      0\n      (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (define (helper n result)\n\
    \    (if (= n 0)\n        result\n        (helper (- n 1) (+ result (- n 2)))))\n\
    \  (helper n 0))\n", "  (cond\n    [(<= 0 n)\n     (error \"fibfib: n must be\
    \ a positive number\")\n     (else (+ 0 (* 2 (fibfib n)))]\n    [else\n     (+\
    \ 0 (* 2 (fibfib (- n 1))) (* 2 (fibfib (- n 2))))]\n  )\n)", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (let ([a (fibfib\
    \ (sub1 n))\n           (b (fibfib (sub1 n)))\n           (c (fibfib (sub1 n)))]\n\
    \       (+ a b c)))]))\n", "  (if (<= n 1)\n      0\n      (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)))))\n", "  (define (helper n acc)\n    (if (zero? n) (helper\
    \ 1 (+ acc (- n (length acc)))))\n    (helper (- n 1) (+ acc (- n (length acc)))))\n\
    \  (helper n 0))\n", "  (define (fib x) (if (= x 0) 0 (+ (fib (- x 1)) x)))\n\
    \  (if (< n 0)\n      '()\n      (cons (fib (- n 1))\n            (fib n))))\n",
  "  (cond [(< n 2) 0]\n        [(eq? (car n) 0) 0]\n        [(eq? (car n) 1) 1]\n\
    \        [else (+ (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond [(= n 1)\
    \ 0]\n        [(= n 2) 1]\n        [(= n 3) (+ (fibfib (- n 1)) (fibfib (- n 2)))]\n\
    \        [else       (+ (fibfib (- n 3)) (fibfib (- n 2)))]))\n</code>\nTo speed\
    \ up recursion, I defined a helper function which takes the previous number and\
    \ the current number:\n<code>", "  ;; Base case\n  (if (zero? n)\n      0\n  \
    \    ;; Recursion case\n      (+ (fibfib (sub1 n))\n         (fibfib (sub2 n))\n\
    \         (fibfib (sub3 n)))))\n</code>\n<|/ a dscore=4 |>\n<| a dscore=2 tags=fibonacci,racket,scheme\
    \ |>\nThis is an alternative solution using a recursive procedure. \n<code>",
  "  (cond [(< n 0) 0]\n        [(= n 0) 0]\n        [(= n 1) 1]\n        [else (+\
    \ (fibfib (- n 1)) \n                  (fibfib (- n 2)) \n                  (fibfib\
    \ (- n 3))))]))\n</code>\n<|/ a dscore=4 |>\n<| c |>\nYour answer helped me a\
    \ lot. Though I am not able to understand the recursion part completely. I would\
    \ like to understand this in a detailed manner like how it works and how it works.\
    \ Can you please help me?\n<|/ c |>\n<| c |>\n, It will take me a day or so to\
    \ explain every line of the recursion.  But for now, please take a look at the\
    \ last function `fibfib`.  It calls `fibfib` and it calls itself three times.\
    \  Each time it subtracts 3 from `n`.\n<|/ c |>\n<| c |>\nThanks for your reply.\
    \ Just one last question, what is the purpose of using an extra `cond`? And where\
    \ does this extra `cond` come from in your solution? Also, why are you using `cond`\
    \ instead of `if`? Isn't it just because `cond` takes only three expressions?\
    \ Please help me understand.\n<|/ c |>\n<| c |>\n`cond` is like an `if` statement\
    \ but it doesn't stop.  `cond` can have multiple clauses.  Each clause will be\
    \ evaluated until one of the clauses is true.  `cond` doesn't have to be `if`\
    \ statement.  It can be any expression that evaluates to a boolean.\n<|/ c |>\n\
    <| a dscore=4 |>\nA quick way to understand the recursion is to use a dry run\
    \ - dry run meaning dry run, don't run anything yet.  In that way, you get a visual\
    \ representation of the process (and you can run it by hand to make sure you understand\
    \ how it works).\nIn this case we want to find the n-th Fibonacci number:\n<code>",
  "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) \n                  (fibfib (- n 2)) \n                  (fibfib\
    \ (- n 3))))]))", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        ((< n 3) (+ (fibfib (- n 2)) (fibfib (- n 1))))\n        (else (fibfib\
    \ (- n 3)) (+ fibfib (- n 2)) (+ fibfib (- n 1)))))\n", "  (if (= n 0)\n     \
    \ 0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (cond\n    [(< n 0)\
    \ 0]\n    [(= n 1) 1]\n    [else (+ (fibfib (- n 1)) \n            (fibfib (-\
    \ n 2)))]\n  )\n)\n", "  (cond\n    ((= n 1) 0)\n    ((= n 2) 1)\n    (else (+\
    \ (fibfib (- n 2)) (fibfib (- n 1))))))\n", "  (if (= n 0)\n      0\n      (+\
    \ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n",
  "  (nth (build-list n #f)\n       (\u03BB (e)\n         (+ (car e)\n           \
    \ (+ (car e)\n              (+ (cdr e)\n                 (car e))))))))", "  (if\
    \ (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n",
  "  (define (fibfib-helper n a b c d)\n    (if (= n 0) a\n      (fibfib-helper (-\
    \ n 1) a b (+ c d) (+ a b))\n    )\n  )\n  (fibfib-helper n 0 1 1 0))\n", "  (cond\n\
    \    [(zero? n) 0]\n    [(equal? (fibfib (- n 1)) (fibfib (- n 2)))\n     (+ fibfib\
    \ (fibfib (- n 3)))]\n    [else (fibfib (- n 1)) + (fibfib (fibfib (- n 2))) +\
    \ (fibfib (fibfib (- n 3)))]\n    )\n  )\n  )\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 tags=fibonacci,scheme |>\n<code>", "  (if (= n 0)\n      0\n    \
    \  (+ (fibfib (- n 1)) (* (fibfib (- n 2)) n))))\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThis does not give the correct answer for n=100 for example the answer\
    \ should be 83200, your code returns 832060.\n<|/ c |>\n<| c |>\nthank you for\
    \ your observation. I have updated the code. Now it works correctly.\n<|/ c |>\n\
    <| c |>\nI added a more efficient solution in the [answer](https://stackoverflow.com/a/66398488/6879826)\n\
    <|/ c |>\n<| a dscore=3 |>\nThe naive recursive implementation is O(n\xB2). The\
    \ iterative version can be done in O(n log n). Here's one way in Scheme:\n<code>",
  "  (define (fibfib-helper n result)\n    (if (= n 0)\n        result\n        (fibfib-helper\
    \ (- n 1) (+ result (- n 1)))))\n  (fibfib-helper n 0))\n", "  (if (= n 0)\n \
    \     0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (define (helper\
    \ i accum)\n    (cond\n      [(= i n) accum]\n      [(< i n) (helper (- i 1) (+\
    \ accum i))]))\n  (helper 0 0))\n", "  (cond [(= n 0)\n         0]\n        [(=\
    \ n 1)\n         0]\n        [(= n 2)\n         1]\n        [else\n         (+\
    \ (fibfib (- n 1))\n            (fibfib (- n 2))\n            (fibfib (- n 3)))]))\n",
  "  ;; Use a loop to compute the nth Fibbonacci number in the Fibbonacci sequence\n\
    \  (define (fibfib-helper n result)\n    (if (= n 0)\n        0\n        (fibfib-helper\
    \ (sub1 n) (+ result (fib n)))\n      )\n  )\n  (fibfib-helper n 0)\n)\n", " \
    \ (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1))\n                   (fibfib (- n 2)))\n   \
    \             (fibfib (- n 3))]))\n", "  (if (= n 1)\n      0\n      (+ (fibfib\
    \ (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [else (+ (fibfib (- n 1)) (fold-left\
    \ (\u03BB (n) (+ n n) n) 0 0))]))\n", "  (if (= n 0)\n      0\n      (+ (fibfib\
    \ (- n 1)) \n         (fibfib (- n 2)))))\n", "  (cond [(= n 1) 0]\n        [(=\
    \ n 2) 1]\n        [else\n         (+ (fibfib (sub1 n))\n            (fibfib (sub2\
    \ n))\n            (fibfib (sub3 n))))]))\n", "  (if (= n 0)\n      0\n      (+\
    \ (fibfib (- n 1)) (fibfib (- n 2))\n          (fibfib (- n 3)))))\n", "  (if\
    \ (zero? n)\n      0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n \
    \        (fibfib (- n 3)))))\n", "  (define (helper n a b)\n    (if (= n 0)\n\
    \        a\n        (helper (- n 1) (+ a b) (+ b))))\n  (helper n 0 0))\n", " \
    \ ;; use an accumulator\n  (define acc (make-fib n+1))\n  (define (fibbonacci\
    \ x y)\n    (if (<= x y)\n        x\n        (fibbonacci (+ x y) (x+y))))\n  (define\
    \ (fib x acc)\n    (if (= x 0)\n        acc\n        (fib (- x 1)\n          \
    \    (fibbonacci 0 acc))))\n  (fib n acc))\n", "  (if (= n 0)\n      0\n     \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (= n 0)\n      0\n      (+\
    \ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n",
  "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        (else (+ (fibfib\
    \ (sub1 n)) (fibfib (sub1 n-1)))))) ; <- the main change\n", "  (if (< n 2)\n\
    \      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (< n 2)\n \
    \     0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (define (fib k)\n\
    \    (cond [(= k 1) 0]\n          [(= k 2) 1]\n          [else (+ (fib (- k (+\
    \ 1 k)) (fib (- k (+ 2 k)))) (fib (- k (+ 3 k)))) ]))\n  (fib n))\n", "  (if (=\
    \ n 0) 0\n      (if (= n 1) 1\n          (+ (fibfib (- n 1))\n             (fibfib\
    \ (- n 2))\n             (fibfib (- n 3))))))\n", "  (cond [(= n 0) 0]\n     \
    \   [(= n 1) 1]\n        [(= n 2) 2]\n        [else\n         (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))]))\n", "  (cond [(< n 1)\n         0]\n\
    \        [(< n 2)\n         1]\n        [else\n         (+ (fibfib (- n 1))\n\
    \            (fibfib (- n 2))\n            (fibfib (- n 3)))]))\n", "  (cond [(=\
    \ n 0) 0]\n        [(= n 1) 0]\n        [else (+ (fibfib (- n 2)) (fibfib (- n\
    \ 3))) ]))\n", "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)))))\n", "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n\
    </code>\nI should also point out that I'm still learning scheme, which means I've\
    \ got a lot to learn. Thanks to everyone that has contributed.\n<|/ a tags=scheme\
    \ |>\n<| c |>\nThe R5RS definition of Fibbonacci sequence can be implemented without\
    \ tail recursion using `#+begin_src racket; `(define (fibfib! n) (cond [(= n 0)\
    \ 0] ([else (+ (fibfib! (- n 1)) \n                              (fibfib! (- n\
    \ 2))))]))`; `#+end_src`. To find the fifth fibonacci number, `fibfib!` will call\
    \ itself recursively, so it is possible to implement without recursion too but\
    \ `fibfib!` is still recursive. Tail recursion can be avoided using an accumulator\
    \ and iteration instead of recursion.\n<|/ c |>\n<| c |>\nthank you, I'm reading\
    \ up on it now. I didn't realize that R5RS had a built-in fibonacci sequence.\n\
    <|/ c |>\n<| c |>\nIf you look at the definition of `fibfib` in http://schemers.org/Documents/Scheme/HTML/r5rs.rs.html#%_idx_136,\
    \ you'll see that it is a tail recursion and should be avoided.\n<|/ c |>\n<|\
    \ c |>\nThat's correct, but the implementation of `fibfib` is still recursive,\
    \ so it is still tail recursion.\n<|/ c |>\n<| c |>\nYou're right. My mistake.\
    \ Fixed.\n<|/ c |>\n<| a tags=scheme |>\nAnother implementation:\n<code>", " \
    \ (if (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  ;;\
    \ Your code here\n  ;; (define (fibfib n) (fibfib-iter n 0 0))\n\n  ;; (define\
    \ (fibfib-iter n a b)\n  (if (> n 0)\n      (+ a (fibfib-iter (- n 1) (+ a b)\
    \ b))\n      b))\n", "  (if (= n 1)\n      0\n      (+ (fibfib (- n 2)) (fibfib\
    \ (- n 3)))))\n", "  (if (<= n 3)\n      (+ 1 (* (fibfib (- n 1)) (fibfib (- n\
    \ 2))))\n      (+ (* (fibfib (- n 1)) (fibfib (- n 3))) (fibfib (- n 2)))))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))]))\n", "  (if (= n 0)\n\
    \      0\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib\
    \ (- n 3)))))\n", "  (if (< n 1)\n      '()\n      (let ([a 2]\n            [b\
    \ 3])\n        (if (= n 2)\n            a\n            (let ([c (+ a b)])\n  \
    \            (if (< n 3)\n                  c\n                  (let ([d (+ b\
    \ c)])\n                    (if (< n 4)\n                        d\n         \
    \               (let ([e (+ c d)])\n                          (if (< n 5)\n  \
    \                            e\n                              (let ([f (+ d e)])\n\
    \                                (if (< n 6)\n                               \
    \     f\n                                    (let ([g (+ e f)])\n            \
    \                          (if (< n 7)\n                                     \
    \     g\n                                          (let ([h (+ f g)])\n      \
    \                                      (if (< n 8)\n                         \
    \                       h\n                                                (let\
    \ ([i (+ g h)])\n                                                  (if (< n 9)\n\
    \                                                      i\n                   \
    \                                   (let ([j (+ h i)])\n                     \
    \                                   (if (< n 10)\n                           \
    \                                 j\n                                        \
    \                    (let ([k (+ i j)])\n                                    \
    \                          (if (< n 11)\n                                    \
    \                              k\n                                           \
    \                       (let ([l (+ j k)])\n                                 \
    \                                   (if (< n 12)\n                           \
    \                                             l\n                            \
    \                                            (let ([m (+ k l)])\n            \
    \                                              (if (< n 13)\n                \
    \                                              m\n                           \
    \                                   (let ([n (+ l m)])\n                     \
    \                                           (if (< n 14)\n                   \
    \                                                 n\n                        \
    \                                            (let ([o (+ m n)])\n            \
    \                                                          (if (< n 15)\n    \
    \                                                                    o\n     \
    \                                                                   (let ([p (+\
    \ n o)])\n          (if (< n 16)\n                                           \
    \           p\n                                                      (let ([q\
    \ (+ o p)])\n                                                        (if (< n\
    \ 17)\n                                                            q\n       \
    \                                                     (let ([r (+ p q)])\n   \
    \                                                           (if (< n 18)\n   \
    \                                                               r\n          \
    \                                                        (let ([s (+ q r)])\n\
    \                                                                    (if (< n\
    \ 19)\n                                                                      \
    \  s\n                                                                       \
    \ (let ([t (+ r s)])\n                                                       \
    \       (if (< n 20)\n                                                       \
    \           t\n                                                              \
    \    (let ([u (+ s t)])\n                                                    \
    \                (if (< n 21)\n                                              \
    \                          u\n                                               \
    \                         (let ([v (+ t u)])\n                               \
    \                               (if (< n 22)\n                               \
    \                                   v\n                                      \
    \                            (let ([w (+ u v)])\n                            \
    \                                        (if (< n 23)\n                      \
    \                                                  w\n                       \
    \                                                 (let ([x (+ v w)])\n       \
    \                                                       (if (< n 24)\n       \
    \                                                           x\n              \
    \                                                    (let ([y (+ w x)])\n    \
    \                                                                (if (", "  (define\
    \ (helper n)\n    (if (= n 0)\n        0\n        (+ (fibfib (- n 1))\n      \
    \     (helper (- n 2)))))\n  (helper n))\n", "  (define (fibfib-helper n)\n  \
    \  (if (<= n 0) 0\n    (+ (fibfib-helper (- n 1))\n       (fibfib-helper (- n\
    \ 2))\n       (fibfib-helper (- n 3)))))\n  (fibfib-helper n))\n", "  (if (<=\
    \ n 1)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n", "  (if (= n\
    \ 0)\n      0\n      (+ (fibfib (- n 1)) \n         (fibfib (- n 2)) \n      \
    \   (fibfib (- n 3)))))\n", "  (if (= n 0)\n      0\n      (+ (fibfib (- n 1))\
    \ \n         (fibfib (- n 2)) \n         (fibfib (- n 3)))))\n", "  (cond [(=\
    \ n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib\
    \ (sub1 n))\n                   (fibfib (sub2 n)))\n        ])\n)\n</cell>\n<cell>",
  "  (fib n (- n 1) 0))\n", "  (if (= n 0) 0\n      (+ (fibfib (sub1 n))\n       \
    \  (fibfib (sub2 n))\n         (fibfib (sub3 n)))))\n\n#lang racket\n", "  (if\
    \ (= n 0)\n      0\n      (+ (fibfib (- n 1)) (fibfib (- n 2)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
