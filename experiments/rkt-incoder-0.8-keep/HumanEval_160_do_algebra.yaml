name: HumanEval_160_do_algebra
language: rkt
prompt: "#lang racket\n\n;; Given two lists operator, and operand. The first list\
  \ has basic algebra operations, and \n;; the second list is a list of integers.\
  \ Use the two given lists to build the algebric \n;; expression and return the evaluation\
  \ of this expression.\n;; The basic algebra operations:\n;; Addition ( + ) \n;;\
  \ Subtraction ( - ) \n;; Multiplication ( * ) \n;; Floor division ( // ) \n;; Exponentiation\
  \ ( ** ) \n;; Example:\n;; operator['+', '*', '-']\n;; array = [2, 3, 4, 5]\n;;\
  \ result = 2 + 3 * 4 - 5\n;; => result = 9\n;; Note:\n;; The length of operator\
  \ list is equal to the length of operand list minus one.\n;; Operand is a list of\
  \ of non-negative integers.\n;; Operator list has at least one operator, and operand\
  \ list has at least two operands.\n(define (do_algebra operator operand)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate do_algebra))\n\
  \    (check-equal? (candidate (list \"**\" \"*\" \"+\") (list 2 3 4 5)) 37)\n  \
  \  (check-equal? (candidate (list \"+\" \"*\" \"-\") (list 2 3 4 5)) 9)\n    (check-equal?\
  \ (candidate (list \"//\" \"*\") (list 7 3 4)) 8)\n))\n\n(test-humaneval)"
completions: ["  (if (null? operand)\n      '()\n      (append \n      (if (equal?\
    \ (caar operand) '+)\n          (do_algebra (car operator) (cddr operand))\n \
    \         (if (equal? (caar operand) '*)\n              (do_algebra (car operator)\
    \ (cddr operand))\n              (if (equal? (caar operand) '//)\n           \
    \       (do_algebra (car operator) (cddr operand))\n                  (if (equal?\
    \ (caar operand) '**)\n                      (do_algebra (car operator) (cddr\
    \ operand))\n                      (do_algebra (car operator) (list operand operand))))))))\n",
  "  (define (result op a1 a2)\n    (cond\n      [(empty? op) 0]\n      [(eq? (car\
    \ op) '+) (+ a1 a2)]\n      [(eq? (car op) '-) (- a1 a2)]\n      [(eq? (car op)\
    \ '*) (* a1 a2)]\n      [(eq? (car op) '//) (/ a1 a2)]\n      [(eq? (car op) '**)\
    \ (* a1 (* a2 a2))]\n      [else (error 'wrong-operator)])\n    (cond\n      [(empty?\
    \ operand) result]\n      [else (result (cdr op) (car operand) (cdr operand))]))\n\
    \  result)\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme dscore=2\
    \ |>\nHere's a way using list functions and recursion:\n<code>", "  (let ((a (make_dec\
    \ operator operand)))\n    (make-dec (first a) (second a))\n  )\n)\n", "  (define\
    \ result 0)\n  (for ([i operand])\n    (define tmp (do_arith i operator))\n  \
    \  (set! result (+ result tmp))\n    result))\n", "  (cond\n    [(empty? operand)\n\
    \     (car (apply (op operand) operator))] \n    [else\n     ((or (null? (car\
    \ operand))\n           (empty? (cdr operand)))\n      (do_algebra operator (cdr\
    \ operand))]))", "  (define (eval a)\n    (cond\n      [(= a 0) 0]\n      [(operator\
    \ '*) \n       (+ (eval a) (eval operand))]\n      [(operator '+) \n       (-\
    \ a (eval operand))]\n      [(operator '-) \n       (- (eval a) (eval operand))]\n\
    \      [(operator '//) \n       (/ a (eval operand))]\n      [(operator '**) \n\
    \       (* a (eval operand))]\n      [(operator '#lang racket) \n       (list\
    \ a (eval operand)]\n      [else (error \"invalid operator\" operator)]))\n  (eval\
    \ operand))", "  ;; Operator list has at least one operator, and operand list\
    \ has at least two operands.\n  \n  (let ((result 0))\n    \n    ;; ((do addition\
    \ with (operator list at index 0)) ((operator list at index 1)) \n    ;; ((do\
    \ addition with (operator list at index 1)) ((operator list at index 2)) \n  \
    \  ;; ((do addition with (operator list at index 2)) ((operator list at index\
    \ 3)) \n    ;; ((do addition with (operator list at index 3)) ((operator list\
    \ at index 4)) \n    ;; ((do addition with (operator list at index 4)) ((operator\
    \ list at index 5)) \n    ;; ((do addition with (operator list at index 5)) ((operator\
    \ list at index 6)) \n    ;; ((do addition with (operator list at index 6)) ((operator\
    \ list at index 7)) \n    ;; ((do addition with (operator list at index 7)) ((operator\
    \ list at index 8)) \n    ;; ((do addition with (operator list at index 8)) ((operator\
    \ list at index 9)) \n    ;; ((do addition with (operator list at index 9)) ((operator\
    \ list at index 10)) \n    ;; ((do addition with (operator list at index 10))\
    \ ((operator list at index 11)) \n    ;; ((do addition with (operator list at\
    \ index 11)) ((operator list at index 12)) \n    ;; ((do addition with (operator\
    \ list at index 12)) ((operator list at index 13)) \n    ;; ((do addition with\
    \ (operator list at index 13)) ((operator list at index 14)) \n    ;; ((do addition\
    \ with (operator list at index 14)) ((operator list at index 15)) \n    ;; ((do\
    \ addition with (operator list at index 15)) ((operator list at index 16)) \n\
    \    ;; ((do addition with (operator list at index 16)) ((operator list at index\
    \ 17)) \n    ;; ((do addition with (operator list at index 17)) ((operator list\
    \ at index 18)) \n    ;; ((do addition with (operator list at index 18)) ((operator\
    \ list at index 19)) \n    ;; ((do addition with (operator list at index 19))\
    \ ((operator list at index 20)) \n    ;; ((do addition with (operator list at\
    \ index 20)) ((operator list at index 21)) \n    ;; ((", "  (cond\n    [(empty?\
    \ operand)\n     (error \"The operand list is empty\")\n     (print-expression\
    \ operand)]\n    [(empty? operator)\n     (error \"The operator list is empty\"\
    )\n     (print-expression operand)]\n    [(equal? (length operator) (length operand))\n\
    \     (cons (apply (first operator) (map - operand operand)) operand)]\n    [else\n\
    \     (let ((op (first operator))\n           (n (rest operand)))\n       (cond\n\
    \         [(equal? op +) (+ n (apply (first operand) (map - operand operand)))]\n\
    \         [(equal? op -) (- n (apply (first operand) (map - operand operand)))]\n\
    \         [(equal? op *) (* n (apply (first operand) (map - operand operand)))]\n\
    \         [(equal? op //) (floor n (apply (first operand) (map - operand operand)))]\n\
    \         [(equal? op **) (* n (apply (first operand) (map - operand operand)))]\n\
    \         [else (error \"Invalid operator. Must be a basic algebra operation.\"\
    )]))]))", "  (if (null? operand)\n      0\n      (+ (first (assoc operator (+\
    \ 0 operand))) \n         (do_algebra (rest operator) (sub1 operand)))))\n", " \
    \ (if (null? operator)\n      (if (null? operand)\n          0\n          (if\
    \ (even? (car operand))\n              (* 2 (car operand))\n              0))\n\
    \      (if (even? (car operand))\n          (if (null? (cdr operand))\n      \
    \        (do_algebra (cdr operator) (car operand))\n              (do_algebra\
    \ (cdr operator) (cdr operand)))\n          (if (null? (cdr operand))\n      \
    \        (do_algebra (cdr operator) (list (car operand)))\n              (do_algebra\
    \ (cdr operator) (list (car operand) (cdr operand)))))\n      (if (null? (cdr\
    \ operand))\n          (do_algebra (cdr operator) (list (car operand)))\n    \
    \      (if (null? (cdr operator))\n              (do_algebra (cdr operator) (list\
    \ (car operand))))\n          (if (null? (cdr operator))\n              (do_algebra\
    \ (cdr operator) (list (car operand) (cdr operand)))))))\n", "  (cond\n    [(empty?\
    \ operand) (error \"Operand list is empty.\")]\n    [else (* operator (do_algebra\
    \ (first operand) (rest operand))) ] ))\n", "  (cond [(empty? operand)\n     \
    \    empty]\n        [(empty? (rest operand))\n         (first operand)]\n   \
    \     [else\n         (cons (first operand)\n              (do_algebra (rest operator)\n\
    \                          (rest operand)))]))\n", "  (cond\n    [(empty? operand)\n\
    \      (error 'math-expression \"Empty operand in do_algebra.\" 'operator)]\n\
    \    [(empty? operator)\n      (error 'math-expression \"Empty operator in do_algebra.\"\
    \ 'operator)]\n    [else (cond\n            [(equal? (first operator) '+)\n  \
    \           (lambda (a b) (+ a b))]\n            [(equal? (first operator) '-)\n\
    \             (lambda (a b) (- a b))]\n            [(equal? (first operator) '*)\n\
    \             (lambda (a b) (* a b))]\n            [(equal? (first operator) '//)\n\
    \             (lambda (a b) (// a b))]\n            [(equal? (first operator)\
    \ '**)\n             (lambda (a b) (** a b))]\n            [else (error 'math-expression\
    \ \"Invalid operator in do_algebra.\" 'operator)])\n     ]))\n", "  (cond [(null?\
    \ operand) 0]\n        [(null? (cdr operand)) (* (car operand) (do_algebra (car\
    \ operator) (cdr operand)))]\n        [else (* (car operand) (do_algebra (car\
    \ operator) (cdr operand)))]))\n", "  (cond\n    ((null? operand) 0)\n    ((null?\
    \ (cdr operand)) (+ (car operand) (do_algebra (car operator) (cdr operand))))\n\
    \    (else (+ (do_algebra (car operator) (cdr operand)) (do_algebra (car operator)\
    \ (cdr operand))))))\n", "  (cond ((and (null? operand) (null? operator)) '())\n\
    \        (else (cons (+ (car operand) (do_algebra (cdr operator) (cdr operand)))\n\
    \                    (do_algebra (cdr operator) operand))))))\n", "  (cond\n \
    \   [(empty? operand) (number->string 0)]\n    [(equal? (length operator) length\
    \ (length operand)) \n     (cond (\n         [(equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (rest operand))]\n         [(equal? (first\
    \ operator) (first operand)) (do_algebra (rest operator) (rest operand))]\n  \
    \       [(equal? (first operator) (first operand)) (do_algebra (rest operator)\
    \ (rest operand))]\n         [(equal? (first operator) (first operand)) (do_algebra\
    \ (rest operator) (rest operand))]\n         [(equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (rest operand))]\n         [(equal? (first\
    \ operator) (first operand)) (do_algebra (rest operator) (rest operand))]\n  \
    \       [(equal? (first operator) (first operand)) (do_algebra (rest operator)\
    \ (rest operand))]\n         [(equal? (first operator) (first operand)) (do_algebra\
    \ (rest operator) (rest operand))]\n         [(equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (rest operand))]\n         [(equal? (first\
    \ operator) (first operand)) (do_algebra (rest operator) (rest operand))]\n  \
    \       [(equal? (first operator) (first operand)) (do_algebra (rest operator)\
    \ (rest operand))]\n         [(equal? (first operator) (first operand)) (do_algebra\
    \ (rest operator) (rest operand))]\n         [(equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (rest operand))]\n         [(equal? (first\
    \ operator) (first operand)) (do_algebra (rest operator) (rest operand))]\n  \
    \       [(equal? (first operator) (first operand)) (do_algebra (rest operator)\
    \ (rest operand))]\n         [(equal? (first operator) (first operand)) (do_algebra\
    \ (rest operator) (rest operand))]\n         [(equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (rest operand))]\n         [(equal? (first\
    \ operator) (first operand)) (do_algebra (rest operator) (rest operand))]\n  \
    \       [(equal? (first operator) (first operand)) (do_algebra (rest operator)\
    \ (rest operand))]\n         [(equal? (first operator) (first operand)) (do_algebra\
    \ (rest operator) (rest operand))]\n         [(equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (rest operand))]\n         [(equal? (first\
    \ operator) (first operand)) (do_algebra (rest operator) (re", "  (cond\n    [(=\
    \ (length operator) 1) (+ operand operand)]\n    [(= (length operator) 2) (- operand\
    \ operand)]\n    [(= (length operator) 3) (* (+ operand operand) (* operand operand))]\n\
    \    [else (/ (+ (+ (* operand operand) (* operator operator) (* operand operand))\
    \ (* operator operator) (* operand operand))\n            (* operator operator)\
    \ (* operand operand)))]))", "  (if (null? operand)\n      (error \"Invalid argument\"\
    )\n      (let ([head (car operand)]\n            [tail (cdr operand)])\n     \
    \   (if (or (null? tail)\n                (null? (cdr tail)))\n            (*\
    \ head head)\n            (if (eq? operator (car tail))\n                (* head\
    \ (do_algebra operator (cdr tail))) \n                (* head (do_algebra (car\
    \ tail) (cdr tail)))))))\n</code>\n<|/ a |>\n<| c |>\nWhy don't you put this in\
    \ as a function in the `racket` module?\n<|/ c |>\n<| a dscore=2 |>\nSince this\
    \ question was asked, the Racket language has added an operator for doing this.\
    \ It doesn't require a helper procedure:\n<code>\n#lang racket\n", "  (letfn [(do_operation\
    \ \n           ((operator operand)\n            (letfn [(op_add (x y)\n      \
    \               (if (and (number? x) (number? y))\n                         (+\
    \ (number? x) (number? y))\n                         (error 'op_add \"Operand\
    \ must be integers\" x))]\n               (op_add x y)))]\n    (op_add (first\
    \ operator) (first operand))))))\n", "  (cond ((null? operator)\n         operand)\n\
    \        ((null? operand)\n         operator)\n        (else\n         (do_algebra\
    \ (cdr operator)\n                     (do_algebra (first operator)\n        \
    \                         (cdr operand))))))\n", "  (if (empty? operand)\n   \
    \   (if (empty? operator)\n          (if (number? operand)\n              operand\n\
    \              #f)\n          #f)\n      (if (list? (car operand))\n         \
    \ (do_algebra (first operator)\n                      (map do_algebra (rest operand)))\n\
    \          (do_algebra (first operand)\n                      (map do_algebra\
    \ (rest operator))))))\n", "  (define (alg_operation left_operand right_operand)\n\
    \    (if (= operator (car left_operand))\n        (cdr left_operand)\n       \
    \ (cdr right_operand)))\n  (let ((result 0))\n    (cond ((null? (car operand))\n\
    \           (set! result (alg_operation null (car operand)))\n           result)\n\
    \          ((null? (cdr operand))\n           (set! result (alg_operation (car\
    \ operand) null))\n           result)\n          ((= (car operand) (+ 0 (alg_operation\
    \ null (car operand))))\n           (set! result (alg_operation (car operand)\
    \ (+ 0 (alg_operation (car operand) null))))\n           result)\n          (else\
    \ \n           (set! result (alg_operation (car operand) (alg_operation null (cdr\
    \ operand))))\n           result)))) \n", "  (cond [(empty? operator) operand]\n\
    \        [(empty? operand) operand]\n        [(equal? (head operator) (*)) (do_algebra\
    \ (cdr operator) (list 0 (do_algebra (cdr operand) (list* (* (head operand) (head\
    \ operand))))))]\n        [(equal? (head operator) (*)) (do_algebra (cdr operator)\
    \ (list 1 (do_algebra (cdr operand) (list* (* (head operand) (head operand)) (+\
    \ (cdr operand) (head operand))))))]\n        [(equal? (head operator) (/)) (do_algebra\
    \ (cdr operator) (list 1 (do_algebra (cdr operand) (list* (* (/ (head operand)\
    \ (head operand)) (+ (cdr operand) (head operand))))))]\n        [(equal? (head\
    \ operator) (//)) (do_algebra (cdr operator) (list 1 (do_algebra (cdr operand)\
    \ (list* (floor-div// (head operand) (head operand)) (+ (cdr operand) (head operand))))))]\n\
    \        [(equal? (head operator) (^)) (do_algebra (cdr operator) (list 1 (do_algebra\
    \ (cdr operand) (list* (* (* (^ operand) (head operand)) (head operand)) (+ (cdr\
    \ operand) (head operand))))))]\n        [(equal? (head operator) (%)) (do_algebra\
    \ (cdr operator) (list 1 (do_algebra (cdr operand) (list* (* (% operand) (head\
    \ operand)) (+ (cdr operand) (head operand))))))]\n        [else (do_algebra (cdr\
    \ operator) (list 2 (do_algebra (cdr operand) (list* (* (head operand) (head operand))\
    \ (+ (+ (cdr operand) (head operand)) (head operand)) (head operand))))))))\n",
  "  (cond\n    [(= (length operator) (length operand)) (+ (do_algebra (rest operator)\n\
    \                                                                 (first operand)))]\n\
    \    [else (+ (do_algebra (first operator)\n                             (rest\
    \ operand))\n               (do_algebra (rest operator)\n                    \
    \       operand))]))\n", "  (cond\n    [(empty? operand)\n     (f\n       ;; The\
    \ first operand and first operator must be the same.\n       ;; The second operand\
    \ and second operator must be the same.\n       (if (equal? (car operand) (car\
    \ operator))\n           ;; If the first operand and first operator are the same\
    \ then\n           ;; the two operands must be the same.\n           (equal? (car\
    \ operand)\n                    (car (cdr operator)))\n           ;; If the first\
    \ operand and first operator are different then\n           ;; the two operands\
    \ must be different.\n           (not (equal? (car operand)\n                \
    \      (car (cdr operator))))]\n    [(equal? (car operand) (car operator))\n \
    \    (+ (* car operand) (do_algebra (cdr operator) (cdr operand)))]\n    [(not\
    \ (equal? (car operand) (car operator)))\n     (* car operand\n        (do_algebra\
    \ (cdr operator)\n                    (cdr operand)))]\n    [else\n     (* car\
    \ operand\n        (do_algebra (cdr operator)\n                    (cdr operand)))]))\n",
  "  (cond [(empty? operand) 0]\n        [(equal? operator (first operand)) (second\
    \ operand)]\n        [(equal? (first operand) operator) (do_algebra (rest operand)\
    \ (second operand))]\n        [else (do_algebra (first operand) (rest operand))]))\n",
  "  (if (null? operand)\n      '()\n      (append (list (cadr (assoc (first operand)\
    \ operator)))\n               (do_algebra operator (cdr operand)))))\n", "  (cond\n\
    \    ((empty? operand)\n     (error \"Invalid operand list.\"))\n    ((empty?\
    \ operator)\n     (error \"Invalid operator list.\"))\n    ((null? (rest operator))\n\
    \     (error \"Invalid operator list.\"))\n    ((null? (rest operand))\n     (error\
    \ \"Invalid operand list.\"))\n    (else\n     (let* ((head (first operator))\n\
    \            (op1 (rest operator))\n            (op2 (first operand))\n      \
    \      (op2 (rest operand))\n            (arg1 (first op2))\n            (arg2\
    \ (rest op2)))\n       (cond\n         ;; Add\n         ((equal? head '+')\n \
    \         (if (= (remainder op2 2) 0)\n              (+ arg1 arg2)\n         \
    \     (error \"Invalid operand list.\")))\n         ;; Subtract\n         ((equal?\
    \ head '-')\n          (if (= (remainder op2 2) 0)\n              (- arg1 arg2)\n\
    \              (error \"Invalid operand list.\")))\n         ;; Multiply\n   \
    \      ((equal? head '*')\n          (if (= (remainder op2 2) 0)\n           \
    \   (* (+ arg1 1) arg2)\n              (error \"Invalid operand list.\")))\n \
    \        ;; Floor division\n         ((equal? head '//')\n          (if (= (remainder\
    \ op2 2) 0)\n              (/ arg1 (floor arg2))\n              (error \"Invalid\
    \ operand list.\")))\n         ;; Exponentiation\n         ((equal? head '**')\n\
    \          (if (= (remainder op2 2) 0)\n              (* arg1 (expo arg2))\n \
    \             (error \"Invalid operand list.\")))\n         ;; Error\n       \
    \  (else\n          (error \"Invalid operator list.\"))))))\n", "  ;; Build an\
    \ algebraic expression and evaluate it \n  (define expr\n    (cond \n      [(=\
    \ (length operator) (length operand)) (list operator)]\n      [(<= (length operator)\
    \ (length operand)) (list operator operand)]\n      [else (list operator operand\
    \ operand)])\n    (apply eval (append (list '+ ) expr)))\n  ;; Return the evaluated\
    \ expression \n  (if (eq? '+ expr '+) (+ 0 (first operand)) (if (eq? '- expr '-)\
    \ (- 0 (first operand)) (if (eq? '* expr '*) 0 (if (eq? '// expr '//) (first operand)\
    \ (first operand))))))\n", "  (cond\n    [(empty? operand) (error \"Operands and\
    \ operators must have the same length.\")]\n    [(null? (first operand)) (error\
    \ \"First operand is not valid.\")]\n    [(null? (second operand)) (error \"Second\
    \ operand is not valid.\")]\n    [(or (not (pair? (first operand))) (not (pair?\
    \ (second operand)))) (error \"Operands and operators are not pairs.\")]\n   \
    \ [else (cons\n            (first (first operand))\n            (do_algebra (second\
    \ operand) (rest operand)))]))\n", "  (define (do_oper oper lst)\n    (cond\n\
    \      [(null? lst) 0]\n      [(equal? (car lst) oper) (+ (car lst) (do_oper oper\
    \ (cdr lst)))]\n      [else (do_oper oper (cdr lst))]))\n\n  (define (do_op oper\
    \ lst)\n    (cond\n      [(null? lst) 0]\n      [(equal? (car lst) oper) (+ (car\
    \ lst) (do_op oper (cdr lst)))]\n      [else (do_op oper (cdr lst))]))\n\n  (define\
    \ (do_math oper lst)\n    (cond\n      [(null? lst) 0]\n      [(equal? (car lst)\
    \ oper) (* (car lst) (do_math oper (cdr lst)))]\n      [else (do_math oper (cdr\
    \ lst))]))\n\n  (define (do_floor oper lst)\n    (cond\n      [(null? lst) 0]\n\
    \      [(equal? (car lst) oper) (// (car lst) (do_floor oper (cdr lst)))]\n  \
    \    [else (do_floor oper (cdr lst))]))\n\n  (define (do_exp oper lst)\n    (cond\n\
    \      [(null? lst) 0]\n      [(equal? (car lst) oper) (** (car lst) (do_exp oper\
    \ (cdr lst)))]\n      [else (do_exp oper (cdr lst))]))\n\n  (define (do_exp oper\
    \ lst)\n    (cond\n      [(null? lst) 0]\n      [(equal? (car lst) oper) (** (car\
    \ lst) (do_exp oper (cdr lst)))]\n      [else (do_exp oper (cdr lst))]))\n\n \
    \ (define (do_op oper lst)\n    (cond\n      [(null? lst) 0]\n      [(equal? (car\
    \ lst) oper) (do_op oper (cdr lst))]\n      [else (do_op oper (cdr lst))]))\n\n\
    \  (define (do_math2 oper lst)\n    (cond\n      [(null? lst) 0]\n      [(equal?\
    \ (car lst) oper) (* (car lst) (do_math2 oper (cdr lst)))]\n      [else (do_math2\
    \ oper (cdr lst))]))\n\n  (define (do_math3 oper lst)\n    (cond\n      [(null",
  "  (cond\n    [(null? operand) 0]\n    [(null? (cdr operand)) (car operand)]\n \
    \   [else (+ (apply (apply car operand)\n                     (map (fn [[x y]]\
    \ \n                             (* x y))\n                         operator))\n\
    \            (apply (apply (cdr operand)\n                      (map \n      \
    \                 (fn [[x y]] \n                          (* x y))\n         \
    \              operator)))))]))\n", "  (cond\n    [(null? operand) (quote ())]\n\
    \    [(null? operator) (quote ())]\n    [(null? (cdr operator)) (quote ())]\n\
    \    [else (cons (* (car operator) (car operand)) (do_algebra (cdr operator) (cdr\
    \ operand)))]))\n", "  (cond\n    [(empty? operand) (error 'not-enough-operands\
    \ operand)]\n    [(empty? operator) (error 'not-enough-operators operator)]\n\
    \    [(member? operator (first(operand))) (error 'non-existent-operator operator)]\n\
    \    [(equal? (length operator) (length operand)) (error 'non-equal-length operator\
    \ operand)]\n    [else (cons (member? (first operator) (first(operand))) (do_algebra\
    \ (rest operator) (rest operand))]))))\n", "  (if (empty? operand)\n      (- 1)\n\
    \      (+ (map (lambda (x) (do_algebra (car operand) (cdr operand))) operator)\n\
    \         (* (car operand) (do_algebra (car operand) (cdr operand)))))) \n", " \
    \ (cond\n    [(equal? 0 operand) (error \"operand list is empty\")]\n    [else\
    \ (+ operator (do_algebra (car operand) (cdr operand))]))\n", "  (define (do_op\
    \ op op1 op2)\n    (cond\n      [(= op +) (+ op1 op2)\n       [(= op -) (- op1\
    \ op2)\n        [(= op *) (* op1 op2)\n         [(= op //) (// op1 op2)\n    \
    \      [(= op **) (* op1 ** (+ op2 1))\n           [(= op /) (/ op1 op2)]]]]])\n\
    \  (define (do_op op op1 op2)\n    (cond\n      [(= op +) (+ op1 op2)\n      \
    \ [(= op -) (- op1 op2)\n        [(= op *) (* op1 op2)\n         [(= op //) (//\
    \ op1 op2)\n          [(= op **) (* op1 ** (+ op2 1))\n           [(= op /) (/\
    \ op1 op2)]]]]])\n  (define (do_op op op1 op2)\n    (cond\n      [(= op +) (+\
    \ op1 op2)\n       [(= op -) (- op1 op2)\n        [(= op *) (* op1 op2)\n    \
    \     [(= op //) (// op1 op2)\n          [(= op **) (* op1 ** (+ op2 1))\n   \
    \        [(= op /) (/ op1 op2)]]]]])\n  (define (do_op op op1 op2)\n    (cond\n\
    \      [(= op +) (+ op1 op2)\n       [(= op -) (- op1 op2)\n        [(= op *)\
    \ (* op1 op2)\n         [(= op //) (// op1 op2)\n          [(= op **) (* op1 **\
    \ (+ op2 1))\n           [(= op /) (/ op1 op2)]]]]])\n  (define (do_op op op1\
    \ op2)\n    (cond\n      [(= op +) (+ op1 op2)\n       [(= op -) (- op1 op2)\n\
    \        [(= op *) (* op1 op2)\n         [(= op //) (// op1 op2)\n          [(=\
    \ op **) (* op1 ** (+ op2 1))\n           [(= op /) (/ op1 op2)]]]]])\n  (define\
    \ (do_op op op1 op2)\n    (cond\n      [(= op +) (+ op1 op2)\n       [(= op -)\
    \ (- op1 op2)\n        [(= op *) (* op1 ", "  (cond\n    [(empty? operand) 0]\n\
    \    [else (+(do_algebra (first operator) (first operand))\n            (do_algebra\
    \ (rest operator) (rest operand)))]))\n", "  (define (do_operand i operand)\n\
    \    (cond ((null? operand) 0)\n          ((number? operand) (* i operand))\n\
    \          ((string? operand) (string->number operand))\n          (else (error\
    \ \"Wrong operand type ~a\" operand))))\n  (define (do_operator i operator)\n\
    \    (cond ((null? operator) 'zero)\n          ((eq? operator '+) (+ i 1))\n \
    \         ((eq? operator '-) (- i 1))\n          ((eq? operator '*) (* i 1))\n\
    \          ((eq? operator '/) (/ i 1))\n          ((eq? operator '**) (** i 1))\n\
    \          (else (error \"Wrong operator ~a\" operator))))\n  (define (do_all_operations\
    \ i operator operand)\n    (cond ((null? operator) operand)\n          ((eq? operator\
    \ '-) (- operand i))\n          ((eq? operator '+) (+ operand i))\n          ((eq?\
    \ operator '*) (* operand i))\n          ((eq? operator '/) (/ operand i))\n \
    \         ((eq? operator '**) (** operand i))\n          (else (error \"Wrong\
    \ operator ~a\" operator))))\n  (define (do_all_operands i operator operand)\n\
    \    (cond ((null? operand) operand)\n          ((eq? operator '+) (+ i 1))\n\
    \          ((eq? operator '-) (- i 1))\n          ((eq? operator '*) (* i 1))\n\
    \          ((eq? operator '/) (/ i 1))\n          ((eq? operator '**) (** i 1))\n\
    \          (else (error \"Wrong operand type ~a\" operand))))\n  (define (do_all_operands_not_null\
    \ i operator operand)\n    (cond ((null? operand) operand)\n          ((eq? operator\
    \ '+) (+ i 1))\n          ((eq? operator '-) (- i 1))\n          ((eq? operator\
    \ '*) (* i 1))\n          ((eq? operator '/) (/ i 1))\n          ((eq? operator\
    \ '**) (** i 1))\n          (else (error \"Wrong operand type ~a\" operand))))\n\
    \  (define (do_all_operands_not_zero i operator operand)\n    (cond ((null? operand)\
    \ operand)\n          ((eq? operator '+) (+ i 1))\n          ((eq? operator '-)\
    \ (- i 1))\n          ((eq? operator '*) (* i 1))\n          ((eq? operator '/)\
    \ (/ i 1))\n          ((", "  (cond\n    ((null? operand) 0)\n    ((null? (cdr\
    \ operand)) 0)\n    ((null? (cddr operand)) 0)\n    ((null? (caddr operand)) 0)\n\
    \    ((null? (cadddr operand)) 0)\n    ((null? (caaddr operand)) 0)\n    ((null?\
    \ (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr\
    \ operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand))\
    \ 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n \
    \   ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null?\
    \ (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr\
    \ operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand))\
    \ 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n \
    \   ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null?\
    \ (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr\
    \ operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand))\
    \ 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n \
    \   ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null?\
    \ (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr\
    \ operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand))\
    \ 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n \
    \   ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null?\
    \ (caadddr operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr\
    \ operand)) 0)\n    ((null? (caadddr operand)) 0)\n    ((null? (caadddr operand))\
    \ 0)\n    ((", "  (cond \n    [(empty? operator) operand]\n    [(empty? operand)\
    \ operand]\n    [else\n     (cond\n       [(= (length (first operator)) (length\
    \ (first operand)))\n        (do_algebra (rest operator) (rest operand))]\n  \
    \     [else\n        (do_algebra (rest operator) (rest (rest operand))) (+ (first\
    \ operator) (first operand)))]))])", "  (cond ((empty? operand) (cons (first operand)\
    \ (do_algebra (rest operator) (rest operand))))\n        (else (+ (do_algebra\
    \ (first operator) (first operand)) (do_algebra (first operator) (rest operand))))))\n",
  "  (cond\n    [(empty? operand) (error \"Too few arguments\")]\n    [(empty? operator)\
    \ (error \"Too few arguments\")]\n    [else\n     (let ((op1 (caar operator))\n\
    \           (op2 (cadar operator))\n           (opn (car operator)))\n       (cond\n\
    \        [(= op1 '+) (+ operand)\n         (if (= op1 '-) (- operand)\n      \
    \     (if (= op1 '*) (* (caar operand) (cadar operand))\n             (if (= op1\
    \ '//) (/ operand (car operand))\n               (if (= op1 '**) (exp (caar operand)\
    \ (caar operand))\n               (error \"invalid operation on operands\")))\n\
    \           (error \"invalid operation on operands\"))]\n        [(= op1 '-) (-\
    \ operand)\n         (if (= op1 '*) (* (caar operand) (cadar operand))\n     \
    \      (if (= op1 '//) (/ operand (car operand))\n           (if (= op1 '**) (exp\
    \ (caar operand) (caar operand))\n           (error \"invalid operation on operands\"\
    ))\n           (error \"invalid operation on operands\"))]\n        [(= op1 '*)\
    \ (* (caar operand) (cadar operand))\n         (if (= op1 '//) (/ operand (car\
    \ operand))\n           (if (= op1 '**) (exp (caar operand) (caar operand))\n\
    \           (error \"invalid operation on operands\"))\n           (error \"invalid\
    \ operation on operands\"))]\n        [(= op1 '**) (exp (caar operand) (caar operand))\n\
    \         (error \"invalid operation on operands\"))]\n        [else\n       \
    \  (error \"invalid operation on operands\")])))]\n    [(empty? operand) (error\
    \ \"Too few arguments\")]\n    [(empty? operator) (error \"Too few arguments\"\
    )]\n    [else\n     (error \"Too few arguments\")]))\n", "  ; Check length of\
    \ operator and operand lists and make sure they are equal.\n  (check-equal? (-\
    \ (length operator) (length operand)) 0)\n  \n  ; Initialize the result variable\
    \ to zero.\n  (set! result 0)\n  \n  ; Loop through the operators list and do\
    \ algebraic operations according to the operators.\n  (loop\n   ((i 0) (value\
    \ 0))\n   ((< i (length operator)) (set! result (+ value (* (operand i) (operator\
    \ (- i 1))))))\n   ((<= i (length operator)) (set! result (+ value (* (operand\
    \ i) (operator (+ i 1))))))\n   ((> i (length operator)) (set! result (+ value\
    \ (/ (operand i) (operator (- i 1))))))\n   ((>= i (length operator)) (set! result\
    \ (+ value (/ (operand i) (operator (+ i 1))))))\n   ((in-operator? (operator\
    \ (- i 1)))\n    (set! result (+ value (/ (operand i) (operator (- i 1))))))\n\
    \   ((in-operator? (operator (+ i 1)))\n    (set! result (+ value (/ (operand\
    \ i) (operator (+ i 1))))))\n   ((in-operator? (operator (+ i 1)))\n    (set!\
    \ result (+ value (/ (operand i) (operator (+ i 1))))))\n   ((in-operator? (operator\
    \ (+ i 1)))\n    (set! result (+ value (/ (operand i) (operator (+ i 1))))))\n\
    \   ((in-operator? (operator (+ i 1)))\n    (set! result (+ value (/ (operand\
    \ i) (operator (+ i 1))))))\n   ((in-operator? (operator (- i 1)))\n    (set!\
    \ result (+ value (/ (operand i) (operator (- i 1))))))\n   ((in-operator? (operator\
    \ (- i 1)))\n    (set! result (+ value (/ (operand i) (operator (- i 1))))))\n\
    \   ((in-operator? (operator (- i 1)))\n    (set! result (+ value (/ (operand\
    \ i) (operator (- i 1))))))\n   ((in-operator? (operator (- i 1)))\n    (set!\
    \ result (+ value (/ (operand i) (operator (- i 1))))))\n   ((in-operator? (operator\
    \ (- i 1)))\n    (set! result (+ value (/ (operand i) (operator (- i 1))))))\n\
    \   ((in-operator? (operator (- i 1)))\n    (set! result (+ value (/ (operand\
    \ i) (operator (- i 1))))))\n   ((in-operator? (operator (- i 1)))\n    (set!\
    \ result (+ value (/ (operand i) (", "  (cond\n    [(null? operand) 0]\n    [(null?\
    \ (cdr operand)) (do_algebra (car operator) (cdr operand))]\n    [else\n     (+\
    \ (* (car operand) (do_algebra (car operator) (cdr operand)))\n        (do_algebra\
    \ (car operator) (cdr operand)))]))\n", '  (local ((define (op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op op op op op op op op op op op op op op op op op op op op op
    op op op op op op ', "  (if (or (null? operand) (null? operator))\n      'error\n\
    \      (append (list (+ (car operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ (caddr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ (caddr operand) (* 2 (caddr operator) (caddr operand))))\n\
    \              (list (+ (caddr operand) (* 2 (cadr operator) (cadr operand))))\n\
    \              (list (+ (cadr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ (cadr operand) (* 2 (caddr operator) (caddr operand))))\n\
    \              (list (+ (cadr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ (caddr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (caddr operator) (caddr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (caddr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (caddr operator) (cadr operand))))\n\
    \              (list (+ 1 (caddr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (cadr operator) (caddr operand))))\n\
    \              (list (+ 1 (cadr operand) (* 2 (caddr operator) (caddr ", "  (if\
    \ (null? (first operand))\n      'error\n      (let ([op1 (first operand)]\n \
    \           [op2 (rest operand)])\n        (cond ((= 0 (modulo 2 (length op1)))\
    \ \n              (cons (list op1 op2) operand))\n              ((= 0 (modulo\
    \ 2 (length op2)) \n                     (list op1 (list op2)))\n            \
    \  (cons (list op1 (list op2)) operand))\n              ((= 0 (modulo 2 (length\
    \ op1)) (list op2 (list op1)))\n              (cons (list op1 (list op2)) operand))\n\
    \              ((= 0 (modulo 2 (length op2)) (list op1 (list op2)))\n        \
    \      (cons (list op1 (list op2)) operand))\n              (else (list op1 (list\
    \ op2) operand))))))\n", "  (cond\n    [(empty? operand) (make-node 'integer (length\
    \ operand) (first operand))] \n    [(empty? operator) (make-node 'integer (length\
    \ operator) (first operand))]\n    [(member? (first operand) operator) (do_algebra\
    \ operator (rest operand))]\n    [else (make-node 'arithmetic (length operator)\
    \ (first operand) (do_algebra operator (rest operand)))]\n  )\n)\n", "  (cond\n\
    \    [(null? operand)\n     (error \"Operand cannot be empty.\")\n     (+ operand)]\n\
    \    [(equal? (first operand) operator)\n     (cond\n       [(null? (rest operand))\n\
    \        (+ 0 (+ (second operand) (* -1 (first operand))))]\n       [(equal? (first\
    \ operand) '-)(+ 0 (- (second operand) (* -1 (first operand))))]\n       [(equal?\
    \ (first operand) '*)\n        (+ 0 (+ (second operand) (* -1 (first operand))))]\n\
    \       [(equal? (first operand) '//)(+ 0 (/ (second operand) (* -1 (first operand))))]\n\
    \       [(equal? (first operand) '**)\n        (+ 0 (+ (second operand) (* -1\
    \ (first operand))))]\n       [else (error \"Invalid operation.\")]])]\n    [else\
    \ (error \"Invalid operation.\")]))\n", "  (cond [(empty? operand) 0]\n      \
    \  [(equal? operator (first operand)) (+ (first operand) (do_algebra (rest operand)\
    \ (first operand)))]\n        [(equal? operator (second operand)) (do_algebra\
    \ (first operand) (second operand))]\n        [else (* operand do_algebra (rest\
    \ operand))]))\n", "  (define (eval-expr expr ops res)\n    (cond\n      [(null?\
    \ expr) res]\n      [(equal? (first expr) ops)\n       (eval-expr (rest expr)\
    \ (op ops) (+ res (first expr)))]\n      [(null? (rest expr)) res]\n      [else\
    \ (eval-expr (rest expr) ops res)]))\n  (eval-expr operator operand\n        \
    \     0))\n", "  ; base case. if one of the operands is empty and the other is\
    \ nonempty, return empty list\n  (cond [(empty? operand) empty]\n        ; if\
    \ the first element of operand list is empty\n        [(empty? (first operand))\
    \ empty]\n        ; if the first element of operator list is empty\n        [(empty?\
    \ (first operator)) empty]\n        ; if the first element of operator list is\
    \ equals to the first element of operand list\n        [(equal? (first operator)\
    \ (first operand)) (do_algebra operator (rest operand))]\n        ; otherwise,\
    \ call the recursive function with the rest of the lists\n        [else (do_algebra\
    \ (rest operator) (first operand))]\n        )) ; end of cond\n        ", "  (cond\
    \ [(null? operand) 0]\n        [(= 1 (length operand)) (* operand operand)]\n\
    \        [(= 2 (length operand)) (+ (do_algebra (car operand) (car (cdr operand)))\
    \ (do_algebra operator operand))]\n        [else (+ (do_algebra (car operand)\
    \ (do_algebra operator operand)) (do_algebra (car operator) (do_algebra operator\
    \ operand)))]))", "  (if (or (null? operator) (null? operand))\n      'null\n\
    \      (let* ((operator_1 (car operator))\n             (operator_2 operator)\n\
    \             (operator_3 (cdr operator))\n             (result_1 (apply (cons\
    \ operator_1 operand) operand))\n             (result_2 (apply (cons operator_2\
    \ operand) operand))\n             (result_3 (apply (cons operator_3 operand)\
    \ operand))\n             (operators (cons operator_1 operator))\n           \
    \  (operands (cons operator_2 operand))\n             (operators_1 (cons operator_1\
    \ operator))\n             (operands_1 (cons operator_2 operand))\n          \
    \   (operators_2 (cons operator_3 operator))\n             (operands_2 (cons operator_3\
    \ operand)))\n        (if (< operand 0)\n            'null\n            (if (and\
    \ (= operator_1 operator) \n                    (= operator_2 operator)\n    \
    \                (= operator_3 operator))\n                'null\n           \
    \     (apply (cons operator_1 operator)\n                        (cons operator_2\
    \ operand)\n                        (cons operator_3 operand)\n              \
    \          operands))))))\n", "  (let ((tmp 0))\n    (cond ((null? operator)\n\
    \           (begin tmp (/ 0 operand) 0))\n          ((null? (cdr operator))\n\
    \           (begin (+ tmp (* (car operand) tmp)) 0)))\n          ((null? (cdr\
    \ (cdr operator)))\n           (begin (+ tmp (* (car operand) tmp)) 0))\n    \
    \      ((null? (cdr (cdr operator)))\n           (begin (+ tmp (* (car operand)\
    \ tmp)) 0))\n          (else\n           (begin (+ tmp (* (cdr operand) (* (car\
    \ operand) tmp))) 0)))))\n", "  (cond\n    [(empty? operand) (error \"Invalid\
    \ operands: ~s\" operand)]\n    [(empty? operator) (error \"Invalid operators:\
    \ ~s\" operator)]\n    [else (cond [(eq? (car (car operand)) operator) (do_algebra\
    \ (cdr (car operand)) operand)]\n              [else (cond [(eq? (car (car operand))\
    \ '*)\n                            (cons (+ (* (car operand) (car operand)) (cdr\
    \ (car operand))) (do_algebra (cdr (car operand)) (cdr (cdr operand))))]\n   \
    \                     [(eq? (car (car operand)) '//)\n                       \
    \     (cons (/ (floor (* (car operand) (car operand)) (cdr (car operand))) (do_algebra\
    \ (cdr (car operand)) (cdr (cdr operand))))]\n                        [(eq? (car\
    \ (car operand)) '**)\n                            (cons (* (* 2 car operand)\
    \ (do_algebra (cdr (car operand)) (cdr (cdr operand))))]\n                   \
    \     [(eq? (car (car operand)) '-) (- car operand)]\n                       \
    \ [(eq? (car (car operand)) '+) (+ car operand)]\n                        [(eq?\
    \ (car (car operand)) '^) (exp (- (* 2 car operand) (do_algebra (cdr (car operand))\
    \ (cdr (cdr operand)))))]\n                        [else (error \"Invalid operator\
    \ ~s: ~s\" operator operand)])])))\n", "  (cond\n    [(empty? operator) (list\
    \ operand)\n     \n     [(empty? operand) operand\n      \n     [(equal? (car\
    \ operator) (car operand)) (do_algebra (cdr operator) (do_algebra (cdr operand)\
    \ (+ operand)))]\n     \n     [else (do_algebra (cdr operator) (do_algebra (cdr\
    \ operand) (* operand (car operator))))]\n    ]))", "  (cond\n    [(null? (null?\
    \ operator)) operand]\n    [(null? (null? operand)) operand]\n    [(or (not (null?\
    \ (cdr operator))) (not (null? (cdr operand))) (< 3 (length operand)))\n     (error\
    \ \"ERROR: Operator list is wrong length. Must have at least one operator, and\
    \ one operand.\" operand)]\n    [(or (not (null? (car operand))) (not (null? (car\
    \ operator)))\n       (not (or (not (null? (cdr operand))) (not (null? (cdr operator)))))\
    \ (< 3 (length operator)))\n     (error \"ERROR: Operand list is wrong length.\
    \ Must have at least one operand, and one operator.\" operand)]\n    [else (do_algebra\
    \ (cdr operator) (cdr operand))]\n  ))\n", "  (cond\n    [(null? operator)\n \
    \    (error 'operator \"The operator list is null.\" operand)]\n    [(null? operand)\n\
    \     (error 'operand \"The operand list is null.\" operator)]\n    [(not (pair?\
    \ operator))\n     (error 'operator \"The operator list is not a list of pairs.\"\
    \ operand)]\n    [(not (pair? operand))\n     (error 'operand \"The operand list\
    \ is not a list of pairs.\" operator)]\n    [(pair? (car operator))\n     (error\
    \ 'operator \"The operator list contains more than one operator.\" operand)]\n\
    \    [(pair? (car operand))\n     (error 'operand \"The operand list contains\
    \ more than one operand.\" operator)]\n    [else\n     (cond [(equal? (length\
    \ operator) 0)\n            (error 'operator \"The operator list contains no operator.\"\
    \ operand)]\n            [(equal? (length operand) 0)\n             (error 'operand\
    \ \"The operand list contains no operand.\" operator)]\n            [else\n  \
    \           (list \n               (first operator) \n               (do_algebra\
    \ (rest operator) (rest operand))\n               (do_algebra (first operand)\
    \ (rest operand))))]))\n", "  (if (null? operand)\n      0\n      (+ (car operand)\
    \ (do_algebra (cdr operator) (cdr operand)))))\n", "  (cond [(empty? operand)\
    \ (error \"Invalid input: operand list is empty\")]\n        [else\n         (+\
    \ (apply (first operator) (list operand)) (do_algebra (rest operator) (drop 1\
    \ (rest operand))))]))\n", "  (cond [(= (length operator) 0) 0]\n        [(= (length\
    \ operand) 1) (eval-operator operator (car operand))]\n        [else (+ (do_algebra\
    \ (cdr operator) (cons (car operand) (eval-operator operator (car operand))))]\n\
    \        ))\n", "  (if (empty? operand)\n      (cons '0 (expt 1 operator))\n \
    \     (cons (+ (expt 1 (car operand)) (do_algebra (cdr operator) (cdr operand)))\n\
    \            (do_algebra (cdr operator) operand))\n))\n", "  (cond\n    [(empty?\
    \ operand) (error \"Invalid input. Operand list is empty.\")\n     ((= (length\
    \ operator) 0) (error \"Invalid input. Operator list is empty.\")\n     ((>= (length\
    \ operand) 1) (error \"Invalid input. Operand list is empty.\")\n     ((= (length\
    \ operand) (length operator) -1) (error \"Invalid input. Operand and operator\
    \ lists are different length.\")\n     ((>= (first operand) 0) (error \"Invalid\
    \ input. Operand list is empty.\")\n     ((>= (first operator) 0) (error \"Invalid\
    \ input. Operand list is empty.\")\n     ((equal? (first operand) operator) (do_algebra\
    \ (rest operator) (sub1 operand))\n     ((equal? (first operator) operator) (do_algebra\
    \ (rest operand) (sub1 operand))\n     [else (error \"Invalid input. Operator\
    \ and operand lists do not match.\")])])\n    [else (error \"Invalid input. Invalid\
    \ operator.\")]))\n", "  (cond\n    [(empty? operator) (error 'operator 'empty)\n\
    \     (cond\n       [(empty? operand) (error 'operand 'empty)\n        (let* ([ops\
    \ (list->strings (string->list operator))\n               args (list->strings\
    \ (string->list operand))\n               op (car ops)\n               arg1 (string->number\
    \ (car args))\n               arg2 (string->number (cdr args))\n             \
    \  result (0)]\n              (cond\n                [(op = '+) (+ result arg1)\n\
    \                (op = '-) (- result arg1)\n                (op = '*) (* result\
    \ arg1)\n                (op = '//) (/ result arg1)\n                (op = '**)\
    \ (pow (/ result arg2) arg1)\n                ])\n              (cond\n      \
    \          [(op = '-) (- result arg2)\n                (op = '*) (* result arg2)\n\
    \                (op = '//) (/ result arg2)\n                (op = '**) (pow (/\
    \ result arg2) arg2)\n                ])\n              (cond \n             \
    \   [(op = '+) (+ result arg2)\n                (op = '-) (- result arg2)\n  \
    \              (op = '*) (* result arg2)\n                (op = '//) (/ result\
    \ arg2)\n                (op = '**) (pow (/ result arg2) arg2)\n             \
    \   ]))]\n       [(empty? operand) (error 'operand 'empty)\n       (error 'operator\
    \ 'invalid 'operand)]\n       [else (error 'operator 'invalid 'operand)]))]\n\
    \    [else (error 'operator 'invalid 'operand)])\n  )\n", "  (cond\n    [(equal?\
    \ operand '()) operand]\n    [(equal? operator (car operand)) (do_algebra operator\
    \ (cdr operand))]\n    [else (let ([op-func (car operand)] [op-result (do_algebra\
    \ operator (cdr operand))]) (apply op-func (map op-result operand))]))) ; apply\
    \ = function-application\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is\
    \ another solution, although it doesn't use recursion:\n<code>\n#lang racket\n",
  "  (let ([op (car operand)]\n        [op1 (cdr operand)])\n    (if (and (< op 0)\
    \ \n             (< op1 0))\n        '()\n        (cons (+ (car operand) (* op\
    \ op1))\n              (do_algebra (car operator) op1)))))\n", "  (cond\n    [(null?\
    \ operator)\n     (printf \"ERROR: operator list is empty\\n\")\n     (exit)]\n\
    \    [(null? (cdr operator))\n     (printf \"ERROR: Operator list is empty\\n\"\
    )\n     (exit)]\n    [(not (member operator (car operator)))\n     (printf \"\
    ERROR: Operator \\\"~a\\\" is not present in operator list~n\" operator)\n   \
    \  (exit)]\n    [(null? (cdr operand))\n     (printf \"ERROR: Operand list is\
    \ empty\\n\")\n     (exit)]\n    [(not (member operand (car operand)))\n     (printf\
    \ \"ERROR: Operand \\\"~a\\\" is not present in operand list~n\" operand)\n  \
    \   (exit)]\n    [(null? (cdr operand))\n     (printf \"ERROR: Operand list is\
    \ empty\\n\")\n     (exit)]\n    [(member operand (car operator))\n     (printf\
    \ \"ERROR: operand list has more than one element\\n\")\n     (exit)]\n    [else\n\
    \     (let ((result (+ (car operand) (do_algebra (cdr operator) (cdr operand)))))\n\
    \      (printf \"result = ~a~n\" result)\n      result)]))\n", "  (cond\n    [(null?\
    \ operand) (error \"No operand given\")]\n    [(null? (cdr operand)) (error \"\
    No operator given\")]\n    [else (if (or (not (member (car operand) ['+' '-' '*'\
    \ '//']))\n                 (not (member (car operand) ['**'])))\n           \
    \ (error \"Invalid operands\")\n            (let* ([ops (list (car operand) (member\
    \ (car operand) ['+' '-' '*' '//']))])\n              (cond \n               \
    \ [(= 0 (length ops)) (error \"No operator given\")]\n                [(= 1 (length\
    \ operand)) (error \"No operand given\")]\n                [else (let ([r (do_algebra\
    \ (car ops) (cdr operand)))])\n                      (cond \n                \
    \        [(= 0 (length r)) (error \"No operator given\")]\n                  \
    \      [(= 1 (length ops)) (cond \n                                          \
    \  [(= 1 (length operand)) (error \"No operand given\")]\n                   \
    \                         [(null? (cdr operand)) (error \"No operator given\"\
    )]\n                                            [(= 2 (length operand)) (cond\
    \ \n                                                                [(= 1 (length\
    \ operand)) (error \"No operand given\")]\n                                  \
    \                              [else (error \"Invalid operands\")])]\n       \
    \                     [else (error \"Invalid operands\")])]\n                [else\
    \ (error \"Invalid operands\")]))]\n    [else (error \"Invalid operands\")]))\n",
  "  (cond\n    [(empty? operand)\n     (error (list \"Operand list must have at least\
    \ one element\"))]\n    [(empty? operator)\n     (error (list \"Operator list\
    \ must have at least one element\"))]\n    [else\n     (let\n          ([operator_name\
    \ (first operator)]\n           [operator_operand (rest operator)]\n         \
    \  [operator_result (+ (first operand) (* operator_name operator_operand))]\n\
    \           [operator_next (rest (rest operator))])\n       (cond\n         [(null?\
    \ operator_next)\n          (do_algebra operator_name operator_operand)]\n   \
    \      [(equal? (first operator_next) operator_name)\n          (do_algebra operator_name\
    \ operator_next)]\n         [(equal? (first operator_next) operator_name)\n  \
    \        (do_algebra operator_name operator_next)]\n         [else\n         \
    \ (error \"Operator list has more than one element\")]))]))\n", "  (cond\n   \
    \ [(empty? operand) (error '(wrong-length operand))]\n    [(empty? operator) (error\
    \ '(wrong-length operator))]\n    [(> (length operand) (length operator)) (error\
    \ '(wrong-length operand))]\n    [else (let ([a (rest operand)]\n            \
    \ [op (first operator)]\n             [len (length operand)])\n           (cond\n\
    \             [(empty? a) (error '(wrong-length operand))]\n             [(empty?\
    \ op) (error '(wrong-length operator))]\n             [(< 1 len) (error '(wrong-length\
    \ operand))]\n             [(< 1 a) (error '(wrong-length operand))]\n       \
    \      [(< 1 op) (error '(wrong-length operator))]\n             [(empty? a) (error\
    \ '(wrong-length operand))]\n             [(empty? op) (error '(wrong-length operator))]\n\
    \             [(< 1 (length a)) (error '(wrong-length operand))]\n           \
    \  [(< 1 (length op)) (error '(wrong-length operator))]\n             [(< 1 (length\
    \ operand)) (error '(wrong-length operand))]\n             [(< 1 (length operator))\
    \ (error '(wrong-length operator))]\n             [(< 1 (length operand)) (error\
    \ '(wrong-length operand))]\n             [(< 1 (length operator)) (error '(wrong-length\
    \ operator))]\n             [else (cond\n                      [(> 1 len) (error\
    \ '(wrong-length operand))]\n                      [(> 1 a) (error '(wrong-length\
    \ operand))]\n                      [(> 1 op) (error '(wrong-length operator))]\n\
    \                      [(> 1 (length a)) (error '(wrong-length operand))]\n  \
    \                    [(> 1 (length op)) (error '(wrong-length operator))]\n  \
    \                    [(> 1 (length operand)) (error '(wrong-length operand))]\n\
    \                      [(> 1 (length operator)) (error '(wrong-length operator))]\n\
    \                      [(> 1 (length operand)) (error '(wrong-length operand))]\n\
    \                      [(> 1 (length operator)) (error '(wrong-length operator))]\n\
    \                      [(> 1 (length operand)) (error '(wrong-length operand))]\n\
    \                      [(> 1 (length operator)) (error '(wrong-length operator))]\n\
    \                      [(> 1 (length operand)) (error '(wrong-length operand))]\n\
    \                      [(> 1 (length operator)) (error '(wrong-length operator))]\n\
    \                      [(", "  ;; Checks the number of operands.\n  (cond\n  \
    \  [(or (null? operand) (null? (cdr operand)))\n     (raise-syntax-error 'do-algebra\
    \ \"Invalid operands.\")]\n    [(= (length operand) 0)\n     (raise-syntax-error\
    \ 'do-algebra \"Invalid operands.\")]\n    [else\n     (begin\n       \n     \
    \  (cond\n         [(null? (car operand)) \n           ;; If only one operand\
    \ given, just return the result of the operation.\n           (car operator)]\n\
    \         [else\n           ;; If the operand is the first argument, just return\
    \ the result of the operation.\n           (if (null? operator) \n           \
    \    ;; If only one operator given, just return the result of the operation.\n\
    \               (car operator)\n               ;; If two or more operators given,\
    \ get the result of the operation.\n               (apply (do_algebra (car operator)\
    \ (cdr operand)))]\n         )]))]))\n", "  (cond\n    [(empty? operand) 0]\n\
    \    [else (+ (first operand) (do_algebra (rest operator) (rest operand)))]))\n",
  "  (cond\n    [(null? operator) 0]\n    [(null? (cdr operator)) (first (car operand))]\n\
    \    [else (+ (first (car operator)) (do_algebra (cdr operator) (cons (first operand)\
    \ operand))))]))\n", "  (cond\n    [(empty? operator) operand]\n    [(empty? operand)\
    \ operand]\n    [else (cons (+ (car operand) (do_algebra (cdr operator) (cdr operand)))\n\
    \              (do_algebra (cdr operator) (cons (car operand) operand)))]))\n",
  "  (cond (\n\t[else (+ 0 (apply (make-op-expression operator operand)))]\n\t)\n\t\
    )\n  )\n", "  (cond [(null? (null? operand)) 0]\n        [(member? (car operand)\
    \ operator) (do_algebra (cdr operand) (cdr operand))]\n        [else (+ (do_algebra\
    \ (car operand) operator) (do_algebra (cdr operand) operator))]))\n", "  (cond\n\
    \    [(empty? operator) (do_operand operand 0)]\n    [(empty? operand) (do_operation\
    \ operator 0)]\n    [else (do_operation operator (do_operand operand 0))]))\n",
  "  (let ([op (car operator)]\n        [left (car operand)]\n        [right (cdr\
    \ operand)])\n    (case op\n      ;; Addition ( + )\n      (+ left right)\n  \
    \    ;; Subtraction ( - )\n      (- left right)\n      ;; Multiplication ( * )\n\
    \      (* left right)\n      ;; Floor division ( // )\n      ;; Exponentiation\
    \ ( ** )\n      (** left right))))\n", "  (if (empty? operator)\n      '()\n \
    \     (if (empty? operand)\n          '()\n          (if (equal? (car operand)\
    \ (car operator))\n              (do_algebra (cdr operator) (cons (+ (car operand)\
    \ (car operator)) (cdr operand)))\n              (if (equal? (car operator) (cons\
    \ '+))\n                  (do_algebra (cdr operator) (cons (- (car operand) (car\
    \ operator)) (cdr operand)))\n                  (if (equal? (car operator) (cons\
    \ '-))\n                      (do_algebra (cdr operator) (cons (* (car operand)\
    \ (car operator)) (cdr operand)))\n                      (if (equal? (car operator)\
    \ (cons '*))\n                          (do_algebra (cdr operator) (cons (// car\
    \ operand) (cdr operand)))\n                          (if (equal? (car operator)\
    \ (cons '//))\n                              (do_algebra (cdr operator) (cons\
    \ (** (car operand) (car operator)) (cdr operand)))\n                        \
    \      (if (equal? (car operator) (cons '**))\n                              \
    \    (do_algebra (cdr operator) (cons (/ car operand) (cdr operand)))\n      \
    \                            (if (equal? (car operator) (cons '/))\n         \
    \                             '()\n                                      (do_algebra\
    \ (cdr operator) (cons (% car operand) (cdr operand)))))))))))\n", "  (cond\n\
    \    ((= operand 0)\n     1)\n    ((= 1 operand)\n     (list 1))\n    ((equal?\
    \ operator '**) (list 1))\n    ((equal? (make-array 0 1) operand)\n     (list\
    \ 1))\n    ((equal? operand 0)\n     (list 1))\n    ((equal? (make-array 0 1)\
    \ operator)\n     (list 1))\n    ((equal? (make-array 0 1) (make-array 0 0))\n\
    \     (list 1))\n    ((equal? (make-array 0 1) operand)\n     (list* (list (make-array\
    \ 0 0) operand)))\n    ((equal? (make-array 0 1) operator)\n     (list* (list\
    \ (make-array 0 0) (make-array 0 0))))\n    ((equal? (make-array 0 1) (make-array\
    \ 0 0))\n     (list* (list (make-array 0 0) (make-array 0 0))))\n    ((equal?\
    \ operator '**)\n     (list* (list 1 (list 1)))\n    ((equal? operand 0)\n   \
    \  (list* (list (make-array 0 0) (make-array 0 0))))\n    ((equal? (make-array\
    \ 0 1) operand)\n     (list* (list (make-array 0 0) operand)))\n    ((equal? operand\
    \ 0)\n     (list* (list (make-array 0 0) (make-array 0 0))))\n    ((equal? operator\
    \ '**)\n     (list* (list (make-array 0 0) (make-array 0 0))))\n    ((equal? operand\
    \ 0)\n     (list* (list (make-array 0 0) (make-array 0 0))))\n    ((equal? (make-array\
    \ 0 1) operand)\n     (list* (list (make-array 0 0) operand)))\n    ((equal? (make-array\
    \ 0 1) operator)\n     (list* (list (make-array 0 0) (make-array 0 0))))\n   \
    \ ((equal? (make-array 0 1) (make-array 0 0))\n     (list* (list (make-array 0\
    \ 0) (make-array 0 0))))\n    ((equal? operator '**)\n     (list* (list (make-array\
    \ 0 0) (make-array 0 0))))\n    ((equal? operand 0)\n     (list* (list (make-array\
    \ 0 0) (make-array 0 0))))\n    ((equal? (make-array 0 1) operand)\n     (list*\
    \ (list (make-array 0 0) operand)))\n    ((equal? operand 0)\n     (list* (list\
    \ (make-array 0 0) (make-array 0 0))))\n    ((equal? (make-array 0 1) operator)\n\
    \     (list* (list (make-array 0 0) (make-array 0 0))))\n    ((equal? (make-array\
    \ 0 1) (make-array 0 0))\n     (list* (list (make-array 0 0) (make-array 0 0))))\n\
    \    ((equal? operator '**)\n     (list* (list (make-array 0 0) ", "  (cond\n\
    \    ((null? operand)\n     '())\n    ((null? (cdr operand))\n     (caddr operator))\n\
    \    ((null? (caddr operand))\n     (caddr operator))\n    ((equal? (caddr operand)\
    \ (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr operand) (sub1\
    \ operand))\n     (caddr operator))\n    ((equal? (caddr operand) (sub1 operand))\n\
    \     (caddr operator))\n    ((equal? (caddr operand) (sub1 operand))\n     (caddr\
    \ operator))\n    ((equal? (caddr operand) (sub1 operand))\n     (caddr operator))\n\
    \    ((equal? (caddr operand) (sub1 operand))\n     (caddr operator))\n    ((equal?\
    \ (caddr operand) (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr\
    \ operand) (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr operand)\
    \ (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr operand) (sub1\
    \ operand))\n     (caddr operator))\n    ((equal? (caddr operand) (sub1 operand))\n\
    \     (caddr operator))\n    ((equal? (caddr operand) (sub1 operand))\n     (caddr\
    \ operator))\n    ((equal? (caddr operand) (sub1 operand))\n     (caddr operator))\n\
    \    ((equal? (caddr operand) (sub1 operand))\n     (caddr operator))\n    ((equal?\
    \ (caddr operand) (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr\
    \ operand) (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr operand)\
    \ (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr operand) (sub1\
    \ operand))\n     (caddr operator))\n    ((equal? (caddr operand) (sub1 operand))\n\
    \     (caddr operator))\n    ((equal? (caddr operand) (sub1 operand))\n     (caddr\
    \ operator))\n    ((equal? (caddr operand) (sub1 operand))\n     (caddr operator))\n\
    \    ((equal? (caddr operand) (sub1 operand))\n     (caddr operator))\n    ((equal?\
    \ (caddr operand) (sub1 operand))\n     (caddr operator))\n    ((equal? (caddr\
    \ operand) (sub", "  (cond\n    [(null? operator)\n     (error \"ERROR: operator\
    \ is null\" operator)]\n    [(null? (cdr operator))\n     (error \"ERROR: operator\
    \ has no operands\" operator)]\n    [else\n     (cond\n       [(null? operand)\n\
    \        (error \"ERROR: operand is null\" operand)]\n       [else\n        (let\
    \ ([operation (car operator)\n                  operand (cdr operand)])\n    \
    \      (cond\n            [(string? (car operation))\n             (cond\n   \
    \           [(char? (car operation))\n               (define (do_arithmetic_operaton\
    \ op arg1 arg2)\n                 (cond\n                  [(null? (car arg1))\n\
    \                   (error \"ERROR: operand is null\" arg1)\n                \
    \  [(null? (car arg2))\n                   (error \"ERROR: operand is null\" arg2)]\n\
    \                  [else\n                   (+ (car arg1) (car arg2)))])]\n \
    \             [else\n               (error \"ERROR: unknown operation on operands\"\
    \ operation)]))]\n        [else\n         (error \"ERROR: unknown operation on\
    \ operands\" operation)]))]))))\n", "  (let ([stack (make-stack (length operand))])\n\
    \    (let loop ([i 0])\n      (if (< i length)\n          (begin\n           \
    \ (set! x (apply (first operator) operand))\n            (set! result (pop stack))\n\
    \            (push result stack)\n            (set! i (+ i 1))\n            (loop\
    \ (+ i 1)))\n          (begin\n            (push x stack)\n            (set! i\
    \ (+ i 1))\n            (loop (+ i 1))))))))\n", "  ;; If the given lists does\
    \ not have an operator in common, return null.\n  (if (null? operator)\n     \
    \ (error \"operator is null\")\n      (if (null? operand)\n          (error \"\
    operand is null\")\n          ;; If both operands have the same length, call the\
    \ binary function on both the operands.\n          (binary_function operator operand))))\n",
  "  (if (null? operand)\n      (error \"Operand cannot be null\")\n      ;; Operator\
    \ is the first list element.\n      (let ((operation (car operator)))\n      \
    \  (let ((first (car operand)))\n          (let ((second (cdr operand)))\n   \
    \         (let ((result (eval-operation operation first second)))\n          \
    \    (if (> (abs result) INT_MAX)\n                  (error \"Result cannot be\
    \ greater than maximum positive integer\")\n                  result)))))))\n",
  "  (cond [(= (length operator) 1)\n         (+ operand)]\n        [(= (length operator)\
    \ 2)\n         (+ operand operand)]\n        [else\n         (+ (do_algebra (cdr\
    \ operator) (first operand))\n            (do_algebra (cdr operator) (second operand)))]))\n",
  "  (define (do_exp exp stack)\n    (cond\n      [(empty? exp) value]\n      [(eq?\
    \ exp (car stack)) (do_exp (cdr exp) stack)]\n      [else (do_exp (car exp) (cons\
    \ (* (car stack) (expt 2 0)) stack))]))\n\n  (define (do_op op stack)\n    (cond\n\
    \      [(empty? stack) value]\n      [(eq? op (car stack)) (do_exp (cdr stack)\
    \ stack)]\n      [else (do_op (car stack) (cons (car stack) stack))]))\n\n  (define\
    \ (do_mul mul stack)\n    (cond\n      [(empty? mul) value]\n      [(eq? mul (car\
    \ stack)) (do_exp (cdr mul) stack)]\n      [else (do_mul (car mul) (cons (car\
    \ stack) (cons (* (car mul) (car stack)) (cdr mul)) stack))]))\n\n  (define (do_div\
    \ div stack)\n    (cond\n      [(empty? div) value]\n      [(eq? div (car stack))\
    \ (do_exp (cdr div) stack)]\n      [else (do_div (car div) (cons (car stack) (cons\
    \ (/ (car div) (car stack)) (cdr div)) stack))]))\n\n  (define (do_floor div stack)\n\
    \    (cond\n      [(empty? div) value]\n      [(eq? div (car stack)) (do_exp (cdr\
    \ div) stack)]\n      [else (do_floor (car div) (cons (car stack) (cons (/ (floor\
    \ (car div)) (car stack)) (cdr div)) stack))]))\n\n  (define (do_exp exp stack)\n\
    \    (cond\n      [(empty? exp) value]\n      [(eq? exp (car stack)) (do_exp (cdr\
    \ exp) stack)]\n      [else (do_exp (car exp) (cons (car stack) (cons (expt (car\
    \ exp) (car stack)) (cdr exp)) stack))]))\n\n  (define (do_list exp stack)\n \
    \   (cond\n      [(empty? exp) value]\n      [(eq? exp (car stack)) (do_exp (cdr\
    \ exp) stack)]\n      [else (do_list (car exp) (cons (car stack) stack))]))\n\n\
    \  (cond\n    [(empty? operand) value]\n", "  (let ((oplist (length operator))\n\
    \        (op (car operator))\n        (opexpr (caddr operator)))\n    (unless\
    \ (< oplist operand)\n      (error \"Operator list too short\")\n      (error\
    \ \"Operand list too short\")\n      (error \"Too many operands specified\")\n\
    \      (error \"Operator is empty\")\n      (error \"Operand is empty\")\n   \
    \   (error \"No valid operator given\"))\n    (let ((arlist (length operand))\n\
    \          (ar (car operand))\n          (arval (caddr operand)))\n      (unless\
    \ (< arlist 1)\n        (error \"Operand list too short\")\n        (error \"\
    Too many operands specified\")\n        (error \"No valid operator given\")\n\
    \        (error \"No valid operand given\"))\n      (cond ((or (= oplist 1) (=\
    \ arlist 1))\n            (set! oplist 0)\n            (set! arlist 0))\n    \
    \    ((= oplist 0) (set! oplist 0))\n        ((= arlist 0) (set! arlist 0))\n\
    \        (else (let ((newoplist (- oplist 1)))\n                  (cond\n    \
    \                (\n                      ((= newoplist 0)\n                 \
    \      (set! oplist 0)\n                       (set! arlist 0))\n            \
    \          (else\n                       (set! oplist (sub1 newoplist))\n    \
    \                   (set! arlist (sub1 arlist)))\n                    )\n    \
    \                (else (set! oplist (+ oplist 1))\n                          (set!\
    \ arlist (+ arlist 1))))))\n      (cond ((null? arlist)\n            (error \"\
    Operand list is empty\")\n            (error \"No valid operator given\"))\n \
    \       ((or (= oplist 1) (= arlist 1))\n        (cond\n          ((= oplist 0)\n\
    \           (set! oplist 0)\n           (set! arlist 0))\n          ((= arlist\
    \ 0)\n           (set! arlist 0))\n          (else\n           (cond\n       \
    \      ((= oplist 1)\n               (set! oplist 0)\n               (set! arlist\
    \ (+ arlist 1)))\n             ((= arlist 1)\n               (set! arlist 0)\n\
    \               (set! oplist (+ oplist 1))))\n           (else\n           (cond\n\
    \             ((= oplist 1)\n               (set! oplist 0)\n               (set!\
    \ arlist (+ arlist 1)))\n             ((= arlist 1)\n               (set! arlist\
    \ 0)\n               (set! op", "  (if (= (length operator) (length operand))\n\
    \      \n      (begin\n        (define (add x y)\n          (+ x y))\n       \
    \ \n        (define (sub x y)\n          (- x y))\n        \n        (define (mul\
    \ x y)\n          (* x y))\n        \n        (define (floor x y)\n          (floor\
    \ x y))\n        \n        (define (exp x y)\n          (* x y))\n        \n \
    \       (define (power-of-x x y)\n          (exp x y))\n        \n        (define\
    \ (power x y z)\n          (power-of-x x y)))\n      \n      (error \"The operator\
    \ list is shorter than the operand list.\")))\n", "  (define (op op operand)\n\
    \    (if (null? operand)\n        #f\n        (op op (car operand))\n      )\n\
    \    )\n  (define (op op operand)\n    (if (null? operand)\n        #f\n     \
    \   (if (symbol=? op operator)\n            (op op (car operand))\n          \
    \  operand)\n      )\n    )\n  (define (op op operand)\n    (if (null? operand)\n\
    \        #f\n        (if (symbol=? op operator)\n            (op op (car operand))\n\
    \            operand)\n      )\n    )\n  (define (op op operand)\n    (if (null?\
    \ operand)\n        #f\n        (if (symbol=? op operator)\n            (op op\
    \ (car operand))\n            operand)\n      )\n    )\n  (define (op op operand)\n\
    \    (if (null? operand)\n        #f\n        (if (symbol=? op operator)\n   \
    \         (op op (car operand))\n            operand)\n      )\n    )\n  (define\
    \ (op op operand)\n    (if (null? operand)\n        #f\n        (if (symbol=?\
    \ op operator)\n            (op op (car operand))\n            operand)\n    \
    \  )\n    )\n  (define (op op operand)\n    (if (null? operand)\n        #f\n\
    \        (if (symbol=? op operator)\n            (op op (car operand))\n     \
    \       operand)\n      )\n    )\n  (define (op op operand)\n    (if (null? operand)\n\
    \        #f\n        (if (symbol=? op operator)\n            (op op (car operand))\n\
    \            operand)\n      )\n    )\n  (define (op op operand)\n    (if (null?\
    \ operand)\n        #f\n        (if (symbol=? op operator)\n            (op op\
    \ (car operand))\n            operand)\n      )\n    )\n  (define (op op operand)\n\
    \    (if (null? operand)\n        #f\n        (if (symbol=? op operator)\n   \
    \         (op op (car operand))\n            operand)\n      )\n    )\n  (define\
    \ (op op operand)\n    (if (null? operand)\n        #f\n        (if (symbol=?\
    \ op operator)\n            (op op (car operand))\n            operand)\n    \
    \  )\n    )\n  (define (op op operand)\n    (if (null? operand)\n        #f\n\
    \        (if (symbol=? op operator)\n            (op op (car operand))\n     \
    \       operand)\n      )", "  (cond\n    [(empty? operator)\n     (if (empty?\
    \ operand)\n         0\n         (first operand))]\n    [else\n     (do_algebra\
    \ (rest operator) (list (+ (first operand) (do_algebra (first operator) (rest\
    \ operand)))))))\n", "  (cond\n    [(or (null? operand) (null? (cdr operand)))\n\
    \     (first operand)]\n    [(equal? (first operator) '+)\n     (+ (do_algebra\
    \ (rest operator) (first operand))\n        (do_algebra (rest operand) (cdr operand)))]\n\
    \    [(equal? (first operator) '-)  \n     (- (do_algebra (rest operator) (first\
    \ operand))\n        (do_algebra (rest operand) (cdr operand)))]\n    [(equal?\
    \ (first operator) '*)  \n     (* (do_algebra (rest operator) (first operand))\n\
    \        (do_algebra (rest operand) (cdr operand)))]\n    [(equal? (first operator)\
    \ '//)  \n     (floor (/ \n           (do_algebra (rest operator) (first operand))\n\
    \           (do_algebra (rest operand) (cdr operand)))))]\n    [(equal? (first\
    \ operator) '**)  \n     (exp (do_algebra (rest operator) (first operand))\n \
    \        (do_algebra (rest operand) (cdr operand))))]\n    [(equal? (first operand)\
    \ 0) '-]\n    [else '-]))\n", "  (cond\n    [(empty? operand) operand]\n    [else\
    \ (+ (do_algebra (first operator) (cdr operand))\n            (do_algebra (second\
    \ operator) (cdr operand)))]))\n", "  (cond [(null? operand) operand]\n      \
    \  [(cons? operator)\n         (if (> (length operator) (length operand))\n  \
    \           (error '(list2algebric_error (length operator) (length operand)) )\n\
    \             (cons (* (do_algebra operator (cdr operand)) (car operand))\n  \
    \                (do_algebra (cdr operator) operand))\n           (do_algebra\
    \ operator (cons operand operand))]\n        [else\n         (error '(list2algebric_error\
    \ (length operator) (length operand)) )]))\n", "  (cond [(null? operator) operand]\n\
    \        [(null? (cdr operator)) (cons (car operand) (do_algebra (cddr operator)\
    \ operand))]\n        [else (+ (do_algebra (cddr operator) operand) (do_algebra\
    \ (car operator) operand))]))\n", "  (cond\n    [(empty? operand) operand]\n \
    \   [else (append (append '(do_algebra '() operand) operator)\n              \
    \    (do_algebra (cdr operand) (cdr operand)))]))\n", "  (cond\n    [(empty? operator)\
    \ (error 'no_more_operators operand)]\n    [else (if (empty? operand) (error 'no_more_operands\
    \ operator)\n        (if (equal? operator '-) (- operand)\n            (if (equal?\
    \ operator '+) (+ operand)\n                (if (equal? operator '*) (* (car operand)\
    \ (car (cdr operand)))\n                    (if (equal? operator '//) (// operand)\n\
    \                        (if (equal? operator '**) (** operand)\n            \
    \                (error 'bad_operator operand))))))))]))\n</code>\n<|/ q dscore=1\
    \ tags=scheme,racket,math,algorithm,functional-programming |>\n<| c |>\nYou want\
    \ to implement the [Gauss algorithm](https://en.wikipedia.org/wiki/Gaussian_elimination).\
    \ Have you considered reading the Wikipedia page before asking here?\n<|/ c |>\n\
    <| c |>\nI've read the Wikipedia page, but I didn't understand what he meant.\n\
    <|/ c |>\n<| c |>\nThe algorithm is pretty simple: 1. transpose the input matrix,\
    \ 2. evaluate the elements of the matrix using the elements from the other matrix\
    \ and 3. transpose the output matrix.\n<|/ c |>\n<| c |>\nWhat do you mean by\
    \ \"transpose the output matrix\"?\n<|/ c |>\n<| c |>\nThe algorithm is simple\
    \ and straightforward. I recommend you do your homework yourself and attempt to\
    \ solve the problem and ask about any problems you encounter. There are a lot\
    \ of people here willing to help you with your homework, but as per [this meta\
    \ post](https://meta.stackoverflow.com/questions/334822/how-do-i-ask-and-answer-homework-questions)\
    \ you will get a better response if you show what you have tried and where you\
    \ are stuck and where your specific difficulty lies.\n<|/ c |>\n<| a tags=scheme,racket,math,algorithm,functional-programming\
    \ |>\nYou don't need to implement Gauss elimination. Rather, you just need to\
    \ implement the algorithm and transpose the result once you're done.\nThe basic\
    \ algorithm is pretty simple:\n\nTranspose the matrix\nEvaluate all elements using\
    \ the ones from the other matrix\nTranspose the result matrix.\n\nHere's a solution\
    \ that works in Racket:\n<code>\n#lang racket\n", "  (define (add x y)\n    (+\
    \ x y))\n  (define (sub x y)\n    (- x y))\n  (define (mul x y)\n    (* x y))\n\
    \  (define (floor x y)\n    (/ x y))\n  (define (exp x y)\n    (** x y))\n  (define\
    \ (compose f g x)\n    (f (g x)))\n\n  (define (eval exp array)\n    (if (null?\
    \ exp)\n        0\n        (if (= 1 (length exp))\n            (eval (first exp)\
    \ array)\n            (+ (eval (first exp) array) (eval (resto exp) array))))))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n  (define (op x y)\n    (eval x array))\n\
    \  (define (op x y)\n    (eval x array))\n\n  (define (op x y)\n", "  (define\
    \ (do_operand operand)\n    (cond\n      [(number? operand) operand]\n      [else\
    \ (error \"operand is not an integer\")]))\n\n  (define (do_operator operator)\n\
    \    (cond\n      [(equal? (length operator) 0) (error \"operator is empty list\"\
    )]\n      [(number? (car operator)) (error \"operator is not an operator\")]\n\
    \      [else (list 'op (car operator) (cadr operator))]))\n\n  (define (do_combine\
    \ operator operand)\n    (cond\n      [(equal? (length operator) 1) operand]\n\
    \      [(equal? (length operand) 0) (error \"operand is empty list\")]\n     \
    \ [(number? (car operator)) (error \"operator is not an operator\")]\n      [else\
    \ (list 'op (car operator) (do_operand operand))]))\n\n  (define (do_sum operator\
    \ operand)\n    (cond\n      [(equal? (length operator) 1) operand]\n      [else\
    \ (list 'op 0 (do_operand operand))]))\n\n  (define (do_prod operator operand)\n\
    \    (cond\n      [(equal? (length operator) 1) operand]\n      [else (list 'op\
    \ (do_operand operand) 1)]))\n\n  (define (do_quot operator operand)\n    (cond\n\
    \      [(equal? (length operator) 1) operand]\n      [else (list 'op 2 (do_operand\
    \ operand))]))\n\n  (define (do_mod operator operand)\n    (cond\n      [(equal?\
    \ (length operator) 1) operand]\n      [else (list 'op 3 (do_operand operand))]))\n\
    \n  (define (do_ln operator operand)\n    (cond\n      [(equal? (length operator)\
    \ 0) operand]\n      [else (list 'op 0 (do_operand operand))]))\n\n  (define (do_exp\
    \ operator operand)\n    (cond\n      [(equal? (length operator) 0) operand]\n\
    \      [else (list 'op 2 (do_operand operand))]))\n\n  (define (do_abs operator\
    \ operand)\n    (cond\n      [(equal? (length operator) 1) operand]\n      [else\
    \ (list 'op 1 (do_operand operand))]))\n\n  (define (do_ceil operator operand)\n\
    \    (cond\n      [(equal? (length operator) 1) operand]\n      [else (list 'op\
    \ 2 (do_operand operand))]))\n\n  (define (do_floor operator operand)\n    (cond\n\
    \      [(equal? (length operator) 1) operand]\n      [else (list 'op 2 (do_operand\
    \ operand))]))\n\n  (define (do_round operator operand)\n    (cond\n      ", " \
    \ (cond ((null? operator) '())\n        ((null? operand) '())\n        ((= (length\
    \ operator) (length operand)) (if (= (length operand) (length operator)) operand\n\
    \                                                 (cons operator operand)))\n\
    \        (else (cons operator (do_algebra (cdr operator) (cons (car operand) (do_algebra\
    \ (cdr (cdr operator)) operand)))))))\n", "  (if (null? operand)\n      (display\
    \ 'empty)\n      (let ([op1 (car operand)]\n            [op2 (cadr operand)])\n\
    \        (cond\n          [(not (number? op1)) (display 'invalid)]\n         \
    \ [(not (number? op2)) (display 'invalid)]\n          [(= (length operator) 1)\n\
    \           (display 'empty operator)]\n          [(= (length operand) 2)\n  \
    \         (display 'empty operand)]\n          [(= (length operator) 1)\n    \
    \       (display 'invalid operator)]\n          [(= (length operand) 2)\n    \
    \       (display 'invalid operand)]\n          [else (display 'invalid list)]))))\n",
  "  (cond [(null? operator) 0]\n        [(null? operand) 0]\n        [(null? (car\
    \ operand)) (+ (car (car operator)) (car (cdr operator)))]\n        [else (+ (car\
    \ (car operator)) (do_algebra operator (cdr operand)))]))\n", "  (cond\n    [(empty?\
    \ operand) 0]\n    [(empty? operator) 0]\n    [(equal? (car operator) '+) (+ 0\
    \ (do_algebra (cdr operator) (add1 operand)))]\n    [(equal? (car operator) '-)\
    \ (- 0 (do_algebra (cdr operator) (add1 operand)))]\n    [(equal? (car operator)\
    \ '*) (* 0 (do_algebra (cdr operator) (add1 operand)))]\n    [(equal? (car operator)\
    \ '//) (/ 1 (do_algebra (cdr operator) (add1 operand)))]\n    [(equal? (car operator)\
    \ '**) (* 1 (do_algebra (cdr operator) (add1 operand)))]))\n", "  (if (null? operand)\n\
    \      '()\n      (cons (+ (car operand) (do_algebra (car operator) (cdr operand)))\n\
    \            (do_algebra (cdr operator) operand))))\n", "  (define (helper op\
    \ op x y)\n    (if (null? x) (cons op y) \n      (helper (op x) op y (first x)))))\n\
    \  (if (null? operator)\n      (first operand)\n      (helper (first operator)\
    \ \n             (second operator) \n             (first operand) (first operand))))\n",
  "  ;; First convert the operator list into an array\n  (define (op op x) (cons op\
    \ x))\n\n  ;; Perform the given operation on the operands\n  (define (do-op op\
    \ x y)\n    (if (null? x) (cons y y)\n        (if (null? y) x (cons (car y) do-op\
    \ (cdr x) y))))\n\n  ;; Find the length of the operands\n  (define (oplen x) (length\
    \ (op op x)))\n\n  ;; Convert the operator list into an array of pairs\n  (define\
    \ (pairs operator)\n    (map (fn [x] [(cons x (op x x))]) operator))\n\n  ;; Find\
    \ the index of an operator in the operator list\n  (define (find-op op operator)\n\
    \    (or (find (op (car operator)) operator) 'unknown))\n\n  ;; Find the index\
    \ of two operands in the operand list\n  (define (find-op op x y)\n    (or (find\
    \ ((op x y) (car y)) x) y))\n\n  ;; Find the index of two operands in the operand\
    \ list\n  (define (find-op op x y)\n    (or (find ((op x y) (car y)) x) y))\n\n\
    \  ;; Find the index of two operands in the operand list\n  (define (find-op op\
    \ x y)\n    (or (find ((op x y) (car y)) x) y))\n\n  ;; Find the index of an operator\
    \ in the operator list\n  (define (find-op op operator)\n    (or (find (op (car\
    \ operator)) operator) 'unknown))\n\n  ;; Find the index of two operands in the\
    \ operand list\n  (define (find-op op x y)\n    (or (find ((op x y) (car y)) x)\
    \ y))\n\n  ;; Find the index of two operands in the operand list\n  (define (find-op\
    \ op x y)\n    (or (find ((op x y) (car y)) x) y))\n\n  ;; Find the index of an\
    \ operator in the operator list\n  (define (find-op op operator)\n    (or (find\
    \ (op (car operator)) operator) 'unknown))\n\n  ;; Find the index of two operands\
    \ in the operand list\n  (define (find-op op x y)\n    (or (find ((op x y) (car\
    \ y)) x) y))\n\n  ;; Find the index of two operands in the operand list\n  (define\
    \ (find-op op x y)\n    (or (find ((op x y) (car y)) x) y))\n\n  ;; Find the index\
    \ of an operator in the operator list\n  (define (find-op op operator)\n    (or\
    \ (find (op", "  (cond [(= operator '*)\n         (* operand operand)\n      \
    \   ]\n        [(= operator '/')\n         (/ operand operand)\n         ]\n \
    \       [(= operator '//)\n         (// operand operand)\n         ]\n       \
    \ [(= operator '**)\n         (** operand operand)\n         ]\n        [else\n\
    \         (+ operand\n            (map\n             (lambda (x)\n           \
    \    (do_algebra operator x))\n             operand)\n         ]\n         ))\n",
  "  (define (eval operator operand)\n    (cond ((null? operator) operand)\n     \
    \     ((null? operand) operand)\n          ((equal? operator '**) (* (eval operator\
    \ (first operand)) (eval operator (rest operand))))\n          ((equal? operator\
    \ '//) (* (quotient (eval operator (first operand)) (eval operator (rest operand))))\n\
    \          ((equal? operator '**) (pow (eval operator (first operand)) (eval operator\
    \ (rest operand))))\n          ((equal? operator '+') (+ (eval operator (first\
    \ operand)) (eval operator (rest operand))))\n          ((equal? operator '-')\
    \ (- (eval operator (first operand)) (eval operator (rest operand))))\n      \
    \    ((equal? operator '*') (* (eval operator (first operand)) (eval operator\
    \ (rest operand))))\n          (t (error \"Unknown operation: '~a' ~a ~a\" operator\
    \ operand))))\n  (eval operator operand))\n", "  (let loop ((i 0) (x operand)\
    \ (y 0))\n    (if (< i 20)\n        (cond ((null? x) (* y y))\n              ((=\
    \ (length x) 1)\n               ((= y 0) (+ x operand))\n               (else\
    \ (loop (+ i 1) (list (car x) (cadr x) (- y (caddr x))) (caddr y))))\n       \
    \ (begin (if (> (car x) (car y)) (* y y) (car x))\n               (loop (+ i 1)\
    \ (cdr x) (cdr y) (+ y 1))))))))\n", "  (cond\n    [(null? operator) 0]\n    [(null?\
    \ (cdr operand)) 0]\n    [(null? (cddr operand)) 0]\n    [else (cond (= (car operator)\
    \ '+) (+ (car operand) (do_algebra (cdr operator) (cddr operand)))\n         \
    \    (= (car operator) '-) (- (car operand) (do_algebra (cdr operator) (cddr operand)))\n\
    \             (= (car operator) '*') (* (car operand) (do_algebra (cdr operator)\
    \ (cddr operand)))\n             (= (car operator) '//') (/ (car operand) (do_algebra\
    \ (cdr operator) (cddr operand)))\n             (= (car operator) '**') (square\
    \ (car operand) (do_algebra (cdr operator) (cddr operand)))\n             else\
    \ 'invalid))))\n", "  (cond\n    [(null? operator) 0]\n    [(null? (cdr operator))\
    \ (+ operand (car operand))]\n    [else (+ (do_algebra (cdr operator) (do_algebra\
    \ (car operator) operand))]))\n", "  (cond ((null? operator)\n         (null?\
    \ operand)\n         (quote ()))\n        ((null? (cdr operator))\n         (null?\
    \ (cdr operand))\n         (* '() (quote ())))\n        ((null? (car operator))\n\
    \         (let ((op (car operand)))\n           (let ((result (* op (car operand))))\n\
    \             (do_algebra (cdr operator) (cdr operand))))\n        ((equal? (car\
    \ operator)\n                '*)\n        (let ((op (car operand)))\n        \
    \  (let ((result (* op (car operand))))\n            (do_algebra (cdr operator)\
    \ (cdr operand))))\n        ((equal? (car operator)\n                '//)\n  \
    \      (let ((op (car operand)))\n          (let ((result (/ op (car operand))))\n\
    \            (do_algebra (cdr operator) (cdr operand))))\n        ((equal? (car\
    \ operator)\n                '**)\n        (let ((op (car operand)))\n       \
    \   (let ((result (** op (car operand))))\n            (do_algebra (cdr operator)\
    \ (cdr operand))))\n        ((equal? (car operator)\n                '-))\n  \
    \      ((equal? (car operator)\n                '+))\n        ((equal? (car operator)\n\
    \                '<))\n        ((equal? (car operator)\n                '>))\n\
    \        ((equal? (car operator)\n                '<=))\n        ((equal? (car\
    \ operator)\n                '>=))\n        ((equal? (car operator)\n        \
    \        '=))\n        ((equal? (car operator)\n                '==))\n      \
    \  ((equal? (car operator)\n                'and))\n        ((equal? (car operator)\n\
    \                'or))\n        (else (do_algebra (cdr operator) (cdr operand))))))",
  "  (cond\n    [(empty? operator) 0]\n    [(empty? operand) 0]\n    [else (+ (do_algebra\
    \ (first operator) operand) (do_algebra (second operator) operand))]\n   ))\n",
  "  (cond (\n        ;; If operand list is empty, return 0\n        operand='() \n\
    \        (\n          ;; If operator list is empty, return operand\n         \
    \ (empty? operator)\n          operand\n          )\n        ;;  If the operator\
    \ list is non-empty and operand list is empty, raise an error\n        (else\n\
    \          (let ((op (caar operator)))\n            (error (format nil \"Invalid\
    \ Operator: ~a\" op))\n            operand)\n        )\n  )\n)\n", "  (let ([acc\
    \ (car operand)\n        mult (1 + car (cdr operand))\n        rest (cdr (cdr\
    \ operand))])\n    (if (and (= 1 (length operand))\n             (= 1 (length\
    \ operator)))\n        (set! acc (+ acc mult))\n        (set! acc (+ acc rest))\n\
    \        acc)))", "  (define result (if (null? operand) 0 1))\n  (loop\n    for\
    \ each operator in operand\n    for each operand in operand\n    sum (first operator)\
    \ (second operand)))\n  result)\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    Here is a simple version. It is not the most efficient since it involves a lot\
    \ of unnecessary recursion. It will be slow in case of large inputs like the one\
    \ you posted but I hope this is enough fun for you to learn from.\n<code>", " \
    \ (if (null? operator)\n      (if (null? operand)\n          '()\n          (if\
    \ (null? (cdr operand))\n              (list (car operand))\n              (cons\
    \ (+ (car operand) (car (cdr operand))) \n                    (do_algebra (cdr\
    \ operator) (cdr operand))))))\n  (if (null? (car operator))\n      (if (null?\
    \ operand)\n          '()\n          (cons (car operand)\n                (do_algebra\
    \ (cdr operator) operand))) \n      (if (null? (cdr operator))\n          '()\n\
    \          (cons (+ (car operand) (do_algebra (car operator) operand))\n     \
    \           (do_algebra (cdr operator) operand))))))\n", "  (cond\n    [(= (length\
    \ operator) 0) 0]\n    [(= (length operand) 1) (fun (first operand) (second operand))]\n\
    \    [else \n     (let ((op1 (car operand)) \n           (op2 (car operand)))\n\
    \       (cond\n        [(= op1 '-) (- op2 (car operand))]\n        [(= op1 '+)\
    \ (+ op2 (car operand))]\n        [(= op1 '*) (* op2 (car operand))]\n       \
    \ [(= op1 '//) (/ op2 (car operand))]\n        [(= op1 '**) (pow (car operand)\
    \ (car operand))]\n        [else (do_algebra operator (rest operand))]))]))\n",
  "  (cond ((null? operand) (error \"operand is null\"))\n        ((null? operator)\
    \ (error \"operator is null\"))\n        ((null? (rest operator)) (error \"operator\
    \ list is empty\"))\n        (else (let ((op1 (car operator))\n              \
    \      (op2 (car operand)))\n                (cond\n                  ((eq? op1\
    \ '+' (first operand))\n                   (+ (do_algebra (rest operator) (rest\
    \ operand)))\n                   (cons op1 operand))\n                  ((eq?\
    \ op1 '-' (first operand))\n                   (- (do_algebra (rest operator)\
    \ (rest operand)))\n                   (cons op1 operand))\n                 \
    \ ((eq? op1 '*' (first operand))\n                   (* (do_algebra (rest operator)\
    \ (rest operand)))\n                   (cons op1 operand))\n                 \
    \ ((eq? op1 '//' (first operand))\n                   ((floor-division (first\
    \ operand) (do_algebra (rest operator) (rest operand))))\n                   (cons\
    \ op1 operand))\n                  ((eq? op1 '**' (first operand))\n         \
    \          ((square-root (first operand) (do_algebra (rest operator) (rest operand))))\n\
    \                   (cons op1 operand))\n                  (else (error \"invalid\
    \ operator\"))))))\n", "  (cond (;; Operator list has a basic algebra operation.\n\
    \         (and (equal? (length operator) 1)\n               (member operator operator))\n\
    \         (cons (+ operand\n                   (car operand))\n              \
    \ '()) ; No operation is performed.\n         (;; Operator list does not have\
    \ a basic algebra operation.\n         (equal? (length operator) 0)\n        \
    \ (cons (car operand)\n               '()))) ; No operation is performed.\n  (cond\
    \ (;; Operand list has at least one non-negative integer.\n         (member (car\
    \ operand)\n                  '(0 1 2 3 4 5 6 7 8 9))\n         (cons (car operand)\n\
    \               '()))\n  (cond (;; Operand list has at least two non-negative\
    \ integers.\n         (equal? (length operand) 2)\n         (+ (do_algebra (car\
    \ operand)\n                      (cons (cdr operand)\n                      \
    \      (cdr operand)))\n            (do_algebra (car operand)\n              \
    \        (cdr operand))))\n  '())) ; Return empty list.\n</code>", "  (if (null?\
    \ operand)\n      (error \"Operand list is empty.\")\n      (if (null? operator)\n\
    \          (error \"Operator list is empty.\")\n          (if (= 0 (length (cdr\
    \ operator)))\n              (error \"Operator list contains no operator.\")\n\
    \              (error \"Operator list is too short (length is \" \n          \
    \          (length (cdr operator)) \", should be at least 2).\")))\n      (let\
    \ ((temp (list (car operator) operand)))\n        (if (null? (cdr operator))\n\
    \            (if (null? (cdr operand))\n                (error \"Operator list\
    \ is too short (length is \" \n                    (length (cdr operator)) \"\
    , should be at least 2).\")\n                (error \"Operator list has too many\
    \ operands (length is \" \n                    (length (cdr operator)) \", should\
    \ be at least 1).\")))\n        (if (null? (car operator))\n            (error\
    \ \"Operator list is too short (length is \" \n                (length (cdr operator))\
    \ \", should be at least 2).\")\n            (if (null? (car operand))\n     \
    \           (error \"Operand list is too short (length is \" \n              \
    \      (length (cdr operand)) \", should be at least 2).\"))\n            (if\
    \ (= 0 (length (cdr operator)))\n                (error \"Operator list contains\
    \ no operator.\")\n                (error \"Operand list is too short (length\
    \ is \" \n                    (length (cdr operand)) \", should be at least 1).\"\
    ))\n            (if (= 0 (length (cdr operand)))\n                (error \"Operand\
    \ list contains no operand.\")\n                (error \"Operator list is too\
    \ short (length is \" \n                    (length (cdr operator)) \", should\
    \ be at least 1).\"))\n            (if (< 0 (length (cdr operator)))\n       \
    \         (error \"Operator list contains too many operators.\")\n           \
    \     (error \"Operand list is too short (length is \" \n                    (length\
    \ (cdr operand)) \", should be at least 1).\"))\n            (if (< 0 (length\
    \ (cdr operand)))\n                (error \"Operand list contains too many operands.\"\
    )\n                (error \"Operator list is too short (length is \" \n      \
    \              (length (cdr operator)) \", should be at least 1).\"))\n      \
    \      (if (= 0 (length (cdr operator)))\n                (error \"Operator list\
    \ contains no operator.\")\n                (error \"Operand list is too short\
    \ (length is \" \n                    (length (cdr operand)) \", should be at\
    \ least 1).\"))\n            (if (= 0 (length (cdr operand)))\n              \
    \  (error \"Operand list contains no operand.\")\n                (error \"Operator\
    \ list is too short (length is \" \n                    (length (cdr operator))\
    \ \", should be at least ", "  (cond (operand? operand 0) \n        (symbol? operator\
    \ 0) \n        (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n        (operand? operator 0)\n        (operand? operand 0)\n  \
    \      (operand? operator 0)\n        (operand? operand 0)\n        (operand?\
    \ operator 0)\n        (operand? operand 0)\n        (operand? operator 0)\n \
    \       (operand? operand 0)\n        (operand? operator 0)\n        (operand?\
    \ operand 0)\n", "  (cond\n    [(empty? operand) (error 'operator)\n    [(empty?\
    \ operator) (error 'operand)]\n    [(> (length operator) (length operand)) (error\
    \ 'operand)]\n    [(> (length operand) (length operator)) (error 'operator)]\n\
    \    [else (eval (append (list operator operand)\n                       (append\
    \ (list \"(\" operand)\n                                 (map (lambda (x) (list\
    \ '+ operand x)) operand))\n                       (append (list \")\"))\n   \
    \                (do_algebra (cdr operator) (cdr operand)))]))\n", "  (cond ((null?\
    \ operator) operand)\n        ((null? (cdr operator)) (+ (car operand) (cdr operand)))\n\
    \        (else (+ (do_algebra (cdr operator) operand) (do_algebra (car operator)\
    \ operand))))\n)\n", "  (if (null? operand)\n      '()\n      (cond [(equal? (car\
    \ operand) operator) (if (null? (cdr operand)) (car operand) (cdr operand))]\n\
    \            [(< 3 (length operand)) (do_algebra operator (cdr operand))]\n  \
    \          [else (cons operator (do_algebra operator (cdr operand)))])))\n", " \
    \ (cond [(empty? operator) (add_operand operand 0)]\n        [(equal? operator\
    \ (car operator)) \n         (add_operand operand (car operand))]\n        [(equal?\
    \ (car operator) '+') (add_operand operand (car operand))]\n        [(equal? (car\
    \ operator) '-') (add_operand operand (- (car operand)))]\n        [(equal? (car\
    \ operator) '*') (add_operand operand (* (car operand)))]\n        [(equal? (car\
    \ operator) '//') (add_operand operand (* (car operand) (car operand)))]\n   \
    \     [(equal? (car operator) '**') (add_operand operand (pow (car operand) (expt\
    \ 2 (car operand))))]\n        [else (error 'arithmetic operator unknown)]))\n",
  "  (if (null? operator)\n      '()\n      (begin\n        (if (> (length (car operator))\
    \ (length (car operand)))\n            (cons (car operand)\n                 \
    \  (do_algebra (cdr operator) (cdr operand)))\n            (cons (car operator)\
    \ (do_algebra (cdr operator) (cons (car operand) '())))\n        ))\n  )\n)\n",
  "  (cond\n    [(null? operator) operand]\n    [(null? (rest operator)) (do_algebra\
    \ (first operand) (second operand))]\n    [(null? (rest operand)) (do_algebra\
    \ (first operand) (second operand))]\n    [(equal? (length operator) (length operand))\
    \ (do_algebra (first operand) (second operand))]\n    [else (cond\n          [(equal?\
    \ (length operator) 0) (error 'do_algebra (first operand) (second operand))]\n\
    \          [(equal? (length operand) 1) (error 'do_algebra (first operand) (second\
    \ operand))]\n          [else (cond\n                 [(equal? (first operator)\
    \ (first operand)) (do_algebra (rest operator) (rest operand))]\n            \
    \     [else (error 'do_algebra (first operand) (second operand))]\n          \
    \       )])]))\n</code>\nI hope this can help you a bit.\n<|/ a tags=scheme,racket,functional-programming\
    \ dscore=0 |>\n<| c |>\nThank you very much for your response! You definitely\
    \ have a lot more to learn than I initially thought I would be able to do! I got\
    \ it working but now I want to know why it is working instead of just copying\
    \ and pasting.\n<|/ c |>\n<| c |>\nYou're welcome! It's probably because the `cond`\
    \ expression checks the list until it reaches the end and stops evaluating the\
    \ other expressions. It seems like there are some [good tutorials on `cond` expressions](http://www.cs.brown.edu/~sk/Publications/Scheme_Report.pdf)\
    \ on their website and I highly recommend going over it if you're new to this\
    \ language.\n<|/ c |>\n<| c |>\nThanks again for your response! I'm still pretty\
    \ new to Scheme, so I just wanted to understand why it worked. Your response is\
    \ very helpful. I'm still working on understanding how to use cond though.\n<|/\
    \ c |>\n<| c |>\nNo problem! I understand how `cond` works, it's just different\
    \ in how it uses its conditional expressions.\n<|/ c |>\n<| c |>\nI made a program\
    \ that solves equations, this one was a little bit tricky because I wanted to\
    \ use the built in `eval` function, but I didn't think it would be possible since\
    \ I wanted it to only take one argument at a time. I just made a program that\
    \ solves equations by using `eval` then using `do-algebra` from the previous program\
    \ to build the equation. This was the only way I could think of to solve the equation.\
    \ I'm sure there are better ways to do this but I'm not sure ", "  (cond\n   \
    \ [(null? operand) 0]\n    [(null? (cdr operand)) (+ 0 (car operand))]\n    [else\
    \ (+ (car operand) (do_algebra (car operator) (cdr operand)))]))\n", "  (cond\n\
    \    [(null? operator)\n     (error \"Operator list is empty!\")\n     ]\n   \
    \ [(null? operand)\n     (error \"Operand list is empty!\")\n     ]\n    [(= 1\
    \ (length operand))\n     (error \"Operand list has one operand!\")\n     ]\n\
    \    [(= 0 (length operand))\n     (error \"Operand list has zero operands!\"\
    )\n     ]\n    [else \n     (cond\n       [(= 1 (length operator))\n        (cond\n\
    \         [(= 1 (length operand))\n          (error \"Operator list has one operator,\
    \ and operand list has one operand.\")\n          ]\n         [else \n       \
    \   (error \"Operator list has more than one operator, and operand list has more\
    \ than one operands.\")\n          ]\n         ]\n       [else \n        (error\
    \ \"Operator list has more than one operator.\")\n        ]\n       ]\n      ]\n\
    \     )\n    (cond\n     [(null? (cdr operator))\n      (+ 0 (* 2 (car operand)\
    \ (car operand)))\n      ]\n     [else \n      (cond\n       [(= 1 (length operator))\n\
    \        (+ (car operand)\n          (do_algebra (cdr operator)\n            \
    \          (cdr operand))\n          )\n        ]\n       [else\n        (error\
    \ \"Operator list has more than one operator.\")\n        ]\n       ]\n      ]\n\
    \     )\n    )\n  )\n)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your suggestions!\
    \ I appreciate it. Your solutions helped me understand how the solutions work,\
    \ as well as make better use of the language syntax and constructs. I hope you\
    \ have a great day! :)\n<|/ c |>\n<| c |>\n: You're very welcome and I'm glad\
    \ I helped. :)\n<|/ c |>\n<| a |>\nHere is another way of doing this. It takes\
    \ advantage of Racket's list-ref. You can think of list-ref as a way to get a\
    \ particular element from a list. The way we get the element from the first list\
    \ is by using list-ref on operand and subtracting 1 from the index of that element.\
    \ So if operand was [1 2 3] then the first element would be the third element\
    \ of the list which would be the element at index 2. \nThis way you don't have\
    \ to reverse the operand. You just find the index of that element and then subtract\
    \ 1 from that index. \nThis would look like this.\n<code>", "  (cond [(null? operator)\
    \ (error \"operator list is empty.\")]\n        [(null? operand) (error \"operand\
    \ list is empty.\")]\n        [(zero? #operand) (error \"operand list is empty.\"\
    )]\n        [(= #operator '-) (lambda (x y)\n                            (do_algebra\
    \ (cdr operator) (cdr operand)))\n         (lambda (x y)\n           (do_algebra\
    \ (cdr operator) (- x y)))\n         (lambda (x y)\n           (do_algebra (cdr\
    \ operator) (* x y)))\n         (lambda (x y)\n           (do_algebra (cdr operator)\
    \ (// x y)))\n         (lambda (x y)\n           (do_algebra (cdr operator) (**\
    \ x y)))\n         #operand]\n        [(= #operator '*) \n         (lambda (x\
    \ y)\n           (do_algebra (cdr operator) (cdr operand)))\n         (lambda\
    \ (x y)\n           (do_algebra (cdr operator) (+ x y)))\n         (lambda (x\
    \ y)\n           (do_algebra (cdr operator) (- x y)))\n         #operand]\n  \
    \      [(= #operator '//)\n         (lambda (x y)\n           (do_algebra (cdr\
    \ operator) (cdr operand)))\n         (lambda (x y)\n           (do_algebra (cdr\
    \ operator) (/ x y)))\n         (lambda (x y)\n           (do_algebra (cdr operator)\
    \ (// x y)))\n         #operand]\n        [(= #operator '**)\n         (lambda\
    \ (x y)\n           (do_algebra (cdr operator) (cdr operand)))\n         (lambda\
    \ (x y)\n           (do_algebra (cdr operator) (* x (^ y y))))\n         (lambda\
    \ (x y)\n           (do_algebra (cdr operator) (+ x y)))\n         #operand]\n\
    \        [else\n         (lambda (x y)\n           (do_algebra (cdr operator)\
    \ (* x (car operand) y))\n           (do_algebra (cdr operator) (+ x (car operand)\
    \ y))\n           (do_algebra (cdr operator) (- x (car operand) y))\n        \
    \   (do_algebra (cdr operator) (// x (car operand) y))\n           (do_algebra\
    \ (cdr operator) (** x (car operand) y))\n           #operand)]\n        ))\n",
  "  (cond ((null? operand) 0)\n        ((eq? (car operand) operator)\n         (do_algebra\
    \ (cdr operand) operand))\n        (else (+ (* (car operand) (do_algebra operator\
    \ operand)) (do_algebra operator operand)))))\n", "  (let* ((sum (apply + (map\
    \ + operator operand)))\n         (product (apply * (map * operator operand)))\n\
    \         (floor (apply // operator operand)))\n    (if (null? (cdr operator))\
    \ \n        sum\n        (let ((exp (car operator)))\n          (if (> exp 0)\
    \ \n              (* exp (floor (* product operand))) \n              floor))))))\n",
  "  (cond [(equal? operator '+) \n         (+ operand operand)\n         operand]\n\
    \        [(equal? operator '-) \n         (- operand operand)\n         operand]\n\
    \        [(equal? operator '*) \n         (* operand operand)\n         operand]\n\
    \        [(equal? operator '//) \n         (// operand operand)\n         operand]\n\
    \        [(equal? operator '**) \n         (** operand operand)\n         operand]))\n",
  "  (let* ((result (make-integer (- (length operator) (length operand))))\n     \
    \    (nums (append (make-list result (lambda (x) (* (x x) (make-integer operand)))\
    \ operand)\n                     (list (list 1) operand)))\n         (ops (append\
    \ operator (list '1))))\n    (loop for i from (- result 1) below nums \n     \
    \     for j from 0 below length (ops i) \n          append (list i (list j))))\n\
    \  ", "  (let* ((result 0)\n         (index (modulo 0 (length operator))) ; The\
    \ index of operator list.\n         (first (car operator))             ; Get the\
    \ first operator of operator list. \n         (second (cadr operator))       \
    \   ; Get the second operator of operator list. \n         (first1 (car operand))\
    \            ; Get the first operand of operand list. \n         (second1 (cadr\
    \ operand))          ; Get the second operand of operand list. \n         (first2\
    \ (car operand))            ; Get the first operand of operand list. \n      \
    \   (second2 (cadr operand)))          ; Get the second operand of operand list.\
    \ \n    (when (< index 0)                      ; If index less than 0.\n     \
    \ (error \"Error in do_algebra. Index cannot be negative.\"))\n    (when (and\
    \ (number? first) (number? second)) ; If both operands are number.\n      (set!\
    \ result (+ first1 (* second second1)))\n      result))\n  result)\n", "  (let\
    \ ([(operator '+)\n         (operand1 '(2)))\n    (operand2 '(3))])\n    (list\
    \ operator (first operand1) (first operand2)\n         (apply + (map first (rest\
    \ operand1))) \n         (apply * (map first (rest operand1))) \n         (apply\
    \ // (map first (rest operand1))) \n         (apply exp (map first (rest operand1))))))\n",
  "  (local ((define (helper result op operand)\n            (cond\n             \
    \ [(empty? operand) result]\n              [(eq? (first operand) operator) \n\
    \                (helper (op result) (op operand) (rest operand))]\n         \
    \     [else (helper (op result) op operand)]))\n        (lambda (op operand)\n\
    \          (helper (op operand) (op operand))))\n    (helper 0 operator operand)))\n",
  "  (if (empty? operator)\n      operand\n      (do ((op operator)\n           (operand\
    \ operand))\n          ((empty? operand) (error 'no-operands))\n          ((empty?\
    \ (rest operand)) (error 'no-operator))\n          ((not (integer? (first operand)))\n\
    \           (error 'non-integer operand))\n          ((not (integer? (rest (rest\
    \ operand))))\n           (error 'non-integer operand))\n          ((integer?\
    \ (first operand))\n           (if (equal? op '+)\n               (+ (first operand)\
    \ (do_algebra (rest operator) (rest operand)))\n               (if (equal? op\
    \ '-)\n                   (- (first operand) (do_algebra (rest operator) (rest\
    \ operand)))\n                   (error 'non-numeric operand))\n             \
    \  (error 'non-numeric operand))\n           (if (equal? op '*)\n            \
    \   (* (first operand) (do_algebra (rest operator) (rest operand)))\n        \
    \       (if (equal? op '//)\n                   (if (not (integer? (first operand)))\n\
    \                     (error 'non-integer operand)\n                     (floor\
    \ (/ (first operand) (do_algebra (rest operator) (rest operand)))))\n        \
    \           (error 'non-integer operand))\n               (if (equal? op '**)\n\
    \                   (if (not (integer? (first operand)))\n                   \
    \  (error 'non-integer operand)\n                     (pow (first operand) (do_algebra\
    \ (rest operator) (rest operand))))\n                   (error 'non-integer operand))\n\
    \               (error 'non-numeric operand))\n           (error 'non-numeric\
    \ operator))))\n", "  (cond [(empty? operator) 0]\n        [(empty? operand) 0]\n\
    \        [(null? operand) 0]\n        [(member (caar operator) arithmetic_ops)\
    \ (do_algebra (cdar operator) (cons (car operand) operand))]\n        [else (+\
    \ (do_algebra (car operator) operand) (do_algebra (cdar operator) (cons (car operand)\
    \ operand)))]))\n", "  (let ([acc (operand)]\n        [lhs-op (sub1 (length operator))]\n\
    \        [rhs-op (sub1 (length operand))]\n        [lhs-val (sub1 (length operand))]\n\
    \        [rhs-val (sub1 (length operand))]\n        [remainder-val (sub1 (length\
    \ operand))]\n        [remainder-op (sub1 (length operator))]\n        [num-ops\
    \ (length operand)]\n        [num-vals (length operand)]\n        [sum-vals (length\
    \ operand)]\n        [temp-sum (sub1 (length operand))]\n        [temp-num (sub1\
    \ (length operand))]\n        [sum-ops (length operator)]\n        [temp-rhs-val\
    \ (sub1 (length operand))]\n        [temp-rhs-op (sub1 (length operand))]\n  \
    \      [sum-rhs-ops (length operator)]\n        [temp-rhs-num (sub1 (length operand))]\n\
    \        [temp-rhs-acc (sub1 (length operand))]\n        [sum-rhs-acc (length\
    \ operator)]\n        [num-sums (length operand)]\n        [num-accum (length\
    \ operand)])\n    (if (= remainder-op 0) (begin (display 'The list operands has\
    \ zero operands, therefore the expression cannot be calculated.) (newline)\n \
    \                              (display \"Please make sure to enter at least one\
    \ operand for the expression to calculate.\")\n                              \
    \ (newline)\n                               (newline))\n    (if (= (sub1 (length\
    \ operand)) 0) (begin (display 'The list operator has zero operands, therefore\
    \ the expression cannot be calculated.) (newline)\n                          \
    \                (display \"Please make sure to enter at least one operator for\
    \ the expression to calculate.\")\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          (newline)\n\
    \                                          (newline)\n                       \
    \                   (newline)\n                                          ", " \
    \ (cond\n    [(empty? operand)\n     operand]\n    [else\n     (cond\n       [(equal?\
    \ (first operand) operator)\n        ((do_algebra operator \n                \
    \    (cons (first operand) (rest operand)))]\n       [else (do_algebra (first\
    \ operand) (cons (first operand) operand))])]\n   ))\n", "  (cond\n    [(empty?\
    \ operand) 0]\n    [(empty? (cdr operand)) (+ (car operand) (do_algebra (car operator)\
    \ (cdr operand)))]\n    [else (+ (do_algebra (car operator) (cdr operand)) (do_algebra\
    \ (cdr operator) operand))]))\n", "  (if (null? operand)\n      '()\n      (cons\
    \ (car operand)\n            (do_algebra (cons (car operator) operator) (cdr operand)))))\n",
  "  (let ((op1 (list->string (cons\n                             (string->list operator)\n\
    \                             (list->string (subseq operand 0 -1))\n         \
    \                    ))\n        (fst (car operator))\n        (snd (string->list\
    \ operator)))\n    (cond\n      [(empty? op1)\n       (cons fst operand)]\n  \
    \    [(or (empty? op2) (empty? fst))\n       (cons fst operand)]\n      [(equal?\
    \ op1 '*)\n       (cons fst operand)]\n      [(equal? op1 '+)\n       (cons fst\
    \ operand)]\n      [(equal? op1 '-)\n       (cons fst operand)]\n      [(equal?\
    \ op1 '//)\n       (cons fst operand)]\n      [(equal? op1 '**)\n       (cons\
    \ fst operand)]\n      [(equal? op1 '^)\n       (cons fst operand)]\n      [else\n\
    \       (let ((op2 (list->string (cons\n                               (string->list\
    \ fst)\n                               (list->string (subseq fst 1 -1))\n    \
    \                           (string->list snd)))\n             (op2-val (string->list\
    \ (car operator)))\n             (op2-op (string->list (cadr operator)))\n   \
    \          (op2-num (cadr operand)))\n         (if (equal? op2 '^)\n         \
    \    (cons (* op2-num operand) (do_algebra op2-op operand)))\n         (if (and\
    \ (equal? op2 '**)\n                  (> (length (rest operand)) 1))\n       \
    \      (cons (pow (first operand) (second operand))\n                   (do_algebra\
    \ op2-op operand)))\n         (if (and (equal? op2 '//)\n                  (>\
    \ (length (rest operand)) 2))\n             (cons (floor (/ (first operand) (second\
    \ operand)))\n                   (do_algebra op2-op operand)))\n         (if (and\
    \ (equal? op2 '*)\n                  (> (length (rest operand)) 2))\n        \
    \     (cons (* op2-num operand)\n                   (do_algebra op2-op operand)))\n\
    \         (if (and (equal? op2 '+)\n                  (> (length (rest operand))\
    \ 2))\n             (cons (+ op2-num operand)\n                   (do_algebra\
    \ op2-op operand)))\n         (if (and (equal? op2 '-)\n                  (> (length\
    \ (rest operand)) 2))\n             (cons (- op2-num operand)\n              \
    \     (do_algebra op2-op operand)))\n", "  (let ((op (cdr operator)))\n    (cond\n\
    \      [(empty? op) operand]\n      [(eq? (car op) '-) operand]\n      [else (cons\
    \ (* operand (car op))\n                    (do_algebra (cdr operator) operand))])))\n",
  "  ;; Return -1 (false) if any of the operand lists doesn't have at least one element.\n\
    \  (if (null? operand)\n      (- 1)\n      ;; Return the value of the first operand\
    \ if the operator list has at least one element.\n      (if (null? (cdr operator))\n\
    \          (car operand)\n          ;; If the first element of the operator list\
    \ is not '+', return 'true', otherwise return 'false'.\n          (if (eq? (car\
    \ operator) '+)\n              (+ (car operand) (do_algebra (cdr operator) (sub1\
    \ (cdr operand))))\n              'false)))\n", "  ;; Compute the basic algebric\
    \ expression\n  (if (null? operand)\n      ;; Base case when both list is empty\n\
    \      (error 'operation \"operator and operand list is empty\")\n      ;; If\
    \ first list is empty, then the second list must be empty. Thus, we can return\
    \ \n      ;; the first element of the first list\n      (if (null? operator)\n\
    \          (first operand)\n          (do_algebra (first operator) (rest operand)))\n\
    \      ;; Otherwise, return the first element of the first list plus the result\
    \ of \n      ;; the rest of the first list.\n      (+ (first operand) (do_algebra\
    \ (first operator) (rest operand))))\n  ;; Return the result of evaluating basic\
    \ algebric expression\n  (do_algebra operator operand))\n", "  (if (null? operator)\n\
    \      '()\n      (let ((left (do_algebra (cdr operator) (cons 0 (car operand)))))\n\
    \        (if (null? (cdr operator))\n            (cons (+ 0 (car operand)) (+\
    \ left (cdr operand)))\n            (let ((right\n                    (do_algebra\
    \ (cdr (car operator)) (cons 0 (car operand)))))\n              (cons (+ (car\
    \ operand) (* left (car operand))) right))))))\n", "  (local\n    ((define (add\
    \ x y)\n      (local\n        ((define (add x y)\n          (+ (* x y) y))\n \
    \       (define (substract x y)\n          (local\n            ((define (substract\
    \ x y)\n              (if (> (- x y) 0)\n               (substract (substract\
    \ x y) y)\n               (- y x)))\n            (define (multiply x y)\n    \
    \          (local\n                ((define (multiply x y)\n                 \
    \ (if (> (- x y) 0)\n                   (multiply (multiply x y) y)\n        \
    \           (* y x)))\n                (define (floordiv x y)\n              \
    \    (local\n                    ((define (floordiv x y)\n                   \
    \   (if (> (- x y) 0)\n                       (floordiv (floordiv x y) y)\n  \
    \                     (- y x)))\n                    (define (powx x y exp)\n\
    \                      (local\n                        ((define (powx x y exp)\n\
    \                          (if (> (- x y) 0)\n                           (powx\
    \ (powx x y exp) exp (* y exp)))\n                          (* y x)))\n      \
    \                (define (exp x exp)\n                        (local\n       \
    \                   ((define (exp x exp)\n                            (if (> (-\
    \ x y) 0)\n                             (exp (exp x exp) exp)\n              \
    \               (* y x)))\n                          (define (mul x y exp)\n \
    \                           (local\n                              ((define (mul\
    \ x y exp)\n                                (if (> (- x y) 0)\n              \
    \                   (mul (mul x y) y exp)\n                                 (*\
    \ y x))))\n                          (define (sqrt x)\n                      \
    \      (local\n                              ((define (sqrt x)\n             \
    \                   (if (> (- x x) 0)\n                                 (sqrt\
    \ (sqrt x)) x))\n                              (define (divx x y)\n          \
    \                      (local\n                                  ((define (divx\
    \ x y)\n                                    (if (> (- x y) 0)\n              \
    \                       (divx (divx x y) y)\n                                \
    \     (/ y x))))\n                              (define (remainder x y)\n    \
    \                            (local\n                                  ((define\
    \ (remainder x y)\n                                    (if (> (- x y) 0)\n   \
    \                                  (remainder (remainder x y) y)\n           \
    \                          (/ x y))))\n                              (define (quotient\
    \ x y)\n                                (local\n                             \
    \     ((define (quotient x y)\n                                    (if (> (- x\
    \ y) 0)\n                                     (quotient (quotient x y) y)\n  \
    \                                   (/ ", "  (cond\n    [(empty? operator) (error\
    \ 'operator is empty)] \n    [(empty? operand) (error 'operand is empty)]\n  \
    \  [(= (length operator) 0) (error 'operator has zero elements)] \n    [(= (length\
    \ operand) 1) (error 'operand has zero elements)]\n    [else (+ (do_algebra (cdr\
    \ operator) (car operand)) \n            (do_algebra (cdr operator) (cdr operand)))]))\n",
  "  (cond [(null? operand) 0]\n        [(null? (rest operand)) (+ 0 (* 0 (do_algebra\
    \ (first operator) (rest operand))))]\n        [else (+ 0 (* 0 (do_algebra (first\
    \ operator) operand) (do_algebra (rest operator) (rest operand))))]))\n", "  (cond\n\
    \    ((empty? operator) (+ (car operand) (car operand)))\n    ((empty? operand)\
    \ (car operand))\n    ((equal? (first operator) (first operand)) (do_algebra (rest\
    \ operator) (cons (rest operand) operand)))\n    ((equal? (first operator) (first\
    \ operand)) (do_algebra (rest operator) (cons (car operand) operand)))\n    ((equal?\
    \ (first operator) (*)) (+ operand\n                                (do_algebra\
    \ (rest operator) (cons (car operand) operand)))\n    ((equal? (first operator)\
    \ (**)) (+ (do_algebra (rest operator) (cons (car operand) operand)) \n      \
    \                          (do_algebra (rest operator) (cons (car operand) operand)))\n\
    \    ((equal? (first operator) (/)) (+ (do_algebra (rest operator) (cons (car\
    \ operand) operand)) \n                                (do_algebra (rest operator)\
    \ (cons (car operand) operand)))\n    ((equal? (first operator) (//)) (+ (do_algebra\
    \ (rest operator) (cons (car operand) operand)) \n                           \
    \     (do_algebra (rest operator) (cons (car operand) operand)))\n    ((equal?\
    \ (first operator) (%)) (+ operand\n                                (do_algebra\
    \ (rest operator) (cons (car operand) operand)))\n    ((equal? (first operator)\
    \ (+)) (+ operand\n                                (do_algebra (rest operator)\
    \ (cons (car operand) operand)))\n    ((equal? (first operator) (-)) (- operand\n\
    \                                (do_algebra (rest operator) (cons (car operand)\
    \ operand)))\n    ((equal? (first operator) (/)) (- operand\n                \
    \                (do_algebra (rest operator) (cons (car operand) operand)))\n\
    \    ((equal? (first operator) (*)) (- operand\n                             \
    \   (do_algebra (rest operator) (cons (car operand) operand)))\n    ((equal? (first\
    \ operator) (//)) (- operand\n                                (do_algebra (rest\
    \ operator) (cons (car operand) operand)))\n    ((equal? (first operator) (%))\
    \ (- operand\n                                (do_algebra (rest operator) (cons\
    \ (car operand) operand)))\n    ((equal? (first operator) (//)) (- operand\n \
    \                               (do_algebra (rest operator) (cons (car operand)\
    \ operand)))\n    ((equal? (first operator) (+)) (+ operand\n                \
    \                (do_algebra (rest operator) (cons (car operand) operand)))\n\
    \    ((equal? (first operator) (-)) (- operand\n                             \
    \   (do_algebra (rest operator", "  ;; (define (do_algebra op1 op2 ... opn)\n\
    \  (if (equal? (length op1) 1) (if (equal? (length op2) 1) (* (car op2) (do_algebra\
    \ (cdr op1) operand))\n                                          (if (equal? (length\
    \ op3) 1) (+ (do_algebra (car op1) (car op2)) (do_algebra (cdr op1) (cdr op3)))\
    \ (do_algebra (car op1) (cdr op2)))\n                                        \
    \  (if (equal? (length op4) 1) (+ op1 (do_algebra (cdr op1) (cdr op4))) (do_algebra\
    \ (car op1) (cdr op2)))\n                                          (if (equal?\
    \ (length op5) 1) (+ op1 (+ op2 (do_algebra (cdr op1) (cdr op5)))) (do_algebra\
    \ (car op1) (cdr op2)))\n                                          (if (equal?\
    \ (length op6) 1) (+ op1 (+ op2 (+ op3 (do_algebra (cdr op1) (cdr op6))))) (do_algebra\
    \ (car op1) (cdr op2)))\n                                          (if (equal?\
    \ (length op7) 1) (+ op1 (+ op2 (+ op3 (+ op4 (do_algebra (cdr op1) (cdr op7)))))\
    \ (do_algebra (car op1) (cdr op2)))\n                                        \
    \  (if (equal? (length op8) 1) (+ op1 (+ op2 (+ op3 (+ op4 (+ op5 (do_algebra\
    \ (cdr op1) (cdr op8))))) (do_algebra (car op1) (cdr op2)))\n                \
    \                          (if (equal? (length op9) 1) (+ op1 (+ op2 (+ op3 (+\
    \ op4 (+ op5 (+ op6 (do_algebra (cdr op1) (cdr op9))))) (do_algebra (car op1)\
    \ (cdr op2)))\n                                          (if (equal? (length op10)\
    \ 1) (+ op1 (+ op2 (+ op3 (+ op4 (+ op5 (+ op6 (+ op7 (do_algebra (cdr op1) (cdr\
    \ op10))))) (do_algebra (car op1) (cdr op2)))\n                              \
    \            (if (equal? (length op11) 1) (+ op1 (+ op2 (+ op3 (+ op4 (+ op5 (+\
    \ op6 (+ op7 (+ op8 (do_algebra (cdr op1) (cdr op11))))) (do_algebra (car op1) ",
  "  (let ([x (list* '(1 2 3 4 5) (list operand))])\n    (map (lambda (element) (+\
    \ element x))\n         (list operator)\n         (cdr x))\n    ))\n", "  (cond\
    \ [(null? operator)\n         (display operand)\n         ]\n        [else (do_algebra\
    \ (cdr operator) (+ operand (car operator)))]\n        ))\n", "  (cond\n    [(null?\
    \ operand) 0]\n    [(null? (cdr operand)) operand]\n    [(pair? (car operand))\
    \ (+ (car operand) (do_algebra (car operand) (cdr operand)))]\n    [else\n   \
    \  (* 2 (do_algebra (car operand) (cdr operand)))]\n   ))\n", "  (cond\n    [(empty?\
    \ operand) (error 'empty \"operand\")]\n    [(empty? operator) (error 'empty \"\
    operator\")]\n    [else (cond\n            [(equal? (car operator) '(+)) (+ (car\
    \ operand) (do_algebra (cdr operator) (cdr operand)))]\n            [(equal? (car\
    \ operator) '(-)) (- (car operand) (do_algebra (cdr operator) (cdr operand)))]\n\
    \            [(equal? (car operator) '*') (* car operand (do_algebra (cdr operator)\
    \ (cdr operand)))]\n            [(equal? (car operator) '//') (// car operand\
    \ (do_algebra (cdr operator) (cdr operand)))]\n            [(equal? (car operator)\
    \ '**') (** car operand (do_algebra (cdr operator) (cdr operand)))]\n        \
    \    [else (error 'invalid \"operator\" \"~S\"' operator)]\n            )]))\n",
  "  (cond\n    [(empty? operator) (check-type operand list)\n     (make-algebra-expr\
    \ operator (first operand) (last (rest operand)))]\n    [else (cons (first (first\
    \ operator)) \n              (do_algebra (rest operator)\n                   \
    \      (cons (first operand) operand)))]))\n", "  (if (null? operand)\n      '()\
    \ \n      (cons (* (car operand) (caar operator))\n            (do_algebra (cdr\
    \ operator) (cdr operand))))) \n", "  (cond\n    [(empty? operand) operand]\n\
    \    [(equal? (car operand) '+) (do_algebra '(+) (cdr operand))]\n    [(equal?\
    \ (car operand) '-) (do_algebra '(+) (cdr operand))]\n    [(equal? (car operand)\
    \ '*) (do_algebra '(*) (cdr operand))]\n    [(equal? (car operand) '//) (do_algebra\
    \ '(* (/ operand))]\n    [(equal? (car operand) '**) (do_algebra '(* (* operand))]\n\
    \    [else (error \"No such operator on operand\")]))) ;; ((error \"No such operator\
    \ on operand\")]))", "  (define i 0)\n  (define result 0)\n  (define op 0)\n \
    \ (define operands '())\n  (define num_operands 0)\n  (define op 0)\n  (define\
    \ num_operands 0)\n  (define op 0)\n  (define operands '())\n  (define num_operands\
    \ 0)\n  (define op 0)\n  (define num_operands 0)\n  (define op 0)\n  (define operands\
    \ '())\n  (define num_operands 0)\n  (define op 0)\n  (define num_operands 0)\n\
    \  (define op 0)\n  (define operands '())\n  (define num_operands 0)\n  (define\
    \ op 0)\n  (define num_operands 0)\n  (define op 0)\n  (define operands '())\n\
    \  (define num_operands 0)\n  (define op 0)\n  (define num_operands 0)\n  (define\
    \ op 0)\n  (define operands '())\n  (define num_operands 0)\n  (define op 0)\n\
    \  (define num_operands 0)\n  (define op 0)\n  (define operands '())\n  (define\
    \ num_operands 0)\n  (define op 0)\n  (define num_operands 0)\n  (define op 0)\n\
    \  (define operands '())\n  (define num_operands 0)\n  (define op 0)\n  (define\
    \ num_operands 0)\n  (define op 0)\n  (define operands '())\n  (define num_operands\
    \ 0)\n  (define op 0)\n  (define num_operands 0)\n  (define op 0)\n  (define operands\
    \ '())\n  (define num_operands 0)\n  (define op 0)\n  (define num_operands 0)\n\
    \  (define op 0)\n  (define operands '())\n  (define num_operands 0)\n  (define\
    \ op 0)\n  (define num_operands 0)\n  (define op 0)\n  (define operands '())\n\
    \  (define num_operands 0)\n  (define op 0)\n  (define num_operands 0)\n  (define\
    \ op 0)\n  (define operands '())\n  (define num_operands 0)\n  (define op 0)\n\
    \  (define num_operands 0)\n  (define op 0)\n  (define operands '())\n  (define\
    \ num_operands 0)\n  (define op 0)\n  (define num_operands 0)\n  (define op 0)\n\
    \  (define operands '())\n  (define num_operands 0)\n  (define op 0)\n  (define\
    \ num_operands 0)\n  (define op 0)\n  (define operands '())\n  (define num_operands\
    \ 0)\n  (define op 0)\n  (define num_operands 0)\n  (define op 0)\n  (define operands\
    \ '())\n  (define num_operands 0)\n  (define op 0)", "  (cond [(empty? operand)\
    \ (list 0)]\n        [(equal? (caar operand) operator) (+ (cadar operand) (do_algebra\
    \ (caddr operand) operand))]\n        [else (do_algebra (caddr operand) (append\
    \ (caddr operand) operand))]))\n", "  (let* ((result (+ \n                 ((first\
    \ operand) \n                  (second operand))\n               ))\n        \
    \ (operators (reverse operator))\n         (operator first (first operators))\n\
    \         (operand second (second operands))\n         (len (- (length operand)\
    \ (length operators)))\n         (i (if (= len 0)\n                0\n       \
    \         (/ len (length operators))))\n         (rest (loop (- i 1) \n      \
    \                 [operator]\n                       [operand]))\n    (if (= (length\
    \ rest) 0)\n        result\n        (do ((operators (reverse rest))\n        \
    \     ((operator first (first operators)))\n             ((operand second (second\
    \ operands)))\n             ((len (- (length operand) (length operators))))\n\
    \             ((i 0))\n             ((rest (loop (- i 1) \n                  \
    \        [operator]\n                          [operand])))\n           ((= (length\
    \ rest) 0)) result\n           (do ((operators (reverse rest))\n             \
    \    ((operator first (first operators)))\n                 ((operand second (second\
    \ operands)))\n                 ((len (- (length operand) (length operators))))\n\
    \                 ((i 0))\n                 ((rest (loop (- i 1) \n          \
    \                    [operator]\n                              [operand])))\n\
    \              (if (or (= (first operators) operator)\n                      \
    \ (= (first operand) operand))\n                  (+ result (do_algebra operator\
    \ operand))\n                  (+ result (do_algebra operator operand)))\n   \
    \           result))))))\n", "  (cond [(null? operand) 0]\n        [(null? (cdr\
    \ operand)) (operand)]\n        [else (do_algebra (car operand) (cons (+ (car\
    \ operand) (cdr operand)) operand))]))\n", "  (cond\n    [(null? operator)\n \
    \    (cond\n       [(null? operand)\n        (error \"Invalid operator\")\n  \
    \     ]\n       [else\n        (error \"Invalid operator\")\n       ]\n     )]\n\
    \    [(null? operand)\n     (error \"Invalid operand\")\n     ]\n    [else\n \
    \    (cond\n       [(assoc (car operator) operand)\n        (error \"Invalid operator\"\
    )\n       ]\n       [else\n        (cond\n         [(list? operand)\n        \
    \  (cond\n            [(equal? (car operand) '**) (do_algebra operand (cdr operand))]\
    \ \n            [else (error \"Invalid operand\")] \n           )\n          ]\n\
    \          [else\n           (error \"Invalid operand\")\n          ]\n      \
    \   ]\n       )\n     ]\n   )\n  )\n)\n", "  (cond\n    [(or (null? operator)\
    \ (null? operand)) '()]\n    [(or (equal? (car operator) '+) (equal? (car operator)\
    \ '-))\n     (cond\n       [(or (null? operand) (null? (cdr operand)) (null? (cddr\
    \ operand)))\n        '()]\n       [(or (equal? (car operand) '*) (equal? (car\
    \ operand) '//))\n        (cond\n         [(or (null? operand) (null? (cdr operand))\
    \ (null? (cddr operand)))\n          '()]\n         [else (+ \n             (cadr\
    \ (car operand))\n             (* (cddr (car operand)) (cadr (car operand))))])]\n\
    \       [(or (equal? (car operand) '**))\n        (cond\n         [(or (null?\
    \ operand) (null? (cdr operand)) (null? (cddr operand)))\n          '()]\n   \
    \      [else (- \n             (cadr (car operand))\n             (* (cddr (car\
    \ operand)) (cadr (car operand))))])]\n       [else (- \n             (cadr (car\
    \ operand))\n             (* (cddr (car operand)) (cadr (car operand))))])]\n\
    \    [else (- \n             (cadr (car operand))\n             (* (cddr (car\
    \ operand)) (cadr (car operand))))]))\n</code>\n<|/ a dscore=1 tags=scheme |>\n\
    <| a |>\nTo evaluate (a + b * c) you can use either of these two forms:\n", " \
    \ (cond\n    [(equal? operand '()) (error 'empty operand)] \n    [(equal? operator\
    \ (list '+)) (+ (first operand) (first operand))] \n    [(equal? operator (list\
    \ '-)) (- (first operand) (first operand))] \n    [(equal? operator (list '*))\
    \ (* 1 (first operand))] \n    [(equal? operator (list '//)) (/ 1 (first operand))]\
    \ \n    [(equal? operator (list '**)) (* 1 (second operand))] \n    [else (error\
    \ 'unknown operator)]))\n", "  (if (null? operand)\n      '#error\n      (let\
    \ ([op1 (first operand)\n             op2 (rest operand)])\n        (if (equal?\
    \ (first operator) '+)\n            (+ (do_algebra operator (rest operand))\n\
    \               (do_algebra operator (rest operand)))\n            (if (equal?\
    \ (first operator) '-')\n                (if (null? op2)\n                   \
    \ 0\n                    (- 0 (do_algebra operator (rest operand))))\n       \
    \         (if (null? op1)\n                    0\n                    (- 0 (do_algebra\
    \ operator (rest operand)))))\n            (if (equal? (first operator) '*')\n\
    \                (if (null? op2)\n                    (* 0 (do_algebra operator\
    \ (rest operand))))\n                (if (null? op1)\n                    (* 0\
    \ (do_algebra operator (rest operand))))\n            (if (equal? (first operator)\
    \ '/')\n                (if (null? op2)\n                    (/ 0 (do_algebra\
    \ operator (rest operand))))\n                (if (null? op1)\n              \
    \      (/ 0 (do_algebra operator (rest operand))))\n            (if (equal? (first\
    \ operator) '**')\n                (if (null? op2)\n                    (** 0\
    \ (do_algebra operator (rest operand))))\n                (if (null? op1)\n  \
    \                  (** 0 (do_algebra operator (rest operand))))\n            (if\
    \ (equal? (first operator) '//')\n                (if (null? op2)\n          \
    \          (floor-div (do_algebra operator (rest operand))\n                 \
    \           (do_algebra operator (rest operand))))\n                (if (null?\
    \ op1)\n                    (floor-div (do_algebra operator (rest operand))\n\
    \                            (do_algebra operator (rest operand))))))))))\n",
  "  (if (null? operator)\n      (if (null? operand)\n          0\n          (list\
    \ operand))\n      (if (null? (rest operator))\n          (+ (first (rest operand))\
    \ (do_algebra (rest operator) operand))\n          (do_algebra (rest operator)\
    \ operand))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis was my first attempt\
    \ at using a 'flat' array so thank you for the solution! I do understand how this\
    \ works though I am not sure if it is how I would have done it in Scheme, as I\
    \ am very new to Scheme and Lisp altogether. I was thinking of how I would do\
    \ this in C++ but my C++ knowledge is very limited so I thought that maybe I could\
    \ get some help on the Scheme side of things. Thanks again.\n<|/ c |>\n<| c |>\n\
    You're welcome! Be sure to read this page to get a better understanding of how\
    \ lists are implemented and how they can be manipulated: http://community.schemewiki.org/?scheme-list-implementation-strategy-for-beginners\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's how I would have done it in Scheme (this doesn't\
    \ even use recursion)\n<code>", "  (cond\n    [(empty? operand) 0]\n    [(equal?\
    \ (caar operand) operator) (+ (do_algebra (cdar operand) (do_algebra (car operand)\
    \ (sub1 (car operand))))))]\n    [else (do_algebra operator (cdr operand))]))\n",
  "  ;; (define (do_algebra operator operand)\n  ;; (define (do_algebra operator operand)\n\
    \  (cond \n    [(null? operand) 0]\n    [(null? (cdr operand)) \n     (cond \n\
    \       [(equal? operator '+) (+ (car operand) 1)]\n       [(equal? operator '-)\
    \ (- (car operand) 1)]\n       [(equal? operator '*') (* car operand)]\n     \
    \  [(equal? operator '//') (// car operand)]\n       [(equal? operator '**') (**\
    \ car operand)]\n       [(equal? operator '-') (- car operand)]\n       [(equal?\
    \ operator '*') (* car operand)]\n       [(equal? operator '//') (// car operand)]\n\
    \       [(equal? operator '**') (** car operand)]\n       [(equal? operator '-')\
    \ (- car operand)]\n       [(equal? operator '-') (- car operand)]\n       [else\
    \ (- car operand)]\n       )]\n    [else\n     (cond \n       [(equal? operator\
    \ '+) (+ (car operand) (do_algebra (car operator) (cdr operand)))]\n       [(equal?\
    \ operator '-) (- (car operand) (do_algebra (car operator) (cdr operand)))]\n\
    \       [(equal? operator '-) (- car operand)]\n       [(equal? operator '*')\
    \ (* car operand)]\n       [(equal? operator '//') (// car operand)]\n       [(equal?\
    \ operator '**') (** car operand)]\n       [(equal? operator '-') (- car operand)]\n\
    \       [(equal? operator '*') (* car operand)]\n       [(equal? operator '//')\
    \ (// car operand)]\n       [(equal? operator '**') (** car operand)]\n      \
    \ [(equal? operator '-') (- car operand)]\n       [(equal? operator '*') (* car\
    \ operand)]\n       [(equal? operator '//') (// car operand)]\n       [(equal?\
    \ operator '**') (** car operand)]\n       [(equal? operator '-') (- car operand)]\n\
    \       [else (- car operand)]\n       )]\n    ]))\n  ;; (define (do_algebra operator\
    \ operand)\n  ;; (define (do_algebra operator ", "  ;; Your code here.\n  ;; The\
    \ first part is the only required code. \n  (define (do_add operand-1 operand-2)\n\
    \    (+ operand-1 operand-2)\n  )\n  ;; Do the same thing for all the other operators\n\
    \  (define (do_mul operand-1 operand-2)\n    (* operand-1 operand-2)\n  )\n  ;;\
    \ Do the same thing for the other operators\n  (define (do_div operand-1 operand-2)\n\
    \    (// operand-1 operand-2)\n  )\n  ;; Do the same thing for the other operators\n\
    \  (define (do_exp operand-1 operand-2)\n    (** operand-1 operand-2)\n  )\n \
    \ (define (do_rem operand-1 operand-2)\n    (modulo operand-1 operand-2)\n  )\n\
    \  (define (do_power operand-1 operand-2)\n    (power operand-1 operand-2)\n \
    \ )\n  (define (do_power operand-1 operand-2)\n    (power operand-1 operand-2)\n\
    \  )\n  (define (do_mod operand-1 operand-2)\n    (modulo operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (// operand-1 operand-2)\n\
    \  )\n  (define (do_floor_divide operand-1 operand-2)\n    (", "  (cond\n    [(empty?\
    \ operand)\n     (list 'number 0)]\n    [(member (car operand) operator)\n   \
    \  (list 'number (- (car operand) (apply operator (cdr operand))))]\n    [else\n\
    \     (list 'error (list->string (list-of-operators (car operand))) \n       \
    \     (list->string operand))]\n  )\n  )\n", "  (if (null? operand)\n      '()\n\
    \      (cons ((car (car operand)) (do_algebra (car operator) (cdr operand)))\n\
    \            (do_algebra (cdr operator) (cons (car operand) (do_algebra (car operator)\
    \ (cons (cdr operand) (do_algebra (car operator) (cons (car operand) '())))))))))\n",
  "  (cond ( (empty? operator) (error \"Operator list is empty\"))\n        ((empty?\
    \ operand) (error \"Operand list is empty\"))\n        ((equal? (first (operator))\
    \ (first (operand))) (do_algebra (rest operator) (cons 1 (rest operand))))\n \
    \       ((equal? (first (operand)) (first (operator))) (do_algebra (rest operator)\
    \ (cons 1 (rest operand))))\n        ((equal? (first (operand)) '*') (do_algebra\
    \ '*' operand))\n        ((equal? (first (operand)) '-') (do_algebra '-' operand))\n\
    \        ((equal? (first (operand)) '-') (do_algebra '-' operand))\n        ((equal?\
    \ (first (operand)) '//') (do_algebra '//' operand))\n        ((equal? (first\
    \ (operand)) '**') (do_algebra '**' operand))\n        ((equal? (first (operator))\
    \ '+') (do_algebra '+' operand))\n        ((equal? (first (operator)) '-') (do_algebra\
    \ '-' operand))\n        ((equal? (first (operator)) '*') (do_algebra '*' operand))\n\
    \        ((equal? (first (operator)) '//') (do_algebra '//' operand))\n      \
    \  ((equal? (first (operator)) '**') (do_algebra '**' operand))\n        ((equal?\
    \ (first (operator)) '+') (do_algebra '+' operand))\n        ((equal? (first (operator))\
    \ '-') (do_algebra '-' operand))\n        ((equal? (first (operator)) '*') (do_algebra\
    \ '*' operand))\n        ((equal? (first (operator)) '//') (do_algebra '//' operand))\n\
    \        ((equal? (first (operator)) '**') (do_algebra '**' operand))\n      \
    \  ((equal? (first (operator)) '+') (do_algebra '+' operand))\n        ((equal?\
    \ (first (operator)) '-') (do_algebra '-' operand))\n        ((equal? (first (operator))\
    \ '*') (do_algebra '*' operand))\n        ((equal? (first (operator)) '//') (do_algebra\
    \ '//' operand))\n        ((equal? (first (operator)) '**') (do_algebra '**' operand))\n\
    \        ((equal? (first (operator)) '+') (do_algebra '+' operand))\n        ((equal?\
    \ (first (operator)) '-') (do_algebra '-' operand))\n", "  (define (do_operation\
    \ operation operand1 operand2)\n    (let ([val1 (apply operation operand1 operand2)]\n\
    \          [val2 (apply operation operand1 operand2)])\n      (cond\n        ((<\
    \ val1 operand2) (+ val1 (* val2 operand2)))\n        ((> val1 operand2) (- val1\
    \ (* val2 (- operand2 1)))) \n        ((< val2 operand2) (- val2 (* val1 (- operand1\
    \ 1)))) \n        ((> val2 operand2) (- val2 (* val1 (- operand1 1))))\n     \
    \   (else 0)))\n  (define (do_inverse_operation operation operand1 operand2)\n\
    \    (cond\n      ((> operand1 operand2) (- (/ operand1 operand2) operand1))\n\
    \      ((< operand1 operand2) (/ (- operand1 operand2) operand2))\n      (else\
    \ 0)))\n  (define (do_unary_operation operation operand1)\n    (cond\n      ((<\
    \ operand1 0) (+ operand1 operand1))\n      (else 0)))\n  (define (do_unary_operation_with_operand\
    \ operation operand)\n    (cond\n      ((< operand 0) (+ operand operand))\n \
    \     (else 0)))\n  (define (do_operation operation operand1 operand2)\n    (cond\n\
    \      ((eqv? operation '+) (+ operand1 operand2))\n      ((eqv? operation '-)\
    \ (- operand1 operand2))\n      ((eqv? operation '*') (* operand1 operand2))\n\
    \      ((eqv? operation '//') (/ operand1 operand2))\n      ((eqv? operation '**')\
    \ (* operand1 (** operand2)))\n      (else 0)))\n  (define (do_operator_list operator\
    \ operands)\n    (if (null? operands)\n        0\n        (+ ((apply do_operation\
    \ operation operands) (do_operator_list operator cdr operands)))))\n  (define\
    \ (do_unary_operation_list operator operands)\n    (if (null? operands)\n    \
    \    0\n        (+ ((apply do_unary_operation operation operands) (do_unary_operation_list\
    \ operator cdr operands)))))\n  (define (do_unary_operation_with_argument_list\
    \ operation operands)\n    (if (null? operands)\n        0\n        (+ ((apply\
    \ do_unary_operation_with_operand operation operands) (do_unary_operation_with_argument_list\
    \ operation cdr operands)))))\n  (define (do_unary_operation_with_argument_list\
    \ operation operands)\n    (if (null? operands)\n        0\n        (+ ((apply\
    \ do_unary_operation_with_operand operation operands) (do_", "  (cond [(empty?\
    \ operand)\n         (if (empty? (first operator))\n             operand\n   \
    \          (first operator))]\n        [(cons? operator)\n         (let ([op1\
    \ (first operator)\n                 op2 (first operand)])\n           (cond [(empty?\
    \ op1)\n                   (if (empty? operand)\n                       operand\n\
    \                       (first operand))]\n                 [(cons? op1)\n   \
    \                (cons (do_algebra op1 operand) (do_algebra op2 operand))]\n \
    \                [(cons? op2)\n                   (cons (do_algebra op1 operand)\
    \ (do_algebra op2 operand))]\n                 [(list? op1)\n                \
    \   (cons (do_algebra op1 operand) (do_algebra op2 operand))]\n              \
    \   [(list? op2)\n                   (cons (do_algebra op1 operand) (do_algebra\
    \ op2 operand))]\n                 [(number? op1)\n                   (cons (do_algebra\
    \ op1 operand) (do_algebra op2 operand))]\n                 [(number? op2)\n \
    \                  (cons (do_algebra op1 operand) (do_algebra op2 operand))]\n\
    \                 [else\n                   (error 'algebra 'operator)]))\n  \
    \       operand]\n        [else\n         (error 'algebra 'operator)]))\n", " \
    \ ;; Return the value of the given operator and operand pair.\n  (cond\n    [(=\
    \ (length operand) 0)\n     (error 'do_algebra \" empty operand or operator list\"\
    )]\n    [(= (length operator) 0)\n     (error 'do_algebra \" empty operator list\"\
    )]\n    [else\n     (cond [(= (operand-first operand) operator)\n            (operand-second\
    \ operand)\n            (* operand-first operand\n               operand-second\
    \ operand)\n            (/ operand-first operand\n               operand-second\
    \ operand)\n            (// operand-first operand\n               operand-second\
    \ operand)\n            (** operand-first operand\n               operand-second\
    \ operand)\n            (< operand-first operand\n               (+ operand-second\
    \ operand))]\n           [else (error 'do_algebra \" wrong number of operands\"\
    )]\n           )])\n", "  (cond\n    [(null? operand) 0]\n    [(null? (cdr operand))\
    \ (first operand)]\n    [else (+ \n            (do_algebra (first operand) (cdr\
    \ operand)) \n            (do_algebra (first operator) (cdr operator)))]))\n",
  "  (define (op lst n) (if (null? (car lst)) (+ 0 (* n n)) ((car lst) (op lst (cdr\
    \ lst) n))))\n  (define (op lst n acc) (if (null? (car lst)) (+ acc (* n n)) ((car\
    \ lst) (op lst (cdr lst) n (* acc acc)))))\n  (if (null? (car operand)) (op operator\
    \ operand 1)\n      (op operator operand 0 (op (car operand) (1+ 0) 0)))\n  (op\
    \ operator operand 0 (op (car operand) 0 1))\n  )\n", "  (cond\n    [(empty? operand)\
    \ (list operand)]\n    [(equal? (first operand) operator) (do_algebra (rest operator)\
    \ (first operand))]\n    [else (do_algebra (rest operator) (first operand))]))\n",
  "  (let ((a (list operand))\n        (b (list operand))\n        (c (list operand))\n\
    \        (d (list operand))\n        (- (append (cons 0 operator) (append a c)))\n\
    \        (/ (append (cons 0 operator) (append a c)))))\n  (append (append (append\
    \ (append (append (- (append (cons 0 operator) (append a c))) \n             \
    \              (append (append (append (cons 1 operator) (append a c))\n     \
    \                                      (append (append (cons 2 operator) (append\
    \ a c))))\n                            (append (append (cons 0 operator) (append\
    \ a c))\n                                          (append (append (cons 1 operator)\
    \ (append a c))\n                                           (append (cons 2 operator)\
    \ (append a c))))\n                            (append (append (cons 0 operator)\
    \ (append a c))\n                                          (append (append (cons\
    \ 1 operator) (append a c))\n                                           (append\
    \ (cons 2 operator) (append a c))))\n                            (append (append\
    \ (cons 0 operator) (append a c))\n                                          (append\
    \ (append (cons 1 operator) (append a c))\n                                  \
    \         (append (cons 2 operator) (append a c)))))\n                       \
    \  (append (append (append (append (- (append (cons 0 operator) (append a c))\n\
    \                                                            (append (append (cons\
    \ 1 operator) (append a c))\n                                                \
    \                          (append (append (cons 2 operator) (append a c))))\n\
    \                                                           (append (append (cons\
    \ 0 operator) (append a c))\n                                                \
    \                          (append (append (cons 1 operator) (append a c))\n \
    \                                                                          (append\
    \ (cons 2 operator) (append a c))))\n                                        \
    \                 (append (append (cons 0 operator) (append a c))\n          \
    \                                                                (append (append\
    \ (cons 1 operator) (append a c))\n                                          \
    \                                 (append (cons 2 operator) (append a c))))\n\
    \                                                         (append (append (cons\
    \ 0 operator) (append a c))\n                                                \
    \                          (append (append (cons 1 operator) (append a c))\n \
    \                                                                          (append\
    \ (cons 2 operator) (append a c)))))\n                         (append (append\
    \ (append (append (- (append (cons 0 operator) (append a c))\n               \
    \                                             (append (append (cons 1 operator)\
    \ (append a c))\n                                                            \
    \              (append (append (cons 2 operator) (append a c))))", "  (let ([o1\
    \ (reverse operand)\n         o2 (rest operand)]\n        [a (rest operand)]\n\
    \        [b (reverse operand)]\n        [c (reverse operand)]\n        [d (cond\
    \ [(null? o1) o2]\n                 [(null? o2) o1]\n                 [else (list\
    \ o1 o2)])])\n    (cond\n      [(equal? operator (first o1)) (+ (first o2) (first\
    \ c))]\n      [(equal? operator (first o2)) (+ (first a) (first c))]\n      [else\
    \ (error \"Unknown operator ~s\" operator)]))) \n", "  (cond [(null? operand)\
    \ #f]\n        [(equal? (car operand) (first operator)) (* 2 (do_algebra (rest\
    \ operator) (cdr operand)))]\n        [(equal? (car operand) (second operator))\
    \ (do_algebra (first operator) (cdr operand))]\n        [else (+ (do_algebra (first\
    \ operator) operand) (do_algebra (second operator) operand))]))\n", "  (if (null?\
    \ (cdr operator))\n      0\n      (+ (do_algebra (car operator)\n            \
    \       (car operand))\n         (do_algebra (cdr operator)\n                \
    \   (cdr operand)))))\n", "  ;; The base case (return 0 if length of operands\
    \ and operator lists are the same.)\n  (cond\n    ((or (null? operand) (null?\
    \ operator))\n     (if (or (null? operand) (null? operator))\n        0\n    \
    \    (/ 0 (- (- (length operator) 1) (length operand))))\n    (else\n      ;;\
    \ The recursive case:\n      (let ([left_op (car operator)]\n            [left_num\
    \ (car operand)])\n        (cond\n          ((or (null? left_op) (null? left_num))\n\
    \           (if (or (null? left_op) (null? left_num))\n               0\n    \
    \           (/ 0 (- (- (length left_op) 1) (length left_num)))))\n          (else\n\
    \           (let ([right_op (cdr operator)])\n             (cond\n           \
    \    ((or (null? right_op) (null? (cdr operand)))\n                (if (or (null?\
    \ right_op) (null? (cdr operand)))\n                   0\n                   (/\
    \ 0 (- (- (length right_op) 1) (length operand))))))\n               (else\n \
    \               ;; This case:\n                (let ([right_num (cdr operand)])\n\
    \                  (cond\n                    ((or (null? right_op) (null? (cdr\
    \ operand)))\n                     (if (or (null? right_op) (null? (cdr operand)))\n\
    \                         0\n                         (/ 0 (- (- (length right_op)\
    \ 1) (length operand))))))\n                    (else\n                     (*\
    \ left_num (do_algebra left_op right_op))))))))))\n</code>\n<|/ a tags=racket,scheme,functional-programming,lisp\
    \ |>\n<| c |>\nThank you for your solution! It looks neat. I think I would have\
    \ never got this one myself!\n<|/ c |>\n<| c |>\nIf this answer has helped you,\
    \ please accept it. Otherwise, a comment is needed.\n<|/ c |>\n<| c |>\nThank\
    \ you for your solution. I think your answer can be improved further by removing\
    \ the 'cond' for the base case and replacing it with 'if' statements to make it\
    \ a little more compact.\n<|/ c |>\n<| c |>\nSure, thanks. I wasn't sure if the\
    \ base case was needed since I didn't want to do any recursion. I'll edit my answer\
    \ accordingly.\n<|/ c |>\n<| a dscore=2 |>\nTo expand on Eli's answer, I propose\
    \ a solution that avoids recursion.  It uses some standard template for writing\
    \ a computational expression evaluator.  One such ", "  (define (eval-expr expr\
    \ operand)\n    (cond\n      [(null? expr) 0]\n      [(cons? (car expr)) (cons\
    \ (eval-expr (car expr) operand) (eval-expr (cdr expr) operand))]\n      [else\
    \ (+ (eval-expr expr operand) (eval-expr expr operand)])\n      )\n  (cond\n \
    \   [(equal? operator '+) (eval-expr operand operand)]\n    [(equal? operator\
    \ '-) (eval-expr operand operand)]\n    [(equal? operator '*) (eval-expr operand\
    \ operand)]\n    [(equal? operator '/) (eval-expr operand operand)]\n    [(equal?\
    \ operator '//) (eval-expr operand operand)]\n    [(equal? operator '**) (eval-expr\
    \ operand operand)]))\n", "  (if (null? operand)\n      0\n      (+ (do_algebra\
    \ (car operator) operand)\n         (do_algebra (cdr operator) operand))))\n",
  "  (if (null? operator)\n      (operand)\n      (let ([curr-op (car operator)])\n\
    \        (if (null? operand)\n            (cons (car operand) (do_algebra (cdr\
    \ operator) (cons (car operand) (do_algebra (cdr operand) (cons (car operand)\
    \ '())))))\n            (let ([curr-value (do_algebra (car operand) (cons (car\
    \ operand) (do_algebra (cdr operand) (cons (car operand) (do_algebra (cdr operand)\
    \ '())))))])\n              (if (equal? curr-op curr-value)\n                \
    \  (cons (car operand) (do_algebra (cdr operator) (cons (car operand) (do_algebra\
    \ (cdr operand) (cons (car operand) '())))))\n                  (cons (curr-op)\
    \ (do_algebra (cdr operator) (cons (curr-value) (do_algebra (cdr operand) '())))))\n\
    \              (cons (curr-op) (do_algebra (cdr operator) (cons (car operand)\
    \ (do_algebra (cdr operand) (cons (car operand) '())))))))\n      (define (eval-op\
    \ op v)\n        (if (and (number? v) (number? op))\n            (+ v op)\n  \
    \          (if (equal? op '+) (+ v 1)\n              (if (equal? op '-) (- v 1)\n\
    \                (if (equal? op '*) (* v 1)\n                  (if (equal? op\
    \ '//) (// v 1)\n                    (if (equal? op '**) (** v 1)\n          \
    \            v))))))))\n      (map (lambda(op v)\n             (eval-op op v))\n\
    \           operator\n           operand)))\n", "  (cond\n    [(empty? operator)\
    \ 0]\n    [else (+ \n            (do_algebra (cdr operator) operand) \n      \
    \      (do_algebra (car operator) operand))]))\n", "  (if (null? operator)\n \
    \     '()\n      (append (make-binary (caar operator)\n                      (caadr\
    \ operator)\n                      (make-binary (car operand)\n              \
    \                   0\n                                 (caddr operand))\n   \
    \                  do_algebra (cdr operator) (cdr operand)))))\n", "  (cond [(null?\
    \ operand)\n         (error \"Operand list is null.\")]\n        [(null? (rest\
    \ operand))\n         (error \"Operand list is too short or empty\")]\n      \
    \  [(equal? (car operand) '-)\n         (do_algebra '- (rest operand))]\n    \
    \    [(equal? (car operand) '*')\n         (do_algebra '* (rest operand))]\n \
    \       [(equal? (car operand) '//')\n         (do_algebra '// (rest operand))]\n\
    \        [(equal? (car operand) '**')\n         (do_algebra '** (rest operand))]\n\
    \        [else \n         (do_algebra (car operand) (append (rest operand) (list\
    \ (car operand))))]))\n", "  (cond\n    [(empty? operand) (error '(error-operands))]\n\
    \    [else\n      (if (= 0 (length operand))\n      (error '(error-operators))\n\
    \      ((car (car operand)) (+ (do_algebra (car operator) (cdr operand)))))]))\n",
  "  (if (null? operator)\n      (if (null? operand)\n          0\n          (+ 0\
    \ operand))\n      (if (null? (cdr operator))\n          (+ 0 (do_algebra (car\
    \ operand) (cdr operand)))\n          (+ (do_algebra (car operator) operand)\n\
    \             (do_algebra (cdr operator) operand))))) \n", "  (cond\n    [(empty?\
    \ operand) (error \"operand list is empty\")]\n    [(empty? operator) (error \"\
    operator list is empty\")]\n    [else (+ (do_algebra operator (rest operand))\
    \ \n             (do_algebra (first operator) (first operand))))]))\n", "  (cond\n\
    \    [(empty? operator) (first operand)]\n    [(empty? operand) 0]\n    [(equal?\
    \ (first operator) (first operand)) \n     (+ (do_algebra (rest operator) (rest\
    \ operand)))]\n    [else (+ (do_algebra (first operator) (first operand)) \n \
    \           (do_algebra (first operator) (rest operand)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
