name: HumanEval_36_fizz_buzz
language: rkt
prompt: "#lang racket\n\n;; Return the number of times the digit 7 appears in integers\
  \ less than n which are divisible by 11 or 13.\n;; >>> fizz_buzz(50)\n;; 0\n;; >>>\
  \ fizz_buzz(78)\n;; 2\n;; >>> fizz_buzz(79)\n;; 3\n(define (fizz_buzz n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n\
  \    (check-equal? (candidate 50) 0)\n    (check-equal? (candidate 78) 2)\n    (check-equal?\
  \ (candidate 79) 3)\n    (check-equal? (candidate 100) 3)\n    (check-equal? (candidate\
  \ 200) 6)\n    (check-equal? (candidate 4000) 192)\n    (check-equal? (candidate\
  \ 10000) 639)\n    (check-equal? (candidate 100000) 8026)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= n 1) 0]\n    [(= (mod n 11) 0) 1]\n    [(= (mod n\
    \ 13) 0) 2]\n    [else (fizz_buzz (sub1 n)))]))\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for the answer and for the link to Fizz-Buzz. I couldn't get the Racket\
    \ equivalent of Fizz-Buzz to work, but it looks like I misunderstood the example.\
    \ I'm glad that I finally got it working :)\n<|/ c |>\n<| c |>\nAs a minor nitpick,\
    \ you can remove `(= (mod n 13) 0)` from the second condition, as `(mod n 13)`\
    \ is zero for all multiples of `3`\n<|/ c |>\n<| a |>\n<code>", "  (cond [(= n\
    \ 0) 0]\n        [(= (modulo n 11) 0) 0]\n        [(= (modulo n 13) 0) 2]\n  \
    \      [else (+ 1 (fizz_buzz (- n 1))))))\n", "  (= (quotient n 11) (quotient\
    \ n 13)))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        ((= (modulo n\
    \ 11) 0) (+ 1))\n        ((= (modulo n 13) 0) (+ 1))\n        (else (fizz_buzz\
    \ (- n 1)))))\n", "  (define (buzz n count)\n    (if (= n 0)\n        count\n\
    \        (buzz (/ n 10) (incf count) (if (= (modulo n 11) (modulo n 13)) (incf\
    \ count) count))))\n  (buzz (min n 1000) 0))\n", "  (if (= n 0) 0\n      (if (=\
    \ (modulo n 11) 0)\n          (if (= (modulo n 13) 0)\n              1\n     \
    \         (+ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient\
    \ n 13)))\n      (+ 1 (fizz_buzz (quotient n 11)))))) ; #lang racket\n", "  (let\
    \ ((count 0))\n    (set! count (cond ((= (modulo n 11) 7) (add1 count))\n    \
    \                  ((= (modulo n 13) 7) (add1 count))\n                      (else\
    \ count))\n    (set! count (cond ((= (modulo n 11) 13) (add1 count))\n       \
    \               ((= (modulo n 13) 13) (add1 count))\n                      (else\
    \ count))\n    (set! count (cond ((= (modulo n 11) 17) (add1 count))\n       \
    \               ((= (modulo n 13) 17) (add1 count))\n                      (else\
    \ count))))\n", "  (if (= n 0)\n      0\n      (+ 1 (count (= (modulo n 11) (modulo\
    \ n 13)) #:when (= 7 n)))))\n", "  (/ (= 0 (remainder n 11)) (= 0 (remainder n\
    \ 13)))\n  (mod n 11))\n", "  (cond\n    ((= n 0) 0)\n    ((or (= n 1) (= n 2))\
    \ (+ 1 (fizz_buzz (- n 1))))\n    ((= n 3) (+ 1 (fizz_buzz (- n 2))))\n    ((=\
    \ n 4) (+ 1 (fizz_buzz (- n 3))))\n    ((= n 5) (+ 1 (fizz_buzz (- n 4))))\n \
    \   ((= n 6) (+ 1 (fizz_buzz (- n 5))))\n    ((= n 7) (+ 1 (fizz_buzz (- n 6))))\n\
    \    ((= n 8) (+ 1 (fizz_buzz (- n 7))))\n    ((= n 9) (+ 1 (fizz_buzz (- n 8))))\n\
    \    ((= n 10) (+ 1 (fizz_buzz (- n 9))))\n    ((= n 11) (+ 1 (fizz_buzz (- n\
    \ 10))))\n    ((= n 12) (+ 1 (fizz_buzz (- n 11))))\n    ((= n 13) (+ 1 (fizz_buzz\
    \ (- n 12))))\n    ((= n 14) (+ 1 (fizz_buzz (- n 13))))\n    ((= n 15) (+ 1 (fizz_buzz\
    \ (- n 14))))\n    ((= n 16) (+ 1 (fizz_buzz (- n 15))))\n    ((= n 17) (+ 1 (fizz_buzz\
    \ (- n 16))))\n    ((= n 18) (+ 1 (fizz_buzz (- n 17))))\n    ((= n 19) (+ 1 (fizz_buzz\
    \ (- n 18))))\n    ((= n 20) (+ 1 (fizz_buzz (- n 19))))\n    ((= n 21) (+ 1 (fizz_buzz\
    \ (- n 20))))\n    ((= n 22) (+ 1 (fizz_buzz (- n 21))))\n    ((= n 23) (+ 1 (fizz_buzz\
    \ (- n 22))))\n    ((= n 24) (+ 1 (fizz_buzz (- n 23))))\n    ((= n 25) (+ 1 (fizz_buzz\
    \ (- n 24))))\n    ((= n 26) (+ 1 (fizz_buzz (- n 25))))\n    ((= n 27) (+ 1 (fizz_buzz\
    \ (- n 26))))\n    ((= n 28) (+ 1 (fizz_buzz (- n 27))))\n    ((= n 29) (+ 1 (fizz_",
  "  (cond\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [(= n 3) 2]\n    [(= n 4) 3]\n \
    \   [else (* 3 (fizz_buzz (- n 1))) (+ 1 fizz_buzz (- n 1))]))\n", "  (if (> n\
    \ 0)\n      (floor (/ (+ (mod n 11) 2) 10))\n      (floor (/ (+ (mod n 13) 2)\
    \ 10))))\n", "  (cond [(= n 0)\n         0]\n        [(= (remainder n 11) 0)\n\
    \         (+ 1 (fizz_buzz (quotient n 11)))]\n        [(= (remainder n 13) 0)\n\
    \         (+ 1 (fizz_buzz (quotient n 13)))]\n        [else\n         (+ 1 (fizz_buzz\
    \ (quotient n 11)))]\n      )\n  )\n", "  (cond [(< n 10)(number-of-digits-7 n)]\n\
    \        [else (cond [(= (remainder n 11) 0)\n                     (= (remainder\
    \ n 13) 0)\n                     (= (remainder n 19) 0)\n                    \
    \ (= (remainder n 17) 0)\n                     (= (remainder n 9) 0)]\n      \
    \            [else (+ 1 (fizz_buzz (/ n 11)))]\n                  )])\n)\n", " \
    \ (cond ((= n 0) 0)\n        ((= n 1) 0)\n        (#t (+ 1 (quotient n 11) (quotient\
    \ n 13)))\n  )\n)\n", "  (cond\n    [(= n 0)\n     0]\n    [(= (mod n 11) 0)\n\
    \     (cond\n       [(= (mod n 13) 0)\n        2]\n       [else (+ 1 (fizz_buzz\
    \ (- n 13)))])]\n    [else (+ 1 (fizz_buzz (- n 11)))]))\n</cell>\n<code language=dyalog-kernel>\n\
    #lang racket\n", "  (cond\n    [(< n 0)\n     0]\n    [(and (= (modulo n 11) 0)\
    \ (= (modulo n 13) 0))\n     2]\n    [else (+ 1 (fizz_buzz (quotient n 11)))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= (modulo n 11) 1) 2]\n    [(=\
    \ (modulo n 13) 1) 3]\n    [else (fizz_buzz (- n 1))]))\n", "  (cond ((zero? n)\
    \ #t)\n        ((= (modulo (car n) 11) #f) #f)\n        ((= (modulo (car n) 13)\
    \ #f) #t)\n        (else (+ 1 (fizz_buzz (sub1 n))))))\n", "  (let ((nums (list\
    \ n n)))\n    (cond\n      [(< nums ((floor (/ nums 11)\n                    \
    \ 13\n                     (remainder nums 11)))) (sub1 nums)]\n      [(< nums\
    \ ((floor (/ nums 13)\n                     11\n                     (remainder\
    \ nums 13)))) (sub1 nums)]\n      [else 0])))\n", "  (let loop ((n n) (count 0))\n\
    \    (cond ((= n 0) (printf \"~a\\n\" count))\n          ((= (mod n 11) 0) (loop\
    \ (/ n 11) (+ count 1)))\n          ((= (mod n 13) 0) (loop (/ n 13) (+ count\
    \ 1)))))\n  count)\n", "  (cond ((< n 7) (+ 1 (fizz_buzz (quotient n 11))))\n\
    \        ((< n 13) (+ 1 (fizz_buzz (quotient n 13))))\n        (else 0)))\n",
  "  (let ((i1 n)\n        (i2 0)\n        (i3 0)\n        (i4 0))\n    (if (= (modulo\
    \ n 10) 7)\n        (i4)\n        (let ((tmp i))\n          (if (or (= tmp 11)\
    \ (= tmp 13))\n              (i3)\n              (if (= tmp 0)\n             \
    \     (i1)\n                  (fizz_buzz (- n tmp)))))\n        (let ((tmp i))\n\
    \          (if (or (= tmp 11) (= tmp 13))\n              (i3)\n              (if\
    \ (= tmp 0)\n                  (i1)\n                  (fizz_buzz (- n tmp)))))))))\n",
  "  (let loop ((count 0))\n    (cond ((= n 0) count)\n          ((= (remainder n\
    \ 11) 0) (loop (+ count 1)))\n          ((= (remainder n 13) 0) (loop (+ count\
    \ 2)))\n          (else (loop (+ count 0))))))\n", "  (count-divisible n 11 13))\n",
  "  (cond\n    [(= n 0)\n     0]\n    [(= n 1) 1]\n    [(= (modulo n 11) 0)\n   \
    \  (cond\n       [(= (modulo n 13) 0)\n        (+ n 1)]\n       [(= (modulo n\
    \ 13) 1)\n        (+ n 2)]\n       [else (+ n 3)]\n       )]\n    [else (+ n (fizz_buzz\
    \ (- n 1)))]\n    ))\n", "  (let*\n      ([s (string n)]\n       [t 0])\n    (for\
    \ ([i s])\n      (let ([f (car i)])\n        (if (or (= (modulo f 11) 0)\n   \
    \             (= (modulo f 13) 0))\n            (set! t (+ t (* f (modulo f 7))))))))\n\
    \  t)", "  (cond\n    [(= n 0)\n     0]\n    [(= n 1)\n     1]\n    [(= (mod n\
    \ 11) 0)\n     (cond\n       [(= (mod n 13) 0)\n        (+ n 3)]\n       [else\n\
    \        (+ n 4)]])]\n    [(= (mod n 13) 0)\n     (cond\n       [(= (mod n 11)\
    \ 0)\n        (+ n 2)]\n       [else\n        (+ n 3)]])]\n    [else\n     (+\
    \ n 4)]))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((even? n) (+ n\
    \ (fizz_buzz (- n 1))))\n    (else\n     (cond\n       ((or (= (modulo n 11 0)\
    \ 0) (= (modulo n 13 0) 0))\n        (+ 1 (fizz_buzz (- n 1)))\n       ((or (=\
    \ (modulo n 11 0) 0) (= (modulo n 13 0) 0))\n        (+ 1 (fizz_buzz (- n 1)))\n\
    \       ((or (= (modulo n 11 0) 0) (= (modulo n 13 0) 0))\n        (+ 1 (fizz_buzz\
    \ (- n 1)))\n       (else\n        (+ n (fizz_buzz (- n 1)))))))\n  )\n)", " \
    \ (cond\n    [(< n 11)    0]\n    [(< n 13    )  0]\n    [else  (+ (fizz_buzz\
    \ (quotient n 11)) (fizz_buzz (quotient n 13)))]\n  )\n)\n", "  (let* ((s (remainder\
    \ n 7))\n         (n (quotient n 7)))\n    (cond\n      [(< n 0)\n       (list\
    \ 0)]\n      [(= s 0)\n       (+ 1 (* n 3))]\n      [(= s 1)\n       (+ 1 (* n\
    \ 2))]\n      [(= s 2)\n       (+ 1 (* n 1))]\n      [(= s 3)\n       (+ 1 (*\
    \ n 0))]\n      [else\n       (+ 1 (fizz_buzz (- n 1)))])))\n", "  (define (count-digits\
    \ n)\n    (if (< n 10)\n        1\n        (if (and (>= n 7)\n               \
    \  (mod n 11))\n            2\n            (if (and (>= n 7)\n               \
    \      (mod n 13))\n                3\n                0)))\n    (count-digits\
    \ (/ n 10)))\n  (count-digits (/ n 10)))", "  (let loop ((n n) (count 0))\n  \
    \  (if (zero? n)\n        0\n        (if (= (modulo n 11) (modulo n 13))\n   \
    \         (loop (quotient n 11) (+ count 1))\n            (loop (quotient n 13)\
    \ (+ count 1))))\n    (modulo n 11)\n    (modulo n 13)))\n", "  (cond\n    ((=\
    \ n 1)     0)\n    ((= n 2)     1)\n    ((= n 3)     1)\n    ((= n 4)     0)\n\
    \    ((= n 5)     1)\n    ((= n 6)     1)\n    ((= n 7)     0)\n    ((= n 8) \
    \    1)\n    ((= n 9)     1)\n    ((= n 10)    1)\n    ((= n 11)    1)\n    ((=\
    \ n 12)    1)\n    ((= n 13)    0)\n    ((= n 14)    1)\n    ((= n 15)    1)\n\
    \    ((= n 16)    1)\n    ((= n 17)    1)\n    ((= n 18)    1)\n    ((= n 19)\
    \    1)\n    ((= n 20)    1)\n    ((= n 21)    1)\n    ((= n 22)    1)\n    ((=\
    \ n 23)    1)\n    ((= n 24)    1)\n    ((= n 25)    1)\n    ((= n 26)    1)\n\
    \    ((= n 27)    1)\n    ((= n 28)    1)\n    ((= n 29)    1)\n    ((= n 30)\
    \    1)\n    ((= n 31)    1)\n    ((= n 32)    1)\n    ((= n 33)    1)\n    ((=\
    \ n 34)    1)\n    ((= n 35)    1)\n    ((= n 36)    1)\n    ((= n 37)    1)\n\
    \    ((= n 38)    1)\n    ((= n 39)    1)\n    ((= n 40)    1)\n    ((= n 41)\
    \    1)\n    ((= n 42)    1)\n    ((= n 43)    1)\n    ((= n 44)    1)\n    ((=\
    \ n 45)    1)\n    ((= n 46)    1)\n    ((= n 47)    1)\n    ((= n 48)    1)\n\
    \    ((= n 49)    1)\n    ((= n 50)    1)\n    ((= n 51)    1)\n    ((= n 52)\
    \    1)\n    ((= n 53)    1)\n    ((= n 54)    1)\n    ((= n 55)    1)\n    ((=\
    \ n 56)    1)\n    ((= n 57)    1)\n    ((= n 58)    1)\n    ((= n 59)    1)\n\
    \    ((= n 60)    1)\n    ((= n 61)    1)\n    ((= n 62)    1)\n    ((= n 63)\
    \    1)\n    ((= n 64)    1)\n    ((= n 65)    1)\n    ((= n 66)    1)\n    ((=\
    \ n 67)    1)\n    ((= n ", "  (cond\n    [(< n 0) 0]\n    [(or (= (mod n 11)\
    \ 0) (= (mod n 13) 0))\n     (+ 1 (fizz_buzz (quotient n 11)))]\n    [else (fizz_buzz\
    \ (quotient n 13))]\n   ))\n", "  (cond\n    [(< n 1) 0]\n    [(and (integer?\
    \ n) (equal? n (mod n 11)))\n      (+ 1 (fizz_buzz (/ n 11)))]\n    [(and (integer?\
    \ n) (equal? n (mod n 13)))\n      (+ 1 (fizz_buzz (/ n 13)))]\n    [else (+ 1\
    \ (fizz_buzz (mod n 7)))]))\n</code>\n<|/ a |>\n<| a dscore=0 tags=racket,scheme,lisp\
    \ |>\nUsing recursion and modulo operations:\n<code>", "  (cond ((= n 1) '(1))\n\
    \        ((= n 11) '(1))\n        ((= n 13) '(1))\n        (else (cond\n     \
    \            ((= (remainder n 11) 0) (cons n '(1)))\n                 ((= (remainder\
    \ n 13) 0) (cons n (cons 3 1)))\n                 (else (fizz_buzz (quotient n\
    \ 11) (cons (remainder n 11) '(1)))\n                           (fizz_buzz (quotient\
    \ n 13) (cons (remainder n 13) '(1)))\n                           (fizz_buzz (quotient\
    \ n 11) (cons (remainder n 13) (cons 3 1)))\n                           (fizz_buzz\
    \ (quotient n 13) (cons (remainder n 11) (cons 3 (cons 3 1))))))))))\n</code>\n\
    <|/ a tags=scheme,racket |>\n<| c |>\nThis solution is much more elegant, and\
    \ much easier to read. Thanks for the help!\n<|/ c |>\n<| a tags=scheme,racket\
    \ |>\nThe problem is that the fizz function does not return the fizz string for\
    \ those numbers that divide the number evenly. Try this version:\n<code>\n#lang\
    \ racket\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= (modulo n\
    \ 11) 0)\n         (if (= (modulo n 13) 0) 1 2))\n        ((= (modulo n 11) 0)\n\
    \         (if (= (modulo n 13) 0) 1 3))\n        ((= (modulo n 11) 0)\n      \
    \   (if (= (modulo n 13) 0) 1 4))\n        ((= (modulo n 11) 0)\n         (if\
    \ (= (modulo n 13) 0) 1 5))\n        ((= (modulo n 11) 0)\n         (if (= (modulo\
    \ n 13) 0) 1 6))\n        ((= (modulo n 11) 0)\n         (if (= (modulo n 13)\
    \ 0) 1 7))\n        ((= (modulo n 11) 0)\n         (if (= (modulo n 13) 0) 1 8))\n\
    \        ((= (modulo n 11) 0)\n         (if (= (modulo n 13) 0) 1 9)\n       \
    \  (if (= (modulo n 13) 0) 1 10))\n        ((= (modulo n 11) 0)\n         (if\
    \ (= (modulo n 13) 0) 1 11)\n         (if (= (modulo n 13) 0) 1 12)\n        \
    \ (if (= (modulo n 13) 0) 1 13)\n         (if (= (modulo n 13) 0) 1 14)))\n</code>\n\
    <|/ a tags=fizzbuzz,scheme |>\n<| c |>\nWhy do you use the `equal?` instead of\
    \ `(= n 0)`? Isn't it a bit unnecessary?\n<|/ c |>\n<| c |>\nI believe it's a\
    \ matter of style. In my code I have `(= n 0)` rather than `(equal? n 0)`. Perhaps\
    \ I'm just used to using `equal?`, but I believe `=` is more readable and I find\
    \ the use of `equal?` more descriptive.\n<|/ c |>\n<| c |>\nIt's more descriptive,\
    \ sure, but it's not more readable. `=` makes it clear what you're doing, and\
    \ `equal?` makes it clear what you're comparing against.\n<|/ c |>\n<| a tags=fizzbuzz,scheme\
    \ |>\n<code>", "  (if (= (mod n 11) (mod n 13)) \n      (+ 1 0)\n      (+ (mod\
    \ n 11) 1)))\n", "  (cond [(= (modulo n 11) 0) 1]\n        [(= (modulo n 13) 0)\
    \ 3]\n        [else (+ (fizz_buzz (quotient n 11)) (fizz_buzz (quotient n 13)))]))\n\
    </code>\n<|/ a tags=racket,lisp,scheme,functional-programming,tail-recursion |>\n\
    <| c |>\nThis is more or less what I ended up doing, except I used `+` instead\
    \ of `-`, since I only wanted the final result to be positive.\n<|/ c |>\n<| a\
    \ dscore=3 |>\nIn scheme, the function call syntax is (name arg1 ... argn).\n\
    The name is the name of a function and all the arguments are the arguments of\
    \ the function.\nIn your case:\n<code>", "  (cond [(zero? n) 0]\n        [(or\
    \ (= (modulo n 11) (modulo n 13)) (= (modulo n 7) (modulo n 11) (modulo n 13)))\
    \ 1]\n        [else 0]))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((=\
    \ (modulo n 11) 0) 0)\n    ((= (modulo n 13) 0) 0)\n    (else (+ 1 (fizz_buzz\
    \ (quotient n 11))))))", "  (count\n   (lambda (x) (= (mod x 11) (mod x 13)))\n\
    \   (range\n    (floor n (/ 10 11))\n    (- n (/ 10 11)))))\n", "  (cond\n   \
    \ [(= n 0)\n     '']\n    [(even? (remainder n 11))\n     (cons (remainder n 11)\
    \ (fizz_buzz (quotient n 11)))]\n    [(even? (remainder n 13))\n     (cons (remainder\
    \ n 13) (fizz_buzz (quotient n 13)))]\n    [else (cons n (fizz_buzz (quotient\
    \ n 11))) (fizz_buzz (quotient n 13))]))\n", "  (cond\n    ((= n 0)\n     '())\n\
    \    ((= (modulo n 11) 0)\n     (cons 0 (fizz_buzz (modulo n 13))))\n    ((= (modulo\
    \ n 13) 0)\n     (cons 1 (fizz_buzz (modulo n 11))))\n    (else\n     (cons n\
    \ (fizz_buzz (quotient n 11))))))\n", "  (define (divisible n d m)\n    (cond\n\
    \      ((= m 11) 1)\n      ((= m 13) 2)\n      (else 0)))\n  (define (count n\
    \ d m)\n    (cond\n      ((= m 0) 0)\n      ((= m 11) 1)\n      ((= m 13) 2)\n\
    \      (else (divisible n d m) + 1))\n  (count n d m))", "  (cond [(< n 10)\n\
    \         (display n)\n         (newline)\n         0]\n        [(= (modulo n\
    \ 11)\n            (modulo n 13))\n         (fizz_buzz (quotient n 11))\n    \
    \     (fizz_buzz (quotient n 13))\n         0]))\n", "  (if (= n 0)\n      0\n\
    \      (count\n       (lambda (x)\n         (when (and (even? x)\n           \
    \         (<= (% x 11) (% x 13)))\n           (+ 1 (fizz_buzz (- x 1)))\n    \
    \       (+ (fizz_buzz (/ x 11)) (fizz_buzz (/ x 13))))\n         (floor (/ n 10))))))\
    \ ;; #lang racket\n", "  (let loop ([i 0])\n    (cond ((= n 0) 0)\n          ((=\
    \ n 1) 1)\n          ((= (modulo n 11) 0) 2)\n          ((= (modulo n 13) 0) 3)\n\
    \          ((= (modulo n 11) 0) (loop (+ i 1)))\n          ((= (modulo n 13) 0)\
    \ (loop (+ i 1)))\n          (else (loop (+ i 1))))))\n</code>\n<|/ a tags=scheme,recursion,racket\
    \ |>\n<| a tags=scheme,recursion,racket |>\nThis is very similar to what Rex's\
    \ answer says, however, instead of using recursion you might want to just use\
    \ loop and check against the numbers (which are integers) instead of dividing\
    \ them by 11 or 13 just so that you can increment the counter:\n<code>", "  (cond\
    \ ((= n 0) 0)\n        ((even? (remainder n 11)) (+ 1 (fizz_buzz (quotient n 11))))\n\
    \        ((even? (remainder n 13)) (+ 1 (fizz_buzz (quotient n 13))))\n      \
    \  (else (fizz_buzz (quotient n 11))))))\n</code>\n<|/ a |>\n<| c |>\nThe second\
    \ answer works well for small values of `n`. But, when `n` is large (for example,\
    \ `n = 50`), the program is too slow. You can use Racket to do this, it supports\
    \ primitive recursion (`fizz_buzz`, for example, is implemented using primitive\
    \ recursion).\n<|/ c |>\n<| c |>\nI appreciate the answer. But, I was looking\
    \ for a solution using `mod` only. Your answer uses `mod` and `cond-case`. Also,\
    \ when I use `mod` instead of `quotient`, my answer doesn't work. So, I came up\
    \ with an alternate solution. So, I'm sticking to my solution so far. But, I'll\
    \ surely upvote your answer for it's generality.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include an alternative solution that only uses `mod`.\n<|/ c |>\n\
    <| a tags=scheme,fizzbuzz,racket,mod,list dscore=1 |>\nThis was a fun exercise\
    \ to learn about functional programming in Racket. I've also thought about the\
    \ problem in a recursive way by building a function which works with either 'number'\
    \ or 'list' arguments.\n<code>", "  (cond [(= n 0)\n         (cond [(= (remainder\
    \ n 11) 0) 0]\n               [(= (remainder n 13) 0) 1]\n               [else\
    \ 2])]\n        [(= (remainder n 11) 0)\n         (cond [(= (remainder n 13) 0)\
    \ 1]\n               [else 2])]\n        [(= (remainder n 13) 0)\n         (cond\
    \ [(= (remainder n 11) 1) 2]\n               [else 3])]\n        [else 0]))\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a solution in Scheme which\
    \ avoids the overhead of cond. \n<code>", "  (cond\n    ((= n 0) 0)\n    ((= n\
    \ 1) 0)\n    ((= n 2) 0)\n    ((= (mod n 11) 0) 0)\n    ((= (mod n 13) 0) 2)\n\
    \    (else 3)))\n</code>\n<|/ a |>\n<| a tags=scheme,racket,sicp,lisp |>\n<code>",
  "  (cond\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [(= n 3) 2]\n    [(= n 4) 3]\n \
    \   [(= n 5) 4]\n    [(= n 6) 5]\n    [else (+ 1 (fizz_buzz (- n 7)))]))\n", " \
    \ (cond\n    [(< n 13) (fizz-buzz (quotient n 11))\n     (< n 11) (fizz-buzz (quotient\
    \ n 13))]\n    [else n]))\n", "  (let ((i1 (quotient n 11))\n        (i2 (quotient\
    \ n 13))\n        (i3 (quotient n 17)))\n    (if (= i1 0)\n        (if (= i2 0)\n\
    \            (if (= i3 0)\n                0\n                2)\n           \
    \ (if (= i3 1)\n                3\n                6))\n        (if (= i2 1)\n\
    \            (if (= i3 0)\n                1\n                3)\n           \
    \ (if (= i3 1)\n                4\n                6))\n        (if (= i1 1)\n\
    \            (if (= i2 0)\n                2\n                4)\n           \
    \ (if (= i2 1)\n                5\n                6)))))\n", "  (define (divisible?\
    \ n div mod mods)\n    (cond\n      [(zero? n) false]\n      [(div = 7) (= (mod\
    \ n div) mod) true]\n      [(div = 11) (and (= (mod n div) mod) (<= mod mod 11))\
    \ true]\n      [(div = 13) (and (= (mod n div) mod) (<= mod mod 13)) true]\n \
    \     [else false]))\n  (define (fizz_buzz-loop n n div mods divs)\n    (cond\n\
    \      [(zero? n) 0]\n      [(divisible? n div mods divs)\n       (add1 (fizz_buzz-loop\
    \ n (quotient n div) (quotient div mods) mods divs))]\n      [else (add1 (fizz_buzz-loop\
    \ n (quotient n div) mods divs))]))\n  (fizz_buzz-loop n n 7 [11 13] [1 3 5 7\
    \ 9 11]))", "  (if (= n 0)\n      0\n      (let ((count 0))\n        (loop\n \
    \          (when (= (modulo n 11) 0)\n             (set! count (+ count 1)))\n\
    \           (when (= (modulo n 13) 0)\n             (set! count (+ count 1)))\n\
    \           (when (= (modulo n 7) 0)\n             (set! count (+ count 1))))))))\n",
  "  (let loop ((n n) (count 0))\n    (if (= n 0)\n        count\n        (if (= (modulo\
    \ n 11) 0)\n            (loop (remainder n 13) (inc count))\n            (loop\
    \ (quotient n 11) (if (= (modulo n 13) 0) (inc count) count))))))\n", "  (let\
    \ ([d (modulo n 11)\n         c (modulo n 13)])\n    (cond\n      [(= d 7)\n \
    \      (cond\n         [(= c 0)\n          (display n)]\n         [(= c 1)\n \
    \         (display \"Fizz\")\n          (newline)]\n         [(= c 2)\n      \
    \    (display \"Buzz\")\n          (newline)]\n         [else\n          (display\
    \ \"FizzBuzz\")\n          (newline)]\n         )])\n      (else (fizz_buzz (+\
    \ n d)))))\n", "  (cond\n    [(< n 0) 0]\n    [else (cond\n            ;; Return\
    \ how many times 7 appears in integers less than n which are divisible by 11 or\
    \ 13.\n            [(= (remainder n 11) 0) (+ 2 (fizz_buzz (/ n 11)))]\n     \
    \       [else (+ 3 (fizz_buzz (/ n 13)))]))]))\n", "  (cond\n    [(< n 1) 0]\n\
    \    [(= (modulo-or-divide n 11 3) 7) 2]\n    [(= (modulo-or-divide n 13 3) 7)\
    \ 3]\n    [else (fizz_buzz (- n 1))]))\n", "  (cond [(= n 0)\n         0]\n  \
    \      [(= (modulo n 11) 0)\n         1]\n        [(= (modulo n 13) 0)\n     \
    \    2]\n        [else\n         (fizz_buzz (quotient n 11))\n         3]\n  \
    \      [(= (modulo n 13) 0)\n         (fizz_buzz (quotient n 13))\n         4]\n\
    \        [else\n         (fizz_buzz (quotient n 11))\n         5]\n        [else\n\
    \         (fizz_buzz (quotient n 13))\n         6]\n        [else\n         (fizz_buzz\
    \ (quotient n 11))\n         7]\n        [else\n         (fizz_buzz (quotient\
    \ n 13))\n         8]\n        [else\n         (fizz_buzz (quotient n 11))\n \
    \        9]\n        [else\n         (fizz_buzz (quotient n 13))\n         10]\n\
    \        [else\n         (fizz_buzz (quotient n 11))\n         11]\n        [else\n\
    \         (fizz_buzz (quotient n 13))\n         12]\n        [else\n         (fizz_buzz\
    \ (quotient n 11))\n         13]\n        [else\n         (fizz_buzz (quotient\
    \ n 13))\n         14]\n        [else\n         (fizz_buzz (quotient n 11))\n\
    \         15]\n        [else\n         (fizz_buzz (quotient n 13))\n         16]\n\
    \        [else\n         (fizz_buzz (quotient n 11))\n         17]\n        [else\n\
    \         (fizz_buzz (quotient n 13))\n         18]\n        [else\n         (fizz_buzz\
    \ (quotient n 11))\n         19]\n        [else\n         (fizz_buzz (quotient\
    \ n 13))\n         20]\n        [else\n         (fizz_buzz (quotient n 11))\n\
    \         21]\n        [else\n         (fizz_buzz (quotient n 13))\n         22]\n\
    \        [else\n         (fizz_buzz (quotient n 11))\n         23]\n        [else\n\
    \         (fizz_buzz (quotient n 13))\n         24]\n        [else\n         (fizz_buzz\
    \ (quotient n 11))\n         25]\n        [else\n         (fizz_buzz (quotient\
    \ n ", "  (cond ((= n 0) 0)\n        ((= (remainder n 11) 0) 1)\n        ((= (remainder\
    \ n 13) 0) 2)\n        (else (+ 3 (fizz_buzz (quotient n 11)))\n             \
    \  (+ 2 (fizz_buzz (quotient n 13)))\n               (+ 1 (fizz_buzz (remainder\
    \ n 13))))))\n", "  (if (= n 0) 0\n      (if (or (= (modulo n 11) (modulo n 13))\n\
    \               (= (modulo n 13) (modulo n 11)))\n          2\n          (+ 1\
    \ (fizz_buzz (quotient n 11))))))\n</cell>\n<code language=racket-csi>", "  (let\
    \ loop ((n n)\n             (result 0))\n    (cond\n      [(= n 0)\n       result]\n\
    \      [(= (modulo n 11) (modulo n 13))\n       (loop (quotient n 11)\n      \
    \       (+ result 1))]\n      [(= (modulo n 13) (modulo n 11))\n       (loop (quotient\
    \ n 13)\n             (+ result 1))]\n      [else\n       (loop (quotient n 10)\n\
    \             (+ result 1))]\n    )\n    result))\n", "  (cond ((= n 0) 0)\n \
    \       (else (if (= (remainder n 11) 0) \n                   (+ (fizz_buzz (/\
    \ n 11)) 1)\n                   (if (= (remainder n 13) 0)\n                 \
    \      (+ (fizz_buzz (/ n 13)) 1)\n                       (+ n 1))))))\n</code>\n\
    <|/ a tags=racket,fizzbuzz |>\n<| a tags=racket,fizzbuzz dscore=1 |>\nHere is\
    \ a more concise version in Python:\n<code>\ndef fizzbuzz(n):\n    if n == 0:\n\
    \        return\n    elif n == 1:\n        return\n    elif n % 3 == 0:\n    \
    \    return\n    elif n % 5 == 0:\n        return\n    elif n % 7 == 0:\n    \
    \    return\n    elif n % 11 == 0:\n        return\n    elif n % 13 == 0:\n  \
    \      return\n    else:\n        return n\n\nprint(fizzbuzz(50))\n</code>\n<|/\
    \ a |>\n<| a tags=racket,fizzbuzz |>\n<code>", "  (local\n    [(define (fizz_buzz-loop\
    \ (n remainder)\n                       (cond\n                        [(remainder\
    \ 0 '())\n                         (= remainder 7)\n                         (cons\
    \ n remainder)]))]\n    [(define (fizz_buzz-loop n remainder)\n      (fizz_buzz-loop\
    \ (quotient n 11)\n                       (remainder (quotient n 11)))])])\n \
    \ (cond [(<= n 0)\n         (error 'fizz_buzz-not-less-than \"The argument must\
    \ be greater than zero.\")]\n        [(zero? (remainder 0 7))\n         (error\
    \ 'fizz_buzz-not-divisible-by-11 \"The argument must be divisible by 11.\")]\n\
    \        [(zero? (remainder 0 13))\n         (error 'fizz_buzz-not-divisible-by-13\
    \ \"The argument must be divisible by 13.\")]\n        [else (fizz_buzz-loop n\
    \ (remainder (quotient n 7)))]\n    )\n  )\n)", "  (cond ((= n 0) 0)\n       \
    \ ((= (remainder n 11) 0) 0)\n        ((= (remainder n 13) 0) 0)\n        ((=\
    \ (remainder n 7) 0) 1)\n        (else (fizz_buzz (- n 1)))))\n", "  (let-values\
    \ ([(fizz buzz) (/ (modulo n 11) 13)]) (if (= fizz 7) (+ buzz 0)))\n  )\n", " \
    \ (define (count-digits n)\n    (cond\n      [(= n 0) 0]\n      [(even? n) (count-digits\
    \ (remainder n 10))]\n      [(odd? n) (cond (even? (remainder n 11)) (1+ (count-digits\
    \ (remainder n 11)))\n                        (even? (remainder n 13)) (1+ (count-digits\
    \ (remainder n 13)))\n                        (else (count-digits (remainder n\
    \ 10)))])\n      [(= (remainder n 10) (7)) (+ 1 (count-digits (remainder n 10)))]\n\
    \      [(= (remainder n 10) (13)) (+ 1 (count-digits (remainder n 10)))]\n   \
    \   [else (+ 1 (count-digits (remainder n 10)))]))\n  (count-digits n))\n", " \
    \ (cond [(= n 0)\n         0]\n        [(= n 1)\n         (* 3 0)]\n        [(=\
    \ (modulo n 11) 0)\n         (* 2 0)]\n        [(= (modulo n 13) 0)\n        \
    \ (* 3 0)]\n        [(= (modulo n 15) 0)\n         (* 3 0)]\n        [else\n \
    \        (if (= (modulo n 7) 0)\n           (+ 1 (fizz_buzz (- n 1)))\n      \
    \     (+ (fizz_buzz (- n 1)) 1))]))\n</cell>\n<text>\nThe above code is more readable.\
    \ However, the cond expression still seems too unwieldy to read. How about we\
    \ write a helper function which returns one if the number is divisible by 7, and\
    \ 0 if the number is not divisible by 7.\n\n\n</text>\n<cell>", "  (cond [(= n\
    \ 0) 0]\n        [(= (modulo n 11) 0) 1]\n        [(= (modulo n 13) 0) 2]\n  \
    \      [else\n         (if (= (modulo n 7) 7) 3)]\n        ))\n", "  (let loop\
    \ ([n n])\n    (if (< n 11)\n        (+ n (loop (quotient n 11)))\n        (if\
    \ (< n 13)\n            (+ n (loop (quotient n 13)))\n            (if (= (modulo\
    \ n 11) (modulo n 13))\n                (+ n (loop (quotient n 11)))\n       \
    \         (+ n (loop (quotient n 13))))))))\n", "  (count-until-divisable 7 n\
    \ '(1 3 5 7 9 11)))\n", "  (let loop ((i 1))\n    (cond ((= i n) i)\n        \
    \  ((= (remainder i 11) 0)\n           (loop (+ i 1)))\n          ((= (remainder\
    \ i 13) 0)\n           (loop (+ i 1)))\n          (else (loop (+ i 1))))))\n",
  "  (cond\n    ((= n 0) 0)\n    ((even? (remainder n 11)) (+ 1 (fizz_buzz (quotient\
    \ n 11))))\n    ((even? (remainder n 13)) (+ 1 (fizz_buzz (quotient n 13))))\n\
    \    (t (+ 1 (fizz_buzz (quotient n 10))))))\n", "  (let ((count 0))\n    (loop\
    \ i n\n      (if (even? i)\n          (if (= (modulo i 3) 0)\n              (if\
    \ (= (modulo i 7) 0)\n                  (set! count (add1 count))\n          \
    \        count)\n              (set! count (add1 count)))\n          (set! count\
    \ (add1 count)))\n      count))\n  count)\n", "  (cond\n    [(< n 100) (+ (mod\
    \ n 11) (mod n 13))])\n)\n", "  (count-seven (quotient n 11) (quotient n 13)))\n",
  "  (let* ((factors (rnr (map list (range 1 (expt n 11))) (map list (range 11 (expt\
    \ n 13))))) ; Create a list of all factors and its multiples\n         (sums (map\
    \ add1 (filter positive? factors))) ; Create a list of the sums of factors\n \
    \        (rest (filter odd? sums)) ; Find the rest\n         (count (length rest)))\
    \ ; Get the count of fizz buzz\n  (printf \"~d\\n\" count)))\n", "  (if (<= n\
    \ 15)\n      (+ 1 (mod n 11))\n      (+ 1 (mod n 13))))\n</code>\n<|/ a |>\n<|\
    \ a |>\nYou don't even need the FizzBuzz table, or even the list of numbers. You\
    \ only need to keep track of the number itself.\n<code>", "  (if (zero? n) 0\n\
    \      (+ 1 (+ (or (= (modulo n 11) 0) (= (modulo n 13) 0))\n                \
    \  (modulo n 11))\n            (if (= (modulo n 11) 0)\n                0\n  \
    \              (+ 1 (modulo n 13))\n              (modulo n 13)))))", "  (cond\n\
    \    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= (modulo (quotient n 11) 11) 0) 1)\n\
    \    ((= (modulo (quotient n 11) 13) 0) 2)\n    (else (fizz_buzz (quotient n 11)))))\n",
  "  (let ((a (mod n 11)) (b (mod n 13))) \n    (cond\n      [(= a 0) 0]\n      [(=\
    \ b 0) 1]\n      [(= b 1) 2]\n      [else (+ 3 (fizz_buzz (- n a)))]))))\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=recursion,racket,scheme |>\nThis is what I came up\
    \ with, using your first example, and using your second example:\n<code>", " \
    \ (if (= n 0)\n      0\n      (cond [(or (= (remainder n 11) 0) (= (remainder\
    \ n 13) 0))\n             (if (= (remainder n 7) 7)\n                 0\n    \
    \             (+ 1))]\n        [else (+ 1)])))\n", "  (define (count-7-digits\
    \ x)\n    (cond\n      [(= (remainder x 7) 0)\n       (add 1 x)]\n      [(= (remainder\
    \ x 7) 1)\n       (add 1 x)]\n      [(= (remainder x 7) 2)\n       (add 1 x)]\n\
    \      [else\n       (add 1 x)]))\n  (if (< n 100)\n    (cond [(= (mod n 11) 0)\n\
    \           (add 1 n)]\n          [else\n           (cond [(= (mod n 13) 0)\n\
    \                  (add 1 n)]\n                    [else\n                   \
    \ (add\n                     (count-7-digits (remainder n 10))\n             \
    \        (count-7-digits (quotient n 10)))]))])\n  (if (< n 1000)\n    (cond [(=\
    \ (mod n 11) 0)\n           (add 1 n)]\n          [else\n           (cond [(=\
    \ (mod n 13) 0)\n                  (add 1 n)]\n                    [else\n   \
    \                 (add\n                     (count-7-digits (remainder n 100))\n\
    \                     (count-7-digits (quotient n 100)))]))])\n  (if (< n 10000)\n\
    \    (cond [(= (mod n 11) 0)\n           (add 1 n)]\n          [else\n       \
    \    (cond [(= (mod n 13) 0)\n                  (add 1 n)]\n                 \
    \   [else\n                    (add\n                     (count-7-digits (remainder\
    \ n 1000))\n                     (count-7-digits (quotient n 1000)))]))])\n  (if\
    \ (< n 100000)\n    (cond [(= (mod n 11) 0)\n           (add 1 n)]\n         \
    \ [else\n           (cond [(= (mod n 13) 0)\n                  (add 1 n)]\n  \
    \                  [else\n                    (add\n                     (count-7-digits\
    \ (remainder n 100000))\n                     (count-7-digits (quotient n 100000)))]))])\n\
    \  (if (< n 1000000)\n    (cond [(= (mod n 11) 0)\n           (add 1 n)]\n   \
    \       [else\n           (cond [(= (mod n 13) 0)\n                  (add 1 n)]\n\
    \                    [else\n                    (add\n                     (count-7-digits\
    \ (remainder n 1000000))\n                     (count-7-digits (quotient n 1000000)))]))])\n\
    \  (if (< n 10000000)\n    (cond [(= (mod n 11) 0)\n           (add 1 n)]\n  \
    \        [else\n           (cond [(= (mod n 13) 0)\n                  (add 1 n)]",
  "  (letrec ([divisor (lambda (x) (= x 11) (= x 13))])\n    (cond\n      [(divisor\
    \ (remainder n 10)) 0]\n      [(divisor (quotient n 10)) 1]\n      [else 2])))\n",
  "  (cond [(zero? n) 0]\n        [(even? n) 0]\n        [(zero? (remainder n 11))\
    \ (+ n (fizz_buzz (quotient n 11)))]\n        [(zero? (remainder n 13)) (+ n (fizz_buzz\
    \ (quotient n 13)))]\n        [else (+ 1 (fizz_buzz n))]))\n", '  (/ (log (- (mod
    n 11) 13) 7) (/ n 11)))', "  (cond\n    [(= n 1) 0]\n    [(= (modulo n 11) 0)\
    \ (if (= (modulo n 11) 3) 2 1)]\n    [(= (modulo n 13) 0) (if (= (modulo n 13)\
    \ 3) 2 1)]\n    [else (+ 1 (fizz_buzz (quotient n 11)))]))\n", "  (define (helper\
    \ n i j)\n    (cond\n      [(= (mod n 11) 0) '(0 1 2 3 4 5 6 7 8)] \n      [(=\
    \ (mod n 13) 0) '(0 1 2 3 4 5 6 7 8 9 10)] \n      [(= (= i j) 0) '(0 1 2 3 4\
    \ 5 6 7 8 9 10 11 12 13 14 15)]\n      [else (helper (/ n 11) (+ i 1) (+ j 1))]))\n\
    \  (helper (/ n 11) 0 0))\n", "  (cond\n    ((< n 1)\n     '())\n    ((zero? (modulo\
    \ n 11))\n     (cond ((zero? (modulo n 13))\n            (cond ((= (modulo n 11)\
    \ 0)\n                   (cond ((= (modulo n 13) 0)\n                        \
    \   (list \"0\")\n                           (list (cons \"11\" \"13\"))))\n \
    \                    ((= (modulo n 13) 1)\n                       (list \"11\"\
    ))\n                     ((= (modulo n 13) 2)\n                       (list \"\
    13\"))\n                     ((= (modulo n 13) 3)\n                       (list\
    \ \"13\"))\n                     ((= (modulo n 13) 4)\n                      \
    \ (list \"13\"))\n                     ((= (modulo n 13) 5)\n                \
    \       (list \"13\"))\n                     ((= (modulo n 13) 6)\n          \
    \             (list \"13\"))\n                     ((= (modulo n 13) 7)\n    \
    \                   (list \"13\"))\n                     ((= (modulo n 13) 8)\n\
    \                       (list \"13\"))\n                     ((= (modulo n 13)\
    \ 9)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 10)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 11)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 12)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 13)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 14)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 15)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 16)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 17)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 18)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 19)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 20)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 21)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 22)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 23)\n                       (list \"13\"))\n                     ((= (modulo\
    \ n 13) 24)\n                       (list \"13\"))\n                     ((",
  "  (let loop ((n n) (c '(7 7)) (out '()))\n    (cond ((= n 0) (list out))\n    \
    \      ((= (modulo n 11) 0) (loop (quotient n 11) (cons (car c) c) (cons (car\
    \ (cdr c)) (cdr out))))\n          ((= (modulo n 13) 0) (loop (quotient n 13)\
    \ (cons (car c) c) (cons (car (cdr c)) (cdr out))))\n          (else (loop (quotient\
    \ n 10) (cons (car c) c) (cons (car (cdr c)) (cdr out)))))\n    (loop (quotient\
    \ n 10) '() '())))\n</code>\n<|/ a |>\n<| c |>\nThis looks promising but why is\
    \ `loop` recursively called?\n<|/ c |>\n<| c |>\nThe recursive call is because\
    \ each number in the sequence is divisible by 11 or 13. The first number is divisible\
    \ by 11, so the second number is divisible by 13. So the first number is divisible\
    \ by 11 and the first number is divisible by 13. The first number is divisible\
    \ by 11, so the second number is divisible by 13, the second number is divisible\
    \ by 11, and the second number is divisible by 13, etc. So the recursive call\
    \ is needed to produce the full list of numbers which are divisible by 11 or 13.\n\
    <|/ c |>\n<| c |>\nOk, I think I understand. So if I wrote `(define (fizz_buzz\
    \ n) (loop (quotient n 10) (cons (car c) c) (cons (car (cdr c)) (cdr out))))`\
    \ then I would essentially just write `(loop (quotient n 10) (cons (car c) c)\
    \ (cons (car (cdr c)) (cdr out)))))` and thus just write `(define (fizz_buzz n)\
    \ (let loop ((n n) (c '(7 7)) (out '()))\n  (cond ((= n 0) (list out))\n     \
    \   ((= (modulo n 11) 0) (loop (quotient n 11) (cons (car c) c) (cons (car (cdr\
    \ c)) (cdr out))))\n        ((= (modulo n 13) 0) (loop (quotient n 13) (cons (car\
    \ c) c) (cons (car (cdr c)) (cdr out))))\n        (else (loop (quoti", "  (if\
    \ (= n 0)\n      0\n      (let ((m (modulo n 11)))\n        (if (= m 7)\n    \
    \        (+ (fizz_buzz (- n m)) 1)\n            (fizz_buzz (- n m)))))) ; <- this\
    \ line is highlighted as wrong\n", "  (cond ((= n 0) 0)\n        ((= n 1) 1)\n\
    \        (#t (+ 3 (fizz_buzz (/ n 11)) (fizz_buzz (/ n 13))))))\n", "  (let loop\
    \ ((n n) (count 0))\n    (cond\n      [(< n 0) count]\n      [(= (modulo (modulo\
    \ n 11) 13) 0) count]\n      [(= (modulo n 11) 0) (loop (quotient n 11) (inc count))]\n\
    \      [(= (modulo n 13) 0) (loop (quotient n 13) (inc count))]\n      [else (loop\
    \ (quotient n 11) (add 1 count))]\n      )))\n", "  (let loop ((count 0))\n  \
    \  (if (< n 0)\n        count\n        (if (or (= (mod n 11) 0) (= (mod n 13)\
    \ 0))\n            (loop (+ count 1))\n            (loop (+ count 0)))\n     \
    \   count)))\n", "  (letrec ((loop ((x n) (y 1))\n             (cond (\n     \
    \          (= (remainder x 11) (ormap y (quotient x 11)))\n               (= (remainder\
    \ x 13) (ormap y (quotient x 13)))\n               (= x y) 0\n               (>\
    \ x n) (loop n (+ y 1))))))\n    (loop n 1)))\n", "  (if (= n 0)\n      0\n  \
    \    (+ 1\n         (if (= (modulo n 13) 7)\n               (if (= (modulo n 11)\
    \ 7)\n                   0\n                   (+ 1 (fizz_buzz (- n 1)))\n   \
    \                (+ 1 (fizz_buzz (- n 2)))\n                   (+ 1 (fizz_buzz\
    \ (- n 3))))\n               (if (= (modulo n 11) 7)\n                   0\n \
    \                  (+ 1 (fizz_buzz (- n 1)))\n                   (+ 1 (fizz_buzz\
    \ (- n 2)))\n                   (+ 1 (fizz_buzz (- n 3))))\n               (if\
    \ (= (modulo n 13) 7)\n                   0\n                   (+ 1 (fizz_buzz\
    \ (- n 1)))\n                   (+ 1 (fizz_buzz (- n 2)))\n                  \
    \ (+ 1 (fizz_buzz (- n 3))))\n               (+ 1 (fizz_buzz (- n 1))))))\n",
  "  (let ((cnt 0))\n    (cond [(= n 0)\n           (printf \"\\n\")]\n          [(=\
    \ (remainder n 11) 0)\n           (set! cnt (+ 1 (fizz_buzz (quotient n 11))))]\n\
    \          [(= (remainder n 13) 0)\n           (set! cnt (+ 1 (fizz_buzz (quotient\
    \ n 13))))]\n          [else\n           (set! cnt (+ 1 (fizz_buzz (quotient n\
    \ 10))))]\n          [cnt]))))\n", "  (cond\n    [(< n 0) 0]\n    [(mod n 11)\
    \ 2]\n    [(mod n 13) 3]\n    [else (+ (fizz_buzz (quotient n 11)) (fizz_buzz\
    \ (quotient n 13)))]))\n", "  (if (or (= n 1) (= n 7))\n      0\n      (+ 1 (apply\
    \ (lambda (x) (modulo n 11)) (modulo n 13)))\n  )\n)\n", "  (cond [(= n 0)\n \
    \        0]\n        [(= (mod-by-one n) 7)\n         (+ 0 (fizz_buzz (floor (/\
    \ n 11)))\n               (fizz_buzz (floor (/ n 13))))]\n        [else\n    \
    \     (+ 1 (fizz_buzz (floor (/ n 11)))\n               (fizz_buzz (floor (/ n\
    \ 13))))]))\n", "  (cond\n    [(< n 7) (count (list-ref '(7 7 7) (quotient n 11)\
    \ (quotient n 13)))]\n    [else 0]))\n", "  (cond\n    ((= n 0)\n     (cond\n\
    \       ((= (modulo n 11) 0)\n        (cond\n          ((= (modulo n 13) 0)\n\
    \           (string-append \"fizzbuzz\")\n          (else (string-append \"fizz\"\
    ))))\n       ((= (modulo n 13) 0)\n        (cond\n          ((= (modulo n 11)\
    \ 0)\n           (string-append \"buzz\")\n          (else (string-append \"buzz\"\
    ))))\n       (else (string-append \"zero\"))))\n    ((= n 1)\n     (cond\n   \
    \    ((= (modulo n 11) 0)\n        (cond\n          ((= (modulo n 13) 0)\n   \
    \        (string-append \"fizzbuzz\")\n          (else (string-append \"fizz\"\
    ))))\n       ((= (modulo n 13) 0)\n        (cond\n          ((= (modulo n 11)\
    \ 0)\n           (string-append \"buzz\")\n          (else (string-append \"buzz\"\
    ))))\n       (else (string-append \"one\"))))\n    (else (string-append \"other\"\
    ))))\n", "  (cond\n    [(< n 3) 0]\n    [(< n 7) 2]\n    [(< n 17) 3]\n    [else\
    \ 4]\n  ))\n  ", "  (cond\n    [(= n 0)\n     '()]\n    [(= (modulo n 11) 0)\n\
    \     '()]\n    [(= (modulo n 13) 0)\n     '()]\n    [else\n     (let ((x (modulo\
    \ n 11)))\n       (cond\n         [(= x 7)\n          (if (> n 79)\n         \
    \     (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz (modulo n\
    \ 11)))\n              (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz\
    \ (modulo n 11))))]\n         [(= x 8)\n          (if (> n 79)\n             \
    \ (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz (modulo n 11)))\n\
    \              (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz\
    \ (modulo n 11))))]\n         [(= x 9)\n          (if (> n 79)\n             \
    \ (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz (modulo n 11)))\n\
    \              (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz\
    \ (modulo n 11))))]\n         [(= x 10)\n          (if (> n 79)\n            \
    \  (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz (modulo n 11)))\n\
    \              (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz\
    \ (modulo n 11))))]\n         [(= x 11)\n          (if (> n 79)\n            \
    \  (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz (modulo n 11)))\n\
    \              (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz\
    \ (modulo n 11))))]\n         [(= x 12)\n          (if (> n 79)\n            \
    \  (+ 1 (fizz_buzz (modulo n 13)))\n              (+ 1 (fizz_buzz (modulo n 11)))\n\
    \              (+ 1 (fizz_buzz (modulo n 13", "  (define (fizz_buzz_helper n count)\n\
    \    (if (zero? n)\n        count\n        (fizz_buzz_helper (quotient n 11) (incf\
    \ count))\n        (fizz_buzz_helper (quotient n 13) (incf count))\n        ))\n\
    \  (fizz_buzz_helper n 0))\n", "  (/ (sub1 (mod n 11))\n     (sub1 (mod n 13)))\n\
    \   7))\n", "  (cond [(= n 1) 0]\n        [(zero? (remainder (modulo n 11) 13))\
    \ 2]\n        [(zero? (remainder (modulo n 11) 11)) 3]\n        [else (+ 1 (fizz_buzz\
    \ (quotient n 11)))]))\n", "  (cond ((< n 11) (/ (- n 11) 11))\n        ((< n\
    \ 13) (/ n 13))\n        ((= (mod n 11) (mod n 13))\n         (cond ((< n 79)\
    \ (/ n 79))\n               ((= (mod n 79) (mod n 11))\n                (+ 1 (fizz_buzz\
    \ (- n 79))))\n               ((< n 79) (/ n 79))\n               ((= (mod n 79)\
    \ (mod n 13))\n                (+ 1 (fizz_buzz (- n 79))))))\n        (else 0)))\n",
  "  (cond [(zero? n) 0]\n        [(zero? (modulo n 11)) 0]\n        [(zero? (modulo\
    \ n 13)) 0]\n        [else (+ 1 (fizz_buzz (/ n 11)))]))\n</cell>\n<code language=ocaml-jupyter>\n\
    #require \"core_intrinsics/prim_intrinsics/mathlib.ml\"", "  (cond [(< n 10000)\n\
    \         (cond\n            [(= (modulo (+ n 1) 11) 0) 1]\n            [(= (modulo\
    \ (+ n 1) 13) 0) 2]\n            [(= (modulo (+ n 1) 17) 0) 3]\n            [else\
    \ 4])]\n        [else (+ 1 (fizz_buzz (+ n 1))) ]))\n", "  (if (= (modulo n 11)\
    \ 0)\n      (if (= (modulo n 13) 0)\n          (+ 1 (fizz_buzz (quotient n 11)))\n\
    \          (+ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz (quotient\
    \ n 11)))\n          (+ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz\
    \ (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient n 13)))\n          (+\
    \ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient n 13)))\n\
    \          (+ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient\
    \ n 13)))\n          (+ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz\
    \ (quotient n 13)))\n          (+ 1 (fizz_buzz (quotient n 11)))\n          (+\
    \ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz (quotient n 11)))\n\
    \          (+ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz (quotient\
    \ n 11)))\n          (+ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz\
    \ (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient n 13)))\n          (+\
    \ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient n 13)))\n\
    \          (+ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz (quotient\
    \ n 13)))\n          (+ 1 (fizz_buzz (quotient n 11)))\n          (+ 1 (fizz_buzz\
    \ (quotient n 13)))\n          (+ 1 (fizz_buzz (quotient n 11)))\n          (+\
    \ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz (quotient n 11)))\n\
    \          (+ 1 (fizz_buzz (quotient n 13)))\n          (+ 1 (fizz_buzz (", " \
    \ (cond\n    [(or (< n 0) (mod n 11)) 0]\n    [(or (< n 0) (mod n 13)) 2]\n  \
    \  [else (+ 0 (fizz_buzz (- n 1)))]))\n", "  (if (zero? n) 0\n      (if (= (modulo\
    \ n 13) 0)\n          (if (= (modulo n 11) 0)\n              (+ 1 (fizz_buzz (/\
    \ n 11)))\n              (+ 1 (fizz_buzz (/ n 13)))\n            (+ 1))\n    \
    \    (+ 1))))\n", "  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 1])\n\
    \  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 2])\n  (cond [(= n (mod\
    \ n 11)) 0]\n        [(= n (mod n 13)) 3])\n  (cond [(= n (mod n 11)) 0]\n   \
    \     [(= n (mod n 13)) 4])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod\
    \ n 13)) 5])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 6])\n  (cond\
    \ [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 7])\n  (cond [(= n (mod n 11))\
    \ 0]\n        [(= n (mod n 13)) 8])\n  (cond [(= n (mod n 11)) 0]\n        [(=\
    \ n (mod n 13)) 9])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 10])\n\
    \  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 11])\n  (cond [(= n (mod\
    \ n 11)) 0]\n        [(= n (mod n 13)) 12])\n  (cond [(= n (mod n 11)) 0]\n  \
    \      [(= n (mod n 13)) 13])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod\
    \ n 13)) 14])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 15])\n\
    \  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 16])\n  (cond [(= n (mod\
    \ n 11)) 0]\n        [(= n (mod n 13)) 17])\n  (cond [(= n (mod n 11)) 0]\n  \
    \      [(= n (mod n 13)) 18])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod\
    \ n 13)) 19])\n  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n 13)) 20])\n\
    \  (cond [(= n (mod n 11)) 0]\n        [(= n (mod n ", "  (let ((fizzs '()))\n\
    \    (for/list ([i n])\n      (when (or (= (modulo i 11) 7)\n                (=\
    \ (modulo i 13) 7))\n        (set! fizzs (cons i fizzs)))\n      (set! fizzs (cons\
    \ i fizzs)))))\n", "  (for/or ([x n] #:when (zero? x))\n    (let* ([y (quotient\
    \ x 11)\n            d (modulo x 11)]\n           [z (quotient y 13)\n       \
    \     u (modulo y 13)])\n      (cond [(and d z) #:when (= d 7)] [(and u z) #:when\
    \ (= u 7)]))))\n</code>\n<|/ a tags=racket,scheme,fizzbuzz,forth dscore=3 |>\n\
    <| c |>\nThank you so much. Your explanation is very helpful and informative!\
    \ I will try this immediately. :)\n<|/ c |>\n<| a |>\nThis implementation uses\
    \ a hash table that stores the number of times a specific digit appears in a list\
    \ of integers:\n<code>", "  (let loop ((i n))\n    (if (= i (mod i 11))\n    \
    \    (+ 1 (loop (div i 11)))\n        (+ 1 (loop (div i 13)))))\n  )\n)\n", " \
    \ (cond\n    ((< n 11) 0)\n    ((< n 13) 1)\n    ((and (= (modulo n 11) 7) (=\
    \ (modulo n 13) 7)) 2)\n    ((and (= (modulo n 11) 7) (= (modulo n 13) 8)) 3)\n\
    \    ((and (= (modulo n 11) 8) (= (modulo n 13) 7)) 4)\n    ((and (= (modulo n\
    \ 11) 8) (= (modulo n 13) 8)) 5)\n    ((and (= (modulo n 11) 9) (= (modulo n 13)\
    \ 7)) 6)\n    ((and (= (modulo n 11) 9) (= (modulo n 13) 8)) 7)\n    ((and (=\
    \ (modulo n 11) 9) (= (modulo n 13) 9)) 8)\n    ((and (= (modulo n 11) 10) (=\
    \ (modulo n 13) 9)) 9)\n    ((and (= (modulo n 11) 10) (= (modulo n 13) 10)) 10)\n\
    \    ((and (= (modulo n 11) 11) (= (modulo n 13) 10)) 11)\n    ((and (= (modulo\
    \ n 11) 11) (= (modulo n 13) 11)) 12)\n    ((and (= (modulo n 11) 11) (= (modulo\
    \ n 13) 12)) 13)\n    ((and (= (modulo n 11) 11) (= (modulo n 13) 13)) 14)\n \
    \   ((and (= (modulo n 11) 11) (= (modulo n 13) 14)) 15)\n    ((and (= (modulo\
    \ n 11) 12) (= (modulo n 13) 13)) 16)\n    ((and (= (modulo n 11) 12) (= (modulo\
    \ n 13) 14)) 17)\n    ((and (= (modulo n 11) 12) (= (modulo n 13) 15)) 18)\n \
    \   ((and (= (modulo n 11) 12) (= (modulo n 13) 16)) 19)\n    ((and (= (modulo\
    \ n 11) 12) (= (modulo n 13) 17)) 20)\n    ((and (= (modulo n 11) 12) (= (modulo\
    \ n 13) 18)) 21)\n    ((and (= (modulo n 11) 12) (= (modulo n 13) 19)) 22)\n \
    \   ((and (= (modulo n 11) 12) (= (modulo n 13) 20)) 23)\n    ((and (= (modulo\
    \ n 11) ", "  (cond\n    ((= n 1)\n     0)\n    ((= (mod n 11) 0) (+ 1 (fizz_buzz\
    \ (quotient n 11))))\n    ((= (mod n 13) 0) (+ 1 (fizz_buzz (quotient n 13))))\n\
    \    (else\n     (+ (count-digits (quotient n 10))\n        (count-digits (quotient\
    \ n 1))))))\n", "  (cond\n    [(< n 0) 0]\n    [(and (> n 11) (= (modulo n 11)\
    \ 7)) 1]\n    [(and (> n 13) (= (modulo n 13) 7)) 2]))\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>", "  (let loop ((n n)\n             (acc 0))\n\
    \    (cond\n      [(= n 1) acc]\n      [(= (modulo n 13) 0) (+ acc 1)]\n     \
    \ [(= (modulo n 11) 0) (+ acc 2)]\n      [(= (modulo n 11) 1) (+ acc 3)]\n   \
    \   [(= (modulo n 13) 1) (+ acc 4)]\n      [else (loop (sub1 n) (+ acc 5))]))))\n",
  "  (if (= n 0)\n      0\n      (+ 1 (count-digits n)))\n  )\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= (mod n 11) 0) 2]\n    [(= (mod n 13) 0) 3]\n\
    \    [else (+ (fizz_buzz (/ n 11)) (fizz_buzz (/ n 13)))]))\n", "  (define (helper\
    \ n acc)\n    (cond\n      [(= n 0) acc]\n      [(= (modulo n 3) 11)\n       (helper\
    \ (quotient n 3) (+ 1 acc))]\n      [(= (modulo n 3) 13)\n       (helper (quotient\
    \ n 3) (+ 1 acc))]\n      [else (helper (quotient n 3) acc)]\n      ))\n  (helper\
    \ n 0))", "  (local ((define (fizz_buzz_helper n acc)\n            (cond\n   \
    \           [(= n 7)\n               (+ acc 1)\n               (fizz_buzz_helper\
    \ (quotient n 11) acc)]\n              [(= n 13)\n               (+ acc 1)\n \
    \              (fizz_buzz_helper (quotient n 13) acc)]\n              [else\n\
    \               (fizz_buzz_helper (quotient n 10) acc)]))\n    (if (= n 0)\n \
    \       0\n        (fizz_buzz_helper (- n 1) 1))))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 1]\n    [(and (= (mod n 11) 0) (= (mod n 13) 0)) 2]\n    [else\
    \ 3]\n  )\n)\n", "  (let loop ((n n))\n    (cond ((= n 0)\n           0)\n   \
    \       ((= (modulo n 11) 0)\n           (+ 0 (loop n (modulo n 11))))\n     \
    \     ((= (modulo n 13) 0)\n           (+ 0 (loop (modulo n 13) (modulo n 11))))\n\
    \          ((= (modulo n 17) 0)\n           (+ 0 (loop (modulo n 17) (modulo n\
    \ 13))))\n          ((= (modulo n 19) 0)\n           (+ 0 (loop (modulo n 19)\
    \ (modulo n 17))))\n          ((= (modulo n 23) 0)\n           (+ 0 (loop (modulo\
    \ n 23) (modulo n 19))))\n          ((= (modulo n 27) 0)\n           (+ 0 (loop\
    \ (modulo n 27) (modulo n 23))))\n          ((= (modulo n 31) 0)\n           (+\
    \ 0 (loop (modulo n 31) (modulo n 27))))\n          ((= (modulo n 35) 0)\n   \
    \        (+ 0 (loop (modulo n 35) (modulo n 31))))\n          ((= (modulo n 39)\
    \ 0)\n           (+ 0 (loop (modulo n 39) (modulo n 35))))\n          ((= (modulo\
    \ n 43) 0)\n           (+ 0 (loop (modulo n 43) (modulo n 39))))\n          ((=\
    \ (modulo n 47) 0)\n           (+ 0 (loop (modulo n 47) (modulo n 43))))\n   \
    \       ((= (modulo n 51) 0)\n           (+ 0 (loop (modulo n 51) (modulo n 47))))\n\
    \          ((= (modulo n 55) 0)\n           (+ 0 (loop (modulo n 55) (modulo n\
    \ 51))))\n          ((= (modulo n 59) 0)\n           (+ 0 (loop (modulo n 59)\
    \ (modulo n 55))))\n          ((= (modulo n 63) 0)\n           (+ 0 (loop (modulo\
    \ n 63) (modulo n 59))))\n          ((= (modulo n 67) 0)\n           (+ 0 (loop\
    \ (modulo n 67) (modulo n 63))))\n          ((= (modulo n 71) 0)\n           (+\
    \ 0 (loop (modulo n 71) (modulo n 67))))\n          ((= (modulo n 75) 0)\n   \
    \        (+ 0 (loop (modulo n 75) (modulo n 71))))\n          ((= (modulo n ",
  "  (let ([i n])\n    (cond\n      [(= i 7) (+ 1 (fizz_buzz (- i 1)))]\n      [else\
    \ (+ (fizz_buzz (mod i 11)) (fizz_buzz (mod i 13)))])))\n", "  (define (fizz-buzz-helper\
    \ n count)\n    (if (= (modulo n 11) (modulo n 13))\n        (if (= count 0)\n\
    \            (+ 1 (fizz-buzz-helper (/ n 11) count))\n            (fizz-buzz-helper\
    \ (/ n 13) count))\n        count))\n  (fizz-buzz-helper n 0))\n", "  (if (zero?\
    \ n) 0\n      (let loop ((count 0) (n n) (k 0))\n        (cond ((= 0 (remainder\
    \ n 11)) (add count 1))\n              ((= 0 (remainder n 13)) (add count 2))\n\
    \              ((= k (floor (/ n 11))) (loop (add count 1) (quotient n 11) (sub1\
    \ k)))\n              (else (loop (add count 1) (quotient n 11) (add1 k)))))))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= (modulo (quotient n 11) 11)\
    \ 0) 2]\n        [(= (modulo (quotient n 13) 13) 0) 3]\n        [else (+ (fizz_buzz\
    \ (quotient n 11)) (fizz_buzz (quotient n 13))) (fizz_buzz (quotient n 1))])))\n",
  "  (cond\n    [(<= n 1) 0]\n    [(= (modulo n 11) 0) 2]\n    [(= (modulo n 13) 0)\
    \ 3]\n    [else (+ 1 (fizz_buzz (quotient n 11)))]))\n", "  (cond\n    ((= n 1)\
    \ '())\n    ((= (modulo n 11) 0) '(7))\n    ((= (modulo n 11) 1) (fizz_buzz (/\
    \ n 11))\n     (cons (fizz_buzz (/ n 13)) (cons 7 '())))))\n</code>\n<|/ a tags=fizzbuzz,racket\
    \ |>\n<| a dscore=0 |>\n<code>", "  (if (or (= n 0) (zero? n))\n      0\n    \
    \  (let ((m (floor n)))\n        (cond\n         ((or (= m 11) (= m 13))\n   \
    \       (+ 1 (fizz_buzz (quotient m 11))))\n         ((= m 7)\n          (+ 1\
    \ (fizz_buzz (quotient m 7))))\n         (else\n          (fizz_buzz (quotient\
    \ m 13)))))))\n", "  (cond [(= n 1) 0]\n        [(= (mod n 11) 0) 2]\n       \
    \ [(= (mod n 13) 0) 3]\n        [else 4]))\n", "  (loop for i from 0 to (/ n 10)\
    \ do\n         (when (= (modulo n 10) 7)\n           (return i))))\n", "  (cond\
    \ [(< n 100) #t]\n        [(= (mod n 11) #t) #f]\n        [(= (mod n 13) #t) #t]\n\
    \        [else (+ 1 (fizz_buzz (/ n 11)))]))\n", "  (let* ((a (number->string\
    \ n))\n         (digits (remove-if (lambda (x) (char=? (string-ref a x) '7)) a))\n\
    \         (count (length digits))\n         (digits (remove-if (lambda (x) (char=?\
    \ (string-ref a x) '7)) digits))\n         (divisibles (remove-if (lambda (x)\
    \ (char=? (string-ref a x) '7)) digits))\n         (fizzes (remove-if (lambda\
    \ (x) (char=? (string-ref a x) '7)) divisibles))\n         (buzzes (remove-if\
    \ (lambda (x) (char=? (string-ref a x) '7)) divisibles)))\n    (if (= n 0)\n \
    \       0\n        (+ (if (= (- n 1) 0)\n              0\n              (+ (*\
    \ n (mod 2 11))\n                   (if (= (- n 1) 0)\n                      \
    \ 0\n                       (* n (mod 2 13)))))))))\n</code>\nNote that a shorter\
    \ version of the function is available in the Racket source:\n<code>", "  (let\
    \ ((fizz_count 0))\n    (for ([x numbers])\n      (when (or (= n x)\n        \
    \        (mod x 11 = 0)\n                (mod x 13 = 0))\n        (set! fizz_count\
    \ (+ fizz_count 1)))))\n  fizz_count)\n", "  (cond\n    ((= n 0) 0)\n    ((= n\
    \ 1) 0)\n    ((= (modulo n 11) 13) (+ 1 (fizz_buzz (/ n 11))))\n    ((= (modulo\
    \ n 13) 11) (+ 1 (fizz_buzz (/ n 13))))\n    (else (+ 1 (fizz_buzz (/ n 11)))\
    \ (+ 1 (fizz_buzz (/ n 13)))))) ; #lang racket\n", "  (let ((x (quotient n 11))\n\
    \        (y (modulo n 11))\n        (z (quotient n 13))\n        (k (modulo n\
    \ 13)))\n    (if (or (= x 0) (= y 0) (= z 0))\n        0\n        (if (= x y)\n\
    \            (if (= x z)\n                (+ 1 k)\n                (+ k (* z (fizz_buzz\
    \ (sub1 z))))))\n        (if (= x z)\n            (+ 1 k)\n            (+ k (*\
    \ y (fizz_buzz (sub1 y))))))))\n</code>\n<|/ a tags=scheme,racket,fizzbuzz |>\n\
    <| a dscore=0 |>\n<code>", "  (cond ((= n 0) 0)\n        ((= (remainder n 11)\
    \ 0)\n         (+ 0 (fizz_buzz (quotient n 11)))\n         (+ (fizz_buzz (quotient\
    \ n 13)) 1))\n        ((= (remainder n 13) 0)\n         (+ 0 (fizz_buzz (quotient\
    \ n 11)))\n         (+ 0 (fizz_buzz (quotient n 13))))\n        ((= (remainder\
    \ n 11) 0)\n         (+ (fizz_buzz (quotient n 13)) 1)\n         (+ (fizz_buzz\
    \ (quotient n 11)) 1)))\n  )\n", "  (define (fizzbuzz n)\n    (cond\n      [(zero?\
    \ n)\n       (cond\n         [(= (modulo n 11) 0)\n          (= (modulo n 13)\
    \ 0)]\n         [else\n          (cond\n            [(= (modulo n 11) 0)\n   \
    \          (= (modulo n 13) 1)\n             [else (+ 1 0)]]))]\n      [(= (modulo\
    \ n 11) 0)\n       (cond\n         [(= (modulo n 13) 0)]\n         [else\n   \
    \       (cond\n            [(= (modulo n 13) 0)\n             (= (modulo n 11)\
    \ 1)\n             [else (+ 1 0)]]))]\n      [else\n       (cond\n         [(=\
    \ (modulo n 13) 0)\n          (= (modulo n 11) 1)\n          [else (+ 1 0)]]))]))\n\
    \  (fizzbuzz n)) ;; <-- comment this out to see that it's non-deterministic\n\
    </cell>\n<code language=racket-language>", "  (cond [(< n 13) (cond (<= 0 (remainder\
    \ n 11)) n (+ 1 n))]\n        [else (cond (<= 0 (remainder n 11)) (fizz_buzz (+\
    \ n 1))\n                  [else (fizz_buzz (+ n 1))])]))\n", "  (cond\n    ((=\
    \ n 0)\n     0)\n    ((= n 1)\n     1)\n    ((= (mod n 11) 0)\n     (fizz_buzz\
    \ (sub1 n)))\n    ((= (mod n 13) 0)\n     (+ 1 fizz_buzz (sub1 n)))\n    (else\n\
    \     (fizz_buzz (sub1 n)))))\n", "  (cond ((= n 0)\n         0)\n        ((=\
    \ n 1)\n         (if (= (remainder n 11) 0)\n             (+ 1 (fizz_buzz (/ n\
    \ 11)))\n             0))\n        ((= n 2)\n         (if (= (remainder n 13)\
    \ 0)\n             (+ 1 (fizz_buzz (/ n 13)))\n             0))\n        ((= n\
    \ 3)\n         (if (= (remainder n 17) 0)\n             (+ 1 (fizz_buzz (/ n 17)))\n\
    \             0))\n        ((= n 4)\n         (if (= (remainder n 19) 0)\n   \
    \          (+ 1 (fizz_buzz (/ n 19)))\n             0))\n        ((= n 5)\n  \
    \       (if (= (remainder n 21) 0)\n             (+ 1 (fizz_buzz (/ n 21)))\n\
    \             0))\n        ((= n 6)\n         (if (= (remainder n 23) 0)\n   \
    \          (+ 1 (fizz_buzz (/ n 23)))\n             0))\n        ((= n 7)\n  \
    \       (if (= (remainder n 25) 0)\n             (+ 1 (fizz_buzz (/ n 25)))\n\
    \             0))\n        ((= n 8)\n         (if (= (remainder n 27) 0)\n   \
    \          (+ 1 (fizz_buzz (/ n 27)))\n             0))\n        ((= n 9)\n  \
    \       (if (= (remainder n 29) 0)\n             (+ 1 (fizz_buzz (/ n 29)))\n\
    \             0))\n        (else (+ 1 (fizz_buzz (/ n 30)))\n             0)))\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nYeah, this is pretty cool. I didn't want\
    \ to give it much more thought than that. Your solution does solve my problem\
    \ and makes it look pretty simple. Thank you.\n<|/ c |>\n<| c |>\nOk, I did a\
    \ little more research, and this is actually a more efficient way of doing it.\
    \ The problem with this is that it uses up extra memory in the process, which\
    \ isn't always desirable. I'll post my own answer to this question.\n<|/ c |>\n\
    <| a |>\n<code>", "  (cond\n    [(<= n 0) 0]\n    [(= (mod n 11) 0) 1]\n    [(=\
    \ (mod n 13) 0) 2]\n    [else (+ 3 (fizz_buzz (/ n 11)))]))\n", "  (cond [(= n\
    \ 0)\n         (write \"0\")]\n        [(= n 1)\n         (write \"1\")]\n   \
    \     [(= (mod-n n 11) 0)\n         (fizz_buzz (div-n n 11))]\n        [(= (mod-n\
    \ n 13) 0)\n         (fizz_buzz (div-n n 13))]\n        [else\n         (fizz_buzz\
    \ (div-n n 10))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= (modulo\
    \ n 11) 0) 2]\n    [(= (modulo n 13) 0) 3]\n    [else (+ (fizz_buzz (quotient\
    \ n 11)) (fizz_buzz (quotient n 13)))]))\n", "  (cond\n    ((= n 0)\n     0)\n\
    \    ((= n 7)\n     (length (filter (lambda (x) (= x 7)) (take-while remainder\
    \ (modulo-11 n) modulo-13 n))))\n    (else\n     (+ (fizz_buzz (quotient n 11))\
    \ (fizz_buzz (quotient n 13))))))\n", "  (cond\n    ((= n 0)\n     0)\n    ((and\
    \ (integer? n) (= (remainder n 11) 0))\n     (+ 0 ((quotient n 11)))\n     (+\
    \ 2 ((quotient n 13))))\n    ((and (integer? n) (= (remainder n 11) 0))\n    \
    \ (+ 0 ((quotient n 11)))\n     (+ 3 ((quotient n 13))))\n    ((and (integer?\
    \ n) (= (remainder n 13) 0))\n     (+ 0 ((quotient n 13)))\n     (+ 4 ((quotient\
    \ n 11))))\n    (else\n     (fizz_buzz (- n 1)))))\n</code>\n<|/ a dscore=3 tags=racket,scheme,fizzbuzz\
    \ |>\n<| a |>\n<code>", "  (define (aux n i res)\n    (cond ((= n i) (set! res\
    \ (+ res 1)))\n          ((= (remainder n 11) 0)\n           (aux (remainder n\
    \ 13) i res))\n          (else (aux (+ n i) 0 (+ res 1)))))\n  (aux n 0 (list\
    \ 0)))\n</cell>\n<code language=racket-language>", "  (if (= n 0)\n      0\n \
    \     (+ 1\n         (cond\n          [(= (mod n 11) 0)\n           (cond\n  \
    \          [(= (mod n 13) 0)\n             (+ 1 (fizz_buzz (/ n 13)))]\n     \
    \       [else\n             (+ 1 (fizz_buzz (/ n 11)))])]\n          [else\n \
    \          (cond\n            [(= (mod n 13) 0)\n             (+ 1 (fizz_buzz\
    \ (/ n 11)))]\n            [else\n             (+ 1 (fizz_buzz (/ n 13)))])])\n\
    \         )\n      )\n  )\n", "  (cond\n    ((< n 100) 0)\n    ((< n 400) 2)\n\
    \    ((< n 1000) 3)\n    ((< n 4000) 3)\n    ((< n 10000) 4)\n    ((< n 40000)\
    \ 5)\n    ((< n 100000) 6)\n    ((< n 400000) 7)\n    ((< n 1000000) 7)\n    ((<\
    \ n 4000000) 8)\n    ((< n 10000000) 9)\n    ((< n 40000000) 10)\n    ((< n 100000000)\
    \ 10)\n    ((< n 400000000) 11)\n    ((< n 1000000000) 13)\n    ((< n 4000000000)\
    \ 14)\n    ((< n 10000000000) 15)\n    ((< n 40000000000) 16)\n    ((< n 100000000000)\
    \ 17)\n    ((< n 400000000000) 18)\n    ((< n 1000000000000) 19)\n    ((< n 4000000000000)\
    \ 20)\n    ((< n 10000000000000) 21)\n    ((< n 40000000000000) 22)\n    ((< n\
    \ 100000000000000) 23)\n    ((< n 400000000000000) 24)\n    ((< n 1000000000000000)\
    \ 25)\n    ((< n 4000000000000000) 26)\n    ((< n 1000000000000000000) 27)\n \
    \   ((< n 40000000000000000) 28)\n    ((< n 10000000000000000000) 29)\n    ((<\
    \ n 4000000000000000000) 30)\n    ((< n 100000000000000000000) 31)\n    ((< n\
    \ 40000000000000000000) 32)\n    ((< n 1000000000000000000000) 33)\n    ((< n\
    \ 400000000000000000000000000000000) 34)\n    ((< n 10000000000000000000000) 35)\n\
    \    ((< n 4000000000000000000000000000000000) 36)\n    ((< n 100000000000000000000000)\
    \ 37)\n    ((< n 40000000000000000000000000000000000) 38)\n    ((< n 1000000000000000000000000)\
    \ 39)\n    ((< n 400000000000000000000000000000000000) 40)\n    ((< n 100000000000000000000000000)\
    \ 41)\n    ((< n 4000000000000000000000000000000000000) 42)\n    ((< n 1000000000000000000000000000)\
    \ 43)))\n", "  (let loop ((n n) (fs '(7 7 7 7 7 7 7 7)) (x 0) (y 0))\n    (cond\
    \ ((= n 0)\n           (cond ((= x 7)\n                   (cons y))\n        \
    \         (else (loop (- n 1) fs (+ x 1) y))))\n          ((= x 7) y)\n      \
    \    (else (loop (- n 1) fs (+ x 1) (+ y 1)))))))\n", "  (let loop ((n n))\n \
    \   (cond ((= n 0) 0)\n          ((or (= (modulo n 11) 0)\n               (= (modulo\
    \ n 13) 0)) (+ 1 (loop (/ n 11))))\n          ((< n 100) 0)\n          ((< n 1000)\
    \ (+ 1 (loop (/ n 13))))\n          ((< n 10000) (+ 1 (loop (/ n 11))))\n    \
    \      ((< n 100000) (+ 1 (loop (/ n 13))))\n          ((< n 1000000) (+ 1 (loop\
    \ (/ n 11))))\n          ((< n 10000000) (+ 1 (loop (/ n 13))))\n          ((<\
    \ n 100000000) (+ 1 (loop (/ n 11))))\n          ((< n 1000000000) (+ 1 (loop\
    \ (/ n 13))))\n          ((< n 10000000000) (+ 1 (loop (/ n 11))))\n         \
    \ ((< n 100000000000) (+ 1 (loop (/ n 13))))\n          ((< n 1000000000000) (+\
    \ 1 (loop (/ n 11))))\n          ((< n 10000000000000) (+ 1 (loop (/ n 13))))\n\
    \          ((< n 100000000000000) (+ 1 (loop (/ n 11))))\n          ((< n 1000000000000000)\
    \ (+ 1 (loop (/ n 13))))\n          ((< n 10000000000000000) (+ 1 (loop (/ n 11))))\n\
    \          ((< n 100000000000000000) (+ 1 (loop (/ n 13))))\n          ((< n 1000000000000000000)\
    \ (+ 1 (loop (/ n 11))))\n          ((< n 10000000000000000000) (+ 1 (loop (/\
    \ n 13))))\n          (else (+ 1 (loop (/ n 11)))))\n  )\n)", "  (cond\n    [(=\
    \ n 1) 0]\n    [(= (mod n 11) 0) 2]\n    [(= (mod n 13) 0) 3]\n    [else (+ 1\
    \ (fizz_buzz (/ n 11))) (+ 1 (fizz_buzz (/ n 13)))]))\n", "  (cond\n    [(> n\
    \ 0) (number? (mod n 11)) (number? (mod n 13))]\n    [else 0]))\n", "  (cond [(<\
    \ n 13) (cond [(< n 11) (+ 1 (mod n 11))])]\n        [(< n 11) (+ 1 (mod n 11))]\n\
    \        [else (+ 1 (mod n 13)))]))\n", "  (cond ((= n 0)\n         0)\n     \
    \   ((= (mod n 11) 0)\n         (cond ((= (mod n 13) 0)\n                (+ n\
    \ 1))\n                ((= (mod n 13) 1)\n                 (+ n 2))\n        \
    \        (else (+ n 3)))\n          ((= (mod n 13) 1)\n           (+ n 3))\n \
    \         (else (+ n 5))))\n</code>\n<|/ a |>\n<| c |>\nThis works perfectly,\
    \ however I do get this error when I try to use it with a different number:\n\n\
    \    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= (mod n 11) 0) 2]\n    [(= (mod\
    \ n 13) 0) 3]\n    [else (+ (fizz_buzz (quotient n 11)) (fizz_buzz (quotient n\
    \ 13)))]))\n", "  (cond\n    [(= n 1) '1]\n    [(= n 2) '2]\n    [else (cond\n\
    \             [(= (remainder n 3) 0) (+ (count (modulo n 11)) '1)]\n         \
    \    [(= (remainder n 3) 1) (+ (count (modulo n 13)) '2)]\n             [else\
    \ '3]))]))\n", "  (if (= n 0)\n      0\n      (if (mod n 11)\n          (if (=\
    \ (mod n 13) 0)\n              2\n              3))))\n", "  (let loop ((n n)\
    \ (i 0))\n    (cond\n      [(zero? n) (printf \"~A\\n\" i)] \n      [(or (= (modulo\
    \ n 11) (modulo n 13)) (= (modulo n 7) (modulo n 11)) (= (modulo n 7) (modulo\
    \ n 13)))\n       (loop (quotient n 11) (add1 i))]\n      [else (loop (quotient\
    \ n 13) (add1 i))]))))\n", "  (cond [(= n 0) '()]\n        [(= (mod-add n 11 0)\
    \ 0) 0]\n        [(= (mod-add n 13 0) 0) 1]\n        [(= (mod-add n 11 0) 0) (+\
    \ (fizz_buzz (- n 11))\n                                       (fizz_buzz (- n\
    \ 13)))]\n        [(= (mod-add n 13 0) 1) (+ (fizz_buzz (- n 13))\n          \
    \                             (fizz_buzz (- n 11)))]\n        [else (+ 1 (fizz_buzz\
    \ (- n 1)))]))\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is another solution\
    \ that is based on the ideas given by Nathan and Kyle.\n<code>", "  (cond ((=\
    \ n 0) 0)\n        ((= n 1) 0)\n        ((= (mod n 11) 0) 0)\n        ((= (mod\
    \ n 13) 0) 0)\n        ((= (mod n 17) 0) 0)\n        ((= (mod n 19) 0) 0)\n  \
    \      ((= (mod n 21) 0) 0)\n        ((= (mod n 23) 0) 0)\n        ((= (mod n\
    \ 25) 0) 0)\n        ((= (mod n 27) 0) 1)\n        ((= (mod n 29) 0) 2)\n    \
    \    ((= (mod n 31) 0) 3)\n        ((= (mod n 33) 0) 4)\n        ((= (mod n 35)\
    \ 0) 5)\n        ((= (mod n 37) 0) 6)\n        ((= (mod n 39) 0) 7)\n        (else\
    \ (fizz_buzz (sub1 n))))))\n", "  (cond\n    [(< n 11) (if (even? (modulo n 11))\
    \ (+ 1 (fizz_buzz (quotient n 11))) (fizz_buzz (quotient n 13)))]\n    [(< n 13)\
    \ (if (even? (modulo n 13)) (+ 1 (fizz_buzz (quotient n 13))) (fizz_buzz (quotient\
    \ n 11)))]\n    [else n]))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n  \
    \  ((= (mod n 11) 0) 2)\n    ((= (mod n 13) 0) 3)\n    (else (+ (fizz_buzz (quotient\
    \ n 11)) (fizz_buzz (quotient n 13)))) ))\n", "  (let loop ((n n)\n          \
    \   (digits '(7 (11) (13) )))\n    (cond\n      [(= n 0) 0]\n      [(= (mod n\
    \ 11) 0) 1]\n      [(= (mod n 13) 0) 2]\n      [(= (modulo n 7) 7) 3]\n      [(>\
    \ (modulo n 7) 0) 4]\n      [else (loop (- n 1) (conj digits 7))]))))\n", "  (cond\n\
    \    [(zero? n) 0]\n    [else (+ (mod n 11) (mod n 13))]))\n", "  (let ([b (divisible?\
    \ n 11)]\n        [t (divisible? n 13)]\n        [c (= (/ n 11) (/ n 13))]\n \
    \       [p (= (/ n 11) 0)]\n        [q (= (/ n 13) 0)])\n    (if (or b t c)\n\
    \        (+ a n)\n        (+ 1 (fizz_buzz (- n 1)))))\n  (if (or b t c)\n    \
    \  0\n      (+ 1 (fizz_buzz (- n 1)))))\n</code>\n<|/ a |>\n<| a dscore=1 tags=racket,scheme\
    \ |>\nHere's a recursive solution using Racket/Scheme (note that the solution\
    \ below is a bit hacky and will probably break on some weird corner cases). \n\
    <code>", "  (let ((count 0))\n    (loop ((x n) (y (n + 11))) (if (zero? (remainder\
    \ x y)) (set! count (inc! count)) (return count))))))\n", "  (if (= n 1)\n   \
    \   0\n      (let ((result 0))\n        (let ((dig (modulo (remainder n 11) 13)))\n\
    \          (if (= dig 7)\n              (set! result (+ result 1))\n         \
    \     (set! result (+ result 0))\n              (set! result (+ result 0)))))))\n",
  "  (define (count-7 n)\n    (cond\n      [(= n 7)\n       1]\n      [(= (quotient\
    \ n 10) 7)\n       1]\n      [else\n       (+ count-7 (quotient n 10))]))\n  (if\
    \ (< n 100)\n      (count-7 n)\n      0))\n</cell>\n<text>\nNow let's take a closer\
    \ look at recursive programming in Scheme. We already used fizz_buzz to implement\
    \ fizzbuzz which does essentially the same thing, but we can do it much more simply.\n\
    \n\n</text>\n<cell>", "  (cond [(< n 100) #t (- 0 \n                      (+ (*\
    \ 2 (remainder (modulo n 11) 10)) \n                          (modulo n 13) 10)))]\n\
    \        [(< n 100) #t 0]\n        [(< n 101) #t (+ 1 (fizz_buzz (- n 10)))]))\n",
  "  (/ (count (quotient-remainder 7 n)) 11))\n</code>\n<|/ a |>\n<| a tags=fizzbuzz,scheme,racket,lisp\
    \ dscore=1 |>\nThis version works.\n<code>", "  (cond ((= n 0) 0)\n        ((zero?\
    \ (remainder n 11)) 1)\n        ((zero? (remainder n 13)) 2)\n        (else (fizz_buzz\
    \ (quotient n 11)))))\n", "  (cond\n    [(<= n 13) (count-digit-7 n)]\n    [else\
    \ 0]))\n", "  (cond\n    [(> n 0) 0]\n    [(= n 1) 1]\n    [(= (mod n 11) 0) (+\
    \ 1 (fizz_buzz (quotient n 11)))]\n    [(= (mod n 13) 0) (+ 1 (fizz_buzz (quotient\
    \ n 13)))]\n    [else (+ 1 (fizz_buzz (quotient n 11))) (+ 1 (fizz_buzz (quotient\
    \ n 13)))]))\n", "  (cond\n    [(= n 0)\n     0]\n    [(= (modulo n 11) 0)\n \
    \    (+ 1 0)]\n    [(= (modulo n 13) 0)\n     (+ 1 0)]\n    [else\n     (+ 1 (fizz_buzz\
    \ (quotient n 11)))]))\n", "  (let ((cnt 0))\n    (do\n      ((i n) (quotient\
    \ i 11))\n      (if (= (mod i 11) 7)\n          (set! cnt (+ cnt 1))\n       \
    \   (set! cnt 0))\n      ((i n) (quotient i 13))\n      (if (= (mod i 13) 7)\n\
    \          (set! cnt (+ cnt 1))\n          (set! cnt 0))\n      (cnt 0))\n   \
    \ (display cnt)\n    (newline)\n    cnt))\n", "  (cond\n    ((= n 0) 0)\n    ((=\
    \ n 1) 0)\n    ((= (modulo n 11) 0) 2)\n    ((= (modulo n 13) 0) 3)\n    ((= (modulo\
    \ n 14) 0) 4)\n    ((= (modulo n 17) 0) 5)\n    ((= (modulo n 19) 0) 6)\n    ((=\
    \ (modulo n 17) 0) 7)\n    ((= (modulo n 19) 0) 8)\n    (else (fizz_buzz (sub1\
    \ n)))))\n", "  (cond\n    [(= n 0) 0]\n    [(even? n) (even? n)\n      (when\
    \ (= (mod n 11) 7)\n        (+ 1 (fizz_buzz (/ n 11)))\n        (+ 1 (fizz_buzz\
    \ (/ n 13)))\n        (+ 1 (fizz_buzz (/ n 17)))\n        (+ 1 (fizz_buzz (/ n\
    \ 19)))\n        (+ 1 (fizz_buzz (/ n 23)))\n        (+ 1 (fizz_buzz (/ n 29)))\n\
    \        (+ 1 (fizz_buzz (/ n 31)))]\n    [else (odd? n) (odd? n)\n      (when\
    \ (= (mod n 11) 7)\n        (+ 1 (fizz_buzz (/ n 11)))\n        (+ 1 (fizz_buzz\
    \ (/ n 13)))\n        (+ 1 (fizz_buzz (/ n 17)))\n        (+ 1 (fizz_buzz (/ n\
    \ 19)))\n        (+ 1 (fizz_buzz (/ n 23)))\n        (+ 1 (fizz_buzz (/ n 29)))]\n\
    \    [else (= n 0) 0]))\n</code>\n<|/ a tags=fizzbuzz,racket |>\n<| a tags=fizzbuzz,racket\
    \ |>\nIt's my first answer and i found a better way to do this without using loops.\
    \ Hope it helps others who are looking.\n<code>", "  (let loop ((n n) (count 0))\n\
    \    (cond ((= n 0) (cons count (list n)))\n          ((= (mod n 11) 0) (loop\
    \ (quotient n 11) (+ count 1)))\n          ((= (mod n 13) 0) (loop (quotient n\
    \ 13) (+ count 1)))\n          (else (loop (quotient n 10) (+ count 1)))))))\n",
  "  (cond\n    [(< n 13) (mod n 11)]\n    [(= n 7) (+ 1 0)]\n    [else 0]))\n", " \
    \ (let loop ((n n) (i 1) (acc 0))\n    (cond\n      [(< n 0)\n       acc]\n  \
    \    [(= (modulo n 11) (modulo n 13))\n       (loop (- n 1) (+ i 1) (+ acc 1))]\n\
    \      [(= (modulo n 11) (modulo n 13) (modulo n 17))\n       (loop (- n 1) (+\
    \ i 1) (+ acc 1))]\n      [(= (modulo n 11) (modulo n 13) (modulo n 17) (modulo\
    \ n 19))\n       (loop (- n 1) (+ i 1) (+ acc 1))]\n      [else\n       (loop\
    \ (- n 1) i acc)])))\n", "  (let ((i (remainder n 11))\n        (j (remainder\
    \ n 13)))\n    (cond [(= i 13) (+ 1 (fizz_buzz (/ n 13)))]\n          [(= i 11)\
    \ (+ 1 (fizz_buzz (/ n 11)))]\n          [(= j 13) (+ 1 (fizz_buzz (/ n 11)))]\n\
    \          [(= j 11) (+ 1 (fizz_buzz (/ n 13)))]\n          [else 0])))\n", " \
    \ (cond\n    [(or (= n 10) n)\n     (cond\n       [(= (mod n 11) 0)\n        (cond\n\
    \         [(= (mod n 13) 0)\n          (list n)]\n         [(= (mod n 13) 1)\n\
    \          (list n)]\n         [else\n          (fizz_buzz (/ n 13))]\n      \
    \  )]\n       [(= (mod n 11) 1)\n        (cond\n         [(= (mod n 13) 0)\n \
    \         (list n)]\n         [(= (mod n 13) 1)\n          (list n)]\n       \
    \  [else\n          (fizz_buzz (/ n 11))]\n        )]\n       [else\n        (fizz_buzz\
    \ (/ n 11))]\n      )]\n    [else\n     (cond\n       [(= (mod n 11) 0)\n    \
    \    (cond\n         [(= (mod n 13) 0)\n          (list n)]\n         [(= (mod\
    \ n 13) 1)\n          (list n)]\n         [else\n          (fizz_buzz (/ n 13))]\n\
    \        )]\n       [(= (mod n 11) 1)\n        (cond\n         [(= (mod n 13)\
    \ 0)\n          (list n)]\n         [(= (mod n 13) 1)\n          (list n)]\n \
    \        [else\n          (fizz_buzz (/ n 11))]\n        )]\n       [else\n  \
    \      (fizz_buzz (/ n 11))]\n      )]\n   ))\n)\n</code>\n<|/ a dscore=2 tags=scheme,racket\
    \ |>\n<| c |>\nWhy are you using recursion for this when the problem doesn't require\
    \ it?\n<|/ c |>\n<| c |>\nI agree with. Using recursion for this problem will\
    \ complicate things unnecessarily and make the code less readable and maintainable.\n\
    <|/ c |>\n<| c |>\nUsing recursion for this problem will also make it not work\
    \ at all. This answer is not useful and should have been a comment instead.\n\
    <|/ c |>\n<| c |>\nThis is how I solve the fizzbuzz problem in Scheme, it's an\
    \ interesting problem; I don't think it's overly complicated and easy to understand\
    \ once you grok it once you get your head around it :)\n<|/ c |>\n<| c |>\nWell,\
    \ actually, the question asked about recursion, and this is how I solved the FizzBuzz\
    \ question.  I don't understand why ", "  (define (fizz-buzz-helper n)\n    (if\
    \ (= n 7)\n        0\n        (+ 1 (fizz-buzz-helper (quotient n 10))))\n    (if\
    \ (= (modulo n 11) 0)\n        0\n        (+ 1 (fizz-buzz-helper (quotient n 11))))\n\
    \    (if (= (modulo n 13) 0)\n        0\n        (+ 1 (fizz-buzz-helper (quotient\
    \ n 13))))\n  )\n  (fizz-buzz-helper n)\n)\n", "  (let loop ((n n))\n    (cond\n\
    \      [(< n 13) (+ (mod n 11) (mod n 13))]\n      [(< n 11) (+ (mod n 11) (mod\
    \ n 13))]\n      [else (+ 1 (loop (mod n 11)))])))\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\n+1 for the most elegant solution I think. Just a couple of comments about\
    \ the solution: I would use `#lang racket` here instead of `#lang scheme` to be\
    \ able to use `(< n 13) ...` without having to define a `let` form and so forth.\
    \ I would also use `#lang racket/base` (or perhaps even the standard library),\
    \ but that's just personal preference.\n<|/ c |>\n<| c |>\nOops -- you're right.\
    \ The code is in racket (I just didn't try it in a browser). Fixed now.\n<|/ c\
    \ |>\n<| c |>\nYou might want to replace `(< n 13) (+ (mod n 11) (mod n 13))`\
    \ with `(< n (quotient n 13))`\n<|/ c |>\n<| c |>\nGood idea, but the `quotient`\
    \ function is only available in racket/base. I'm sure that could be replaced with\
    \ `(ceil (/ n 13))` but that would also change how things are evaluated.\n<|/\
    \ c |>\n<| c |>\nYes, I was just about to propose it after seeing your answer.\
    \ :)\n<|/ c |>\n<| a |>\nHow about this?\n<code>", "  (if (= n 0) 0\n      (if\
    \ (and (= (modulo n 11) 0) (= (modulo n 13) 0))\n          0\n          (+ 1 (fizz_buzz\
    \ (- n 1))))))\n</code>\nI believe this solution is O(n). To make it run fast,\
    \ I'd probably change it to:\n<code>", "  (count (lambda (d)\n            (or\
    \ (= d 7)\n                (= (quotient d 11) 0))\n            (or (= d 13)\n\
    \                (= (quotient d 13) 0))\n            (= (quotient d 11) 0)\n \
    \           (= (quotient d 13) 0))) n\n  (count (lambda (d)\n            (or (=\
    \ d 7)\n                (= (quotient d 11) 0))\n            (or (= d 13)\n   \
    \             (= (quotient d 13) 0))\n            (= (quotient d 11) 0))) n\n\
    \  (count (lambda (d)\n            (or (= d 7)\n                (= (quotient d\
    \ 11) 0))\n            (or (= d 13)\n                (= (quotient d 13) 0))\n\
    \            (= (quotient d 11) 0))) n\n  (count (lambda (d)\n            (or\
    \ (= d 7)\n                (= (quotient d 11) 0))\n            (or (= d 13)\n\
    \                (= (quotient d 13) 0))\n            (= (quotient d 11) 0))) n\n\
    \  (count (lambda (d)\n            (or (= d 7)\n                (= (quotient d\
    \ 11) 0))\n            (or (= d 13)\n                (= (quotient d 13) 0))\n\
    \            (= (quotient d 11) 0))) n\n  (count (lambda (d)\n            (or\
    \ (= d 7)\n                (= (quotient d 11) 0))\n            (or (= d 13)\n\
    \                (= (quotient d 13) 0))\n            (= (quotient d 11) 0))) n\n\
    \  (count (lambda (d)\n            (or (= d 7)\n                (= (quotient d\
    \ 11) 0))\n            (or (= d 13)\n                (= (quotient d 13) 0))\n\
    \            (= (quotient d 11) 0))) n\n  (count (lambda (d)\n            (or\
    \ (= d 7)\n                (= (quotient d 11) 0))\n            (or (= d 13)\n\
    \                (= (quotient d 13) 0))\n            (= (quotient d 11) 0))) n\n\
    \  (count (lambda (d)\n            (or (= d 7)\n                (= (quotient d\
    \ 11) 0))\n            (or (= d 13)\n                (= (quotient d 13) 0))\n\
    \            (= (quotient d 11) 0))) n\n  (count (lambda (d)\n            (or\
    \ (= d 7)\n                (= (quotient d 11) 0))\n            (or (= d 13)\n\
    \                (= (quotient d 13) 0))\n            (= (quoti", "  (cond\n  \
    \  [(= n 1) 0]\n    [(= n 2) 0]\n    [(= n 3) 1]\n    [(= n 4) 2]\n    [(= n 5)\
    \ 3]\n    [(= n 6) 4]\n    [(= n 7) 5]\n    [else (+ 7 (fizz_buzz (quotient n\
    \ 7)))]))\n", "  (define (remainder n)\n    (remainder (quotient n 10) (floor\
    \ n 10)))\n  (define (is-fizz-buzz n)\n    (or (= (modulo n 11) 7) (= (modulo\
    \ n 13) 7)))\n  (cond\n    [(<= n 0) 0]\n    [(is-fizz-buzz (remainder n)) (+\
    \ n 1)]))\n", "  (cond\n    [(zero? n) 0]\n    [(zero? (modulo n 11))\n     (cond\n\
    \       [(zero? (modulo n 13))\n        (+ 3 (fizz_buzz (- n 1)))]\n       [(zero?\
    \ (modulo n 13))\n        (+ 2 (fizz_buzz (- n 1)))]\n       [(zero? (modulo n\
    \ 13))\n        (+ 1 (fizz_buzz (- n 1)))]\n       [else (fizz_buzz (- n 1))])]\n\
    \    [else (+ (fizz_buzz (- n 1)) (fizz_buzz (- n 1)))]))\n", "  (cond (< n (modulo\
    \ n 11)) 0)\n        (= n (modulo n 13)) 1)\n        (else (modulo n 11)))) ",
  "  (cond ((zero? n) 0)\n        ((or (= (modulo n 11) 0)(= (modulo n 13) 0)) 1)\n\
    \        (else (+ 1 (fizz_buzz (modulo n 11))) (fizz_buzz (modulo n 13)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
