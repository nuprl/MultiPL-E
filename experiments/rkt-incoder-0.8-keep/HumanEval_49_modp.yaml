name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n;; >>> modp(3,\
  \ 5)\n;; 3\n;; >>> modp(1101, 101)\n;; 2\n;; >>> modp(0, 101)\n;; 1\n;; >>> modp(3,\
  \ 11)\n;; 8\n;; >>> modp(100, 101)\n;; 1\n(define (modp n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      1\n      (* p (modp n (sub1 p))))) ;; (* (% n\
    \ (- p 1)) p))\n", "  (modp-impl n p))\n", "  (mod n (bignum-size p)))\n", " \
    \ (cond\n    ((= n 0) 1)\n    ((= n 1) p)\n    ((= n 2) (modp 1 (* p p)))\n  \
    \  ((= (logand n 2) 0) (modp 1 (* p (expt 2 1))))\n    ((< n (/ 2 p)) (modp n\
    \ (* p (expt 2 1))))\n    ((< (log n 2) (log p 2))\n      (cond\n\t((= (logand\
    \ n 2) 0) (modp 1 (* p (expt 2 1))))\n\t((= (log n 2) 0) (modp 1 (* p (expt 2\
    \ 1))))\n\t((< n (/ 2 p)) (modp n (* p (expt 2 1))))\n\t(else (modp (- n (/ 2\
    \ p)) p)))))\n  )\n", "  (if (and (integer? n) (integer? p))\n      (mod n p)\n\
    \      (mod (- n 1) p)))\n", "  (mod n p (* 2 p)))\n", "  (modulo (* n n) (/ p\
    \ 2)))\n", "  (if (= p 0)\n      1\n      (* n (modp n (- p 1)))))", "  (if (=\
    \ n 0)\n      1\n      (if (= (modulo p n) 0)\n          0\n          (* 2 (modp\
    \ n (modulo p n))))))\n", "  (- p (remainder n p)))\n", "  (let ([q (* n p)])\n\
    \    (if (= q 0)\n        1\n        (quot q p))\n    ))\n", "  (let ((x (- n\
    \ p)))\n    (if (zero? x)\n        p\n        (- p (modulo x p))))))\n", "  (let\
    \ loop ((n n) (p p))\n    (if (= n 0)\n        p\n        (loop (quotient n p)\
    \ (quotient p n))))))\n", "  (cond\n    [(= n 0) (error 'modp (list \"Cannot divide\
    \ by zero\"))]\n    [(= p 0) (error 'modp (list \"Cannot divide by zero\"))]\n\
    \    [else (cond [(= (remainder n p) 0)\n                   (remainder n p)]\n\
    \                 [else (modp n (quotient p n))])]))\n", "  (cond [(= n 0) 1]\n\
    \        [(= n 1) 0]\n        [(> n 1) (modp (sub1 n) (mod-val p 2))]\n      \
    \  [else (* 2 (mod-val p n))]\n))\n", "  (let ([m (* n p)]\n        [x (+ (/ n\
    \ p) 1)])\n    (cond\n      [(= x 1) 1]\n      [(= m 0) 1]\n      [(= x m) 0]\n\
    \      [else (modp x m)]\n    )\n  )\n)\n", "  (define (x y) (modulo x y))\n \
    \ (if (= p 0)\n      1\n      (* 2 (x n)))\n  (modp n (sub1 p)))\n", "  (modulo\
    \ (modulo n p) p))\n", '  (- n (modulo (* 2 n) p)))', "  (assert (integer? n))\n\
    \  (assert (integer? p))\n  (modpow2 n p))\n", '  (modulo (* 2 n) p))', "  (/\
    \ (modulo-n n p) p))\n", "  (mod n (exptmod p n)))\n", "  (mod p n (ceiling n\
    \ p)))\n", "  (mod n p))\n", "  (let loop ((n n) (p p))\n    (if (< n 0)\n   \
    \     (if (= p 0)\n            0\n            (* p (remainder n p)))\n       \
    \ (loop (quotient n p) (quotient (modulo n p) p))))))\n", "  (mod ((logandbit\
    \ n)\n         (- 1))\n         p))\n", "  (if (zero? n)\n      1\n      (let\
    \ ([(c n) (f 1)]\n            [(k p) (g p)])\n        (cond\n          [(= c 0)\
    \ (modp f (- k 1))]\n          [(< c k) (modp f (- k 1))]\n          [else (modp\
    \ (f (* c k)) (g c))])))))\n</cell>\n<code language=ocaml-jupyter>", "  (cond\
    \ ((= n 0) 1)\n        ((= n 1) p)\n        (else (* 2 (modp n (mod n p)))))\n\
    \  )\n", "  (if (<= n 1)\n      n\n      (mod (- n 1) p)))\n", "  (let ((x (/\
    \ n p)))\n    (cond ((zero? x) 1)\n          ((> x 0) (modp x (remainder p x)))\n\
    \          (else 0)))", "  (let ((q (/ n p))\n        (r (/ 2 (- n p))))\n   \
    \ (cond ((= q 0) 1)\n          ((= r 0) r)\n          ((= r (mod q p)) q)\n  \
    \        (else (modp r (quot q p)))))\n  ", "  (if (= n 0)\n      1\n      (modulo\
    \ (* 2 n) (modulo (modulo n p) p))))\n", "  (define (sub x y)\n    (sub1 (modulo\
    \ x y) y))\n  (if (odd? n)\n      (modulo n p)\n      (sub (sub (modulo n p) (-\
    \ n 1)) p)))\n", "  (modpow2 n p p 1))\n", "  (let loop ((x n) (p p) (acc '()))\n\
    \    (cond\n      [(= x 0) acc]\n      [(even? x) \n       (loop (/ x p)\n   \
    \          (mod-or-not (div (mod x p) 2)\n                           (+ (mod x\
    \ p) 1))\n             (cons x acc))]\n      [else (loop (/ x p) (mod x p) (cons\
    \ x acc))]))))\n", "  (modulo (log2 n) p))\n", "  (cond [(= n 0) (modulo-p p 1)]\n\
    \        [else (modp (/ n 2) p)]))\n", "  (if (zero? n)\n      1\n      (* n (modp\
    \ n (remainder n p)))\n  )\n)\n", "  (modulo (bigint 2) n p))\n", "  (modulo (*\
    \ n p) (* 2 p)))\n", "  (if (= n 0)\n      1\n      (modulo n (/ p 2))))\n", " \
    \ (define (go n s)\n    (cond ((= n 0) s)\n          ((even? n) (go 2(remainder\
    \ n p) (+ s 2)))\n          (else (go (quotient n p) (+ s 1)))))\n  (go n 0))\n",
  "  (if (= n 0)\n      p\n      (mod (expt 2 n)\n           (expt p n))))\n", " \
    \ (expt (expt (expt (expt (expt n 2) 2) 3) 4) p) ; 2 * 2 * 3 * 4 % p\n)\n", " \
    \ (define (modp-aux n p acc)\n    (if (= n 0)\n        acc\n        (modp-aux\
    \ (- n 1)\n                  p\n                  (* acc (modulo-arithmetic p\
    \ n))))\n    (modp-aux n\n              p\n              (modulo-arithmetic p\
    \ n)))\n  (modp-aux n\n            p\n            (modulo-arithmetic p n)))\n",
  "  (modp n p 2))\n", "  (modp-2 n p))\n", "  (cond ((= n 0) 1)\n        ((= p 0)\
    \ 0)\n        (else (* n (modp (sub1 n) p)))\n  )\n)\n", "  (let loop ((n n) (p\
    \ p))\n    (cond ((= n 0) 1)\n          ((= p 0) 1)\n          ((= n p) 1)\n \
    \         ((< n p) (- 1))\n          (else (mod n p (+ n p))) (loop (- n 1) p))))\n",
  "  (- n (lcm-mod p n)))\n  ;; TODO: handle negative numbers\n", "  (modulo (pow\
    \ 2 n) p))\n", "  (cond ((= n 0) 1)\n        ((= n p) 0)\n        (else (modulo\
    \ (modp n (sub1 p)) p))))\n", "  (cond ((zero? n) 1)\n        ((zero? p) 0)\n\
    \        (else (modp (- n 1) p)))\n)\n", "  (if (> n 1)\n      0\n      (floor\
    \ (log (expt 2 n) p))))\n", "  (let ((res\n          (mod (expt 2n n)\n      \
    \         (expt 2p p))))\n    (if (and (< n p)\n            (>= (- res 1) n))\n\
    \        (- res)\n        (if (= res 0)\n            0\n            res))))\n",
  "  (modulo (* 2 n) p (modulo (* 2 n) p p p)))\n", "  (cond [(< n 0) 1]\n       \
    \ [else (modp (/ n p) p)]))\n", "  (mod (expt 2 n) p))\n", "  (mod n (/ 2 p)))\n",
  "  (if (= n 0)\n      (mod p 2)\n      (modp (sub1 n) (mul p 2))))\n", "  (modulo-n\
    \ n p))\n", "  (let ([x n]\n        [q (/ (- n 1) p)]\n        [r (mod x p)]\n\
    \        [s 0]\n        [i 0])\n    (if (zero? q)\n        (let ([y (+ x p)])\n\
    \          (if (zero? r)\n              y\n              (modp y p)\n        \
    \      ))\n          (modp r p)\n          )\n      (let ([y (+ r (- q r))]\n\
    \            [z (mod x p)])\n        (if (zero? y)\n            (+ s z)\n    \
    \        (let ([u (+ z 1)])\n              (if (zero? u)\n                  (+\
    \ s z)\n                  (let ([v (- u 1)])\n                    (if (zero? v)\n\
    \                        (+ s z)\n                        (let ([x (+ (* u p)\
    \ (* v p))])\n                          (modp x p)\n                         \
    \ )\n                        )\n                    )\n                )\n   \
    \           )\n            )\n          )\n        (let ([z (modp y p)])\n   \
    \       (modp z p)\n          )\n        )\n      )\n    )\n  )", "  (let ([m\
    \ (expt 2 n)])\n    (if (> n 0)\n        (modp m p)\n        (modulo m p))))\n",
  "  (cond [(zero? n) 1]\n        [(even? n) (modp (sub1 n) p) (add1 n)]\n       \
    \ [(odd? n) (modp (sub1 n) p) 1]\n        [else (modp (add1 n) p) (add1 n)]))\n",
  "  (if (zero? n)\n      1\n      (modulo (* 2 n) p)))\n", "  (check-type n number)\n\
    \  (check-type p number)\n  (let ([m (mod (+ n 1) p)]\n        [a #1]\n      \
    \  [i #1]\n        [r #1])\n    (let loop ([x n])\n      (cond ((= x 0)\n    \
    \         (if (= m p)\n                 r\n                 (loop (- x 1))))\n\
    \            ((even? x)\n             (if (= m p)\n                 (loop x))\n\
    \             (if (< x m)\n                 (loop (+ x 1)))))\n    (loop (+ x\
    \ 1))\n    r))\n", "  (cond [(= n 0) 1]\n        [(= p 0) 0]\n        [(even?\
    \ n) (cond [(= (mod (+ n 1) p) 0) (+ n 1)\n                           ((and (=\
    \ n 1) (= p 0) (= (mod (+ n 2) p) 0)) 1)\n                           (else 0)]\n\
    \                      [(even? (mod (+ n 2) p))\n                        (cond\
    \ [(= (mod (+ n 2) p) 0) (+ n 2)\n                               ((and (= n 2)\
    \ (= p 0) (= (mod (+ n 3) p) 0)) 1)\n                               (else 0)]\n\
    \                              [else (* n n)]))]))\n", "  (let loop ((n n) (p\
    \ p) (acc 0))\n    (cond [(= n 0) acc]\n          [(< n p) (loop (/ n p) (div\
    \ n p) acc)]\n          [(> n p) (loop (* (/ n p) (+ acc)) (- n p) acc)]\n   \
    \       [else acc])))\n", "  (if (= n 0)\n      1\n      (if (= p 1)\n       \
    \   n\n          (* 2 (modp n (- p 1))))))\n", "  (if (= n 0)\n      1\n     \
    \ (* 2 (modp n (quo (log n (log p)) p))))) ;; log\n", "  (if (<= n p)\n      (mod\
    \ n p)\n      (* 2 (modp n (- p 1)))))\n", "  (if (= n 1)\n      p\n      (* n\
    \ (modp n (- p 1)))))\n", "  (modulo (expt 2 n) p))\n", "  (if (= n 0)\n     \
    \ 1\n      (if (= n p)\n          n\n          (modp (- n (* (- n p) p)) p))\n\
    \  ))\n", "  (check-type n int)\n  (check-type p int)\n  (check-type p int)\n\
    \  (modp-helper n p 1))\n", "  (assert (>= n 0))\n  (assert (< n p))\n  (if (<\
    \ n p)\n      (mod p n)\n      (mod n p)))\n", "  (- n (quotient n p)))\n", " \
    \ (if (= n 0)\n      1\n      (if (>= (modulo n p) 0)\n          (modulo n p)\n\
    \          (modp (quotient n p) (quotient (- n 1) p)))))\n", "  (if (= n 0)\n\
    \      1\n      (modulo (* (expt 2 n) p) p)))\n", "  (if (zero? n) 1 modp (quotient\
    \ n p (- musq 1))))\n", "  (if (= n 0)\n      0\n      (modp (- n 1) p)))\n",
  "  (cond\n    [(= n 0) 1]\n    [else (modp (- n 1) (expt p n))]\n    ))\n", "  (*\
    \ 2 (modpow n p)))\n", "  (mod n p))\n", "  (if (= 0 n)\n      0\n      (if (=\
    \ n 1)\n          1\n          (* p modp(int (/ n 2)) p))))\n", "  (if (= n 1)\n\
    \      (modulo-power n p 2)\n      (modulo-power (- n 1) p (mod-exponent p 2))))\n",
  "  (cond\n    [(= p 0) 1]\n    [(= n 0) 0]\n    [(= n p) (quotient n p)]\n    [else\
    \ (modp n (quotient n p))]))\n", "  (if (= n 0)\n      1\n      (quot (expt (modulo\
    \ (* 2 n) p) 2) p)))\n", "  (mod n p))\n", "  (if (zero? n)\n      1\n      (modulo\
    \ (expt 2 n) p)))\n", "  (if (< n 0)\n      (error \"modp: n must be > 0\"))\n\
    \  (mod ((expt n p)) p))\n", "  (assert (and (integer? n) (positive? n)))\n  (assert\
    \ (and (integer? p) (positive? p)))\n  (modp (expt n 2) p))\n", "  (if (= n 0)\n\
    \      1\n      (* 2 (modp n (- p 1)))))\n", "  (modulo (expt 2 n) p))\n", " \
    \ (cond\n    [(= n 0) 1]\n    [(= n p) 0]\n    [else (modp (- n 1) p) ]))\n",
  "  (let ((m 0))\n    (if (= n 0)\n        m\n        (if (< m p)\n            (modp\
    \ (/ n p) p)\n            (* 2 (modp n (/ p p))\n            (modp n (/ p p))\n\
    \            (* 2 (modp n (/ p p))\n            (modp n (/ p p))\n           \
    \ (* 2 (modp n (/ p p))\n            (modp n (/ p p))))))))\n", "  (check-type\
    \ n number?) ; n is assumed to be an integer\n  (check-type p number?) ; p is\
    \ assumed to be an integer\n  (let ((ms (mod n p)))\n    (cond\n      [(zero?\
    \ ms)\n       (raise (expt p n))]\n      [(= ms 0)\n       (raise (expt p n))]\n\
    \      [else\n       (modp ms p)]))) ; Recursive call\n", "  (expt p n))\n", " \
    \ (cond\n    ((= n 0) 0)\n    ((= n 1) p)\n    ((= p 1) 1)\n    (else (* 2 (modp\
    \ (- n 1) p)))))\n", "  (modp-int n p))\n", "  (let loop ((p p) (acc 1))\n   \
    \ (if (= n 0)\n        acc\n        (loop (remainder n p) (+ acc (remainder n\
    \ (- p n)))))\n    acc))\n", "  (cond [(< n 0)\n         0]\n        [(= (- n\
    \ p) 0)\n         1]\n        [else (modp (- n p) (expt p 2))]))\n", "  (if (=\
    \ n 0)\n      1\n      (* 2 (modp n (remainder p n)))))\n", "  (mod n p))\n",
  "  (let ((m (ceil (logbase (abs n) p) p)))\n    (if (= m 0)\n        n\n       \
    \ (modp (mod n m) p))))\n</code>\n<|/ a tags=scheme,modulo,racket,floor,ceiling\
    \ |>\n<| a |>\nI needed the solution for both negative numbers and positive numbers\
    \ with racket.\n<code>", "  (assert (and (= n 0)\n              (= p 0)\n    \
    \          (not (zero? n))\n              (not (zero? p))))\n  (if (= n p)\n \
    \     n\n      (modulo (* 2 (expt n p)) p)))\n", "  (assert (and (integer? n)\
    \ (positive? n)))\n  (assert (and (integer? p) (positive? p)))\n  (let ((q (expt\
    \ p n)))\n    (assert (and (zero? q) (positive? q)))\n    q))\n", "  (let ((acc\
    \ (remainder n p)))\n    (if (zero? acc)\n        n\n        (remainder acc (modulo\
    \ n p)))\n    acc))\n", "  (if (even? n)\n      n\n      (+ n (modp (- n 1) p))))\n",
  "  (if (> n 0)\n      (modp (1- n) p)\n      0))\n", "  (modulo n p))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= p 1) 1]\n        [(= p 0) (modulo n p)]))\n", "  (cond\n\
    \    ((= n 0) 1)\n    ((= n 1) p)\n    ((= n p) (modulo p n))\n    ((= p (div\
    \ n p)) (modp n (div n p)))\n    ((= p (div n 2)) (modulo p n))\n    (else (modulo\
    \ p (modp n (div n 2))))))\n", "  (cond\n    [(zero? n) 0]\n    [(zero? p) 1]\n\
    \    [(even? n) (floor (* n p))]\n    [else (modp (- n 1) p)]))\n", "  (check-type\
    \ n number)\n  (check-type p number)\n  (check-type p number)\n  (let ((m (modulo\
    \ n p)))\n    (check-type m number)\n    (- m n)))\n", "  (if (< n 0)\n      (modulo\
    \ (- n p) p)\n      (modulo n p)))\n", "  (mod (expt n p) p))\n", "  (mod n (+\
    \ (expt 2 n)p)))\n", "  (let ([t0 (bit-shift n 0))\n        (t1 (bit-shift n 1))\n\
    \        (t2 (bit-shift n 2))\n        (t3 (bit-shift n 3))\n        (t4 (bit-shift\
    \ n 4))\n        (t5 (bit-shift n 5))\n        (t6 (bit-shift n 6))\n        (t7\
    \ (bit-shift n 7))\n        (t8 (bit-shift n 8))\n        (t9 (bit-shift n 9))\n\
    \        (t10 (bit-shift n 10))\n        (t11 (bit-shift n 11))\n        (t12\
    \ (bit-shift n 12))\n        (t13 (bit-shift n 13))\n        (t14 (bit-shift n\
    \ 14))\n        (t15 (bit-shift n 15))\n        (t16 (bit-shift n 16))\n     \
    \   (t17 (bit-shift n 17))\n        (t18 (bit-shift n 18))\n        (t19 (bit-shift\
    \ n 19))\n        (t20 (bit-shift n 20))\n        (t21 (bit-shift n 21))\n   \
    \     (t22 (bit-shift n 22))\n        (t23 (bit-shift n 23))\n        (t24 (bit-shift\
    \ n 24))\n        (t25 (bit-shift n 25))\n        (t26 (bit-shift n 26))\n   \
    \     (t27 (bit-shift n 27))\n        (t28 (bit-shift n 28))\n        (t29 (bit-shift\
    \ n 29))\n        (t30 (bit-shift n 30))\n        (t31 (bit-shift n 31))\n   \
    \     (t32 (bit-shift n 32))\n        (t33 (bit-shift n 33))\n        (t34 (bit-shift\
    \ n 34))\n        (t35 (bit-shift n 35))\n        (t36 (bit-shift n 36))\n   \
    \     (t37 (bit-shift n 37))\n        (t38 (bit-shift n 38))\n        (t39 (bit-shift\
    \ n 39))\n        (t40 (bit-shift n 40))\n        (t41 (bit-shift n 41))\n   \
    \     (t42 (bit-shift n 42))\n        (t43 (bit-shift n 43))\n        (t44 (bit-shift\
    \ n 44))\n        (t45 (bit-shift n 45))\n        (t46 (bit-shift n 46))\n   \
    \     (t47 (bit-shift n 47", "  (modulo (* n 2) p))\n", "  (if (= p 0) 1 \n  \
    \    (* 2 (modp (sub1 n) p)) ))\n", "  (let ((q (/ n p)))\n    (- q (floor (/\
    \ n p))))\n", "  (/ (pow (expt n 2) p)\n     (expt n 2)))\n", "  (modp-loop n\
    \ p))\n", "  (let ((res0 (modulo n p)))\n    (cond\n      [(= res0 0)\n      \
    \ (modulo (expt 2 n) p)\n       (modulo 2 (expt n 2))]\n      [(= res0 p)\n  \
    \     (modulo n 2)]\n      [else\n       res0])))\n", "  (if (= n 0)\n      1\n\
    \      (if (= (mod n p) 0)\n          (/ n p)\n          (* n (modp (- n 1) p))))))\n",
  "  (assert (integer? n))\n  (assert (positive? n))\n  (assert (positive? p))\n \
    \ (if (= n 0)\n      0\n      (modulo (integer->int n) (integer->int p))))\n",
  "  (if (= n 0)\n      1\n      (* 2 n (modp n (- p 1)))))\n", "  (if (= n 0)\n \
    \     1\n      (if (= p 0)\n          0\n          (if (< n p)\n             \
    \ (modp (- n 1) p)\n              (modp n (- p 1))))))\n", "  (if (= n 1)\n  \
    \    p\n      (modulo (* n p) (expt 2 n))))\n", "  (cond ((< n p) n)\n       \
    \ (else (modulo (expt 2 n) p))))\n", "  (mod n (+ n p)))\n", "  (if (= n 0)\n\
    \      1\n      (* 2 (modp (sub1 n) p))))\n", "  (mod n p))\n", "  (let ((q p))\n\
    \    (cond ((= n 0) 1)\n          ((< n p) (- q (modp n (- q q))))\n         \
    \ (else (* q (modp n (- n q)))))))\n", "  (if (zero? n)\n      (modulo p 2)\n\
    \      (quotient n p modp)))\n", "  (modulo (iota n) p))\n", "  (let ((t (modinv\
    \ n p)))\n    (* t t)))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 0]\n      \
    \  [(= p 1) (modulo n p)]\n        [else (modp (- n p) (modulo n p))]))\n", " \
    \ (cond [(< n 0) 1]\n        [(< n p) 0]\n        [else (quotient n (modulo p\
    \ n))]))\n</cell>\n<code language=other-env>", "  (modulo (* 2 n) p))\n", "  (modulo-by-power\
    \ n p 2))\n", "  (define (modp a b)\n    (if (zero? b)\n        a\n        (modp\
    \ (modulo a b) (b div 2))))\n  (modp n (- p (expt 2 n))))\n", "  (/ (remainder\
    \ n p) 2))\n", "  (if (= n 0)\n      1\n      (modulo (* n p) p)))\n", "  (cond\
    \ (zero? n) 0\n        (= n p) p\n        (even? n) (modp (sub1 n) (* 2 p))\n\
    \        (odd? n) (modp n (/ (- 1 n) p))))\n", "  (let ((a 1))\n    (while (<=\
    \ n 0)\n      (set! a (mod a p) (set! n (- n 1)))\n      (set! a (* 2 a))\n  \
    \  )\n    (mod a p)\n  )\n)\n", "  (mod n (expt p 2)))\n", "  (mod n (expt p 2)))\
    \ ; mod n (expt p 2)\n", "  (modp n (mod n p)))\n", "  (let ((car (floor n)))\n\
    \    (let ((rem (modulo n p)))\n      (cond ((< rem 0)\n             (add1 car))\n\
    \            ((> rem 0)\n             (modp rem p))\n            (else n))))\n",
  "  (modulo (* 2 n) p))\n", "  (cond (<?? (modulo? n p) n)\n        ((= n p) 1)\n\
    \        (else (modp (quotient n p) (modulo n p))))\n  ))\n", "  (modulo n p))\n",
  "  (let loop ((n n) (p p) (acc 0))\n    (cond ((and (integer? n) (integer? p)) acc)\n\
    \          ((even? n) (loop (/ n 2) p (+ acc (remainder n p))))\n          (else\
    \ (loop (* n p) (quotient n p) (+ acc 1))))))\n", "  (let loop ((n n) (p p))\n\
    \    (cond ((= n 0) (mod p n)) ((even? n) (loop (divmod n p)\n               \
    \                          (mod p n)))\n          (else (loop (sub1 n)\n     \
    \                (mod p n))))))\n", "  (if (or (= n 0) (= p 0))\n      0\n   \
    \   (quot (expt 2 n) p)))\n", "  (mod n p))\n", "  (let ([s (+ n 1) u (* s p)]\n\
    \        [e (* (expt 2 s) p)])\n    (if (= n 1)\n        e\n        (modp n (*\
    \ u p)))))\n", "  (modulo (expt 2 n) p))\n</code>\n<|/ a tags=scheme |>\n<| c\
    \ |>\nI did it without expt by multiplicating by p^n-1 (where p is prime). This\
    \ gives a number that is always greater than p^n-1.\n<|/ c |>\n<| a dscore=2 tags=scheme\
    \ |>\nThis solution involves no expt function.\n<code>", "  (modp' (* 2 n) (modp\
    \ p n)))\n", "  (mod n (/ p 2)))\n", "  (cond ((= n 0) 1)\n        ((= p 0) 1)\n\
    \        (else (* 2 (modp n (/ p 2))))))", "  (cond [(= n 0) 1]\n        [(or\
    \ (> n p) (< n p)) 0]\n        [(< n (/ p 2)) (modp (- n p) p)]\n        [else\
    \ (modp (- n p) (* 2 p))]))\n", "  (expt 2 n (/ p p)))\n", "  (if (= n 0)\n  \
    \    1\n      (* 2 (modp (- n 1) p))))\n</cell>\n<cell>", "  (check-type n unsigned)\n\
    \  (check-type p unsigned)\n  (assert (>= n 0))\n  (assert (>= p 0))\n  (let ((m\
    \ (expt 2 n)))\n    (cond ((= m 0) 1)\n          ((= m p) p)\n          ((= (mod\
    \ m p) 1) p)\n          ((= (mod m p) (- n 1))\n           (modp n (- n 1))))\n\
    \    (modp n (+ n 1)))\n", "  (let ((f (makeFactExpand '(mod (n (ln p))) '[n p])))\n\
    \    (exptmod f n p)))\n", "  (if (= n 1)\n      n\n      (let ([acc (/ (- n 1)\
    \ p)])\n        (if (= acc 0)\n            (- n p)\n            (modp acc (- p\
    \ 1))))))\n", "  (check-type n unsigned-integer)\n  (check-type p unsigned-integer)\n\
    \  (assert (= n 0))\n  (assert (= p 1))\n  (assert (= (bitwise-and n p) 0))\n\
    \  (check-type p unsigned-integer)\n  (assert (<= 0 n p))\n  (assert (<= p 2))\n\
    \n  (let (result 0)\n    (do ((bits (truncate p bitwise-and))\n         (rem\n\
    \          (bitwise-and n bits)\n          bits)\n       ((>= rem)\n        (set!\
    \ result (rem)))\n      (set! result (bitwise-or (bitwise-and result bits)\n \
    \                        (bitwise-and n bits))))\n    (assert (= result n)))\n\
    \  result)\n", "  (cond (< n p) p\n        (< p n) (mod n p)\n        (= n p)\
    \ 1\n        :else 0))\n", "  (let ([n (expt n p)]\n        [t (expt p p)]\n \
    \       [r (- t n)]\n        [x (mod n p)])\n    (cond [(= x 0) (/ n p)]\n   \
    \       [(= x 1) (/ n t)]\n          [else (/ x r)])))\n", "  (if (or (= n 0)\
    \ (= p 0))\n      (mod n p)\n      (* n (mod-fast (- n 1) p))\n  ))\n", "  (cond\
    \ ((= n 0) 1)\n        ((= p 0) 1)\n        ((< n p) (modp (- n p) (expt p 2))))\n\
    \  )", "  (cond ((= n 0) 0)\n        ((or (= n 1) (= n p))\n         (modulo (-\
    \ n 1) p))\n        (else (modp (- n 1) p))))\n", "  (let ((m (mod (expt 2 n)\
    \ p)))\n    (if (= n 0)\n        m\n        (modp n (- m p)))))\n", "  (mod n\
    \ p))\n", "  (cond\n    [(zero? n) 0]\n    [(> n 1) (modp (- n p) p)]\n    [else\
    \ (mod (pow p n) p)]))\n", "  (check-type n number)\n  (check-type p number)\n\
    \  (mod n p))\n", "  (let ((n' (- n p)))\n    (cond ((= n' 0) 1)\n          ((=\
    \ n' 1) 0)\n          (else (+ n' (modp n' p)))))\n  )\n", "  (assert (and (<=\
    \ n 0) (< p 1)))\n  (assert (< p n))\n  (let ((l (floor (logand n p) 2)))\n  \
    \  (if (= l 1)\n        (floor (/ n p))\n        (modulo (/ (1- n) p) (expt n\
    \ l))))))\n", "  (mod n (int p)))\n", "  (let loop ([n n] [p p] [result 0] [k\
    \ 0])\n    (if (= k p)\n        result\n        (loop (sub1 n)\n             \
    \  (sub1 p)\n               (add1 (remainder (* (expt 2 k) n) p)))\n        (loop\
    \ (add1 n)\n               (sub1 p)\n               (add1 result))))))\n", " \
    \ (if (= n 0)\n      (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo p (modulo (modulo (modulo p n)))))))))) p)\n      (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo p n)))))) p))))\n", "  (let\
    \ loop ([p p n n])\n    (if (= n 0)\n        p\n        (loop (- n 1)\n      \
    \         (modulo (* p n) p))))))\n", "  (let ((m (expt 2 n)))\n    (let ((p (expt\
    \ p 2)))\n      (mod m p))))\n", "  (cond [(= n 0) 1]\n        [(= p 1) (- n 1)]\n\
    \        [else (/ (* (- n 1) (modp n (- p 1))) p)]))", "  (if (< n 0)\n      (error\
    \ \"n must be non-negative\")\n      (mod (expt 2 n) p)))\n", "  (cond ((= n 0)\
    \ 1)\n        (else (mod (exp (- n 1) p) p))))\n", "  (/ (- n (* 2 p)) p))\n",
  "  (modulo-power n p 2))\n", "  (define (loop x k r)\n    (cond\n      [(= x 0)\n\
    \       (modulo (remainder k p) p)\n       ]\n      [(= k 1)\n       (modulo (-\
    \ x 1) p)\n       ]\n      [else\n       (loop (- x 1) (- k 1) (r x (modulo k\
    \ p)))\n       ]\n      )\n    )\n  (loop (+ n 1) n 1))\n", "  (cond [(zero? n)\
    \ 1]\n        [(equal? n 0) 0]\n        [(equal? n p) 0]\n        [else (expt\
    \ 2 (modulo (modulo (+ n 1) p) p)\n                       (- n (* p p)))]))",
  "  (let ((x 2))\n    (if (= n 0)\n        x\n        (let ((x (* x x)))\n      \
    \    (cond ((= x 0)\n                 (mod p x))\n                ((= x p)\n \
    \                (mod p x))\n                (else\n                 (modp n (-\
    \ x 1)))\n                )\n          )\n      )\n    )\n  )\n)\n", "  (let ([a\
    \ (regexp-opt p '(\n                             \\A\n                       \
    \      \\d\n                             \\D\n                             \\\
    D+\n                             ))\n        b (regexp-opt p '(\n            \
    \                 \\d\n                             \\D\n                    \
    \         \\D+\n                             ))\n        m (if (regexp-opt p '\\\
    D+)\n             0\n             (regexp-opt p '\\D))])\n    (let ([r (* n (modulo\
    \ n p))])\n      (cond [(< r m) (- m r)]\n            [else r])))\n", "  (modp-int\
    \ n p))\n", "  (cond ((> n 0) 1)\n        ((< n 0) 0)\n        (else (* 2 (modp\
    \ (- n 1) p)))))\n", "  (let ((mf (make-mpfr 1 p)))\n    (mpfmod mf n mf)))\n",
  "  (modp (* n n) p))\n</code>\nAs you can see, it relies on modp being commutative\
    \ and associative. This has some nice properties, including that modp(100, 101)\
    \ and modp(3, 11) both return 1, and modp(2, 10) and modp(2, 0) both return 0,\
    \ but this may not be the case in general. In the latter case, the following will\
    \ give different results.\n<code>"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
