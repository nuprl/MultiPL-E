name: HumanEval_95_check_dict_case
language: rkt
prompt: "#lang racket\n\n;; Given a dictionary, return True if all keys are strings\
  \ in lower \n;; case or all keys are strings in upper case, else return False.\n\
  ;; The function should return False is the given dictionary is empty.\n;; Examples:\n\
  ;; check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n;;\
  \ check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should\
  \ return False.\n;; check_dict_case({\"a\":\"apple\", \"8\":\"banana\", \"a\":\"\
  apple\"}) should return False.\n;; check_dict_case({\"Name\":\"John\", \"Age\":\"\
  36\", \"City\":\"Houston\"}) should return False.\n;; check_dict_case({\"STATE\"\
  :\"NC\", \"ZIP\":\"12345\" }) should return True.\n(define (check_dict_case dict)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n\
  \    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"\
  ))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"\
  banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\"\
  \ .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal?\
  \ (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"\
  ))) #f)\n    (check-equal? (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"\
  12345\"))) #t)\n    (check-equal? (candidate #hash((\"fruit\" .  \"Orange\") (\"\
  taste\" .  \"Sweet\"))) #t)\n    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? dict) #f]\n        [(equal? (caar dict) (string->lower-case\
    \ (caar dict)))\n         (check_dict_case (delete (caar dict) dict))\n      \
    \   #t]\n        [(equal? (caar dict) (string->upper-case (caar dict)))\n    \
    \     (check_dict_case (delete (caar dict) dict))\n         #t]\n        [else\n\
    \         (check_dict_case (delete (caar dict) dict))\n         #t]))\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(check_string_in_lower_case (car dict))\n   \
    \  (check_string_in_upper_case (car dict))\n     (check_string_in_lower_case (cadr\
    \ dict))\n     (check_string_in_upper_case (cadr dict))]\n    [else (check_string_in_lower_case\
    \ (car dict))\n           (check_string_in_upper_case (car dict))]))\n", "  (cond\n\
    \    [(empty? dict)\n     #t]\n    [(and (typep (first dict) (string (string->symbol\
    \ lower-case)))\n          (typep (first dict) (string (string->symbol upper-case))))\n\
    \     #f]\n    [else #f]))\n", "  (cond\n    [(empty? dict) #t]\n    [(member?\
    \ (caar dict) '(#\\A #\\a)) (check_dict_case (assoc (caar dict) (cdr dict)))]\n\
    \    [else #f]\n    ))\n", "  (or (equal? nil dict)\n      (and (pair? dict)\n\
    \           (check-for-case-matches dict)\n           (check-for-case-matches\
    \ dict dict))))\n", "  (or (not (null? dict))\n      (and\n      (map (lambda\
    \ (x)\n         (and (number? (string-length x))\n               (string=? (string-upcase\
    \ x) (string-upcase (string x))))\n         dict)\n      )))\n", "  (cond\n  \
    \  [(empty? dict) #t]\n    [(member? (caar dict) (map (\u03BB (k) (char->string\
    \ (toLower k)))\n                              (filter (\u03BB (k) (string->boolean\
    \ (toUpper k)))\n                                     dict)))\n     (or (check_dict_case\
    \ (dict (caddr dict)))\n         (check_dict_case (dict (cadddr dict))))]\n  \
    \  [else #f]))\n", "  (cond\n    [(empty? dict) (println \"true\") (println \"\
    false\")]\n    [(member? (car dict) (string->lower-case(cadr (cdr dict))))\n \
    \    (println \"true\")\n     (println \"false\")\n     ]\n    [(member? (car\
    \ dict) (string->upper-case(cadr (cdr dict))))\n     (println \"true\")\n    \
    \ (println \"false\")\n     ]\n    [else (println \"false\")]))\n", "  (cond\n\
    \    [(null? dict) false]\n    [(atom? (car dict)) (check_dict_case (car dict))])\n\
    \  [else\n    (cond\n      [(null? (cdr dict)) false]\n      [(atom? (car dict))\
    \ (check_dict_case (car dict))]\n      [(string? (car dict)) (check_dict_case\
    \ (map string->symbol (map string->string dict)))]\n      [else (check_dict_case\
    \ (map symbol->string (map symbol->symbol (map string->string dict))))])))\n",
  "  (cond\n    [(empty? dict) #t]\n    [(string? (first dict)) (or (all? (map string?\
    \ (rest dict)) (map string? (rest dict)))\n                           (all? (map\
    \ string? (rest dict)) (map string? (rest dict))))]\n    [else #f]))\n", "  (cond\
    \ [(empty? dict)\n         false]\n        [(pair? dict) (equal? (caar dict) (check_dict_case\
    \ (first dict)))\n         (check_dict_case (caddr dict))]\n        [else false]))\n\
    </code>\n<|/ a tags=racket,scheme,lisp |>\n<| a tags=racket,scheme,lisp |>\nUsing\
    \ Racket, here's one way to do it:\n<code>", "  (cond\n    [(empty? dict) #false]\n\
    \    [(member? (car dict) (map lowcase (dict 'keys))) #true]\n    [(member? (car\
    \ dict) (map upper (dict 'keys))) #false]\n    [else #false]))\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(pair? (first dict)) (check_dict_case(first dict))\
    \ (check_dict_case(rest dict))]\n    [(equal? (first dict) (string->lower (string->symbol\
    \ (first dict))))]\n    [(equal? (first dict) (string->upper (string->symbol (first\
    \ dict))))]\n    [else false]\n  ))\n", "  (cond [(empty? dict) #f]\n        [(or\
    \ (string=? (car (dict (car dict)))\n                      (string->lower (car\
    \ dict)))\n             (string=? (car (dict (car dict)))\n                  \
    \    (string->upper (car dict)))) #t]\n        [else #f]))\n", "  (cond\n    [(empty?\
    \ dict) false]\n    [(empty? (car dict)) true]\n    [(equal? (car dict) (string-downcase\
    \ (car dict))) (check_dict_case (cdr dict))]\n    [else false]))\n", "  (cond\n\
    \    ((not (null? dict)) \n     (and (or\n           (member (car dict) '(#\\\
    a \"A\" \"a\"))\n           (member (car dict) '(#\\b \"B\" \"b\"))\n        \
    \   (member (car dict) '(#\\c  \"C\" \"c\"))\n           (member (car dict) '(#\\\
    d  \"D\" \"d\"))\n           (member (car dict) '(#\\e  \"E\" \"e\"))\n      \
    \     (member (car dict) '(#\\f  \"F\" \"f\")))\n     (and (or\n           (member\
    \ (caar dict) '(#\\a \"A\" \"a\"))\n           (member (caar dict) '(#\\b \"B\"\
    \ \"b\"))\n           (member (caar dict) '(#\\c  \"C\" \"c\"))\n           (member\
    \ (caar dict) '(#\\d  \"D\" \"d\"))\n           (member (caar dict) '(#\\e  \"\
    E\" \"e\"))\n           (member (caar dict) '(#\\f  \"F\" \"f\")))\n     False)\n\
    \    (else True)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this, very concise\
    \ and clearly explained!\n<|/ c |>\n<| a |>\nThis is one possible solution with\
    \ pattern matching + function calls:\n<code>", "  (cond\n    ((null? dict) #t)\n\
    \    ((not (symbolp (first dict))) false)\n    ((string? (first dict)) (string->symbol\
    \ (first dict)))\n    ((string->symbol (first dict))\n     (cond\n       ((string=?\
    \ (symbol->string (first dict)) \"A\") true)\n       ((string=? (symbol->string\
    \ (first dict)) \"a\") true)\n       ((string=? (symbol->string (first dict))\
    \ \"B\") true)\n       ((string=? (symbol->string (first dict)) \"b\") true)\n\
    \       ((string=? (symbol->string (first dict)) \"C\") true)\n       ((string=?\
    \ (symbol->string (first dict)) \"c\") true)\n       ((string=? (symbol->string\
    \ (first dict)) \"D\") true)\n       ((string=? (symbol->string (first dict))\
    \ \"d\") true)\n       ((string=? (symbol->string (first dict)) \"E\") true)\n\
    \       ((string=? (symbol->string (first dict)) \"e\") true)\n       ((string=?\
    \ (symbol->string (first dict)) \"F\") true)\n       ((string=? (symbol->string\
    \ (first dict)) \"f\") true)\n       ((string=? (symbol->string (first dict))\
    \ \"G\") true)\n       ((string=? (symbol->string (first dict)) \"g\") true)\n\
    \       ((string=? (symbol->string (first dict)) \"H\") true)\n       ((string=?\
    \ (symbol->string (first dict)) \"h\") true)\n       ((string=? (symbol->string\
    \ (first dict)) \"I\") true)\n       ((string=? (symbol->string (first dict))\
    \ \"i\") true)\n       ((string=? (symbol->string (first dict)) \"J\") true)\n\
    \       ((string=? (symbol->string (first dict)) \"j\") true)\n       ((string=?\
    \ (symbol->string (first dict)) \"K\") true)\n       ((string=? (symbol->string\
    \ (first dict)) \"k\") true)\n       ((string=? (symbol->string (first dict))\
    \ \"L\") true)\n       ((string=? (symbol->string (first dict)) \"l\") true)\n\
    \       ((string=? (symbol->string (first dict)) \"M\") true)\n       ((string=?\
    \ (symbol->string (first dict)) \"m\") true)\n       ((string=? (symbol->string\
    \ (first dict)) \"N\") true)\n       ((string=? (symbol->string (first dict))\
    \ \"n\") true)\n       ((string=? (symbol->string (first dict)) \"O\") true)\n\
    \       ((string=? (symbol->string (first dict)) \"o\") true)\n       ((string=?\
    \ (symbol->string (first dict)) \"P\") ", "  (if (empty? dict)\n      #f\n   \
    \   (or (equal? (car (keys dict)) (string->lower (car dict)))\n          (equal?\
    \ (car (keys dict)) (string->upper (car dict))))))\n", "  (cond\n    [(empty?\
    \ dict) #t]\n    [(list? (first dict)) (or (check_dict_case (first dict))\n\t\t\
    \t(check_dict_case (rest dict)))]\n    [(string? (first dict)) (string? (first\
    \ dict))] \n    [else #f]))\n", "  (or ((empty? dict) false)\n      (and (member\
    \ (caar dict) (map cadr dict))\n           (check_dict_case (second dict))))\n\
    \  )", "  (and (empty? dict)\n       (or (string? \n               (first dict))\n\
    \           (string?\n               (first dict)\n               (first dict)\n\
    \               (first dict))\n           (string?\n               (first dict)\n\
    \               (first dict)\n               (first dict)\n               (first\
    \ dict))))) ;; #lang racket\n", "  (cond [(empty? dict) false]\n        [(string-equal?\
    \ (string->lower key) (string->lower key)) true]\n        [(string-equal? (string->upper\
    \ key) (string->upper key)) true]\n        [else false]))", "  (or (empty? dict)\n\
    \      (map? (lambda (pair) (pair-case? (car pair) 'string)))\n      (map? (lambda\
    \ (pair) (pair-case? (car pair) 'string?))))) \n", "  (cond [(empty? dict) #f]\n\
    \        [(equal? (first dict) (map lower (rest dict)))\n         (check-dict_case\
    \ (rest dict))]\n        [(equal? (first dict) (map upper (rest dict)))\n    \
    \     (check-dict_case (rest dict))]\n        [else #f]))\n", "  (cond ((empty?\
    \ dict) #t)\n        ((not (boolean? (caar dict))) #f)\n        (else (or (check_dict_case\
    \ (map #(if (string? %) #(string % #) %) dict))\n                   (check_dict_case\
    \ (map #(if (string? %) #(string % #) %) dict)))))\n</code>\n<code>\n#lang racket\n",
  "  (cond\n    [(empty? dict) #t]\n    [(equal? (first (first dict)) (first (first\
    \ dict)))\n     (equal? (first (rest dict)) (first (rest dict)))]\n    [else #f]))\n",
  "  (cond [(empty? dict) #t]\n        [(symbol? (car dict)) #t]\n        [(and (symbol?\
    \ (car dict)) (upper-case? (cadr dict))) #f]\n        [(and (not (symbol? (car\
    \ dict))) (upper-case? (cadr dict))) #t]\n        [else #f]))\n", "  (cond\n \
    \   [(empty? dict)\n      false]\n    [(string? (car dict)) (check_dict_case (cdr\
    \ dict))\n     true]\n    [else (check_dict_case (car dict))]))\n", "  (if (empty?\
    \ dict) \n      #f\n      (or ((string? (car dict)) (string? (string->lower-case\
    \ (car dict))) (string? (string->upper-case (car dict))))\n          (check-dict_case\
    \ (cdr dict))))) ;; #lang racket\n", "  (cond\n    [(empty? dict) #t]\n    [(string?\
    \ (? (first dict) (string->string (string->lower (first dict))))) #t]\n    [else\
    \ #f]))\n", "  (cond\n    ((null? dict)\n      false)\n    ((symbol? (car dict))\n\
    \      (and (char? (string->char (car dict)))\n           (check_dict_case (assoc\
    \ dict (car dict))))\n      (check_dict_case (assoc dict (car dict))))\n    (else\
    \ (and (char? (string->char (car dict)))\n              (check_dict_case (assoc\
    \ dict (car dict)))))))\n", "  (and (empty? dict)\n       (or (string? (car dict))\n\
    \           (string? (cadr dict))))) ; car or cadr\n", "  (and (not (empty? dict))\n\
    \       (> (length dict) 2)\n       (> (fst dict) (string->lower (first dict))))\n\
    \  (or (> (length dict) 2)\n      (> (fst dict) (string->upper (first dict))))\n\
    \  (every? (lambda (key)\n            (and (number? key)\n                 (or\
    \ (number? (first key))\n                     (or (number? (second key))\n   \
    \                      (string->lower (first key))\n                         (string->upper\
    \ (first key))\n                         (string->lower (second key))\n      \
    \                   (string->upper (second key)))))\n          (dict key)))\n",
  "  (if (empty? dict) #t \n      (and (map? (lambda (key) (equal? (string-lower (car\
    \ (key-value dict))\n                                             string-lower\
    \ (string-upper (car (key-value dict))))))\n             (keys dict))\n      (and\
    \ (map? (lambda (key) (equal? (string-lower (car (key-value dict))\n         \
    \                                    string-lower (string-upper (car (key-value\
    \ dict))))))\n             (values (values dict))))))\n", "  (cond\n    [(empty?\
    \ dict)  #f]\n    [(symbol? (keys (car dict)))\n     ((and (>= (length (keys (car\
    \ dict))) (length (string->symbol (string->lower-case (keys (car dict)))))) #t)\n\
    \     ((and (>= (length (keys (car dict))) (length (string->symbol (string->upper-case\
    \ (keys (car dict)))))) #f)\n     ((check_dict_case (assoc dict (string->lower-case\
    \ (keys (car dict)))) #t)\n     (check_dict_case (assoc dict (string->upper-case\
    \ (keys (car dict)))) #f)\n     (check_dict_case (assoc dict (string->symbol keys\
    \ (car dict)))) #t]\n    [else #f]))\n", "  (and (or (= (length dict) (length\
    \ dict))\n          (every? string dict)))\n  (every? (lambda (x) (= (string-lower\
    \ x) (string-lower dict))) dict)\n  (every? (lambda (x) (= (string-upper x) (string-upper\
    \ dict))) dict))\n", "  (cond\n    [(empty? dict) #f]\n    [(cons? dict)\n   \
    \  (let ([keys (keys (first dict))])\n       (cond\n         [(equal? (set->list\
    \ (set keys))\n                    (list->set (map string->symbol (string->list\
    \ keys))))\n          #t]\n         [else\n          #f]))]))\n", "  (cond\n \
    \   [(empty? dict) #f]\n    [(string? (car dict)) (check_dict_case (cdr dict))]\
    \ \n    [(string? (car dict)) (check_dict_case (cdr dict))]\n    [else #f]))\n\
    \    ", "  (cond\n    [(empty? dict) #false]\n    [(equal? (car (keys dict)) (string->lower-case\
    \ (car (keys dict))) #true) #true]\n    [else (equal? (car (keys dict)) (string->upper-case\
    \ (car (keys dict))) #true) #false]))\n", "  (or (and (string? (car dict)) (string?\
    \ (cadr dict))\n          (equal? (car dict) (string-downcase (cadr dict)))\n\
    \          (equal? (cadr dict) (string-upcase (car dict))))\n      (or (and (string?\
    \ (car dict)) (string? (cadr dict))\n          (equal? (car dict) (string-downcase\
    \ (cadr dict)))\n          (equal? (cadr dict) (string-upcase (car dict))))))\n",
  "  (cond\n    ((not (null? dict))\n     (and (equal? (lower-case-first dict) (map\
    \ lower-case-first dict))\n          (equal? (upper-case-first dict) (map upper-case-first\
    \ dict))))\n    (false)\n    )\n  )\n  ;; End of check_dict_case\n", "  (let ((keys\
    \ (hash-map null (hash-set (mapcar string->string) \n                        \
    \                 (mapcar string->string))))\n        (lower-case (hash-map null\
    \ (hash-set (mapcar string->string) \n                                       \
    \  (mapcar string->string))))\n    (for/fold ((keys (hash-map null (hash-set (mapcar\
    \ string->string) \n                                          (mapcar string->string))))\n\
    \                (lower-case (hash-map null (hash-set (mapcar string->string)\
    \ \n                                              (mapcar string->string))))\n\
    \              (iter (hash-set (mapcar string->string) (mapcar string->string)))\n\
    \    (if (and (not (empty-hash-map keys)) (not (empty-hash-map lower-case)))\n\
    \      (and (not (empty-hash-set keys)) (not (empty-hash-set lower-case))\n  \
    \         (not (member (car keys) iter))\n           (not (member (car lower-case)\
    \ iter))\n           (not (member (cadr keys) iter))\n           (not (member\
    \ (cadr lower-case) iter))\n           (not (member (car iter) keys)\n       \
    \         (member (cadr iter) lower-case))\n           (not (member (car iter)\
    \ lower-case)\n                (member (cadr iter) keys))\n           (not (member\
    \ (cadr iter) keys)\n                (member (cadr iter) lower-case))\n      \
    \     (not (member (car iter) lower-case)\n                (member (cadr iter)\
    \ keys)))))))\n", "  (cond\n    [(empty? dict) #f]\n    [(member? (string (car\
    \ dict)) (map string (string-lower dict) (map string (string-upper dict))))\n\
    \     (check-dict_case (cdr dict))]\n    [else #f]\n  )\n)\n", "  (or (check_dict_case_rec\
    \ dict (empty-dict))\n      (and (not (null? dict)) (or (and (check-string (car\
    \ dict)) (check-string (cdr dict)))\n                                 (and (check-string\
    \ (car dict)) (not (check-string (cdr dict))))))))\n", "  (cond ((null? dict)\
    \ #f)\n        ((not (pair? dict))\n         (and (equal? (string-upper-case?\
    \ (car dict)) (string-lower-case? (car dict)))\n               (equal? (string-upper-case?\
    \ (cadr dict)) (string-lower-case? (cadr dict))))\n        (else (and (equal?\
    \ (string-upper-case? (car dict)) (string-upper-case? (cadr dict)))\n        \
    \          (equal? (string-upper-case? (car dict)) (string-upper-case? (cadr dict))))\n\
    \        )))\n</code>\n<|/ a |>\n<| c |>\nWhat if your dictionary is (1 2 \"3\"\
    ) would it evaluate to true? It's not clear if we're going to have to handle that\
    \ case.\n<|/ c |>\n<| a tags=lisp,scheme,lisp |>\nThe \"proper\" way to solve\
    \ this would be to write your own \"string comparison\" procedure, using something\
    \ like equal? (in Racket) or eqv? or whatever you prefer.\nIn fact, since you're\
    \ using Racket and Racket has eqv?, you could use this procedure\n<code>", " \
    \ (or (check_string (first dict) (second dict))\n      (check_string (second dict)\
    \ (first dict))))\n", "  (cond\n    [(empty? dict) false]\n    [(equal? (fst dict)\
    \ (string-equal? (lower-case (first dict)) (first dict))) true]\n    [(equal?\
    \ (fst dict) (string-equal? (upper-case (first dict)) (first dict))) true]\n \
    \   [else false]))", "  (cond\n    ((null? dict) True)\n    (\n      (or (is-string?\
    \ dict) (is-string? (car dict)))\n      ((= (car dict) (to-string (car dict)))\
    \ (check-dict_case (cdr dict)))\n      (else false)))\n", "  (cond\n    [(empty?\
    \ dict) #t]\n    [(equal? (first (keys dict)) (string->lower (first dict))) #t]\n\
    \    [(equal? (first (keys dict)) (string->upper (first dict))) #f]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? dict) false]\n    [(= (length dict) (length\
    \ keys))\n     (for/and\n          (lambda (pair)\n            (let ([keys (assoc\
    \ pair)])\n              (cond\n                [(string? keys) true]\n      \
    \          [(string? (substring keys 0 1)) (substring keys 0 1) = ?A]\n      \
    \          [else false])]))]\n    [else false]\n    )\n  )\n)\n", "  (cond\n \
    \   ((not (empty? dict)) (and\n                      (and (typep (first dict)\
    \ 'string) (check-if-lower-case (first dict))\n                           (check-if-upper-case\
    \ (first dict))\n                           (check-if-equal-case (first dict)\
    \ (first (rest dict))))\n                      (check-if-lower-case (first (rest\
    \ dict)))\n                      (check-if-upper-case (first (rest dict)))\n \
    \                     (check-if-equal-case (first (rest dict)) (first (rest dict))))\n\
    \    (else false)))\n", "  (cond\n    [(empty? dict) #f]\n    [(map? (car dict))\
    \ (check_dict_case (car dict))\n              (check_dict_case (cdr dict))]\n\
    \    [else #t]))\n", "  (check-for-type dict\n                  '(hash-table-of-hashes\
    \ vector (pair? (pair? string))))\n  (let ((keys (hash-table-values dict)))\n\
    \    (cond ((null? keys)) #t\n          ((every (string->boolean (cadr keys))\n\
    \                 (string->boolean (cadr keys))))\n          #f))))\n", "  (cond\n\
    \    [(null? dict) #f]\n    [(cons? dict) #t]\n    [(cons? dict) (and (check-case?\
    \ dict) (check-case? (car dict))\n                         (check-case? (cadr\
    \ dict)) (check-case? (caddr dict)))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ dict) #t]\n    [(cons? dict) #f]\n    [(and (pair? (car dict))\n          (and\
    \ (pair? (car dict)) (equal? (car dict) (check-lower-case (car dict))))\n    \
    \      (and (pair? (cdr dict))\n              (and (pair? (cdr dict)) (equal?\
    \ (cdr dict) (check-upper-case (cdr dict))))) #f]\n    [(and (pair? (car dict))\n\
    \          (and (pair? (cdr dict))\n              (and (pair? (car dict)) (equal?\
    \ (car dict) (check-lower-case (cdr dict))))\n              (and (pair? (cdr dict))\n\
    \                  (and (pair? (cdr dict)) (equal? (cdr dict) (check-upper-case\
    \ (cdr dict))))) #f]\n    [else #f]\n  ))\n", "  (cond\n    [(empty? dict) #f]\n\
    \    [(< (length dict) 1) #f]\n    [(> (length dict) 1) #f]\n    [(string-equal?\
    \ (keys (first dict)) (string->lower-case-string (first dict)))\n    (check_dict_case\n\
    \     (rest dict))]\n    [(string-equal? (keys (first dict)) (string->upper-case-string\
    \ (first dict)))\n    (check_dict_case\n     (rest dict))]\n    [else #f]))\n",
  "  (cond ((empty? dict) #f)\n        ((equal? (car dict) (string-downcase (car dict)))\
    \ #t)\n        (else (check_dict_case (cdr dict)))))\n", "  (cond\n    ((null?\
    \ dict) #f)\n    ((not (equal? (car dict) (string-case-left (car dict))))\n  \
    \   (check_dict_case (cdr dict)))\n    ((not (equal? (car dict) (string-case-right\
    \ (car dict))))\n     (check_dict_case (cdr dict)))\n    (else (check_dict_case\
    \ (cdr dict)))))\n", "  (cond\n    [(empty? dict) False]\n    [(and (pair? dict)\
    \ (equal? (first dict) (string->char (string->list (first dict))))) \n     (check_dict_case\
    \ (second dict))]\n    [else (or (equal? (first dict) (string->char (string->list\
    \ (first dict))))\n              (equal? (first dict) (string->char (string->list\
    \ (first dict)) (case->))))]))\n", "  (cond\n    [(empty? dict) false]\n    [else\
    \ (and (or (string? (caar dict)) (string-equal? (caar dict) (string->symbol (string->lower\
    \ \n                                                                         \
    \            (caar dict))))) \n             (or (string? (cadar dict)) (string-equal?\
    \ (cadar dict) (string->symbol (string->upper \n                             \
    \                                                          (cadar dict))))))]))\n",
  "  (if (null? dict)\n      #t\n      (or (member #\\a (map string->lower dict))\
    \ \n          (member #\\b (map string->upper dict)))))\n", "  (let ([keys (symbol-names\
    \ dict)])\n    (if (= (length keys) 0)\n        #t\n        ;; Check if all keys\
    \ are symbols in lower case.\n        (let ([flag (and (= (length (map symbol->string\
    \ keys))\n                              (length keys)))])\n          (if (not\
    \ flag)\n              #f\n              ;; Check if all keys are symbols in upper\
    \ case.\n              (let ([flag (and (= (length (map symbol->string\n     \
    \                                      (upper-case-symbol-keys keys)))\n     \
    \                            (length keys)))])\n                (if (not flag)\n\
    \                    #f\n                    #t)))))))\n", "  (or (check_dict\
    \ dict)\n      (check_dict (list_to_dict (dict_to_list dict))))) ; This may fail\
    \ for dictionaries larger than 1000 items", "  (cond\n    [(empty? dict) false]\n\
    \    [(equal? (caar dict) (string->lower (car dict)))\n     (check_dict_case (caddr\
    \ dict))]\n    [else false]))\n</cell>\n<cell>", "  (and (not (empty? (keys dict)))\n\
    \       (or (and (< <? (length dict)) (string->list (apply (lambda (x) (list <?\
    \ (car x)))) dict))\n           (and (> <? (length dict)) (string->list (apply\
    \ (lambda (x) (list <? (car x)))) dict))))\n  )\n", "  (cond ((null? dict) #f)\n\
    \        ((and (string? (car dict))\n               (string? (caar dict)))\n \
    \        (= (string-lower (car dict)) (string-lower (caar dict))))\n        ((and\
    \ (string? (car dict))\n               (string? (caar dict)))\n         (= (string-upper\
    \ (car dict)) (string-upper (caar dict))))\n        (#t (check-dict_case (cdr\
    \ dict)))))\n", "  (cond [(empty? dict) #false]\n        [(symbol? (car dict))\
    \ (and (upper? (car dict)) \n                                  (check_dict_case\
    \ (cdr dict)))]\n        [(list? (car dict)) (and (lower? (car dict)) \n     \
    \                            (check_dict_case (cdr dict)))]\n        [else #false]))\n",
  "  (and (= (length dict) 1)\n       (or (= (string-length (string->lower (key dict)))\
    \ \n              (string-length (string->lower (key dict))))\n           (= (string-length\
    \ (string->upper (key dict))) \n              (string-length (string->upper (key\
    \ dict))))))\n", "  (if (empty? dict)\n      #f\n      (let ((keys (keys dict)))\n\
    \        (cond\n          [(or (string? keys) (string-upper-case? keys))\n   \
    \        (every (lambda (k) (equal? (string-case-of k) key)) keys)]\n        \
    \  [(or (string? keys) (string-lower-case? keys))\n           (every (lambda (k)\
    \ (equal? (string-case-of k) key)) keys)]\n          [else #f]\n        )))))\n",
  "  (cond\n    ((null? dict) false)\n    ((string? (car dict)) (equal? (car (car\
    \ dict)) (car (cdr (car dict)))))\n    ((equal? (car (car dict)) (car (cdr (car\
    \ dict)))))\n    (else (check_dict_case (cdr dict)))))\n", "  (cond\n    ((null?\
    \ dict) #t)\n    ((not (or (string? (car dict)) (string? (cdr dict))) #t) #f)\n\
    \    (else (or ((string? (car dict)) (string? (cdr dict))) (check_dict_case (cdr\
    \ dict))))))\n", "  (and (empty? dict)\n       (or (not (member (key dict) (member\
    \ #\\lower dict))\n              (not (member (key dict) (member #\\upper dict)))))\n\
    \       (not (empty? (values (dict dict)))))) ; <-- THIS BREAKS THE TEST CASE\n",
  "  (if (empty? dict)\n      #f\n      (let ((key-val (first dict)))\n        (cond\
    \ ((equal? (string-length key) (string-length key-val))\n              #t\n  \
    \            (equal? (string->chars (string->string key))\n                  \
    \    (string->chars (string->string key-val))))\n              (else (check-dict\
    \ (delete key dict :test identity)))))))\n", "  (cond\n    [(empty? dict) false]\n\
    \    [(cons? dict) (any? (lambda (x) (equal? (car x) (cadr x))\n             \
    \                  (equal? (car (cdr dict)) (cadr (cdr (cdr dict)))\n        \
    \                       (lower? (car dict))\n                               (upper?\
    \ (car dict))\n                               (equal? (car dict) (cadr dict))\n\
    \                               (equal? (car (cdr dict)) (cadr (cdr (cdr dict)))))))]\n\
    \    [else false]))\n", "  (cond\n    [(empty? dict)\n     #f]\n    [(atom? (car\
    \ dict))\n     (lower? (car dict))\n     (check_dict_case (cdr dict))]\n    [else\n\
    \     (not (and (atom? (car dict)) \n              (lower? (car dict)) \n    \
    \          (check_dict_case (cdr dict)))))]))\n", "  (if (empty? dict)\n     \
    \ false\n      (cond\n        ((string? dict) (cond\n                        \
    \  ((string? (car dict)) (string? (car dict)))\n                          ((string?\
    \ (cdr dict)) (string? (cdr dict))))\n        ((string? (car dict))\n        \
    \ (cond\n           ((string? (car dict)) (string? (car dict)))\n           ((string?\
    \ (cdr dict)) (string? (cdr dict))))\n           ;; ((string? (car dict)) (string?\
    \ (cdr dict))) should return false.\n        ((string? (cdr dict))\n         (cond\n\
    \           ((string? (car dict)) (string? (car dict)))\n           ((string?\
    \ (cdr dict)) (string? (cdr dict))))\n           ;; ((string? (car dict)) (string?\
    \ (cdr dict))) should return false.\n        (else (check_dict_case (cdr dict))))))\
    \ \n</code>\nThe above code passes all the test cases but fails on case:\n<code>",
  "  (and (not (empty? (dict)))\n       (cond\n         ;; String in lower case\n\
    \         ((not (string=? (car (dict)) (string=? (car dict) (string->lower (car\
    \ (dict)))))) (check-dict dict \"in lower case\"))\n         ;; String in upper\
    \ case\n         ((not (string=? (car (dict)) (string=? (car dict) (string->upper\
    \ (car (dict)))))) (check-dict dict \"in upper case\"))\n         ;; String in\
    \ both cases\n         ((not (string=? (car (dict)) (string=? (car dict) (string->upper\
    \ (car (dict)))))) (check-dict dict \"in both cases\"))\n         ;; Invalid case\n\
    \         (else (check-dict dict \"invalid case\")))))\n", "  (cond\n    [(empty?\
    \ dict) false]\n    [(string-equal? (fst dict) (check-lower-case (fst dict)))\
    \ true]\n    [(string-equal? (fst dict) (check-upper-case (fst dict))) true]\n\
    \    [else false]))\n", "  (cond\n    [(empty? dict) #t]\n    [(pair? (car dict))\
    \ (check_dict_case((car dict)))]\n    [else (or (char? (car dict))\n         \
    \     (char? (car dict))\n              (check_dict_case(cdr dict))))]))\n", " \
    \ (cond\n    [(empty? dict) true]\n    [else (and (or\n                   (> (string-length\
    \ dict) 0)\n                   (< (string-length dict) 0)\n                  \
    \ (string-upper-case (string-ref dict 0))\n                   (string-lower-case\
    \ (string-ref dict 0))))]))\n", "  (or (every (lambda (x) (typep x 'string)) dict)\
    \ (every (lambda (x) (typep x 'string)) (map string->symbol dict))))\n", "  (cond\n\
    \    ((empty? dict) #f)\n    ((cons? dict) (all (lambda (key val) (and (string?\
    \ (string->lower key)) (equal? (string->lower val) (string->lower dict))))\n \
    \            (dict-keys dict)))\n    (else #f)))\n", "  (cond\n    [(empty? dict)\
    \ #f]\n    [(atom? (car dict)) #t]\n    [(and (pair? (car dict)) (atom? (car dict)))\
    \ (check-case? (car dict))]\n    [else #f]))\n", "  (cond\n    [(empty? dict)\
    \ true]\n    [(equal? (string->upper (first dict)) (string->upper (first dict)))\n\
    \     (check_dict_case (first dict)) (check_dict_case (rest dict))]\n    [else\
    \ false]))\n", "  (cond\n    [(empty? dict) #f]\n    [(check_strings_in_lower_case?\
    \ dict) #t]\n    [(check_strings_in_upper_case? dict) #t]\n    [else #f]\n   \
    \ )\n  )\n", "  (and (not (empty? dict))\n       ((eq? (string-lower keys) (string-lower\
    \ dict)) \n        (check_dict_cases (cdr dict)))\n       ((eq? (string-upper\
    \ keys) (string-upper dict)) \n        (check_dict_cases (cdr dict)))\n      \
    \ (else false)))\n", "  (cond\n    ((null? dict) false)\n    ((equal? (caar dict)\
    \ (caadr dict)) (equal? (cadar dict) (caadr dict)))\n    (else false)))\n", " \
    \ (cond\n    [(empty? dict) false]\n    [(and (list? (car dict))\n           (list?\
    \ (cdr dict)))\n      (and (map? (car dict))\n           (map? (cdr dict)))]\n\
    \    [(and (pair? (car dict))\n           (pair? (cdr dict)))\n      (and (list?\
    \ (car dict))\n           (list? (cdr dict)))]\n    [else false]\n    )\n  )\n",
  "  (cond\n    [(empty? dict) #f]\n    [(equal? (car dict) (string->lower (car dict)))\n\
    \     (check_dict_case (cdr dict))]\n    [(equal? (car dict) (string->upper (car\
    \ dict)))\n     (check_dict_case (cdr dict))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? dict) #t]\n    [(not (map? (lambda (k) (and (symbol? k) (equal?\
    \ (string->lower k) (string->upper k))))))\n     (not (map? (lambda (k) (and (symbol?\
    \ k) (equal? (string->upper k) (string->lower k))))))]\n    [else #f]))\n", " \
    \ (cond\n    [(null? dict) false]\n    [(symbol? (car dict)) (check_dict_case\
    \ (cdr dict))]\n    [(and\n        (string? (car dict))\n        (string? (cdr\
    \ dict))) true]\n    [else false]))\n", "  (or (and (string? (car (keys dict)))\
    \ \n          (equal? (car (keys dict)) (string->lower (car (keys dict))))) \n\
    \      (and (equal? (car (keys dict)) (string->upper (car (keys dict))))))\n",
  "  (cond\n    [(empty? dict)\n      false]\n    [(map? (car dict))\n      (and (>=\
    \ (length (car dict)) 1)\n           (check_dict_case (car dict)))]\n    [(pair?\
    \ (car dict))\n      (and (map? (car dict))\n           (check_dict_case (car\
    \ dict)))]\n    [else false]))\n", "  (cond\n    [(empty? dict) #t]\n    [(every\
    \ string? (key-set dict)) #t]\n    [else #f]))\n</cell>\n<text>\nExercise 2\n\
    Write a procedure that prints out all possible combinations of 3 numbers in a\
    \ list with repetitions. The list should contain between 1 and 10 elements. The\
    \ number should occur only once per combination. The numbers should all be in\
    \ the range between 1 and 100.\n\nExamples:\n\nInput: (list 1 2 3 2 3 4 5 2 4\
    \ 5 3 4 5 6 7 8 9 9 9 9 1 2 3 4 5 6 7 8 9 9 9)\nOutput: ((1 2 3) (1 2 4) (1 2\
    \ 5) (1 2 6) (1 2 7) (1 2 8) (1 2 9) (1 3 4) (1 3 5) (1 3 6) (1 3 7) (1 3 8) (1\
    \ 3 9) (1 4 5) (1 4 6) (1 4 7) (1 4 8) (1 4 9) (1 5 6) (1 5 7) (1 5 8) (1 5 9)\
    \ (1 6 7) (1 6 8) (1 6 9) (1 7 8) (1 7 9) (1 8 9) (2 3 4) (2 3 5) (2 3 6) (2 3\
    \ 7) (2 3 8) (2 3 9) (2 4 5) (2 4 6) (2 4 7) (2 4 8) (2 4 9) (2 5 6) (2 5 7) (2\
    \ 5 8) (2 5 9) (2 6 7) (2 6 8) (2 6 9) (2 7 8) (2 7 9) (2 8 9) (3 4 5) (3 4 6)\
    \ (3 4 7) (3 4 8) (3 4 9) (3 5 6) (3 5 7) (3 5 8) (3 5 9) (3 6 7) (3 6 8) (3 6\
    \ 9) (3 7 8) (3 7 9) (3 8 9) (4 5 6) (4 5 7) (4 5 8) (4 5 9) (4 6 7) (4 6 8) (4\
    \ 6 9) (4 7 8) (4 7 9) (4 8 9) (5 6 7) (5 6 8) (5 6 9) (5 7 8) (5 7 9) (5 8 9)\
    \ (6 7 8) (6 7 9) (6 8 9) (7 8 9))\n\n\n</text>\n<code language=dyalog-kernel>",
  "  \n  (or (empty? dict)\n      (and\n       (check-if (string? key) dict)\n   \
    \    (check-if (string? (string key)) dict))))\n", "  (cond\n    [(empty? dict)\
    \ #t]\n    [(member (key dict) (string->symbol string->lower (key dict))) #t]\n\
    \    [else #f]))\n", "  (or (and (empty? dict) (not (pair? dict))) (and (not (empty?\
    \ dict)) (pair? dict))))\n", "  (if (empty? dict)\n      #t\n      (and (every\
    \ (lambda (x) (string? (string->lower x))) (list->values (dict)))\n          \
    \ (every (lambda (x) (string? (string->upper x))) (list->values (dict))))))\n",
  "  (cond\n    [(empty? dict) false]\n    [(list? (car dict)) (check_dict_case (car\
    \ dict))\n               (check_dict_case (cdr dict))]\n    [else (= (string?\
    \ (car (car dict))) (string? (car (cdr (car dict)))))\n           (check_dict_case\
    \ (cdr (car dict)))]))\n", "  (cond\n    [(empty? dict) false]\n    [(string?\
    \ (car dict)) (lower (car dict))] \n    [else (lower (car dict))] \n    [else\
    \ (upper (car dict))] \n    [else (check_dict_case (cdr dict))]))\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(member key '(#\\a #\\b ...)) (and (<= key #\\\
    A) (<= key #\\B) ...) \n       (check_dict_case (remove-if (lambda (x)\n     \
    \                                (and (<= key #\\A) (<= key #\\B) ...))\n    \
    \                                dict))]\n    [else false]\n  )\n)\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(member #\\a (member #\\a (toString dict))) false]\n\
    \    [else true]))\n", "  (and (empty? dict) \n       (or (equal? (caar dict)\
    \ (caadr dict))\n           (equal? (caadr dict) (caadr dict)))))\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(string? (car dict)) (check_dict_case (car dict))\
    \ (check_dict_case (cdr dict))]\n    [else false]))\n", "  (cond\n    [(empty?\
    \ dict)\n      true]\n    [(map? (first dict))\n     (cond\n       [(equal? (first\
    \ dict) (upper-case (first dict)))\n        (cond\n         [(equal? (second dict)\
    \ (upper-case (second dict)))\n          (check_dict_case (second dict))]\n  \
    \       [(equal? (first dict) (lower-case (first dict)))\n          (check_dict_case\
    \ (second dict))]\n         [else\n          (check-dict_case (second dict))])]\n\
    \       [else\n        (check-dict_case (second dict))])]\n    [else\n     (check-dict_case\
    \ (second dict))]))\n", "  (cond\n    [(empty? dict) false]\n    [else (and (<\
    \ \n                (count\n                 (filter (lambda (k) (and (symbol?\
    \ k) (string<? (char->lower (car k)) \n                                      \
    \        (string<? (char->upper (car k))))) \n                          (entry-keys\
    \ dict))))\n               (check_dict_case (cdr dict)))]))\n", "  (cond [(null?\
    \ dict) #f]\n        [(member (car dict) '(\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\
    \ \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\
    \ \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\")) #t]\n        [(member (car dict)\
    \ '(\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"\
    M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"\
    Z\")) #t]\n        [else #f]))\n", "  (cond\n    [(empty? dict) false]\n    [else\
    \ (and (map? (lambda (x) (equal? (string->lower x) (string->lower dict))))\n \
    \            (map? (lambda (x) (equal? (string->upper x) (string->upper dict))))])\n\
    \  )\n)\n", "  (cond\n    [(empty? dict) #false]\n    [(equal? (caar dict) (string-lower\
    \ (string-upcase (cadar dict))))\n     (check_dict_case\n      (remove-if (lambda\
    \ (k) (equal? (string-upcase k) (string-lower (string-upcase (cadar dict)))))\
    \ \n                dict))]\n    [else #false]))", "  (if (null? dict)\n     \
    \ #f\n      (and (map? dict) (map? (lambda (x) (or (string? (car x)) (string?\
    \ (caar x))))))\n  )\n", "  (cond [(null? dict) false]\n        [(and (list? (car\
    \ dict)) (< 2 (length dict)))\n         (and (list? (car dict)) (<= (length dict)\n\
    \                                   (length (car dict))))\n         (and (list?\
    \ (car dict)) (<= (length dict)\n                                   (length (cdr\
    \ dict))))\n         true]\n        [else (or (and (list? (car dict)) (< (length\
    \ dict) (length \n                   (cdr dict)))) (and (list? (car dict)) (<=\
    \ (length dict)\n                                                           (length\
    \ (car dict))))\n                    false)]))\n", "  (or (and (symbol? (car dict))\
    \ (string? (car dict)))\n      (and (symbol? (car dict)) (string? (cdr dict))))\n\
    )\n", "  (or (string=? (keys (dict)) (list (string-lower (keys (dict))) (string-upper\
    \ (keys (dict)))) \n      (or (string=? (keys (dict)) (list (string-lower (keys\
    \ (dict))) (string-upper (keys (dict)))))\n      (not (equal? (keys (dict)) (list\
    \ (string-lower (keys (dict))) (string-upper (keys (dict)))))\n      ))\n)\n",
  "  (cond [(empty? dict) false]\n        [(and (pair? (car dict))\n             \
    \ (equal? (check-case(car dict)) \n                      (check-case(car (cdr\
    \ dict))))\n              (check_dict_case(cdr dict)))\n         true]\n     \
    \   [else false]))\n", "  (cond\n    [(empty? dict) #t]\n    [(equal? (car dict)\
    \ (string-lower \"a\")) #t]\n    [(equal? (car dict) (string-upper \"A\")) #f]\n\
    \    [(equal? (car dict) (string-lower \"a\")) #f]\n    [else (check_dict_case(cdr\
    \ dict))]))\n", "  (let ([keys-lc (map lowcase (list dict '()))\n         keys-uc\
    \ (map uppercase (list dict '()))])\n    (and (empty? keys-lc)\n         (empty?\
    \ keys-uc))\n    false))\n", "  (cond\n    ((empty? dict)\n     #t)\n    ((not\
    \ (pair? dict))\n     #f)\n    ((equal? (first dict) (second dict))\n     (check_dict_case\
    \ (second dict))\n     (check_dict_case (rest dict)))\n    (else\n     (equal?\
    \ (first (first dict))\n             (first (second dict))\n             (check-dict_case(second\
    \ dict))\n             (check-dict_case(rest dict)))))\n", "  (cond\n    [(empty?\
    \ dict) (empty? dict)] \n    [(equal? (car dict) (string->lower (car dict)) ||\n\
    \             (equal? (car dict) (string->upper (car dict)))) (check_dict_case\
    \ (cdr dict))]\n    [else false]))\n</code>\n<|/ a tags=scheme,dictionary |>\n\
    <| a dscore=2 |>\nAn implementation of Laurent's answer with Racket:\n<code>\n\
    #lang racket\n", "  (cond\n    [(empty? dict) (not empty?)]\n    [(and (pair?\
    \ dict) (member? (caar dict) '(\"a\" \"A\" \"b\" \"B\" \"i\" \"I\" \"s\" \"S\"\
    )))\n     (and (lower? (cadar dict))\n          (member? (caar dict) '(\"A\" \"\
    a\" \"B\" \"b\" \"I\" \"i\" \"S\" \"s\")))]\n    [(and (pair? dict) (member? (caar\
    \ dict) '(\"8\" \"9\" \"0\" \"1\")))\n     (and (upper? (cadar dict))\n      \
    \    (member? (caar dict) '(\"A\" \"a\" \"B\" \"b\" \"I\" \"i\" \"S\" \"s\")))]\n\
    \    [(and (pair? dict) (member? (caar dict) '(\"0\" \".\" \":\" \"@\" \"_\")))\n\
    \     (and (lower? (cadar dict))\n          (member? (caar dict) '(\"A\" \"a\"\
    \ \"B\" \"b\" \"I\" \"i\" \"S\" \"s\")))]\n    [(and (pair? dict) (member? (caar\
    \ dict) '(\"0\" \".\" \":\" \"@\" \"_\")))\n     (and (upper? (cadar dict))\n\
    \          (member? (caar dict) '(\"A\" \"a\" \"B\" \"b\" \"I\" \"i\" \"S\" \"\
    s\")))]\n    [else false]))\n", "  (cond\n    [(empty? dict) #t]\n    [(and (empty?\
    \ (rest dict)) (string-equal? (first dict) (first dict)))\n     (check-dict_case-aux\
    \ dict '#f)\n     (check-dict_case-aux dict '#t)\n     (check-dict_case-aux dict\
    \ '#f)]\n    [else (check-dict_case-aux dict '#f)]))\n", "  (cond [(empty? dict)\
    \ false]\n        [(or (pair? dict) (atom? dict)) false]\n        [(equal? (first\
    \ dict) (string-length dict)) true]\n        [else (equal? (first dict) (substring\
    \ dict 1 1))]))\n", "  (cond\n    ((null? dict)\n     (string? (first dict))\n\
    \     (string? (last dict)))\n    (else (and (>= (length dict) (length dict))\
    \ \n               (string? (first dict)) \n               (string? (last dict)))))",
  "  (cond [(empty? dict) #t]\n        [(and (string? (caar dict)) (string? (cadar\
    \ dict))) (or (char-lower? (cadar dict)) (char-upper? (cadar dict)))]\n      \
    \  [else #f]))\n", "  (cond [(null? dict)\n         (false)]\n        [(and (string?\
    \ (caar dict))\n              (string? (caadr dict)))\n         (false)]\n   \
    \     [else\n         (and (equal? (caar dict) (string->atom(car dict)))\n   \
    \            (equal? (caadr dict) (string->atom(cadr dict))))\n         (false)]))\n",
  "  (if (empty? dict)\n      #f\n      (or (string? (caar dict))\n          (string?\
    \ (cadar dict))))\n  ", "  (cond\n    [(empty? dict) #f]\n    [(= (string-equal?\
    \ (first dict) (string (string->lower (first dict)))) #t) #f]\n    [else (check_dict_case\
    \ (rest dict))]\n  ))\n", "  (cond ((null? dict) #f)\n        ((not (pair? (car\
    \ dict)))\n         (and (eq? (string->lower (car dict)) (string->lower (car (cdr\
    \ dict))))\n              (check_dict_case (cdr dict)))\n        (t (or (check_dict_case\
    \ (car dict))\n               (check_dict_case (cdr dict))))))\n", "  (cond\n\
    \    [(empty? dict) #f]\n    [(not (pair? dict)) #f]\n    [(and (string? (caar\
    \ dict)) (string? (caddr dict)))\n     ((or (string? (caar dict)) (string? (caddr\
    \ dict)))\n      #t)]\n    [else #f]))\n", "  (cond\n    [(null? dict) #f]\n \
    \   [(and (string? (car dict)) (string? (cadr dict))) #t]\n    [(and (string?\
    \ (car dict)) (string? (cadr dict)) (string? (caddr dict)))\n         #f]\n  \
    \  [else #f]\n    )\n  )\n", "  (cond\n    [(empty? dict) false]\n    [(string-equal?\
    \ (string->lower-case (car dict)) (string->lower-case (car dict)))\n     (check_dict_case\
    \ (cdr dict))]\n    [(string-equal? (string->upper-case (car dict)) (string->upper-case\
    \ (car dict)))\n     (check_dict_case (cdr dict))]\n    [else false]))\n", " \
    \ (cond\n    ((empty? dict) #f)\n    ((member? (car dict) #\\A) #t)\n    ((member?\
    \ (car dict) #\\a) #t)\n    ((member? (car dict) #\\B) #f)\n    ((member? (car\
    \ dict) #\\b) #f)\n    ((member? (car dict) #\\C) #f)\n    ((member? (car dict)\
    \ #\\c) #f)\n    ((member? (car dict) #\\D) #f)\n    ((member? (car dict) #\\\
    d) #f)\n    ((member? (car dict) #\\E) #f)\n    ((member? (car dict) #\\e) #f)\n\
    \    ((member? (car dict) #\\F) #f)\n    ((member? (car dict) #\\f) #f)\n    ((member?\
    \ (car dict) #\\G) #f)\n    ((member? (car dict) #\\g) #f)\n    ((member? (car\
    \ dict) #\\H) #f)\n    ((member? (car dict) #\\h) #f)\n    ((member? (car dict)\
    \ #\\I) #f)\n    ((member? (car dict) #\\i) #f)\n    ((member? (car dict) #\\\
    J) #f)\n    ((member? (car dict) #\\j) #f)\n    ((member? (car dict) #\\K) #f)\n\
    \    ((member? (car dict) #\\k) #f)\n    ((member? (car dict) #\\L) #f)\n    ((member?\
    \ (car dict) #\\l) #f)\n    ((member? (car dict) #\\M) #f)\n    ((member? (car\
    \ dict) #\\n) #f)\n    ((member? (car dict) #\\O) #f)\n    ((member? (car dict)\
    \ #\\o) #f)\n    ((member? (car dict) #\\P) #f)\n    ((member? (car dict) #\\\
    p) #f)\n    ((member? (car dict) #\\Q) #f)\n    ((member? (car dict) #\\q) #f)\n\
    \    ((member? (car dict) #\\R) #f)\n    ((member? (car dict) #\\r) #f)\n    ((member?\
    \ (car dict) #\\S) #f)\n    ((member? (car dict) #\\s) #f)\n    ((member? (car\
    \ dict) #\\T) #f)\n    ((member? (car dict) #\\t) #f)\n    ((member? (car dict)\
    \ #\\U) #f)\n    ((member? (car dict) #\\u) #f)\n    ((member? (car dict) #\\\
    v) #f)\n    ((member? (car dict) #\\W) #f)\n    ((member? (car dict) #", "  (cond\
    \ [(empty? dict) #false]\n        [(equal? (car dict) (string-lower (car dict)))\
    \ #true]\n        [(equal? (car dict) (string-upper (car dict))) #true]\n    \
    \    [else #f]))\n", "  (cond\n    [(empty? dict) #t]\n    [(not (pair? dict))\
    \ #f]\n    [(equal? (caar dict) (string->symbol (car dict))) #t]\n    [else (equal?\
    \ (caar dict) (string->symbol (string-lower (car dict)))) #t]\n    [else (equal?\
    \ (caar dict) (string->symbol (string-upper (car dict)))) #f]\n    [else (check_dict_case\
    \ (cdr dict))]))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ |>\nAh, I got it.  I needed to recursively check each car and cdr pair, until\
    \ I hit a non-pair case.  Once I checked a car I needed to check it's cdr, then\
    \ if that doesn't work, I'll have to restart all the way back up.  This is what\
    \ I came up with:\n<code>", "  (cond ((empty? dict) #f)\n        ((map? (car (keys\
    \ dict))) (check_dict_case (cdr dict)))\n        (else (or (and (string? (car\
    \ dict)) (string? (car dict)))\n                   (and (string? (car (keys dict)))\
    \ (string? (car (keys dict)))))))\n", "  (or (every? (lambda (key) (equal? (string-lower\
    \ (string-trim key))\n                                (string-lower (string-trim\
    \ (string-upper key)))))\n          (every? (lambda (key) (equal? (string-lower\
    \ (string-trim key))\n                                (string-upper (string-trim\
    \ (string-upper key)))))\n          (null? dict))))\n", "  (or (null? dict) (every\
    \ (lambda (key) (and (string? key) (string-length key))) (pairs dict))))\n", " \
    \ (define (helper str)\n    (cond\n      [(empty? str) #false]\n      [(pair?\
    \ str) (helper (car str))\n       (helper (cdr str))]))\n  (helper dict))\n",
  "  (cond\n    [(empty? dict) #t]\n    [(map? (keys dict)) #t]\n    [else\n     (and\
    \ (map? (map string (string-lower keys))) #t)\n     (and (map? (map string (string-upper\
    \ keys))) #t)]))\n", "  (cond\n    [(empty? dict) #false]\n    [(string? (car\
    \ dict)) (and (check-case? (car dict)) (check-case? (cdr dict)))]\n    [else (and\
    \ (check-case? (car dict)) (check-case? (cdr dict)))]))\n", "  (cond\n    [(empty?\
    \ dict) #t]\n    [(string? (car dict)) (or (check_dict_case (cdr dict)) (check_dict_case\
    \ (car dict)))]\n    [else false]\n  )\n)\n", "  (cond\n    ((empty? dict) #f)\n\
    \    ((string-equal? ((first dict) 'key) (string-lower-case? ((first dict) 'key))))\
    \ #t)\n    ((string-equal? ((first dict) 'key) (string-upper-case? ((first dict)\
    \ 'key)))) #f)\n    (else #f)\n    )\n  )\n", "  (cond\n    [(empty? dict) #f]\n\
    \    [(string? (car dict)) #t]\n    [(and (or (string? (car dict)) (string?(cadr\
    \ dict)))\n          (string? (caadr dict)))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(equal? (caar dict) (string-lower (string-downcase\
    \ (caar dict))))\n     (check_dict_case (append (rest dict) (list '()))) ]\n \
    \   [(equal? (caar dict) (string-upper (string-downcase (caar dict))))\n     (check_dict_case\
    \ (append (rest dict) (list '()))) ]\n    [else true]))\n", "  (cond\n    ((null?\
    \ dict) #f)\n    ((or (number? (car dict)) (string? (car dict)))\n     (check_dict_case\
    \ (cdr dict)))\n    ((string? (car dict))\n     (string? (caar dict))\n     (and\
    \ (string? (caar dict) (or (string? (car dict)) (string? (car (cdr dict))))))\n\
    \    ((list? (car dict)) (or (check_dict_case (car dict)) (check_dict_case (cdr\
    \ dict))))\n    ((pair? (car dict))\n     (or (check_dict_case (car dict)) (check_dict_case\
    \ (cdr dict))))\n    (else #t)))\n", "  (cond\n    [(null? dict) #f]\n    [(string?\
    \ (car dict)) (check_dict_case (car dict))\n              (check_dict_case (cdr\
    \ dict))]))\n", "  (if (empty? dict)\n      true\n      (or (and (empty? (car\
    \ dict)) (empty? (cdr dict)))\n          (and (empty? (car dict)) (empty? (cadr\
    \ dict)))\n          (and (empty? (car dict)) (empty? (cddr dict))))))", "  (cond\n\
    \    [(empty? dict) #f]\n    [(empty? (car dict)) #t]\n    [(equal? (car dict)\
    \ (string-downcase-first (car dict)))\n     (check_dict_case (cdr dict))]\n  \
    \  [else (check_dict_case (cdr dict))]))\n", "  (if (empty? dict)\n      #t\n\
    \      (and (equal? (first dict) (second dict))\n           (string? (first dict))\
    \ \n           (string? (second dict))\n           (and (equal? (first dict) (first\
    \ dict))\n                (equal? (second dict) (second dict))\n             \
    \   (string? (third dict))\n                (string? (fourth dict)))))\n", " \
    \ \n  (cond [(empty? dict) false]\n        [(pair? (car dict)) \n         (and\
    \ (map? (car dict)) \n               (check_dict_case (cdr dict)))]\n        [else\
    \ (and (< \n                    (lower-case? (car dict)) \n                  \
    \  (upper-case? (car dict)))]\n       )\n      )\n   )\n  ", "  (cond ((null?\
    \ dict) #f) \n        ((pair? dict) (check_dict_case (car dict))\n          (and\
    \ (check_dict_case (cadr dict))\n               (check_dict_case (caddr dict))))\n\
    \        (else (equal? (car dict) \n                     (string->lower \n   \
    \                   (string->upper \n                       (car dict))))))\n",
  "  (and (not (null? dict)) ;; If the dictionary is not empty, proceed\n       (not\
    \ (member (string->lower (keys (car dict))) \n                      (string->lower\
    \ (keys (car dict))))))) ;; If all the keys are in lower case, return True\n  ",
  "  (cond\n    [(empty? dict) #f]\n    [(string-equal? (first dict) (string-downcase\
    \ (first dict)))\n     (check-dict_case (tail dict))]))\n", "  (let ((temp-dict\
    \ (make-hash))\n         ;; Iterate through the dictionary to create temp-dict\n\
    \         (iter (hash-iterator temp-dict)))\n    (if (hash-has-keys dict iter)\n\
    \        ;; All keys are strings -- dictionary is all lower case\n        (let\
    \ ((key (hash-ref iter 0))\n              (value (ref (hash-ref dict key))))\n\
    \          (cond ((string? key)\n                 (set! value (make-string (length\
    \ key) value)))\n                (else\n                 (set! value (string value))))\n\
    \      ;; All keys are strings -- dictionary is all upper case\n      (let ((key\
    \ (hash-ref iter 0))\n            (ref (hash-ref dict key)))\n        (cond ((string?\
    \ key)\n              (set! ref (make-string (length key) ref)))\n           \
    \   (else\n              (set! ref (string ref))))\n      (set! iter (hash-next\
    \ iter))\n      (check-dict-case-recurse (hash-ref dict iter) temp-dict))))\n",
  "  (cond ((null? dict)\n         #f)\n        ((not (pair? (car dict)))\n      \
    \   #f)\n        ((not (list? (car dict)))\n         #f)\n        ((not (vector?\
    \ (car dict)))\n         #f)\n        ((string? (car dict))\n         (check_dict_case\
    \ (cdr dict)))\n        ((string? (car dict))\n         (check_dict_case (cdr\
    \ dict)))\n        ((pair? (car dict))\n         (check_dict_case (cdr dict)))\n\
    \        ((vector? (car dict))\n         (check_dict_case (cdr dict)))\n     \
    \   ((list? (car dict))\n         (check_dict_case (cdr dict)))\n        ((string?\
    \ (cadr dict))\n         (check_dict_case (cdr dict)))\n        (#t (check-for-errors\n\
    \              (check-for-string\n               (cadr dict)\n               (check_dict_case\n\
    \               (caddr dict))\n               (check_dict_case\n             \
    \  (cadddr dict)))))\n      )\n  )\n", "  (and (not (empty? dict)) (equal? (map\
    \ car (sort (map string->symbol (filter string->symbol (keys dict))))) '())))",
  "  (cond\n    [(empty? dict) false]\n    [(string? key (low-case key)) (check_dict_case\
    \ (assoc key dict))\n     (check_dict_case (assoc key (dict (upper-case key))))]\n\
    \    [else false]))\n", "  (if (empty? dict)\n      #f\n      (let ([keys (keys\
    \ dict)])\n        (and (equal? (set-upper-case keys) keys)\n             (equal?\
    \ (set-lower-case keys) keys)))))\n", "  \n  (define (helper dict low-keys up-keys)\n\
    \    (if (empty? dict)\n        #f\n        (if (and (equal? (car dict) (cadr\
    \ dict)) \n                (or (equal? (cadr dict) (caddr dict))\n           \
    \         (equal? (cadr dict) (cadddr dict))))\n            ; found a match with\
    \ same case\n            #t\n            (if (not (equal? (car dict) (caddr dict)))\n\
    \                ; found a match with different case\n                (false ;\
    \ dict is inconsistent \n                (helper (cdr dict) \n               \
    \         low-keys (cons (cadr dict) (cons (caddr dict) up-keys)))\n         \
    \       #f))))) ; dict consistent\n\n  (if (empty? dict)\n      #f\n      (helper\
    \ (car dict) \n              (list #t) #t))))\n", "  (cond\n    [(empty? dict)\
    \ false]\n    [else (and (list? (first dict))\n               (all (string->lower\
    \ . keys) (first dict)))\n          (check_dict_case (rest dict))]\n    [else\
    \ false]))\n", "  (cond\n    [(empty? dict) #f]\n    [(member? (caar dict) (map\
    \ (fn [item]\n                                 (cond\n                       \
    \           [(string? (car item)) #t]\n                                  [(string?\
    \ (cadr item)) #f]\n                                  [else #f])\n           \
    \                      (cdr (assoc item dict))])) #t]\n    [else #f]))\n", " \
    \ (and (empty? dict) #t)\n  (or (= (length (keys dict)) 1)\n      (= (length (set\
    \ (map string->char (keys dict))\n                         (set (map string->char\
    \ (values dict))\n                              (set (map string->char (keys dict))))))\n\
    \      #t))\n", "  (cond\n    [(empty? dict) false]\n    [(or (string? key) (string?\
    \ (car dict))) (or (string? (car dict)) (string? key))])\n  )\n", "  (define (check_dict_case-helper\
    \ d key val empty?)\n    (cond\n      [(empty? d) empty?]\n      [(equal? (car\
    \ d) key) (equal? val (string key))]\n      [else (check_dict_case-helper (cdr\
    \ d) key val (equal? (car d) key))]\n    ))\n  (check_dict_case-helper dict '()\
    \ (string 'False) false))\n", "  (cond\n    [(empty? dict) false]\n    [(cons?\
    \ dict) \n     (equal? (caar dict) (string->lower-case (caar dict))) (check-dict_case\
    \ (caddr dict))]\n    [else (check-dict_case (caddr dict))]))\n", "  (let ([k\
    \ (dict (map #(\u03BB (x) (and (symbol? x) (equal? (char->string (string x))\n\
    \                                          (char->string (car x)))))\n       \
    \            (keys dict))])\n    (cond [(empty? k) false]\n          [(empty?\
    \ (rest k)) false]\n          [else (and (equal? (car k) (string (car k)) (equal?\
    \ (cdr k) (string (car k))))\n                  (check_dict_case (cdr k)))]))\n",
  "  (let loop ((dict1 (assoc dict '()))\n            (dict2 dict1))\n    (cond\n\
    \      [(empty? dict1) (= dict2 dict1)] \n      [(not (and (pair? dict1)\n   \
    \            (= (string? (first dict1))\n                  (string? (first dict2)))))]\n\
    \      [(not (and (pair? dict2)\n               (= (string? (first dict2))\n \
    \                 (string? (first dict1)))))]\n      [else (loop (rest dict1)\
    \ dict2)]))\n  false)\n", "  (cond\n    [(null? dict) #false]\n    [(member (car\
    \ dict) '(\"A\" \"a\" \"b\" \"B\" \"B\" \"b\" \"A\" \"A\" \"8\" \"8\" \"a\"))]\n\
    \    [else (check_dict_case\n             (assoc (car dict) '(\"A\" \"a\" \"b\"\
    \ \"B\" \"B\" \"b\" \"A\" \"A\" \"8\" \"8\" \"a\"))) ]))\n", "  (if (empty? dict)\n\
    \    #f\n    (or (every (lambda (k) (typep k string)) dict) \n        (every (lambda\
    \ (k) (typep k string)) (dict-map dict string))))) ;; Scheme doesn't have typep.\n",
  "  (if (empty? dict) false\n      (and (or\n             (check-string-lower-case\
    \ (first dict))\n             (check-string-upper-case (first dict)))\n      \
    \     (check-string-lower-case (rest dict))\n           (check-string-upper-case\
    \ (rest dict))))) \n", "  (cond\n    [(empty? dict) false]\n    [(or (string?\
    \ #:key (string-ref (car dict) #:key)) (string? #:key (string-ref (cdr dict) #:key)))\n\
    \      false]\n    [else true]))\n", "  (cond\n    ((null? dict) #f)\n    ((or\
    \ (string? (car dict))(string? (upper-case? (car dict)))) #f)\n    ((or (string?\
    \ (upper-case? (car dict))(string? (lower-case? (car dict))))) #f)\n    (else\
    \ #f)))\n", "  (or (every? string? (keys dict)) (every? (lambda (x) (string= x\
    \ \"A\")) (keys dict)) (every? (lambda (x) (string= x \"B\")) (keys dict))))\n",
  "  (cond\n    [(empty? dict)\n      (equal? dict empty-dictionary)\n    ]\n    [(string?\
    \ (car dict))\n      (cond\n        [(equal? (string->lower dict) (string->lower\
    \ (cdr dict)))\n         (check_dict_case (cdr dict))\n        ]\n        [(equal?\
    \ (string->upper dict) (string->upper (cdr dict)))\n         (check_dict_case\
    \ (cdr dict))\n        ]\n        [else\n         (false)\n        ]\n      )\n\
    \    ]\n    [(cons? dict)\n      (cond\n        [(equal? (string->lower dict)\
    \ (string->lower (car dict)))\n         (check_dict_case (car dict))\n       \
    \ ]\n        [(equal? (string->upper dict) (string->upper (car dict)))\n     \
    \    (check_dict_case (car dict))\n        ]\n        [else\n         (false)\n\
    \        ]\n      )\n    ]\n    [else\n      (false)\n    ]\n  )\n)\n", "  (cond\n\
    \    ((empty? dict) #f)\n    (else\n      (let* (\n            lowercase-dict\
    \ (apply map string dict)\n            uppercase-dict (apply map string dict (map\
    \ string #'char->upper-case))\n            all-lowercase-string (apply and (map\
    \ (lambda (s)\n                                            (equal? (first s) (first\
    \ lowercase-dict)))\n                                        lowercase-dict))\n\
    \            all-uppercase-string (apply and (map (lambda (s)\n              \
    \                              (equal? (first s) (first uppercase-dict)))\n  \
    \                                      uppercase-dict))\n            are-all-strings-lowercase\
    \ (cond\n                                ((null? all-lowercase-string) #f)\n \
    \                               ((null? all-uppercase-string) #t)\n          \
    \                      (equal? all-lowercase-string all-uppercase-string) #f))\n\
    \            are-all-strings-uppercase (cond\n                               \
    \ ((null? all-lowercase-string) #f)\n                                ((null? all-uppercase-string)\
    \ #t)\n                                (equal? all-uppercase-string all-lowercase-string)\
    \ #t))\n            are-all-strings (are-all-strings-lowercase or are-all-strings-uppercase))\n\
    \        #t))))\n", "  (cond\n    [(empty? dict) #f]\n    [(equal? (first dict)\
    \ (string->symbol (string->lower (first dict))))\n     (check_dict_case (rest\
    \ dict))]\n    [(equal? (first dict) (string->symbol (string->upper (first dict))))\n\
    \     (check_dict_case (rest dict))]\n    [else #f]))\n", "  (cond [(empty? dict)\
    \ #t]\n        [(member (first dict) (string-lower-case)) #t]\n        [(member\
    \ (first dict) (string-upper-case)) #t]\n        [else #f]))\n", "  (and (not\
    \ (empty? dict))\n       (let ((check (make-string (length dict) ?))\n       \
    \      (key (first dict)))\n         (for-each (lambda (x) (set-char check x (string-char\
    \ (string->char (string->string x))))\n                    dict)\n          (set-char\
    \ (check-char key)\n                    (check-char key)\n                   \
    \ ?)))\n  dict)\n", "  (and (or (string? (string-intern key))\n           (string?\
    \ (string-upper-case-intern key))\n           (null? dict)\n           (pair?\
    \ (car dict))\n           (check-for-valid-keys (cdr dict) (key))\n          \
    \ (check-for-valid-keys (cddr dict) (key)))\n    (not (string? (string-intern\
    \ key))\n         (string? (string-upper-case-intern key))))", "  (cond\n    [(empty?\
    \ dict) false]\n    [(equal? (caar dict) (caar (car dict)))\n    (check_dict_case\
    \ (assoc dict (car (cdr (cdr dict)))))]\n    [else false]))\n", "  (cond\n   \
    \ [(empty? dict) #f]\n    [(string? first(dict)) (check_dict_case(tail(dict)))]\n\
    \    [else (or (string? (first dict)) (check_dict_case(tail(dict))))]))\n", " \
    \ (cond\n    [(empty? dict) true]\n    [(equal? (car dict) (string-downcase (car\
    \ dict)))\n     (check_dict_case (cdr dict))]\n    [else false]))\n", "  \n  (let\
    \ helper ((dict dict))\n    (cond\n      [(null? dict) false]\n      [else (cond\
    \ [(string? (string-ref (car dict) 0)) false]\n                 [(string? (string-ref\
    \ (car dict) 1)) false]\n                 [else (helper (cdr dict))]) ]))) \n",
  "  (and (not (null? dict))\n       (and (cons? dict)\n            (or (and (= (first\
    \ dict) (string? (string->lower dict))))\n                (and (= (first dict)\
    \ (string? (string->upper dict))))\n                ;; Both lower and upper case\
    \ are present\n                (and (= (length dict) (/ (length dict) 2))))\n\
    \            ;; Every key is a string in the dictionary\n            (not (null?\
    \ (rest dict))))))\n", "  (cond\n    ((empty? dict) #f)\n    ((= (length dict)\
    \ 1) #f)\n    ((atom? (car dict)) #t)\n    (else (and (check_dict_case (car dict))\n\
    \             (or (and (equal? (string->char (car dict)) #\\A)\n             \
    \       (equal? (string->char (car dict)) #\\a)))\n             (or (and (equal?\
    \ (string->char (car dict)) #\\B)\n                    (equal? (string->char (car\
    \ dict)) #\\b)))\n             (and (check_dict_case (cdr dict))\n           \
    \       (check_dict_case\n                   (remove-if (lambda (key)\n      \
    \                          (equal? (string->char (string->list key)) #\\a) dict)))))))\n",
  "  (or (and (empty? dict) (null? (car dict))) (and (not (empty? dict)) (and (or\
    \ (string=? (car dict) (string->lower (car dict))) (string=? (car dict) (string->upper\
    \ (car dict)))))) \n  )\n", "  (or (and (is-string? dict) (map? (lambda (k v)\
    \ (equal? (car k) (tolower (car v))))))\n      (and (is-string? dict) (map? (lambda\
    \ (k v) (equal? (car k) (toupper (car v))))))))\n", "  (define (check dict)\n\
    \    (cond\n      [(null? dict) false]\n      [(list? (car dict)) (and (check-dict\
    \ (car dict)) (check (cdr dict)))]\n      [(string? (car dict)) (and (equal? (string-downcase\
    \ (car dict)) \n                                   (string-downcase (car dict)))\
    \ (check (cdr dict)))]\n      [else false]\n      ))\n  (check (car dict)))\n",
  "  (cond\n    ((empty? dict)  false)\n    ((equal? (car dict) (string->symbol (car\
    \ dict)))  true)\n    ((equal? (car dict) (string->symbol (string->symbol (car\
    \ dict))))  false)\n    (else (check_dict_case (cdr dict)))))\n", "  (cond ((null?\
    \ dict) #t)\n        ((not (map? (car (car dict)))\n             (check-dict_case\n\
    \               (cdr dict))))\n        (else #f)))\n", "  (cond\n    [(empty?\
    \ dict) #f]\n    [(member? (car dict) (list (map string->symbol (map (\u03BB (x)\n\
    \                                            (string->lower-case x))\n       \
    \                                     (car dict))))) #t]\n    [else #f]\n    )\n\
    \  )\n", "  (cond\n    [(null? dict) false]\n    [(member (key dict) (string-refs))\n\
    \     (string-equal? (lower-case (key dict)) (lower-case (key dict)))]\n    [(member\
    \ (key dict) (string-refs))\n     (string-equal? (upper-case (key dict)) (upper-case\
    \ (key dict)))]\n    [else false]))\n", "  (cond ((null? dict) #f)\n        ((string=?\
    \ (car dict) (string-downcase (car dict)))\n         (check_dict_case (cdr dict)))\n\
    \        (else (bool=? (car dict) (string-upcase (car dict)))))) \n</code>\n<|/\
    \ a tags=racket,lisp dscore=1 |>\n<| c |>\nThe first solution only works for words\
    \ (not for numbers). Also, the second solution does not even work for words. Please\
    \ take another look at the question.\n<|/ c |>\n<| c |>\nThe first solution will\
    \ work for words and numbers. Please see the examples: http://pastebin.com/9QC8v9K9.\
    \ The second solution works for words and numbers.\n<|/ c |>\n<| c |>\nIt does\
    \ not work for words. Try it on your example.\n<|/ c |>\n<| c |>\nI'm so sorry.\
    \ There was an error on my part. It works now.\n<|/ c |>\n<| c |>\nThis works\
    \ great! One question: I see that `dict=?` can use `#t`, `#f`, etc. Is there a\
    \ function that can check a number against a word?\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is an implementation of an algorithm I came up with. \nIt works by iterating\
    \ over each letter in the string and keeping track of the letters that had been\
    \ seen. The string should only contain letters. It will also work if you have\
    \ words or symbols.\n<code>", "  (cond\n    [(empty? dict) false]\n    [(equal?\
    \ (keys (car dict)) (string->list (string->lower (first dict))))\n     (check_dict_case\
    \ (cdr dict))]\n    [(equal? (keys (car dict)) (string->list (string->upper (first\
    \ dict))))\n     (check_dict_case (cdr dict))]\n    [else (check-bool (equal?\
    \ (car dict) (cadr dict)))]\n  ))\n", "  (cond\n    ((empty? dict) #f)\n    ((check_key_case\
    \ (first dict))\n     (cond\n       ((empty? rest) #f)\n       ((check_key_case\
    \ (first rest)) #t)\n       (else (check_key_case (first rest)))))\n    (else\
    \ (check_key_case (first dict)))))\n", "  (if (empty? dict)\n      #f\n      (or\
    \ (string? (caar dict)) (string? (cadar dict))\n          (and (not (string? (caar\
    \ dict))) (not (string? (cadar dict))))\n          (and (not (string? (caadr dict)))\
    \ (not (string? (caaar dict))))\n          (and (not (string? (caar dict))) (not\
    \ (string? (cadadr dict))))\n          (and (not (string? (caadr dict))) (not\
    \ (string? (caarr dict))))\n          (and (not (string? (caadr dict))) (not (string?\
    \ (caaar dict))))\n          (and (not (string? (caadr dict))) (not (string? (caadr\
    \ dict))))\n          (and (not (string? (caadr dict))) (not (string? (caadadr\
    \ dict))))\n          (and (not (string? (caadadr dict))) (not (string? (caaadr\
    \ dict))))\n          (and (not (string? (caadr dict))) (not (string? (caadadr\
    \ dict))))\n          (and (not (string? (caadr dict))) (not (string? (caadr dict))))\n\
    \          (and (not (string? (caadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caaadr dict))))\n\
    \          (and (not (string? (caadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not (string? (caadr dict))) (not (string? (caadr dict))))\n \
    \         (and (not (string? (caadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caaadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caaadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caaadadr dict))))\n\
    \          (and (not (string? (caadadr dict))) (not (string? (caadadr dict))))\n\
    \          (and (not ", "  (cond\n    [(empty? dict) #t]\n    [(cons? dict) \n\
    \     (and\n      (apply (lambda (k v) (equal? (car k) (check-string v)))\n  \
    \           (car (assoc (car dict) (cdr dict))))\n     (check_dict_case (cdr dict))]))\n",
  "  (if (null? dict)\n      #f\n      (let ((keys (flatten (map string->list (dict-keys\
    \ dict)))))\n        (and (every (lambda (e) (char->string e)) keys)\n       \
    \      (every (lambda (e) (char->string e)) (keys reverse)))))\n  )\n</code>\n\
    <code>\n#lang racket\n", "  (let ([keys #(map cadr dict)])\n    (not (= 0 (length\
    \ keys)))))\n", "  (cond\n    [(empty? dict) #f]\n    [else (and (equal? (caar\
    \ dict) (string-lower (car dict))) (check_dict_case (cdr dict)))]))\n", "  (and\
    \ (empty? dict) (= (count (map string dict)) 0)\n       (= (count (map string\
    \ dict))\n        (= (count (map string-upcase dict))\n         (- 0 (count (map\
    \ string-upcase dict))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
