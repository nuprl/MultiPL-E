name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n;; count_upper('aBCdEf') returns 1\n;; count_upper('abcdefg')\
  \ returns 0\n;; count_upper('dBBE') returns 0\n(define (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (let loop ((s s))\n    (if (= (length s) 0)\n        0\n        (if\
    \ (even? (rest s))\n            (+ 1 (if (char=? (first s) \"A\" \"a\") 0))\n\
    \            (loop (rest s)))))) ;; (count_upper \"abCdEf\") returns 2\n</code>\n\
    Now let's write the code for the function that computes your answer:\n<code>",
  "  (cond\n    [(or (char=? (car s) #\\A)\n         (char=? (car s) #\\O))\n    \
    \  0]\n    [(char=? (car s) #\\A)\n     (add1 (count_upper (cdr s)))]\n    [(char=?\
    \ (car s) #\\E)\n     (add1 (count_upper (cdr s)))]\n    [else (count_upper (cdr\
    \ s))]\n   )\n)\n", "  (cond\n    ((= (length s) 0)\n     0)\n    ((even? i)\n\
    \     (cond\n       ((or (char-upper? (string-ref s i))\n            (char-upper?\
    \ (string-ref s (+ i 1))))\n        1)\n       (else\n        0))))\n", "  (if\
    \ (empty? s)\n      0\n      (+ 1 (- (count (char s #\\A) (char s #\\a))\n   \
    \            (count (char s #\\A) (char s #\\A)))))\n", "  (let ((count 0))\n\
    \    (lambda ()\n      (let ((char (car s)))\n        (cond\n          ((string=?\
    \ char #\\A) (set! count (+ count 1)))\n          ((string=? char #\\a) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\b) (set! count (+ count 1)))\n\
    \          ((string=? char #\\c) (set! count (+ count 1)))\n          ((string=?\
    \ char #\\d) (set! count (+ count 1)))\n          ((string=? char #\\e) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\f) (set! count (+ count 1)))\n\
    \          ((string=? char #\\g) (set! count (+ count 1)))\n          ((string=?\
    \ char #\\h) (set! count (+ count 1)))\n          ((string=? char #\\i) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\j) (set! count (+ count 1)))\n\
    \          ((string=? char #\\k) (set! count (+ count 1)))\n          ((string=?\
    \ char #\\l) (set! count (+ count 1)))\n          ((string=? char #\\n) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\m) (set! count (+ count 1)))\n\
    \          ((string=? char #\\o) (set! count (+ count 1)))\n          ((string=?\
    \ char #\\p) (set! count (+ count 1)))\n          ((string=? char #\\q) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\r) (set! count (+ count 1)))\n\
    \          ((string=? char #\\s) (set! count (+ count 1)))\n          ((string=?\
    \ char #\\t) (set! count (+ count 1)))\n          ((string=? char #\\v) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\W) (set! count (+ count 1)))\n\
    \          ((string=? char #\\-) (set! count (+ count 1)))\n          ((string=?\
    \ char #\\_) (set! count (+ count 1)))\n          ((string=? char #\\:) (set!\
    \ count (+ count 1)))\n          ((string=? char #\\;) (set! count (+ count 1)))\n\
    \          ((string=? char #\\') (set! count (", "  (cond\n    [(or (char=? s\
    \ #\\a) (char=? s #\\e))  0] ;; a..e are vowels.\n    [(or (char=? s #\\b) (char=?\
    \ s #\\f))  1] ;; b..f are vowels.\n    [else                       (+ (count_upper\
    \ (substring s 0 2)) 1)]))\n", "  (count (lambda (x)\n           (char-upper?\
    \ (char-code x) (char-code (substring s x))))\n         0 s))\n", "  (if (null?\
    \ s)\n      0\n      (let loop ([s s])\n        (if (null? s)\n            0\n\
    \            (if (char=? s #\\A)\n                (if (even? index)\n        \
    \            (+ 1 (loop (rest s))) ; recurse without changing the position\n \
    \                   (loop (rest s)))))))\n", "  (cond\n    ((null? s) 0)\n   \
    \ ((char-upper? (car s)) 1)\n    (else (+ 1 (count_upper (cdr s))))))\n", "  (cond\
    \ [(char-upper? s 0) 0]\n        [(char-upper? s 1) 1]\n        [else (+ 1 (count_upper\
    \ (cdr s))))))\n", "  (let loop ((count 0) (char #\\A))\n    (cond [(string-length\
    \ s = 0)\n           count]\n          [else\n           (set! char (char-ref\
    \ s (string-length s)))\n           (when (char-alphabetic? char)\n          \
    \   (loop (+ count 1)\n                   (char-ref char 1)))]\n          [else\n\
    \           (loop (+ count 1)\n                 (char-ref char (- 1 (string-length\
    \ s))))]))\n</code>\nI then added a small helper function to handle the special\
    \ case where the last character of the string is alphabetic, since we don't need\
    \ to test for it.\n<code>", "  (let loop ([i 0] [n 0])\n    (cond\n      [(null?\
    \ s) n]\n      [(char=? (car s) #\\A) (loop (+ i 2) 0)]\n      [(char=? (car s)\
    \ #\\z) (loop (+ i 2) (+ n 1))]\n      [else (loop (+ i 2) (+ n 1))])))\n", " \
    \ ;; Use recursion because we want to count only even indices.\n  (if (zero? s)\n\
    \      0\n      (if (char-upper? (car s))\n          (+ 1 (count_upper (cdr s)))\n\
    \          (count_upper (cdr s)))))\n", "  (count\n   (lambda (i)\n    (if (even?\
    \ i)\n      (cond (char= (char-code (char s i)) 'A)\n            (char= (char-code\
    \ (char s i)) 'E)\n            (char= (char-code (char s i)) 'I))\n      'X))\n\
    \   0))\n", "  (if (empty? s)\n      0\n      (if (even? (modulo length? s 2))\n\
    \          1\n          0)))\n", "  (count #\\a #\\b #\\c #\\d #\\e #\\f #\\g\
    \ #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\x #\\y #\\z))\n", "  (match s\n    ((char\
    \ #\\a) (+ 1 0))\n    ((char #\\e) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char\
    \ #\\o) (+ 1 0))\n    ((char #\\A) (+ 1 0))\n    ((char #\\E) (+ 1 0))\n    ((char\
    \ #\\U) (+ 1 0))\n    ((char #\\O) (+ 1 0))\n    ((char #\\a) (+ 1 0))\n    ((char\
    \ #\\E) (+ 1 0))\n    ((char #\\o) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char\
    \ #\\U) (+ 1 0))\n    ((char #\\O) (+ 1 0))\n    ((char #\\a) (+ 1 0))\n    ((char\
    \ #\\e) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char #\\o) (+ 1 0))\n    ((char\
    \ #\\A) (+ 1 0))\n    ((char #\\E) (+ 1 0))\n    ((char #\\o) (+ 1 0))\n    ((char\
    \ #\\u) (+ 1 0))\n    ((char #\\U) (+ 1 0))\n    ((char #\\O) (+ 1 0))\n    ((char\
    \ #\\a) (+ 1 0))\n    ((char #\\e) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char\
    \ #\\o) (+ 1 0))\n    ((char #\\A) (+ 1 0))\n    ((char #\\E) (+ 1 0))\n    ((char\
    \ #\\o) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char #\\U) (+ 1 0))\n    ((char\
    \ #\\O) (+ 1 0))\n    ((char #\\A) (+ 1 0))\n    ((char #\\E) (+ 1 0))\n    ((char\
    \ #\\o) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char #\\U) (+ 1 0))\n    ((char\
    \ #\\O) (+ 1 0))\n    ((char #\\a) (+ 1 0))\n    ((char #\\e) (+ 1 0))\n    ((char\
    \ #\\u) (+ 1 0))\n    ((char #\\o) (+ 1 0))\n    ((char #\\A) (+ 1 0))\n    ((char\
    \ #\\E) (+ 1 0))\n    ((char #\\o) (+ 1 0))\n    ((char #\\u) (+ 1 0))\n    ((char\
    \ #\\U) (+ 1 0))\n    ((char #\\O) (+ 1 0))\n    ((char #\\A) (+ 1 0))\n    ((char\
    \ #\\E) (+ ", "  (if (<= (length s) 3)\n      (if (= (substring s 0 2) #\\a)\n\
    \          (if (= (substring s 0 1) #\\u)\n              (if (= (substring s 1\
    \ 2) #\\e)\n                  (+ 1 (count_upper s))\n                  (count_upper\
    \ s))\n              (count_upper s))\n          (count_upper s))\n      (count_upper\
    \ s)))\n</code>\n<|/ a tags=scheme,racket,recursion |>\n<| c |>\nThis answer doesn't\
    \ explain why it is correct or why it works.\n<|/ c |>\n<| c |>\nI don't see anything\
    \ wrong with this answer. I wrote it this way to better illustrate my point. My\
    \ goal was to demonstrate that a simple recursive function can be used in place\
    \ of a loop. My code was just an exercise in thinking about the problem and writing\
    \ a recursive function.\n<|/ c |>\n<| a dscore=0 tags=scheme,racket,recursion\
    \ |>\nI know it's a late answer, but I wanted to give it a try anyway after seeing\
    \ the question. So this is how I solved the problem using Racket's syntax:\n<code>\n\
    #lang racket", "  (let loop ((count 0) (cur (char->integer (string-ref s 0)))\n\
    \             (end (string-length s)))\n    (cond\n      [(char-upper-case cur)\
    \ (loop (add1 count) cur (sub1 end))\n                                       (char-upper-case\
    \ end)]\n      [else (loop (add1 count) cur (sub1 end))]))))\n", "  (count-if\
    \ even? #(char= (char s) #\\A) (make-string s (length s) #\\A)))\n", "  (let ([counter\
    \ 0])\n    (do ([i s (+ i 2))\n         (char char->integer (char-lowercase i))])\n\
    \      (cond\n        ((= (modulo char 26) 0)\n         (set! counter (+ counter\
    \ 1))))))\n", "  (cond\n    [(empty? s) 0]\n    [(even? index) count]\n    [else\
    \ (count_upp (substring s index index))]))", "  (let loop ((i 0)\n           \
    \  (upper-case 0))\n    (cond ((or (not s) (< i 26)) 0)\n          ((char=? s\
    \ #\\a)\n           (loop (+ i 1)\n                 (+ upper-case 1)))\n     \
    \     ((char=? s #\\e)\n           (loop (+ i 2)\n                 (+ upper-case\
    \ 1)))\n          ((char=? s #\\i)\n           (loop (+ i 3)\n               \
    \  (+ upper-case 1)))\n          ((char=? s #\\o)\n           (loop (+ i 4)\n\
    \                 (+ upper-case 1))))\n    upper-case))\n", "  (define (count_upper-helper\
    \ s index count)\n    (cond\n      [(char=? s #\\A) (+ count 1)]\n      [else\
    \ (count_upper-helper (substring s (+ index 2)) #\\A count)]))\n  (count_upper-helper\
    \ s 0 0))\n", "  (if (string? s) (cond\n                     ((string? s)\n  \
    \                    (cond\n                         ((even? (string-length s))\
    \ (+ (char s 0) (char s 'A) \n                              (char s 'a) (char\
    \ s 'e) (char s 'i) (char s 'o) \n                              (char s 'u)))\n\
    \                         (else 0))\n                      (else 0))\n       \
    \              (else 0)))\n  0)\n", "  (cond\n    [(empty? s) 0]\n    [(even?\
    \ #xA) (+ 1 (string-length (substring s \"a\" #\"A\")))]\n    [else (+ 1 (string-length\
    \ (substring s \"b\" #\"B\")))]))\n", "  (cond (empty? s)\n        0\n       \
    \ (even? (modulo 26 (length s)) (modulo 26 (substring s 0 (length s)))\n     \
    \           (substring s 1 (length s)))\n        (odd? (modulo 26 (length s))\
    \ (modulo 26 (substring s 0 (length s)))\n                (substring s 1 (length\
    \ s)))\n        1\n        :default)))\n", "  (define vowels '(a e i o u y))\n\
    \  (define (count-upper s i n)\n    (cond\n      [(empty? s) n]\n      [(char=?\
    \ (first s) vowels) (count-upper (rest s) (+ i 2) n)]\n      [else (count-upper\
    \ (rest s) (+ i 1) (+ n 1))]))\n  (count-upper s 0 0))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? (length (rest s))) (add1 (count (eqv? #\\U (char s (- i (length\
    \ s)))))) \n    (count_upper (rest s))]))\n", "  (count (\u03BB (x)\n        \
    \    (and (char-upper? (char->integer x)) (even? (char-code x))))\n          (\u03BB\
    \ (x) (char-code x))))\n</code>\n<|/ a |>\n<| c |>\nOh that's nice, I thought\
    \ it would be some \"racket way\" to do it, but I just needed a pointer in the\
    \ right direction. Thanks!\n<|/ c |>\n<| c |>\nNote that this code only works\
    \ on ASCII-representable characters.  To make it work on all Unicode characters,\
    \ you should replace `char->integer` with `char->utf-digit->integer`\n<|/ c |>\n\
    <| c |>\nHmm I thought that would be true, however when I try to run it I get:\n\
    \nuser=> (count_upper \"\xE9\")\nERROR: char->integer: Invalid code point\n  arising\
    \ from the arithmetic for \"char-upper-code \" [...]\n<|/ c |>\n<| c |>\nYeah,\
    \ I realized that I'd made a mistake.  I've fixed it up and added a version that\
    \ works for Unicode characters now.\n<|/ c |>\n<| c |>\nWow, thank you! I wonder\
    \ why that wasn't stated in the book I'm reading about racket (I'm a first year\
    \ computer science student).\n<|/ c |>\n<| a dscore=1 tags=racket,scheme |>\n\
    You can do this with recursion.\n<code>", "  (let ([i (string-length s)])\n  \
    \  (cond [(even? i) 0]\n          [(and (= 0 (modulo i 2)) (char-upper? (substring\
    \ s i (+ i 1)))) 1]\n          [else 0])))\n", "  (let loop ((s s) (count 0) (vowels\
    \ '(A E I O U)))\n    (if (char-upper? s)\n        (loop (substring s 1 ) (+ count\
    \ (list->vector (chars-on s))))\n        0\n      )\n    ))\n", "  (let ((count\
    \ 0))\n    (lambda (x)\n      (if (even? x)\n          (set! count (inc! count))\n\
    \          count))))\n", "  (cond\n    [(null? s) 0]\n    [(even? (car s)) \n\
    \     (+ \n      (count_upper (cdr s)) \n      (if (char-upper? (car s)) 1 0))]\n\
    \    [else (count_upper (cdr s))]))\n", "  (define (helper s count)\n    (cond\
    \ ((null? s) count)\n          ((char=? (first s) #\\a)\n           (helper (rest\
    \ s) (add1 count)))\n          ((char=? (first s) #\\e)\n           (helper (rest\
    \ s) (add1 count)))\n          ((char=? (first s) #\\i)\n           (helper (rest\
    \ s) (add1 count)))\n          ((char=? (first s) #\\o)\n           (helper (rest\
    \ s) (add1 count)))\n          ((char=? (first s) #\\u)\n           (helper (rest\
    \ s) (add1 count)))\n          (else\n           (helper (rest s) count)))\n \
    \   (helper s 0))\n  \n  (helper s 0))\n", "  (if (string-empty? s)\n      0\n\
    \      (if (or (even? (string-length s) (modulo (string-length s) 2))\n      \
    \        (even? (string-length s) (modulo (string-length s) 3)))\n           (count_upper\
    \ \n            (substring s (quotient (string-length s) 2)\n                \
    \     (+ (quotient (string-length s) 2) 1))) \n           (count_upper \n    \
    \        (substring s (quotient (string-length s) 3)\n                     (+\
    \ (quotient (string-length s) 3) 1))))))\n", "  (cond ((empty? s) 0)\n       \
    \ ((char-upper? (car s)) (* (count_upper (cdr s)) 1))\n        (else (+ 1 (count_upper\
    \ (cdr s))))))\n", "  (let loop ([s (string->list s)] [n 0])\n    (cond [(empty?\
    \ s) n]\n          [(char=? (car s) #\\A) 1]\n          [(char=? (car s) #\\a)\
    \ 0]\n          [else (loop (cdr s) (+ n (count_upper (car s))))])))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nNice use of `loop`. It's not my usual approach, but\
    \ I think I like it. Your `loop` function has the advantage of not mutating the\
    \ global environment.\n<|/ c |>\n<| c |>\nIt does have the advantage of not mutating\
    \ the global environment, since the `loop` function is the one actually mutating\
    \ the global environment. Mutating the global environment is something that should\
    \ be avoided in any functional program. Plus, I think it's nice to see a functional\
    \ programming technique employed here.\n<|/ c |>\n<| a dscore=1 tags=scheme,racket\
    \ |>\nThe basic problem here is that the string returned by string->list is not\
    \ the string you think it is.  In particular, it's not a list at all.  Instead,\
    \ it is an interned string.  (See section 6.2.3 of the Racket Reference.)  So\
    \ when you call string->list on the string \"A\"\n<code>", "  (cond [(or (<= (length\
    \ s) 0) (= (length s) 1))\n         0]\n        [else\n         (cond\n      \
    \    [(or (eq? (char s 0 (+ 1 i)) (char-code (char s i)))\n             (eq? (char\
    \ s 1 (+ 1 i)) (char-code (char s i)))\n             (eq? (char s 2 (+ 1 i)) (char-code\
    \ (char s i)))\n             (eq? (char s 3 (+ 1 i)) (char-code (char s i)))\n\
    \             (eq? (char s 4 (+ 1 i)) (char-code (char s i)))\n             (eq?\
    \ (char s 5 (+ 1 i)) (char-code (char s i)))\n             (eq? (char s 6 (+ 1\
    \ i)) (char-code (char s i)))\n             (eq? (char s 7 (+ 1 i)) (char-code\
    \ (char s i)))\n             (eq? (char s 8 (+ 1 i)) (char-code (char s i)))\n\
    \             (eq? (char s 9 (+ 1 i)) (char-code (char s i)))\n             (eq?\
    \ (char s 10 (+ 1 i)) (char-code (char s i)))\n             (eq? (char s 11 (+\
    \ 1 i)) (char-code (char s i)))\n             (eq? (char s 12 (+ 1 i)) (char-code\
    \ (char s i)))\n             (eq? (char s 13 (+ 1 i)) (char-code (char s i)))\n\
    \             (eq? (char s 14 (+ 1 i)) (char-code (char s i)))\n             (eq?\
    \ (char s 15 (+ 1 i)) (char-code (char s i)))\n             (eq? (char s 16 (+\
    \ 1 i)) (char-code (char s i)))\n             (eq? (char s 17 (+ 1 i)) (char-code\
    \ (char s i)))\n             (eq? (char s 18 (+ 1 i)) (char-code (char s i)))\n\
    \             (eq? (char s 19 (+ 1 i)) (char-code (char s i)))\n             (eq?\
    \ (char s 20 (+ 1 i)) (char-code (char s i)))\n             (eq? (char s 21 (+\
    \ 1 i)) (char-code (char s i)))\n             (eq? (char s 22 (+ 1 i)) (char-code\
    \ (char s i)))\n             (eq? (char s 23 (+ 1 i)) (char-code (char s i)))\n\
    \             (eq? (char s 24 (+ ", "  (define (count i vowel)\n    (cond\n  \
    \    [(char=? vowel (code-char i)) (+ 1 vowel)]\n      [(char=? (code-char i)\
    \ 'A) (if (even? (+ i 1) vowel)\n                             (count (+ i 1) vowel)\n\
    \                             vowel)]\n      [(char=? (code-char i) 'a) (if (even?\
    \ (+ i 1) vowel)\n                             (count (+ i 1) vowel)\n       \
    \                      vowel)]\n      [(char=? (code-char i) 'B) (if (even? (+\
    \ i 1) vowel)\n                             (count (+ i 1) vowel)\n          \
    \                   vowel)]\n      [(char=? (code-char i) 'b) (if (even? (+ i\
    \ 1) vowel)\n                             (count (+ i 1) vowel)\n            \
    \                 vowel)]\n      [(char=? (code-char i) 'C) (if (even? (+ i 1)\
    \ vowel)\n                             (count (+ i 1) vowel)\n               \
    \              vowel)]\n      [(char=? (code-char i) 'c) (if (even? (+ i 1) vowel)\n\
    \                             (count (+ i 1) vowel)\n                        \
    \     vowel)]\n      [(char=? (code-char i) 'D) (if (even? (+ i 1) vowel)\n  \
    \                           (count (+ i 1) vowel)\n                          \
    \   vowel)]\n      [(char=? (code-char i) 'd) (if (even? (+ i 1) vowel)\n    \
    \                         (count (+ i 1) vowel)\n                            \
    \ vowel)]\n      [(char=? (code-char i) 'E) (if (even? (+ i 1) vowel)\n      \
    \                       (count (+ i 1) vowel)\n                             vowel)]\n\
    \      [(char=? (code-char i) 'e) (if (even? (+ i 1) vowel)\n                \
    \             (count (+ i 1) vowel)\n                             vowel)]\n  \
    \    [(char=? (code-char i) 'F) (if (even? (+ i 1) vowel)\n                  \
    \           (count (+ i 1) vowel)\n                             vowel)]\n    \
    \  [(char=? (code-char i) 'f) (if (even? (+ i 1) vowel)\n                    \
    \         (count (+ i 1) vowel)\n                             vowel)]\n      [(char=?\
    \ (code-char i) 'G) (if (even? (+ i 1) vowel)\n                             (count\
    \ (+ i 1) vowel)\n                             vowel)]\n      [(char=? (code-char\
    \ i) 'g) (if (even? (+ i 1) vowel)\n                             (count (+ i 1) ",
  "  (if (< s 0)\n      0\n      (count-upper-even (- s 1) (check-char #\\A) (check-char\
    \ #\\Z) 0 0)))\n", "  (cond ((null? s) 0)\n        ((char-upper? (first s) (first\
    \ s))\n         (count_upper (rest s))\n        )\n        (else (+ 1 (count_upper\
    \ (rest s))))\n))\n", "  (cond [(string=? s \"#t\") 1]\n        [(string=? s \"\
    #f\") 0]\n        [(odd? s) 0]\n        [(even? (string=? (substring s 0 (+ (length\
    \ s) (* 2 (length (substring s 'A 0))))) \"AaOo\")) 1]\n        [else 0]))", " \
    \ (cond [(empty? s) 0]\n        [(even? (length s)) (+ (char->int (car s)) (count_upper\
    \ (cdr s)))]\n        [else 0]))\n", "  (count_chars s '[AEIOUaeiou]' even))\n",
  "  (let loop ((s s)\n             (vowels '#(a e i o u))\n             (count 0))\n\
    \    (if (string-empty? s)\n        count\n        (loop (substring s 0 (length\
    \ s)) (append vowels (substring s 0 (length s))) (add1 count)))))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(even? (- count 0 s))\n     (if (= (% 2 s) 0)\n    \
    \    (+ count 1)\n        0)]\n    [else (count_upper rest)]))\n", "  (let ((n\
    \ 0))\n    (do\n      (define (helper char)\n        (if (char-upper? char)\n\
    \            (if (even? char) (add1 (add1 (add1 n)))\n              (helper (subchar\
    \ char 1))))\n        (helper (add1 char)))\n      (define i 0)\n      (while\
    \ ((< i (length s)))\n        (set! n (add1 n))\n        (set! i (add1 i)))))\n\
    \  n)\n", "  (if (empty? s)\n      0\n      (+ (car s)\n         (if (even? 0)\n\
    \             (count_upper (cdr s))\n             0))))\n", "  (cond [(string=?\
    \ s \"\")  0]\n        [(string=? s \"aA\")  1]\n        [(string=? s \"bB\")\
    \  1]\n        [(string=? s \"cC\")  1]\n        [(string=? s \"dD\")  1]\n  \
    \      [(string=? s \"eE\")  1]\n        [(string=? s \"fF\")  1]\n        [(string=?\
    \ s \"gG\")  1]\n        [(string=? s \"hH\")  1]\n        [(string=? s \"iI\"\
    )  1]\n        [(string=? s \"jJ\")  1]\n        [(string=? s \"kK\")  1]\n  \
    \      [(string=? s \"lL\")  1]\n        [(string=? s \"mM\")  1]\n        [(string=?\
    \ s \"nN\")  1]\n        [(string=? s \"oO\")  1]\n        [(string=? s \"pP\"\
    )  1]\n        [(string=? s \"qQ\")  1]\n        [(string=? s \"rR\")  1]\n  \
    \      [(string=? s \"sS\")  1]\n        [(string=? s \"tT\")  1]\n        [(string=?\
    \ s \"uU\")  1]\n        [(string=? s \"vV\")  1]\n        [(string=? s \"wW\"\
    )  1]\n        [(string=? s \"xX\")  1]\n        [(string=? s \"yY\")  1]\n  \
    \      [(string=? s \"zZ\")  1]\n        [(or (char-index-one? s #\\A) (char-index-one?\
    \ s #\\Z)) 0]\n        [(or (char-index-two? s #\\A) (char-index-two? s #\\Z))\
    \ 0]\n        [(or (char-index-three? s #\\A) (char-index-three? s #\\Z)) 0]\n\
    \        [(or (char-index-four? s #\\A) (char-index-four? s #\\Z)) 0]\n      \
    \  [(or (char-index-five? s #\\A) (char-index-five? s #\\Z)) 0]\n        [(or\
    \ (char-index-six? s #\\A) (char-index-six? s #\\Z)) 0]\n        [(or (char-index-seven?\
    \ s #\\A) (char-index-seven? s #\\Z)) 0]\n        [(or (char-index-eight? s #\\\
    A) (char-index-eight? s ", "  (cond [(zero? s) 0]\n        [(even? s)\n      \
    \   (add1 (count-vowels (substring s 0 (/ s 2)))))]))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(= (char s 0) #\\a) (add1 (count_upper (substring s 1)))]\n    [(=\
    \ (char s 0) #\\e) (add1 (count_upper (substring s 1)))]\n    [(= (char s 0) #\\\
    i) (add1 (count_upper (substring s 1)))]\n    [(= (char s 0) #\\o) (add1 (count_upper\
    \ (substring s 1)))]\n    [(= (char s 0) #\\u) (add1 (count_upper (substring s\
    \ 1)))]\n    [(= (char s 0) #\\U) (add1 (count_upper (substring s 1)))]\n    [else\
    \ (add1 (count_upper (substring s 1)))]))\n", "  (if (empty? s)\n      0\n   \
    \   (if (char=? (first s) 'a)\n          (1+ (count_upper (rest s))))\n      (if\
    \ (char=? (first s) 'e)\n          (1+ (count_upper (rest s))))\n      (if (char=?\
    \ (first s) 'i)\n          (1+ (count_upper (rest s))))\n      (if (char=? (first\
    \ s) 'o)\n          (1+ (count_upper (rest s))))\n      (if (char=? (first s)\
    \ 'u)\n          (1+ (count_upper (rest s))))))\n", "  (cond [(even? s) (count-vowels\
    \ (substring s 0 (- (length s) 2)))]\n        [else 0]))\n", "  (let loop ((s\
    \ s)\n             (counter 0))\n    (cond ((string=? s \"\") counter)\n     \
    \     ((string=? s \"a\" #\\a) (loop (cdr s) (add1 counter)))\n          ((string=?\
    \ s \"b\" #\\b) (loop (cdr s) (add1 counter)))\n          ((string=? s \"c\" #\\\
    c) (loop (cdr s) (add1 counter)))\n          ((string=? s \"d\" #\\d) (loop (cdr\
    \ s) (add1 counter)))\n          ((string=? s \"e\" #\\e) (loop (cdr s) (add1\
    \ counter)))\n          ((string=? s \"f\" #\\f) (loop (cdr s) (add1 counter)))\n\
    \          ((string=? s \"g\" #\\g) (loop (cdr s) (add1 counter)))\n         \
    \ ((string=? s \"h\" #\\h) (loop (cdr s) (add1 counter)))\n          ((string=?\
    \ s \"i\" #\\i) (loop (cdr s) (add1 counter)))\n          ((string=? s \"j\" #\\\
    j) (loop (cdr s) (add1 counter)))\n          ((string=? s \"k\" #\\k) (loop (cdr\
    \ s) (add1 counter)))\n          ((string=? s \"l\" #\\l) (loop (cdr s) (add1\
    \ counter)))\n          ((string=? s \"m\" #\\m) (loop (cdr s) (add1 counter)))\n\
    \          ((string=? s \"n\" #\\n) (loop (cdr s) (add1 counter)))\n         \
    \ ((string=? s \"o\" #\\o) (loop (cdr s) (add1 counter)))\n          ((string=?\
    \ s \"p\" #\\p) (loop (cdr s) (add1 counter)))\n          ((string=? s \"q\" #\\\
    q) (loop (cdr s) (add1 counter)))\n          ((string=? s \"r\" #\\r) (loop (cdr\
    \ s) (add1 counter)))\n          ((string=? s \"s\" #\\s) (loop (cdr s) (add1\
    \ counter)))\n          ((string=? s \"t\" #\\t) (loop (cdr s) (add1 counter)))\n\
    \          ((string=? s \"u\" #\\u) (loop (cdr s) (add1 counter)))\n         \
    \ ((string=? s \"v\" #\\v) (", "  (let ((count 0))\n    (for-each (lambda (c)\n\
    \                (when (and (oddp (char-code c)) (char-upper? (char-code c)))\n\
    \                  (set! count (incf count)))\n                (when (evenp count)\n\
    \                  (return count))\n              s)\n              )\n    count))\n",
  "  (define even-indices (make-array (/ s 2) #f))\n  (define count-upper (make-array\
    \ (/ s 2) #f))\n  (define i (- s 2))\n  (for ([i (in-range s)])\n    (when (even?\
    \ (remainder i 2))\n      (when (= (- i 2) 0)\n        (set! even-indices (- even-indices\
    \ (- i 2))) (set! count-upper (- count-upper 1))))\n    (set! count-upper (+ count-upper\
    \ (sub1 (char-case (char s i))))))\n  ;; If the string is null or length 0 or\
    \ s even, count is 0.\n  (when (or (null? s) (= s 0) (even? s))\n    (set! count-upper\
    \ (- count-upper 1))))\n  ;; Sort count-upper from largest to smallest and return\
    \ the value\n  (sort (- count-upper 1) < (lambda (a b) (> a b))))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(odd? (length s)) 0]\n    [(even? (length s)) (add1\
    \ (count (take-odd s)\n                                    (filter (lambda (c)\n\
    \                                               (equal? (char-code c) char-upper-case))\n\
    \                                       s))))]\n    [else (count_upper (rest s))]))\n",
  "  (let loop ((counts ()))\n    (if (empty? s)\n        (reverse counts)\n     \
    \   (let ((c (car s)))\n          (if (char-upper? c)\n              (loop (cons\
    \ c counts))\n              (loop (cons c counts))))))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(member (char-code (first (first (rest s))) 'a) '(A E I O U)) 1]\n\
    \    [else 0]))\n", "  (define vowels '([aAeEiIoOuU])) ;; vowels\n  (define odds\
    \ '([bBcCdD]))         ;; odds\n  (define odds-and-vowels '([bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTuUvVwWxXzZ]))\n\
    \  (define (odds-and-vowels-at-even i)\n    (cond\n      [(number? i) (cond\n\
    \                      [(even? i) vowels]\n                      [(odd? i) odds-and-vowels]])]\n\
    \      [else (error 'count-upper (symbol->string s))]))\n  (cond [(empty? s) 0]\n\
    \        [else (+ (length (remove-if-not (lambda (x) (eq? (first x) 'A) (odds-and-vowels-at-even\
    \ i))))\n               (length (remove-if-not (lambda (x) (eq? (first x) 'a)\
    \ (odds-and-vowels-at-even i))))]))\n", "  (if (empty? s)\n      0\n      (let\
    \ ((c (car s))\n            (n (length s)))\n        (if (even? n)\n         \
    \   (if (char-upper? c)\n                (+ 1 (count_upper (cdr s))))\n      \
    \      (count_upper (cdr s))))))\n", "  (cond [(empty? s) 0]\n        [(equal?\
    \ (char-value s) #\\a)  1]\n        [(equal? (char-value s) #\\e)  2]\n      \
    \  [(equal? (char-value s) #\\i)  3]\n        [(equal? (char-value s) #\\o)  4]\n\
    \        [(equal? (char-value s) #\\u)  5]\n        [else 0]))\n", "  (let ([i\
    \ 0]) (map (\u03BB (c) (if (or (char-upper? c) char-lower? (char-char-n? c))\n\
    \                             1\n                             (if (even? i)\n\
    \                                 (+ 1 (count_upper s))\n                    \
    \             (count_upper s))))\n                       (string->list s))))\n",
  "  (count_upper-helper (string-index s #\\A) 0 #\\a #\\b #\\c #\\d #\\e #\\f #\\\
    g #\\h))\n", "  (let loop ([count-evens 0]\n             [count-vowels 0])\n \
    \   (cond\n      [(empty? s) count-vowels]\n      [(char=? (first s) #\\a) count-vowels]\n\
    \      [(char=? (first s) #\\e) count-vowels]\n      [(char=? (first s) #\\i)\
    \ count-vowels]\n      [(char=? (first s) #\\o) count-vowels]\n      [(char=?\
    \ (first s) #\\U) count-vowels]\n      [(char=? (first s) #\\1) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\2) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\3) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\4) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\5) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\6) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\7) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\b) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\t) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\v) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\W) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\o) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\O) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\U) (loop (add1 count-evens)\
    \ (add1 count-vowels))]\n      [(char=? (first s) #\\v) (loop (add1 count", " \
    \ (let* ((i 0)\n         (count 0))\n    (for ([x s])\n      (when (char=? x 'A)\n\
    \        (set! i (+ i 1))\n        (set! count (+ count 1))\n        (when (even?\
    \ i)\n          (return count))))))\n", "  (cond\n    [(equal? s \"\") 0]\n  \
    \  [(equal? (char-code s) #\\a) 1]\n    [(equal? (char-code s) #\\b) 1]\n    [else\
    \ (+ 0 (count_upper (substring s 0 (quotient (length s) 2))))]))\n", "  (count-if\
    \ odd? s #\\U))\n", "  (cond [(empty? s) 0]\n        [(even? (string-length s))\n\
    \         (count_upper (substring s 0 2))\n         (count_upper (substring s\
    \ 2 4))\n         (count_upper (substring s 4 6))\n         (count_upper (substring\
    \ s 6 8))\n         (count_upper (substring s 8 10))]\n        [else 1]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(equal? (char-code (first s)) 97) (+ 1 (count_upper\
    \ (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (count_up_down (count_up_down_case\
    \ s) '()))\n", "  (cond [(null? s) 0]\n        [(zero? (remainder s (length s)))\
    \ 0]\n        [else (if (even? (remainder s (length s))) (add1 (count_upper (sub1\
    \ (length s))))\n                (count_upper (sub1 (length s)))]))\n", "  ;;\
    \ Odd indices represent uppercase vowels.\n  ;;\n  ;; (count_upper 'aBCdEf') returns\n\
    \  ;; (count_upper 'abcdefg') returns\n  ;; (count_upper 'dBBE') returns\n  ;;\
    \ Since even (index % 2) is 0, the even indices are vowels\n  ;; count_upper('aBCdEf')\
    \ returns\n  (let ((count 0))\n    (for-each (lambda (c)\n                (when\
    \ (zero? (modulo c 26))\n                  (set! count (add1 count))))\n     \
    \         s))\n  count)\n", "  (let ((i (in-range 0 (length s))))\n    (cond\n\
    \      ((= 0 (mod i (length #{'aEiuOYaeiouAEIOU})))\n       (string-length s))\n\
    \      ((string= (substring s (- 1 i)) #{'aEiuOYaeiouAEIOU})\n       (+ 1 (string-length\
    \ s)))\n      (else (count_upper s)))))\n", "  (cond\n    [(empty? s) 0]\n   \
    \ [(even? (car s)) (+ (count_upper (cdr s)) 1))]\n    [else (count_upper (cdr\
    \ s))]))\n", "  (cond\n    ((or (char=? #\\A s) (char=? #\\z s)) (add1 0))\n \
    \   ((or (char=? #\\A s) (char=? #\\e s)) (add1 1))\n    ((or (char=? #\\A s)\
    \ (char=? #\\I s)) (add1 2))\n    ((or (char=? #\\A s) (char=? #\\o s)) (add1\
    \ 3))\n    ((or (char=? #\\A s) (char=? #\\U s)) (add1 4))\n    ((or (char=? #\\\
    A s) (char=? #\\l s)) (add1 5))\n    ((or (char=? #\\A s) (char=? #\\L s)) (add1\
    \ 6))\n    ((or (char=? #\\A s) (char=? #\\0 s)) (add1 7))\n    ((or (char=? #\\\
    A s) (char=? #\\W s)) (add1 8))\n    ((or (char=? #\\A s) (char=? #\\Y s)) (add1\
    \ 9))\n    ((or (char=? #\\A s) (char=? #\\Z s)) (add1 10)\n    ((or (char=? #\\\
    A s) (char=? #\\A s)) (add1 11))\n    ((or (char=? #\\B s) (char=? #\\D s)) (add1\
    \ 12))\n    ((or (char=? #\\B s) (char=? #\\F s)) (add1 13))\n    ((or (char=?\
    \ #\\B s) (char=? #\\G s)) (add1 14))\n    ((or (char=? #\\B s) (char=? #\\H s))\
    \ (add1 15))\n    ((or (char=? #\\B s) (char=? #\\I s)) (add1 16))\n    ((or (char=?\
    \ #\\B s) (char=? #\\J s)) (add1 17))\n    ((or (char=? #\\B s) (char=? #\\K s))\
    \ (add1 18))\n    ((or (char=? #\\B s) (char=? #\\L s)) (add1 19))\n    ((or (char=?\
    \ #\\B s) (char=? #\\L s)) (add1 20))\n    ((or (char=? #\\B s) (char=? #\\N s))\
    \ (add1 21))\n    ((or (char=? #\\B s) (char=? #\\P s)) (add1 22))\n    ((or (char=?\
    \ #\\B s) (char=? #\\R ", "  (cond [(string=? (substring s 0 (substring s (char-code\
    \ (first s)) 0))\n                    \"AEIOU\")\n         (+ 1 (apply (lambda\
    \ (s) (count_upper s))\n                    (substring s 1 (char-code (first s)))))]\n\
    \        [else 0]))\n", "  (cond\n    [(empty? s) 0]\n    [(even? #n) (+ 1 (count_upper\
    \ (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (cond [(or (= 0 (mod\
    \ s (length s)))\n            (char-upper? s (string->list (car s))))\n      \
    \   0]\n        [else\n         (+ (char-upper? s (string->list (car s)))\n  \
    \          (count_upper (cdr s))]))\n", "  (cond\n    ((empty? s)\n     0)\n \
    \   ((char-uppercase? (car s))\n     (+ 1 (count_upper (cdr s))))\n    ((odd?\
    \ (car s))\n     (count_upper (cdr s)))\n    (else\n     (count_upper (cdr s)))))\n",
  "  (cond\n    ((or (char-upper? #\\a) (char-upper? #\\A)) (length s))\n    ((char-upper?\
    \ #\\a s) (length s))\n    ((char-upper? #\\A s) (length s))\n    (else 0)))\n",
  "  (cond\n    [(empty? s)        0]\n    [(even? (length s))\n     (cond\n     \
    \  [(char=? (first s) (first 'aAeEiIoOuU))\n        (cond\n         [(char=? (first\
    \ s) (first 'AaAeEiIoOuU)) (+ 1 0)]\n         [(char=? (first s) (first 'aAeEiIoOuU))\
    \ (+ 1 0)]\n         [(char=? (first s) (first 'AaAeEiIoOuU)) (+ 1 0)]\n     \
    \    [(char=? (first s) (first 'aAeEiIoOuU)) (+ 1 0)]\n         [else\n      \
    \    (+ 0 0)])]\n       [(char=? (first s) (first 'AaAeEiIoOuU)) (+ 1 0)]\n  \
    \     [else\n        (+ 0 0)]])]\n    [else\n      (+ 0 0)]))\n", "  (cond [(empty?\
    \ s)\n         0]\n        [(even? (length s))\n         (count_upper (substring\
    \ s 0 1))]\n        [else (+ (if (char=? #\\U (first s))\n                   \
    \ (+ 1 (count_upper (substring s 1)))\n                    (count_upper (substring\
    \ s 1)))]))\n", "  (let ([i 0])\n    (cond\n      [(string-empty? s) 0]\n    \
    \  [(char-upper? (car s) i) \n       (incf i (cdr s) s) (i (+ i 1))]\n      [else\
    \ 0])))\n", "  (cond\n    ((null? s) 0)\n    ((= (length s) 0)\n     (error \"\
    count_upper: empty string\"))\n    ((= (mod s 2) 0) 0)\n    ((char-upper? (car\
    \ s)) #t)\n    (else (count_upper (cdr s)))))\n  ", "  (count\n   (lambda (a b)\n\
    \     (when (odd? b)\n      (when (eqv? a #\\A) (return 1))\n      (when (eqv?\
    \ a #\\a) (return 1))\n      (when (eqv? a #\\U) (return 1))\n      (when (eqv?\
    \ a #\\u) (return 1))\n      (when (eqv? a #\\o) (return 1))))\n   (char-code\
    \ s)\n   (string-length s)))\n", "  (cond\n    [(empty? s) 0]\n    [(equal? (char-code\
    \ (car s)) 65)\n     (cond\n       [(even? (char-code (car s)) (car s)\n     \
    \         (char-code (cadr s)) (cadr s))\n        (+ (count-upper (cdr s)) (count-upper\
    \ (cdr s)))]\n       [else (count-upper (cdr s))])]\n    [else (count-upper (cdr\
    \ s))]))\n</cell>\n<cell>", "  (cond [(null? s) 0]\n        [(and (char= (char-code\
    \ (car s)) 65) (even? (char-code (car s))))\n         (+ (count_upper (cdr s))\
    \ (count (char 65)))]\n        [(and (char= (char-code (car s)) 97) (even? (char-code\
    \ (car s))))\n         (+ (count_upper (cdr s)) (count (char 97)))]\n        [else\n\
    \         (+ (count_upper (cdr s)) (count (char 97)))]))\n", "  (count (lambda\
    \ (c) (or (char-upper? (c))\n                      (even? (char-index (c) s))))\n\
    \          s))\n", "  (define (count_upper-aux\n           (s s)\n           (even-indices\
    \ s 0))\n    (cond\n      [(empty? s) 0]\n      [(odd? (car s)) (+ 1 (count_upper-aux\
    \ (cdr s) (add1 even-indices)))]\n      [else (count_upper-aux (cdr s) (add1 even-indices))]\n\
    \      )\n    )\n    (count_upper-aux s 0)\n    )\n", "  (cond [(= 0 (length s))\
    \ 0]\n        [(even? (modulo (length) 2) \n                (char->integer (string->character\
    \ (substring s 0 (length s)))))\n         (+ \n          (count_upper (substring\
    \ s 0 (length s))))]))\n", "  (cond\n    ((null? s) 0)\n    ((char-or-digit? s)\
    \ 0)\n    ((char-or-digit? (car s)) (count_upper (cdr s)))\n    (else (cond \n\
    \           ((or (char? (car s)) (char? (cadr s))) (count_upper (cdr s))) \n \
    \          ((char? (car s)) (count_upper (cdr s)))\n           (else (count_upper\
    \ (cdr s))))))))\n", "  (count_vowels s even?))\n", "  (cond\n    [(null? s) 0]\n\
    \    [(eqv? (char-code (car s)) (char-code (char-downcase (char-upcase (car s)))))\n\
    \     (add1 (count_upper (cdr s)))]\n    [else (count_upper (cdr s))]))\n", " \
    \ (let ([i s])\n    (if (empty? i)\n        0\n        (if (char-upper? i)\n \
    \           (+ 1 (count_upper (cdr i)))\n            (count_upper (cdr i))))))\n",
  "  (let ((count 0))\n    (for ((i (in-range 0 (length s)))\n          (j (in-range\
    \ 0 (length s)))\n          (a (in-range 0 (length s)))\n          (b (in-range\
    \ 0 (length s))))\n      (cond\n        ((and (number? (char-code (car s)) (char-code\
    \ (a) (in-range 0 i))))\n         (set! count (+ count (+ 1 (char-code (car s)))))\n\
    \         )\n        ((and (number? (char-code (car s)) (char-code (b) (in-range\
    \ 0 i))))\n         (set! count (+ count (+ 1 (char-code (car s)))))\n       \
    \  )\n        ((char-code (car s)) (char-code (a) (in-range 0 i)) (in-range 0\
    \ j) (in-range 0 j))\n        ((char-code (car s)) (char-code (b) (in-range 0\
    \ i)) (in-range 0 j) (in-range 0 j))\n        (else (error-expected-char))\n \
    \       )\n      )\n      count\n      )\n    )\n</code>\n<|/ q tags=racket,scheme\
    \ |>\n<| a dscore=0 |>\nYou can use the built-in char-code function:\n<code>",
  "  (let ((count 0))\n    (for ([i (in-range (length s))])\n      (cond\n       \
    \ ((char-upper? (char (substring s i i)))\n          (set! count (+ count 1)))\n\
    \        (else (set! count 0)))))\n  count)\n", "  (count_vowels s #\\V))\n",
  "  (count\n   (lambda(x y)\n      (cond\n        ((zero? (remainder x 26)) 1)\n\
    \        ((zero? (remainder y 26)) 0)\n        (else (and (char=? (char-value\
    \ x) (char-value y)) (count_upper (char-code x)) (count_upper (char-code y)))))))\n\
    \  s)\n", "  (if (null? s) 0)\n  (let ((result (+ (if (even? (remainder s 2))\
    \ 1 0) (if (char=? s #\\V) (if #t\n                                          \
    \                      (if (char=? s #\\e)\n                                 \
    \                                (if (char=? s #\\i)\n                       \
    \                                              (if (char=? s #\\o)\n         \
    \                                                                (if (char=? s\
    \ #\\u)\n                                                                    \
    \       (if (char=? s #\\a)\n                                                \
    \                             (if (char=? s #\\L)\n                          \
    \                                                     (if (char=? s #\\P)\n  \
    \                                                                            \
    \ (if (char=? s #\\F)\n                                                      \
    \                             (if (char=? s #\\z)\n                          \
    \                                                         0))))))))))))\n    (set!\
    \ result (- result result)))\n  result)\n", "  (cond\n    [(empty? s) 0]\n   \
    \ [(even? (string-length s)) (count_upper_1 (substring s 0 (string-length s))))]\n\
    \    [else (count_upper_1 (substring s 0 (string-length s))))]))\n", "  (let loop\
    \ ((c 'a)\n             (count 0))\n    (if (string-empty? s)\n        count\n\
    \        (loop (char c)\n              (if (char-upper? c)\n                 \
    \ (loop (char c)\n                        (add1 count))\n                  count)))))\n",
  "  (let ((count 0))\n    (do-chars\n       ([c c]\n        (if (char=? c #\\V)\n\
    \            (if (even? i)\n                (set! count (add1 count))\n      \
    \        (do-chars ([c c]) (set! count 0)))\n          (do-chars ([c c])\n   \
    \         (set! count 0)))\n      (add! count 1)))\n    count)\n", "  (define\
    \ (helper! n s)\n    (if (null? s)\n        n\n        (helper! (+ n 1) (substring\
    \ s 0 (+ n 1)))))\n  (helper! 0 (string->list s))))\n", "  (local\n    [(define\
    \ (even? i)\n      (= (remainder i 2) 0))]\n    (count\n     (for [i (in-range\
    \ (length s))]\n       (when (even? i)\n         (char-uppercase (car s) i)))))\n\
    </code>\n<|/ a |>\n<| a |>\nHere is a solution that doesn't use any high-level\
    \ constructs such as lambda, cond, or local like suggested. It uses simple recursion\
    \ instead:\n<code>", "  (if (null? s) 0\n      (if (char-upper? (car s))\n   \
    \       (+ 0 (count_upper (cdr s)))))\n      )", "  (cond\n    [(empty? s) 0]\n\
    \    [else (+ (if (char= (char-at (+ s (- n 'a)) 'A) 'aA) 1)\n               \
    \    (count_upper (substring s 0 (+ s (- n 'a)))])]))\n", "  (let loop ((s s)\n\
    \             (count 0))\n    (if (eq? s \"\")\n        count\n        (loop (substring\
    \ s 0 (string->length s))\n              (add1 count)))))\n", "  (cond (empty?\
    \ s) 0\n        (string? (first s)) 0\n        (cons? s)\n        (even? (second\
    \ s)) (count_upper (rest s))\n        (else       (count_upper (rest s)))))\n",
  "  (let ((count 0))\n    (loop for i from 0 to (string-length s) step 2\n      \
    \   collect (if (char-upper? (substring s i i)) (add1 count)))\n    count))\n",
  "  (cond\n    [(empty? s) 0]\n    [(pair? s)\n     (cond\n       [(even? ?a) (+\
    \ (car s?a) (count_upper (cdr s?a)))]\n       [(even? ?e) (+ (car s?e) (count_upper\
    \ (cdr s?e)))]\n       [(even? ?i) (+ (car s?i) (count_upper (cdr s?i)))]\n  \
    \     [(even? ?o) (+ (car s?o) (count_upper (cdr s?o)))]\n       [(even? ?u) (+\
    \ (car s?u) (count_upper (cdr s?u)))]\n       [(even? ?y) (+ (car s?y) (count_upper\
    \ (cdr s?y)))]\n       [else (count_upper s?s)]))]\n    [else (count_upper s?s)]))\n",
  "  (define count 0)\n  (define i 0)\n  (while [i]\n  (when (char-upper? s[i] #\\\
    a)\n    (set! i (+ i 2))\n    (set! count (+ count 1)))\n  (when (char-upper?\
    \ s[i] #\\e)\n    (set! i (+ i 1))\n    (set! count (+ count 1)))\n  (set! i (+\
    \ i 1)))\n  count)\n", "  (let loop ([i 0] [evens 0])\n    (if (< i (string-length\
    \ s))\n        (loop (+ i 1) (+ evens (string=? (char-code (char s i)) #\\A)\n\
    \                          (string=? (char-code (char s i)) #\\e)\n          \
    \                (string=? (char-code (char s i)) #\\i)))\n        evens)))\n",
  "  (reverse (count-if #(= (car %) 'A) (reverse s))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? 0) 0]\n    [(equal? s (substring s 0 2)) (+ 1 (count_upper\
    \ s (+ 3 1)))]\n    [else 0]))\n", "  (let ((vowels '(#\\a #e #i #o #u)))\n  \
    \  (cond [(or (char->integer (car s)) (char->integer #\\newline)\n           \
    \  (char->integer #\\tab) (char->integer #\\newline))\n           0]\n       \
    \   [(member #\\a vowels)\n           (+ (char->integer (car s)) 1)]\n       \
    \   [else\n           (+ (char->integer (car s)) 0)]\n          [else (count_upper\
    \ (cdr s))])))\n", "  (cond [(= (length s) 0) 0]\n        [(= (mod s 2) 0) 1]\n\
    \        [else (+ 1 (count_upper (substring s 0 (+ 0 (mod s (length s))))))]))\n",
  "  (letrec ([count_upper-aux\n            (lambda (s i)\n              (cond ((char-upper?\
    \ s i) (add1 i))\n                    ((eq? i 0) 0)\n                    (else\
    \ (count_upper-aux (substring s i) (i-1)))))]\n           [count_upper-loop\n\
    \            (lambda (s i)\n              (count_upper-aux s i) (add1 i))])\n\
    \    (count_upper-loop s 0)))\n", "  (define even (substring s 0 2))\n  (define\
    \ odd (substring s 2 4))\n  (cond [(null? s)\n         0]\n        [(even? (car\
    \ even))\n         (+ 0 (count_upper (cdr even)))]\n        [(odd? (car odd))\n\
    \         (+ 1 (count_upper (cdr odd)))]))\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    A variation of the answer posted by.\n<code>", "  (cond\n    [(null? s) 0]\n \
    \   [(equal? (car s) #\\A)\n     (+ (count_upper (cdr s)) #\\A)]\n    [(equal?\
    \ (car s) #\\z)\n     (+ (count_upper (cdr s)) #\\z)]\n    [else\n     (+ (count_upper\
    \ (cdr s)) (car s))]\n    ))\n", "  (let loop ([s s])\n    (cond\n      [(empty?\
    \ s)\n       (length (string->list s))]\n      [(string=? s (string-ref s 0 1\
    \ :end))\n       (let ([i 1]) (loop s))]\n      [(string=? (string-ref s 0 1 :end)\
    \ s)\n       (+ i (string-length (string-ref s 0 1 :end)))]\n      [else\n   \
    \    (let ([i 0]) (loop s))]))))\n", "  (regexp-replace s '[AEIOUaeiou]([aeiouy])'\
    \ '($1+1)' 1))\n", "  ;; count each uppercase vowel\n  (let loop ((c 0)\n    \
    \         (uppers '()))\n    (cond ((char-not (char s c)) c)\n          (else\
    \ (loop (+ c 1) (cons c uppers)))))\n  ;; count odd indices as well\n  (let loop\
    \ ((c 0)\n             (uppers '()))\n    (cond ((char-not (char s c)) c)\n  \
    \        (else (loop (+ c 1) (cons c uppers)))))\n  0)\n", "  (- (length s) (/\
    \ (- (modulo (length s) 2) 2) ((length s) 2)))\n)\n", "  (count\n   (lambda (c)\n\
    \     (or (char-upper? (c) (cdr (cdr s)))\n          (char-upper? (c) (cons (c)\
    \ (cons (c) '())))\n          (char-upper? (c) (cons (c) (cons (c) (cons (c) '()))))))\n\
    \   '() s))\n", "  (cond\n    [(empty? s) 0]\n    [(even? (car s)) (+ 1 (count_upper\
    \ (cdr s)))]))\n", "  (define (count_vowels s)\n    (define (helper char vowels\
    \ count)\n      (cond\n        [(equal? (char-alphabetic char) vowels) count]\n\
    \        [else (helper (cdr char) (cons (char-alphabetic char) vowels) (+ count\
    \ 1))]))\n    (helper s #f 0))\n  (count_vowels s))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? (car s)) (add1 (count_upper (cdr s))) ]\n    [else (count_upper\
    \ (cdr s)) ] ) )\n", "  (let loop ((i 0)\n             (cnt 0))\n    (if (null?\
    \ s)\n        cnt\n        (loop (+ i 2) (if (char=? (first s) (char 65) ) (inc\
    \  cnt) )))))\n", "  (let ((count 0))\n    (loop\n       for i from 0 to (length\
    \ s)\n       for c from (substring s i i) downto 'z'\n       when (char-upper?\
    \ (char c))\n       do (set! count (+ count 1)))\n    count))\n", "  (let ((count\
    \ 0))\n    (for ([i (in-range (length s)))\n          (if (char=? (char-code (char\
    \ s i)) #\\A)\n              (if (char=? (char-code (char s i)) #\\E)\n      \
    \            (if (char=? (char-code (char s i)) #\\V)\n                      (add1\
    \ (add1 count))\n                      count)\n                  count)\n    \
    \          count)\n          count)\n    count))\n", "  (cond ( (empty? s) #f\
    \ )\n        ( (equal? (char-code (car s)) (char-code (upcase (cadr s))) ) 1 (+\
    \ 0 (count_upper (cdr s))) )\n        (else (count_upper (cdr s)))))\n", "  (if\
    \ (= (length s) 0)\n      0\n      (+ (/ (modulo 26 (substring s 0 1))) 2\n  \
    \       (/ (modulo 26 (substring s 1 2))) 2\n         (/ (modulo 26 (substring\
    \ s 2 3))) 2\n         (/ (modulo 26 (substring s 3 4))) 2\n         (/ (modulo\
    \ 26 (substring s 4 5))) 2\n         (/ (modulo 26 (substring s 5 6))) 2\n   \
    \      (/ (modulo 26 (substring s 6 7))) 2\n         (/ (modulo 26 (substring\
    \ s 7 8))) 2\n         (/ (modulo 26 (substring s 8 9))) 2\n         (/ (modulo\
    \ 26 (substring s 9 10))) 2\n         (/ (modulo 26 (substring s 10 11))) 2\n\
    \         (/ (modulo 26 (substring s 11 12))) 2\n         (/ (modulo 26 (substring\
    \ s 12 13))) 2\n         (/ (modulo 26 (substring s 13 14))) 2\n         (/ (modulo\
    \ 26 (substring s 14 15))) 2\n         (/ (modulo 26 (substring s 15 16))) 2\n\
    \         (/ (modulo 26 (substring s 16 17))) 2\n         (/ (modulo 26 (substring\
    \ s 17 18))) 2\n         (/ (modulo 26 (substring s 18 19))) 2\n         (/ (modulo\
    \ 26 (substring s 19 20))) 2\n         (/ (modulo 26 (substring s 20 21))) 2\n\
    \         (/ (modulo 26 (substring s 21 22))) 2\n         (/ (modulo 26 (substring\
    \ s 22 23))) 2\n         (/ (modulo 26 (substring s 23 24))) 2\n         (/ (modulo\
    \ 26 (substring s 24 25))) 2\n         (/ (modulo 26 (substring s 25 26))) 2\n\
    \         (/ (modulo 26 (substring s 26 27))) 2\n         (/ (modulo 26 (substring\
    \ s 27 28))) 2\n         (/ (modulo 26 (substring s 28 29))) 2\n         (/ (modulo\
    \ 26 (substring s 29 30))) 2\n         (/ (modulo 26 (substring s 30 31))) 2\n\
    \         (/ (modulo 26 (substring s 31 32))) 2\n         (/ (modulo 26 (substring\
    \ s 32 33))) 2\n         (/ (modulo 26 (substring s 33 34))) 2\n", "  (cond\n\
    \    ((null? s) 0)\n    ((equal? (car s) 'A) 0)\n    ((equal? (car s) 'B) 0)\n\
    \    ((equal? (car s) 'C) 0)\n    ((equal? (car s) 'D) 0)\n    ((equal? (car s)\
    \ 'E) 1)\n    ((equal? (car s) 'F) 0)\n    ((equal? (car s) 'G) 0)\n    ((equal?\
    \ (car s) 'H) 0)\n    ((equal? (car s) 'I) 0)\n    ((equal? (car s) 'J) 0)\n \
    \   ((equal? (car s) 'K) 0)\n    ((equal? (car s) 'L) 0)\n    ((equal? (car s)\
    \ 'M) 0)\n    ((equal? (car s) 'N) 0)\n    ((equal? (car s) 'O) 0)\n    ((equal?\
    \ (car s) 'P) 0)\n    ((equal? (car s) 'Q) 0)\n    ((equal? (car s) 'R) 0)\n \
    \   ((equal? (car s) 'S) 0)\n    ((equal? (car s) 'T) 0)\n    ((equal? (car s)\
    \ 'U) 0)\n    ((equal? (car s) 'V) 0)\n    ((equal? (car s) 'W) 0)\n    ((equal?\
    \ (car s) 'X) 0)\n    ((equal? (car s) 'Y) 0)\n    ((equal? (car s) 'Z) 0)\n \
    \   ((equal? (car s) 'a) 0)\n    ((equal? (car s) 'b) 0)\n    ((equal? (car s)\
    \ 'c) 0)\n    ((equal? (car s) 'd) 0)\n    ((equal? (car s) 'e) 1)\n    ((equal?\
    \ (car s) 'f) 0)\n    ((equal? (car s) 'g) 0)\n    ((equal? (car s) 'h) 0)\n \
    \   ((equal? (car s) 'i) 0)\n    ((equal? (car s) 'j) 0)\n    ((equal? (car s)\
    \ 'k) 0)\n    ((equal? (car s) 'l) 0)\n    ((equal? (car s) 'm) 0)\n    ((equal?\
    \ (car s) 'n) 0)\n    ((equal? (car s) 'o) 0)\n    ((equal? (car s) 'p) 0)\n \
    \   ((equal? (car s) 'q) 0)\n    ((equal? (car s) 'r) 0)\n    ((equal? (car s)\
    \ 's) 0)\n    ((equal? (car s) 't) 0)\n    ((equal", "  (count_chars s #{\\Aa\\\
    Ee\\Ii\\Oo\\Uu} #{\\a\\e\\i\\o\\u}))\n</code>\n<code>", '  (count_upper_aux (make-list
    length s) #f #f #f #f #f))', "  (let ([i 0])\n    (if (< i 3)\n        (if (char-upper?\
    \ (char-code (char s i)))\n            (+ 1)\n          0)\n      (count_upper\
    \ (char s i)))))\n", "  (let loop ([s s])\n    (if (empty? s) 0\n        (if (=\
    \ (char s 0) #\\A) (if (even? 0) 0 (+ 1 (loop (cdr s))))\n            (if (even?\
    \ (char s 0)) 0 (+ 1 (loop (cdr s))))))))\n", "  (cond\n    [(empty? s) 0]\n \
    \   [(equal? (char->integer #\\a) 0) 1]\n    [else (+ 1 (count_upper (rest s))))))\n",
  "  (cond\n    ((null? s) 0)\n    ((string= (first s) \"A\") 2)\n    ((string= (first\
    \ s) \"O\") 2)\n    ((string= (first s) \"E\") 2)\n    ((string= (first s) \"\
    I\") 2)\n    ((string= (first s) \"U\") 2)\n    ((string= (first s) \"a\") 2)\n\
    \    ((string= (first s) \"o\") 2)\n    ((string= (first s) \"e\") 2)\n    ((string=\
    \ (first s) \"i\") 2)\n    ((string= (first s) \"u\") 2)\n    ((string= (first\
    \ s) \"A\") 2)\n    ((string= (first s) \"O\") 2)\n    ((string= (first s) \"\
    E\") 2)\n    ((string= (first s) \"I\") 2)\n    ((string= (first s) \"U\") 2)\n\
    \    ((string= (first s) \"a\") 2)\n    ((string= (first s) \"o\") 2)\n    ((string=\
    \ (first s) \"e\") 2)\n    ((string= (first s) \"i\") 2)\n    ((string= (first\
    \ s) \"u\") 2)\n    ((string= (first s) \"A\") 2)\n    ((string= (first s) \"\
    O\") 2)\n    ((string= (first s) \"E\") 2)\n    ((string= (first s) \"I\") 2)\n\
    \    ((string= (first s) \"U\") 2)\n    ((string= (first s) \"a\") 2)\n    ((string=\
    \ (first s) \"o\") 2)\n    ((string= (first s) \"e\") 2)\n    ((string= (first\
    \ s) \"i\") 2)\n    ((string= (first s) \"u\") 2)\n    ((string= (first s) \"\
    A\") 2)\n    ((string= (first s) \"O\") 2)\n    ((string= (first s) \"E\") 2)\n\
    \    ((string= (first s) \"I\") 2)\n    ((string= (first s) \"U\") 2)\n    ((string=\
    \ (first s) \"a\") 2)\n    ((string= (first s) \"o\") 2)\n    ((string= (first\
    \ s) \"e\") 2)\n    ((string= (first s) \"i\") 2)\n    ((string= (first s) \"\
    u\") 2)\n    ((string= (first s) \"A\") 2)\n    ((string= (first s) \"O\") 2)\n\
    \    ((string= (first s) \"E\") 2)\n    ((string= (first s) \"I\") 2)\n    ((string=\
    \ (first s) \"U\") 2)\n    ((string= (first s) \"a", "  (cond\n    [(equal? s\
    \ \"\") 0]\n    [(odd? s) 0]\n    [(equal? (first s) \"A\") 1]\n    [(equal? (first\
    \ s) \"E\") 2]\n    [(equal? (first s) \"I\") 3]\n    [(equal? (first s) \"O\"\
    ) 4]\n    [(equal? (first s) \"U\") 5]\n    [else (+ 1 (count_upper (rest s)))]))\n",
  "  (let ([vowels 'aeiouAEIOU])\n    (cond\n      [(char-ci=? s #\\a) (+ 1 (member\
    \ (char-ci s) vowels))]\n      [(char-ci=? s #\\b) (+ 1 (member (char-ci s) vowels))]\n\
    \      [(char-ci=? s #\\c) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=?\
    \ s #\\d) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=? s #\\e) (+ 1 (member\
    \ (char-ci s) vowels))]\n      [(char-ci=? s #\\f) (+ 1 (member (char-ci s) vowels))]\n\
    \      [(char-ci=? s #\\g) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=?\
    \ s #\\h) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=? s #\\i) (+ 1 (member\
    \ (char-ci s) vowels))]\n      [(char-ci=? s #\\j) (+ 1 (member (char-ci s) vowels))]\n\
    \      [(char-ci=? s #\\k) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=?\
    \ s #\\l) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=? s #\\n) (+ 1 (member\
    \ (char-ci s) vowels))]\n      [(char-ci=? s #\\o) (+ 1 (member (char-ci s) vowels))]\n\
    \      [(char-ci=? s #\\p) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=?\
    \ s #\\q) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=? s #\\r) (+ 1 (member\
    \ (char-ci s) vowels))]\n      [(char-ci=? s #\\s) (+ 1 (member (char-ci s) vowels))]\n\
    \      [(char-ci=? s #\\t) (+ 1 (member (char-ci s) vowels))]\n      [(char-ci=?\
    \ s #\\v) (+ 1 (member (char-ci s) vowels))]\n      [else ", "  (cond [(or (=\
    \ (length s) 0)\n           (string=? (char->string s) '#\\a))\n         (length\
    \ s)]\n        [(or (= (length s) 0)\n             (char->string\n           \
    \    (subseq-of s 0 (modulo (length s) 2))\n               '#\\a))\n         (length\
    \ s)]\n        [else\n         (cond [(= (length s) 0)\n               (length\
    \ s)]\n               [else\n               (let ([letters (string->list s)])\n\
    \                 (cond [(or\n                          (string=? (substring letters\
    \ 0 (modulo letters (length s)) '#\\A)\n                                    '#\\\
    A)\n                          (empty? letters)]\n                       [else\n\
    \                         (+ 0 (count letters '#\\A)))]\n                    \
    \   [else\n                         (cond [(= (length letters) 1)\n          \
    \                     (length letters)]\n                               [else\n\
    \                               (cond [(string=? (substring letters 0 1 '#\\A)\n\
    \                                            '#\\A)\n                        \
    \            (empty? letters)\n                                    (count letters\
    \ '#\\A)]\n                                   [else\n                        \
    \            (let ([letters (string->list (substring letters 1 length)))])\n \
    \                                     (cond [(or\n                           \
    \                      (string=? (substring letters 0 (modulo letters (length\
    \ s)) '#\\A)\n                                                  '#\\A)\n     \
    \                                            (empty? letters)]\n             \
    \                                  [else\n                                   \
    \              (+ 0 (count letters '#\\A)))]\n                               \
    \                [else\n                                                 (cond\
    \ [(= (length letters) 1)\n                                                  \
    \    (length letters)]\n                                                     [else\n\
    \                                                      (count letters '#\\A)])])]))])))])))\n",
  "  (if (= 0 (length s))\n      0\n      (let ([count-vowels (make-hash)])\n    \
    \    (hash-update! count-vowels (substring s 0 (modulo s (length s))) (modulo\
    \ (char-code (char s (modulo s (length s))) 65)))\n        (hash-update! count-vowels\
    \ (substring s 1 (modulo s (length s))) (modulo (char-code (char s (modulo s (length\
    \ s))) 97)))\n        (values (- 1 (hash-ref count-vowels 'a)) (hash-ref count-vowels\
    \ 'b) (hash-ref count-vowels 'c) (hash-ref count-vowels 'd) (hash-ref count-vowels\
    \ 'e) (hash-ref count-vowels 'f)))))\n", "  (cond\n    [(empty? s) 0]\n    [(eq?\
    \ (first (rest (rest s))) ?V) 1]\n    [else 0]))\n", "  (cond\n    [(empty? s)\
    \ 0]\n    [else\n     (cond\n       [(char=? (first s) 'A) (+ 1 (count_upper rest))]\n\
    \       [else (count_upper rest)]\n     )]\n   ))\n", "  (cond\n    [(empty? s)\
    \ 0]\n    [(even? ?x) (inc (in-range ?x ?x (char-value ?o)))]\n    [else (inc\
    \ (in-range ?x ?x #\\E))]))\n", "  (cond\n    [(empty? s) 0]\n    [(not (even?\
    \ (car s))) (+ (car s) count_upper (cdr s))]\n    [else (count_upper (cdr s))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(even? index) (add1 (count_vowels (substring\
    \ s index)))]\n    [else 0]))\n", "  (if (null? s)\n      '()\n      (if (even?\
    \ (modulo 1 (length s))) \n          (+ 1 (count_upper (substring s 0 (- 2 (length\
    \ s))))) \n          (count_upper (substring s 0 (- 1 (length s)))))))\n", " \
    \ ;; (count s #\\A)\n  (match s\n    ([#\\A] 1)\n    (([#\\A #\\B #\\C #\\D #\\\
    E #\\F #\\G #\\H #\\I #\\J \n      #\\K #\\L #\\M #\\N #\\O #\\P #\\Q #\\R #\\\
    S #\\T #\\U #\\V \n      #\\W #\\X #\\Y #\\Z] 2)\n    ([#\\A #\\B #\\C #\\D #\\\
    E #\\F #\\G #\\H #\\I #\\J \n      #\\K #\\L #\\M #\\N #\\O #\\P #\\Q #\\R #\\\
    S #\\T #\\U #\\V \n      #\\W #\\X #\\Y #\\Z | #\\a #\\b #\\c #\\d #\\e #\\f #\\\
    g] 0)\n    ([#\\a #\\b #\\c #\\d #\\e #\\f #\\g | #\\A] 1)\n    ((#\\A | #\\a)\
    \ 1)\n    ((#\\A | #\\b) 1)\n    ((#\\A | #\\C) 1)\n    ((#\\A | #\\D) 1)\n  \
    \  ((#\\A | #\\E) 1)\n    ((#\\A | #\\F) 1)\n    ((#\\A | #\\G) 1)\n    ((#\\\
    A | #\\H) 1)\n    ((#\\A | #\\I) 1)\n    ((#\\A | #\\J) 1)\n    ((#\\A | #\\K)\
    \ 1)\n    ((#\\A | #\\L) 1)\n    ((#\\A | #\\M) 1)\n    ((#\\A | #\\N) 1)\n  \
    \  ((#\\A | #\\O) 1)\n    ((#\\A | #\\P) 1)\n    ((#\\A | #\\Q) 1)\n    ((#\\\
    A | #\\R) 1)\n    ((#\\A | #\\S) 1)\n    ((#\\A | #\\T) 1)\n    ((#\\A | #\\U)\
    \ 1)\n    ((#\\A | #\\V) 1)\n    ((#\\A | #\\W) 1)\n    ((#\\A | #\\X) 1)\n  \
    \  ((#\\A | #\\Y) 1)", "  (if (<= (length s) 0)\n      0\n      (if (even? (remainder\
    \ s 2)) (add1 (count_vowels (rest s))))\n      (count_upper s)))\n", "  (foldr\
    \ (lambda (c i)\n           (if (even? i)\n               (if (char=? c #\\A)\n\
    \                   (+ 1 (if (char=? c #\\A)\n                             (+\
    \ 1 (if (char=? c #\\W)\n                                     (+ 1 (if (char=?\
    \ c #\\D)\n                                            0\n                   \
    \                         1))))))\n               0))\n         '()\n        \
    \ s))\n", "  ;; Write code here.\n  ;; Hint: Use \"count\" function.\n  (define\
    \ (even n)\n    (= n 2))\n  (define (odd n)\n    (= n 3))\n  (count s even))",
  "  (cond\n    [(empty? s) 0]\n    [(= 0 (remainder s (first s))) 1]\n    [else (+\
    \ (count_upper (rest s)) (first (rest s))))]))\n", "  (regexp-opt (match [_ aA\
    \ aE aI aO aU aY] [\\yy \\yA \\yE \\yI \\yO \\yU \\yY]) s))\n", "  (cond\n   \
    \ [(or (char-equal s '()) (string-length s)) 0]\n    [(and (char-equal (char-at\
    \ (car s) 0) #\\A)\n           (char-equal (char-at (car s) 0) #\\O)) (+ 1 (count_upper\
    \ (cdr s)))]\n    [else (count_upper (cdr s))]))\n", "  (define (c-count s)\n\
    \    (cond\n      [(empty? s) 0]\n      [(char= (char-downcase (first s)) (char-downcase\
    \ 'a)) 1])\n    (cond [(zero? l) (+ (c-count (rest s)) 1) (rest s)]\n        \
    \  [(char= (char-downcase (first s)) (char-downcase 'a)) (c-count (rest s))]))\n\
    \  (c-count s))\n", "  (cond\n    ((empty? s) 0)\n    ((char=? s (char-code #\\\
    A)) 2)\n    ((char=? (char-code s) #\\a) (add1 (count_upper (cdr s))))\n    (else\
    \ (add1 (count_upper (cdr s))))))\n", "  (let loop ((s s)\n             (counts\
    \ 0))\n    (if (string? s)\n        (if (char? (car s))\n            (if (char=?\
    \ (car s) #\\A)\n                (loop (cdr s) (+ counts 1)))\n            (if\
    \ (char=? (car s) #\\z)\n                (loop (cdr s) (+ counts 0)))\n      \
    \      (loop (cdr s) counts))\n        counts)))\n", "  (cond ((zero? s) 0)\n\
    \        ((char-lower? (car s)) 1)\n        (else (+ 1 (count_upper (cdr s))))))\n\
    </code>\n<|/ a tags=racket,scheme,racket-student-languages dscore=0 |>\n<| a tags=racket,scheme,racket-student-languages\
    \ |>\n<code>", "  (define (even-indices s)\n    (cond\n      [(empty? s) 0]\n\
    \      [else (even-indices\n                (substring s (modulo s (length s))\
    \ 1))]))\n  (define (even-indices-? s)\n    (cond\n      [(empty? s) false]\n\
    \      [(or (char=? (char-code s) #\\a)\n           (char=? (char-code s) #\\\
    e))\n        (even-indices? s)]\n      [else true]))\n  (define (even-indices-plus-count\
    \ s)\n    (cond\n      [(empty? s) 0]\n      [(even-indices-? s)\n       (+ (even-indices-plus-count\n\
    \           (substring s (modulo s (length s)) 1))\n          1)]\n      [else\
    \ (even-indices-plus-count\n              (substring s (modulo s (length s)) 1))]))\n\
    \  (even-indices-plus-count s))\n", "  (cond\n    [(empty? s) 0]\n    [(even?\
    \ 0) 0]\n    [else (+ 1 ((list-ref s 0 #\\a) (list-ref s 1 #\\u)))]))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(even? (char-code (car s)) (char-code (upper-case-code\
    \ (car s))))\n     (+ 1 (count_upper (cdr s)))]))\n", "  (if (null? s) 0\n   \
    \   (if (even? (length s))\n          (if (char-upper? (car s))\n            \
    \  (+ (count_upper (cdr s)) 1)\n              (count_upper (cdr s)))\n       \
    \   (count_upper (cdr s)))))\n</code>\n<|/ a dscore=2 |>\n<| a tags=recursion,scheme,lisp\
    \ |>\nAs a homework question, try the following:\n<code>", "  (cond [(= 0 (string-length\
    \ s)) (error '()) 1]\n        [(even? (string-index s #\\a)) (+ 1 (count_upper\
    \ (string-tail s)))]\n        [else (count_upper (string-tail s))]))\n", "  (let\
    \ loop ((s s)\n             (i 0)\n             (count 0))\n    (cond ((char=?\
    \ s #\\A) (set! count 1) (loop (substring s i) (incf i) count))\n          ((char=?\
    \ s #\\a) (loop (substring s i) (incf i) count))\n          ((char=? s #\\b) (loop\
    \ (substring s i) (incf i) count))\n          ((char=? s #\\d) (loop (substring\
    \ s i) (incf i) count))\n          ((char=? s #\\E) (loop (substring s i) (incf\
    \ i) count))\n          ((char=? s #\\F) (loop (substring s i) (incf i) count))\n\
    \          ((char=? s #\\g) (loop (substring s i) (incf i) count))\n         \
    \ ((char=? s #\\G) (loop (substring s i) (incf i) count))\n          ((char=?\
    \ s #\\H) (loop (substring s i) (incf i) count))\n          ((char=? s #\\I) (loop\
    \ (substring s i) (incf i) count))\n          ((char=? s #\\J) (loop (substring\
    \ s i) (incf i) count))\n          ((char=? s #\\K) (loop (substring s i) (incf\
    \ i) count))\n          ((char=? s #\\L) (loop (substring s i) (incf i) count))\n\
    \          ((char=? s #\\M) (loop (substring s i) (incf i) count))\n         \
    \ ((char=? s #\\N) (loop (substring s i) (incf i) count))\n          ((char=?\
    \ s #\\O) (loop (substring s i) (incf i) count))\n          ((char=? s #\\P) (loop\
    \ (substring s i) (incf i) count))\n          ((char=? s #\\Q) (loop (substring\
    \ s i) (incf i) count))\n          ((char=? s #\\R) (loop (substring s i) (incf\
    \ i) count))\n          ((char=? s #\\S) (loop (substring s i) (incf i) count))\n\
    \          ((char=? s #\\T) (loop (substring s i) (incf i) count))\n         \
    \ ((char=? s #\\U) (loop (substring s i) (incf i) count))\n          ((char=?\
    \ s #\\", "  (- (length (filter (lambda (c) (and (char-upper? (c)) (even? (char-code\
    \ c))))\n                  (range 0 (length s))))\n     (length (filter (lambda\
    \ (c) (and (char-upper? (c)) (not (even? (char-code c))))\n                  (range\
    \ 0 (length s))))))\n", "  (cond\n    [(empty? s) 0]\n    [(equal? s (substring\
    \ s 0 1)) 1]\n    [else (+ 1 (count_upper (substring s 0 1)))]))\n", "  (if (null?\
    \ s) 0\n      (if (even? s)\n          (cond\n            ((string=? (string-ref\
    \ s 0) #\\a) (+ 1 (count_upper (substring s 1 ))))\n            ((string=? (string-ref\
    \ s 0) #\\e) (+ 1 (count_upper (substring s 1 ))))\n            ((string=? (string-ref\
    \ s 0) #\\i) (+ 1 (count_upper (substring s 1 ))))\n            ((string=? (string-ref\
    \ s 0) #\\o) (+ 1 (count_upper (substring s 1 ))))\n            (#t (count_upper\
    \ s)))))))\n", "  (let ([n (length s)]\n        [count (length s)])\n    (cond\
    \ [(= 0 (mod n 2)) (add1 count)]\n          [else (count_upper s (- n 2))])))",
  "  (cond\n    [(or (< s 26) (char=? s #\\a))\n     (add1 (count_upper s (+ s 1)))]\n\
    \    [(char=? s #\\A)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\\
    G)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\M)\n     (add1 (count_upper\
    \ s (+ s 1)))]\n    [(char=? s #\\N)\n     (add1 (count_upper s (+ s 1)))]\n \
    \   [(char=? s #\\O)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\\
    P)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\Q)\n     (add1 (count_upper\
    \ s (+ s 1)))]\n    [(char=? s #\\R)\n     (add1 (count_upper s (+ s 1)))]\n \
    \   [(char=? s #\\S)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\\
    T)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\U)\n     (add1 (count_upper\
    \ s (+ s 1)))]\n    [(char=? s #\\V)\n     (add1 (count_upper s (+ s 1)))]\n \
    \   [(char=? s #\\W)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\\
    X)\n     (add1 (count_upper s (+ s 1)))]\n    [(char=? s #\\Y)\n     (add1 (count_upper\
    \ s (+ s 1)))]\n    [(char=? s #\\Z)\n     (add1 (count_upper s (+ s 1)))]\n \
    \   [_ (add1 (count_upper s (+ s 1)))]))\n", "  (let loop ((count 0)\n       \
    \      (next (substring s 0 s))\n             (remainder '()))\n    (if (not next)\n\
    \        count\n        (loop (+ (count) (if (char-upper? next) 1 0))\n      \
    \        (substring next 1 next)\n              remainder)))))\n", "  (count_vowels\
    \ s (\u03BB (x) (= x #\\V)) 2))\n", "  (cond [(or (empty? s) (eq? (first s) #\\\
    A)) 0]\n        [(eq? (first s) #\\A) (+ 1 (count_upper (rest s)))]\n        [else\
    \ (+ 1 (count_upper (rest s))))))\n</cell>\n<text>\nExercise 1\nWrite a function\
    \ count_vowels that takes a list of characters and returns the number of vowels\
    \ in each character.\n\nHint: For a character, use char->int, which will give\
    \ the integer ASCII code of that character.\n\n\n</text>\n<cell>\n#lang racket\n",
  "  (cond [(= (length s) 0) 0]\n        [(= (length s) 1)\n         (if (string=?\
    \ (car s) #\\a)\n             (+ 1 (count_upper (cdr s)))\n             0)]\n\
    \        [(= (length s) 2)\n         (if (string=? (car s) #\\e)\n           \
    \  (+ 1 (count_upper (cdr s)))\n             0)]\n        [(= (length s) 3)\n\
    \         (if (string=? (car s) #\\i)\n             (+ 1 (count_upper (cdr s)))\n\
    \             0)]\n        [else\n         (if (string=? (car s) #\\u)\n     \
    \        (+ 1 (count_upper (cdr s)))\n             (count_upper (cdr s)))]))\n",
  "  (define (loop i n)\n    (if (= i 0)\n        n\n        (if (char-upper? (substring\
    \ s i (+ i 1)))\n            (loop (+ i 1) (+ n 1))\n            (loop (+ i 1)\
    \ n))))\n  (loop 0 0))\n", "  (cond\n    ((equal? s \"\") 0)\n    ((even? #?a)\
    \ (cond\n                   ((equal? (char s #?a) 'A) 1)\n                   ((equal?\
    \ (char s #?a) 'E) 2)\n                   ((equal? (char s #?a) 'I) 2)\n     \
    \              ((equal? (char s #?a) 'O) 2)\n                   ((equal? (char\
    \ s #?a) 'U) 2)\n                   (else 0))))\n    ((odd? #?a) (cond\n     \
    \              ((equal? (char s #?a) 'A) 1)\n                   ((equal? (char\
    \ s #?a) 'E) 2)\n                   ((equal? (char s #?a) 'I) 2)\n           \
    \        ((equal? (char s #?a) 'O) 2)\n                   ((equal? (char s #?a)\
    \ 'U) 2)\n                   (else 0))))\n    ((odd? #?e) (cond\n            \
    \       ((equal? (char s #?e) 'A) 1)\n                   ((equal? (char s #?e)\
    \ 'E) 1)\n                   ((equal? (char s #?e) 'I) 1)\n                  \
    \ ((equal? (char s #?e) 'O) 1)\n                   ((equal? (char s #?e) 'U) 1)\n\
    \                   (else 0))))\n    ((odd? #?i) (cond\n                   ((equal?\
    \ (char s #?i) 'A) 1)\n                   ((equal? (char s #?i) 'E) 1)\n     \
    \              ((equal? (char s #?i) 'I) 1)\n                   ((equal? (char\
    \ s #?i) 'O) 1)\n                   ((equal? (char s #?i) 'U) 1)\n           \
    \        (else 0))))\n    ((odd? #?o) (cond\n                   ((equal? (char\
    \ s #?o) 'A) 1)\n                   ((equal? (char s #?o) 'E) 1)\n           \
    \        ((equal? (char s #?o) 'I) 1)\n                   ((equal? (char s #?o)\
    \ 'O) 1)\n                   ((equal? (char s #?o) 'U) 1)\n                  \
    \ (else 0))))\n    ((odd? #?u) (cond\n                   ((equal? (char s #?u)\
    \ 'A) 1)\n                   ((equal? (char ", "  (let loop ((s s) (count 0))\n\
    \    (cond [(= count 0) 0]\n          [(char=? s #\\a) (add1 count)]\n       \
    \   [(char=? s #\\e) (add1 count)]\n          [(char=? s #\\i) (add1 count)]\n\
    \          [(char=? s #\\o) (add1 count)]\n          [else (loop (substring s\
    \ 0 (add1 (length s))) (add1 count))]))\n)\n</cell>\n<text>\nExercise 3: Write\
    \ a function called count_vowels that takes two parameters: a non-empty string\
    \ and a positive integer; and returns the number of vowels in the string that\
    \ are at the given index.\n\n\n</text>\n<cell>", "  (define (helper i acc)\n \
    \   (cond [(zero? i) (add1 acc)]\n          [(char-upper? s (- i 1)) (helper (-\
    \ i 1) (add1 acc))]\n          [else (helper (- i 1) acc)]))\n  (helper 0 0))\n",
  "  (cond\n    [(empty? s) 0]\n    [(not (even? (length s))) 0]\n    [(lower? (char-code\
    \ s)) 0]\n    [else (+ 1 (count_upper (cdr s)))]))\n", "  (let loop ((count 0)\
    \ (s s) (i 0) (c '()))\n    (if (not (= i len(s)))\n        count\n        (let\
    \ ((new-count (if (char-upper? (substring s i i))\n                          \
    \  (add1 (car c))\n                            0))\n              (new-s (substring\
    \ s i i 1)))\n          (if (= new-count 0)\n              (loop count new-s 0\
    \ c)\n              (loop new-count new-s 1 (cons new-count c)))))))\n", "  (cond\
    \ ((null? s) 0)\n        (else (count_upper (cdr s))\n               (cond\n \
    \                ((equal? (car s) 'A) (+ 1 count_upper (cdr s)))\n           \
    \      ((equal? (car s) 'E) (+ 1 count_upper (cdr s)))\n                 ((equal?\
    \ (car s) 'I) (+ 1 count_upper (cdr s)))\n                 (else (+ 1 count_upper\
    \ (cdr s))))))))\n", "  (let loop ((s (string->list s))\n             (i 0))\n\
    \    (cond [(empty? s) 0]\n          [else\n           (cond [(char=? (first s)\
    \ #\\A) 0]\n                 [(char=? (first s) #\\a) 1]\n                 [(char=?\
    \ (first s) #\\e) 2]\n                 [(char=? (first s) #\\i) 3]\n         \
    \        [(char=? (first s) #\\o) 4]\n                 [(char=? (first s) #\\\
    U) 5])\n           (loop (rest s) (+ i 1))]\n          [else (+ i (loop (rest\
    \ s) 0))]))))\n", "  (let loop ((counts #())\n             (str (string->list\
    \ s)))\n    (cond ((null? str) (counts))\n          ((even? (length str))\n  \
    \         (loop (cons (car (nthcdr str 0) counts)\n                    (substring\
    \ str (1+ 0) 1))\n                 rest))\n          (else\n           (loop (cons\
    \ (car (nthcdr str 0) counts)\n                     (substring str (1+ 0) 1))\n\
    \                   (cdr str)))\n          (else\n           (loop counts str)))\n\
    \    (length (filter even? (reverse counts)))))\n", "  (let loop ((s s) (count\
    \ 0))\n    (cond\n      [(= s (string-ref s 0)) count]\n      [else (loop (string-tail\
    \ s) (+ count (modulo (char->integer (char->lowercase (char->string s))) 26)))]\n\
    \    )))\n", "  (if (empty? s)\n      0\n      (if (even? (length s))\n      \
    \    (let ((v (char-upper (car s))))\n            (+ v (count_upper (cdr s)))))))\n",
  "  ; Initialize a counter to 0 and increment it for each occurrence of an\n  ; uppercase\
    \ vowel in the even indices.\n  (define count 0)\n  (let loop ([s (string-ref\
    \ s 0)])\n    (cond [(or (= (hash-ref s #\\A) hash-ref s #\\a) (= (hash-ref s\
    \ #\\B) hash-ref s #\\b))\n           (hash-set s #\\A (hash-set s #\\A 1))\n\
    \           count]\n          [(or (= (hash-ref s #\\A) hash-ref s #\\a) (= (hash-ref\
    \ s #\\B) hash-ref s #\\b))\n           (hash-set s #\\A (hash-set s #\\A (+ (hash-set\
    \ s #\\A 1) 1)))\n           count]\n          [(or (= (hash-ref s #\\A) hash-ref\
    \ s #\\a) (= (hash-ref s #\\B) hash-ref s #\\b))\n           (hash-set s #\\B\
    \ (hash-set s #\\B 1))\n           count]\n          [(or (= (hash-ref s #\\A)\
    \ hash-ref s #\\a) (= (hash-ref s #\\B) hash-ref s #\\b))\n           (hash-set\
    \ s #\\B (hash-set s #\\B (+ (hash-set s #\\B 1) 1)))\n           count]\n   \
    \       [(or (= (hash-ref s #\\A) hash-ref s #\\a) (= (hash-ref s #\\B) hash-ref\
    \ s #\\b))\n           (hash-set s #\\C (hash-set s #\\C 1))\n           count]\n\
    \          [(or (= (hash-ref s #\\A) hash-ref s #\\a) (= (hash-ref s #\\B) hash-ref\
    \ s #\\b))\n           (hash-set s #\\C (hash-set s #\\C (+ (hash-set s #\\C 1)\
    \ 1)))\n           count]\n          [(or (= (hash-ref s #\\A) hash-ref s #\\\
    a) (= (hash-ref s #\\B) hash-ref s #\\b))\n           (hash-set s #\\D (hash-set\
    \ s #\\D 1))\n           count]\n          [(or (= (hash-ref s #\\A) ", "  (define\
    \ (count_upper-aux\n           s n c)\n    (cond\n      [(empty? s) n]\n     \
    \ [(char=? (car s) c) (incf n)]\n      [(char=? (car s) #\\Upper) (incf n)]\n\
    \      [(char=? (car s) #\\u) (incf n)]\n      [else (incf (count_upper-aux s\
    \ (+ n 1))\n                   (count_upper-aux s (+ n 1))\n                 \
    \  c)]\n      ))\n  (count_upper-aux s 0 (char=? s #\\Upper)))", "  (cond\n  \
    \  [(empty? s) 0]\n    [(even? (length s)) (+ 1 (count (char s 'A) (length s)))]\n\
    \    [else (+ 1 (count_upper (rest s)))]))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(even? (car s)) (+ 1 (count_upper (cdr s)))]\n    [else 0]))\n", "  (let\
    \ loop [s (string->list s)\n           count 0]\n    (cond\n      [(null? s) count]\n\
    \      [(list? (car s))\n       (loop (cdr s) (+ count (length (string->list s))))]\n\
    \      [(char=? (car s) #\\A)\n       (loop (cdr s) (+ count 1))]\n      [(char=?\
    \ (car s) #\\E)\n       (loop (cdr s) (+ count 1))]\n      [(char=? (car s) #\\\
    Y)\n       (loop (cdr s) (+ count 1))]\n      [(char=? (car s) #\\O)\n       (loop\
    \ (cdr s) (+ count 1))]\n      [(char=? (car s) #\\U)\n       (loop (cdr s) (+\
    \ count 1))]\n      [(char=? (car s) #\\I)\n       (loop (cdr s) (+ count 1))]\n\
    \      [(char=? (car s) #\\0)\n       (loop (cdr s) (+ count 1))]\n      [(char=?\
    \ (car s) #\\1)\n       (loop (cdr s) (+ count 1))]\n      [(char=? (car s) #\\\
    2)\n       (loop (cdr s) (+ count 1))]\n      [(char=? (car s) #\\3)\n       (loop\
    \ (cdr s) (+ count 1))]\n      [(char=? (car s) #\\4)\n       (loop (cdr s) (+\
    \ count 1))]\n      [(char=? (car s) #\\5)\n       (loop (cdr s) (+ count 1))]\n\
    \      [(char=? (car s) #\\6)\n       (loop (cdr s) (+ count 1))]\n      [(char=?\
    \ (car s) #\\7)\n       (loop (cdr s) (+ count 1))]\n      [(char=? (car s) #\\\
    8)\n       (loop (cdr s) (+ count 1))]\n      [(char=? (car s) #\\9)\n       (loop\
    \ (cdr s) (+ count 1))]\n      [(char=? (car s) #\\P)\n       (loop (cdr s) (+\
    \ count 1))]\n      [(char=? (car s) #\\P)\n       (loop (cdr s) (+ count 1))]\n\
    \      [(char=? (car s) #\\P)\n       (loop (cdr s) (+ count 1))]\n      [(char",
  "  (let loop ((s (string->list s)))\n    (cond\n      [(empty? s) 0]\n      [else\
    \ (let ((str (rest s))\n                 (ls (string->list str)))\n          \
    \ (cond\n             [(or (empty? str) (number? (car str)))\n               (cond\n\
    \                 [(even? (length str)) 0]\n                 [(odd? (length str))\
    \ 0]\n                 [else (+ 1 (count_upper str))])]\n             [else (cond\n\
    \                   [(even? (length str)) 0]\n                   [(odd? (length\
    \ str)) 0]\n                   [else (loop (rest str))])])]]))))\n", "  (cond\n\
    \    ((empty? s) 0)\n    ((char? (car s))\n     (cond\n       ((even? (car (cdr\
    \ s)))\n        (count_upper (cdr s)))\n       (else 0)))\n    (else (count_upper\
    \ (cdr s)))))\n", "  (cond [(equal? s '') 0]\n        [(even? (string->list s))\n\
    \         (+ (length s)\n            (count (lambda (x) (string=? x 'A))\n   \
    \                #:from-end #t)))]\n        [else (error \"Unrecognized string:\
    \ ~a\" s)]))\n", "  (cond [(empty? s) 0]\n        [(and (char-upper? (char-code\
    \ (car s))) (even? (char-code (cdr s))))\n         (add1 (count_upper (cdr s)))]\n\
    \        [else (count_upper (cdr s))]))\n", "  (define char-index 2)\n  (define\
    \ (count index)\n    (define (char s)\n      (if (char-index s)\n          (if\
    \ (char= (char s) 'A')\n              (if (odd? index)\n                  0\n\
    \                  1\n                  )\n              )\n          )\n    \
    \  )\n    (if (char-index s)\n        (if (even? index)\n            0\n     \
    \       (+ (count (sub1 index))\n               (count (sub2 (add1 index)))\n\
    \               )\n           )\n       )\n    )\n  )\n  (count 0)\n  )\n", " \
    \ (if (empty? s)\n      0\n      (let ((c (char-code (car s))))\n        (cond\
    \ ((= c #\\A)\n              (+ 1 (count_upper (cdr s))))\n              ((= c\
    \ #\\E)\n              (+ 1 (count_upper (cdr s))))\n              ((= c #\\I)\n\
    \              (+ 1 (count_upper (cdr s))))\n              ((= c #\\O)\n     \
    \         (+ 1 (count_upper (cdr s))))\n              (else\n              (count_upper\
    \ (cdr s)))))))\n", "  (if (null? s)\n      '()\n      (if (even? (string->int\
    \ (car s)))\n          (+ 1 (count_upper (cdr s)))\n          (count_upper (cdr\
    \ s)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
