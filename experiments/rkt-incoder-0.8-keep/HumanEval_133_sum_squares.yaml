name: HumanEval_133_sum_squares
language: rkt
prompt: "#lang racket\n\n;; You are given a list of numbers.\n;; You need to return\
  \ the sum of squared numbers in the given list,\n;; round each element in the list\
  \ to the upper int(Ceiling) first.\n;; Examples:\n;; For lst = [1,2,3] the output\
  \ should be 14\n;; For lst = [1,4,9] the output should be 98\n;; For lst = [1,3,5,7]\
  \ the output should be 84\n;; For lst = [1.4,4.2,0] the output should be 29\n;;\
  \ For lst = [-2.4,1,1] the output should be 6\n(define (sum_squares lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.0)) 14)\n    (check-equal? (candidate\
  \ (list 1.0 2.0 3.0)) 14)\n    (check-equal? (candidate (list 1.0 3.0 5.0 7.0))\
  \ 84)\n    (check-equal? (candidate (list 1.4 4.2 0.0)) 29)\n    (check-equal? (candidate\
  \ (list -2.4 1.0 1.0)) 6)\n    (check-equal? (candidate (list 100.0 1.0 15.0 2.0))\
  \ 10230)\n    (check-equal? (candidate (list 10000.0 10000.0)) 200000000)\n    (check-equal?\
  \ (candidate (list -1.4 4.6 6.3)) 75)\n    (check-equal? (candidate (list -1.4 17.9\
  \ 18.9 19.9)) 1086)\n    (check-equal? (candidate (list 0.0)) 0)\n    (check-equal?\
  \ (candidate (list -1.0)) 1)\n    (check-equal? (candidate (list -1.0 1.0 0.0))\
  \ 2)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst)\n     (error \"No list\")\n     (sum-squares\
    \ '())]\n    [(number? (car lst))\n     (sum-squares (cdr lst))]\n    [else\n\
    \     (sum-squares (cons (int (car lst)) (cdr lst)))]))\n", "  (if (null? lst)\n\
    \      0\n      (+ (square (first lst)) (sum-squares (rest lst)))))\n", "  (cond\n\
    \    ((null? lst) 0)\n    ((= (remainder lst (car lst)) (car lst)) (sum_squares\
    \ (cdr lst)))\n    (else (+ (* lst (car lst)) (sum_squares (cdr lst))))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(number? (first lst)) (* first (sum_squares\
    \ (rest lst)))]\n    [else (+ (floor (first lst) (* 2 (sum_squares (rest lst))))\n\
    \             (floor (first lst) (* 2 (sum_squares (rest lst))))]))\n</code>\n\
    <|/ a tags=scheme,racket,functional-programming |>\n<| a |>\nI think you meant\n\
    <code>", "  (if (empty? lst)\n      0\n      (+ (square (car lst)) (sum-squares\
    \ (cdr lst)))))\n</code>\n<|/ a dscore=0 |>\n<| a |>\nYou can simplify it a bit\
    \ by using map and a lambda for sum:\n<code>", "  (if (null? lst)\n      0\n \
    \     (+ (* (ceiling (car lst)) (car lst)) (sum-squares (cdr lst)))))\n", "  (cond\n\
    \    [(empty? lst) 0]\n    [else (cons (* 0 (ceil (square (car lst))) (ceil (square\
    \ (cadr lst))))\n                (sum_squares (cdr lst)))]))\n</code>\nIn Scheme,\
    \ use 'cons' or 'list' to construct a list, and 'car' and 'cdr' to access its\
    \ elements.\n<|/ a tags=racket,scheme,racket-student-languages dscore=0 |>\n<|\
    \ c |>\nYou forgot to mention that this solution will crash if the input list\
    \ is empty or contains less than 2 elements.\n<|/ c |>\n<| c |>\nI did mention\
    \ it in the last paragraph of the answer: \"In Scheme, use 'cons' or 'list' to\
    \ construct a list, and 'car' and 'cdr' to access its elements\"\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHere's a solution with one tail-recursive function and one loop.\
    \ The latter is tail recursive and should be preferred.\n<code>", "  (cond\n \
    \   [(empty? lst)\n     0]\n    [else\n     (+ (* (ceiling (* (car lst) (car lst)))\n\
    \           (ceiling (* (car lst) (+ 1 lst)))\n           (ceiling (* (cdr lst)\
    \ (+ 1 lst))))\n      (sum_squares (cdr lst))]))\n", "  (if (empty? lst)\n   \
    \   0\n      (+ (round (first lst)) (sum_squares (rest lst)))))\n</code>\n<|/\
    \ a tags=racket,scheme dscore=2 |>\n<| a tags=racket,scheme |>\nHere is a solution\
    \ that is simple, robust, and efficient. The idea is to reduce the problem to\
    \ the sum problem of the sum of square of each element in the list. In the sum\
    \ problem, we only care about the elements themselves. In a solution, all we need\
    \ to do is find the sum of square of each element in the list. \nThe solution\
    \ will use Racket for syntax and library functions, including sum, map, foldr,\
    \ sum*, and round. I think it's a bit cleaner than some of the other solutions.\n\
    <code>\n#lang racket", "  (let loop ((lst lst)\n             (acc 0))\n    (if\
    \ (null? lst)\n        acc\n        (loop (rest lst)\n               (+ (*square*\
    \ (round (car lst))))\n               acc))))\n", "  (if (null? lst)\n      0\n\
    \      (+ (* lst (* lst (car lst)))\n         (sum-squares (cdr lst)))))\n", " \
    \ (define (helper lst acc)\n    (cond [(empty? lst)\n           acc]\n       \
    \   [(number? (car lst))\n           (helper (cdr lst) (+ acc (* lst (car lst))))]\n\
    \          [else\n           (helper (cdr lst) (+ acc (* lst (ceiling(car lst))))))))\n\
    \  (helper lst 0))\n", "  (if (null? lst)\n      0\n      (+ (sqr (floor (car\
    \ lst))) (sum-squares (cdr lst)))))\n", "  (if (null? lst)\n      '()\n      (cons\
    \ ((/ (expt (first lst) 2) (length lst))\n             (/ (expt (rest lst) 2)\
    \ (length lst)))\n            (sum-squares (rest lst)))))\n", "  (let loop ((lst\
    \ lst) (sum 0))\n    (if (empty? lst)\n        sum\n        (loop (rest lst) (+\
    \ (* (car lst) (* sum (car lst))) sum)))))\n", "  (cond\n    [(empty? lst) 0]\n\
    \    [(positive? lst) (* (first lst) (sum-squares (rest lst)))]\n    [else (error\
    \ \"Invalid argument: \" lst)]\n  ))\n", "  (define square (lambda(x) (* x x)))\n\
    \  (define round_up (lambda (x) (ceiling x)))\n  (cond [(empty? lst) 0]\n    \
    \    [else (+ (map (lambda (x) (square (round_up (round_up (round_up x)))))\n\
    \                 (map square (rest lst)))]\n        ))\n", "  (if (null? lst)\n\
    \      0\n      (+ (* (ceiling (first lst))\n            (ceiling (second lst)))\n\
    \         (sum-squares (rest lst))))))\n", "  (if (null? lst)\n      (/ 1 0)\n\
    \      (+ (* 2 (round (cdr lst)))\n         (sum-squares (cdr lst)))))\n</code>\n\
    <|/ a tags=racket,scheme |>\n<| c |>\nWhat happens if you apply this to `(-1.4\
    \ -4.2 0.000000 1)` ? I think the problem is with rounding, but `ceil` returns\
    \ `0` when passed a negative argument.\n<|/ c |>\n<| c |>\nThis was my first thought,\
    \ too, but `ceil` returns `0` when the input number is negative. Thus, the `round`\
    \ function won't round the negative number to the nearest integer.\n<|/ c |>\n\
    <| a dscore=0 tags=racket,scheme |>\nHere is my solution:\n<code>", "  (define\
    \ (make-sum-squares lst sum)\n    (if (null? lst)\n        sum\n        (make-sum-squares\
    \ (cdr lst) (+ sum (* lst (car lst)))))\n  (make-sum-squares lst 0))\n", "  (if\
    \ (null? lst)\n      0\n      (+ (square (car lst))\n         (sum-squares (cdr\
    \ lst)))))\n</code>\nYou can make your functions reusable by passing as parameters\
    \ functions you want to use.\nYou can make your functions reusable by passing\
    \ as parameters functions you want to use.\nYou can make your functions reusable\
    \ by passing as parameters functions you want to use.\nYou can make your functions\
    \ reusable by passing as parameters functions you want to use.\nYou can make your\
    \ functions reusable by passing as parameters functions you want to use.\nYou\
    \ can make your functions reusable by passing as parameters functions you want\
    \ to use.\nYou can make your functions reusable by passing as parameters functions\
    \ you want to use.\nYou can make your functions reusable by passing as parameters\
    \ functions you want to use.\nYou can make your functions reusable by passing\
    \ as parameters functions you want to use.\nYou can make your functions reusable\
    \ by passing as parameters functions you want to use.\nYou can make your functions\
    \ reusable by passing as parameters functions you want to use.\nYou can make your\
    \ functions reusable by passing as parameters functions you want to use.\nYou\
    \ can make your functions reusable by passing as parameters functions you want\
    \ to use.\nYou can make your functions reusable by passing as parameters functions\
    \ you want to use.\nYou can make your functions reusable by passing as parameters\
    \ functions you want to use.\nYou can make your functions reusable by passing\
    \ as parameters functions you want to use.\nYou can make your functions reusable\
    \ by passing as parameters functions you want to use.\nYou can make your functions\
    \ reusable by passing as parameters functions you want to use.\nYou can make your\
    \ functions reusable by passing as parameters functions you want to use.\nYou\
    \ can make your functions reusable by passing as parameters functions you want\
    \ to use.\nYou can make your functions reusable by passing as parameters functions\
    \ you want to use.\nYou can make your functions reusable by passing as parameters\
    \ functions you want to use.\nYou can make your functions reusable by passing\
    \ as parameters functions you want to use.\nYou can make your functions reusable\
    \ by passing as parameters functions you want to use.\nYou can make your functions\
    \ reusable by passing as parameters functions you want to use.\nYou can make your\
    \ functions reusable by passing as parameters functions you want to use.\nYou\
    \ can make your functions reusable by passing as parameters functions you want\
    \ to use.\nYou can make your functions reusable by passing as parameters functions\
    \ you want to use.\nYou can make your functions reusable by passing as parameters\
    \ functions you want to use.\nYou can make your functions reusable by passing\
    \ as parameters functions you want to use.\nYou can make your functions reusable\
    \ by passing as parameters functions you want to use.\nYou can make your functions\
    \ reusable by passing as parameters functions you want to use.\n", "  (reduce\
    \ + (map (lambda (x) (* x x)) lst)))\n", "  (reduce (lambda (x y)\n          \
    \  (+ (* x x) (* y y)))\n          lst 0))", "  (if (null? lst)\n      0\n   \
    \   (+ (round (* lst (fst lst)) #t)\n         (sum-squares (append (rest lst)\
    \ (list (round (* lst (fst lst))))))))\n", "  (if (null? lst)\n      0\n     \
    \ (+ (* (floor lst int) (floor lst int)) (sum-squares (rest lst)))))", "  (sum-squares\
    \ '(square 0 lst)))\n", "  (map ceil\n       (map sqrt\n            (map (lambda\
    \ (n)\n                  (* n n)))\n              lst)))\n", "  (if (empty? lst)\
    \ 0\n      (+ (round (* lst (car lst))) \n         (sum-squares (cdr lst)))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(< 0 (first lst)) 0]\n    [else (+ (first lst)\n\
    \            (square (round (first lst))))\n           (sum-squares (rest lst))]))\n",
  "  (define (make-square-sum)\n    (lambda (lst)\n      (let loop ((i lst) (acc 0))\n\
    \        (cond ((null? i) (square acc))\n               ((positive? (first i))\n\
    \                (let ((j (rest i)) (temp (square j)))\n                  (loop\
    \ j (+ acc temp)))\n               (else (loop (rest i) acc))))))\n  (make-square-sum\
    \ lst))\n</code>\n<|/ a tags=scheme,racket,scheme |>\n<| c |>\nThank you for this,\
    \ this is very useful! I didn't know about racket-math, I was trying to do this\
    \ in DrRacket.\n<|/ c |>\n<| a |>\nThis solution uses only racket/scheme/math\n\
    <code>", "  (define (sq x)\n    (* x x))\n  (define (round-to-ceil n)\n    (ceiling\
    \ n (floor (/ (+ (* x x) (sq x)) (* x x))))) \n  (define (sum-sq lst acc k)\n\
    \    (cond [(empty? lst) acc]\n          [(<= (first lst) (first k)) (sum-sq (rest\
    \ lst) (+ (first k) (square (first lst))) (rest k))]\n          [(> k (first lst))\
    \ (sum-sq lst acc k)]\n          [else (sum-sq lst acc (rest k))]\n          ))\n\
    \  (sum-sq lst 0 (rest lst)))\n", "  (let ((sum 0))\n    (cond ((null? lst)\n\
    \           (cond ((= sum 0) 0)\n                   (else (round (sum (car lst))\
    \ int))))\n          ((= (car lst) (cadr lst))\n           (cond ((= sum 0) 0)\n\
    \                   (else (+ (* (round (car lst) int) (car lst)) (sum (cdr lst))))))\n\
    \          (else\n           (set! sum (+ sum (* car lst))) (sum (cdr lst))))))\n",
  "  (apply + \n        (map (lambda (x) (round (* x (x x)))) \n             (number-sequence\
    \ lst)))) \n", "  (reduce + (map (lambda (n) (* n n)) lst)))\n", "  (cond\n  \
    \  ((null? lst) 0)\n    ((not (number? (car lst))) (* 0 (floor (car lst))))\n\
    \    ((even? (length lst)) (* 0 (sum-squares (rest lst))))\n    ((odd? (length\
    \ lst)) (+ (floor (car lst)) (sum-squares (cdr lst))))\n    (else (* 0 (floor\
    \ (car lst))) (sum-squares (cdr lst)))))\n", "  (if (null? lst)\n      0\n   \
    \   (+ (map (lambda (x) (int-ceiling x)) lst) (map (lambda (x) (int-ceiling x))\
    \ (sub1 lst))))))\n", "  (cond\n    [(empty? lst) 0]\n    [else (* \n        \
    \    (floor (* (first lst) (first lst))) \n            (sum_squares (rest lst))\n\
    \            )]))\n", "  (let loop ((result 0.0)\n             (lst lst))\n  \
    \  (if (null? lst)\n        result\n        (loop (+ result (car lst))\n     \
    \         (- lst (car lst))))))\n", "  (if (empty? lst)\n      0\n      (+ (square\
    \ (round (car lst))) (sum_squares (cdr lst)))))\n", "  (if (null? lst) 0\n   \
    \   (+ (* (ceiling car lst) (car lst))\n         (sum_squares (cdr lst)))))\n",
  "  (if (null? lst)\n      0\n      (+ (expt (floor lst) 2)\n         (sum-squares\
    \ (sub1 lst)))))\n", "  (define (helper lst acc)\n    (cond\n      [(null? lst)\
    \ acc]\n      [(number? (car lst)) (helper (cdr lst) (+ (car lst) acc))]\n   \
    \   [else (helper (cdr lst) (+ (* acc (car lst))) (/ acc (cdr lst)))]\n    ))\n\
    \  (helper (reverse lst) 0))\n", "  (define (round num)\n    (cond ((< num 0)\
    \ -num)\n          ((> num 0) (num)))\n    (+ (round (* num num)) (round (* num\
    \ (- num 1)))))\n  (define (sum_squares-helper lst acc)\n    (cond\n      ((null?\
    \ lst) acc)\n      ((= (car lst) (car acc)) (sum_squares-helper (cdr lst) acc))\n\
    \      (else (sum_squares-helper (cdr lst) (cons (car acc) acc)))))\n  (sum_squares-helper\
    \ lst '()))\n  ;; end #lang racket\n\n  ;; You are given a list of numbers.\n\
    \  ;; Write an efficient function `sumSquare` that computes the sum of squares.\n\
    \  ;; Use a recursive algorithm to compute the sum.\n  ;; Examples:\n  ;; For\
    \ lst = [1,3,5,7,11] the output should be 45\n  ;; For lst = [-2,-1,1,-2] the\
    \ output should be 0\n  ;; For lst = [] the output should be 0\n  (define (sumSquaresEfficient-helper\
    \ lst acc)\n    (cond\n      ((null? lst) acc)\n      ((= (car lst) (car acc))\
    \ (sumSquaresEfficient-helper (cdr lst) acc))\n      (else (sumSquaresEfficient-helper\
    \ (cdr lst) (cons (car acc) acc)))))\n  (sumSquaresEfficient-helper lst '()))\n\
    \  ;; end #lang racket\n\n  ;; You are given two lists of numbers.\n  ;; You need\
    \ to return the sum of squared numbers in the given lists.\n  ;; Examples:\n \
    \ ;; For lst = [1, 2, 3] the output should be 9\n  ;; For lst = [1, 3, 5] the\
    \ output should be 25\n  (define (sum-squares lst1 lst2)\n    (define (sum-squares-helper\
    \ lst1 lst2 acc)\n      (cond\n        ((null? lst1) (sum-squares-helper lst2\
    \ (cons (car lst2) acc))\n        )\n        ((null? lst2) (sum-squares-helper\
    \ (car lst1) (cons (car lst2) acc))\n        )\n        (else (sum-squares-helper\
    \ (car lst1) (cdr lst2) (cons (car lst2) acc))\n        )\n        )\n    (sum-squares-helper ",
  "  (define (sum_squares lst acc)\n    (cond\n      [(null? lst) (sum acc)]\n   \
    \   [else (sum_squares (rest lst) (+ (* acc (car lst)) (* acc (abs (car lst))))))]))\n\
    \  (sum_squares lst 0))\n</code>\n<|/ a tags=lisp,racket |>\n<| c |>\nThe question\
    \ is tagged `racket`, not `scheme`.\n<|/ c |>\n<| c |>\n, my apologies, it seemed\
    \ like it was a very generic question that could be answered with a recursive\
    \ function.\n<|/ c |>\n<| c |>\nThanks for your solution! I wonder if you could\
    \ solve it by converting it to Scheme? I haven't learned Scheme yet, and I've\
    \ only learned Racket.\n<|/ c |>\n<| c |>\n, you could do it, but I think the\
    \ racket version is better. I'll edit my answer to include the scheme.\n<|/ c\
    \ |>\n<| c |>\nThanks for taking the time to write your answer. I'll try it and\
    \ see if I can understand it.\n<|/ c |>\n<| a tags=lisp,racket dscore=0 |>\nHere\
    \ is a solution that is tail-recursive, and uses Scheme to create the functions:\n\
    <code>", "  (cond\n    ((empty? lst) 0)\n    ((= (car lst) '-) (* -1 0))\n   \
    \ ((= (car lst) '-) (cons 0 (sum_squares (cdr lst))))\n    ((= (car lst) '-) (cons\
    \ 0 (sum_squares (cdr lst)))))\n  (+ (round-up (square (car lst)) 0) (round-down\
    \ (square (car lst)) 0)\n      (sum-squares (cdr lst))))\n", "  (reduce + (map\
    \ (lambda (x) (square (round x #lang racket))) lst)))\n", "  (reduce + (map (\u03BB\
    \ (x) (round (* x x))) lst)))\n", "  (define (helper-sqr n lst)\n    (if (empty?\
    \ lst)\n        (* n n)\n        (helper-sqr (* n n) (sub1 lst))))\n  (helper-sqr\
    \ (ceiling . fst) (map ceiling (map fst lst))))\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>", "  (let loop ((lst lst) (sum 0))\n    (if (null? lst)\n        sum\n\
    \        (loop (rest lst) (+ sum (square (first lst)))))\n    ))\n", "  (let ([sum\
    \ (foldr (lambda (x y)\n                    (+ x (* y y)))\n                 \
    \  0 lst)])\n    (round sum)))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you\
    \ for the response. The code I posted works perfectly and is a solution to my\
    \ original question. My main concern with this is that it isn't very easy to read,\
    \ so I was hoping for a more simple solution. I thought there might be a way to\
    \ do this using only basic functions. I appreciate your help.\n<|/ c |>\n<| c\
    \ |>\nIt wasn't clear from your question that you wanted something with as little\
    \ code as possible.\n<|/ c |>\n<| a tags=scheme,racket |>\nThe easiest thing to\
    \ do is to convert the list into a list of lists, each containing an even number\
    \ of elements, then just use foldr on that. Something like:\n<code>", "  (define\
    \ (iter lst sum)\n    (cond [(null? lst) sum]\n          [(number? (car lst))\
    \ (iter (cdr lst) (+ sum (square (car lst))))]\n          [else (iter (cdr lst)\
    \ sum)]))\n  (iter lst 0))\n", "  (if (null? lst)\n      0\n      (+ (map (lambda\
    \ (x) (* x x)) lst)))\n", "  (if (empty? lst)\n      0\n      (+ (floor (* lst\
    \ (car lst)) lst)\n         (sum-squares (cdr lst)))))\n", "  (let loop ((lst\
    \ lst)\n             (acc 0))\n    (cond\n      [(null? lst) acc]\n      [(number?\
    \ (car lst)) (+ acc (sqr (car lst)))]\n      [else (loop (cdr lst) (+ acc (sqr\
    \ (car lst))))])))\n</code>\n<|/ a |>\n<| a tags=scheme,racket |>\n<code>", " \
    \ (sum lst (lambda (x y) (* x y)))\n)\n", "  (sum (map (lambda (x) (round x))\
    \ lst)))\n</cell>\n<cell>\n#lang racket\n", "  (reduce + \n\t  (map (lambda (num)\n\
    \t\t  (* num (sqrt num))) lst)))\n", "  (let loop ((lst lst)\n             (res\
    \ 0))\n    (cond ((null? lst) res)\n          ((< lst (car lst))\n           (loop\
    \ (cdr lst) (+ res (* lst lst))))\n          (else (loop (cdr lst) res)))))\n",
  "  (define (helper-func lst)\n    (if (null? lst)\n        0\n        (+ (* lst\
    \ (car lst)) (helper-func (cdr lst)))))\n  (helper-func lst))\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nFor those who prefer to use fold, there is one more solution\
    \ (using fold):\n<code>", "  (if (null? lst)\n      0\n      (+ (square (round\
    \ (car (cdr lst)))) (sum_squares (cdr lst))))))\n", "  (if (null? lst)\n     \
    \ 0\n      (+ (sqr (car lst))\n         (sum-squares (cdr lst)))))\n", "  (define\
    \ (sqr-each x)\n    (* x x))\n  (define (ceil-each x)\n    (ceiling (* x x)))\n\
    \  (define (round-each x)\n    (round (* x x)))\n  (define (add x y)\n    (+ x\
    \ y))\n  (define (add x y z)\n    (+ x (add y z)))\n  (define (add x y z w)\n\
    \    (+ x (add y z (add z w))))\n  (define (add x y z w x)\n    (+ x (add y z\
    \ (add z w (add w x))))\n  (define (add x y z w x y)\n    (+ x (add y z (add z\
    \ w (add w x (add x y)))))\n  (define (add x y z w x y z)\n    (+ x (add y z (add\
    \ z w (add w x (add x y z)))))\n  (define (add x y z w x y z w)\n    (+ x (add\
    \ y z (add z w (add w x (add x y z w)))))\n  (define (add x y z w x y z w x)\n\
    \    (+ x (add y z (add z w (add w x (add x y z w x)))))\n  (define (add x y z\
    \ w x y z w x y)\n    (+ x (add y z (add z w (add w x (add x y z w x y)))))\n\
    \  (define (add x y z w x y z w x y z)\n    (+ x (add y z (add z w (add w x (add\
    \ x y z w x y w)))))\n  (define (add x y z w x y z w x y z w)\n    (+ x (add y\
    \ z (add z w (add w x (add x y z w x y z w)))))\n  (define (add x y z w x y z\
    \ w x y z w x)\n    (+ x (add y z (add z w (add w x (add x y z w x y z w x)))))\n\
    \  (define (add x y z w x y z w x y z w x y)\n    (+ x (add y z (add z w (add\
    \ w x (add x y z w x y z w x y)))))\n  (define (add x y z w x y z w x y z w x\
    \ y z)\n    (+ x (add y ", "  (if (empty? lst)\n      0\n      (+ (square (round\
    \ (cadr lst)))\n         (sum-squares (cdr lst)))))\n", "  (define (sum x)\n \
    \   (* x x))\n  (define (round)\n    (ceiling x))\n  (sum (round (map (lambda\
    \ (x) (* x x)) lst))))\n</code>\n<|/ a tags=scheme,racket dscore=2 |>\n<| a dscore=1\
    \ |>\nAnother solution is to use built-in map/reduce functions:\n<code>", "  (let\
    \ ((res (loop lst 0)))\n    (if (null? res)\n        res\n        (let ((sum (car\
    \ res)))\n          (loop (cdr res) (+ sum (* sum (car res))))))))\n", "  (if\
    \ (empty? lst) 0\n      (+ (* lst (square (car lst)))\n         (sum_squares (cdr\
    \ lst)))))\n", "  (cond\n    ((null? lst) 0)\n    ((list? (car lst)) (+ (sum-squares\
    \ (first lst)) (sum-squares (rest lst)))\n     (/ (* 2 (first lst)) (length lst))\
    \ (sum-squares (rest lst)))))\n", "  (sum-square-round lst))\n", "  (define (sum-squares-aux\
    \ acc num)\n    (if (empty? num)\n        acc\n        (sum-squares-aux (+ acc\
    \ (square-number (first num))) (rest num))))\n  (sum-squares-aux (+ (first (sort\
    \ (map square-number lst)) 0)) lst))\n", "  (let ([total (make-array\n       \
    \         (length (array->list lst)) \n                (lambda (i)\n         \
    \         (* i i))))])\n    (for-each (lambda (i)\n               ((array-set\
    \ total i (round (+ 0 (array-ref total i))))))\n             lst)))\n", "  (cond\n\
    \    ((null? lst) 0)\n    ((number? (car lst)) (cdr (+ (square car lst) (car lst))))\n\
    \    (else (sum_squares (cdr lst)))))\n", "  (sum-squares-helper (car lst) (cdr\
    \ lst) '()))\n", "  (if (null? lst)\n      0\n      (+ (ceil (* lst (car lst)))\n\
    \         (sum-squares (cdr lst)))))\n", "  (define (helper lst acc)\n    (cond\n\
    \      [(null? lst)\n       (if (zero? acc)\n           0\n           (ceiling\
    \ acc))\n       ;; Add the new result to the accumulator\n       ]\n      [(number?\
    \ (car lst))\n       (helper lst (+ acc (* (car lst) (car lst)))\n        ]\n\
    \      [else (helper (cdr lst) (+ acc (* (car lst) acc)))]\n      ))\n  (helper\
    \ lst 0))\n", "  (define (helper lst acc)\n    (cond\n      [(null? lst) (add1\
    \ (* acc acc))]\n      [else (helper (cdr lst) (add1 (* acc (car lst))))]))\n\
    \  (helper lst 0))\n", "  (cond\n    [(empty? lst) 0]\n    [(number? (first lst))\
    \ (square (round (first lst)))]\n    [else (+ (sum_squares (rest lst)) (square\
    \ (round (first lst))))]))\n", "  (if (empty? lst)\n      0\n      (+ (sq (car\
    \ lst))\n         (sum_squares (cdr lst)))))\n", "  (if (null? lst)\n      0\n\
    \      (+ (* 3 (floor (* lst (car lst))))\n         (sum-squares (cdr lst)))))\n",
  "  (define (sum-of-squares-helper lst acc)\n    (cond [(null? lst) acc]\n      \
    \    [(>= (first lst) 0)\n           (sum-of-squares-helper (rest lst)\n     \
    \                           (+ (sqrt (first lst))\n                          \
    \         (sum-of-squares-helper (rest lst) acc)))]\n          [else (sum-of-squares-helper\
    \ (rest lst)\n                                  (+ (first lst)\n             \
    \                       (sum-of-squares-helper (rest lst) acc)))]))\n  (sum-of-squares-helper\
    \ lst 0))\n", "  (if (null? lst)\n      '()\n      (+ (square (ceiling x) (ceiling\
    \ y))\n         (sum-squares rest)))))\n", "  (if (empty? lst)\n      0\n    \
    \  (+ (sq (first lst))(sum-squares (rest lst))))))\n", "  (define (iter x acc\
    \ accs)\n    (if (empty? x)\n        acc\n        (iter (cdr x) (inc acc) (car\
    \ accs))))\n  (iter lst 0 [lst]))\n", "  (if (empty? lst)\n      0\n      (+ (square\
    \ elt lst)\n         (sum_squares (cdr lst)))))\n", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(> (first lst) 0) (+ (square (round (first lst)))\n               \
    \           (sum_squares (rest lst)))]\n    [else (sum_squares (rest lst))]))\n",
  "  (if (empty? lst)\n      0\n      (+ (square (car lst))\n         (sum-squares\
    \ (cdr lst)))))\n", "  (if (null? lst)\n      0\n      (+ (* (ceiling (first lst))\
    \ (ceiling (first lst)))\n         (sum-squares (rest lst)))))\n", "  (define\
    \ (sum-square-iter lst)\n    (if (null? lst)\n        (quote ())\n        (let\
    \ ((n (car lst)))\n          (+ n (sum-square-iter (cdr lst)))))\n  (sum-square-iter\
    \ lst))\n", "  (define (helper lst sum)\n    (if (empty? lst)\n        sum\n \
    \       (helper (rest lst) (+ (square (first lst)) sum)))))\n  (helper (reverse\
    \ lst) 0))\n", "  (cond\n    [(empty? lst) 0]\n    [else (+ (* lst (square lst))\
    \ (sum_squares (rest lst)))]))\n", "  (if (null? lst)\n      '()\n      (+ (*\
    \ lst (* lst (cdr lst)))\n         (sum-squares (cdr lst)))))\n", "  (define (make-sum\
    \ lst)\n    (let ((sum (+ 0 0)))\n      (for ([i (in-range (length lst))])\n \
    \       (set! sum (+ sum (list-ref lst i))))\n      sum))\n\n  (define (square\
    \ x)\n    (* x x))\n\n  (define (round x)\n    (ceiling (/ x 2)))\n\n  (define\
    \ (ceiling x)\n    (- x 1))\n\n  (define (up-round x)\n    (round (/ x 2)))\n\n\
    \  (define (square x y)\n    (if (null? y)\n        x\n        (square x (cdr\
    \ y))))\n\n  (define (round x y)\n    (if (null? y)\n        x\n        (round\
    \ x (cdr y))))\n\n  (define (ceiling x y)\n    (if (null? y)\n        x\n    \
    \    (ceiling x (cdr y))))\n\n  (define (up-round x y)\n    (if (null? y)\n  \
    \      x\n        (up-round x (cdr y))))\n\n  (define (square x y z)\n    (if\
    \ (null? y)\n        x\n        (square x (cdr y) z)))\n\n  (define (round x y\
    \ z)\n    (if (null? y)\n        x\n        (round x (cdr y) z)))\n\n  (define\
    \ (ceiling x y z)\n    (if (null? y)\n        x\n        (ceiling x (cdr y) z)))\n\
    \n  (define (up-round x y z)\n    (if (null? y)\n        x\n        (up-round\
    \ x (cdr y) z)))\n\n  (define (squares lst)\n    (if (null? lst)\n        (make-sum\
    \ lst)\n        (squares (cdr lst) lst)))\n\n  (define (rounded lst)\n    (if\
    \ (null? lst)\n        (make-sum lst)\n        (rounded (cdr lst) lst)))\n\n \
    \ (define (ceilings lst)\n    (if (null? lst)\n        (make-sum lst)\n      \
    \  (ceilings (cdr lst) lst)))\n\n  (define (up-roundeds lst)\n    (if (null? lst)\n\
    \        (make-sum lst)\n        (up-roundeds (cdr lst) lst)))\n\n  (define (squared\
    \ lst)\n    (if (null? lst)\n        (make-sum lst)\n        (squared (cdr lst)\
    \ lst)))\n\n  (define (rounded lst sum)\n    (if (null? lst)\n        sum\n  \
    \      (rounded (cdr lst) sum)))\n\n  (define (ceilings lst sum)", "  (define\
    \ (sum-squares acc list)\n    (cond ((null? list) acc)\n          ((number? (car\
    \ list))\n           (sum-squares (+ (square (floor (car list)))\n           \
    \              (square acc))\n                     (cdr list)))\n          (else\n\
    \           (sum-squares (+ (square (floor (car list)))\n                    \
    \     (square acc))\n                     (cdr list)))))\n  (sum-squares 0 lst))\n",
  "  (cond\n    ((null? lst) 0)\n    ((number? (car lst)) (sqrt (+ (car lst) (* 2\
    \ (car lst)))))\n    (else (sum-squares-helper lst))\n  )\n)\n", "  (if (null?\
    \ lst)\n      0\n      (+ (*\n          (ceiling (caar lst))\n          (ceiling\
    \ (+ (caar lst) (* 2 cadddr (cdr lst))))\n          (ceiling (+ (caadr lst) (*\
    \ 2 cadddr (cdadr lst))))\n          (ceiling (+ (cadddr lst) (* 2 cadddr (caddadr\
    \ lst))))\n          (ceiling (+ (caddadr lst) (* 2 cadddr (cadddad lst))))\n\
    \          (ceiling (+ (cadddad lst) (* 2 cadddr (cadddad lst))))\n          (ceiling\
    \ (+ (cadddad lst) (* 2 cadddr (cadddab lst))))\n          (ceiling (+ (cadddab\
    \ lst) (* 2 cadddr (cadddab lst))))\n          (ceiling (+ (cadddab lst) (* 2\
    \ cadddr (cadddba lst))))\n          (ceiling (+ (cadddba lst) (* 2 cadddr (cadddba\
    \ lst))))\n          (ceiling (+ (cadddba lst) (* 2 cadddr (cadddc lst))))\n \
    \         (ceiling (+ (cadddc lst) (* 2 cadddr (cadddc lst))))\n          (ceiling\
    \ (+ (cadddc lst) (* 2 cadddr (caddde lst))))\n          (ceiling (+ (caddde lst)\
    \ (* 2 cadddr (caddde lst))))\n          (ceiling (+ (caddde lst) (* 2 cadddr\
    \ (cadddfe lst))))\n          (ceiling (+ (cadddfe lst) (* 2 cadddr (cadddfe lst))))\n\
    \          (ceiling (+ (cadddfe lst) (* 2 cadddr (cadddg lst))))\n          (ceiling\
    \ (+ (cadddg lst) (* 2 cadddr (cadddg lst))))\n          (ceiling (+ (cadddg lst)\
    \ (* 2 cadddr (cadddh lst))))\n          (ceiling (+ (cadddh lst) (* 2 cadddr\
    \ (cadddh lst))))\n          (ceiling (+ (cadddh lst) (* 2 cadddr (cadddi lst))))\n\
    \          (ceiling (+ (cadddi lst) (* 2 cadddr (", "  (apply + (map (lambda (n)\
    \ (* n n)) lst)))\n", "  (apply + \n        (map \n          (lambda (x) \n  \
    \          (round (* x x)) \n            (round (* x x)))\n          lst)))\n",
  "  (define (f lst acc)\n    (if (null? lst)\n        acc\n        (f (cdr lst) (+\
    \ (square (round (car lst)) acc))))\n  (f lst 0))\n</code>\n<|/ a tags=racket\
    \ dscore=0 |>\n<| c |>\nHi, i tried this but i got an exception error. My list\
    \ is `[4.4 2.8 2.8 1.6 0.2 0.2 -0.2 -0.2 -0.6 0]` and expected result should be\
    \ `[-8.6 -9.2 -7.2 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -2.0 -2.0 -3.0 -4.0 -6.0]` but\
    \ getting `Error: sum-of-squares: contract violation\n  expected: real?\n  given:\
    \ real?\n  argument position: 1st\n  other arguments.:\n<|/ c |>\n<| a tags=racket\
    \ |>\nHere is another answer that makes use of the reduce function from Racket\
    \ (documentation).\n<code>\n#lang racket\n", "  (define (square x)\n    (* x x))\n\
    \  (define (round x)\n    (ceiling (* x 10)))\n  (define (sum-squares lst)\n \
    \   (define (sum-squares lst acc acc1)\n      (if (null? lst)\n          acc\n\
    \          (sum-squares (cdr lst)\n                      (+ acc (square acc1))\n\
    \                      acc1)))\n    (let ((result 0))\n      (sum-squares lst\n\
    \                   (+ (round result) result)\n                   result)))\n\
    \  result)\n", "  (if (null? lst)\n      0\n      (+ (* lst (cdr lst)) (sum-squares\
    \ (cdr lst)))))\n", "  (define (helper lst acc index)\n    (cond\n      [(null?\
    \ lst) (sum-list acc)]\n      [(number? (car lst)) (helper (cdr lst) acc (+ index\
    \ 1))]\n      [else (helper (cdr lst) (+ acc (sqrt (car lst))) (+ index 1))]))\n\
    \  (helper lst 0 0))\n", "  (cond\n    [(null? lst)\n     0]\n    [(number? (car\
    \ lst)) (* lst (car lst))]\n    [else\n     (sum-squares (cons (ceil (car lst))\
    \ (rest lst)))]))\n", "  (define (square n)\n    (* n n))\n  (define (round n\
    \ t)\n    (round (* n t) (/ (- n t) t)))\n  (define (ceil-floor n)\n    (if (=\
    \ n 0)\n        0\n        (+ (ceil (round n 10)) (floor (round n 10))))))\n \
    \ (sum\n    (map (lambda (n) (* n n))\n         (map (lambda (n) (square n))\n\
    \               (map (lambda (n) (round n 10))\n                     (reverse\
    \ lst)))))\n", "  (if (null? lst)\n      0\n      (+ (* lst (car lst)) (sum-squares\
    \ (cdr lst)))))\n</code>\nThe code above will work for all cases. However, it\
    \ is better to use the ceiling function from scheme or racket.\n<|/ a dscore=3\
    \ |>\n<| c |>\nHi Ken! I wanted to implement a similar function in python and\
    \ your answer helped me! thank you so much! I appreciate it.\n<|/ c |>\n<| c |>\n\
    Thanks, this helped me. Just wanted to add that, while I was trying my code, I\
    \ kept on getting an error, where I couldn't find the bug in my code because I\
    \ wasn't comparing my variables in some way. For example I tried to see if my\
    \ code was working on other number than [1..9], which was what I wanted to do.\
    \ But this time, I had some number in the list that was giving me the wrong sum.\n\
    <|/ c |>\n<| c |>\nAlso note that if you just want to round the numbers to their\
    \ nearest integer, you can use `round` from the `math` module.\n<|/ c |>\n<| a\
    \ dscore=3 |>\nI came across a similar problem. I wanted to round the numbers\
    \ to their nearest integer and not use ceiling or floor (as these may have some\
    \ limitations). I came up with the following:\n<code>", "  (cond\n    ((null?\
    \ lst) 0)\n    ((number? lst) (round (abs (* lst lst))))\n    (else (+ (sum-squares\
    \ (rest lst)) (* lst (sum-squares (rest lst)))))))\n", "  (cond\n    [(empty?\
    \ lst)\n     (error 'sum-squares-error \"no numbers in list\")]\n    [(number?\
    \ (first lst))\n     (* 1 (sum-squares-helper lst))]\n    [else (error 'sum-squares-error\
    \ \"list contains non-numbers\"))]))\n", "  (if (null? lst)\n      '()\n     \
    \ (+ (square (car lst)) (sum-squares (cdr lst)))))\n", "  (if (empty? lst)\n \
    \     0\n      (+ (* lst (car lst)) (sum-squares (cdr lst)))))\n", "  (if (empty?\
    \ lst)\n      0\n      (+ (square (round (car lst))) (* (sum_squares (cdr lst))\
    \ 2))))\n", "  (let loop ((lst lst) (acc 0))\n    (if (null? lst)\n        acc\n\
    \        (loop (cdr lst)\n              (+ acc\n                  (* acc (ceiling(car\
    \ lst))))))))\n", "  (define (square x)\n    (* x x))\n  (+ (map square lst) (map\
    \ square lst)))\n", "  (if (null? lst) 0\n      (+ (square (ceil (car lst)))\n\
    \         (sum_squares (cdr lst)))))\n</code>\n<|/ a |>\n<| c |>\nThank you very\
    \ much for taking the time to explain it. This was very helpful.\n<|/ c |>\n<|\
    \ c |>\nThis does not answer the question on how to round the values before summing,\
    \ see comment at Raman Pirvu's answer\n<|/ c |>\n<| a dscore=1 |>\nThis is a simple\
    \ solution which is not dependent on any particular programming language. \n<code>",
  "  (define (add-to-sum n sum)\n    (if (number? n) (* n sum)\n        (add-to-sum\
    \ (ceiling n) sum)))\n  (if (number? (car lst))\n      (add-to-sum (car lst) (+\
    \ (car lst) (sum (cdr lst))))\n      (add-to-sum (car lst) (car lst))))\n", " \
    \ (if (null? lst)\n      0\n      (+ (sqr (first lst)) (sum-squares (rest lst)))))\n",
  "  (define (sq x)\n    (* x x))\n  (define (round x m)\n    (+ m\n        (quotient\
    \ x m)\n        (floor x)))\n  (define (ceiling x)\n    (floor x))\n  (let ((m\
    \ (quotient lst 1)))\n    (cond ((> m 0) (+ (sq (round lst m))\n             \
    \           (sq (round lst m))))\n          ((< m 0) (+ (sq 0)\n             \
    \           (sq (round lst m))))\n          ((= m 0) (+ (sq 0)\n             \
    \           (sq 0)))))\n", "  (cond\n    ((empty? lst) 0)\n    ((= 0 (length lst))\
    \ 0)\n    ((< 0 (length lst)) 0)\n    (else (+ (car lst)\n            (sum-squares\
    \ (cdr lst)))))) ; #lang racket\n", "  (let* ((sum (foldr (lambda (x y) (+ x y))\
    \ 0 lst))\n         (rounded-sum (round sum))\n         (squares (map square rounded-sum)))\n\
    \    (if (null? squares)\n        0\n        (foldr (lambda (x y) (+ x y)) 0 squares))))\n\
    </code>\n<|/ a |>\n<| c |>\nHi, thanks for the answer. I think I didn't explain\
    \ myself well enough. I am not looking for the square of each element in the list,\
    \ just the sum of squares of each element in the list. For example, in the example\
    \ I gave in the first comment the expected result is 14.\n<|/ c |>\n<| c |>\n\
    Sorry, I misunderstood the problem then. Edited.\n<|/ c |>\n<| c |>\nYou beat\
    \ me to it.  I used `map` instead of `for`, which is more idiomatic.  Also, the\
    \ round is unnecessary as `+` rounds before adding the squares.\n<|/ c |>\n<|\
    \ c |>\nThanks all. I think that I finally understand. Thanks everyone for your\
    \ help!\n<|/ c |>\n<| a tags=racket,scheme,functional-programming dscore=0 |>\n\
    The simplest solution I can think of is\n<code>", "  (let loop ((lst lst) (acc\
    \ 0))\n    (cond\n      [(empty? lst) acc]\n      [else (loop (rest lst) (+ acc\
    \ (square (first lst))))]))) ;; #lang racket\n", "  (apply + (map (lambda (x)\
    \ (* x x)) lst)))\n", "  (cond\n    ((null? lst) 0)\n    ((even? (car lst)) (cdr\
    \ (car lst)))\n    (else (+ (car lst) (sum-squares\n                      (floor-list\
    \ lst)))))) ;; (car lst) (cdr (car lst))\n                    ;; ^^ ^^ ^^\n",
  "  (if (empty? lst)\n      0\n      (+ (square (round (car (reverse lst)))) (sum-squares\
    \ (reverse lst)))))\n", "  (cond\n    [(empty? lst) 0]\n    [(number? (car lst))\
    \ (* int (car lst) (sum-squares (cdr lst)))]\n    [else (+ (sum-squares lst) (sum-squares\
    \ (cdr lst))))]))\n", "  (cond [(empty? lst) 0]\n        [(number? (car lst))\n\
    \         (* 2 (floor (car lst)))]\n        [else (+ (sum_squares (cdr lst)) (*\
    \ 2 (floor (car lst))))]))\n</cell>\n<code language=racket-student>\n#lang racket\n",
  "  (if (null? lst)\n      0\n      (+ (* (ceiling (first lst))\n          (ceiling\
    \ (first lst)))\n         (sum_squares (rest lst)))))\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [else (+ (square (round (car lst)))\n               (sum-squares\
    \ (cdr lst)))]))\n", "  (cond\n    ((null? lst) 0)\n    ((even? (car lst)) (+\
    \ (car lst) (* 2 (sum-squares (cdr lst))))\n     (if (less? (car lst) 0) (+ (car\
    \ lst) (* 2 (sum-squares (cdr lst))))\n      (+ (* 2 (car lst)) (sum-squares (cdr\
    \ lst)))))\n    ((odd? (car lst)) (+ (car lst) (* 2 (sum-squares (cdr lst))))\n\
    \     (if (less? (car lst) 0) (+ (car lst) (* 2 (sum-squares (cdr lst))))\n  \
    \    (+ (* 2 (car lst)) (sum-squares (cdr lst)))))\n    ((> (car lst) 0) (+ (*\
    \ 2 (car lst)) (sum-squares (cdr lst)))\n     (if (less? (car lst) 0) (+ (* 2\
    \ (car lst)) (sum-squares (cdr lst)))\n      (+ (* 2 (car lst)) (sum-squares (cdr\
    \ lst)))))\n    ((= (car lst) 0) (+ (* 2 (car lst)) (sum-squares (cdr lst)))\n\
    \     (if (less? (car lst) 0) (+ (* 2 (car lst)) (sum-squares (cdr lst)))\n  \
    \    (+ (* 2 (car lst)) (sum-squares (cdr lst)))))\n    (else (sum-squares (cdr\
    \ lst)))))\n", "  (sum-squares-helper lst 0 '()))\n", "  (if (null? lst)\n   \
    \   0\n      (+ (* 0 (floor (car lst)))\n         (* 0 (floor (- (car lst) (cadr\
    \ lst)))))\n  (sum_squares (cdr lst))))\n", "  (define (sum_sq i)\n    (define\
    \ (sqrt-i) (sqrt i))\n    (+ 0 (square-root i sqrt-i)))\n  (reduce + (map (lambda\
    \ (i) (sum_sq i)) lst)))\n", "  (reduce + (map (lambda (x) (* x x)) lst)))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(even? (car lst)) (+ (square car lst) (sum-squares\
    \ (cdr lst)))]\n    [else (+ (square car lst) (sum-squares (cdr lst)))]))\n",
  "  (define (f l acc)\n    (if (null? l)\n        acc\n        (f (rest l) (+ acc\
    \ (* l (first l)))))\n  (f lst 0))\n</code>\n<|/ a tags=scheme,racket dscore=1\
    \ |>\n<| c |>\nNice use of foldl!\n<|/ c |>\n<| a |>\nHere's my solution:\n<code>",
  "  (cond ((null? lst) 0)\n        (else (+ (square (round (car (car lst)))) (sum_squares\
    \ (cdr lst))))))\n</code>\n<|/ a tags=scheme,lisp,racket dscore=1 |>\n<| c |>\n\
    This is not in any way an improvement over my answer, only a more verbose and\
    \ clumsy version of the same thing.\n<|/ c |>\n<| a dscore=0 |>\nThis is one way\
    \ to do it\n<code>", "  (map (lambda (x) (* x (float x)))\n       (round (ceil\
    \ (sum lst))))))\n", "  (define (sum xs)\n    (if (null? xs) 0\n        (+ (car\
    \ xs) (sum (cdr xs)))))\n\n  (define (square xs)\n    (if (null? xs) 0\n     \
    \   (+ (square (car xs)) (square (cdr xs)))))\n\n  (define (round xs)\n    (if\
    \ (null? xs) xs\n        (let ((x (ceiling (car xs))))\n          (cons x (round\
    \ (cdr xs))))))\n\n  (sum (round (map (lambda (x) (square x)) lst)))\n)\n</code>\n\
    <|/ a tags=scheme,racket dscore=2 |>\n<| a |>\nI believe that there are several\
    \ ways of doing it but here is one way. I think it is quite straightforward and\
    \ I think I understood the question correctly.\n<code>", "  (if (empty? lst)\n\
    \      0\n      (+ (first lst)\n         (* 2 (sum-squares (rest lst))))))\n",
  "  (define (aux x y acc)\n    (if (< x y) acc 0)\n    (aux (ceiling x) (sub1 y)\
    \ (+ x acc))))\n\n  (aux 0 lst 0))\n", "  (define (aux xs acc)\n    (if (null?\
    \ xs)\n        acc\n        (aux (cdr xs) (+ acc (* xs (car xs)))))))\n  (aux\
    \ lst 0))\n", "  (let ([sum (apply + (map (lambda (el) (round (* el (el))))\n\
    \                              lst))]\n        [square (map (lambda (el) (round\
    \ (* el el))) lst)])\n    (cond [(null? lst) sum]\n          [(< sum 0) (cond\
    \ [(null? (cdr square)) (+ sum (car square))]\n                             [(<\
    \ (car square) 0) (cond [(null? (cddr square)) (+ sum (car square))]\n       \
    \                                                 [(< (cddr square) 0) (cons sum\
    \ (car square))]\n                                                        [(<\
    \ (cddr square) 1) (sum (car square))]\n                                     \
    \                   [else (sum (car square))])])]\n          [else (cond [(null?\
    \ (cdr square)) (cons sum (car square))]\n                         [(< (car square)\
    \ 0) (cons sum (car square))]\n                         [(< (cddr square) 0) (cons\
    \ sum (car square))]\n                         [(< (cddr square) 1) (sum (car\
    \ square))]\n                         [else (sum (car square))])]\n          [else\
    \ (cond [(null? (cdr square)) (cons sum (car square))]\n                     \
    \    [(< (car square) 0) (cons sum (car square))]\n                         [(<\
    \ (cddr square) 0) (cons sum (car square))]\n                         [(< (cddr\
    \ square) 1) (sum (car square))]\n                         [else (sum (car square))])]\n\
    \          [else (cond [(null? (cdr square)) (cons sum (car square))]\n      \
    \                   [(< (car square) 0) (cons sum (car square))]\n           \
    \              [(< (cddr square) 0) (cons sum (car square))]\n               \
    \          [(< (cddr square) 1) (sum (car square))]\n                        \
    \ [else (sum (car square))])]\n          [else (cons sum (car square))]))\n",
  "  (if (null? lst)\n      0\n      (+ (floor (* lst (first lst)) (first lst))\n\
    \         (sum-squares (rest lst)))))\n", "  (if (null? lst)\n      0\n      (let\
    \ ([square (lambda (n)\n                     (* n\n                        (ceil\
    \ (* n n))))])\n        (+ (sum lst (map square lst)))))) ; The sum function can\
    \ take functions as its argument list\n</code>\n<|/ a tags=scheme dscore=0 |>\n\
    <| c |>\n`ceil`  is part of Scheme - it isn't a standard function in Racket.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe simplest approach might be to change your approach\
    \ a bit. Instead of thinking in terms of \"what can I do and what can I?\" think\
    \ about \"what can I do and how to do it?\" and write some code that does the\
    \ job. Here's some code that does it:\n<code>", "  (if (null? lst)\n      0\n\
    \      (+ \n       (* \n        (ceiling (first lst)) \n        (floor (first\
    \ lst))\n       )\n       (sum_squares (rest lst))\n      )\n    )\n)\n", "  (cond\n\
    \    [(empty? lst) 0]\n    [else (+ (sqr (car lst)) (sum_squares (cdr lst)))]))\n",
  "  (cond\n    [(empty? lst) (error \"empty list\")\n     (+ (* *1 (ceiling (first\
    \ lst))))\n     (sum_squares (rest lst))]\n    [else\n     (+ (+ (ceiling (first\
    \ lst)) (* (first lst) (first lst))) \n        (sum_squares (rest lst)))]))\n",
  "  (define (helper lst acc)\n    (if (null? lst)\n      acc\n      (helper (cdr\
    \ lst)\n              (+ (* (car lst) (car acc))\n                  (sum_squares\
    \ (cdr lst))))))\n  (helper lst 0))\n", "  (map sqr (round (map (lambda (x) (*\
    \ x x)) lst))))\n", "  (sum-square-helper\n   (lambda (lst acc)\n     (if (empty?\
    \ lst)\n         acc\n         (sum-square-helper (cdr lst) (* (car lst) acc))))\n\
    \   lst 0))\n", "  (if (null? lst)\n      '()\n      (+ (* (ceiling (car lst))\
    \ (car lst)) (sum_squares (cdr lst)))))\n", "  (reduce (lambda (sum n)\n     \
    \       (+ (* n n) (round (* sum n)))) lst 0))\n</code>\n<|/ a dscore=0 tags=racket,scheme\
    \ |>\n<| c |>\nWhy should he use `(reduce (lambda (sum n) (+ (* n n) (round (*\
    \ sum n))))` instead of `(apply (lambda (sum n) (+ (* n n) (round (* sum n))))\
    \ lst)`?\n<|/ c |>\n<| c |>\nAgreed. I think the second is clearer.\n<|/ c |>\n\
    <| c |>\nI'm still a bit confused. Why should I use apply instead of reduce here?\
    \ What is wrong with reduce then?\n<|/ c |>\n<| a |>\nA bit of mathematical simplification\
    \ to the above answer:\n<code>", "  (sum-squares-iter lst))\n", "  (let loop ((lst\
    \ lst)\n             (acc 0))\n    (if (null? lst)\n        acc\n        (loop\
    \ (cdr lst)\n              (+ (* (car lst) (car lst))\n                 (loop\
    \ (cdr lst) acc)))))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| c |>\n\
    This fails for negative numbers, i.e. `(sum-squares '(-2 -1 0))` returns `0` instead\
    \ of `1`.\n<|/ c |>\n<| a |>\nHere's a way to do it without mutation, just an\
    \ accumulator that keeps track of the current value:\n<code>", "  (if (null? lst)\n\
    \      0\n      (+ (* lst (* lst (* lst lst)))\n         (round (ceiling (* lst\
    \ (* lst lst)))))))\n", "  (map ceiling (map * lst lst)))\n", "  (cond ((null?\
    \ lst) (quote 0))\n        ((number? (car lst))\n         (+ (* 2 (car lst))\n\
    \            (sum-squares (cdr lst))))\n        (else\n         (sum-squares (append\
    \ lst (list '()))))))\n</code>\n<|/ a tags=scheme,racket dscore=1 |>\n<| c |>\n\
    I did this exercise using recursive functions. My solution was too long to post\
    \ here. But thanks for the answer\n<|/ c |>\n<| c |>\nI posted my solution. Would\
    \ you like to see it?\n<|/ c |>\n<| a tags=scheme,racket |>\nHere is another solution\n\
    <code>", "  (cond\n    [(empty? lst) 0]\n    [else\n     (let ([square (make-integer\
    \ -9999 1))\n           (count (make-integer -9999 1))\n           (square_sum\
    \ (make-integer -9999 0))\n           (sum_sum (make-integer -9999 0))\n     \
    \      (temp_sum (make-integer -9999 0))\n           (temp_square (make-integer\
    \ -9999 0))])\n       (define (loop lst count sum square square_sum sum_sum temp_sum\
    \ temp_square)\n         (cond\n          [(empty? lst) square_sum]\n        \
    \  [else (loop (rest lst)\n                     (add1 count)\n               \
    \      (+ sum square)\n                     (+ square_sum square)\n          \
    \           (+ sum_sum sum)\n                     (+ temp_sum temp_sum)\n    \
    \                 (+ temp_square temp_square)\n                     (loop (rest\
    \ lst)\n                           (add1 count)\n                           (+\
    \ sum square)\n                           (+ square_sum square)\n            \
    \               (+ sum_sum sum)\n                           (+ temp_sum temp_sum)\n\
    \                           (+ temp_square temp_square))))\n       (loop (rest\
    \ lst)\n             count\n             sum\n             square\n          \
    \   square_sum\n             sum_sum\n             temp_sum\n             temp_square)\n\
    \       (if (= (round square_sum) square_sum)\n           (/ sum_sum count)\n\
    \           (/ sum_sum count))]))))\n", "  (sum lst (lambda (x) (* x x))))\n",
  "  (apply + \n    (map sqr (round lst))))\n</code>\n<|/ a tags=scheme,racket |>\n\
    <| c |>\n`round` isn't part of the standard Scheme library, but it's a built-in\
    \ procedure: https://racket-lang.org/docs/guide/builtins.html#(def._((lib._racket%2Flist..rkt)._round))\n\
    <|/ c |>\n<| c |>\nAnd even though the OP doesn't mention it, `map` already does\
    \ what `filter` does: http://www.cs.bham.ac.uk/~jxr/teaching/scheme/racket/filter.html\n\
    <|/ c |>\n<| c |>\n`racket/filter` applies a procedure to each element of a list.\
    \ The OP wants to round each element (as specified by the OP in the comments of\
    \ the question), not eliminate all odd numbers. `racket/filter` does something\
    \ completely different from what `racket/map` does.\n<|/ c |>\n<| c |>\nWhat do\
    \ you mean?\n<|/ c |>\n<| c |>\n`racket/filter` applies a predicate (here `(=\
    \ x (round x))`) to each element of a list, and if it returns `true` then it keeps\
    \ that element. For instance, `filter #(= (round #) 2) (round (list 0 2 3 5 7))`\
    \ returns `(list 0 2 3 5 7)`.\n<|/ c |>\n<| a dscore=0 tags=scheme,racket |>\n\
    Here's a solution I came up with:\n<code>", "  (cond\n    [(empty? lst) 0]\n \
    \   [(member (floor (car lst)) lst) (+ (square (car lst)) (sum_squares (cdr lst)))]\n\
    \    [else (+ (square (car lst)) (sum_squares (cdr lst)))]))\n", "  (cond\n  \
    \  [(empty? lst) 0]\n    [(= 0 (modulo (car lst) 2)) (+ 1 (sum-squares(cdr lst)))]\n\
    \    [else (+ (* (int (car (ceil lst))) (int (car (ceil lst)))))\n          (sum-squares\
    \ (cdr lst))])))\n</code>\n<|/ a dscore=0 |>\n<| a tags=scheme,racket,lisp |>\n\
    Here is a recursive solution:\n<code>", "  (cond\n    ((null? lst) 0)\n    ((equal?\
    \ (first lst) (- (first lst) (first lst)))\n     (cons (cons 0 (- (first lst)\
    \ (first lst))) \n           (sum-squares (rest lst)))\n    (else (+ (* 1 (first\
    \ lst)) (sum-squares (rest lst)))))\n  )\n)\n", "  (define (add lst acc sum)\n\
    \    (if (null? lst)\n        sum\n        (add (cdr lst) (incf sum (* sum acc))\
    \ acc)))\n  (let ((sum (car lst)))\n    (add lst (caddr lst) sum)))\n", "  (cond\n\
    \    [(empty? lst) 0]\n    [(floor (car lst)) (+ 0 (sum-squares (cdr lst)))]\n\
    \    [else (+ (floor (car lst)) (sum-squares (cdr lst)))]))\n", "  (let ((x 0)\n\
    \        (total 0))\n    (for ((i lst) (j lst))\n      (let ((x (* i i)))\n  \
    \      (set! total (+ total (round x))))\n      (set! x (round (* x x)))\n   \
    \   (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (round x))))\n      (set! x (round (+ x (round x))))\n\
    \      (set! x (round (+ x (", "  (if (null? lst)\n      0\n      (+ (* lst (*\
    \ lst (/ lst 2))) (* (round lst) (int-ceiling (round lst))))))\n", "  (cond ((null?\
    \ lst)\n         0)\n        ((< 0 (ceil (car lst)))\n         (+ (* (ceil (car\
    \ lst)) (ceil (car lst)))\n            (sum-squares (cdr lst))))\n        (else\n\
    \         (+ (* (ceil (car lst)) (ceil (car lst)))\n            (sum-squares (cdr\
    \ lst))))))\n", "  (if (null? lst)\n      0\n      (+ (* (round-up lst (ceiling\
    \ lst))\n           (round-up lst (floor-down lst)))\n         (sum-squares (cdr\
    \ lst)))))\n", "  (reduce (lambda (x y) (+ x y)) lst))\n", "  (define (sum_squares\
    \ lst)\n    (cond ((null? lst) 0)\n          ((= (car lst) (ceiling (car lst)))\n\
    \           (+ (* (car lst) (ceiling (car lst)))\n              (sum_squares (cdr\
    \ lst))))\n          (else\n           (+ (* (car lst) (ceiling (car lst)))\n\
    \              (sum_squares (cdr lst))))))\n  (define (ceiling x)\n    (ceiling\
    \ x 2))\n\n  (sum_squares lst))\n", "  (if (null? lst)\n      '()\n      (+ (square\
    \ (round (car lst))) (sum-squares (cdr lst)))))\n</code>\n<|/ a |>\n<| c |>\n\
    I get the error `#lang racket`\n<|/ c |>\n<| c |>\nSorry I did forget to add `#lang\
    \ racket` to my question. Added now.\n<|/ c |>\n<| c |>\nI still get an error:\
    \ http://pastebin.com/6qjQqQj3\n<|/ c |>\n<| c |>\nI tested in DrRacket. It gave\
    \ the correct answers for all the test cases I tested.\n<|/ c |>\n<| c |>\nI have\
    \ updated my answer with a shorter solution using recursion without `round`\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nThe code can be written like this:\n<code>",
  "  (if (null? lst)\n      0\n      (+ \n       (* (ceiling (first lst)) (ceiling\
    \ (first lst)))\n       (+ (* 2 (first lst)) (* 3 (first lst)))))) ;; (+ ... )\n",
  "  (cond\n    [(empty? lst) 0]\n    [else\n     (+ (round (car (car lst))) (sum_squares\
    \ (cdr lst)))]))\n", "  (define (round x)\n    (cond [(= x 0)\n           x]\n\
    \          [(< x 0)\n           (expt x 2)]\n          [else (round (expt x 2))]))\n\
    \  (define (square-up x)\n    (cond [(< x 0)\n           0]\n          [(= x 0)\n\
    \           1]\n          [else\n           (+ (round x) (square-up (- x 1)))]))\n\
    \  (define (square x)\n    (square-up (square-up x)))\n  (reduce (lambda (x y)\n\
    \            (+ (square (- y x)) (square y)))\n          lst)\n)\n", "  (sum (map\
    \ sqr lst)))\n", "  (if (null? lst)\n      0\n      (+ (* 0 (floor (car lst))\n\
    \           (floor (car lst)))\n         (sum_squares (cdr lst)))))\n", "  (if\
    \ (empty? lst)\n      0\n      (+ (* 1 (floor lst floor))\n         (* 1 (+ (lst\
    \ ceiling) (floor lst))\n              (* 1 (lst ceiling) (floor lst))))))\n",
  "  (define (helper (lst acc)\n    (cond [(null? lst) acc]\n          [(number? (car\
    \ lst)) (helper (cdr lst) (* (+ (car lst) (* acc acc)) acc)]\n          [else\
    \ (helper (cdr lst) (+ (car lst) acc))]))\n  (helper lst 0))\n", "  (if (null?\
    \ lst)\n      0\n      (+ (* 1 (round (car lst)))\n         (sum_squares (cdr\
    \ lst)))))\n", "  (cond\n    [(empty? lst) 0]\n    [(member? (car lst) lst) (+\
    \ (* 2 (ceiling (car lst)))\n                          (sum-squares (cdr lst)))]\n\
    \    [else (sum-squares (cdr lst))]))\n</code>\n<|/ a tags=scheme |>\n<| c |>\n\
    I forgot to mention that my professor does not allow us to use built in procedures.\
    \  This may have something to do with the fact that my professor does not understand\
    \ functional programming. He is quite incompetent and he doesn't know that Scheme\
    \ is a functional language. My teacher has given us some hints in which we could\
    \ solve this problem, however he does not allow us to use the built in procedures.\
    \ However, thank you for the answer!\n<|/ c |>\n<| c |>\n: I really wonder how\
    \ you come up with that kind of requirement. Are you asking your professor because\
    \ he is very uncomfortable with using built-in procedures for some reason, or\
    \ did he have another reason? If it's the latter, I would strongly suggest revising\
    \ your teacher's mind and learning some functional programming before you go any\
    \ further.\n<|/ c |>\n<| c |>\nYeah, it sounds like the teacher wanted to make\
    \ sure you had a solid grasp of what functions do, and what the syntax and semantics\
    \ would be.\n<|/ c |>\n<| c |>\nI agree with you entirely.  However, this teacher\
    \ doesn't know much about functional programming so he probably doesn't understand\
    \ the concept of functions.  I am a beginner to Scheme and I thought this could\
    \ be a good opportunity to learn, however as I stated above, I can't use built-in\
    \ procedures.\n<|/ c |>\n<| c |>\n: Well, that teacher is obviously not interested\
    \ in teaching you anything about functional programming. I was trying to help\
    \ you understand what you're actually asking for. By the way, it's easy to get\
    \ in trouble when you try to do something that your teacher insists you not do\
    \ \u2014 it's good that it happens to you, and I understand where you're coming\
    \ from, but it's not good that you get in the habit of doing it.\n<|/ c |>\n<|\
    \ a dscore=0 tags=scheme |>\n<code>", "  (let loop ((lst lst) (acc 0))\n    (cond\
    \ ((null? lst) acc)\n          ((list? (car lst))\n           (loop (cdr lst)\
    \ (+ acc (square (round (car lst))))))\n          ((number? (car lst))\n     \
    \      (loop (cdr lst) (+ acc (square (round (car lst)))))) ; no need for round\
    \ here\n          (else\n           (loop (cdr lst) (+ acc (square (car lst))))))))\
    \ ;; unreachable\n", "  (let ((square-sum (make-sum (ceiling (apply + (map sq\
    \ lst))) 'int)))\n    (apply + (map ceiling (map square lst)))))\n", "  (apply\
    \ + (map (\u03BB (x)\n                  (* x x))\n                 lst)))\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYou should use a `fold` instead of an `apply`.\n<|/\
    \ c |>\n<| c |>\nI am not able to understand the use of fold,can you please tell\
    \ me the code with fold\n<|/ c |>\n<| c |>\nI gave you an example of how to use\
    \ a fold instead of an apply, if you haven't learned about folds yet, I highly\
    \ suggest you read [the documentation](http://docs.racket-lang.org/reference/fold.html)\
    \ for folds. The syntax is very easy to understand.\n<|/ c |>\n<| c |>\nI am able\
    \ to understand the syntax,but my question is how the fold will help to find the\
    \ sum of the squared numbers,as i am unable to understand how fold will help to\
    \ find the sum of the squared numbers,can you please help me to understand this\n\
    <|/ c |>\n<| c |>\nThe fold function simply takes a function of two arguments\
    \ and applies it successively to all the elements of an input list until it reaches\
    \ the end of the list. In this case, it applies the function to all the elements,\
    \ square them, then adds them up. The `fold` function returns an accumulated value\
    \ of the same type as the input list. Since `lst` is a list of numbers, the accumulated\
    \ value will be a number.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (let loop ((lst\
    \ lst) (sum '() sum (reverse sum)))\n    (cond [(empty? lst) 0]\n          [(integer?\
    \ (car lst)) (+ (square (car lst)) sum)]\n          [else (loop (cdr lst) (add1\
    \ sum (square car lst)) (add1 sum (car lst)))])))\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis code doesn't work for negative numbers. I believe this part should\
    \ be changed: \n`[(integer? (car lst)) (+ (square (car lst)) sum)]`\n<|/ c |>\n\
    <| a tags=racket,scheme dscore=1 |>\nAnother answer using recursion with the sqrt\
    \ function and applying it to each element of the list:\n<code>", "  (let loop\
    \ ((lst lst) (acc 0))\n    (if (null? lst)\n        acc\n        (loop (rest lst)\
    \ (+ acc (* ** (caar lst) 2))))))\n", "  (if (null? lst)\n      '(0)\n      (+\
    \ (square (round (car lst)))\n         (sum_squares (cdr lst)))))\n", "  (define\
    \ (sum lst)\n    (cond\n      [(null? lst) 0]\n      [(positive? (car lst)) (+\
    \ (car lst) (sum (cdr lst)))]))\n  (define (sqr-sum lst)\n    (cond\n      [(null?\
    \ lst) 0]\n      [(positive? (car lst)) (+ (sqr (car lst)) (sqr-sum (cdr lst)))]))\n\
    \  (define (round lst n)\n    (cond\n      [(null? lst) lst]\n      [else (cons\
    \ (round (car lst) (- n 1)) (round (cdr lst) n))])))\n  (if (and (not (null? lst))\n\
    \           (not (null? (cdr lst)))\n           (positive? (car lst)))\n     \
    \ (+ (round (car lst) 0) (sqr-sum (round (cdr lst) 0)))\n      (sqr-sum (round\
    \ (cdr lst) 0))))\n", "  (sum-squares (round lst #t)))\n", "  (if (empty? lst)\n\
    \      0\n      (+ (expt (round (car lst)) 2)\n         (sum-squares (cdr lst)))))\n\
    </code>\n<|/ a dscore=2 tags=lisp,racket,scheme,sicp |>\n<| c |>\nThanks for answering!\
    \ I really liked the way you solved it but I wasn't able to understand the recursion.\
    \ I tried reading some books on lisp but wasn't able to understand it too much.\
    \ I will try to understand your solution and try to follow it step by step. Thanks\
    \ again!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (if (empty? lst)\n      0\n\
    \      (+ (first lst) (square (floor (second lst) (Ceiling))))))\n</code>\n<|/\
    \ a tags=scheme,racket,lisp dscore=0 |>\n<| c |>\nWhy are you adding this to the\
    \ code posted in the question? It is an answer.\n<|/ c |>\n<| c |>\nI added this\
    \ answer to the question because the question was too long for comments and answers\
    \ sections. In general I thought this question was an answer, because the question\
    \ is about a basic Scheme question. I thought this answer would help others.\n\
    <|/ c |>\n<| c |>\nAs a general rule, answering questions in the question section\
    \ is fine. However, the question should have been posted as an answer, not as\
    \ a question. Not everyone has the time (or opportunity) to remember the question,\
    \ and answering it in the question section makes it harder for everyone.\n<|/\
    \ c |>\n<| c |>\nThe question was posted as a question, because I wanted to know\
    \ how it could be done in scheme and to learn how it could be done with racket\
    \ and lisp. As you can see in the question there are more people that know racket\
    \ and lisp than me. But if you think that it is not an answer to the question,\
    \ I will remove it from the question. Thanks\n<|/ c |>\n<| c |>\nI understand,\
    \ but I wanted to help the people who need it. I also think that this question\
    \ is not an answer but a question and the problem was solved. But your answer\
    \ was still very helpful. Thanks!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (define\
    \ (f x)\n    (square (round x))\n  )\n  (sum-of lst f)\n)\n", "  (if (null? lst)\n\
    \      0\n      (+ (* 0 (floor (* lst (car lst)))) \n         (sum-squares (cdr\
    \ lst)))))\n", "  (if (null? lst)\n      0\n      (+ (round (* lst (car lst)))\
    \ \n         (sum-squares (cdr lst)))))\n", "  (let loop ((lst lst) (acc 0))\n\
    \    (if (null? lst)\n        acc\n        (loop (rest lst) (+ acc (* lst (car\
    \ lst)))))))\n", "  (cond\n    [(empty? lst) 0]\n    [(cons? lst) (+ (square (car\
    \ lst))\n                    (sum_squares (cdr lst)))]\n    [else (+ (square (round\
    \ (car lst)))\n              (sum_squares (round (cdr lst))))]))\n", "  (let ([sum\
    \ (sum-sq lst)] \n        [square (map (lambda (x)\n                      (round\
    \ x (/ x 2)) #'/ lst))])\n    (+ sum (reduce (fold + square) 0 lst))))\n</code>\n\
    <|/ a tags=racket,scheme,sum,list |>\n<| a dscore=0 |>\n<code>", "  (cond\n  \
    \  [(empty? lst)\n     0]\n    [else\n     (+ (first lst) (second lst) (sum_squares\
    \ (rest lst)))]))\n", "  (cond\n    [(empty? lst) 0]\n    [else (+ (* (car lst)\
    \ (car lst)) (sum_squares (cdr lst)))]))\n", "  (define (loop lst)\n    (if (null?\
    \ lst)\n        0\n        (+ (sq (car lst)) (loop (cdr lst)))))\n  (loop lst))\n",
  "  (define (square-up lst)\n    (let loop ((acc 0)\n               (arr lst))\n\
    \      (if (null? arr)\n          acc\n          (loop (+ (* acc acc) (first arr))\n\
    \                (rest arr)))))\n  (square-up (ceil lst)))\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [else (+ (round (first lst)) (sum_squares (rest lst)))]))\n", " \
    \ (if (null? lst)\n      0\n      (+ 0 (map (lambda (n) (round (* n n)) lst))))))\n\
    </code>\n<|/ a |>\n<| c |>\nThank you, that was very helpful, I will test my code\
    \ against your answer. I am also interested in learning how to do this problem\
    \ using a recursive solution, what is the best way to learn about these?\n<|/\
    \ c |>\n<| a tags=racket,scheme |>\nHere's a solution with tail recursion:\n<code>",
  "  (cond\n    [(empty? lst) 0]\n    [else\n     (+ (* 0.5 (ceiling (first lst))\
    \ (first lst)) (sum_squares (rest lst)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
