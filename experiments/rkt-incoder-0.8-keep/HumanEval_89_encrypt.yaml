name: HumanEval_89_encrypt
language: rkt
prompt: "#lang racket\n\n;; Create a function encrypt that takes a string as an argument\
  \ and\n;; returns a string encrypted with the alphabet being rotated. \n;; The alphabet\
  \ should be rotated in a manner such that the letters \n;; shift down by two multiplied\
  \ to two places.\n;; For example:\n;; encrypt('hi') returns 'lm'\n;; encrypt('asdfghjkl')\
  \ returns 'ewhjklnop'\n;; encrypt('gf') returns 'kj'\n;; encrypt('et') returns 'ix'\n\
  (define (encrypt s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n\
  \    (check-equal? (candidate \"hi\") \"lm\")\n    (check-equal? (candidate \"asdfghjkl\"\
  ) \"ewhjklnop\")\n    (check-equal? (candidate \"gf\") \"kj\")\n    (check-equal?\
  \ (candidate \"et\") \"ix\")\n    (check-equal? (candidate \"faewfawefaewg\") \"\
  jeiajeaijeiak\")\n    (check-equal? (candidate \"hellomyfriend\") \"lippsqcjvmirh\"\
  )\n    (check-equal? (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ) \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    (check-equal? (candidate\
  \ \"a\") \"e\")\n))\n\n(test-humaneval)"
completions: ["  (cond \n    [(null? s) \"\"]\n    [(empty? s) \"\"]\n    [else\n\
    \     (let loop ((s (substring s 0 (char-count s))) (acc (char-count s))\n   \
    \             (shift (- shift 2) (- shift 2)))\n       (cond\n         [(< shift\
    \ 2) (cons s acc)]\n         [(< shift 3) (loop (substring s (char-count s)) (cons\
    \ (char-code (car acc)) acc) (shift (- shift 3)))]\n         [(< shift 4) (loop\
    \ (substring s (char-count s)) (cons (char-code (car acc)) acc) (shift (- shift\
    \ 4)))]\n         [(< shift 5) (loop (substring s (char-count s)) (cons (char-code\
    \ (car acc)) acc) (shift (- shift 5)))]\n         [(< shift 6) (loop (substring\
    \ s (char-count s)) (cons (char-code (car acc)) acc) (shift (- shift 6)))]\n \
    \        [(< shift 7) (loop (substring s (char-count s)) (cons (char-code (car\
    \ acc)) acc) (shift (- shift 7)))]\n         [(< shift 8) (loop (substring s (char-count\
    \ s)) (cons (char-code (car acc)) acc) (shift (- shift 8)))]\n         [(< shift\
    \ 9) (loop (substring s (char-count s)) (cons (char-code (car acc)) acc) (shift\
    \ (- shift 9)))]\n         [(< shift 10) (loop (substring s (char-count s)) (cons\
    \ (char-code (car acc)) acc) (shift (- shift 10)))]\n         [(< shift 11) (loop\
    \ (substring s (char-count s)) (cons (char-code (car acc)) acc) (shift (- shift\
    \ 11)))]\n         [(< shift 12) (loop (substring s (char-count s)) (cons (char-code\
    \ (car acc)) acc) (shift (- shift 12)))]\n         [(< shift 13) (loop (substring\
    \ s (char-count s)) (cons (char-code (car acc)) acc) (shift (- shift 13)))]\n\
    \         [(< shift 14) (loop (substring s (char-count s)) (cons (char-code (car\
    \ acc)) acc) (shift (- shift 14)))]\n         [(< shift 15) (loop (substring s\
    \ (char-count s)) (cons (char-code (c", "  (cond [(< s (string-length alphabet))\
    \ (string alphabet)]\n        [else (string-append (substring s 0 (- s (string-length\
    \ alphabet))) (substring alphabet 0 (- s (string-length alphabet)) 2))]))\n",
  "  ;; Create an empty list.\n  (define (append lst1 lst2)\n    (if (null? lst1)\n\
    \        lst2\n        (append (rest lst1) (list (first lst2)))))\n\n  ;; Rotate\
    \ the alphabet.\n  (define (rotate lst)\n    (if (null? lst)\n        '()\n  \
    \      (append (list (first lst))\n                (rotate (rest lst)))))\n\n\
    \  ;; Combine the two steps to create a rotated string.\n  (rotate (rotate (list\
    \ (car s))))\n)\n", "  (loop for i from (length s) downto 0\n\tcollect (list (char->integer\
    \ (char->integer s[i]) 2)\n\t\t\t\t(char->integer #\\0 2))\n\tinto rotated\n\t\
    collect (list (char->integer #\\0 2)\n\t\t\t\t(char->integer s[(- i 1)] 2))\n\t\
    into shifted\n\tcollect (if (char->integer s[i] 2)\n\t\t\t\t\t(cons (+ i 1) shifted)\n\
    \t\t\t\t\t(cons (- i 1) rotated)))\n)\n", "  (let ((alph (make-array 26 :initial-element\
    \ #\\)))\n    (let ((place 0))\n      (do ((char s (inc place))\n           (place\
    \ (inc place)))\n          ((= (length char) 0)\n           (set! alph (rotate-array\
    \ alph 'left))))\n      (let ((result \"\") (i 0))\n        (do ((char alph (inc\
    \ i))\n             (place (inc place)))\n          ((or (eq? char #\\)\n    \
    \          (eq? char #\\))\n           (set! result (string result char)))\n \
    \         (let ((place (inc place)))\n            (set! i (inc i)))\n        \
    \  (set! result (string result (char (char (subseq char 0 place) \n          \
    \                                      (char (subseq char place (subseq char 0\
    \ place)) \n                                                  (char (subseq char\
    \ place (subseq char place (subseq char 0 place))) \n                        \
    \                          (char (subseq char place (subseq char place (subseq\
    \ char place (subseq char 0 place))) \n                                      \
    \            (char (subseq char place (subseq char place (subseq char place (subseq\
    \ char 0 place))) \n                                                  (char (subseq\
    \ char place (subseq char place (subseq char place (subseq char 0 place))) \n\
    \                                                  (char (subseq char place (subseq\
    \ char place (subseq char place (subseq char 0 place))) \n                   \
    \                               (char (subseq char place (subseq char place (subseq\
    \ char place (subseq char place (subseq char 0 place))) \n                   \
    \                               (char (subseq char place (subseq char place (subseq\
    \ char place (subseq char place (subseq char 0 place)))))))))))))))))))))))))))))))))))))))))))))))\n",
  "  (cond [(empty? s)'']\n        [(= (length s) 1) (substring (char s (char s 0))\n\
    \                               (* (- 2 (length s)) \n                       \
    \          (length (substring (char s (char s 0)) \n                         \
    \                      (* (+ 2 (length s)) \n                                \
    \                (length (char s (char s 0)))))))]\n        [else (cons (encrypt\n\
    \                       (substring (char s (char s 0)) \n                    \
    \           (* (- 1 (length s)) \n                                 (length (substring\
    \ (char s (char s 0)) \n                                               (* (+ 1\
    \ (length s)) \n                                                (length (char\
    \ s (char s 0))))))) \n                      (encrypt \n                     \
    \  (substring (char s (char s 0)) \n                               (* (- 2 (length\
    \ s)) \n                                 (length (substring (char s (char s 0))\
    \ \n                                               (* (+ 2 (length s)) \n    \
    \                                            (length (char s (char s 0))))))))]))\n\
    </code>\n<|/ a |>\n<| a tags=scheme,lisp,racket,functional-programming |>\nHere\
    \ is a Scheme implementation I wrote for myself that doesn't use any libraries\
    \ (but might still be useful as a reference):\n<code>", "  (let ([l '()])\n  \
    \  (for/or ([c #\\a] [c #\\b] [c #\\c] [c #\\d] [c #\\e]\n             [c #\\\
    f] [c #\\g] [c #\\h] [c #\\i] [c #\\j]\n             [c #\\k] [c #\\l] [c #\\\
    m] [c #\\n] [c #\\o]\n             [c #\\p] [c #\\q] [c #\\r] [c #\\s] [c #\\\
    t]\n             [c #\\v] [c #\\w] [c #\\y] [c #\\z] [c #\\0]]\n            (not\
    \ (empty? l))\n          (let ([char (char->integer (c)))]\n            (set!\
    \ l (append (cons char (list char)) l))\n            (set! l (append (cons char\
    \ (list char)) l))\n            (set! l (append (cons char (list char)) l))\n\
    \            (set! l (append (cons char (list char)) l))\n            (set! l\
    \ (append (cons char (list char)) l))\n            (set! l (append (cons char\
    \ (list char)) l))\n            (set! l (append (cons char (list char)) l))\n\
    \            (set! l (append (cons char (list char)) l))\n            (set! l\
    \ (append (cons char (list char)) l))\n            (set! l (append (cons char\
    \ (list char)) l))\n            (set! l (append (cons char (list char)) l))\n\
    \            (set! l (append (cons char (list char)) l))\n            (set! l\
    \ (append (cons char (list char)) l))\n            (set! l (append (cons char\
    \ (list char)) l))\n            (set! l (append (cons char (list char)) l))\n\
    \            (set! l (append (cons char (list char)) l))\n            (set! l\
    \ (append (cons char (list char)) l))\n            (set! l (append (cons char\
    \ (list char)) l))\n            (set! l (append (cons char (list char)) l))\n\
    \            (set! l (append (cons char (list char)) l))\n            (set! l\
    \ (append (con", "  ;; Encode the string into an integer so we can use rotate\
    \ and modulo.\n  (define (encode s)\n    (foldl (lambda (c x)\n             (*\
    \ 26 (char->integer c))\n             (char->integer x))\n         0\n       \
    \  s))\n  ;; Rotate the string.\n  (define (rotate x)\n    (foldl (lambda (c y)\n\
    \             (let ((x (char->integer c)))\n               (let ((y (char->integer\
    \ y)))\n                 (* y x)\n                 (- x y))\n               (char->integer\
    \ y)))\n         0\n         x))\n  (define (encrypt s)\n    (rotate\n     ((encode\
    \ s) (- 26 s)) \n     (- s 26)))\n  encrypt)\n", "  (let ((alphabet (create-alphabet\
    \ s)))\n    (loop for i from 0 to (length s) by 2\n          collect (substring\
    \ alphabet i (+ i (length alphabet))))))\n</code>\nThe rotate procedure below\
    \ does the same thing as your rotate procedure but rotates down rather than upwards.\n\
    <code>", "  (let ([alpha (char->list\n               'a b c d e f g h i j k l\
    \ m n o p q r s t u v w x y z)]\n        [alpha (substring alpha (length alphabet)\
    \ 1)])\n    (append (substring s 0 2)\n            (map car\n                \
    \ (map (lambda (c) (substring c 1 -1))\n                       (substring s (+\
    \ 2 1) (length s)))\n                 alpha)\n            (substring s (+ 2 1)\
    \ (length s)))))\n", "  (cond [(empty? s) '']\n        [(= (length s) 1) (list-ref\
    \ (list s-a s-a s-a) (modulo (length (string->list s))))] \n        [else (cons\
    \ (list-ref (list-tail (string->list s) (modulo (length (string->list s))))\n\
    \                        (encrypt (list-tail (string->list s) (modulo (length\
    \ (string->list s)))))) \n        ]))\n", "  (let loop ((s (string->list s))\n\
    \             (alpha '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n\
    \    (cond\n      [(null? s) (list '())]\n      [else (loop (cdr s) (append (car\
    \ s)\n                                (list (substring alpha (+ 0 (car (car s)))))))])))\n\
    </code>\nThe code can be improved by using the built-in functions map and fold\
    \ and also by removing the if statements from loop and by using let instead of\
    \ cond. \n<code>", "  (cond [(= (length s) 1) s]\n        [(< 0 (remainder (modulo\
    \ (length s) 26) 2)) s]\n        [else (cons (char->symbol (char->number (first\
    \ s)) \n                     (char->symbol (char->number (rest (first s)))))\n\
    \                   (encrypt (rest (first s))))]))\n", "  (if (empty? s) \n  \
    \    '\n      (let ((chars (string->list s))\n            (chars-len (string->length\
    \ s)))\n        (if (= chars-len (length chars))\n            (list '())\n   \
    \         (let ((char (first chars))\n                  (chars (rest chars))\n\
    \                  (alpha (first (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n                  (alpha-len (string->length alpha)))\n              (cond\
    \ ((char-or-null? char) (list char))\n                    (else (let ((alpha (first\
    \ (string->list \"abcdefghijklmnopqrstuvwxyz\"))))\n                         \
    \  (cond ((char-or-null? char) (list char))\n                                (else\
    \ (let ((char (first (string->list char))))\n                                \
    \        (cond ((char-or-null? char) (list char))\n                          \
    \                    (else (let ((alpha (first (string->list char)))) \n     \
    \                                                (list char (encrypt (substring\
    \ (concat alpha (substring alpha-len 0 alpha-len (- alpha-len 2)) (- alpha-len\
    \ 2) alpha-len (- alpha-len 2)))))\n                                         \
    \          )\n                                          )\n                  \
    \                     )\n                                )\n                 \
    \          )\n                    )\n              )\n            )\n      )\n\
    \  )\n)\n", "  (cond \n    [(empty? s) s]\n    [else\n     (append (rotate-string\
    \ s 26) \n            (rotate-string (rest s) -26))]))", "  (cond\n    ((empty?\
    \ s)'())\n    ((= (length s) 1) (char s (substring s 0 (- (length s) 1) ) ))\n\
    \    ((char-lessp (char-at (substring s 0 (- (length s) 1) )) (char-at (substring\
    \ s 0 (- (length s) 1) ))) (char s (substring s 0 (- (length s) 1) ) ))\n    ((char-eq?\
    \ (char-at (substring s 0 (- (length s) 1) )) (char-at (substring s 0 (- (length\
    \ s) 1) ))) (char s (substring s 0 (- (length s) 1) ) ))\n    (else (cons (char\
    \ (+ (char-at (substring s 0 (- (length s) 1) )) 1) (char (+ (char-at (substring\
    \ s 0 (- (length s) 1) )) 2) (char (+ (char-at (substring s 0 (- (length s) 1)\
    \ )) 3) (char (+ (char-at (substring s 0 (- (length s) 1) )) 4)) (char (+ (char-at\
    \ (substring s 0 (- (length s) 1) )) 5)) (char (+ (char-at (substring s 0 (- (length\
    \ s) 1) )) 6)) (char (+ (char-at (substring s 0 (- (length s) 1) )) 7)) (char\
    \ (+ (char-at (substring s 0 (- (length s) 1) )) 8)) (char (+ (char-at (substring\
    \ s 0 (- (length s) 1) )) 9))\n  ))\n)\n", "  (let ((alph (list 'a 'b 'c 'd 'e\
    \ 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p)))\n    (let ((rot1 (list 'b c d e f g h i\
    \ j k l m n o p)))\n      (cond [(empty? s) \"\"]\n            [(< 1 (length alph))\
    \ (error 'invalid-char alph)]\n            [else (cons (car alph) (cons (car rot1)\
    \ (cons (car alph) (cons (cdr rot1) (cons (cdr alph) (cons (cdr rot1) (cons (car\
    \ alph) (cons (car rot1) (cons (car alph) (cdr alph)))))\n                   \
    \                                                                            \
    \         (encrypt (cdr s))))))]))))\n", "  (let loop ((s s)\n             (acc\
    \ '()))\n    (cond [(empty? s) (append acc (list '()))]\n          [(char=? (car\
    \ s) 'a) (append acc (list 'z))\n           (loop (cdr s)\n                 (cons\
    \ (char s (+ 0 (char->int (caar acc))) 'z)\n                       acc))]\n  \
    \        [(char=? (car s) 'b) (append acc (list 'v))\n           (loop (cdr s)\n\
    \                 (cons (char s (+ 0 (char->int (caar acc))) 'v)\n           \
    \            acc))]\n          [(char=? (car s) 'c) (append acc (list 'w))\n \
    \          (loop (cdr s)\n                 (cons (char s (+ 0 (char->int (caar\
    \ acc))) 'w)\n                       acc))]\n          [(char=? (car s) 'd) (append\
    \ acc (list 'x))\n           (loop (cdr s)\n                 (cons (char s (+\
    \ 0 (char->int (caar acc))) 'x)\n                       acc))]\n          [(char=?\
    \ (car s) 'e) (append acc (list 'y))\n           (loop (cdr s)\n             \
    \    (cons (char s (+ 0 (char->int (caar acc))) 'y)\n                       acc))]\n\
    \          [(char=? (car s) 'f) (append acc (list 'z))\n           (loop (cdr\
    \ s)\n                 (cons (char s (+ 0 (char->int (caar acc))) 'z)\n      \
    \                 acc))]\n          [(char=? (car s) 'g) (append acc (list 'j))\n\
    \           (loop (cdr s)\n                 (cons (char s (+ 0 (char->int (caar\
    \ acc))) 'j)\n                       acc))]\n          [(char=? (car s) 'h) (append\
    \ acc (list 'k))\n           (loop (cdr s)\n                 (cons (char s (+\
    \ 0 (char->int (caar acc))) 'k)\n                       acc))]\n          [(char=?\
    \ (car s) 'i) (append acc (list 'l))\n           (loop (cdr s)\n             \
    \    (cons (char s (+ 0 (char->int (caar acc))) 'l)\n                       acc))]\n\
    \          [(char=? (car s) 'j) (append acc (list 'm))\n           (loop (cdr\
    \ s)\n                 (cons (char s (+ 0 (char->int (caar acc))) 'm)\n      \
    \                 acc))]", "  (let loop ((s s)\n             (c '(#\\a #\\e #\\\
    i #\\o #\\u #\\y))\n             (r '(#\\c #\\h #\\l #\\m #\\n #\\p))\n      \
    \       (s (r c c c c c c c c c c c c c c c c c c c c c))\n             (i 0))\n\
    \    (cond\n      [(= i 24) s]\n      [else\n       (cond\n         [(= s (r i\
    \ c c c c c c c c c c c c c c c c c c c c c c))\n          (loop (s r ((car c)\
    \ (cadr c) (caaddr c 'u) (caaddr c 'i) (caaddr c 'e) (caaddr c 'o) (caaddr c 'a)\
    \ (caaddr c 'y)))]\n         [(= s (r i c c c c c c c c c c c c c c c c c c c\
    \ c c c))\n          (loop (s r ((car c) (cadr c) (caaddr c 'a) (caaddr c 'o)\
    \ (caaddr c 'u) (caaddr c 'i) (caaddr c 'e) (caaddr c 'y)))]\n         [(= s (r\
    \ i c c c c c c c c c c c c c c c c c c c c c))\n          (loop (s r ((car c)\
    \ (cadr c) (caaddr c 'y) (caaddr c 'o) (caaddr c 'u) (caaddr c 'i) (caaddr c 'e)\
    \ (caaddr c 'a) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr\
    \ c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i)\
    \ (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr\
    \ c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c 'i) (caaddr c '",
  "  (let loop ([s s])\n    (if (empty? s)\n        (list)\n        (let ([c (first\
    \ s)])\n          (set! s (rest s))\n          (append (list->string (reverse\
    \ (append (map rot90 c))) c) loop)))))\n", "  (let* ((a (substring s '(range 65\
    \ 90)) '(range 91 122))\n         (b (substring s '(range 97 122) '(range 65 90))))\n\
    \    (string-append (string-append a (substring a '(range 65 97))\n          \
    \                       (string-append b (substring b '(range 97 122))))\n   \
    \               (string-append a (substring a '(range 97 122))\n             \
    \                    (string-append b (substring b '(range 65 90)))))))\n", " \
    \ (let* ((alpha (make-alphabet '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i\
    \ #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\\
    z)))\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char alphabet)\n  \
    \  (map alpha-char alphabet)\n    (map alpha-char alphabet)\n    (map alpha-char\
    \ alphabet)\n    (map alph", "  (let* ((letters (string->list s))\n         (shift\
    \ (length letters))\n         (results (make-array (+ (* 2 shift) (length letters))\
    \ \n                              :initial-contents empty))\n         (i 0))\n\
    \    (do ((i (- i shift))\n         (letter (string-ref letters i))\n        \
    \ (letter (char->integer (char->string letter))))\n        ((or (>= i 0) (< i\
    \ shift))\n         (set! i (- i shift))\n         (set! letter (char->integer\
    \ (char->string letter)))\n         (vector-push! results letter)\n         (vector-push!\
    \ results (- letter 'a)))\n    (let ((letter (char->integer (char->string s))))\n\
    \      (vector-push! results letter)\n      (vector-push! results (- letter 'a))))\n\
    \  (make-string (string-reverse results))\n  )\n", "  (define (go s acc)\n   \
    \ (if (empty? s) \n        (reverse acc) \n        (go (rest s) (cons (substring\
    \ s 0 1) acc))))\n  (go s '()))", "  (cond [(empty? s) (empty? s)]\n        [(equal?\
    \ (substring s '1) (substring s '0)) (substring s '1)]\n        [else (cons (substring\
    \ s '1)\n                    (encrypt (substring s '0)))))\n</code>\n<|/ a |>\n\
    <| c |>\nYour answer looks nice but as I am new to lisp I am not able to understand\
    \ your code fully. I have no idea on what to do with the last two lines. I tried\
    \ to print them out but getting error on `(print (encrypt \"hello\"))` which says\
    \ that **NIL is not of type LIST.**\n<|/ c |>\n<| c |>\nI am sorry for being so\
    \ stupid. I am new to lisp so this was really a stupid question to ask. Thank\
    \ you so much for your help. I was able to figure it out :)\n<|/ c |>\n<| a tags=lisp,racket,scheme,functional-programming\
    \ |>\nHere is a version which returns the encrypted string. It uses a helper function\
    \ that builds a rotation map from the given alphabet:\n<code>", "    (let loop\
    \ ((s s) (result '()))\n        (if (empty? s)\n            result\n         \
    \   (loop (cdr s) (cons (rotate-char (car s)) result)))))\n", "  (cond [(empty?\
    \ s) \"\"]\n        [else (set! \n                 (substring s (- (string-length\
    \ s) 1) (string-length s)) \n                 (substring s 0 (- (string-length\
    \ s) 1))\n                 (substring s 0 (- (string-length s) 1)))\n        \
    \      (append (encrypt (substring s (- (string-length s) 1))) \n            \
    \          (append (encrypt (substring s 0 (- (string-length s) 1))) \n      \
    \                        (append (encrypt (substring s 0 (- (string-length s)\
    \ 1))) \n                                      (append (encrypt (substring s 0\
    \ (- (string-length s) 1))) \n                                              (encrypt\
    \ (substring s 0 (- (string-length s) 1))))))\n              (append (encrypt\
    \ (substring s (- (string-length s) 1))) \n                      (append (encrypt\
    \ (substring s 0 (- (string-length s) 1))) \n                              (append\
    \ (encrypt (substring s 0 (- (string-length s) 1))) \n                       \
    \               (append (encrypt (substring s 0 (- (string-length s) 1))) \n \
    \                                             (encrypt (substring s 0 (- (string-length\
    \ s) 1))))))\n              (append (encrypt (substring s (- (string-length s)\
    \ 1))) \n                      (append (encrypt (substring s 0 (- (string-length\
    \ s) 1))) \n                              (append (encrypt (substring s 0 (- (string-length\
    \ s) 1))) \n                                      (append (encrypt (substring\
    \ s 0 (- (string-length s) 1))) \n                                           \
    \   (encrypt (substring s 0 (- (string-length s) 1))))))\n              (append\
    \ (encrypt (substring s (- (string-length s) 1))) \n                      (append\
    \ (encrypt (substring s 0 (- (string-length s) 1))) \n                       \
    \       (append (encrypt (substring s 0 (- (string-length s) 1))) \n         \
    \                             (append (encrypt (substring s 0 (- (string-length\
    \ s) 1))) \n                                              (encrypt (substring\
    \ s 0 (- (string-length s) 1))))))\n              (append (encrypt (substring\
    \ s (- (string-length s) 1))) \n                      (append (encrypt (substring\
    \ s 0 (- (string-length s) 1))) \n                              (append (encrypt\
    \ (substring s 0 (- (string-length s) 1))) \n                                \
    \      (append (encrypt (substring s 0 (- (string-length s) 1))) \n          \
    \                                    (encrypt (substring s 0 (- (string-length\
    \ s) 1))))))\n              (append (encrypt (substring s (- (string-length s)\
    \ 1))) \n                      (append (encrypt (", "  (let ([alpha (alphabet)]\n\
    \        [rot-alpha (rotate-alphabet alpha (add-to-alphabet 'a 2))])\n    (map\
    \ (lambda (x)\n           (cond [(char=? x 'a) (alpha-char rot-alpha (add-to-alphabet\
    \ 'a 2))]\n                 [(char=? x 'b) (alpha-char rot-alpha (add-to-alphabet\
    \ 'b 2))]\n                 [(char=? x 'c) (alpha-char rot-alpha (add-to-alphabet\
    \ 'c 2))]\n                 [(char=? x 'd) (alpha-char rot-alpha (add-to-alphabet\
    \ 'd 2))]\n                 [(char=? x 'e) (alpha-char rot-alpha (add-to-alphabet\
    \ 'e 2))]\n                 [(char=? x 'f) (alpha-char rot-alpha (add-to-alphabet\
    \ 'f 2))]\n                 [(char=? x 'g) (alpha-char rot-alpha (add-to-alphabet\
    \ 'g 2))]\n                 [(char=? x 'h) (alpha-char rot-alpha (add-to-alphabet\
    \ 'h 2))]\n                 [(char=? x 'i) (alpha-char rot-alpha (add-to-alphabet\
    \ 'i 2))]\n                 [(char=? x 'j) (alpha-char rot-alpha (add-to-alphabet\
    \ 'j 2))]\n                 [(char=? x 'k) (alpha-char rot-alpha (add-to-alphabet\
    \ 'k 2))]\n                 [(char=? x 'l) (alpha-char rot-alpha (add-to-alphabet\
    \ 'l 2))]\n                 [(char=? x 'm) (alpha-char rot-alpha (add-to-alphabet\
    \ 'm 2))]\n                 [(char=? x 'n) (alpha-char rot-alpha (add-to-alphabet\
    \ 'n 2))]\n                 [(char=? x 'o) (alpha-char rot-alpha (add-to-alphabet\
    \ 'o 2))]\n                 [(char=? x 'p) (alpha-char rot-alpha (add-to-alphabet\
    \ 'p 2))]\n                 [(char=? x 'q) (alpha-char rot-alpha (add-to-alphabet\
    \ 'q 2))]\n                 [(char=? x 'r) (alpha-char rot-alpha (add-to-alphabet\
    \ 'r 2))]\n                 [(char=? x 's) (alpha-char rot-alpha (add-to-alphabet\
    \ 's 2))]\n                 ", "  (cond\n    [(empty? s) s]\n    [else\n     (let\
    \ ((c (string->char (char-code (first s)))))\n       (if (char-alphabetic? c)\n\
    \           (string-append\n            (escape-alphabet-char (string->char (char-alphabetic->char\
    \ (char-code c)))))\n           (string-append\n            (encrypt (substring\
    \ s 0 (char-length c)))))))]))\n", "  (let ((alpha (make-string 26))\n       \
    \ (current-char (substring (s 0) 1))\n        (index (modulo (- 26 26) 26))\n\
    \        (alpha-index (modulo (- 26 26) 26)))\n    (set! alpha (substring (alpha-list\
    \ alphabet) alpha-index))\n    (loop\n       with index from 0\n       with alpha-index\
    \ from 0\n       for current-char in alphabet\n       for index from 0\n     \
    \  until (equal? current-char (substring (alpha-list alphabet) alpha-index))\n\
    \       do\n         (set! alpha-index (+ alpha-index 2))\n         (set! alpha\
    \ (substring (alpha-list alphabet) alpha-index))\n         (set! alpha-index (modulo\
    \ (+ alpha-index 26) 26))\n         (set! alpha (substring (alpha-list alphabet)\
    \ alpha-index))\n         return (concat alpha (substring s index) current-char))\n\
    \    (substring s (- index 1))))\n", "  (let ((alphabet (list 'a 'b 'c 'd 'e 'f\
    \ 'g 'h 'i)))\n    (map (lambda (c)\n           (let ((idx (modulo (length (alphabet))\
    \ (length (string-length s)))))\n             (cond\n               ((< idx (length\
    \ (alphabet)))\n                (substring alphabet (- idx (length (alphabet)))))\n\
    \               ((= idx 0)\n                (substring alphabet 0))\n        \
    \       (else\n                (substring alphabet idx))))\n         s))))\n",
  "  (string-append (cons (substring s 0 (string-length s) - 1) \n               \
    \       (substring s 1 (string-length s) - 1))\n                  (encrypt (string-append\
    \ (substring s 2 (string-length s) - 1) \n                                   \
    \   (substring s 0 (string-length s) - 1)))))\n", "  ;; Your code here\n  (displayln\
    \ s)\n  (let loop ((letters (char->string s))\n             (result (make-string\
    \ (string-length letters)))\n             (i 0))\n    (cond\n      [(string=?\
    \ letters \"\") result]\n      [(string=? letters result) \"\"]\n      [(string=?\
    \ (substring letters 0 (string-length letters)) \"z\") (append (substring letters\
    \ 0 (string-length letters)) \"a\")\n       (loop (substring letters 1 (string-length\
    \ letters)) \"a\" (i+1))]\n      [(string=? (substring letters 0 (string-length\
    \ letters)) \"a\") (append (substring letters 0 (string-length letters)) \"b\"\
    )\n       (loop (substring letters 1 (string-length letters)) \"b\" (i+1))]\n\
    \      [(string=? (substring letters 0 (string-length letters)) \"b\") (append\
    \ (substring letters 0 (string-length letters)) \"c\")\n       (loop (substring\
    \ letters 1 (string-length letters)) \"c\" (i+1))]\n      [(string=? (substring\
    \ letters 0 (string-length letters)) \"c\") (append (substring letters 0 (string-length\
    \ letters)) \"d\")\n       (loop (substring letters 1 (string-length letters))\
    \ \"d\" (i+1))]\n      [(string=? (substring letters 0 (string-length letters))\
    \ \"d\") (append (substring letters 0 (string-length letters)) \"e\")\n      \
    \ (loop (substring letters 1 (string-length letters)) \"e\" (i+1))]\n      [(string=?\
    \ (substring letters 0 (string-length letters)) \"e\") (append (substring letters\
    \ 0 (string-length letters)) \"f\")\n       (loop (substring letters 1 (string-length\
    \ letters)) \"f\" (i+1))]\n      [(string=? (substring letters 0 (string-length\
    \ letters)) \"f\") (append (substring letters 0 (string-length letters)) \"g\"\
    )\n       (loop (substring letters 1 (string-length letters)) \"g\" (i+1))]\n\
    \      [(string=? (substring letters 0 (string-length letters)) \"g\") (append\
    \ (substring letters 0 (string-length letters)) \"h\")\n       (loop (substring\
    \ letters 1 (string-length letters)) \"h\" (i+1))]\n      [(string=? (substring\
    \ letters 0 (string-length letters)) \"h\") (append (substring letters 0 (", " \
    \ (encrypt s '(a b c d e f g h i j k l m n o p q r s t u v w x y z))\n  (encrypt\
    \ s '(a b c d e f g h i j k l m n o p q r s t u v w x y z a)))\n", "  (let loop\
    \ ((s s)\n             (k 0))\n    (cond\n      [(null? s) (list '())]\n     \
    \ [(= (length s) 0) (list '())]\n      [(char=? (first s) #\\A) (loop (rest s)\
    \ (k (+ k 1)))]\n      [else (loop (rest s) (+ k 2))]\n      )\n    )\n  )\n",
  "    (let ((alpha (make-string 26 (quote #\\A))))\n      (let ((temp (make-string\
    \ 26 (quote #\\A))))\n        (dotimes (i (length s))\n          (setf (aref alpha\
    \ i) (char->integer (char->string (car s))))\n          (setf (aref temp i) (char->integer\
    \ (char->string (char->integer (car s))))\n                (setf (aref alpha i)\
    \ (char->integer (char->string (char->integer a)))\n                      (aref\
    \ temp i) (char->integer (char->string (char->integer a)))\n                )\n\
    \          (setf (car s) (setf (aref temp i) (aref alpha i))\n               \
    \ (cdr s) (setf (aref temp i) (aref temp i+1))\n            )\n          )\n \
    \       (setf (encrypt (substring s 0 i)) \n              (substring temp (length\
    \ temp) i) (substring alpha (length alpha) i) (substring alpha (length alpha)\
    \ i+1) \n            )\n        (setf (encrypt (substring s i (length s))) \n\
    \              (substring temp (length temp) i) (substring alpha (length alpha)\
    \ i) (substring alpha (length alpha) i+1) \n            )\n        (setf (encrypt\
    \ (substring s i (length s))) \n              (substring temp (length temp) i)\
    \ (substring alpha (length alpha) i) (substring alpha (length alpha) i+1) \n \
    \           )\n        (setf (encrypt (substring s i (length s))) \n         \
    \     (substring temp (length temp) i) (substring alpha (length alpha) i) (substring\
    \ alpha (length alpha) i+1) \n            )\n        (setf (encrypt (substring\
    \ s i (length s))) \n              (substring temp (length temp) i) (substring\
    \ alpha (length alpha) i) (substring alpha (length alpha) i+1) \n            )\n\
    \        (setf (encrypt (substring s i (length s))) \n              (substring\
    \ temp (length temp) i) (substring alpha (length alpha) i) (substring alpha (length\
    \ alpha) i+1) \n            )\n        (setf (encrypt (substring s i (length s)))\
    \ \n              (substring temp (length temp) i) (substring alpha (length alpha)\
    \ i) (substring alpha (length alpha) i+1) \n            )\n        (setf (encrypt\
    \ (substring s i (length s))) \n              (", "  (if (empty? s)\n      '()\n\
    \      (append-string (map (lambda (c) (cond\n                               \
    \   [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 1)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 2)))]\n                               \
    \   [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 3)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 4)))]\n                               \
    \   [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 5)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 6)))]\n                               \
    \   [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 7)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 8)))]\n                               \
    \   [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 9)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 10)))]\n                              \
    \    [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 11)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 12)))]\n                              \
    \    [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 13)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 14)))]\n                              \
    \    [(char-code c) (char-code (substring s 0 -1) (substring s (- char-code c)\
    \ 15)))]\n                                  [(char-code c) (char-code (substring\
    \ s 0 -1) (substring s (- char-code c) 16)))]\n                              \
    \    [(char-code c) (char-code (substring s 0 ", "  (encrypt s #\\a))\n", "  (if\
    \ (null? s)\n      empty\n      (begin\n       (char->int (first s))\n       (if\
    \ (or (string=? (second s) \"z\") (string=? (second s) \"A\"))\n           (encrypt\
    \ (rest s))\n           (begin \n             (char->int (first s))\n        \
    \     (if (or (string=? (second s) \"z\") (string=? (second s) \"A\"))\n     \
    \            (encrypt (rest s))\n                 (begin \n                  \
    \ (char->int (first s))\n                   (if (or (string=? (second s) \"z\"\
    ) (string=? (second s) \"A\"))\n                       (encrypt (rest s))\n  \
    \                     (begin \n                         (char->int (first s))\n\
    \                         (if (or (string=? (second s) \"z\") (string=? (second\
    \ s) \"A\"))\n                             (encrypt (rest s))\n              \
    \               (begin \n                               (char->int (first s))\n\
    \                               (if (or (string=? (second s) \"z\") (string=?\
    \ (second s) \"A\"))\n                                   (encrypt (rest s))\n\
    \                                   (begin \n                                \
    \     (char->int (first s))\n                                     (if (or (string=?\
    \ (second s) \"z\") (string=? (second s) \"A\"))\n                           \
    \              (encrypt (rest s))\n                                         (begin\
    \ \n                                           (char->int (first s))\n       \
    \                                    (if (or (string=? (second s) \"z\") (string=?\
    \ (second s) \"A\"))\n                                              (encrypt (rest\
    \ s))\n                                              (begin \n               \
    \                                 (char->int (first s))\n                    \
    \                            (if (or (string=? (second s) \"z\") (string=? (second\
    \ s) \"A\"))\n                                                    (encrypt (rest\
    \ s))\n                                                    (begin \n         \
    \                                             (char->int (first s))\n        \
    \                                              (if (or (string=? (second s) \"\
    z\") (string=? (second s) \"A\"))\n                                          \
    \                (encrypt (rest s))\n                                        \
    \                  (begin \n                                                 \
    \           (char->int (first s))\n                                          \
    \                  (if (or (string=? (second s) \"z\") (string=? (second s) \"\
    A\"))\n                                                                (encrypt\
    \ (rest s))\n                                                                (begin\
    \ \n                                                                  (char->int\
    \ (first s))\n                                                               \
    \   (if (or (string=? (second s) \"z\") (string=? (second s) \"A\"))\n       \
    \                                                               (encrypt (rest\
    \ s))\n                                                                      (encrypt\
    \ (cdr s))))\n                                                          (encrypt\
    \ (cdr s))))\n                                                      (encrypt (cdr\
    \ s))))\n                                                   (encrypt (cdr s))))\n\
    \                                             (encrypt (cdr s))))\n          \
    \                               (encrypt ", "  (cond [(= 0 (length s)) \"\"]\n\
    \        [(equal? (substring s 0 1) #\\z) (substring s 1 1)]\n        [else (cons\
    \ (char->int (substring s 0 1)) \n                    (encrypt (substring s 1\
    \ \n                                (+ 2 (length s)))))]))\n", "  (if (empty?\
    \ s) '()\n      (cons (list-ref (list-ref (list s 'z 'h 'j 'k 'm 'l 'n) (remainder\
    \ (length s) 2))\n                  (remainder (length s) 1))\n            (encrypt\
    \ (rest s)))))\n", "  (let ([alphabet\n          (list 'a b c d e f g h i j k\
    \ l m n o p q r s t u v w x y z)])\n    (if (null? s)\n        (list '@)\n   \
    \     ; Rotate the string by adding two letters at a time to the alphabet\n  \
    \      ; and shift the letters down by two multiplied to two places.\n       \
    \ (append (cons (first s) alphabet)\n                (cons (second s) (rotate-letters\
    \ (rest s) alphabet))))))\n  ", "  (if (null? s) '()\n      (cons (char->digit\
    \ (first s))\n            (encrypt (rest (rest s))))))\n</code>\n<|/ a dscore=2\
    \ tags=scheme,racket,recursion |>\n<| a dscore=1 tags=scheme,racket,recursion\
    \ |>\nFor what it's worth, here is a version of this that doesn't use char->digit.\n\
    <code>", "  (define (encrypt s acc)\n    (cond [(empty? s) acc]\n          [else\
    \ (encrypt (cdr s) (cons (char->int (first s)) (cons (char->int (second s)) (cons\
    \ (char->int (third s)) (cons (char->int (fourth s)) (cons (char->int (fifth s))\
    \ (cons (char->int (sixth s)) (cons (char->int (seventh s)) (cons (char->int (eighth\
    \ s)) (cons (char->int (ninth s)) (cons (char->int (tenth s)) (cons (char->int\
    \ (eleventh s)) (cons (char->int (twelfth s)) (cons (char->int (thirteenth s))\
    \ (cons (char->int (fourteenth s)) (cons (char->int (fifteenth s)) (cons (char->int\
    \ (sixteenth s)) (cons (char->int (seventeenth s)) (cons (char->int (eighteenth\
    \ s)) (cons (char->int (nineteenth s)) acc))))))))))))))))))))\n  )\n  (encrypt\
    \ s nil)\n  )\n", "  (define (shift n)\n    (if (< 0 n)\n        (- n (+ 4 (char->integer\
    \ (char->string\n          (substring s 0 n))))))\n    (if (> 4 n)\n        (-\
    \ n (+ 4 (char->integer (char->string\n          (substring s 4 (- n 2)))))))\n\
    \    (if (<= 5 n (+ 4 (char->integer (char->string\n          (substring s 8 (-\
    \ n 2)))))))\n  (let ((alphabet '(\n    (a . 4) (b . 2) (c . 3) (d . 1) (e . 7)\
    \ (f . 6) (g . 5) (h . 0)\n    (i . 9) (j . 8) (k . 7) (l . 6) (m . 5) (n . 4)\
    \ (o . 3) (p . 2)\n    (q . 1) (r . 0) (s . 9) (t . 8) (u . 7) (v . 6) (w . 5)\
    \ (x . 4)\n    (y . 3) (z . 2) ))\n    (define (loop s i)\n      (cond\n     \
    \   [(= i 0) (cons 0 (loop (substring s 0 i) 0))]\n        [(= i 1) (cons 1 (loop\
    \ (substring s 0 i) 0))]\n        [(= i 2) (cons 2 (loop (substring s 0 i) 1))]\n\
    \        [else (let ((c (char->integer (char->string (substring s i 0)))))\n \
    \               (cons c (loop (substring s 0 i) 1))]))]))\n    (loop (reverse\
    \ s) 0))))\n", "  (let loop ((s s) (alpha 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ))\
    \ (ans '()))\n    (cond\n      [(empty? s)\n       (reverse ans)]\n      [else\n\
    \       (loop (substring s 0 (add1 (length s))) (append (map \n             (lambda\
    \ (x)\n               (cond\n                 [(member x (reverse alpha)) \n \
    \                  (substring alpha (quotient (length alpha) 2) \n           \
    \                  (quotient (length alpha) 2))]\n                 [(member (substring\
    \ alpha 0 1) x) \n                   (substring alpha 1 0)]\n                \
    \ [else \n                   (substring alpha 0 0)]))\n             (substring\
    \ s 0 1))) ans)]))))\n", "  (if (null? s) \n      (list s)\n      (let ((current\
    \ (car s))\n            (previous (cadr s)))\n        (let loop ((encrypted (list\
    \ current))\n                   (alpha '(a b c d e f g h i j k l m n o p q r s\
    \ t u v w x y z)))\n          (if (equal? alpha previous)\n              (cons\
    \ current encrypted)\n              (if (> current (length alpha))\n         \
    \         (loop (cons current encrypted) (rotate (subseq alpha 2))) \n       \
    \           (loop (cons current encrypted) (rotate (subseq alpha (- current 1))))))))))\n",
  "  (cond [(empty? s) '']\n        [(and (not(char? (first s))) (char? (first s)))\
    \ (cons (first s) (encrypt (rest s))) (cons (first s) (encrypt (rest s)))]\n \
    \       [else (encrypt (rest s)) (encrypt (first s))]))\n", "  (cond\n    [(empty?\
    \ s) \"\"]\n    [(symbol? (car s)) (car s)]\n    [else (cons (encode-letter \n\
    \                  (encode-number \n                   (char->integer \n     \
    \               (char->string \n                     (char->primitive (first s)))))\n\
    \                  (encrypt (rest s)))]))) \n", "    (cond ((empty? s) s) \n \
    \         ((string=? s \"\") \"\") \n          ((string=? s \"\\n\") \"\")\n \
    \         ((string=? s \"\\r\") \"\")\n          ((string=? s \" \") \"\")\n \
    \         ((string=? s \"\\t\") \"\")\n          (else (concat (map 'rot13 (char->integer\
    \ (string->list (string->char (first s))))) (encrypt (string->rest s))))))\n",
  "  (let ((alph (rotate 'a 'z)))\n    (cond \n      ((empty? s) empty)\n      ((equal?\
    \ (char s 0) alph) empty)\n      ((equal? (char s 0) #\\a) alph)\n      (else\
    \ (cons (char alph (- 2 (length s))) empty)))))\n", "  (cond\n    [(empty? s)\
    \ \"\"]\n    [(equal? (first s) 'g) (cons (first s) (encrypt (rest s)))]\n   \
    \ [else (cons (first s) (encrypt (rest s)))]))\n", "  (string-append (map string-append\
    \ (list (substring s 0 1) (substring s 2 5)) (map string-append (list 'a (b c\
    \ d e f g h i j k l m n o p q r s t u v w x y z))))))\n", "  (let ((alphabet '(a\
    \ b c d e f g h i j k l m n o p q r s t u v w x y z))) \n    (if (null? s)\n \
    \       '()\n        (append\n         (map (lambda (c) (substring (alphabet (cdr\
    \ alphabet)) (- c 1)) alphabet)\n              (map char->integer s))\n      \
    \   (map string->list alphabet))))\n", "  (string-append (reverse (list s s s\
    \ s s s s s)) (reverse (list s s s s s s s s))))\n", "  (cond\n    [(empty? s)\
    \ s]\n    [(eq? (first s) 'a) (cons (second s) (encrypt (subseq s 1)))]\n    [(eq?\
    \ (first s) 'b) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first\
    \ s) 'c) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'd)\
    \ (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'e) (cons\
    \ (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'f) (cons (second\
    \ s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'g) (cons (second s) (encrypt\
    \ (subseq s (+ 1 1)))]\n    [(eq? (first s) 'h) (cons (second s) (encrypt (subseq\
    \ s (+ 1 1)))]\n    [(eq? (first s) 'i) (cons (second s) (encrypt (subseq s (+\
    \ 1 1)))]\n    [(eq? (first s) 'j) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n\
    \    [(eq? (first s) 'k) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq?\
    \ (first s) 'l) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first\
    \ s) 'm) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'n)\
    \ (cons (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'o) (cons\
    \ (second s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'p) (cons (second\
    \ s) (encrypt (subseq s (+ 1 1)))]\n    [(eq? (first s) 'q) (cons (second s) (encrypt\
    \ (subseq s (+ 1 1)))]\n    [(eq? (first s) 'r) (cons (second s) (encrypt (subseq\
    \ s (+ 1 1)))]\n    [(eq? (first s) 's) (cons (second s) (encrypt (subseq s (+\
    \ 1 1)))]\n    [(eq? (first s) 't) (cons (second s) (encrypt (subseq s (+ 1 1)))]\n\
    \    [(eq? (first ", "  (cond\n    [(empty? s) s]\n    [(equal? (first s) 'z)\
    \ (rotate-2 s)]\n    [(equal? (first s) 'a) (rotate-1 s)]\n    [(equal? (first\
    \ s) 'b) (rotate-1 s)]\n    [(equal? (first s) 'c) (rotate-2 s)]\n    [else (rotate-3\
    \ s)]))\n</code>\nThis works in the following way:\n\nThe first statement is checked\
    \ for empty strings, which will return s.\nThen the first character of s is checked\
    \ against 'z', 'a', and 'b'.\nIf the character matches 'z', then 'a' is rotated\
    \ by 1.\nIf the character matches 'a', then 'b' is rotated by 1.\nIf the character\
    \ matches 'b', then 'c' is rotated by 2.\nIf the character matches 'c', then 'd'\
    \ is rotated by 3.\nIf the character does not match any of the characters, then\
    \ 'd' is rotated by 3.\nOtherwise, the character matches 'z', or 'a', or 'b',\
    \ or 'c', and so on.\n\nTo verify this, I ran the following tests:\n<code>\n>\
    \ (decrypt 'lm)\n'hi'\n> (decrypt 'ewhjklnop)\n'asdfghjkl'\n> (decrypt 'kj)\n\
    'gf'\n> (decrypt 'ix)\n'et'\n</code>\nTo improve this code, you can replace each\
    \ of the if statements with an elsif statement and replace else with elseif. \
    \ You can do this by replacing the if statements with either if or elsif depending\
    \ on which behavior you want.\nTo demonstrate this, I replaced the if statement\
    \ with the elsif statement:\n<code>", "  (cond [(= 0 (length s)) s]\n        [(=\
    \ (length s) 1) (first s)\n         (cons (first s) (cons (second s) (encrypt\
    \ (rest s))))]\n        [else (cons (first s) (cons (second s) (encrypt (rest\
    \ s))))]\n  ))\n", "  (let loop ((s s)\n             (enc '() '()))\n    (if (empty?\
    \ s)\n        (reverse (cons (first s) enc))\n        (loop (rest s)\n       \
    \       (cons (first s) enc)))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis implementation\
    \ is very similar to Kyle's but yours has a few other improvements. +1 for the\
    \ explanation and for the functional programming in general. Thanks!\n<|/ c |>\n\
    <| a tags=encryption,string,scheme |>\nA bit late to the party, but another solution\
    \ that is pretty short and uses recursion. I wrote this answer before I saw the\
    \ other (the one with all the comments) so I am just going to throw this out there\
    \ for reference.\n<code>", "  (cond [(= (length s) 0) s]\n        [(> (length\
    \ s) 26) \"\"]\n        [else (let ([s2 \"abcdefghijklmnopqrstuvwxyz\"]) \n  \
    \                (cond [(char->integer (char s (+ char-code (char s (length s)))))\
    \ \n                          (+ (char->integer (char s (+ char-code (char s (length\
    \ s))))) 2)]\n                        [else s2]))]))\n", "  (define (encrypt s\
    \ count)\n    (if (= count 0)\n        s \n        (encrypt (string-append (substring\
    \ s (- count 1)) \n                              (substring s 'a))\n         \
    \         (- count 1))))\n  (encrypt s 'a))\n", "  (define (rot x y)\n    (cond\
    \ [(= y 0) x]\n          [(< y 2) (cons (substring x (* y 2) 2) (rot (substring\
    \ x (* y 2) 2) (- y 1)))]\n          [else (rot (substring x (* y 1) 1) (- y 1))]))\n\
    \  (rot s (length s)))\n", "  (cond [(null? s) \"\"]\n        [else (cons \n \
    \               (substring (list s rot1 rot2 s rot2 s) 0 0)\n                (encrypt\
    \ (substring (list s rot2 rot3 s rot3 s) 0 0))\n                (encrypt (substring\
    \ (list s rot3 rot1 s rot1 s) 0 0)))))", "  (char->string (char->int (make-string\
    \ (length s)\n                                   #\\a\n                      \
    \             #\\b\n                                   #\\c\n                \
    \                   #\\d\n                                   #\\e\n          \
    \                         #\\f\n                                   #\\g\n    \
    \                               #\\h\n                                   #\\i\n\
    \                                   #\\j\n                                   #\\\
    k\n                                   #\\l\n                                 \
    \  #\\m\n                                   #\\n\n                           \
    \        #\\o\n                                   #\\p\n                     \
    \              #\\q\n                                   #\\r\n               \
    \                    #\\s\n                                   #\\t\n         \
    \                          #\\v\n                                   #\\u\n   \
    \                                #\\v\n                                   #\\\
    w\n                                   #\\x\n                                 \
    \  #\\y\n                                   #\\z)))\n  (apply append (map \n \
    \               (lambda (c)\n                  (cond \n                  ((char->int\
    \ c > #\\z) (cons c (reverse (cadr alphabet)))) \n                  ((char->int\
    \ c > #\\y) (cons c (reverse (caddr alphabet)))) \n                  ((char->int\
    \ c > #\\w) (cons c (reverse (cadddr alphabet)))) \n                  ((char->int\
    \ c > #\\x) (cons c (reverse (cadddrr alphabet)))) \n                  ((char->int\
    \ c > #\\u) (cons c (reverse (cadddrur alphabet))))\n                  ((char->int\
    \ c > #\\t) (cons c (reverse (cadddrtrl alphabet))))\n                  ((char->int\
    \ c > #\\r) (cons c (reverse (cadddrtrr alphabet))))\n                  ((char->int\
    \ c > #\\s) (cons c (reverse (cadddrtrsu alphabet))))\n                  ((char->int\
    \ c > #\\f) (cons c (reverse (cadddrtrsuu alphabet))))\n                  ((char->int\
    \ c > #\\g) (cons c (reverse (cadddrtrsuuu alphabet))))\n                  ((char->int\
    \ c > #\\e) (cons c (reverse (cadddrtrsuuuu alphabet))))\n                  ((char->int\
    \ c > #\\d) (cons c (reverse (cadddrtrsuuuuu alphabet))))\n                  ((char->int\
    \ c > #\\c) (cons c (reverse (cadddrtrsuuuuuu alphabet))))\n                 \
    \ ((char->int c > #\\b) (cons c (reverse (cadddrtrsuuuuuuuu alphabet))))\n   \
    \               ((char->int c > #\\a) (cons c (", "  (cond\n    [(empty? s) \"\
    \"]\n    [else (append (list (modulo (char->digit (first s)) 26))\n          \
    \          (cons (modulo (char->digit (first s)) 26) \n                      \
    \     (encrypt (rest s))))]))) \n", "  (define (encrypt s)\n    (if (null? s)\n\
    \        s\n        (cond [(char-lower? (char s 0)) (char-upper? (char s 0))]\n\
    \              [(char-upper? (char s 0)) (char-lower? (char s 0))]\n         \
    \     [else (cons (char (char-upper? (char s 0)) (char (char-lower? (char s 0))))\n\
    \                        (encrypt (substring s (+ 2 1)))]\n              )))\n\
    \  (encrypt s))\n", "  (if (empty? s) '')\n  (let ([c (first (string->list (string->char\
    \ s)))]\n        [l (length (string->list (string->char s)))])\n    (let\n   \
    \   [(s (string->list s))]\n      (let\n        [(a (string->list (string->char\
    \ s 0)))]\n        (let \n          [(b (string->list (string->char s 1)))]\n\
    \          (let\n            [(m (let [\n                    (if (equal? (char->int\
    \ (car a)) 65)\n                        0\n                        (if (equal?\
    \ (char->int (car a)) 66)\n                            1\n                   \
    \         (if (equal? (char->int (car a)) 67)\n                              \
    \  2\n                                3))]\n                  (+ \n          \
    \        (* m (- l 2)\n                      (cond\n                        [(<\
    \ m 0)\n                         (cond\n                           [(< l 1)\n\
    \                             (cond\n                                [(< c 0)\n\
    \                                 'a']\n                                [(< c\
    \ 26)\n                                 'a']\n                               \
    \ [(< c 27)\n                                 'b']\n                         \
    \       [(< c 30)\n                                 'c']\n                   \
    \             [(< c 31)\n                                 'd']\n             \
    \                   [(< c 32)\n                                 'e']\n       \
    \                         [(< c 33)\n                                 'f']\n \
    \                               [(< c 34)\n                                 'g']\n\
    \                                [(< c 35)\n                                 'h']\n\
    \                                [(< c 36)\n                                 'i']\n\
    \                                [(< c 37)\n                                 'j']\n\
    \                                [(< c 38)\n                                 'k']\n\
    \                                [(< c 39)\n                                 'l']\n\
    \                                [(< c 40)\n                                 'm']\n\
    \                                [(< c 41)\n                                 'n']\n\
    \                                [(< c 42)\n                                 'o']\n\
    \                                [(< c 43)\n                                 'p']\n\
    \                                [(< c 44)\n                                 'q']\n\
    \                                [(< c 45)\n                                 'r']\n\
    \                                [(< c 46)\n                                 's']\n\
    \                                [(< c 47)\n                                 't']\n\
    \                                [(< c 48)\n                                 'u']\n\
    \                                [(< c 49)\n                                 'v']\n\
    \                                [(< c 50)\n                                 'w']\n\
    \                                [(< c 51)\n                                 'x']\n\
    \                                [(< c 52)\n                                 'y']\n\
    \                                [(< c 53)\n                                 'z']\n\
    \                                [(< c 54)\n                                 'A']\n\
    \                                [(< c 55)\n                                 'B']\n\
    \                                [(< c 56)\n                                 'C']\n\
    \                                [(< c ", "  (define (encrypt s a)\n    (if (zero?\
    \ a) s\n      (cons a\n            (encrypt s (- a 1)))))\n\n  (encrypt s 0))\n",
  "  (if (empty? s)\n      '()\n      (append (encrypt (substring s 0 (car s))) (cons\
    \ 'r (substring s (cdr s))))))\n</cell>\n<cell>\n#lang racket\n", "  (cond ((empty?\
    \ s) s)\n        ((char=? (car s) #\\a) (encrypt\n                           \
    \ (rotate-letter (car s)\n                                         #\\a\n    \
    \                                     #\\b\n                                 \
    \        #\\c\n                                         #\\d\n               \
    \                          #\\e\n                                         #\\\
    f\n                                         #\\g\n                           \
    \              #\\h\n                                         #\\i\n         \
    \                                #\\j\n                                      \
    \   #\\k\n                                         #\\l\n                    \
    \                     #\\m\n                                         #\\n\n  \
    \                                       #\\o\n                               \
    \          #\\p\n                                         #\\q\n             \
    \                            #\\r\n                                         #\\\
    s\n                                         #\\t\n                           \
    \              #\\v\n                                         #\\w\n         \
    \                                #\\x\n                                      \
    \   #\\y\n                                         #\\z\n                    \
    \                     #\\A\n                                         #\\B\n  \
    \                                       #\\C\n                               \
    \          #\\D\n                                         #\\E\n             \
    \                            #\\F\n                                         #\\\
    G\n                                         #\\H\n                           \
    \              #\\I\n                                         #\\J\n         \
    \                                #\\K\n                                      \
    \   #\\L\n                                         #\\M\n                    \
    \                     #\\N\n                                         #\\O\n  \
    \                                       #\\P\n                               \
    \          #\\Q\n                                         #\\R\n             \
    \                            #\\S\n                                         #\\\
    T\n                                         #\\V\n                           \
    \              #\\W\n                                         #\\X\n         \
    \                                #\\Y\n                                      \
    \   #\\Z\n                                         #\\1\n                    \
    \                     #\\2\n                                         #\\3\n  \
    \                                       #\\4\n                               \
    \          #\\5\n                                         #\\6\n             \
    \                            #\\7\n                                         #\\\
    8\n                                         #\\9\n                           \
    \              #\\0)\n                             s)\n        ((char=? (car s)\
    \ #\\b) (encrypt\n                            (rotate-letter (car s)\n       \
    \                                  #\\b\n                                    \
    \     #\\a\n                                         #\\c\n                  \
    \                       #\\d\n                                         #\\e\n\
    \                                         #\\f\n                             \
    \            #\\g\n                                         #\\h\n           \
    \                              #\\i\n                                        \
    \ #\\j\n                                         #\\k\n                      \
    \                   #\\l\n                                         #\\m\n    \
    \                                     #\\n\n                                 \
    \        #\\o\n                                         #\\p\n               \
    \                          #\\q\n                                         #\\\
    r\n                                         #\\s\n                           \
    \              #\\t\n                                         #\\v\n         \
    \                                #\\w\n                                      \
    \   #\\x\n                                         #\\y\n                    \
    \                     #\\z\n                                         #\\A\n  \
    \                                       #\\B\n                               \
    \          #\\C\n                                         #\\D\n             \
    \                            #\\E\n                                         #\\\
    F\n                                         #\\G\n                           \
    \              #\\H\n                                         #\\I\n         \
    \                                #\\J\n                                      \
    \   ", "  (cond\n    [(empty? s) \"\"]\n    [(>= (length s) 2)\n     (cons (mod\
    \ s 26) \"\")])\n    (else\n     (let ([letter (char s 0)])\n       (cond\n  \
    \       [(char? (substring s 1 0)) (char-append letter (char s 1))]\n        \
    \ [else (cons letter \n                     (encrypt (substring s (+ 1 )))])]))))\n",
  "  (cond\n    [(empty? s) (error 'encrypt-error \"Encrypt received an empty string.\"\
    )]\n    [(equal? (caar s) 'z) (encrypt (rest s) '(y z x w v u t s r q p))]\n \
    \   [(equal? (caar s) 'w) (encrypt (rest s) '(z w x y v u t s r q p))]\n    [(equal?\
    \ (caar s) 'v) (encrypt (rest s) '(w v x y z s t r q p))]\n    [(equal? (caar\
    \ s) 'u) (encrypt (rest s) '(w v u x y z t r q p))]\n    [(equal? (caar s) 't)\
    \ (encrypt (rest s) '(w v u t x y z r q p))]\n    [(equal? (caar s) 's) (encrypt\
    \ (rest s) '(w v u t s x y z r q))]\n    [(equal? (caar s) 'r) (encrypt (rest\
    \ s) '(w v u t s r x y z q))]\n    [(equal? (caar s) 'q) (encrypt (rest s) '(w\
    \ v u t s r q x y z))]\n    [(equal? (caar s) 'p) (encrypt (rest s) '(w v u t\
    \ s r q p x y))]))\n", "  (cond [(empty? s) '']\n        [(equal? (first s) 'a)\
    \ (rotate-a-2 s)]\n        [(equal? (first s) 'b) (rotate-b-2 s)]\n        [(equal?\
    \ (first s) 'c) (rotate-c-2 s)]\n        [(equal? (first s) 'd) (rotate-d-2 s)]\n\
    \        [(equal? (first s) 'e) (rotate-e-2 s)]\n        [(equal? (first s) 'f)\
    \ (rotate-f-2 s)]\n        [(equal? (first s) 'g) (rotate-g-2 s)]\n        [(equal?\
    \ (first s) 'h) (rotate-h-2 s)]\n        [else (cons (first s) (encrypt (rest\
    \ s))) ]))\n", "  (cond\n    [(empty? s)\n     (string->symbol \"x\")]\n    [(equal?\
    \ (char->symbol s) 'z)\n     (string->symbol \"y\")]\n    [else\n     (string->symbol\
    \ (apply append (map (lambda (letter)\n                                      \
    \   (rotate-letter-down letter 2))\n                                   (string->list\
    \ (string->symbol s)))))]))\n", "  (lambda (x) \n    (lambda (y)\n      (cond\
    \ ((null? y) x)\n            (else (if (char=? (char-after-char (string-ref x\
    \ 0)) y)\n                     (string-append\n                       (string-repeat\
    \ (char-before-char (string-ref x 0)) 2)\n                       (string-append\
    \ x y))\n                     (else (lambda (y)\n                            (lambda\
    \ (x)\n                              (cond ((null? x) x)\n                   \
    \                 ((char=? (char-after-char (string-ref x 0)) y)\n           \
    \                         (string-append\n                                   \
    \  (string-repeat (char-before-char (string-ref x 0)) 2)\n                   \
    \                  (string-append x (string-append y (cdr y)))))\n           \
    \                         ((char=? (char-after-char (string-ref x 0)) y)\n   \
    \                                 (string-append\n                           \
    \          (string-repeat (char-before-char (string-ref x 0)) 2)\n           \
    \                          (string-append x (string-append y (car y))))\n    \
    \                                ((char=? (char-after-char (string-ref x 0)) y)\n\
    \                                    (string-append\n                        \
    \             (string-repeat (char-before-char (string-ref x 0)) 2)\n        \
    \                             (string-append x (string-append y y)))\n       \
    \                             ((char=? (char-after-char (string-ref x 0)) y)\n\
    \                                    (string-append\n                        \
    \             (string-repeat (char-before-char (string-ref x 0)) 2)\n        \
    \                             (string-append x (string-append y (car y)))))\n\
    \                                    ((char=? (char-after-char (string-ref x 0))\
    \ y)\n                                    (string-append\n                   \
    \                  (string-repeat (char-before-char (string-ref x 0)) 2)\n   \
    \                                  (string-append x (string-append y y)))\n  \
    \                                  ((char=? (char-after-char (string-ref x 0))\
    \ y)\n                                    (string-append\n                   \
    \                  (string-repeat (char-before-char (string-ref x 0)) 2)\n   \
    \                                  (string-append x (string-append y (cdr y)))))\n\
    \                                    ((char=? (char-after-char (string-ref x 0))\
    \ y)\n                                    (string-append\n                   \
    \                  (string-repeat (char-before-char (string-ref x 0)) 2)\n   \
    \                                  (string-append x (string-append y (cdr y)))))\n\
    \                                    ((char=? (char-after-char (string-ref x 0))\
    \ y)\n                                    (string-append\n                   \
    \                  (string-repeat (char-before-char (string-ref x 0)) 2)\n   \
    \                                  (string-append x (string-append y (cdr y)))))\n\
    \                                    ", "  (let ((alpha (char->string #\\@)))\n\
    \    (define (rotate-letter c alpha)\n      (cond \n        ((< c 26) (substring\
    \ alpha 0 1)\n         (substring alpha (+ 1 1)))\n        (else (substring alpha\
    \ 0 2)\n              (substring alpha (+ 1 2))))\n      (let ((c (char->integer\
    \ c)))\n        (cond\n          ((< c 26) (rotate-letter c (char->string alpha)))\n\
    \          (else (rotate-letter c (char->string \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )))\n      )\n    )\n    (define (rotate-string s alpha)\n      (map rotate-letter\
    \ s alpha)\n    )\n    (let ((alpha (char->string alpha)))\n      (map (lambda\
    \ (c) (rotate-letter c alpha)) s)\n    )\n  )\n)\n", "  (string-append (encrypt\
    \ (encrypt s) (expt 2 1)) s))\n", "  (cond\n    [(empty? s) \"\"]\n    [else\n\
    \      (let* ((idx (substring s 0 (string-length s)))\n             (new-idx (+\
    \ idx 1)))\n        (cond\n          [(and (= idx 0) (= (length s) 0)) \"\"]\n\
    \          [(char=? (char-ref s (- idx 1) 0) ?a) ?a]\n          [(char=? (char-ref\
    \ s (- idx 1) 1) ?b) ?b]\n          [(char=? (char-ref s (- idx 1) 2) ?c) ?c]\n\
    \          [(char=? (char-ref s (- idx 1) 3) ?d) ?d]\n          [(char=? (char-ref\
    \ s (- idx 1) 4) ?e) ?e]\n          [(char=? (char-ref s (- idx 1) 5) ?f) ?f]\n\
    \          [(char=? (char-ref s (- idx 1) 6) ?g) ?g]\n          [(char=? (char-ref\
    \ s (- idx 1) 7) ?h) ?h]\n          [(char=? (char-ref s (- idx 1) 8) ?i) ?i]\n\
    \          [(char=? (char-ref s (- idx 1) 9) ?j) ?j]\n          [(char=? (char-ref\
    \ s (- idx 1) 10) ?k) ?k]\n          [(char=? (char-ref s (- idx 1) 11) ?l) ?l]\n\
    \          [(char=? (char-ref s (- idx 1) 12) ?m) ?m]\n          [(char=? (char-ref\
    \ s (- idx 1) 13) ?n) ?n]\n          [(char=? (char-ref s (- idx 1) 14) ?o) ?o]\n\
    \          [(char=? (char-ref s (- idx 1) 15) ?p) ?p]\n          [(char=? (char-ref\
    \ s (- idx 1) 16) ?q) ?q]\n          [(char=? (char-ref s (- idx 1) 17) ?r) ?r]\n\
    \          [(char=? (char-ref s (- idx 1) 18) ?s) ?s]\n          [(char=? (char-ref\
    \ s (- idx 1) 19) ?t) ?t]\n          [(char=? (char-ref s (- idx 1) 20) ?u) ?u]\n\
    \          [(char=? (char-ref s (- idx 1) 21) ?v) ?v]\n          [(char=? (char-ref\
    \ s (- idx 1) 22) ?", "  (define (rotate)\n    (cond \n      [(empty? s) empty]\n\
    \      [(equal? (first s) empty) (first s)]\n      [else (cons (first s)\n   \
    \              (rotate (rest s)))]))\n  (rotate s))\n", "  (define (rotate-string\
    \ str)\n    (if (null? str)\n        '()\n        (cons (car str) (rotate-string\n\
    \                        (cdr str)))))\n  (rotate-string (substring s 0 (length\
    \ s))))\n", "  (if (empty? s)\n      s\n      (+ (take s #(char 97) (+ 1 2)) #(char\
    \ 97 97) (+ 1 2)) (encrypt (rest s))))\n    ", "  (cond [(empty? s) '()]\n   \
    \     [(equal? (first s) 'z) (rotate-z '(#\\e #\\h))\n         (rotate-z (rest\
    \ s))]\n        [else (rotate-z (rest s))]))\n", "  (cond [(equal? s \"\") \"\"\
    ]\n        [(list? (car s)) (cons (encrypt (car s)) (encrypt (cdr s)))]\n    \
    \    [else (cons (char-at (char-code (first s)) (+ \n                        \
    \                    (char-code (first s)) 2))\n                   (encrypt (substring\
    \ (second s) 0 2)))]))\n", "    (cond \n        ((null? s) '())\n        ((null?\
    \ (cdr s)) (car s))\n        (else (cons (rotated-letter s 0 '()) \n         \
    \           (encrypt (cdr s)))))) \n", "  (let ([rot1 (list 'a 'b 'c 'd 'e 'f\
    \ 'g 'h 'i 'j 'k 'l 'm 'n\n                     'o 'p 'q 'r 's 't)]\n        [rot2\
    \ (list 'b 'd 'f 'h 'i 'k 'j 'l 'm 'o 'p 'q 's\n                     'r 't 'u)]\n\
    \        [rot3 (list 'c 'e 'h 'k 'j 'm 'o 'p 'q 'r 's 'u 'v\n                \
    \     'w 'x 'y 'z)]\n        [rot4 (list 'd 'f 'g 'h 'i 'j 'm 'n 'o 'p 'q 'r 's\n\
    \                     'u 'v 'w 'x 'y 'z)]\n        [rot5 (list 'e 'h 'g 'j 'k\
    \ 'l 'm 'n 'o 'p 'q 'r 's\n                     'u 'v 'w 'x 'y 'z)]\n        [rot6\
    \ (list 'f 'h 'i 'g 'j 'k 'l 'm 'n 'o 'p 'q 's\n                     'u 'v 'w\
    \ 'x 'y 'z)]\n        [rot7 (list 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's\n   \
    \                  'u 'v 'w 'x 'y 'z)]\n        [rot8 (list 'h 'i 'j 'k 'l 'm\
    \ 'n 'o 'p 'q 'r 's\n                     'u 'v 'w 'x 'y 'z)]\n        [rot9 (list\
    \ 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's \n                     'u 'v 'w 'x 'y 'z)])\n\
    \    (set! rot2 (rotate! rot2 s)\n          rot3 (rotate! rot3 s)\n          rot4\
    \ (rotate! rot4 s)\n          rot5 (rotate! rot5 s)\n          rot6 (rotate! rot6\
    \ s)\n          rot7 (rotate! rot7 s)\n          rot8 (rotate! rot8 s)\n     \
    \     rot9 (rotate! rot9 s)))\n", "  (let ((alphabet '(#\\a (#\\b #\\c (#\\d #\\\
    e (#\\f #\\g (#\\h #\\i (#\\j #\\k (#\\l #\\m (#\\n #\\o (#\\p #\\q (#\\r #\\\
    s (#\\t #\\v (#\\w #\\x (#\\y #\\z))))))))))\n        (r '(#\\1 #\\2 #\\3 #\\\
    4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\10))\n        (str '(#\\1 #\\2 #\\3 #\\4 #\\5 #\\\
    6 #\\7 #\\8 #\\9 #\\10)))\n    (map (lambda (a) (substring s 0 a)) alphabet)\n\
    \    (apply append\n           (map (lambda (c) (substring r 0 c)) alphabet)\n\
    \           (map (lambda (c) (substring r 0 c)) alphabet))\n    (substring str\
    \ 0 len)))\n", "  (let ((alphabet (list->string (sub1 (make-longest-string s)))))\n\
    \    (rotate-letter-by alphabet 2)\n    (string->list alphabet)))\n", "  (let\
    \ ((alpha (make-alphabet)))\n    (let ((alpha-letters (make-alpha-letters)))\n\
    \      (encrypt-helper\n        (encrypt s)\n        alpha\n        alpha-letters\n\
    \        alpha-letters))))\n", "  (cond ((empty? s) s)\n        ((char-lower?\
    \ (first s)) (rotate-letter (first s) 1))\n        (else (cons (first s) (encrypt\
    \ (rest s))))\n        ))\n", "  (if (= (length s) 0) \"\")\n  (let* ((c (rotate\
    \ (first s))))\n    (append (encrypt (cdr s))\n            (list (first c)))))\n",
  "  (let loop ((len (length s)) (result '()))\n    (cond ((zero? len) (reverse result))\n\
    \          ((char=? (char-at s len) 65)\n           (loop (sub1 len) (cons (char-at\
    \ s 'a) result))\n           (loop (sub1 len) (cons (char-at s 'b) result))\n\
    \           (loop (sub1 len) (cons (char-at s 'c) result))\n           (loop (sub1\
    \ len) (cons (char-at s 'd) result))\n           (loop (sub1 len) (cons (char-at\
    \ s 'e) result))\n           (loop (sub1 len) (cons (char-at s 'f) result))\n\
    \           (loop (sub1 len) (cons (char-at s 'g) result))\n           (loop (sub1\
    \ len) (cons (char-at s 'h) result))\n           (loop (sub1 len) (cons (char-at\
    \ s 'i) result))\n           (loop (sub1 len) (cons (char-at s 'j) result))\n\
    \           (loop (sub1 len) (cons (char-at s 'k) result))\n           (loop (sub1\
    \ len) (cons (char-at s 'l) result))\n           (loop (sub1 len) (cons (char-at\
    \ s 'm) result))\n           (loop (sub1 len) (cons (char-at s 'n) result))\n\
    \           (loop (sub1 len) (cons (char-at s 'o) result))\n           (loop (sub1\
    \ len) (cons (char-at s 'p) result))\n           (loop (sub1 len) (cons (char-at\
    \ s 'q) result))\n           (loop (sub1 len) (cons (char-at s 'r) result))\n\
    \           (loop (sub1 len) (cons (char-at s 's) result))\n           (loop (sub1\
    \ len) (cons (char-at s 't) result))\n           (loop (sub1 len) (cons (char-at\
    \ s 'u) result))\n           (loop (sub1 len) (cons (char-at s 'v) result))\n\
    \           (loop (sub1 len) (cons (char-at s 'w) result))\n           (loop (sub1\
    \ len) (cons (char-at s 'x) result))\n           (loop (sub1 len) (cons (char-at\
    \ s 'y) result))\n           (loop (sub1 len) (cons (char-at s 'z) result))\n\
    \          (else \n           (loop (sub", "  (let loop ((s s)\n             (r\
    \ #f)\n             (s s))\n    (cond\n      [(empty? s) (string 'z)]\n      [(char-alphabet\
    \ (car s))\n       (loop (cdr s)\n             (or (= (char-alphabet (car s))\
    \ (char-alphabet (cdr s))) r)\n             (cons (char-alphabet (car s)) (loop\
    \ (cdr s) r s)))]\n      [(char-alphabet (car s)) (loop (cdr s) r (cons (char-alphabet\
    \ (car s)) s)))]\n      [else (loop (cdr s) r (cons (char-alphabet (car s)) s))]))))\n",
  "  (let loop ((letters alphabet)\n             (result (make-array (length s) #:element-type\
    \ 'char)))\n    (for ((i 0 (+ i 1))) (do\n                        (set! i (mod\
    \ i 26))\n                        (set! i (+ i 2))\n                        (set!\
    \ result (vector-set! result i (char-ref letters i))))\n    result))\n", "  (cond\n\
    \    [(empty? s) \"\"]\n    [(member (first s) (list 'a 'b 'c)) (cons (char->int\
    \ 'a) \n                                        (encrypt (substring s 1)))]\n\
    \    [else (cons (char->int (first s)) (encrypt (substring s 1)))]))\n", "  (if\
    \ (or (not (symbol? s)) (zero? s))\n      'z\n      (let ((letter (first s)) (rotated\
    \ (rotate-letter (car s) #:rotated 1)))\n        (cons (if (< letter (- 'a 26))\
    \ (- 'a letter) (+ letter (- 'a 26))) (encrypt (cdr s))))))\n", "  (let loop ((s\
    \ s))\n    (if (empty? s)\n        (string)\n        (string-append\n        \
    \ (string-join (take s alphabet)\n                       (cons 'l (drop s alphabet))\n\
    \                       (loop (drop s 2))))))))\n", "  (let loop [s (string->list\
    \ s)\n           result '()\n           i 0]\n    (cond [(empty? s) result]\n\
    \          [(< i 26)\n           (loop (rest s) (append result (list s-(char->integer\
    \ 'a) (char->integer 'z'))) (i + 2))]\n          [(>= i 26)\n           (loop\
    \ (rest s) (append result (list s-(char->integer 'a') (s-(char->integer 'z'))))\
    \ (+ i (char->integer 'z')))]\n          [(char->integer 'a' < char->integer 'z')\n\
    \           (loop (rest s) (append result (list s-(char->integer 'a') (s-(char->integer\
    \ 'z'))) s-(char->integer 'a'))\n                   (+ i 2))]\n          [else\
    \ \n           (loop (rest s) (append result (list s-(char->integer 'a') (s-(char->integer\
    \ 'z'))) s-(char->integer 'a'))\n                   (+ i 1))]))\n  (reverse result))\n",
  "  (let loop ((x 0) (y '()) (m (make-list 26)))\n    (if (> x 26)\n        (append\
    \ (cons (char->string->int (char->string (char->substring s x 1)))\n         \
    \         y)\n                (loop (+ x 1) (cons x y) m))\n        (cons (char->string->int\
    \ (char->string (char->substring s x 1))) y)\n        (loop (+ x 1) y (cons x\
    \ m)))\n    (loop '() s '())))\n", "  (loop for i from 0 to (length s) by 2\n\
    \        for j from 0 to (length s) - i by 2\n        collect (substring (s i\
    \ j) 0 1)\n  )\n)\n", "  (cond [(empty? s)\n         '']\n        [(member (first\
    \ s) alphabet)\n         (substring (map first alphabet) (length alphabet))]\n\
    \        [else\n         (substring (map first (map (lambda (x) (if (not (member\
    \ (first x) alphabet) x))\n                                           (cons x\
    \ alphabet) alphabet))\n                       (length alphabet))\n         (+\
    \ (encrypt (rest (substring (map first (map (lambda (x) (if (not (member (first\
    \ x) alphabet) x)) \n                                                        \
    \        (cons x alphabet) alphabet))\n                                    (length\
    \ alphabet))))\n            (length (encrypt (first s))))]))) \n", "  (if (string-empty?\
    \ s)\n      '()\n      (append (rotate-string (first s) 'right)\n            \
    \  (encrypt (rest s)))))\n", "  (define (iter char inc)\n    (cond [(= inc 0)\
    \ (substring s (string-length s) 0)]\n          [(char (char-code char)) (char\
    \ (char-code (char-code char)))]\n          [(char (char-code (char-code char)))\
    \ (iter (char inc (+ 1 inc)))]\n          [else (iter char (- inc 1))]))\n  (iter\
    \ 'z (- (string-length s) 1))\n  )\n", "  (define (shift l) \n    (cond\n    \
    \  [(= l 26) (list l)]\n      [else (cons (- l 27) (shift (+ l 1)))]))\n  (let\
    \ loop ((i 0) (x '()))\n    (if (<= i 26)\n        (let ((y (shift((char->integer\
    \ \n                           (string->list (substring s i 1)))\n           \
    \                (+ i (- i 1)))))\n              (if (= i 0)\n               \
    \   (cons (char->integer \n                           (string->list (substring\
    \ s i 1)))\n                         x)\n                  x))\n        (loop\
    \ (+ i 1) (cons i x))))))\n</code>\n<code>\n#lang racket\n", "  (apply append\n\
    \    (map (lambda (x)\n            (concat (rotate-letter (char->digit x)) (concat\
    \ (char->digit x) (char->digit x)))) s))) \n", "  (cond [(empty? s) s]\n     \
    \   [(or (char=? (first (substring s 0 0)) 'z')\n              (char=? (first\
    \ (substring s 0 0)) 'a')\n              (char=? (first (substring s 0 0)) 'b')\n\
    \              (char=? (first (substring s 0 0)) 'c')\n              (char=? (first\
    \ (substring s 0 0)) 'd')\n              (char=? (first (substring s 0 0)) 'e')\n\
    \              (char=? (first (substring s 0 0)) 'f')\n              (char=? (first\
    \ (substring s 0 0)) 'g')\n              (char=? (first (substring s 0 0)) 'h')\n\
    \              (char=? (first (substring s 0 0)) 'i')\n              (char=? (first\
    \ (substring s 0 0)) 'j')\n              (char=? (first (substring s 0 0)) 'k')\n\
    \              (char=? (first (substring s 0 0)) 'l')\n              (char=? (first\
    \ (substring s 0 0)) 'm')\n              (char=? (first (substring s 0 0)) 'n')\n\
    \              (char=? (first (substring s 0 0)) 'o')\n              (char=? (first\
    \ (substring s 0 0)) 'p')\n              (char=? (first (substring s 0 0)) 'q')\n\
    \              (char=? (first (substring s 0 0)) 'r')\n              (char=? (first\
    \ (substring s 0 0)) 's')\n              (char=? (first (substring s 0 0)) 't')\n\
    \              (char=? (first (substring s 0 0)) 'u')\n              (char=? (first\
    \ (substring s 0 0)) 'v')\n              (char=? (first (substring s 0 0)) 'w')\n\
    \              (char=? (first (substring s 0 0)) 'x')\n              (char=? (first\
    \ (substring s 0 0)) 'y')\n              (char=? (first (substring s 0 0)) 'z')\n\
    \              (char=? (first (substring s 0 0)) 'a') (cons (first (substring\
    \ s 0 0)) (reverse (encrypt (rest (substring s 0 0)))))]\n        [(or (char=?\
    \ (first (substring s 0 0)) 'z')\n              (char=? (first (substring s 0\
    \ 0)) 'a')\n              (char=? (first (substring s 0 0)) 'b')\n           \
    \   (char=? (first (substring s 0 0)) 'c')\n              (char=? (first (substring ",
  "  (cond\n    ((null? s) \"\")\n    ((string=? (caar s) \"z\") (cons (cdr s) (cons\
    \ car \n    (list (encrypt\n      (substring (caar s) 0 1))\n      (encrypt (substring\
    \ (caar s) 1 ))))\n    (encrypt (cdr s)))))\n    (else (cons (cadr s) (cons car\
    \ \n    (list (encrypt\n      (substring (caar s) 0 1))\n      (encrypt (substring\
    \ (caar s) 1 ))))))))\n", "  (cond [(zero? s)\n         '']\n        [else\n \
    \        (cons (char (char-code (substring s 0 (string-length s)) \n         \
    \             (char-code (substring s 0 (string-length s)) + 2)\n            \
    \          (char-code (substring s 0 (string-length s)) + 4))\n              \
    \    (encrypt (substring s 0 (string-length s))))]))\n         ]))\n", "  (let\
    \ ((alpha (make-alphabet)))\n    (for-each [c s]\n      (let ((next (alpha-char\
    \ c (alpha-length alpha))))\n        (alpha-set alpha (alpha-length alpha) next))\n\
    \    (alpha-to-string alpha))))\n", "  (cond [(zero? s) \"\"]\n        [else (cons\
    \ (mod ((first s) 26) (length (rest s))) (encrypt (rest s)))]))\n", "  (let loop\
    \ ((s s)\n             (result '()))\n    (if (eq? s \"\")\n        result\n \
    \       (loop (substring s (length s) (length s)) (append result (rot13 s))))))\n",
  "  (let loop ((letters #(#\\a #b #c #d #e #f #g #h #i #j #k #l #m #n #o #p #q #r\
    \ #s #t #u #v) #'())\n             (s s)\n             (char (string s)))\n  \
    \  (if (null? s)\n        s\n        (if (> char (string s))\n            (let\
    \ ((letter (char->integer (car char))) (letters (cdr letters)))\n            \
    \  (if (< letter (car letters))\n                  (loop (cons (car letters) letters)\
    \ (cdr s))\n                  (loop (cons (car letters) letters) (cdr s))))\n\
    \            (let ((letter (char->integer (car char))) (letters (cdr letters)))\n\
    \              (if (< letter (car letters))\n                  (loop (cons (cdr\
    \ letters) letters) (cdr s))\n                  (loop (cons (cdr letters) letters)\
    \ (cdr s)))))))\n</code>\n<|/ a tags=scheme,racket,encryption,racket-student-languages\
    \ dscore=1 |>\n<| c |>\nHi Jack how about if i used the function decrypt for the\
    \ opposite? Would the code be very similar or would you write it differently?\
    \ Would you write it differently or would you use the built in function decrypt?\n\
    <|/ c |>\n<| c |>\nI added a solution using a built-in function.  It would be\
    \ fairly easy to adapt that to also accept an encryption key as well.\n<|/ c |>\n\
    <| c |>\nThanks for that. I get it now. Just a little question. Does it matter\
    \ if the variable names letter and letter have been used twice?\n<|/ c |>\n<|\
    \ c |>\n, in the first let loop (in the second code block) it is just called `letter`\
    \ and `letters`.  In the third let loop (in the second code block) it is also\
    \ called `letter` and `letters`. That is how you differentiate them.  But in the\
    \ second let loop (in the first code block) it is just called `letter` and `letters`.\
    \  I didn't need to change the second let loop (in the first code block).  It\
    \ should just work if you change `let` for `let*`.\n<|/ c |>\n<| c |>\nI changed\
    \ let* to let and it worked perfectly. I hope you don't mind me asking a couple\
    \ of additional questions regarding your ", "  (if (empty? s) s \n      (cond\
    \ ((char=? (char-code (first s)) 'A) (append-str (encrypt-lowercase (substring\
    \ s (- 1 (string-length s)) (- 2 (string-length s))) (substring (substring s (+\
    \ 1 (string-length s)) 1) (* 2 2))))\n            ((char=? (char-code (first s))\
    \ 'Z) (append-str (encrypt-uppercase (substring s (- 1 (string-length s)) (- 2\
    \ (string-length s))) (substring (substring s (+ 1 (string-length s)) 1) (* 2\
    \ 2))))\n            (else (append-str (encrypt-alphabet (substring s (- 1 (string-length\
    \ s)) (- 2 (string-length s))) (substring (substring s (+ 1 (string-length s))\
    \ 1) (* 2 2)))))))) \n", "  (reverse (map string->char (rotate s #\\A))))\n",
  "  (if (string? s) \n      (let ((n (string-length s)))\n        (string-append\n\
    \         (rotate (substring s 0 (+ (* (floor n) 2) \n                       \
    \          (* n 2))))\n         (rotate (substring s (+ 1 \n                 \
    \               (+ (* (floor n) 2) \n                                    (* n\
    \ 2))))\n                  (substring s (+ 1 \n                              \
    \  (+ (* (floor n) 2) \n                                    (* n 2)))))))\n  \
    \    '()))\n", "  (define (cipher s)\n    (cond [(= (length s) 0)\n          \
    \ '']\n          [(equal? (string->list s)\n                    (apply #'append\
    \ (map string->list alphabet)))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (append (map string->list\
    \ alphabet))\n           (append (map string->list alphabet))\n           (append\
    \ (map string->list alphabet))\n           (append (map string->list alphabet))\n\
    \           (append (map string->list alphabet))\n           (", "  (cond [(empty?\
    \ s) \"\"]\n        [(= (length s) 1) (first s)]\n        [else (let [a (first\
    \ s)\n                     (b (encrypt (rest s))\n                     (d (reverse\
    \ (rest s)))\n                     (e (if (char-alphabetic? b) (reverse b) b))\n\
    \                     (f (if (char-alphabetic? d) (reverse d) d)\n           \
    \          (g (if (char-alphabetic? e) (reverse e) e))]\n                 `(,a\
    \ ,g (,f ,g))]))))\n", "  (define (encrypt str rot)\n    (define (encrypt str\
    \ rot)\n      (cond [(empty? str) str]\n            [(= (first str) rot) (str\
    \ rot)\n             (encrypt (rest str) (+ rot 2)\n                   (cons (first\
    \ str) (encrypt (rest str) rot))) ] ))\n    (encrypt s 0))\n  (encrypt s '0))\n",
  "  (cond \n    [(null? s) \"\"]\n    [(eq? (length s) 1) (substring s 0 (modulo\
    \ (length s) 2))]\n    [(eq? (length s) 2) (substring s 1 (modulo (length s) 2))]\n\
    \    [else (substring s 0 (modulo (length s) 2))]))\n", "  (define (encrypt s\
    \ shift)\n    (if (empty? s)\n        (list->string (list))\n        (let ([letter\
    \ (first s)\n                (new-shift (- shift 1))])\n          (cons (case\
    \ letter\n                    (a #\\A)\n                    (c #\\C)\n       \
    \             (g #\\G)\n                    (t) #\\T)\n                (encrypt\
    \ (rest s) new-shift))))))\n  (encrypt s 'zero))\n</cell>\n<text>\nExercise 3\n\
    Decrypt is a variation of encrypt that reverses the process. For example, 'lm'\
    \ becomes 'hi' and so on. Write a definition for the decrypt procedure. Start\
    \ with a decrypt procedure that takes a string as an argument and returns a string\
    \ decrypted with the alphabet being rotated. For example, 'lm' becomes 'hi' and\
    \ so on. The alphabet should be rotated in a manner such that the letters shift\
    \ down by two multiplied to two places.\n\n\n</text>\n<cell>\n#lang racket\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(empty? (rest s)) \"\"]\n    [else (append\
    \ (encrypt (rest s))\n                  (+ (char->integer ?l) (* 2 ?r))\n    \
    \              (char->integer ?r))]))\n", "  (cond\n    [(empty? s) (error \"\
    No argument given\")] \n    [(equal? (first s) 'a) (cond\n                   \
    \    [(equal? (rest s) 'z) (cond\n                                        [(equal?\
    \ (first s) 'a) (cond\n                                                      \
    \      [(equal? (rest s) 'c) (cond\n                                         \
    \                                      [(equal? (first s) 'b) (cond\n        \
    \                                                                            \
    \                [(equal? (rest s) 'd) (cond\n                               \
    \                                                                            \
    \  [(equal? (first s) 'c) (cond\n                                            \
    \                                                                       [(equal?\
    \ (rest s) 'e) (cond\n                                                       \
    \                                                                  [(equal? (first\
    \ s) 'e) (cond\n                                                             \
    \                                                               [(equal? (rest\
    \ s) 'g) (cond\n                                                             \
    \                                                                          [(equal?\
    \ (first s) 'h) (cond\n                                                      \
    \                                                                            \
    \         [(equal? (rest s) 'i) (cond\n                                      \
    \                                                                            \
    \                                           [(equal? (first s) 'i) (cond\n   \
    \                                                                            \
    \                                                                            \
    \    [(equal? (rest s) 'j) (cond\n                                           \
    \                                                                            \
    \                                                       [(equal? (first s) 'k)\
    \ (cond\n                                                                    \
    \                                                                            \
    \                                [(equal? (rest s) 'l) (cond\n               \
    \                                                                            \
    \                                                                            \
    \            [(equal? (first s) 'l) (cond\n                                  \
    \                                                                            \
    \                                                                         [(equal?\
    \ (rest s) 'm) (cond\n                                                       \
    \                                                                            \
    \                                                        [(equal? (first s) 'm)\
    \ (cond\n                                                                    \
    \                                                                            \
    \                                                                 [(equal? (rest\
    \ s) 'n) (cond\n                                                             \
    \                                                                            \
    \                                                                            \
    \               [(equal? (first s) 'n) (cond\n                               \
    \                                                                            \
    \                                                                            \
    \                                                 [(equal? (rest s) 'p) (cond\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \        [(equal? (first s) 'p) (cond\n                                      \
    \                                                                            \
    \                                                                            \
    \                                                   [(equal? (rest s) 'q) (cond\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                [(equal? (first s) 'q) (cond\n                              \
    \                                                                            \
    \                                                                            \
    \                                                                  [(equal? (rest\
    \ s) 'r) (cond\n                                                             \
    \                                                                            \
    \                                                                            \
    \                                       [(equal? (first s) 'r) (cond\n       \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                       [(equal? (rest s) 's) (cond\n        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                        [(equal? (first s) 's)\
    \ (cond\n                                                                    \
    \                                                                            \
    \                                                                            \
    \                                                                            [(equal?\
    \ (rest s) 't) (cond\n                                                       \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                 [(equal? (first s) 't) (cond\n                             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                [(equal? (rest s) 'u) (cond\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \  [(equal? (first s) 'u) (cond\n                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                   [(equal? (rest s) 'v) (cond\n            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                       [(equal?\
    \ (first s) 'v) (cond\n                                                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                             [(equal? (rest s) 'w) (cond\n                  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                [(equal? (first\
    \ s) 'w) (cond\n                                                             \
    \                                                                   ", "  (cond\n\
    \    [(string=? s \"\\n\")\n     (string=? s \"\\r\\n\")\n     (string=? s \"\\\
    r\")\n     (string=? s \"\\n\")]\n    [(string=? s \"\\r\\n\")\n     (string=?\
    \ s \"\\n\")\n     (string=? s \"\\r\")\n     (string=? s \"\\r\\n\")]\n    [(string=?\
    \ s \"\\r\")\n     (string=? s \"\\n\")\n     (string=? s \"\\r\\n\")\n     (string=?\
    \ s \"\\r\")]\n    [else \n     (char->integer (char->symbol s) (lambda (c) \n\
    \                                     (+ (char->integer c) \n                \
    \                         ((integer->char 27) \n                             \
    \              (char->integer c))))])\n  )\n)\n", "  (if (empty? s) (error 'empty\
    \ string)\n      (append (substring s 0 (- #(length s) 2)) (substring s (- #(length\
    \ s) 2) (- #(length s) 2)))))\n</code>\n<|/ a tags=string,racket,functional-programming\
    \ |>\n<| c |>\nI think my brain is just muddled since I started learning `racket`\
    \ last week...\n<|/ c |>\n<| c |>\nI wish people would stop answering questions\
    \ like this, and start answering them right away, rather than editing their questions.\
    \ I see this all the time.\n<|/ c |>\n<| c |>\nI appreciate your time and patience\
    \ to help people who are new to the language. Your answer was very helpful.\n\
    <|/ c |>\n<| c |>\nI tried to apply your solution to `encrypt`, but I don't know\
    \ how you did it exactly. Could you please help me understand that?\n<|/ c |>\n\
    <| c |>\nI just realized I made a mistake in my answer. The code now works fine.\n\
    <|/ c |>\n<| a tags=string,racket,functional-programming dscore=2 |>\n<code>",
  "  (define (shift x k)\n    (if (null? k)\n        '()\n        (cons (car k)\n\
    \              (shift (cdr k) (cdr k))))\n    (cond ((= x 'a) 'b)\n          ((=\
    \ x 'b) 'a)\n          ((= x 'c) 'd)\n          ((= x 'd) 'c)\n          ((= x\
    \ 'e) 'f)\n          ((= x 'f) 'e)\n          ((= x 'g) 'h)\n          ((= x 'h)\
    \ 'g)\n          ((= x 'i) 'j)\n          ((= x 'j) 'i)\n          ((= x 'k) 'l)\n\
    \          ((= x 'l) 'k)\n          ((= x 'm) 'n)\n          ((= x 'n) 'm)\n \
    \         ((= x 'o) 'p)\n          ((= x 'p) 'o)\n          ((= x 'q) 'r)\n  \
    \        ((= x 'r) 'q)\n          ((= x 't) 's)\n          ((= x 's) 't)\n   \
    \       ((= x 'u) 'v)\n          ((= x 'v) 'u)\n          ((= x 'w) 'x)\n    \
    \      ((= x 'x) 'w)\n          ((= x 'y) 'z)\n          ((= x 'z) 'y)\n     \
    \     ((= x 'A) 'B)\n          ((= x 'B) 'A)\n          ((= x 'C) 'D)\n      \
    \    ((= x 'D) 'C)\n          ((= x 'E) 'F)\n          ((= x 'F) 'E)\n       \
    \   ((= x 'G) 'H)\n          ((= x 'H) 'G)\n          ((= x 'I) 'J)\n        \
    \  ((= x 'J) 'I)\n          ((= x 'K) 'L)\n          ((= x 'L) 'K)\n         \
    \ ((= x 'M) 'N)\n          ((= x 'N) 'M)\n          ((= x 'O) 'P)\n          ((=\
    \ x 'P) 'O)\n          ((= x 'Q) 'R)\n          ((= x 'R) 'Q)\n          ((= x\
    \ 'T) 'S)\n          ((= x 'S) 'T)\n          ((= x 'U) 'V)\n          ((= x '",
  "  (define (shift n)\n    (cond [(= n 0) 'z]\n          [(= n 1) 'a]\n         \
    \ [(= n 2) 'b]\n          [(= n 3) 'c]\n          [(= n 4) 'd]\n          [(=\
    \ n 5) 'e]\n          [(= n 6) 'f]\n          [(= n 7) 'g]\n          [(= n 8)\
    \ 'h]\n          [(= n 9) 'i] \n          [(= n 10) 'j]\n          [(= n 11) 'k]\n\
    \          [(= n 12) 'l]\n          [(= n 13) 'm]\n          [(= n 14) 'n]\n \
    \         [(= n 15) 'o]\n          [(= n 16) 'p]\n          [(= n 17) 'q]\n  \
    \        [(= n 18) 'r]\n          [(= n 19) 's]\n          [(= n 20) 't]\n   \
    \       [(= n 21) 'u]\n          [(= n 22) 'v]\n          [(= n 23) 'w]\n    \
    \      [(= n 24) 'x]\n          [(= n 25) 'y]\n          [(= n 26) 'z]\n     \
    \     [(= n 27) 'a]\n          [(= n 28) 'b]\n          [(= n 29) 'c]\n      \
    \    [(= n 30) 'd]\n          [(= n 31) 'e]\n          [(= n 32) 'f]\n       \
    \   [(= n 33) 'g]\n          [(= n 34) 'h]\n          [(= n 35) 'i]\n        \
    \  [(= n 36) 'j]\n          [(= n 37) 'k]\n          [(= n 38) 'l]\n         \
    \ [(= n 39) 'm]\n          [(= n 40) 'n]\n          [(= n 41) 'o]\n          [(=\
    \ n 42) 'p]\n          [(= n 43) 'q]\n          [(= n 44) 'r]\n          [(= n\
    \ 45) 's]\n          [(= n 46) 't]\n          [(= n 47) 'u]\n          [(= n 48)\
    \ 'v]\n          [(= n 49) 'w]\n          [(= n 50) 'x]\n          [(= n 51) 'y]\n\
    \          [(= n 52) 'z]))\n  (", "  (encrypt s rotator))\n", "  (let ((n 0))\n\
    \    (let loop ((s s)\n               (alphabet '(a b c d e f g h i j k l m n\
    \ o p q r s t u v w x y z))\n               (current 0))\n      (cond ((empty?\
    \ s)\n             (string-append alphabet (number->string n)))\n            ((equal?\
    \ (car s) current)\n             (loop (cdr s) alphabet (+ current 2)))\n    \
    \        (else (loop (cdr s)\n                      alphabet (+ current (* (-\
    \ current 1)\n                                        (+ 1 (- (car s) current)))))))))\n",
  "  (let* ((alphabet (make-array 26 :initial-element #\\a)) \n         (rotated (make-array\
    \ 26 :initial-element #\\a))\n         (shift 2)\n         (current (first alphabet))\n\
    \         (char (first s))\n         (result '()))\n    (set! alphabet (rotate-array\
    \ alphabet shift))\n    (do ((i 0 (+ i 1)))\n        ((< i (length alphabet)))\n\
    \      (set! char (cadr alphabet))\n      (set! result (cons char (append result\
    \ (list (+ (first current) (first char) (second char) (third char) (fourth char)\
    \ (fifth char) (sixth char) (seventh char) (eighth char) (tenth char) (eleventh\
    \ char) (twelfth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char) (eighteenth char) (tenteenth char) (eleventeenth char)\
    \ (twelfteenth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char) (eighteenth char) (tenteenth char) (eleventeenth char)\
    \ (twelfteenth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char) (eighteenth char) (tenteenth char) (eleventeenth char)\
    \ (twelfteenth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char) (eighteenth char) (tenteenth char) (eleventeenth char)\
    \ (twelfteenth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char) (eighteenth char) (tenteenth char) (eleventeenth char)\
    \ (twelfteenth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char) (eighteenth char) (tenteenth char) (eleventeenth char)\
    \ (twelfteenth char) (thirteenth char) (fourteenth char) (fifteenth char) (sixteenth\
    \ char) (seventeenth char", "  (cond\n    [(empty? s) s]\n    [else (append (encrypt\
    \ (substring s 0 (length (first s))))\n                 (list rot13 (first s)\n\
    \                         (encrypt (substring s (+ 1 length (first s))))))]))\n",
  "  (string-append (caesar-rotate-string s 'a' 1) (caesar-rotate-string s 'b' 2)\
    \ \n               (caesar-rotate-string s 'c' 3) \n               (caesar-rotate-string\
    \ s 'd' 4) \n               (caesar-rotate-string s 'e' 5) \n               (caesar-rotate-string\
    \ s 'f' 6) \n               (caesar-rotate-string s 'g' 7) \n               (caesar-rotate-string\
    \ s 'h' 8)))\n", "  (let ((r (make-string (nth s 26))))\n    (lambda (x)\n   \
    \   (set! r (nth x (floor (/ x 26)))\n            (set! r (substring r (* 2 (modulo\
    \ x 26))))\n            (set! x (substring x (* 2 (modulo x 26))))\n         \
    \   (r))))\n  (apply map r (cycle s))))\n", "  (cond [(empty? s)\n         (list\
    \ #\\)]\n        [(symbol=? (first s) #\\A)\n         (cons (first s)\n      \
    \        (encrypt (rest s))]\n        [else\n         (cons (first s)\n      \
    \        (encrypt (rest s))]))]))\n", "  (let ((alphabet (list (list 'a 'b) (list\
    \ 'c 'd) (list 'e 'f)\n                          (list 'g 'h) (list 'i 'j) (list\
    \ 'k 'l)\n                          (list 'm 'n) (list 'o 'p) (list 'q 'r)\n \
    \                         (list 's 't) (list 'u 'v) (list 'w 'x)\n           \
    \               (list 'y 'z))))\n    (let loop ((s s)\n               (acc 'z)\
    \ ; Accumulator for current position.\n               (i (string-length s))) ;\
    \ Current position in string.\n      (cond ((equal? i 0) acc)\n            ((equal?\
    \ (char-alphabet (substring s 0 i)) \n                    (char-alphabet (substring\
    \ s '(+ i 1))))\n             (loop (substring s (+ i 1) (i))\n              \
    \    (append acc\n                          (list (substring s (+ i 1) (+ i 2))))\n\
    \                  (+ i 1))\n            (else (loop (substring s i) \n      \
    \                 (append acc\n                              (list (substring\
    \ s i 1))) \n                       (+ i 1))))))))\n", "  (define (rotate-by a\
    \ n)\n    (cond ((= n 0) '())\n          ((odd? n) (cons a (rotate-by (substring\
    \ a 1 (quotient n 2)) (quotient n 2)))\n          (even? n) (cons (substring a\
    \ (quotient n 2)) (rotate-by a (remainder n 2))))\n          (else (rotate-by\
    \ a (quotient n 2)))))\n  (rotate-by s 2))", "  (cond\n    [(empty? s) s]\n  \
    \  [(equal? (first s) 'z) (cons 'z (encrypt (subseq s 1)))]\n    [else (cons (first\
    \ s) (encrypt (subseq s (+ 1 start))))]))\n", "  (char->string (char->int-array\
    \ (map #(define (m x) (rotated (caesar x) 2)) s))))\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=racket,encryption |>\nThe simplest way is to map each letter to its\
    \ ASCII value minus 26 (26 is 'a' and a is subtracted from it). For example in\
    \ JavaScript this would look like:\n<code>\nfunction encrypt(text) {\n    let\
    \ newText = '';\n    for (let i = 0; i < text.length; i++) {\n        newText\
    \ += String.fromCharCode(text.charCodeAt(i) - 26);\n    }\n    return newText;\n\
    }\n</code>\nThis approach is actually a little more efficient that converting\
    \ to an int/char array first. Here's a version using Racket lists:\n<code>", " \
    \ (let ([alphabet\n          (list 'a b c d e f g h i j k l m n o p q r s t u\
    \ v w x y z)])\n    (if (null? s) '()\n        (cons (expt (first alphabet) (length\
    \ alphabet)) (encrypt (rest s))))\n    (encrypt (rest s))))\n", "  (let ((alph\
    \ (make-array 26 (lambda (i v) (char-code (v i) 0)))))\n    (define (rotate x\
    \ c)\n      (if (char=? x c)\n          c\n          (rotate-char (char->integer\
    \ x) c)))\n    (define (rotate-char c d)\n      (let ((newc (char-code c 0)))\n\
    \        (char-code newc 0))\n      (char->string newc))\n    (define (rotate-letter\
    \ a b)\n      (let ((newa (char->string a)))\n        (char->string (interpose\
    \ (lambda (c) (cons (char->string d) c)) newa)))\n    (define (rotate-alph c d)\n\
    \      (let ((newc (char-code c 0)))\n        (char-code newc 0))\n      (char->string\
    \ newc))\n    (define (rotate-alph c d)\n      (let ((newc (char-code c 0)))\n\
    \        (char-code newc 0))\n      (char->string newc))\n    (define (rotate-alph\
    \ c d)\n      (let ((newc (char-code c 0)))\n        (char-code newc 0))\n   \
    \   (char->string newc))\n    (define (rotate-alph c d)\n      (let ((newc (char-code\
    \ c 0)))\n        (char-code newc 0))\n      (char->string newc))\n    (define\
    \ (rotate-alph c d)\n      (let ((newc (char-code c 0)))\n        (char-code newc\
    \ 0))\n      (char->string newc))\n    (define (rotate-alph c d)\n      (let ((newc\
    \ (char-code c 0)))\n        (char-code newc 0))\n      (char->string newc))\n\
    \    (define (rotate-alph c d)\n      (let ((newc (char-code c 0)))\n        (char-code\
    \ newc 0))\n      (char->string newc))\n    (define (rotate-alph c d)\n      (let\
    \ ((newc (char-code c 0)))\n        (char-code newc 0))\n      (char->string newc))\n\
    \    (define (rotate-alph c d)\n      (let ((newc (char-code c 0)))\n        (char-code\
    \ newc 0))\n      (char->string newc))\n    (define (rotate-alph c d)\n      (let\
    \ ((newc (char-code c 0)))\n        (char-code ", "  (let ((letters '(a b c d\
    \ e f g h i j k l m n o p q r s t u v w x y z))\n        (result '()))\n    (cond\
    \ [(empty? s) result]\n          [(< (length (first s)) 26) result]\n        \
    \  [(< 2 (length letters))\n           (encrypt (substring letters 0 (- (length\
    \ (first s)) 2)))]\n          [else \n           (append \n            (encrypt\
    \ (substring letters (* (- (length (first s)) 2) 2) \n                       \
    \            (- (length (first s)) 2)))\n            (encrypt (substring letters\
    \ (* (- (length (first s)) 2) 2) \n                                   2)))]\n\
    \          [(< 2 (length letters))\n           (cons (char (+ (char (first letters)\
    \ +) \n                          (char (first letters) +)) result)]\n        \
    \  [(< 2 (length letters))\n           (append (encrypt (substring letters 0 2))\n\
    \                  (cons (char (+ (char (first letters) +) \n                \
    \                (char (first letters) +)) result)]\n          [else \n      \
    \     (append (encrypt (substring letters 0 2))\n                  (cons (char\
    \ (+ (char (first letters) +) \n                                (char (first letters)\
    \ +)) result)]\n          [(< 2 (length letters))\n           (append (encrypt\
    \ (substring letters 1 2))\n                  (cons (char (+ (char (first letters)\
    \ +) \n                                (char (first letters) +)) result)]\n  \
    \        [else \n           (append (encrypt (substring letters 1 2))\n      \
    \            (cons (char (+ (char (first letters) +) \n                      \
    \          (char (first letters) +)) result)]\n          [(< 2 (length letters))\n\
    \           (append (encrypt (substring letters 2 2))\n                  (cons\
    \ (char (+ (char (first letters) +) \n                                (char (first\
    \ letters) +)) result)]\n          [else \n           (append (encrypt (substring\
    \ letters 2 2))\n                  (cons (char (+ (char (first letters) +) \n\
    \                                (char (first letters) +)) result)]\n        \
    \  [(< 2 (length letters))\n           (append (encrypt (substring letters 3 2))\n\
    \                  (cons (char (+ (char (first letters) +) \n                \
    \                (char (first letters) +)) result)]\n          [else \n      \
    \     (append (encrypt (substring letters 3 2))\n                  ", "  (let\
    \ ((alpha (make-alphabet (length s))))\n    (map (lambda (i)\n           (rotate-alphabet\n\
    \            (char-alphabet alpha (mod i (char-length alpha))))\n          (range\
    \ (length s))))\n    (string-append s (map char-alphabet alpha))))\n", "  (let\
    \ loop ((alphabet (list #\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\\
    k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))\n\
    \             ((index 0) \n               (result \"\")))\n    (if (null? alphabet)\n\
    \        result\n        (loop (rest alphabet)\n               (add1 index)\n\
    \               (concat result \n                         (substring alphabet\
    \ (add1 (- index 2))))))))\n", "  (cond [(empty? s) (list)] \n        [(= (length\
    \ s) 1) (cons (car s) '(#\\0))]\n        [else\n         (cond [(> 2 (length s))\
    \ (encrypt (cdr s))]\n               [(= 1 (length s)) (encrypt (car s))]\n  \
    \             [else\n                (let ([c (cons (car s) '(#\\0))])\n     \
    \              (encrypt (cdr s))\n                   (cons (car s) c))]))]))\n",
  "  (let loop ((count 0) (s s))\n    (if (null? s) \n        s\n        (cond [(<\
    \ (length s) count) (cons s null)]\n              [(null? (rest s)) (cons null\
    \ (loop (+ count 1) (substring s 0 (+ count 1))))]\n              [(= (length\
    \ s) count) (loop (+ count 1) (substring s (- count 1) count))])\n        [(=\
    \ (length s) count) (loop (+ count 1) (encrypt (substring s (- count 1) count)))]\n\
    \        [else (cons (char (char (substring s 0 (+ count 1))) \n             \
    \          (char (char (substring s (- count 1) count))))])\n    )\n  )\n)\n",
  "  (let ((a #\\a))\n    (define (shift-one char)\n      (char (substring a 0 2)\
    \ (char (substring a 1 3) +\n                                    (char (substring\
    \ a 2 4) +\n                                     (char (substring a 3 5) 2))))\n\
    \    (define (shift-two char)\n      (char (substring a 0 2) (char (substring\
    \ a 1 3) +\n                                    (char (substring a 2 4) +\n  \
    \                                   (char (substring a 3 5) +\n              \
    \                                      (char (substring a 4 6) 2))))\n    (define\
    \ (shift-three char)\n      (char (substring a 0 2) (char (substring a 1 3) +\n\
    \                                    (char (substring a 2 4) +\n             \
    \                        (char (substring a 3 5) +\n                         \
    \                           (char (substring a 4 6) +\n                      \
    \                               (char (substring a 5 7) 2))))\n    (define (shift-four\
    \ char)\n      (char (substring a 0 2) (char (substring a 1 3) +\n           \
    \                         (char (substring a 2 4) +\n                        \
    \             (char (substring a 3 5) +\n                                    \
    \                (char (substring a 4 6) +\n                                 \
    \                    (char (substring a 5 7) +\n                             \
    \                        (char (substring a 6 8) 2))))\n    (define (shift-five\
    \ char)\n      (char (substring a 0 2) (char (substring a 1 3) +\n           \
    \                         (char (substring a 2 4) +\n                        \
    \             (char (substring a 3 5) +\n                                    \
    \                (char (substring a 4 6) +\n                                 \
    \                    (char (substring a 5 7) +\n                             \
    \                        (char (substring a 6 8) +\n                         \
    \                            (char (substring a 7 9) 2))))\n    (define (shift-six\
    \ char)\n      (char (substring a 0 2) (char (substring a 1 3) +\n           \
    \                         (char (substring a 2 4) +\n                        \
    \             (char (substring a 3 5) +\n                                    \
    \                (char (substring a 4 6) +\n                                 \
    \                    (char (substring a 5 7) +\n                             \
    \                        (char (substring a 6 8) +\n                         \
    \                            (char (substring a 7 9) +\n                     \
    \                                (char (substring a 8 10) 2))))\n    (define (shift-seven\
    \ char)\n      (char (substring a 0 2) (char (substring a 1 3) +\n           \
    \                         (char (substring a 2 4) +\n                        \
    \             (char (substring a 3 5) +\n                                    \
    \                (char (substring a 4 6) +\n                                 \
    \                    (", "  (cond ((null? s) '())\n        (else (cons (char->list\
    \ (char->string (car s)) 'a') \n                     (encrypt (string->char (substring\
    \ s (+ 3 (string-length s))))))))\n", "  (letrec ([rotate-two-places (lambda (a\
    \ b)\n                                   (cons a (cons b (cons b (cons a '())))))\n\
    \             [rot-by-one   (lambda (a b)\n                               (cons\
    \ a (cons b '())))]\n             [rot-by-two   (lambda (a b)\n              \
    \                 (cons (cons b (cons b '())) (cons b '())))]\n             [rot-by-three\
    \ (lambda (a b)\n                               (cons (cons b (cons b (cons b\
    \ '()))) (cons b '())))]\n             [rot-by-four (lambda (a b)\n          \
    \                     (cons (cons b (cons b (cons b (cons b '())))) (cons b '())))]\n\
    \             [rot-by-five (lambda (a b)\n                               (cons\
    \ (cons b (cons b (cons b (cons b (cons b '())))) (cons b '())))]\n          \
    \   [rot-by-six (lambda (a b)\n                               (cons (cons b (cons\
    \ b (cons b (cons b (cons b (cons b '())))) (cons b '())))) (cons b '())))]\n\
    \             [rot-by-seven (lambda (a b)\n                               (cons\
    \ (cons b (cons b (cons b (cons b (cons b (cons b (cons b (cons b (cons b '()))))\
    \ (cons b '())))) (cons b '())))) (cons b '())))]\n             [rot-by-eight\
    \ (lambda (a b)\n                               (cons (cons b (cons b (cons b\
    \ (cons b (cons b (cons b (cons b (cons b (cons b (cons b (cons b '())))) (cons\
    \ b '())))) (cons b '())))) (cons b '())))]\n             [rot-by-nine (lambda\
    \ (a b)\n                               (cons (cons b (cons b (cons b (cons b\
    \ (cons b (cons b (cons b (cons b (cons b (cons b (cons b (cons b '())))) (",
  "  (cond\n    [(empty? s) \"\"]\n    [(cons? s) (append (map (lambda (l)\n     \
    \                     (cons (char->integer l) \n                             \
    \   (sub (char->integer l) 32)))\n                          (cycle (map char->string\
    \ (cycle (list 'a' \n                                                        \
    \      'b' \n                                                              'c'\
    \ \n                                                              'd' \n     \
    \                                                         'e' \n             \
    \                                                 'f' \n                     \
    \                                         'g' \n                             \
    \                                 'h' \n                                     \
    \                         'i' \n                                             \
    \                 'j' \n                                                     \
    \         'k' \n                                                             \
    \ 'l' \n                                                              'm' \n \
    \                                                             'n' \n         \
    \                                                     'o' \n                 \
    \                                             'p' \n                         \
    \                                     'q' \n                                 \
    \                             'r' \n                                         \
    \                     's' \n                                                 \
    \             't' \n                                                         \
    \     'u' \n                                                              'v'\
    \ \n                                                              'w' \n     \
    \                                                         'x' \n             \
    \                                                 'y' \n                     \
    \                                         'z')))) \"\")]\n    [else (cond [(>\
    \ (length (string->list s)) 16) \"\"]\n                [else (append (map (lambda\
    \ (l)\n                                  (cons (char->integer l) \n          \
    \                              (sub (char->integer l) 32)))\n                \
    \              (cycle (map char->string (map (lambda (c)\n                   \
    \                                           (cond\n                          \
    \                                      [(eq? (char->string c) s) (char->integer\
    \ c)]\n                                                                [else (cdr\
    \ (cdr c))]))\n                                                        (cycle\
    \ (list 'a' \n                                                               \
    \ 'b' \n                                                                'c' \n\
    \                                                                'd' \n      \
    \                                                          'e' \n            \
    \                                                    'f' \n                  \
    \                                              'g' \n                        \
    \                                        'h' \n                              \
    \                                  'i' \n                                    \
    \                            'j' \n                                          \
    \                      'k' \n                                                \
    \                'l' \n                                                      \
    \          'm' \n                                                            \
    \    'n' \n                                                                'o'\
    \ \n                                                                'p' \n   \
    \                                                             'q' \n         \
    \                                                       'r' \n               \
    \                                                 's' \n                     \
    \                                           't' \n                           \
    \                                     'u' \n                                 \
    \                               'v' \n                                       \
    \                         'w' \n                                             \
    \                   'x' \n                                                   \
    \             'y' \n                                                         \
    \       'z'))))) \"\")]))))", "  (if (empty? s) '()\n      (cond [(char-alphabet\
    \ (first s))\n             (let ([letter (char-alphabet (first s))])\n       \
    \        (cond [(null? letter)\n                       (encrypt (rotate-letter\
    \ (first s) 2))]\n                     [else\n                       (encrypt\
    \ (rotate-letter (first s) (+ 1 \n                                           \
    \                letter)))])))]))\n", "    (let* ((alpha (make-alphabet (length\
    \ s) '#\\#)))\n       (map (lambda (i)\n              (let ((a (rev (char alpha\
    \ (- i 2)))))\n                 (printf \"~a\" a)\n                 (set! alpha\
    \ (rotate alpha (+ i 2)))))\n             (range (length s)))))\n      ", "  (let\
    \ loop ((i 0))\n    (cond [(null? s)\n           \"\"]\n          [(equal? (char\
    \ (car s)) ?z)\n           (loop (+ i 1))]\n          [(< i (length alphabet))\n\
    \           (loop (+ i 1))]\n          [(equal? (char (car s) (substring alphabet\
    \ i 1))\n            (char (car s)(substring alphabet (+ i 1) 1)))\n         \
    \  (loop (+ i 1))]\n          [else\n           (cons (char (car s)(substring\
    \ alphabet (+ i 1) 1))\n                 (loop (+ i 1)))]))))\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nI love this solution! I'm still learning functional programming,\
    \ but this makes it extremely easy to understand and implement to solve any problem\
    \ I come across. Thank you for the detailed answer. I'm going to try to implement\
    \ this now.\n<|/ c |>\n<| a tags=functional-programming,scheme,encryption,racket,recursion\
    \ |>\nMy version:\n<code>", "  (define (shift ch shift)\n    (cond [(< shift 'a)\
    \ 'b]\n          [(< shift 'b) 'c]\n          [(< shift 'c) 'd]\n          [(<\
    \ shift 'd) 'e]\n          [(< shift 'e) 'f]\n          [(< shift 'f) 'g]\n  \
    \        [(< shift 'g) 'h]\n          [(< shift 'h) 'i]\n          [(< shift 'i)\
    \ 'j]\n          [(< shift 'j) 'k]\n          [(< shift 'k) 'l]\n          [(<\
    \ shift 'l) 'm]\n          [(< shift 'm) 'n]\n          [(< shift 'n) 'o]\n  \
    \        [(< shift 'o) 'p]\n          [(< shift 'p) 'q]\n          [(< shift 'q)\
    \ 'r]\n          [(< shift 'r) 's]\n          [(< shift 's) 't]\n          [(<\
    \ shift 't) 'u]\n          [(< shift 'u) 'v]\n          [(< shift 'v) 'w]\n  \
    \        [(< shift 'w) 'x]\n          [(< shift 'x) 'y]\n          [(< shift 'y)\
    \ 'z]\n          [(< shift 'z) 'a]\n          [(< shift 'a) 'b]\n          [(<\
    \ shift 'b) 'c]\n          [(< shift 'c) 'd]\n          [(< shift 'd) 'e]\n  \
    \        [(< shift 'e) 'f]\n          [(< shift 'f) 'g]\n          [(< shift 'g)\
    \ 'h]\n          [(< shift 'h) 'i]\n          [(< shift 'i) 'j]\n          [(<\
    \ shift 'j) 'k]\n          [(< shift 'k) 'l]\n          [(< shift 'l) 'm]\n  \
    \        [(< shift 'm) 'n]\n          [(< shift 'n) 'o]\n          [(< shift 'o)\
    \ 'p]\n          [(< shift 'p) 'q]\n          [(< shift 'q) 'r]\n          [(<\
    \ shift 'r) 's]\n          [(< shift 's) 't]\n          [(< shift 't) 'u]\n  \
    \        [(< shift 'u) 'v]\n          [(< shift 'v) 'w]\n", "  (let ([a (string->list\
    \ (string->string s))])\n    (string->string\n     (foldr (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set!\
    \ k (+ n c)) k)\n            (\u03BB (k [n c]) (set! k (+ n c)) k)\n         \
    \   (\u03BB (k [n c]) (set! k (+ n c)) k)\n            (\u03BB (k [n c]) (set",
  "  (if (null? (rest (rest s)))\n      (first s)\n      (let ((alph (list->string\
    \ (list (string->list (first s)))))\n            (key (list->string (list (string->list\
    \ (second s))))))\n        (let ((alph-len (length alph))\n              (key-len\
    \ (length key))\n              (alph-key (make-array alph-len \n             \
    \                      :element-type 'string\n                               \
    \    :initial-element (first alph))\n              ))\n          (map (lambda\
    \ (e) (substring e (+ (* 2 key-len) alph-len))) s)\n          (map (lambda (alph)\n\
    \                  (substring alph (+ (* 2 alph-len) key-len))) alph-key)\n  \
    \        (map (lambda (e) (substring e (+ (* 2 alph-len) alph-len))) alph-key)\n\
    \          (map #(if (string=? e key) 'x e) alph-key)\n          (append alph-key\
    \ (list (string->list (first s))))\n          (encrypt (rest (rest s))))))\n",
  "  (string-append (make-encrypted-string (string s)) (string s)))\n", "  (let loop\
    \ ((s (string->list s))\n             (alpha (string->list 'abcdezabcdez'))\n\
    \             (alpha-shift 0))\n    (if (null? s)\n        (reverse (list (string->string\
    \ s))))\n    (let ((alpha-letter (first alpha))\n          (alpha-letter2 (rest\
    \ alpha-letter)))\n      (cond\n        ((> (- alpha-shift 2)) \n         (cons\
    \ (cons (cons (cons alpha-letter alpha-letter2)\n                         alpha-letter)\n\
    \                    'z)\n              (cons alpha-letter2 alpha-letter))\n \
    \       ((< alpha-shift 2))\n         (cons (cons (cons alpha-letter alpha-letter2)\n\
    \                         alpha-letter)\n               'z)\n         (cons alpha-letter2\
    \ alpha-letter))\n      (loop (rest s) alpha (+ alpha-shift 2)))\n    ))\n", " \
    \ (let loop ((s s)\n             (alphabet (list 'z #\\a 'a 'b 'c #\\d #\\e #\\\
    f 'g 'h 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't))\n             (result 'z))\n    (cond\
    \ ((null? s) (cons result alphabet))\n          ((member (car s) alphabet)\n \
    \          (loop (cdr s) alphabet (cons (+ (length (string->list result)) 1) result))\n\
    \           (loop (cdr s) alphabet result))\n          (else\n           (loop\
    \ (cdr s) alphabet result))))\n", "  (let ((str (string->list s))\n        (idx\
    \ (length str)))\n    (cond\n      [(null? str) '()] \n      [(< (length str)\
    \ 2) (* idx ((- idx 2) (* idx 2))) (str)]\n      [(= (length str) 1) (cons str\
    \ '())]\n      [else (cons (cons (substring str 0 (- idx 2)) (substring str 1))\n\
    \                (encrypt (substring str 1 idx))\n                (encrypt (substring\
    \ str idx 2)))])))\n</code>\n<|/ a |>\n<| c |>\nThanks! I'm new to racket and\
    \ was trying to do this in racket.\n<|/ c |>\n<| c |>\nNo worries, just glad I\
    \ could help.\n<|/ c |>\n<| a dscore=2 |>\nThe solution is pretty simple, it's\
    \ just about the same, just in a different order. Try this:\n<code>", "  (let\
    \ ((alph (alphabet)))\n    (cond [(empty? s) s]\n          [(> (char-index (first\
    \ s) alph) alph) \n           (substring (append (substring (first s) 1 \n   \
    \                               (- alph (char-index (first s) alph))) \n     \
    \                       (first alph)) (+ (char-index (first s) alph) 1))]\n  \
    \        [else \n           (cond [(< (char-index (first s) alph) (char-index\
    \ (rest s) alph))\n                  (cons (substring (append (substring (first\
    \ s) 1 \n                                        (- alph (char-index (first s)\
    \ alph))) \n                                  (first alph)) \n               \
    \         (substring (first alph) 1 \n                                  (+ (char-index\
    \ (first s) alph) 1)))]\n                    [else \n                    (cons\
    \ (substring (append (substring (first s) 1 \n                               \
    \         (+ (char-index (first s) alph) 1)) (first alph)) \n                \
    \            (encrypt (rest s)))])))]))\n", "  (cond\n    [(empty? s) \"\"]\n\
    \    [(empty? (rest s)) s]\n    [else (concat \n            (substring (rotated-alphabet\
    \ (first s) 'a) 0 2)\n            (encrypt (rest s)))]))\n", "  (cond [(empty?\
    \ s) s]\n        [(eq? s (first s)) (second s)]\n        [else (append\n     \
    \            (list (second s)\n                       (second (first s))\n   \
    \                    (second (second s))\n                       (first s)\n \
    \                      (first (first s)))\n                 (encrypt (substring\
    \ s 0 (- (length s) 2)))\n                 (encrypt (substring s (- (length s)\
    \ 2) (length)))\n                 (encrypt (substring s (- 0 (- (length s) 2))\
    \ (length)))\n                 (encrypt (substring s 0 (- (length s) 2)))]))\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nHi there, thanks for your answer! Could you\
    \ explain a bit more about what your code does? I am not familiar with cond and\
    \ map, but I do know how to use append, length and substring. Thank you.\n<|/\
    \ c |>\n<| c |>\nMy code uses a `cond` construct to match on strings with a single\
    \ character, two characters, three characters, and more. In the first two cases,\
    \ it just returns the string unchanged. In the final two cases, it returns a list\
    \ with the first two characters changed, the remaining string changed, and then\
    \ the rest of the string changed and appended to the list created by the previous\
    \ call.\n<|/ c |>\n<| c |>\nAh, thanks! I see what your code is doing, but my\
    \ code was to implement it by myself and I wanted to understand how it worked.\
    \ So I could use it for my own code. Thanks!\n<|/ c |>\n<| c |>\nMy code implements\
    \ a function that takes a string as an argument and returns a string encrypted\
    \ with the alphabet being rotated. The alphabet should be rotated in a manner\
    \ such that the letters shift down by two multiplied to two places. For example:\n\
    \nencrypt('hi') returns 'lm'\nencrypt('asdfghjkl') returns 'ewhjklnop'\nencrypt('gf')\
    \ returns 'kj'\nencrypt('et') returns 'ix'\n<|/ c |>\n<| c |>\nYour code is not\
    \ efficient, but it is simple and easy to understand. It uses `cond` construct\
    \ and `append`. It uses `length`, `substring`, and `sublist`. It uses `map` and\
    \ `append`. Your code is fine and more efficient than the other solutions in the\
    \ answers. You could also implement this without using `append` and `length` and\
    \ `substring` and using `list` instead of `cons`.\n<|/ c |>\n<| a tags=scheme\
    \ |>\n<code>", "  (cond\n    [(empty? s) (error \"empty string\")]\n    [else\
    \ (+ (+ (* (char->int (first s)) (- 9)) (* 2 (char->int (first s))))\n       \
    \     (+ (* (char->int (first s)) (- 9)) (* 2 (char->int (second s))))\n     \
    \       (encrypt (rest s))]))\n", "  (cond\n    ((null? s) s)\n    ((string=?\
    \ s \"\")\n     (string=? (encrypt (list-ref '() 0)) \"z\")\n     (string=? (encrypt\
    \ (list-ref '() 1)) \"z\")\n     (string=? (encrypt (list-ref '() 2)) \"z\")\n\
    \     (string=? (encrypt (list-ref '() 3)) \"z\")\n     (string=? (encrypt (list-ref\
    \ '() 4)) \"z\")\n     (string=? (encrypt (list-ref '() 5)) \"z\")\n     (string=?\
    \ (encrypt (list-ref '() 6)) \"z\")\n     (string=? (encrypt (list-ref '() 7))\
    \ \"z\")\n     (string=? (encrypt (list-ref '() 8)) \"z\")\n     (string=? (encrypt\
    \ (list-ref '() 9)) \"z\")\n     (string=? (encrypt (list-ref '() 10)) \"z\")\n\
    \     (string=? (encrypt (list-ref '() 11)) \"z\")\n     (string=? (encrypt (list-ref\
    \ '() 12)) \"z\")\n     (string=? (encrypt (list-ref '() 13)) \"z\")\n     (string=?\
    \ (encrypt (list-ref '() 14)) \"z\")\n     (string=? (encrypt (list-ref '() 15))\
    \ \"z\")\n     (string=? (encrypt (list-ref '() 16)) \"z\")\n     (string=? (encrypt\
    \ (list-ref '() 17)) \"z\")\n     (string=? (encrypt (list-ref '() 18)) \"z\"\
    )\n     (string=? (encrypt (list-ref '() 19)) \"z\")\n     (string=? (encrypt\
    \ (list-ref '() 20)) \"z\")\n     (string=? (encrypt (list-ref '() 21)) \"z\"\
    )\n     (string=? (encrypt (list-ref '() 22)) \"z\")\n     (string=? (encrypt\
    \ (list-ref '() 23)) \"z\")\n     (string=? (encrypt (list-ref '() 24)) \"z\"\
    )\n     (string=? (encrypt (list-ref '() 25)) \"z\")\n     (string=? (encrypt\
    \ (list-ref '() 26)) \"z\")\n     (string=? (encrypt (list-ref '() 27)) \"z\"\
    )\n     (string=? (encrypt (list-ref '() 28)) \"z\")\n     (string=? (encrypt ",
  "  (let* ((alphabet (list* (string \"a\") (string \"b\") (string \"c\") (string\
    \ \"d\") (string \"e\") (string \"f\") (string \"g\") (string \"h\") (string \"\
    i\") (string \"j\") (string \"k\") (string \"l\") (string \"m\") (string \"n\"\
    ) (string \"o\") (string \"p\") (string \"q\") (string \"r\") (string \"s\") (string\
    \ \"t\") (string \"u\") (string \"v\") (string \"w\") (string \"x\") (string \"\
    y\") (string \"z\"))) \n         (new-alphabet (rotate-alphabet alphabet 2))\n\
    \         (new-string (map (lambda (char n)\n                           (char\
    \ (+ (char-code char) (* n 2))))\n                         s \n              \
    \           new-alphabet))\n         (new-string (string-append new-string \"\
    a\")))\n    (prin1 new-string))\n", "  (let ((alpha (make-rot-alphabet (length\
    \ s))))\n    (string-append \n     (string-append \n      (map \n       (lambda\
    \ (x)\n         (cond \n           ((<= (modulo x 2) 0) (rot-alpha alpha x)) \n\
    \           (else x))) \n      (map \n       (lambda (x)\n         (string-append\
    \ x 'y'))) \n      (map \n       (lambda (x)\n         (string-append x 'x')))\
    \ \n      (map \n       (lambda (x)\n         (string-append x 'z'))) \n     \
    \ s) \n     'y)))\n", "  (cond [(null? s) s]\n        [(or (char=? (char-code\
    \ (first s)) 97) (char=? (char-code (first s)) 65))\n          (substring (cons\
    \ (char-code (char-code (first s)) 97) \n                       (substring (encrypt\
    \ (substring (substring s 0 (1- (string-length s))))\n                       \
    \              (substring s 0 (1- (string-length s)))))\n                    \
    \   (substring s (1- (string-length s))))]\n        [else (substring (encrypt\
    \ (substring s 0 (1- (string-length s))))\n                       (substring s\
    \ (1- (string-length s)))]\n        ))\n", "  (let ((alpha (make-alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n    (loop-for-chars\n      (lambda (c)\n        (let* ((a-alpha (char->letter\
    \ c))\n               (b (substring alpha (+ a-alpha 2) 1))\n               (c-alpha\
    \ (char->letter b))\n               (d (char->letter c-alpha))\n             \
    \  (e (string-to-list d))\n               (f (string-to-list d-alpha))\n     \
    \          (g (+ (* 2 f) 1))\n               (h (substring alpha (+ g 2) 1))\n\
    \               (i-alpha (char->letter h))\n               (j-alpha (char->letter\
    \ i-alpha))\n               (k-alpha (char->letter j-alpha))\n               (l\
    \ (substring alpha (+ j-alpha 2) 1))\n               (m-alpha (char->letter l))\n\
    \               (n-alpha (char->letter m-alpha))\n               (o (substring\
    \ alpha (+ n-alpha 2) 1))\n               (p-alpha (char->letter o))\n       \
    \        (q-alpha (char->letter p-alpha))\n               (r-alpha (char->letter\
    \ q-alpha))\n               (s-alpha (char->letter r-alpha))\n               (t\
    \ (substring alpha (+ o-alpha 2) 1))\n               (u-alpha (char->letter t))\n\
    \               (v-alpha (char->letter u-alpha))\n               (w-alpha (char->letter\
    \ v-alpha))\n               (x-alpha (char->letter w-alpha))\n               (y-alpha\
    \ (char->letter x-alpha))\n               (z-alpha (char->letter y-alpha)))\n\
    \          (format #t \"~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~",
  "  (loop for c across s\n        for i from 0\n        for j from (* i 2) to (*\
    \ i 2)\n        collect (char-ref (substring c i j) (char-code (char-ref 'a' 0)))))\n",
  "  (cond\n    ((empty? s) \"\")\n    ((even? (length s)) (rotate-char (first s)\
    \ 'up))\n    (else (rotate-char (first s) 'down))\n  )\n)\n", "    (if (char=?\
    \ #\\A (first s))\n        (encrypt (rest (rest s))))\n    (+ (* (char-code #\\\
    a) (char-code #\\b)) (encrypt (rest (rest s)))))\n</code>\n<|/ a tags=encryption,racket,char,string\
    \ dscore=1 |>\n<| c |>\nOh I see, I got it now. Thank you so much! :) I am new\
    \ to DrRacket.\n<|/ c |>\n<| c |>\nHow would I go about doing this with racket's\
    \ built-in functions, though?\n<|/ c |>\n<| c |>\nI guess I forgot to mention\
    \ that, sorry.\n<|/ c |>\n<| c |>\nI updated my answer. Sorry I did not know about\
    \ racket built-in functions\n<|/ c |>\n<| c |>\nI added a description of my current\
    \ solution to my question. Do you see a way to optimize it further?\n<|/ c |>\n\
    <| a tags=encryption,racket,char,string |>\nThis answer uses built-in functions\
    \ of Racket. \nThe idea is to use foldr to create a function which does the rotation.\
    \ Then use foldr to apply this function to a string and use reduce to create another\
    \ function which applies this function to each character of the string.\n<code>\n\
    #lang racket\n", "  (let ((alphabet (list\n                 'z\n             \
    \    'y\n                 'x\n                 'w\n                 'v\n     \
    \            'u\n                 't\n                 's\n                 'r\n\
    \                 'q\n                 'p\n                 'o\n             \
    \    'n\n                 'm\n                 'l\n                 'k\n     \
    \            'j\n                 'i\n                 'h\n                 )))\n\
    \    (if (null? (symbol->string alphabet))\n        '\n        (let loop ((s (string->symbols\
    \ s)))\n          (if (null? (symbol->string alphabet))\n              (append\
    \ (encrypt s) 'z)\n              (if (equal? (first s) (first alphabet))\n   \
    \               (append (encrypt s) (cons (car alphabet) (cdr (cdr alphabet))))\
    \ ; rotate first letter by two\n                  (if (equal? (first s) (first\
    \ (cdr alphabet)))\n                      (append (encrypt s) (cdr alphabet))\n\
    \                      (append (encrypt s) (cons (cons (car alphabet) (cons (cdr\
    \ alphabet) (cdr alphabet)))\n                                               \
    \   (cons (car alphabet) (cons (car alphabet) (cons (cdr alphabet) (cdr alphabet)))))))))))))\n",
  "  (let ([alph (list 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't\
    \ 'u 'v 'w 'x 'y 'z)])\n    (let ([alph (append alph (list 'z 'x 'y 'w 'v 'u 't\
    \ 's 't))))\n      (let ([alph (append alph (list 'q 'p 'o 'm 'n 'l 'k 'j 'i 'h\
    \ 'g 'f 'e 'd 'c 'b 'a z)))]\n        (let ([alph (append alph (list 'u 'r 't\
    \ 'q 'p 'o 'm 'n 'l 'k 'j 'i 'h 'g 'f 'e 'd 'c 'b 'a z)))])\n          (let ([alph\
    \ (append alph (list 'u 'r 't 'q 'p 'o 'm 'n 'l 'k 'j 'i 'h 'g 'f 'e 'd 'c 'b\
    \ 'a z)))])\n            (let ([alph (append alph (list 'u 'r 't 'q 'p 'o 'm 'n\
    \ 'l 'k 'j 'i 'h 'g 'f 'e 'd 'c 'b 'a z)))])\n              (let ([alph (append\
    \ alph (list 'u 'r 't 'q 'p 'o 'm 'n 'l 'k 'j 'i 'h 'g 'f 'e 'd 'c 'b 'a z)))])\n\
    \                (let ([alph (append alph (list 'u 'r 't 'q 'p 'o 'm 'n 'l 'k\
    \ 'j 'i 'h 'g 'f 'e 'd 'c 'b 'a z)))])\n                  (let ([alph (append\
    \ alph (list 'u 'r 't 'q 'p 'o 'm 'n 'l 'k 'j 'i 'h 'g 'f 'e 'd 'c 'b 'a z)))])\n\
    \                    (let ([alph (append alph (list 'u 'r 't 'q 'p 'o 'm 'n 'l\
    \ 'k 'j 'i 'h 'g 'f 'e 'd 'c 'b 'a z)))])\n                      (let ([alph (",
  "  (reverse\n   (append (reverse (substring s 0 0)) \n          (substring s 1 0)\
    \ \n          (substring s 2 0))))\n", "  (let ((alphabet (list  'a 'b 'c 'd 'e\
    \ 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z)))\n    (let\
    \ ((alpha (make-array (length alphabet) \n                              (lambda\
    \ (index x) alphabet))))\n      (map (lambda (x)\n             (let ((i (- x 26)))\n\
    \               (set! alpha (set! alpha (+ alpha (substring alphabet i))) \n \
    \              alpha (- alpha (length alphabet))))\n          (substring alphabet\
    \ 0 26))))\n  (substring alphabet 0 26))\n", "  (cond \n   ((empty? s) \"\")\n\
    \   (else (append (map #(if (= (substring s 0 (string-length s)) c)\n        \
    \                (substring s (+ 0 (string-length s)) \n                     \
    \             (+ 0 (string-length s))) \n                         (substring s\
    \ (+ 0 (string-length s)) \n                                  (+ 2 (string-length\
    \ s)))) \n                     (rotate (substring s (+ 0 (string-length s)) \n\
    \                                       (string-length s)))\n                \
    \     (encrypt (substring s 0 (string-length s)))))))", "  (define (shift ch)\n\
    \    (cond [(char=? ch #\\a) (cons (char=? (char-after ch (char-before ch (char-after\
    \ ch (char-before ch #\\a)) #\\a) #\\a) '())]\n          [(char=? ch #\\z) (cons\
    \ (char=? (char-after ch (char-before ch (char-after ch (char-before ch #\\a))\
    \ #\\a) #\\a) '())]\n          [(char=? ch #\\A) (cons (char=? (char-after ch\
    \ (char-before ch (char-after ch (char-before ch #\\a)) #\\a) #\\a) '())]\n  \
    \        [(char=? ch #\\Z) (cons (char=? (char-after ch (char-before ch (char-after\
    \ ch (char-before ch #\\a)) #\\a) #\\a) '())]\n          [(char=? ch #\\d) (cons\
    \ (char=? (char-after ch (char-before ch (char-after ch (char-before ch #\\a))\
    \ #\\a) #\\a) '())]\n          [else (cons (char=? (char-after ch (char-before\
    \ ch (char-after ch (char-before ch #\\a)) #\\a) #\\a) '())]))\n  (define (rotate-2\
    \ ch)\n    (char-after ch (char-before ch (char-after ch (char-before ch #\\a))))\n\
    \  (define (rotate-1 ch)\n    (char-after ch (char-before ch (char-after ch (char-before\
    \ ch #\\a))))\n  (define (rotate-3 ch)\n    (char-after ch (char-before ch (char-after\
    \ ch (char-before ch #\\a))))\n  (define (rotate-4 ch)\n    (char-after ch (char-before\
    \ ch (char-after ch (char-before ch #\\a))))\n  (define (rotate-5 ch)\n    (char-after\
    \ ch (char-before ch (char-after ch (char-before ch #\\a))))\n  (define (rotate-6\
    \ ch)\n    (char-after ch (char-before ch (char-after ch (char-before ch #\\a))))\n\
    \  (define (rotate-7 ch", "  (define (rotate c n) (cons c (rotate (cdr c) n)))\n\
    \  (define (rotate-pairs c)\n    (cond [(null? c) (cdr c)]\n          [(pair?\
    \ c) (rotate-pairs (car c))]))\n  (define (encrypt c)\n    (rotate-pairs (rotate\
    \ c 2)))\n  (encrypt-string s))\n", "  (define (encrypt c a b)\n    (if (= c ?a)\n\
    \        (crypt (substring c 1 1) (cons ?b ?a) (crypt ?a ?b ?c))\n        (encrypt\
    \ (cdr c) (cons ?a ?b) (crypt ?b ?a ?c))))\n  (encrypt s #(#\\a ?b ?c) #(#?b ?a\
    \ ?c)))\n", "  (let ((alpha (list (list \"a\" 26) (list \"b\" 25) (list \"c\"\
    \ 24) \n                      (list \"d\" 23) (list \"e\" 22) (list \"f\" 21)\
    \ \n                      (list \"g\" 20) (list \"h\" 19) (list \"i\" 18) \n \
    \                     (list \"j\" 17) (list \"k\" 16) (list \"l\" 15) \n     \
    \                 (list \"m\" 14) (list \"n\" 13) (list \"o\" 12) \n         \
    \             (list \"p\" 11) (list \"q\" 10) (list \"r\" 9) \n              \
    \        (list \"s\" 8) (list \"t\" 7) (list \"u\" 6) \n                     \
    \ (list \"v\" 5) (list \"w\" 4) (list \"x\" 3) \n                      (list \"\
    y\" 2) (list \"z\" 1)))) ; end of alpha.\n    (loop for e in (list) (\n      \
    \    for i = (length s)\n          when (< i 13) \n          do (println e) ;\
    \ for testing only\n          do (println i) ; for testing only\n          do\
    \ (println alpha (+ i (* 2 (car e))) (+ i (* 2 (cadr e)))))) ; for testing only\n\
    \  ) ; end of encrypt\n) ;; end of #lang racket\n</code>\n<|/ a tags=scheme,racket,cryptarithmetic-puzzle\
    \ |>\n<| a dscore=2 tags=scheme,racket,cryptarithmetic-puzzle |>\n<code>\n#lang\
    \ racket\n", "  (define (rot x y)\n    (cond\n      [(= y 0) x]\n      [(> y 2)\
    \ (rot x (- y 2))]\n      [else (rot (rot x y) 0)]))\n  (define (encrypt x y)\n\
    \    (cond\n      [(= y 0) x]\n      [(> y 2) (encrypt x (- y 2))]\n      [else\
    \ (encrypt (rot x y) 0)]))\n  (define (encrypt x y z)\n    (cond\n      [(= y\
    \ 0) x]\n      [(> y 2) (encrypt x (- y 2) z)]\n      [else (encrypt (rot x y\
    \ z) 0)]))\n  (encrypt s (- s 26)))\n", "  (cond\n    [(empty? s) \"\"]\n    [(equal?\
    \ (first s) \"z\") (encrypt (rest s))]\n    [else (encrypt (append (first s) (encrypt\
    \ (rest s))))]))\n", "  (cond [(empty? s) '']\n        [(equal? s (first s)) 'z]\n\
    \        [else (append (append (map (lambda (char) (rotate-right-char (first char)\
    \ (second char))\n                                               (rest s))\n \
    \                                             (make-string 2 'z))\n          \
    \                  (encrypt (rest s)))]))\n        \n        \n        ", "  (apply\
    \ str (map #(char (char-code (first s)) \n                        (char-code (second\
    \ s)) \n                        (char-code (third s))) \n                   (rot13\
    \ (reverse s)))))", "  (let ([c (char-sort (make-string (in->char-string s)))])\n\
    \    (rotate-array s (- 26 0)) ; rotate 26 times \n    (for-each \n     (lambda\
    \ (l)\n       (let ([i (char l c)] ; get position of letter in alphabet\n    \
    \         [j (char l c \"-\")])\n         (if (equal? i j)\n             (cons\
    \ (char (char l c \"-\") \n                     (char (char l c \"a\"))\n    \
    \                 (char (char l c \"b\"))\n                     (char (char l\
    \ c \"c\"))\n                     (char (char l c \"d\"))\n                  \
    \   (char (char l c \"e\"))\n                     (char (char l c \"f\"))\n  \
    \                   (char (char l c \"g\"))\n                     (char (char\
    \ l c \"h\"))\n                     (char (char l c \"i\"))\n                \
    \     (char (char l c \"j\"))\n                     (char (char l c \"k\"))\n\
    \                     (char (char l c \"l\"))\n                     (char (char\
    \ l c \"m\"))\n                     (char (char l c \"n\"))\n                \
    \     (char (char l c \"o\"))\n                     (char (char l c \"p\"))\n\
    \                     (char (char l c \"q\"))\n                     (char (char\
    \ l c \"r\"))\n                     (char (char l c \"s\"))\n                \
    \     (char (char l c \"t\"))\n                     (char (char l c \"u\"))\n\
    \                     (char (char l c \"v\"))\n                     (char (char\
    \ l c \"w\"))\n                     (char (char l c \"x\"))\n                \
    \     (char (char l c \"y\"))\n                     (char (char l c \"z\")))\n\
    \             (cons (char (char l c) \n                     (char (char l c \"\
    a\"))\n                     (char (char l c \"b\"))\n                     (char\
    \ (char l c \"c\"))\n                     (char (char l c \"d\"))\n          \
    \           (char (char l c \"e\"))\n                     (char (char l c \"f\"\
    ))\n                     (char (char l c \"g\"))\n                     (char (char\
    \ l c \"h\"))\n                     (char (char l c \"i\"))\n                \
    \     (char (char l c \"j\"))\n                     (char (char l c \"k\"))\n\
    \                     (char (char l c \"l\"))\n                     (char (char\
    \ l c \"m\"))\n                     (char (char l c \"n\"))\n                \
    \     (char (char l c \"o\"))\n                     (char (char l c ", "  (let\
    \ ([a (map char alphabet)]\n        [e (map char encryption)])\n    (map string->list\n\
    \         (map #(cons (substring s 0 %) (substring s (+ 1 %) %))\n           \
    \     (zip-collate '() (substring a %) '() e (substring e %))))))\n", "  (cond\n\
    \    ((empty? s) empty)\n    (else (cons (char-at (string->list s) 0) (encrypt\
    \ (remainder s 1))))))\n", "  (let loop ((n 0)\n             (acc '()))\n    (if\
    \ (null? s)\n        acc\n        (loop (+ n 1)\n              (cons (string->list\
    \ (char->string (car s))) acc)))))\n", "  (lambda (c)\n    (char-to-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x (char-at-x\
    \ (char-at-x (char-", "  (let ([alpha (make-array 26 \n                      \
    \  (lambda (x) (char->integer (char->string x)))))\n    (loop [i 0]\n      (if\
    \ (>= (length s) i)\n          (append alpha (list null))\n          (let ([c\
    \ (char (substring s i (inc i)))])\n            (set! alpha (subarray alpha (i)\
    \ (+ i (char->integer c)))))\n          (set! alpha (subarray alpha 0 i))))))\n",
  "  ; Base case\n  (cond [(string? s)\n         (char->string\n          (map (lambda\
    \ (c)\n                   (char->int c))\n                 (take-two (rotate-letters\
    \ string-to-list (length s)))))]\n        [else\n         (string? \"\")]))\n",
  "  (cond\n    [(empty? s) \"\"]\n    [else (let* ([letter-count (length (first s))]\n\
    \                [letters (take-letters s letter-count)]\n                [count\
    \ 1])\n            (cond\n              [(< (- letter-count count) 0) (cons x\
    \ letters)\n               (= letter-count count (- letter-count count))\n   \
    \            (= (+ count 1) letter-count) (cons (cons x letters)\n           \
    \                                   letters)]\n              [else (cons (cons\
    \ (cons x letters)\n                                    (encrypt (drop-letters\
    \ s count)))\n                        letters)]))]))\n", "  (cond \n   ((empty?\
    \ s) 'z)\n   (else (append (encrypt (substring s 0 (- (length s) 2))) (substring\
    \ s '1) (encrypt (substring s 1 (- (length s) 2)))))))\n", "  (cond\n    [(empty?\
    \ s) s]\n    [(eq? (char-ref s 0) #\\a) (cons (char-ref s 'a) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\b) (cons (char-ref s 'b) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\c) (cons (char-ref s 'c) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\d) (cons (char-ref s 'd) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\e) (cons (char-ref s 'e) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\f) (cons (char-ref s 'f) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\n) (cons (char-ref s 'n) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\o) (cons (char-ref s 'o) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\p) (cons (char-ref s 'p) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\q) (cons (char-ref s 'q) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\r) (cons (char-ref s 'r) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\s) (cons (char-ref s 's) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\t) (cons (char-ref s 't) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\v) (cons (char-ref s 'v) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\w) (cons (char-ref s 'w) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\0) (cons (char-ref s '0) (encrypt (char-cdr\
    \ s)))]\n    [(eq? (char-ref s 0) #\\1) (cons (char-ref s '1) (encrypt (char-cdr\
    \ s)))]", "  (let loop ((s s)\n             (alph (list 'a b c d e f g h i j k\
    \ l m n o p q r s t u v w x y z))\n             (chars (list (char->integer s)\
    \ (char->integer 0)))\n             (encrypted (make-string (char->integer 26)\
    \ empty)))\n    (if (null? s)\n        (reverse encrypted)\n        (loop (rest\
    \ s) alph (+ 2 (length (first chars))) encrypted (loop (first s) alph (rest chars)\
    \ encrypted (loop (first s) alph (rest chars) encrypted)))\n    )\n  )\n)\n",
  "  (let ((i (position #\\a s) (position #\\z s)) (j 0)) \n    (cond [(or (< i 0)\
    \ (< j 0)) \"?\"]\n          [(eq? (mod i 2) 0) (cons s? (encrypt (substring s\
    \ j i)))]\n          [(eq? (mod i 2) 1) (cons s? (encrypt (substring s (+ i 2)\
    \ (- j 2))))]\n          [else (cons s? (encrypt (substring s j i) (+ i 2))))]))\n",
  "  (let ((letters '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n   \
    \ (let loop ((s s)\n               (r '()))\n      (cond ((null? s) r)\n     \
    \       ((eq? (first s) 'a) (append r (list (second s))))\n            ((eq? (first\
    \ s) 'b) (append r (list (third s))))\n            ((eq? (first s) 'c) (append\
    \ r (list (fourth s))))\n            ((eq? (first s) 'd) (append r (list (fifth\
    \ s))))\n            ((eq? (first s) 'e) (append r (list (sixth s))))\n      \
    \      ((eq? (first s) 'f) (append r (list (seventh s))))\n            ((eq? (first\
    \ s) 'g) (append r (list (eighth s))))\n            ((eq? (first s) 'h) (append\
    \ r (list (ninth s))))\n            ((eq? (first s) 'i) (append r (list (tenth\
    \ s))))\n            ((eq? (first s) 'j) (append r (list (eleventh s))))\n   \
    \         ((eq? (first s) 'k) (append r (list (twelfth s))))\n            ((eq?\
    \ (first s) 'l) (append r (list (thirteenth s))))\n            ((eq? (first s)\
    \ 'm) (append r (list (fourteenth s))))\n            ((eq? (first s) 'n) (append\
    \ r (list (fifteenth s))))\n            ((eq? (first s) 'o) (append r (list (sixteenth\
    \ s))))\n            ((eq? (first s) 'p) (append r (list (seventeenth s))))\n\
    \            ((eq? (first s) 'q) (append r (list (eighteenth s))))\n         \
    \   ((eq? (first s) 'r) (append r (list (nineteenth s))))\n            ((eq? (first\
    \ s) 't) (append r (list (tenth s))))\n            ((eq? (first s) 'u) (append\
    \ r (list (eleven s))))\n            ((eq? (first s) 'v) (append r (list (twelve\
    \ s))))\n            ((eq? (first s) 'w) (append r (list (thirteen s))))\n   \
    \         ((eq? (first s) 'x) (append r (list (fourteen s))))\n            ((eq?\
    \ (first s) 'y) (append r (list (fifteen s))))\n            ((eq? (first s) ",
  "  (cond ((empty? s) '())\n        ((equal? (first s) 'a) (cons (first (first s))\
    \ (encrypt (rest s))))\n        ((equal? (first s) 'b) (cons (first (first (first\
    \ s))) (encrypt (rest (rest s)))))\n        ((equal? (first s) 'c) (cons (first\
    \ (first (first (first s))))(encrypt (rest (rest s)))))\n        ((equal? (first\
    \ s) 'd) (cons (first (first (first (first (first (first s)))))))(encrypt (rest\
    \ (rest s))))\n        ((equal? (first s) 'e) (cons (first (first (first (first\
    \ (first (first (first (first s)))))))) (encrypt (rest (rest s))))\n        ((equal?\
    \ (first s) 'f) (cons (first (first (first (first (first (first (first (first\
    \ s)))))))(encrypt (rest (rest s)))))))", "  (let loop ((s s)\n             (e\
    \ '()))\n    (cond ((null? s) '())\n          ((char (car s))\n           (loop\
    \ (cdr s)\n                 (cons (char (char (car s)\n                      \
    \        (char (car s)\n                              (char (car s)\n        \
    \                      (* 2 (char (car s)))))\n                     e)))\n   \
    \       (else\n           (loop (cdr s)\n                 (cons (char (char (car\
    \ s)\n                              (char (car s)\n                          \
    \    (* 2 (char (car s)))))\n                     e))))))\n", "  (let loop ((s\
    \ s)\n             (acc '()))\n    (cond\n      [(= 0 (string-length s)) (reverse\
    \ acc)]\n      [else (loop (substring s 0 (string-length s) #t)\n            \
    \    (cons (char->digit (first (char->string s))) acc))])))\n", "  (define alphabet\
    \ (list a b c d e f g h i j k l m n o p q r s t u v w x y z))\n  (define (shift-down\
    \ l)\n    (cond [(null? l) l]\n          [(equal? l (car l)) (shift-down (cdr\
    \ l))]\n          [else (cons (car l) (shift-down (cdr l)))]))\n  (let ([alpha\
    \ (shift-down alphabet)])\n    (define (rotate-letter n)\n      (cond [(< n 26)\
    \ alphabet]\n            [else (cons (rotate-letter (- n 26)) (rotate-letter (-\
    \ n 26)))))\n    (string-append (cons (char->integer (char->symbol s (char->integer\
    \ 0)) alpha) \n                      (rotate-letter (length (char->symbol s (char->integer\
    \ 0)))))\n    ))\n", "  (define (enc-loop s result)\n    (cond [(empty? s) result]\n\
    \          [(equal? (char->integer (char-ref s 0)) 0)) result]\n          [(equal?\
    \ (char->integer (char-ref s 0)) 1) (enc-loop (char->string (char-ref s (add1\
    \ 1))) (cons (char->integer (char-ref s 0)) result))]\n          [else (enc-loop\
    \ (char->string (char-ref s (add1 1)) (cons (char->integer (char-ref s 0)) result)))]))\n\
    \  (enc-loop s ''))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
