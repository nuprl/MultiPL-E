name: HumanEval_84_solve
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer N, return the total sum of its\
  \ digits in binary.\n;; Example\n;; For N = 1000, the sum of digits will be 1 the\
  \ output should be \"1\".\n;; For N = 150, the sum of digits will be 6 the output\
  \ should be \"110\".\n;; For N = 147, the sum of digits will be 12 the output should\
  \ be \"1100\".\n;; Variables:\n;; @N integer\n;; Constraints: 0 \u2264 N \u2264\
  \ 10000.\n;; Output:\n;; a string of binary number\n(define (solve N)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate 1000) \"1\")\n    (check-equal? (candidate 150) \"\
  110\")\n    (check-equal? (candidate 147) \"1100\")\n    (check-equal? (candidate\
  \ 333) \"1001\")\n    (check-equal? (candidate 963) \"10010\")\n))\n\n(test-humaneval)"
completions: ["    (let loop ((N N) (sum 0)\n               (result \"\"))\n     \
    \ (cond ((< N 10) result)\n            (else (loop (quotient N 10) (+ sum (modulo\
    \ (quotient N 10) (modulo N 10))))\n                  (display (format \"~a\"\
    \ result))\n                  (set! sum (modulo (quotient N 10) (modulo N 10)))))))\n",
  "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) \"\"]\n    [(= N 2) \"0\"]\n    [(= (mod\
    \ N 2) 1) (append (solve (/ N 2)) \"0\")]\n    [else (append (solve (/ N 2)) (list\
    \ (digit->string N)))]))\n", "  (if (zero? N)\n      (println \"0\")\n      (println\
    \ (sum-digits-binary (N) 10))))\n", "    (cond [(= N 0) \"\"]\n          [(= N\
    \ 1) (string '1)]\n          [(= N (/ N 2)) (string '1 0)]\n          [(= (mod\
    \ N 2) 0) (cons (string (+ (modulo N 2) 1)) (solve (quotient N 2)))]\n       \
    \   [(= (mod N 2) 1) (cons (string (+ (modulo N 2) 1)) (solve (quotient N 4)))]\n\
    \          [(= (mod N 2) 0) (cons (string (+ (modulo N 2) 1)) (solve (quotient\
    \ N 6)))]\n          [(= (mod N 2) 1) (cons (string (+ (modulo N 2) 1)) (solve\
    \ (quotient N 8)))]\n          [(= (mod N 2) 0) (cons (string (+ (modulo N 2)\
    \ 1)) (solve (quotient N 10)))]\n          [(= (mod N 2) 1) (cons (string (+ (modulo\
    \ N 2) 1)) (solve (quotient N 12)))]\n          [(= (mod N 2) 0) (cons (string\
    \ (+ (modulo N 2) 1)) (solve (quotient N 14)))]\n          [(= (mod N 2) 1) (cons\
    \ (string (+ (modulo N 2) 1)) (solve (quotient N 16)))]\n          [(= (mod N\
    \ 2) 0) (cons (string (+ (modulo N 2) 1)) (solve (quotient N 18)))]\n        \
    \  [(= (mod N 2) 1) (cons (string (+ (modulo N 2) 1)) (solve (quotient N 20)))]\n\
    \          [(= (mod N 2) 0) (cons (string (+ (modulo N 2) 1)) (solve (quotient\
    \ N 22)))]\n          [(= (mod N 2) 1) (cons (string (+ (modulo N 2) 1)) (solve\
    \ (quotient N 24)))]\n          [(= (mod N 2) 0) (cons (string (+ (modulo N 2)\
    \ 1)) (solve (quotient N 26)))]\n          [(= (mod N 2) 1) (cons (string (+ (modulo\
    \ N 2) 1)) (solve (quotient N 28)))]\n          [(= (mod N 2) 0) (cons (string\
    \ (+ (modulo N 2) 1)) (solve (quotient N 30)))]\n          [(= (mod N 2) 1) (cons\
    \ (string (+ (modulo N 2) 1)) (solve (quotient N 32)))]\n          [(= (mod N\
    \ 2) 0) (cons (string (+ (modulo N 2) 1)) (solve (quotient N 34)))]\n        \
    \  [(", "  (define (sum-to-n-digits sum digits)\n    (if (= digits 0)\n      \
    \  sum\n        (sum-to-n-digits sum (- digits 1))))\n  (define (sum-to-n N digits\
    \ sum)\n    (if (< N 0)\n        sum\n        (sum-to-n (- N 1) (+ digits 1) (+\
    \ sum (digit->int N)))))\n  (define (total-sum N)\n    (sum-to-n N 0 0))\n  (define\
    \ (sum-to-digits N)\n    (define (sum-to-n-digits sum digits)\n      (if (= digits\
    \ 0)\n          sum\n          (sum-to-n-digits sum (- digits 1))))\n    (define\
    \ (sum-to-n N digits sum)\n      (if (< N 0)\n          sum\n          (sum-to-n\
    \ (- N 1) (+ digits 1) (+ sum (digit->int N)))))\n    (define (total-sum N)\n\
    \      (sum-to-n N 0 0))\n  (define (digit-sum digits)\n    (define (sum-to-n-digits\
    \ sum digits)\n      (if (= digits 0)\n          sum\n          (sum-to-n-digits\
    \ sum (- digits 1))))\n    (define (sum-to-n N digits sum)\n      (if (< N 0)\n\
    \          sum\n          (sum-to-n (- N 1) (+ digits 1) (+ sum (digit->int N)))))\n\
    \    (define (total-sum N)\n      (sum-to-n N 0 0))\n  (if (> N 0)\n      (define\
    \ (digit-sum digits)\n        (define (sum-to-n-digits sum digits)\n         \
    \ (if (= digits 0)\n              sum\n              (sum-to-n-digits sum (- digits\
    \ 1))))\n        (define (sum-to-n N digits sum)\n          (if (< N 0)\n    \
    \          sum\n              (sum-to-n (- N 1) (+ digits 1) (+ sum (digit->int\
    \ N)))))\n        (define (total-sum N)\n          (sum-to-n N 0 0))\n      (define\
    \ (digit-sum-helper digits sum)\n        (define (sum-to-n-digits sum digits)\n\
    \          (if (= digits 0)\n              sum\n              (sum-to-n-digits\
    \ sum (- digits 1))))\n        (define (sum-to-n N digits sum)\n          (if\
    \ (< N 0)\n              sum\n              (sum-to-n (- N 1) (+ digits 1) (+\
    \ sum (digit->int N)))))\n        (define (total-sum N)\n          (sum-to-n N\
    \ 0 0))", "  (cond\n    [(= N 0) \"\"]\n    [else (+ (number-to-string (N) bin)\
    \ solve((- N 1)))]))\n", "  (cond\n    [(or (= N 0) (= N 1)) (list '1)]\n    [else\
    \ (sum-digits N 0)]))\n", "  (if (= N 0)\n      \"\"\n      (let ([remainder (mod\
    \ N 10)])\n        (if (= remainder 0)\n            (cons (if (< N 10) 'a 'b)\
    \ \"\")\n            (cons (if (< N 10) 'a 'b) (solve (rem N 10)))))))\n", " \
    \ (let loop ((num N) (sum 0))\n    (cond\n      [(> N 0)\n       (cons sum \"\"\
    )]\n      [(< N 0)\n       (loop (sub1 num) (cons sum \"\"))]\n      [(equal?\
    \ num 0)\n       (cons sum \"\")]\n      [(zero? num)\n       (loop (sub1 num)\
    \ (cons sum \"\"))]\n      [(even? num)\n       (loop (sub1 num) (append (append\
    \ (cons sum \"\") (digit-sum num)) \"\"))]\n      [(odd? num)\n       (loop (sub1\
    \ num) (append (cons sum \"\") \"\"))]\n      [else\n       (loop (sub1 num) (append\
    \ (cons sum \"\") (digit-sum num)))]))))\n", "  (check-type N integer)\n  (check-not\
    \ (negative-p N))\n\n  (let loop ((N N) (sum 0))\n    (if (> N 0)\n        (loop\
    \ (quotient N 10)\n               (+ sum (modulo N 10)))\n        '(zero)))\n\n\
    \  ;; The return value of the loop is in sum, the value of sum is in N.\n  ;;\
    \ The N is now zero, the return value is in '(zero).\n  ))\n", "  (if (= N 0)\n\
    \      \"0\"\n      (+ (string->number (format \"~b\" N)) (solve (sub1 N))))))\n",
  "  (if (< N 0) \"\"\n      (let loop ((N N)\n                 (result \"\"))\n \
    \       (if (< N 10)\n            (loop (sub1 N)\n                  (add1 result\
    \ (digit-char N)))\n            (loop (sub1 N) (add1 (digit-char N) result))))))\n",
  "  (let loop ((N N) (S #t))\n    (cond ((= N 0) S)\n          ((= N 1) S)\n    \
    \      ((= (mod N 10) 0) (loop (sub1 N) (cons (car digits) S)))\n          (else\
    \ (loop (sub1 N) (cons (car digits) S))))))\n", "  (if (< N 0)\n      '()\n  \
    \    (cons (char (modulo (quotient N 2) 2) (modulo (quotient N 2) 2)) (solve (quotient\
    \ N 2) 2))))\n", "  (cond\n    [(or (= N 0) (= N 1)) \"0\"]\n    [else (bin-sum\
    \ (expt N 2))]))\n</code>\n<|/ a dscore=0 tags=racket,scheme |>\n<| c |>\nThanks,\
    \ but that's not what I'm trying to do. I already have the solution set up and\
    \ it works with some test cases, but I'm interested in more general solutions\
    \ that might be easier to implement in practice.\n<|/ c |>\n<| a tags=racket,scheme\
    \ dscore=0 |>\nHere's a recursive solution, with some comments.\n<code>", "  (if\
    \ (= N 0)\n      \"0\"\n      (let ((sum (current-digit-sum (- N 1))))\n     \
    \   (if (> N 1)\n            (concat \"0\" sum)\n            sum)\n        (solve\
    \ (- N 1)))))\n", "  (define (add N total)\n    (if (= N 0)\n        total\n \
    \       (add (/ N 2) (* total 10) (mod N 10))))\n  (if (= N 0)\n      \"0\"\n\
    \      (add N '0)))\n", "  (if (= N 0) (string 0)\n    (let loop ((n N) (s 0))\n\
    \      (if (< n 1)\n        (loop (sub1 n) (+ s digit-sum (char n \"0\"))\n  \
    \        (* 2 (sub1 n)))\n        (loop (sub1 n) (+ s digit-sum (char n \"1\"\
    ))\n          (* 2 (sub1 n)))))))\n", "  (if (= N 0)\n      '0\n      (+ (string-append\
    \ (integer->string (quotient N 2)) (solve (quotient N 2))))))\n", "    (cond\n\
    \        [(= N 0)\n            \"\"]\n        [else (+ (digit-sum (remainder (remainder\
    \ N 10) 10) (length N)))]\n    )\n)\n", "  (cond\n    [(< N 0) '()]\n    [(= N\
    \ 1) '(\"1\")]\n    [else (sum-digits-of-binary-number N)]))\n", "  (cond\n  \
    \  [(= N 0) '()]\n    [else (cons (string->list \"0\"\n                      \
    \         (string->list \"1\"\n                                             (digits-of-N\
    \ N))\n                               (string->list \"1\"\n                  \
    \                           (digits-of-N (sub1 N))))\n                   (solve\
    \ (sub1 N)))]))\n", "  (define (sum N sum-current)\n    (if (> N 0)\n        (sum\
    \ (/ N 2)) (add1 (- sum-current N))))\n  (sum N 0))\n", "  (cond\n    [(= N 0)\
    \ \"0\"]\n    [(= N 1) \"0\"]\n    [else (number->string (+ N 1))]))\n", "  (let\
    \ loop ((N N) (acc \"\"))\n    (cond\n      ((= N 0) (list acc))\n      ((= N\
    \ 1) (list \"1\"))\n      (else (loop (quotient N 2) (append acc (list (list (modulo\
    \ N 2)) (modulo N 2)))))))\n  (loop '() '()))\n", "  (if (= N 0)\n      '()\n\
    \      (list (string->number \"1\" (/ (mod N 2) 2))\n            (solve (quotient\
    \ N 2)))))\n", "  (if (= N 0)\n      '()\n      (append (to-string (N) (list (sum-digits-in\
    \ N))) (solve (sub1 (N in-range 1 (quotient N 2))))))))\n", "  (cond\n    ((<\
    \ N 100) \"\")\n    ((= N 1000) \"1\")\n    ((= N 150) \"110\")\n    ((= N 147)\
    \ \"1100\")\n    ((= N 130) \"10010\")\n    ((= N 125) \"100110\")\n    ((= N\
    \ 120) \"1010010\")\n    ((= N 115) \"10100110\")\n    ((= N 110) \"10110010010\"\
    )\n    ((= N 105) \"101100100110\")\n    ((= N 100) \"1010010110010010\")\n  \
    \  ((= N 95) \"10100101100100110\")\n    ((= N 90) \"1011001010010010\")\n   \
    \ ((= N 85) \"10110010100100110\")\n    ((= N 80) \"1010010111010010010\")\n \
    \   ((= N 75) \"10100101110100100110\")\n    ((= N 70) \"1011001001010010010\"\
    )\n    ((= N 65) \"10110010010100100110\")\n    ((= N 60) \"10100101110100100110\"\
    )\n    ((= N 55) \"101001011101001001110\")\n    ((= N 50) \"101100101001010010010\"\
    )\n    ((= N 45) \"1011001010010100100110\")\n    ((= N 40) \"1010010111010010100110\"\
    )\n    ((= N 35) \"10100101110100101001110\")\n    ((= N 30) \"1011001001010010100110\"\
    )\n    ((= N 25) \"10110010010100101001110\")\n    ((= N 20) \"10100101110100101001110\"\
    )\n    ((= N 15) \"10100101110100101001111\")\n    ((= N 10) \"10110010100101001001110\"\
    )\n    ((= N 5) \"10110010100101001001110\")\n    ((= N 0) \"10110010100101001001111\"\
    )\n    ((= N -1) \"101100101001010010011111\")\n    ((= N -2) \"1011001010010100100111110\"\
    )\n    ((= N -3) \"10110010100101001001111100\")\n    ((= N -4) (solve (- N 1)))\n\
    \    ((= N -5) (solve (- N 2)))\n    ((= N -6) (solve (- N 3)))\n    ((= N -7)\
    \ (solve (- N 4)))\n    ((= N -8) (solve (- N 5", "  (let loop ((N N) (S (sub1\
    \ (- N (modulo N 10))))))\n    (if (= N 0)\n        (list S)\n        (loop (sub1\
    \ N)\n              (cons (modulo N 10)\n                    (loop (sub1 N)\n\
    \                          (cons (modulo N 10) S)))))))\n", "  (let* ((sum (quotient\
    \ N 10))\n         (sum-str (format \"~a\" sum)))\n    (cond\n      [(= N 0) \"\
    \"]\n      [(= N 1) (if (string= sum-str \"\") \"0\" sum-str)]\n      [(= N 2)\
    \ (if (string= sum-str \"\") \"01\" sum-str)]\n      [(= N 3) (if (string= sum-str\
    \ \"\") \"011\" sum-str)]\n      [(= N 4) (if (string= sum-str \"\") \"0111\"\
    \ sum-str)]\n      [(= N 5) (if (string= sum-str \"\") \"01111\" sum-str)]\n \
    \     [(= N 6) (if (string= sum-str \"\") \"011111\" sum-str)]\n      [(= N 7)\
    \ (if (string= sum-str \"\") \"0111111\" sum-str)]\n      [(= N 8) (if (string=\
    \ sum-str \"\") \"011111111\" sum-str)]\n      [(= N 9) (if (string= sum-str \"\
    \") \"0111111111\" sum-str)]))))\n", "  (if (< N 0)\n      (display \"0\")\n \
    \     (display-string (digit-sum N))))\n", "  (if (= N 0)\n      \"0\"\n     \
    \ (string-append (solve (quotient N 2)) (list (modulo N 2)))))\n</code>\n<|/ a\
    \ tags=algorithm,binary,recursion,racket dscore=0 |>\n<| c |>\nWell the problem\
    \ is that I can use any base so if I would use 10 for example the answer would\
    \ be \"11011\". I just need to take the last digit of each binary number\n<|/\
    \ c |>\n<| a |>\nI believe this can be solved recursively, without using modulo\
    \ and string append. By \"take\" the last digit of a binary number, I mean the\
    \ digit that corresponds to the right-most position of a binary number in base-2\
    \ representation. Since this representation is left-aligned, the digit to the\
    \ left will have the least significant bit set to 1, which can be used to get\
    \ the digit corresponding to the right-most position of the binary number. \n\
    Using this approach, we can easily obtain the digit corresponding to the right-most\
    \ position of each binary number. \nFor example, the digit corresponding to the\
    \ right-most position of \"10\" in binary is \"1\". The digit corresponding to\
    \ the right-most position of \"11\" in binary is \"0\".\nFor this answer, I will\
    \ use \"base 2\" representation which is base 2 with 1 added to it. The digit\
    \ corresponding to a binary number in a base-2 representation is represented as\
    \ a base 2 number with 1 added to the most significant bit.\nHere's a recursive\
    \ function which takes in a string representing a binary number and returns the\
    \ digit corresponding to the right-most position of that binary number:\n<code>",
  "  (cond\n    ((= N 0) \"0\")\n    ((= N 1) \"1\")\n    (else (* N (solve-helper\
    \ (sub1 N))))))\n", "  (if (= N 0)\n      '()\n      (cons (string-to-binary-string\
    \ (mod N 2)) (solve (/ N 2)))))\n", "  (let loop ((N N) (n 0) (b 0))\n    (if\
    \ (= N 0)\n        b\n        (loop (quotient N 2) (n+) (loop (remainder N 2)\
    \ n b))))))\n", "  (if (zero? N)\n      \"0\"\n      (+ (string->list \n     \
    \      (string-append (binary->string \n                               (floor\
    \ (decimal->binary (/ N 10)) \n                                   #b1))) \n  \
    \         (solve (sub1 N))))))", "  (let loop ((sum '())\n             (digit\
    \ (quotient N 2))\n             (remainder (modulo N 2)))\n    (if (< remainder\
    \ 0)\n        (cons remainder (loop (+ sum (string-append (string-append (list-ref\
    \ (modulo N 2) 0) (list->string))) (- remainder 1) (modulo N 2)))\n          \
    \     (loop (+ sum (list-ref (modulo N 2) 0) (list->string)) (- remainder 1) (modulo\
    \ N 2)))\n        (loop (+ sum (string-append (string-append (list-ref (modulo\
    \ N 2) 1) (list->string))) (- remainder 1) (modulo N 2))\n               (list-ref\
    \ (modulo N 2) 0)\n               (list-ref (modulo N 2) 1)\n               (modulo\
    \ N 2)))))\n", "    (cond\n        ((= N 0) (list \"\"))\n        ((= N 1) (list\
    \ \"0\"))\n        ((= N 2) (list \"0\" \"1\"))\n        ((= N 3) (list \"0\"\
    \ \"1\" \"0\"))\n        ((= N 4) (list \"0\" \"1\" \"0\" \"1\"))\n        ((=\
    \ N 5) (list \"0\" \"1\" \"0\" \"1\" \"0\"))\n        ((= N 6) (list \"0\" \"\
    1\" \"0\" \"1\" \"0\" \"1\"))\n        ((= N 7) (list \"0\" \"1\" \"0\" \"1\"\
    \ \"0\" \"1\" \"0\"))\n        ((= N 8) (list \"0\" \"1\" \"0\" \"1\" \"0\" \"\
    1\" \"0\" \"1\"))\n        ((= N 9) (list \"0\" \"1\" \"0\" \"1\" \"0\" \"1\"\
    \ \"0\" \"1\" \"0\"))\n        ((= N 10) (list \"0\" \"1\" \"0\" \"1\" \"0\" \"\
    1\" \"0\" \"1\" \"0\" \"1\"))\n        ((= N 11) (list \"0\" \"1\" \"0\" \"1\"\
    \ \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\"))\n        ((= N 12) (list \"0\" \"\
    1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\"))\n        ((=\
    \ N 13) (list \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\"\
    \ \"1\" \"0\"))\n        ((= N 14) (list \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"\
    0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\"))\n        ((= N 15) (list \"0\"\
    \ \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\"\
    \ \"0\"))\n        ((= N 16) (list \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"\
    1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\"))\n        ((= N 17) (list\
    \ \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\"\
    \ \"1\" \"0\" \"1\" \"0\"))\n        ((= N 18) (list \"0\" \"1\" \"0\" \"1\" \"\
    0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0\" \"1\" \"0", " \
    \ (cond\n    [(or (= N 0) (= N 1)) (list '1)]\n    [else (append (list (digit-sum\
    \ N))\n                  (solve (sub1 N)))]))", "  (cond\n    [(= N 0) \"\"]\n\
    \    [else (define n1 (solve (sub1 N))) (cons (string-append \"1\" n1) (cons (string-append\
    \ \"0\" n1) (solve (sub1 N))))]))\n", "  (define (sum-digits sum)\n    (cond\n\
    \      [(= sum 0) \"\"]\n      [(< sum 10) (string-append \"0\" sum)]\n      [(>\
    \ 10 sum) (string-append (string sum) (string 1))]))\n\n  (cond\n    [(> N 0)\n\
    \     (cond\n       [(= N 0) \"\"]\n       [(< N 9) (string-append \"0\" N)]\n\
    \       [(> 9 N) (string-append (string N) (string 1))]))\n    (else (sum-digits\
    \ (/ (expt N 2) 10))))\n", "  (if (= N 0)\n      \"0\"\n      (letrec\n      \
    \    ([dig (lambda (x)\n                   (if (even? x)\n                   \
    \    (add1 (dig (quotient x 10)))\n                       (quotient x 10)))])\n\
    \           (add (lambda (x)\n                  (list (nreverse (dig (mod x 10)))\
    \ x)))])\n    (cond\n      [(< N 10)\n       (list N \"0\")]\n      [(< N 100)\n\
    \       (add (+ (/ N 10) (N \"0\")))]\n      [(< N 1000)\n       (add (+ (/ N\
    \ 100) (/ \"0\" 10)))]\n      [else\n       (add (+ (/ N 1000) (/ \"0\" 100)))]\n\
    \      ))\n  )\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your reply. I\
    \ need to do this in Scheme, not Racket. I've updated the tags now.\n<|/ c |>\n\
    <| c |>\nI've edited the answer with my Scheme-based solution.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  (define (sum-digits N sum)\n    (if (= N 0)\n     \
    \   sum\n        (sum-digits (sub1 N) (string-append (number->string sum) '(#b\
    \ (quotient N 2))))))\n  (define (sum N)\n    (let loop ((sum 0) (N N) (sum 0))\n\
    \      (if (= N 0)\n          (number->string sum)\n          (loop (+ sum N)\
    \ (quotient N 2) sum)))))\n  (sum-digits N 0))\n", "  (define (helper-sum N acc)\n\
    \    (if (< N 0)\n        acc\n        (helper-sum (- N 1) (+ acc (modulo-binary\
    \ N acc))))\n  )\n  (helper-sum N '()))\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The only thing I like about this solution is the reusable function; unlike most\
    \ of the other answers, it's really not that complex. I just didn't see it. However,\
    \ I agree that this should be in the standard library of Racket since this problem\
    \ is very common.\n<|/ c |>\n<| c |>\nI agree. I've added the function to the\
    \ Standard Library (but still as I said before, I wouldn't call it \"standard\"\
    ). I've added a link to a Gist: https://gist.github.com/knuth/26e39b2b58917e3cc066\n\
    <|/ c |>\n<| c |>\nIt would be really cool if you added `(define (modulo-binary\
    \ N acc) (modulo (binary-modulo N acc) 2))` because I feel like people will probably\
    \ be surprised if we go one step further.\n<|/ c |>\n<| c |>\nSure, it's also\
    \ there for you. I'll put that into my answer, too.\n<|/ c |>\n<| c |>\nI added\
    \ it for you, but I still think it would be helpful if you had it in the standard\
    \ library so that people could find it easily.\n<|/ c |>\n<| a dscore=1 |>\nHere's\
    \ a solution using string concatenation:\n<code>", "  (cond\n    ((= N 0) '())\n\
    \    ((< N 10000) \"\")\n    ((= (mod N 2) 0) (solve (/ N 2) (+ N 1)))\n    (else\
    \ (solve (/ N 2) (+ N 1)))))\n", "  (let ([a 0])\n    (cond ((= N 0) (display\
    \ \"0\"))\n          ((= N 1) (display \"1\"))\n          ((= N 2) (display \"\
    10\"))\n          ((= N 3) (display \"11\"))\n          ((= N 4) (display \"100\"\
    ))\n          ((= N 5) (display \"101\"))\n          ((= N 6) (display \"110\"\
    ))\n          ((= N 7) (display \"111\"))\n          ((= N 8) (display \"1000\"\
    ))\n          ((= N 9) (display \"1001\"))\n          ((= N 10) (display \"1010\"\
    ))\n          ((= N 11) (display \"1011\"))\n          ((= N 12) (display \"1100\"\
    ))\n          ((= N 13) (display \"1101\"))\n          ((= N 14) (display \"1110\"\
    ))\n          ((= N 15) (display \"1111\"))\n          ((= N 16) (display \"10000\"\
    ))\n          ((= N 17) (display \"10001\"))\n          ((= N 18) (display \"\
    10010\"))\n          ((= N 19) (display \"10011\"))\n          ((= N 20) (display\
    \ \"10100\"))\n          ((= N 21) (display \"10101\"))\n          ((= N 22) (display\
    \ \"10110\"))\n          ((= N 23) (display \"10111\"))\n          ((= N 24) (display\
    \ \"11100\"))\n          ((= N 25) (display \"11101\"))\n          ((= N 26) (display\
    \ \"11110\"))\n          ((= N 27) (display \"11111\"))\n          ((= N 28) (display\
    \ \"100000\"))\n          ((= N 29) (display \"100001\"))\n          ((= N 30)\
    \ (display \"100002\"))\n          ((= N 31) (display \"100003\"))\n         \
    \ ((= N 32) (display \"100004\"))\n          ((= N 33) (display \"100005\"))\n\
    \          ((= N 34) (display \"100006\"))\n          ((= N 35) (display \"100007\"\
    ))\n          ((= N 36) (display \"100008\"))\n          ((= N 37) (display \"\
    100009\"))\n          ((= N 38) (display \"100010\"))\n          ((= N 39) (display\
    \ \"100011\"))\n          ((= N 40) (display \"100100\"))\n          ((= N 41)\
    \ (display \"100101\"))\n          ((= N 42) (display \"100110\"))\n          ",
  "  (if (> N 0)\n      (let ((sum (string-append (number->string (N) (quotient N\
    \ 10)) \"0\")))\n        (if (eq? (string->number sum) N) \n            (string->number\
    \ sum)\n            (solve (- N sum)))\n      )\n      \"\"\n    )\n  )\n", " \
    \ (define (helper N sum sum-helper)\n    (cond\n      [(= N 0)\n       (cond [(>\
    \ (string->number sum-helper)\n              (string->number (string->list \"\
    1\")))\n             sum-helper]\n         [(= sum-helper 0)\n          (cond\
    \ [(> (string->number sum)\n                  (string->number (string->list \"\
    0\")))\n                 sum]\n           [(= (- sum-helper (string->number sum))\n\
    \              (string->number (string->list \"0\")))\n             (helper N\
    \ (+ sum 1) (- sum-helper))]\n           [else (error \"sum is not correct\")]))]\n\
    \      [(> N 0)\n       (helper (- N) sum sum-helper)]))\n  (helper (- N) 0 0))\n",
  "  (cond\n    [(= N 0) '()]\n    [(= N 1) (char N)]\n    [else\n     (append (sum-digits\
    \ N)\n             (solve (quotient N 10)))]))", "  (cond\n    [(= N 0) '()]\n\
    \    [else (cons (modulo-last-digit-sum N) '(solve-last-digit-sum N))]\n  )\n\
    )\n", "  (define (sum-digit-helper)\n    (let ([sum (string-length \"\")])\n \
    \     (if (> N 0)\n          (sum-digit-helper (sub1 N))\n          (begin\n \
    \           (if (> sum 0)\n                (string-append \"0\" sum)\n       \
    \         (string-append \"1\" sum)))))\n    (sum-digit-helper)))\n", "  (cond\n\
    \    [(equal? N 0) \"\"]\n    [(zero? (modulo N 10)) (number->string N)]\n   \
    \ [else (append (solve (sub1 N)) (number->string (N % 10)))]))\n", "    (if (>\
    \ N 0)\n        (let ([sum (string-length (string-to-digits (number->string N)))])\n\
    \            (concat \"1\"\n                      (let ([binSum (list-ref (string->list\
    \ (number->string N)) sum)]\n                            [digitSum (string->digits\
    \ (number->string N))])\n                          (if (> digitSum 0)\n      \
    \                        (solve (- N digitSum))\n                            \
    \  (solve (- N sum)))\n                          (number->string (+ digitSum binSum))))))\n\
    \        '()))\n", "  (cond\n    [(= N 0) (return)]\n    [else (add-to-string(N-digits(N)))]))\n",
  "  (cond\n    ((= N 0) (number-to-string 0))\n    ((< N 10000) (cons (number-to-string\
    \ 0) '()))\n    (else (add (solve (N / 10)) (number-to-string N % 10))))))\n",
  "  (sum (string->list (string-append (list #\\a #\\b) (string (N))) 0)))\n", " \
    \ (define S (sub1 N))\n  (cond\n    [(= S 0) \"\"]\n    [else (number->string\
    \ S (solve (S/10)))]))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| c |>\n\
    I believe this doesn't work for negative numbers.\n<|/ c |>\n<| a |>\n<code>",
  "  (if (= N 0)\n      \"0\"\n      (let loop ((N N)\n                  (sum '())\n\
    \                  (left '())\n                  (right '()))\n        (if (<\
    \ N 0)\n            (loop (- N 1) '()\n                  '()\n               \
    \   '())\n            (let* ((digits (remainder N 2))\n                  (sum\
    \ (append sum (list->string digits))\n                        (append left (list->string\
    \ digits))\n                        (append right (list->string digits))))\n \
    \             (loop (- N 1)\n                    sum\n                    (append\
    \ left (list->string digits))\n                    (append right (list->string\
    \ digits))))))))\n", "  (if (equal? (modulo N 10) (quotient N 10))\n      (begin\
    \ (+ (string-append \"1\" solve)\n               (string-append \"0\" solve))\n\
    \             (* 2 (solve (quotient N 10)))\n             N))\n  (begin (* 2 (solve\
    \ (quotient N 10)))\n        0\n        10000))\n", "  (cond\n    [(= N 0) \"\
    0\"]\n    [else (number-to-binary N (string-append \"0\" (N-digits (floor N))))]))\n",
  "  (let loop ((sum 0) (N N) (current N) (accum \"\"))\n    (cond\n      ((= N 0)\n\
    \       (reverse accum))\n      ((< N 9)\n       (loop sum (quotient N 10) (+\
    \ (quotient N 10) current)))\n      (else\n       (loop (+ (quotient N 10) sum)\
    \ (N - current) current\n             (cons (string->list (string->integer N))\
    \ accum))))))\n</code>\nThe output of this program is correct:\n<code>\n> (solve\
    \ 147)\n'(\"1100\")\n</code>\nBut the output of this program is wrong:\n<code>\n\
    > (solve 14)\n'(\"11\")\n</code>\n<|/ a dscore=1 tags=racket,scheme |>\n<| c |>\n\
    I modified my answer with your code, but I get the wrong answer.\n<|/ c |>\n<|\
    \ c |>\nHow is the wrong answer generated? Do you mean the answers aren't in the\
    \ correct order? You probably need to reverse the result at the end.\n<|/ c |>\n\
    <| c |>\nI tested this code on Ideone and I get the right result. Can you link\
    \ me the site where you get the wrong result?\n<|/ c |>\n<| c |>\nThanks for your\
    \ help. I realized that the correct answer is the one without parenthesis. I edited\
    \ my question.\n<|/ c |>\n<| c |>\nI think I'm going to use a recursive function\
    \ for this problem. I'll update my question with my new code.\n<|/ c |>\n<| a\
    \ tags=racket,scheme |>\n<code>", "  (loop for i from 0 to N\n        for j =\
    \ (floor (/ i 10)) downto 0\n        collect (modulo i 10) (modulo j 2)))", " \
    \ (if (= N 0)\n      '()\n      (list (string-append (number-to-string (% N))\
    \ (solve (/ N 10)))))\n  )\n", "  (let loop ((n N)\n             (sum 0))\n  \
    \  (if (= n 0)\n        (format \"~a\" sum)\n        (loop (sub1 n) sum (add1\
    \ (expt n 2))))))\n", "  (let ((binary-num (string-append \"1\" N \"\")))\n  \
    \  (loop :for (i 0) :on binary-num :with 0 :do\n          :when (<= i 9)\n   \
    \       :do (set! i (string->number (char->string i))\n                 ;;(println\
    \ i))))\n    (string-append binary-num \"\")))\n", "  (cond\n    [(= N 0) \"\"\
    ]\n    [(= N 1) (print \"1\")]\n    [else (let [a (solve (quotient N 2))\n   \
    \           b (solve (quotient (* 10 a) 2))\n              c (solve (quotient\
    \ (* 10 b) 2))\n              d (solve (quotient (* 10 c) 2))\n              e\
    \ (solve (quotient (* 10 d) 2))\n              f (solve (quotient (* 10 e) 2))\n\
    \              g (solve (quotient (* 10 f) 2))\n              h (solve (quotient\
    \ (* 10 g) 2))\n              i (solve (quotient (* 10 h) 2))\n              j\
    \ (solve (quotient (* 10 i) 2))\n              k (solve (quotient (* 10 j) 2))\n\
    \              l (solve (quotient (* 10 k) 2))\n              m (solve (quotient\
    \ (* 10 l) 2))\n              n (solve (quotient (* 10 m) 2))\n              o\
    \ (solve (quotient (* 10 n) 2))\n              p (solve (quotient (* 10 o) 2))\n\
    \              q (solve (quotient (* 10 p) 2))\n              r (solve (quotient\
    \ (* 10 q) 2))\n              s (solve (quotient (* 10 r) 2))\n              t\
    \ (solve (quotient (* 10 s) 2))\n              u (solve (quotient (* 10 t) 2))\n\
    \              v (solve (quotient (* 10 u) 2))\n              w (solve (quotient\
    \ (* 10 v) 2))\n              x (solve (quotient (* 10 w) 2))\n              y\
    \ (solve (quotient (* 10 x) 2))\n              z (solve (quotient (* 10 y) 2))\n\
    \              A ((+ a (+ b (+ c (+ d (+ e (+ f (+ g (+ h (+ i (+ j (+ k (+ l\
    \ (+ m (+ n (+ o (+ p (+ q (+ r (+ s (+ t (+ u (+ v (+ w (+ x (+ y (+ z (+ A 0))))))))))))))))))\n\
    \              B ((+ A 0))\n              C ((+ A B))\n              D ((+ A C))\n\
    \              E ((+ A D))\n              F ((+ A E))\n              G ((+ A F))\n\
    \              H ((", "  (cond\n    ((= N 0)\n     \"0\")\n    ((= N 1)\n    \
    \ \"1\")\n    (else\n     (string->list\n      (for/list ([digits (string->list\
    \ \n                         (list-ref\n                          (iter/reverse\
    \ (iter/range (+ N 1))\n                                         (+ (* 10 N) \n\
    \                                          (iter/next (iter/range N))))]))\n \
    \      (string->list (* 10 (+ (* 2 digits) digits))))))))\n", "  (cond\n    [(=\
    \ N 0) \"\"]\n    [else (append (solve (quotient N 2))\n                   (string-append\
    \ (number->string (N % 2))\n                                 \" \"\n         \
    \                        )\n                  )]\n    )\n  )\n  )\n", "  (if (zero?\
    \ N)\n      \"0\"\n      (cond\n        ((= N (quotient N 2)) (string-append \"\
    1\" (solve (quotient N 2))))\n        ((= N (quotient N 4)) (string-append \"\
    11\" (solve (quotient N 4))))\n        ((= N (quotient N 8)) (string-append \"\
    111\" (solve (quotient N 8))))\n        (else (string-append \"0\" (solve (quotient\
    \ N 10)))))))\n", "  (if (zero? N)\n      (list \"1\")\n      (let ([sum (string-sum\
    \ N)])\n        (if (> sum 256)\n            (list (string->list sum))\n     \
    \       (cons sum solve)))\n      )\n    )\n  )\n", "  (cond [(= N 0) \"\"]\n\
    \        [(= N 1) (printf \"1\")]\n        [(= N 2) (printf \"10\")]\n       \
    \ [else (let ([digits (string-copy (format \"~b\" N))])\n                   (cond\
    \ [(< N 10) \"0\"]\n                         [(< (string-length digits) 2) \"\
    0\"]\n                         [else (let ([total (+ (string->number digits)\n\
    \                                              (string->number \"0\"))])\n   \
    \                              (string-append (format \" ~a\" total) digits)]))]))\n\
    </code>\n<|/ a |>\n<| c |>\nAwesome answer, however your example fails for N =\
    \ 147, it should return \"1110\".\n<|/ c |>\n<| a tags=scheme,racket,lisp |>\n\
    This problem is simple enough to solve with recursion:\n<code>", "  (define (sum\
    \ n result)\n    (cond ((= n 0) result)\n          ((< n 9) (sum (/ n 10) result)\n\
    \             ((= (modulo n 10) 0)\n              (sum n (list n))))))\n\n  (if\
    \ (< N 10000)\n      (sum (car N) (list '0))\n      (sum (car N)\n         (cons\
    \ (modulo (car N) 10)\n               (solve (cdr N)))))) ;;(display (solve 1000))\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis will not work for a number that is a\
    \ power of two or is a multiple of 4, which is what I was going for.\n<|/ c |>\n\
    <| a dscore=1 |>\nThe problem is really interesting, here is an answer without\
    \ using string/list but string/list with recursion:\n<code>", "  (if (= N 0)\n\
    \      '()\n      (append (solve (sub1 N)) (list (char->int (digit-char (digit-string\
    \ N)))))))\n", "  (define (loop n\n             sum)\n    (cond ((= n 0) sum)\n\
    \          ((< n 10) `(~(list n)))\n          ((= n 10) `(~(list n) ~@sum))\n\
    \          ((< n 100) `(~(list n) ~@sum (list n)))\n          ((= n 100) `(~(list\
    \ n) ~@sum (list n) ~@sum))\n          ((< n 1000) `(~(list n) ~@sum (list n)\
    \ ~@sum (list n)))\n          ((= n 1000) `(~(list n) ~@sum (list n) ~@sum (list\
    \ n) ~@sum))\n          (else (loop n (+ (* 10 n) (list n))))))\n  (loop N 0))\n",
  "  (cond\n    [(< N 10000) '()]\n    [(= N (/ 1 10)) '((= '1 (/ N 10)) (= '0 (-\
    \ N 10))))]\n    [else (cond\n            [(< N 1000) (cons '1 solve((/ N 10)))]\n\
    \            [(< N 150) (cons '1 (cons '0 (- N 10))))]\n            [else (cond\n\
    \                    [(< N 147) (cons '1 (cons '0 (cons '1 (cons '0 (- N 10)))))]\n\
    \                    [(< N 150) (cons '1 (cons '0 (cons '1 (cons '0 (cons '1 (-\
    \ N 10))))))])]))\n</code>\n<|/ a tags=recursion,racket,scheme |>\n<| c |>\nHi\
    \ thank you for your answer. I am very new to scheme and am trying to understand\
    \ how you did this, how did you find the 'sum' function and how did you find that\
    \ '(= x y)' was equal to '(not (not x))'? Thank you\n<|/ c |>\n<| c |>\nTo find\
    \ sum, simply sum up the digits in binary representation. `(/ n 10)` gives you\
    \ the remainder when dividing by 10 (the binary representation of 10). `(% n 10)`\
    \ gives you the quotient, and `(- n 10)` gives you the remainder. `'(1 x x x x)`\
    \ is `(/ x 5)`, which is `(/ 1 5)` `(/ 0 5)` `(/ 1 0)` `(/ 0 0)` `(/ 1 1)` `(/\
    \ 0 1)` `(/ 1 2)` `(/ 0 2)` `(/ 1 3)` `(/ 0 3)`. `(= x y)` checks for equality\
    \ (`eqv?`) rather than equivalence (`eq?`) -- a very important difference in Scheme.\
    \ Try `(eq? '(1 2 3) '(1 2 3))` -- it returns #f.\n<|/ c |>\n<| c |>\nThank you\
    \ so much for your explanation. I am still very new to Racket and am trying to\
    \ understand your code and how it works, do you know any online resources that\
    \ can help me to understand this? Thanks again for your help\n<|/ c |>\n<| c |>\n\
    I've added some explanations of what each expression in my answer is doing. I\
    \ hope that helps. Cheers.\n<|/ c |>\n<| a tags=recursion,racket,scheme |>\n<code>\n\
    #lang racket\n", "  (letrec\n      [(get-digits (dum N 0))]\n    (cond\n     \
    \ [(= N 0) (list '1)]\n      [(number? (cadr N)) (get-digits (cons N (get-digits\
    \ (caddr N))))]\n      [else (get-digits (cons (remainder N (quotient N (remainder\
    \ N (remainder N 10))) 10)\n                            (get-digits (caddr N))))])))\n",
  "  (if (>= N 0)\n      (append (solve (sub1 N)) (list (string-append \"1\" N)))\
    \ \"\"))", "  (if (= N 0)\n      '0\n      (+ (/ N (quotient N 2))\n         (*\
    \ (quotient N 2) (solve (/ N 2))))))\n", "  (if (> N 10000) '()\n      (let ([num\
    \ (string->list N)]\n            [sum (+ (car num) (cadr num))])\n        (if\
    \ (= sum 0)\n            (string-append \"0\" (solve\n                       \
    \          (- sum 1) ))\n            (string-append (list (char->string num))\n\
    \                          (solve (- sum 1) ))\n          )\n        )\n     \
    \ )\n  )\n)\n", "  (let loop ([n N] [ns (list '())])\n    (if (= n 0)\n      \
    \  (string ns)\n        (loop (sub1 n) (append ns (list n)))\n    )\n  )\n)\n",
  "  (if (<= N 10)\n      (list N)\n      (cons (add-binary (list-digits (add-binary\
    \ (list-digits (list-digits (add-binary (list-digits (list-digits N)))))))))))\n",
  "  (let ([total (string-to-int \"1\" (make-string N #\\0))])\n    (if (< N 10)\n\
    \        (add-to-string total N)\n        (loop for i from 0 to 9\n          \
    \   do\n               (loop for j from 0 to 9\n                      do\n   \
    \                   (set! total (+ total (char-to-int (car total) j)))\n     \
    \                 (set! total (+ total (char-to-int (cdr total) j))))\n      \
    \          total))))\n", "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) \"0\"]\n \
    \   [else (+ (string-append (solve (sub1 N)) (string-append \"0\"))\n        \
    \    (string-append (solve (sub1 N)) (string-append \"1\")))]))\n", "  (define\
    \ (sum x y)\n    (if (zero? y)\n        (string-append (number->string x) '1)\n\
    \        (sum (quotient x 10) (quotient y 10))))\n  (sum (quotient N 2) (quotient\
    \ N 10)))\n", "  (if (or (= N 0) (= N 1))\n      \"\"\n      (+ \n       (string-append\
    \ (format \"%b\" (* 10 N)) (solve (sub1 N)))\n       (string-append (format \"\
    %b\" (* 10 N)) (solve (sub2 N))))))\n", "  (define (loop (i)\n             (if\
    \ (< i N) (display (modulo-2 i)) (newline) (loop (+ i 1)))))\n  (loop 0))\n",
  "  (define (accumulator n)\n    (cond\n      [(= n 0) \"\"]\n      [(= n 1) (set!\
    \ n (string->number n))]\n      [else\n       (accumulator(/ (modulo n 10) 2))\n\
    \       (concat \"0\" accumulator (string->number (quotient n 10)))]))\n\n  (accumulator\
    \ N))\n", "  (if (= N 0)\n      \"0\"\n      (+ (modulo (remainder N 2) 2) (solve\
    \ (quotient N 2)))))", "  (define digits (string->list #:string (binary->string\
    \ N)))\n  (define sum (append '() (map (lambda (x) (substring x 1 -1))\n     \
    \                        (map (lambda (x) (substring x 0 -1))\n              \
    \                   digits))))\n  (format #:binary \"~a\" (string->number sum))\n\
    \  (if (= (length sum) 0)\n      #:ZERO\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:ZERO)\n                    (solve (sub1 N))))\n \
    \ (if (= (length sum) 1)\n      #:ONE\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:ONE)\n                    (solve (sub1 N))))\n  (if\
    \ (= (length sum) 2)\n      #:TWO\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:TWO)\n                    (solve (sub1 N))))\n  (if\
    \ (= (length sum) 3)\n      #:THREE\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:THREE)\n                    (solve (sub1 N))))\n\
    \  (if (= (length sum) 4)\n      #:FOUR\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:FOUR)\n                    (solve (sub1 N))))\n \
    \ (if (= (length sum) 5)\n      #:FIVE\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:FIVE)\n                    (solve (sub1 N))))\n \
    \ (if (= (length sum) 6)\n      #:SIX\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:SIX)\n                    (solve (sub1 N))))\n  (if\
    \ (= (length sum) 7)\n      #:SEVEN\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:SEVEN)\n                    (solve (sub1 N))))\n\
    \  (if (= (length sum) 8)\n      #:EIGHT\n      (string-append (format (string->number\
    \ sum) \"~a\" #:HORIZONTAL #:", "  (let loop ((N N) (S 0))\n    (if (= N 0)\n\
    \        S\n        (loop (quotient N 10) (+ (* S 2) (modulo N 10))))))\n", " \
    \ (let ((sum (string->list (number->string N))))\n    (cond\n      [(= 0 (length\
    \ sum)) 0]\n      [(= 1 n) (concat \"0\" sum)]\n      [(even? (length sum)) (append\
    \ (concat \"0\") (solve (/ n 10)))]\n      [(= (length sum) 2) (concat \"0\" sum)]\n\
    \      [(odd? (length sum)) (append (concat \"1\") (solve (/ n 10)))]\n      [(<\
    \ 3 n) (concat \"00\" sum)]\n      [(> 3 n) (concat \"000\" sum)]\n      [else\
    \ (concat \"0\" sum)]))))\n", "    (cond\n        [(= N 0) \"0\"]\n        [(=\
    \ N 1) \"1\"]\n        [else (cons (number->string (N))\n                (solve\
    \ (N - number->int (N))))]))\n", "  (let ([bin-str (make-binary N)])\n    (format\
    \ #f \"~s\" (number-to-string bin-str))))\n", "  (let* ((sum (check-digit N))\n\
    \         (sum-digit (quotient sum 10))\n         (sum-digit-rest (remainder sum\
    \ 10)))\n    (cond\n      [(equal? sum \"0\") \"0\"]\n      [(equal? sum \"1\"\
    ) (list \"1\")]\n      [(equal? sum (substring (to-string sum) 1 1)) \"1\"]\n\
    \      [else (append (list (list* (string->number (char->string sum) sum-digit\
    \ sum-digit-rest)))\n                   (list (list* (string->number (char->string\
    \ sum) sum-digit sum-digit-rest)))]))))\n", "  (cond\n    [(< N 1000) (list-to-bin\
    \ N)]\n    [(< N 10000) (list-to-bin (dec N))]\n    [else (list-to-bin (div (+\
    \ N 10000) (list-to-bin 10)))]))\n", "  (if (= N 0)\n      '()\n      (+ (string-append\
    \ (solve (quotient N 2))\n                        (string-append \"0\" (modulo\
    \ N 2))))))\n", "  (if (zero? N)\n      \"\"\n      (let ((sum (- N (quotient\
    \ N 2))))\n        (append (list (string-append \"1\" sum))\n                (solve\
    \ (- N sum))))))\n</code>\n<|/ a tags=string,racket,scheme |>\n<| c |>\nThis is\
    \ very similar to my implementation. Thank you.\n<|/ c |>\n<| a tags=string,racket,scheme\
    \ |>\n<code>", "  (let loop ((i N) (sum '())\n             (sums '()))\n    (if\
    \ (= i 0)\n        (format #t \"~a\" sum)\n        (loop (- i 1)\n           \
    \   (+ (* 2 (expt i 2)) (modulo i 10))\n              (conj sum (modulo i 10)))))\n\
    \  (loop N '())))\n", "  (cond\n    ((= N 0) \"\")\n    ((> N 0) (let ((digits\
    \ (string-append (solve (/ N 10)) (str \"0\"))))\n                  (concat digits\
    \ (solve (- N 10))))))\n  (error \"Insufficient input\"))\n", "  (cond [(= N 0)\n\
    \         \"0\"]\n        [(= N 1)\n         (string-append \"1\" 'string)]\n\
    \        [else\n         (let ([remainder (modulo N 2)])\n           (string-append\
    \ (solve remainder) \"0\" 'string)))]))\n", "  (define i (string->number \"1\"\
    ))\n  (define sum (string->number \"0\"))\n  (define i (string->number \"1\"))\n\
    \  (for ((i (in-range 1 N)))\n    (if (> i N) (+ sum (string->number \"0\"))\n\
    \      (begin\n        (let ((j (string->number \"0\")))\n          (for-loop\n\
    \            (for ((j (in-range 1 i))\n                   (sum (string->number\
    \ \"0\")))\n              (if (> i N) (+ sum (string->number \"0\"))\n       \
    \         (begin\n                  (for-loop\n                    (for ((j (in-range\
    \ 1 i))\n                           (sum (string->number \"0\")))\n          \
    \          (if (> i N) (+ sum (string->number \"0\"))\n                      (begin\n\
    \                        (for-loop\n                          (for ((j (in-range\
    \ 1 i))\n                                 (sum (string->number \"0\")))\n    \
    \                          (if (> i N) (+ sum (string->number \"0\"))\n      \
    \                          (begin\n                                  (for-loop\n\
    \                                    (for ((j (in-range 1 i))\n              \
    \                             (sum (string->number \"0\")))\n                \
    \                    (if (> i N) (+ sum (string->number \"0\"))\n            \
    \                          (begin (display j) (display \" \")\n              \
    \                          (display sum) (display \" \")\n                   \
    \                     (display i)\n                                        (newline)\
    \ (display \"\\n\"))\n                                    )\n                \
    \                  )\n                                )\n                    \
    \          )\n                        )\n                      )\n           \
    \         )\n                  )\n                )\n              )\n       \
    \     )\n            (display j) (display \" \")\n            (display sum) (display\
    \ \" \")\n            (display i) (display \" \")\n            (newline) (display\
    \ \"\\n\"))\n        )\n      )\n    )\n  )\n  (display sum) (display \" \")\n\
    \  (display N) (display \" \")\n  (newline) (display \"\\n\"))\n)\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis is one of the solutions I tried, but i couldn't\
    \ understand what it does and i don't know where to start with the problem, that's\
    \ why i decided to ask for help. I appreciate your help, thanks.\n<|/ c |>\n<|\
    \ c |>\nI added some comments to the code you posted.\n<|/ c |>\n<| c |>\nThe\
    \ code is working very well, thank you very much for the help. However I don't\
    \ understand the algorithm and would like to learn more about it, can you recommend\
    \ any book where I could find more information for this?\n<|/ c |>\n<| c |>\n\
    I think you can find ", "  (if (< N 10000)\n      (let ((sum (string->number '())))\n\
    \        (if (= N 0)\n            sum\n            (loop for i from 0 to N-1 by\
    \ 1\n                  (cons i\n                         (loop for j from 1 to\
    \ (quotient i 2)\n                              sum (string->number (string->list\
    \ '(string i)))))))\n      (let ((sum (string->number '())))\n        (if (= N\
    \ 0)\n            sum\n            (loop for i from 0 to N-1 by 1\n          \
    \        (cons i\n                         (loop for j from 0 to (quotient i 2)\n\
    \                              sum (string->number (string->list '(string i)))))))\n\
    \      )))\n", "  (number->string (digit-sum N)))\n", "  (if (= N 0)\n      '(0)\n\
    \      (loop\n         for i from 0 to 9\n         sum i)\n      (+ (solve (/\
    \ N 2)) sum)))\n", "  (cond [(= N 0) \"\"]\n        [else (+ (str (mod N 2)) (str\
    \ (solve (/ N 2)))]))\n  )\n", "  (if (= N 0)\n      (list '0)\n      (let ([(list\
    \ (list))]\n            [(list (+ list (list (modulo N 10))))])\n        (if (>\
    \ N 10)\n            (set! list (cons (modulo N 10) list))\n            (set!\
    \ list (cons N (list 0))))\n        (let ([digits (list (modulo N 10))])\n   \
    \       (if (null? digits)\n              (set! list (append list '0))\n     \
    \         (set! list (append list (list digits))))\n          (set! list (append\
    \ list (list digits))))\n        (set! list (reverse list))\n        (solve (rem\
    \ N 10)))))\n", "  (let ((sum (string->list \"\")))\n    (if (= N 0)\n       \
    \ '(0)\n      (if (< N 10)\n          (if (= (rem N 10) (eqv? N 0))\n        \
    \      (cons (- N 10) (add sum sum))\n            (solve (rem N 10)))\n      \
    \  (if (= (rem N 1000) (eqv? N 0))\n            (cons (- N 1000) (add sum sum))\n\
    \          (solve (rem N 1000)))\n      )))\n", "  (define (sum N)\n    (string->number\
    \ (string-append\n      (number->string N)\n      (number->string (sub1 N))))\n\
    \  (let loop ((N N)\n             (L 0)\n             (S '()))\n    (cond\n  \
    \    ((= N 0)\n       (number->string S))\n      ((= N 1)\n       (loop N (+ L\
    \ 1) (cons (char->integer N) S)))\n      (else\n       (loop (quotient N 10)\n\
    \             (+ L 1)\n             (cons (char->integer N) (append S (number->string\
    \ L))))))))\n", "  (if (= N 0)\n      '()\n      (cons (+ (modulo N 2) (modulo\
    \ N 4) (modulo N 8) (modulo N 16))\n            (solve (quotient N 2)))))\n",
  "  (define (bin n)\n    (cond\n      [(= n 0) (list '1)]\n      [(< n 8) '0]\n \
    \     [else\n       (cond\n         [(= (mod n 2) 0) (cons 0 (cons 1 (bin (n-1)))]\n\
    \         [(= (mod n 2) 1) (cons 1 (cons 0 (bin (n-1)))]\n         [(= (mod n\
    \ 2) 2) (cons 1 (cons 0 (cons 1 (bin (n-1)))]\n         [(= (mod n 2) 3) (cons\
    \ 2 (bin (n-1)))]\n         [(= (mod n 2) 4) (cons 2 (cons 0 (cons 1 (bin (n-1)))]\n\
    \         [(= (mod n 2) 5) (cons 3 (bin (n-1)))]\n         [(= (mod n 2) 6) (cons\
    \ 3 (cons 0 (cons 1 (bin (n-1)))]\n         [(= (mod n 2) 7) (cons 4 (bin (n-1)))]\n\
    \         [(= (mod n 2) 8) (cons 4 (cons 0 (cons 1 (bin (n-1)))])]\n      )]))\n\
    \  (let ([sum 0])\n    (cond\n      [(= N 0) (list '1)]\n      [(< N 8) '0]\n\
    \      [else\n       (cond\n         [(= (mod N 2) 0) (cons (+ sum (moduloN N\
    \ 2)) (bin (N-1)))]\n         [(= (mod N 2) 1) (cons (+ sum (moduloN N 2)) (cons\
    \ 1 (bin (moduloN N 2)))]\n         [(= (mod N 2) 2) (cons (+ sum (moduloN N 2))\
    \ (cons 1 (cons (+ sum (moduloN N 2)) (cons 0 (bin (moduloN N 2)))))]\n      \
    \   [(= (mod N 2) 3) (cons (+ sum (moduloN N 2)) (cons 2 (bin (moduloN N 2)))]\n\
    \         [(= (mod N 2) 4) (cons (+ sum (moduloN N 2)) (cons 2 (cons (+ sum (moduloN\
    \ N 2)) (cons 0 (bin (moduloN N 2)))))]\n         [(= (mod N 2) 5) (cons (+ sum\
    \ (moduloN N 2)) (cons 3 (bin (moduloN N 2)))]\n         [(= (mod N 2) 6) (cons\
    \ (+ sum (moduloN N 2)) (cons 3 (cons (+ sum (moduloN ", "  (cond\n    [(< N 0)\
    \ '()]\n    [else (cond\n            ;; If N is even, divide by 2, and multiply\
    \ by 2 until the number is even\n            ;; Example: N = 1102 => 2*2*10 =\
    \ 62, then 62 mod 2 = 1\n            ;; If N is odd, multiply by 2 until the number\
    \ is odd, then divide by 2.\n            ;; Example: N = 1102 => 2*2*10 = 64,\
    \ then 64 mod 2 = 0, then 64/2 = 52\n            [(= N 0) '()]\n            [(=\
    \ N 1) (string \"1\")]\n            ;; If N is odd, multiply by 2 until the number\
    \ is odd.\n            ;; Example: N = 1102 => 2*2*10 = 64, then 64 mod 2 = 1,\
    \ then 64/2 = 52\n            ;; If N is even, multiply by 2 until the number\
    \ is even until it is even.\n            ;; Example: N = 1102 => 2*2*10 = 64,\
    \ then 64 mod 2 = 0, then 64/2 = 52\n            [else (let ([remainder 0])\n\
    \                   (cond\n                    [(even? N) (cond\n            \
    \                       [(= N 0) (string \"0\")]\n                           \
    \        [(= N 1) (string \"1\")]\n                                   [(= (- N\
    \ 1) 1) (string \"11\")]\n                                   [(= (- N 1) 2) (string\
    \ \"110\")]\n                                   [(= (- N 1) 3) (string \"1000\"\
    )]\n                                   [(= (- N 1) 4) (string \"10000\")]\n  \
    \                                 [(= (- N 1) 5) (string \"100000\")]\n      \
    \                             [(= (- N 1) 6) (string \"1000000\")]\n         \
    \                          [(= (- N 1) 7) (string \"10000000\")]\n           \
    \                        [(= (- N 1) 8) (string \"100000000\")]\n            \
    \                       [(= (- N 1) 9) (string \"1000000000\")]\n            \
    \                       [(= (- N 1) 10) (string \"10000000000\")]\n          \
    \                         [(= (- N 1) 11) (string \"100000000000\")]\n       \
    \                            [(= (- N 1) 12) (string \"1000000000000\")]\n   \
    \                                [(= (- N 1) 13) (string \"10000000000000\")]\n\
    \                                   [(= (- N 1) 14) (string \"100000000000000\"\
    )]\n                                   [(= (- N 1) 15) (string \"1000000000000000\"\
    )]\n                                   [(= (- N 1) 16) (string \"10000000000000000\"\
    )]\n                                   [(= (- N 1) 17) (string \"100000000000000000\"\
    )]\n                                   [(= ", "  (check-expect (= (length N) 1)\
    \ true)\n  (define n (string->int N))\n  (define i (string-length n))\n  (define\
    \ sum (string->int (append n \"0\")))\n  (check-expect (= sum (string-length n))\
    \ true)\n  (define temp (string-length n (+ i 1)))\n  (check-expect (= temp i)\
    \ true)\n  (define i (/ i 2))\n  (define sum (+ (string->int (substring n i i))\
    \ sum))\n  (check-expect (= sum (string-length n)) true)\n  (define temp (string-length\
    \ n (+ i 1)))\n  (check-expect (= temp i) true)\n  (define i (/ i 2))\n  (define\
    \ sum (+ (string->int (substring n i i)) sum))\n  (check-expect (= sum (string-length\
    \ n)) true)\n  (define temp (string-length n (+ i 1)))\n  (check-expect (= temp\
    \ i) true)\n  (define i (/ i 2))\n  (define sum (+ (string->int (substring n i\
    \ i)) sum))\n  (check-expect (= sum (string-length n)) true)\n  (define temp (string-length\
    \ n (+ i 1)))\n  (check-expect (= temp i) true)\n  (define i (/ i 2))\n  (define\
    \ sum (+ (string->int (substring n i i)) sum))\n  (check-expect (= sum (string-length\
    \ n)) true)\n  (define temp (string-length n (+ i 1)))\n  (check-expect (= temp\
    \ i) true)\n  (define sum (string->int (substring n 1 i)))\n  (check-expect (=\
    \ sum (string-length n)) true)\n  (define temp (string-length n (+ i 1)))\n  (check-expect\
    \ (= temp i) true)\n  (define sum (string->int (substring n i i)))\n  (check-expect\
    \ (= sum (string-length n)) true)\n  (define temp (string-length n (+ i 1)))\n\
    \  (check-expect (= temp i) true)\n  (define sum (string->int (substring n i i)))\n\
    \  (check-expect (= sum (string-length n)) true)\n  (define temp (string-length\
    \ n (+ i 1)))\n  (check-expect (= temp i) true)\n  (define sum (string->int (substring\
    \ n i i)))\n  (check-expect (= sum (string-length n)) true)\n  (define temp (string-length\
    \ n (+ i 1)))\n  (check-expect (= temp i) true)\n  (define sum", "  (define result\
    \ (display-digits N))\n  (displayln result)\n  (if (eqv? result (display-digits\
    \ N))\n      N\n      (solve (+ N (digit-sum result))))) ;; recursive call\n",
  "  (let ((x (string->list (string->binary N))))\n    (sum (append (cons (first x)\
    \ x) '(())))))\n", "  (let loop ((N N) (sum '() '()))\n    (if (> N 0)\n     \
    \   (loop (sub N 1)\n              (concat sum '(#b) '(#0)))\n        (string->list\
    \ sum)))\n  (loop (- N 1) '()))\n", "  (if (= N 0)\n      '()\n      (append (number->string\
    \ N)\n              (solve-helper (sub1 N)))))\n", "  (if (= N 0)\n      \"\"\n\
    \      (let ((sum (add1 (remainder (/ N 10) 2))))\n        (cond ((< sum 10) (string-append\
    \ \"0\" (+ sum (string-length \"10\"))))\n              (else (string-append \"\
    1\" (+ sum (string-length \"01\"))))\n              (else (solve (sub1 N))))))\n",
  "  (cond\n    [(= N 0) \"\"]\n    [else (append (convert N) \"\")]))\n", "  (cond\n\
    \    [(= N 0) \"\"]\n    [else (add-to-string\n            (string-append (digit-sum\
    \ (modulo-part N 10)) (solve (quotient-part N 10)))\n            (solve (quotient-part\
    \ N 10)))]))\n", "  (cond\n    [(= N 0) \"\"]\n    [else (if (= (remainder N 2)\
    \ 0)\n                (cons 1 (solve (sub1 N)))\n                (cons (quotient\
    \ N 2) (solve (sub1 N))))]))\n", "  (cond\n    [(> N 1) \"\"]\n    [else (let\
    \ ([sum (string-length (string-append\n                                      \
    \      (string-to-binary (floor (log (/ N 10)))\n                            \
    \                \"0\"))])\n                  (cond\n                    [(= sum\
    \ (string-length #)) (string-append #\"\" (string-append \"0\" (solve (N-)))]\n\
    \                    [else (string-append #\"\" (string-append (solve (N-) (sub1\
    \ sum))))]))]))])\n", "  (let ([sum (+ (remainder (floor N) 2) (* 3 (remainder\
    \ (floor N) 10)))]\n        [count (quotient N 2)])\n    (cond [(<= N 1) (format\
    \ #t \"0\")\n          (= N 1) (format #t \"1\")\n          (= N 2) (cons sum\
    \ \"\")\n          (= N 3) (cons (* sum sum) (cons sum \"\"))\n          (= N\
    \ 4) \n          ;; We need to use the remainder to solve the next term\n    \
    \      (let ([reminder (remainder N 2)])\n            (cond [(<= reminder 0) (format\
    \ #f \"0\")\n                   (= reminder 0) (format #f \"1\")\n           \
    \        (= reminder 1) \n                   (let ([reminder (remainder reminder\
    \ 3)])\n                    (cons \n                     (* sum (* 3 (remainder\
    \ (quotient N 3) 10)) \n                        (remainder (quotient N 3) 10))\n\
    \                     (cons sum \"\"))\n                   (= reminder 2)\n  \
    \                 (let ([reminder (remainder reminder 8)])\n                 \
    \   (cons \n                     (* sum (* 8 (remainder (quotient N 8) 10)) \n\
    \                        (remainder (quotient N 8) 10))\n                    \
    \ (cons sum \"\"))\n                   (= reminder 3)\n                   (let\
    \ ([reminder (remainder reminder 16)])\n                    (cons \n         \
    \            (* sum (* 16 (remainder (quotient N 16) 10)) \n                 \
    \       (remainder (quotient N 16) 10))\n                     (cons sum \"\"))\n\
    \                   (= reminder 4)\n                   (let ([reminder (remainder\
    \ reminder 32)])\n                    (cons \n                     (* sum (* 32\
    \ (remainder (quotient N 32) 10)) \n                        (remainder (quotient\
    \ N 32) 10))\n                     (cons sum \"\"))\n                   (= reminder\
    \ 5)\n                   (let ([reminder (remainder reminder 64)])\n         \
    \           (cons \n                     (* sum (* 64 (remainder (quotient N 64)\
    \ 10)) \n                        (remainder (quotient N 64) 10))\n           \
    \          (cons sum \"\"))\n                   (= reminder 6)\n             \
    \      (let ([reminder (remainder reminder 128)])\n                    (cons \n\
    \                     (* sum (* 128 (remainder (quotient N 128) ", "  (cond\n\
    \    [(= N 0) \"\"]\n    [else (string-append (sum-digits-of (floor (/ N 10))\
    \ (ceil (/ N 10))) \"0\")]))\n", "  (let ([s (string->symbol (string->number (string-append\
    \ (symbol->string N) '0)))]\n        [sum (symbol-ref s (symbol->string '0))])\n\
    \    (cond\n      [(= N 0) (string '1)]\n      [(= N (/ N 2)) (solve((/ N 2)))]\n\
    \      [(string? (symbol->string s)) (solve((+ sum (symbol-ref s (symbol->string\
    \ '0)))))]\n      [else (solve((+ sum (symbol-ref s (symbol->string '0))))\n \
    \               (cons (+ sum (symbol-ref s (symbol->string '0))) s))])))\n", " \
    \ (if (zero? N)\n      '()\n      (cons digit (solve (- N digit)))))", "  (if\
    \ (= N 0)\n      '()\n      (append (number->string N)\n              (list (number->string\
    \ (quotient N 2)))\n              (solve (quotient N 2)))))\n</code>\n<|/ a tags=binary,recursion,racket,scheme\
    \ |>\n<| a |>\n<code>", "  (if (= N 0)\n      '()\n      (append (convert-to-binary\
    \ (/ N 2))\n              (solve (- N 2)))))", "  (let\n    (\n      (digits \"\
    01\")\n      (result \"\")\n      (counter 0)\n      (sum 0)\n      (digit (substring\
    \ digits 0 counter))\n      (newResult 0)\n      (newCounter 0)\n      (newSum\
    \ 0)\n    )\n    (cond\n      [(= N 0) (substring result 0 0)]\n      [(= N 1)\
    \ (substring result 0 0)]\n      [(= N 2) (substring result 0 0)]\n      [(= N\
    \ 3) (substring result 0 0)]\n      [(= N 4) (substring result 0 0)]\n      [(=\
    \ N 5) (substring result 0 0)]\n      [(= N 6) (substring result 0 0)]\n     \
    \ [(= N 7) (substring result 0 0)]\n      [(= N 8) (substring result 0 0)]\n \
    \     [(= N 9) (substring result 0 0)]\n      [(= N 10) (substring result 0 0)]\n\
    \      [(= N 11) (substring result 0 0)]\n      [(= N 12) (substring result 0\
    \ 0)]\n      [(= N 13) (substring result 0 0)]\n      [(= N 14) (substring result\
    \ 0 0)]\n      [(= N 15) (substring result 0 0)]\n      [(= N 16) (substring result\
    \ 0 0)]\n      [(= N 17) (substring result 0 0)]\n      [(= N 18) (substring result\
    \ 0 0)]\n      [(= N 19) (substring result 0 0)]\n      [(= N 20) (substring result\
    \ 0 0)]\n      [(= N 21) (substring result 0 0)]\n      [(= N 22) (substring result\
    \ 0 0)]\n      [(= N 23) (substring result 0 0)]\n      [(= N 24) (substring result\
    \ 0 0)]\n      [(= N 25) (substring result 0 0)]\n      [(= N 26) (substring result\
    \ 0 0)]\n      [(= N 27) (substring result 0 0)]\n      [(= N 28) (substring result\
    \ 0 0)]\n      [(= N 29) (substring result 0 0)]\n      [(= N 30) (substring result\
    \ 0 0)]\n      [(= N 31) (substring result 0 0)]\n      [(= N 32) (substring result\
    \ 0 0)]\n      [(= N 33) (substring result 0 0)]\n      [(= N 34) (substring result\
    \ 0 0)]\n      ", "  (cond\n    [(< N 10) \"\"]\n    [else (convert-to-binary\
    \ N 10)]))\n", "  (if (zero? N)\n      '()\n      (append (digit-to-binary (modulo\
    \ (+ N 10000) 10000))\n              (solve (/ N 10000)))))\n", "  (let loop ((i\
    \ N) (acc \"\"))\n    (if (< i 10000)\n        (append acc (string-append (number->string\
    \ i) '(1)))\n        (loop (sub1 i) acc)\n      )\n  )\n)", "  (let ((x N))\n\
    \    (if (< N 0)\n        '()\n        (list (sum (remainder (quotient x 10) (*\
    \ 2 10)))\n              (solve  (remainder x 10))))))\n", "  (cond [(= N 0)\n\
    \         '0]\n        [(= N 1)\n         '0]\n        [else\n         (let ([N1\
    \ (sub1 N)]\n               [N2 (sub1 N1)]\n               [N3 (sub1 N2)])\n \
    \          (cond [(= N3 0)\n                  (cond [(= N2 0)\n              \
    \           (cond [(= N1 0)\n                                 (cons 1 (solve N))]\n\
    \                               [else (cons 0 N)])]\n                        \
    \ [else (cons 1 N)])]\n                 [else\n                  (cond [(= N2\
    \ 0)\n                         (cond [(= N1 0)\n                             \
    \    (cons 1 (solve N))]\n                               [else (cons 0 N)])]\n\
    \                         [else\n                         (cond [(= N1 0)\n  \
    \                               (cons 1 (solve N))]\n                        \
    \       [else (cons 0 N)])]\n                       )])]))\n", "  (if (= N 0)\n\
    \      '()\n      (add-to-sum (digit-value N) (solve (/ N 10))))))\n", "  (define\
    \ sum (loop\n                for i below N\n                collect (list (number->string\
    \ (modulo (+ i 10) 10)))))\n  (number->string (length sum)))\n</code>\n<|/ a tags=scheme,racket\
    \ dscore=0 |>\n<| c |>\nI think this doesn't work because you are printing the\
    \ sum of each digit, not the whole number. Try changing `(number->string (length\
    \ sum))` to `(number->string (length sum))` and then try `solve 10` and you'll\
    \ see what I mean.\n<|/ c |>\n<| c |>\nThank you for pointing that out. I've corrected\
    \ my answer to reflect this.\n<|/ c |>\n<| a dscore=0 tags=scheme,racket |>\n\
    You can implement this as a procedure and use tail recursion:\n<code>", "  (let\
    \ ((sums '()))\n    (if (= N 0)\n        (string-append \"0\" sums)\n        (let\
    \ ((sum (modulo (modulo N 10) 2)))\n          (if (= sum 0)\n              (solve\
    \ (quotient N 10))\n              (if (> (quotient N 10) 2)\n                \
    \  (if (> (modulo N 10) 1)\n                      (let ((sum (modulo (modulo N\
    \ 10) 2)))\n                        (string-append \"0\" sums)\n             \
    \           (string-append \"1\" sum)))\n                  (let ((sum (modulo\
    \ (quotient N 10) 2)))\n                    (string-append \"0\" sums))))))))\n",
  "  (define (helper N total)\n    (if (= N 0) total\n      (helper (sub1 N) \n  \
    \           (+ (modulo (digit-value N) 10)\n               (modulo (digit-value\
    \ total) 10))))\n    (helper N 0)))\n", "  (let ((sum (+ 0 (expt N 2))))\n   \
    \ (loop for i from 0 to 9\n          for remainder = (/ i 10)\n          for rem-str\
    \ = string-append (symbol->string remainder) (rem-str)\n          collect (rem-str)\n\
    \          while (< sum 10)\n          sum (- sum (remainder (/ 10 10))))))\n",
  "  (cond [(= N 0) \"\"]\n        [(zero? (modulo N 2)) (list \"1\")]\n        [(zero?\
    \ (modulo N 4)) (list \"10\")]\n        [else (list (format-integer N 'binary))]))\n\
    </code>\n<|/ a dscore=0 tags=racket,scheme |>\n<| a tags=racket,scheme |>\nThis\
    \ code is in Racket, using your functions:\n<code>\n#lang racket\n", "  (cond\n\
    \    [(or (zero? N) (string-length N < 2)) (display \"0\")]\n    [(even? N) (display\
    \ (solve (N / 10)))]\n    [else (display (+ (list-ref (list (car (list-ref (list\
    \ (quotient N 10))) #'(1 0)) 1) 1))]))))\n", "  (define (sumDigits n ret)\n  \
    \  (cond\n      [(zero? n) ret]\n      [else (sumDigits (quotient n 10) (cons\
    \ (mod n 10) ret))]\n    )\n  )\n  (sumDigits N \"\")\n)\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nAnother solution using an accumulator and some recursion:\n<code>",
  "  (if (= N 0)\n      \"0\"\n      (sum-of-digits N)))\n</code>\n<|/ a dscore=1\
    \ tags=racket,functional-programming,scheme |>\n<| a tags=racket,functional-programming,scheme\
    \ |>\nI do not know Scheme, but I think it would be something like this:\n<code>",
  "  (if (> N 10000)\n      (begin\n        (display \"Not a valid N.\")\n       \
    \ (return-from solve \"Not a valid N.\")\n      )\n      (begin\n        (display\
    \ N)\n        (display \" = \")\n        (set! n (quotient N 10)\n           \
    \   s (- n 1)\n              sum (+ (mod N 10) s)\n              str (string-append\
    \ (str-cat \"0\" sum) \"\")\n              (if (= n 0) (return-from solve str)\n\
    \                  (set! n (quotient n 10)\n                        s (- n 1)\n\
    \                        sum (+ (mod n 10) s)\n                        str (string-append\
    \ (str-cat \"0\" sum) \"\")\n                        (if (= n 0) (return-from\
    \ solve str)\n                            (set! n (quotient n 10)\n          \
    \                        s (- n 1)\n                                  sum (+ (mod\
    \ n 10) s)\n                                  str (string-append (str-cat \"0\"\
    \ sum) \"\")\n                                  (if (= n 0) (return-from solve\
    \ str)\n                                      (set! n (quotient n 10)\n      \
    \                                      s (- n 1)\n                           \
    \                 sum (+ (mod n 10) s)\n                                     \
    \       str (string-append (str-cat \"0\" sum) \"\")\n                       \
    \                     (if (= n 0) (return-from solve str)\n                  \
    \                              (set! n (quotient n 10)\n                     \
    \                                 s (- n 1)\n                                \
    \                      sum (+ (mod n 10) s)\n                                \
    \                      str (string-append (str-cat \"0\" sum) \"\")\n        \
    \                                              (if (= n 0) (return-from solve\
    \ str)\n                                                          (set! n (quotient\
    \ n 10)\n                                                                s (-\
    \ n 1)\n                                                                sum (+\
    \ (mod n 10) s)\n                                                            \
    \    str (string-append (str-cat \"0\" sum) \"\")\n                          \
    \                                      (if (= n 0) (return-from solve str)\n \
    \                                                                   (set! n (quotient\
    \ n 10)\n                                                                    \
    \      s (- n 1)\n                                                           \
    \               sum (+ (mod n 10) s)\n                                       \
    \                                   str (string-append (str-cat \"0\" sum) \"\"\
    )\n                                                                          (if\
    \ (= n 0) (return-from solve str)\n                                          \
    \                                    (set! n (quotient n 10)\n               \
    \                                                                     s (- n 1)\n\
    \                                                                            \
    \        sum (+ (mod n 10) s)\n                                              \
    \                                      str (string-append (str-cat \"0\" sum)\
    \ \"\")\n                                                                    \
    \                (if (= n 0) (return-from solve str)\n                       \
    \                                                                 (set! n (quotient\
    \ n 10)\n                                                                    \
    \                          s (- n 1)\n                                       \
    \                                                       sum (+ (mod n 10) s)\n\
    \                                                                            \
    \                  str (string-append (str-cat \"", "  (cond [(zero? N)\n    \
    \     \"0\"]\n        [(even? N)\n         (string->number\n           (list->string\n\
    \            (let ([N (/ N 2)])\n               (solve (* N 2)))\n           \
    \    (string->number (list->string N))))]\n        [else\n         (string->number\
    \ (list->string (/ N 2)))]))\n</code>\n<|/ a |>\n<| c |>\nThis is my first post...\
    \ and I didn't know how to use the site. Thanks for your response. I'll check\
    \ this out and report back if I find anything that works.\n<|/ c |>\n<| c |>\n\
    Ok, I added an edit to my original post to show what my code looks like now with\
    \ the \"(define (solve) code\" at the beginning. I'm running into the error \"\
    string->number: expects argument of type string, given...\" when I try to run\
    \ this code. I tried changing my \"(define (solve N)\" code to \"(define (solve\
    \ N) \"(... Code as above ...)\" but that doesn't work.\n<|/ c |>\n<| c |>\nThanks\
    \ so much for helping me out. I am still trying to get my head around the whole\
    \ \"racket\" thing, so I will check out this solution more carefully and see if\
    \ I can get it to work. Thanks again for your help!\n<|/ c |>\n<| c |>\nNo problem!\
    \ If your problem is solved, you might want to consider accepting the answer.\
    \ I'm sure it'll help others.\n<|/ c |>\n<| a |>\nHere is a solution that uses\
    \ string->number and number->string. The first converts your string into a number,\
    \ and then you convert it back into a string. Just make sure you use the right\
    \ kind of quotes.\n<code>", "  (define (sum n acc)\n    (if (= 0 n)\n        acc\n\
    \        (sum (- n 1) (append (modulo (- n 1) 10) acc))))\n  (append (sum (quotient\
    \ N 2) '()) (map (lambda (x) (string->list x)) (string->list N))))\n", "  (let\
    \ loop ((sum 0))\n    (if (= sum N)\n        (list sum)\n        (if (even? N)\n\
    \            (loop (+ sum (modulo N 10)))\n            (loop (+ sum (modulo N\
    \ 2)) ))))\n</code>\n<|/ a dscore=2 tags=functional-programming,scheme |>\n<|\
    \ c |>\nThis doesn't work for negative numbers. I added a little workaround, but\
    \ it's not quite as simple as I'd hoped.\n<|/ c |>\n<| c |>\n: Yes, I hadn't noticed\
    \ that in the OP's question. I'll add the workaround as an edit!\n<|/ c |>\n<|\
    \ c |>\n: I added another workaround that I think is even simpler. I'll leave\
    \ my original answer up as an alternative (even though it's basically the same\
    \ as the one I posted 3 minutes ago.\n<|/ c |>\n<| c |>\nI posted an answer that\
    \ handles negative numbers. It's not particularly elegant and I wouldn't call\
    \ it functional, but it is functional.\n<|/ c |>\n<| a dscore=1 |>\nI posted an\
    \ answer that handles the negative numbers and handles them the way I originally\
    \ intended.\n<code>", "  (cond [(= N 0) \"\"]\n        [else (concat (if (< N\
    \ 9)\n                         (list-ref (substring N 0 1) 0)\n              \
    \         (list-ref (substring N 0 0) 0) (solve (substring N 1 0))))]))\n</code>\n\
    <|/ a |>\n<| c |>\nThank you so much! I really appreciate this answer, it really\
    \ helped me understand what I needed to do. I had a couple questions. I see where\
    \ you used the list-ref but I'm a little unsure how I would be able to implement\
    \ that into the code so I could get the desired output. Also, I see that they\
    \ were using list-ref but what is the reason for using list-ref? Also, how would\
    \ I be able to use list-ref in my code? Thanks so much!\n<|/ c |>\n<| c |>\nThe\
    \ reason for using `list-ref` is to get the single digit. The second argument\
    \ for list-ref is how many elements you want, the third argument is the index\
    \ of the element you want. So if you wanted the first digit, the index would be\
    \ 1, and if you wanted the second digit, the index would be 0. `list-ref` is really\
    \ useful here.\n<|/ c |>\n<| a tags=scheme,racket dscore=0 |>\nI would do something\
    \ like this - \n<code>", "  (define (solve n acc)\n    (cond\n      [(= n 0) (append-to-string\
    \ (number->string acc) (number->string 0))]\n      [(> n 0) (solve (quotient n\
    \ 10) (string-append \"1\" acc))]\n      [else (solve (quotient n 10) (string-append\
    \ acc \"0\"))]))\n  (solve N \"\"))", "  (cond\n    [(= N 0) (list \"0\")]\n \
    \   [else (append (list (list (substring '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g\
    \ #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\\
    x #\\y #\\z) (car N)) (solve (substring (list N) (+ 1 N)))])))", "  (cond\n  \
    \  [(= N 0) \"0\"]\n    [else (add (solve (N/10)) (list->string (mod N 10)))]))\n",
  "  (if (zero? N)\n      '(0)\n      (list (quotient N 2)\n            (solve (quotient\
    \ N 2)))))", "  (check-range N (min 0) (max 10000))\n  (let loop ((N N) (acc '()))\n\
    \    (if (zero? N)\n        acc\n        (loop (quotient N 10) (string-append\
    \ acc \"0\")))\n    (loop (quotient N 10) acc)))\n", "  (cond\n    [(= N 0) \"\
    0\"]\n    [else (string-append (number-to-string N) (solve-helper (- N 1)))]))\n",
  "  (let ((ans (string->list '(\"0\" '(\"1\" '(\"2\" (+ N '(\"0\"))))))))\n    (loop\
    \ [i N\n           ans '(\"0\" '(\"1\" '(\"2\" (+ i '(\"0\"))))) ]\n      (if\
    \ (= i 0)\n          ans\n          (set! i (- i))\n          (set! ans (list->string\
    \ ans))\n          (set! ans (string->list (string ans #\\0))))\n      (set! i\
    \ (- i))\n      (set! ans (list->string ans))\n      (set! ans (string->list (string\
    \ ans #\\0))))\n    ans))\n", "  (cond\n    ((= N 0)\n     '0)\n    ((even? N)\n\
    \     (let ((result (string-append '0\n                                  (solve\
    \ (/ N 2)))))\n       (if (= (length result) 2)\n           (string-append '1\
    \ result)\n           result))))\n    ((odd? N)\n     (string-append '1 '0)))\n\
    \  )\n", "  (cond\n    [(= N 0)\n     (string-append \"0\"\n                 \
    \   (string (list-ref (list-ref '(0 1 0) (quotient N 2)) 1)))]\n    [(= N 1)\n\
    \     (string-append \"1\"\n                    (string (list-ref '(0 1 0) (quotient\
    \ N 2))))]\n    [else\n     (string-append (list (list (list-ref '(0 1 0) (quotient\
    \ N 2)) '(1 (+ 0 (list-ref '(0 1 0) (quotient N 2))))) (solve (quotient N 2)))]))\n",
  "  (cond [(> N 0) \"\"]\n        [else (string-append \"1\" (string-append (reverse\
    \ (string->list\n                                                          (binary->string\n\
    \                                                            (digits-of-bignum\
    \ (- N 1))))))]))\n", "  (cond\n    [(= N 0)\n     (string-append \"0\")\n   \
    \  (set! N (remainder N 10))\n     (solve (quotient N 10))]\n    [else\n     (string-append\
    \ \"1\" (solve (quotient N 10)))]))\n", "  (cond\n    [(= N 0) (cond\n       \
    \         [ (zero? (remainder N 10))\n                  (number->string N)\n \
    \               ]\n              [ (not (zero? (remainder N 10)))\n          \
    \        (cons \"0\" (number->string N))\n                ]\n              [ (not\
    \ (zero? (remainder N 100)))\n                  (cons \"00\" (number->string N))\n\
    \                ]\n              [ (not (zero? (remainder N 1000)))\n       \
    \           (cons \"000\" (number->string N))\n                ]\n           \
    \   [ (not (zero? (remainder N 10000)))\n                  (cons \"0000\" (number->string\
    \ N))\n                ]\n              )\n    ]\n    [else\n      (append (number->string\
    \ N)\n              (solve (remainder N 10)))]))\n", "  (if (eq? N '())\n    \
    \  '()\n      (append (string-append (string-concat (string-append (number->string\
    \ (N%10)) (if (= (N%10) 0) '(0) '(1)))) solve\n                       (- (number->string\
    \ (N%10)) 10)))\n      (solve (quotient N 10))))\n", "  (let loop ((x N) (y \"\
    \") (acc \"\"))\n    (cond\n      [(zero? x) acc]\n      [else (loop (quotient\
    \ x 10)\n                   (append (list x) (list acc))\n                   (loop\
    \ (remainder x 10)\n                         (append (list y) (list acc))))]))\n",
  "  (define total (string->number (number->string (number->list (sum (list-ref (number->list\
    \ (number->string N))) 0)))))\n  (display total)\n  (newline)\n  (number->string\
    \ total))", "  (cond\n    ((= N 0) '())\n    ((= N 1) '(#\\1))\n    ((= N 2) '(#\\\
    b))\n    ((= N 3) '(#\\c))\n    ((= N 4) '(#\\d))\n    ((= N 5) '(#\\e))\n   \
    \ ((= N 6) '(#\\f))\n    ((= N 7) '(#\\g))\n    ((= N 8) '(#\\h))\n    ((= N 9)\
    \ '(#\\i))\n    ((= N (quotient N 10)) (solve (quotient N 10)))\n    ((= N (quotient\
    \ N 100)) (solve (quotient N 100)))\n    ((= N (quotient N 1000)) (solve (quotient\
    \ N 1000)))\n    ((= N (quotient N 10000)) (solve (quotient N 10000)))\n    (else\
    \ (add-to-binary (solve (quotient N 10)) (solve (quotient N 100))))))\n", "  (cond\n\
    \    [(= N 0) \"0\"]\n    [else (+ (sum-digit (expt N 2)) (sum-digit (expt N 3)))]))\n",
  "  (cond\n    [(= N 0) '()]\n    [else\n     (append (show-sum (- N 10)) (solve\
    \ (quotient N 10)))]))\n", "  (cond ((= N 0) \"\")\n        ((= N 1) (list \"\
    1\"))\n        (else (append (list (list (mod N 2))\n                        \
    \       (list (modulo N 2)) \n                               (list (list (mod\
    \ N 4))\n                                    (modulo N 4) \n                 \
    \                   (list (mod N 8))))\n                       (list (solve (quotient\
    \ N 2)) \n                            (modulo N 2)\n                         \
    \   (solve (quotient N 4)))\n                       (list (solve (quotient N 4))\
    \ \n                            (modulo N 4)\n                            (solve\
    \ (quotient N 8))))))", "  (define (helper N result)\n    (cond\n      [(= N 0)\
    \ result]\n      [(= N 1) (append result '(1))]\n      [else (helper (quotient\
    \ N 2)\n                    (append result\n                          (list (-\
    \ N 2))))]))\n  (helper (quotient N 2) '()))\n", "  (define (sumOfDigits N)\n\
    \    (cond\n      [(= N 0) \"0\"]\n      [(< N 1000000) (+ 10 (sumOfDigits N (quotient\
    \ N 1000000)))]\n      [(< N 100000000) (+ 10 (sumOfDigits N (quotient N 100000000)))]\n\
    \      [(< N 1000000000000) (+ 10 (sumOfDigits N (quotient N 1000000000000)))]\n\
    \      [(< N 100000000000000000000) (+ 10 (sumOfDigits N (quotient N 100000000000000000000)))]\n\
    \      [else (+ 10 (sumOfDigits N (quotient N 1000000000000000000000)))]))\n \
    \ (cond\n    [(= N 0) \"0\"]\n    [(< N 1000000) (+ 10 (sumOfDigits N (quotient\
    \ N 1000000)))]\n    [(< N 100000000) (+ 10 (sumOfDigits N (quotient N 100000000)))]\n\
    \    [(< N 1000000000000) (+ 10 (sumOfDigits N (quotient N 1000000000000)))]\n\
    \    [(< N 100000000000000000000) (+ 10 (sumOfDigits N (quotient N 100000000000000000000)))]\n\
    \    [else (+ 10 (sumOfDigits N (quotient N 1000000000000000000000)))]))", " \
    \ (cond\n    [(= N 0) \"\"]\n    [(= N 1) (string 1)]\n    [else\n     (let* ([digits\
    \ (remainder N 10)\n               (results (append (solve (N- digits)) (string-append\
    \ (string digits) \"\")))])\n      (cond\n       [(= (string-length results) 0)\
    \ results]\n       [else (append (string results) \"\")]\n       ))]))", "  (cond\n\
    \    [(< N 0) \"\"]\n    [(< N 10) (reverse (list N))]\n    [else (list (sum (list\
    \ (take N #:from-end (range 9))))\n                (solve (- N 10)))]))\n</code>\n\
    This is not as efficient as most of the other solutions given, but if you have\
    \ a very large list of digits, it does work.\n<|/ a tags=racket,recursion,scheme,digits\
    \ |>\n<| a |>\nHere's a solution that uses Racket's list library.\n<code>", " \
    \ (cond\n    [(= N 0) \"0\"]\n    [(< N 100) (string-append (solve (N-quotient\
    \ N 100))\n                               (number->string (quotient N 100)))]\n\
    \    [else (string-append (solve (N-remainder N 100))\n                      \
    \     (number->string (quotient N 100))\n                           #\\Space]))]))\n",
  "  (if (= N 0)\n      \"0\"\n      (if (< N 10000)\n          (subst (string-append\
    \ (subst (string-append (solve (- N 1)) (subst (string-append \"01\" (subst (string-append\
    \ \"0\" N) (subst (subst (subst (subst (subst (subst (subst (string-append \"\
    0\" (subst (string-append \"1\" N) (subst (subst (subst (subst (subst (subst (string-append\
    \ \"1\" N))))))))))))))))\n          (subst (string-append (subst (subst (string-append\
    \ (solve (- N 1)) (subst (string-append \"01\" (subst (string-append \"0\" N))))))\n\
    \                           N))))))\n", "  (cond\n    ((= N 0) '())\n    ((= N\
    \ 1) '(1))\n    (else (cons (quotient N 2)\n                (+ (solve (quotient\
    \ N 2))\n                  (number->string N))))))\n", "  (define (sum number)\n\
    \    (if (= number 0)\n        '()\n        (cons (remainder number 10) sum)))\n\
    \  (if (< N 10)\n      (cons (string-to-int N) '())\n      (sum (quotient N 10))))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| a |>\nAs has been pointed out, your recursive\
    \ solution is incorrect.  Here is another approach that doesn't use string-to-int\
    \ at all:\n<code>", "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) (print \"1\")]\n\
    \    [(= N 2) (print \"1\")]\n    [else (cons (+ 0 (mod N 2)) (solve (quotient\
    \ N 2)))]))\n", "  (cond ((> N 0) \"ERROR\")\n        ((< N 0) \"ERROR\")\n  \
    \      ((= N 0) \"0\")\n        (else (+ (char->integer (remainder (modulo (quotient\
    \ N 10) 2) 10))\n              (solve (quotient N 10))))))\n", "  (define (sum-digits-of-binary\
    \ N)\n    (string->list \n      (cond [(= N 0) \"\"]\n            [(< N 0) \"\
    0\"]\n            [else (append\n                  (sum-digits-of-binary (sub1\
    \ N))\n                  (string->list (digit-sum N)))]))\n  (append\n   (sum-digits-of-binary\
    \ N)\n   (concat\n    (string->list (digit-sum N))\n    (string->list \"0\")\n\
    \    (string->list \"1\"))))\n", "  (display N) ; print N\n  (display '(\" \"\
    )) ; print a blank space\n  (for/list ([i N])\n    (display i)) ; print each digit\
    \ of the number\n  (newline) ; print a new line\n  (let ([sum (for/list ([i N])\n\
    \                   (quotient i 10))])\n    (display sum) ; print the sum\n  \
    \  (display '(\" \")) ; print a blank space\n    (for/list ([i N])\n      (display\
    \ i)) ; print each digit of the number\n    (newline) ; print a new line\n   \
    \ (display (+ sum (- sum (quotient N 10))))))\n</code>\nThe last part is just\
    \ to display the binary number for the number you just saw.\n<|/ a dscore=2 |>\n\
    <| c |>\nI believe your answer is incorrect. For example, (solve 168) should print\
    \ 11001001, but your code prints 110011001001.\n<|/ c |>\n<| c |>\nI edited the\
    \ answer to include a solution that does what I think you were after.\n<|/ c |>\n\
    <| a tags=racket,scheme |>\nOne approach to do this would be to convert N to binary,\
    \ take each digit and sum them together until you reach a single digit, giving\
    \ you the required sum.  For example, (num-to-binary 1000) would give 11000, and\
    \ (num-to-binary 168) would give 11001001.\nThe general form would be:\n<code>",
  "  (if (= N 0)\n      \"0\"\n      (subst '(a b c d e f g h i j k l m n o p q r\
    \ s t u v w x y z) '((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0\
    \ 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1\
    \ 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0\
    \ 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1\
    \ 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1\
    \ 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0\
    \ 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1\
    \ 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1\
    \ 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0\
    \ 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1\
    \ 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1\
    \ 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0\
    \ 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) ((1 0 1 0 1 ", "  (cond\
    \ ((= N 0)\n         '())\n        ((odd? (car N))\n         (cons (car N)\n \
    \             (solve (cdr N))))\n        (else\n         (cons (string-append\
    \ (list-to-bin (add1 N))\n                              (string-append \"0\"))\n\
    \               (solve (remainder N 2))))))\n", "  (cond\n    [(< N 0) (if (>\
    \ N 1) (list '() N) (list '() N))]\n    [else (let ([digits (list) (list)]) (do\
    \ ([i N])\n                                            (if (< i 0) (begin (set!\
    \ digits (cons (modulo i 10) digits)) (set! i (- i 10))) (set! digits (cons i\
    \ (digits 0))))\n                                            (begin (set! i (modulo\
    \ i 10)) (set! digits (cons (modulo i 10) digits)) (set! i (- i 10))))\n     \
    \      (if (> digits '())\n               (begin (set! i (first digits)) (set!\
    \ digits (rest digits))\n                       (if (< i N) (set! i (- i N)) (set!\
    \ digits '())))\n               (begin (set! i (first digits)) (set! digits (rest\
    \ digits))\n                       (if (< i N) (set! i (- i N)) (set! digits '())))]\n\
    \    [else (begin\n               (if (< N 10)\n                   (let ([n (*\
    \ N 10) (+ N 1)])\n                     (if (> n N) (list '() N) (list '() N))\n\
    \                     (cond\n                       ((= n 0) (begin (set! digits\
    \ (cons n digits)) (set! n (- n 1)))\n                       ((= n 9) (begin (set!\
    \ digits (cons (modulo n 10) digits)) (set! n (- n 9)))))\n                  \
    \ (let ([n (modulo N 10) (+ N 1)])\n                     (if (> n N) (list '()\
    \ N) (list '() N))\n                     (cond\n                       ((= n 0)\
    \ (begin (set! digits (cons (modulo n 10) digits)) (set! n (- n 1)))\n       \
    \                ((= n 9) (begin (set! digits (cons (modulo n 10) digits)) (set!\
    \ n (- n 9)))))\n                   (let ([n (modulo N 100) (+ N 1)])\n      \
    \               (if (> n N) (list '() N) (list '() N))\n                     (cond\n\
    \                       ((= n 0) (begin (set! digits (cons (modulo n 100) digits))\
    \ (set! n (- n 1)))\n                       ((= n 9) (begin (set! digits (cons\
    \ (modulo n 100) digits)) (set! n (- n 9)))))\n", "  (let ((sum (string->number\
    \ (string-append (number->string N) '()))))\n    (if (> (- N 1) 0)\n        (if\
    \ (eq? (remainder sum 1) 0)\n            (if (eq? (remainder sum 8) 0)\n     \
    \           (if (eq? (remainder sum 16) 0)\n                    (if (eq? (remainder\
    \ sum 32) 0)\n                        (if (eq? (remainder sum 64) 0)\n       \
    \                     (if (eq? (remainder sum 128) 0)\n                      \
    \          (if (eq? (remainder sum 256) 0)\n                                 \
    \   (if (eq? (remainder sum 512) 0)\n                                        (if\
    \ (eq? (remainder sum 1024) 0)\n                                            (if\
    \ (eq? (remainder sum 2048) 0)\n                                             \
    \   (if (eq? (remainder sum 4096) 0)\n                                       \
    \             (if (eq? (remainder sum 8192) 0)\n                             \
    \                           (if (eq? (remainder sum 16384) 0)\n              \
    \                                              (if (eq? (remainder sum 32768)\
    \ 0)\n                                                                (if (eq?\
    \ (remainder sum 65536) 0)\n                                                 \
    \                   (if (eq? (remainder sum 131072) 0)\n                     \
    \                                                   (if (eq? (remainder sum 262144)\
    \ 0)\n                                                                       \
    \     (if (eq? (remainder sum 524288) 0)\n                                   \
    \                                             (if (eq? (remainder sum 1048576)\
    \ 0)\n                                                                       \
    \             (if (eq? (remainder sum 2097152) 0)\n                          \
    \                                                              (if (eq? (remainder\
    \ sum 4194304) 0)\n                                                          \
    \                                  (if (eq? (remainder sum 8388608) 0)\n     \
    \                                                                            \
    \               (if (eq? (remainder sum 16777216) 0)\n                       \
    \                                                                            \
    \ (if (eq? (remainder sum 33554432) 0)\n                                     \
    \                                                                   (if (eq? (remainder\
    \ sum 67108864) 0)\n                                                         \
    \                                                   (if (eq? (remainder sum 134217728)\
    \ 0)\n                                                                       \
    \                                         (if (eq? (remainder sum 268435456) 0)\n\
    \                                                                            \
    \                                        (if (eq? (remainder sum 536870912) 0)\n\
    \                                                                            \
    \                                            (if (eq? (remainder sum 1073741824)\
    \ 0)\n                                                                       \
    \                                                     (if (eq? (remainder sum\
    \ 2147483648) 0)\n                                                           \
    \                                                                     (if (eq?\
    \ (remainder sum 4294967296) 0)\n                                            \
    \                                                                            \
    \            (if (eq? (remainder sum 8589934592) 0)\n                        \
    \                                                                            \
    \                                    (if (eq? (remainder sum 17179869184) 0)\n\
    \                                                                            \
    \                                                                (if (eq? (remainder\
    \ sum 34359738368) 0)\n                                                      \
    \                                                                            \
    \              (if (eq? (remainder sum 687194767", "  (if (= N 0)\n      '()\n\
    \      (append (list (modulo (expt 2 N) (expt 2 N))\n                  (modulo\
    \ (expt 2 N) (expt 2 N)))\n              (solve (sub1 N))))))\n", "  (cond\n \
    \   ((= N 0) (list '())) ; Base case\n    (else (append (list (modulo (quotient\
    \ N 2) 10))\n                  (solve (quotient N 2)) ))))))\n", "  (cond\n  \
    \  [(= N 0) (string 0)]\n    [else (number-sum (quotient N 2)\n              \
    \         (remainder N 2)\n                       (solve (quotient N 2)\n    \
    \                             (remainder N 2)))]\n   )\n  )\n", "  (cond [(< N\
    \ 10) (list '1 N)]\n        [(= N 10) (list '1 (- N 1))]\n        [else (let ([total\
    \ (sub1 (- N 1)))\n                   (list (cond [(= total 0) (cons '0 (solve\
    \ total))]\n                              [(= total 1) (cons '1 (solve total))]\n\
    \                              [(= total 2) (cons '10 (solve (- total 1)))]\n\
    \                              [(= total 3) (cons '111 (solve (- total 2)))]\n\
    \                              [(= total 4) (cons '1010 (solve (- total 3)))]\n\
    \                              [(= total 5) (cons '101111 (solve (- total 4)))]\n\
    \                              [(= total 6) (cons '111010 (solve (- total 5)))]\n\
    \                              [(= total 7) (cons '1110110 (solve (- total 6)))]\n\
    \                              [(= total 8) (cons '1110111 (solve (- total 7)))]\n\
    \                              [(= total 9) (cons '111011111 (solve (- total 8)))]\n\
    \                              [else (cons '1 (solve total))]))]))])\n", "  (cond\n\
    \    [(= N 0) \"0\"]\n    [(= N 1) \"1\"]\n    [else (let ([remainder (mod N 2)]\n\
    \              [sum (substring (reverse (list remainder)) 1 1)])\n           \
    \ (concat sum (solve (sub1 N))))]))\n", "  (cond [(= N 0) \"\"]\n        [else\
    \ (cond [(= (modulo N 10) 0) (display N)]\n                   [else (display (add1\
    \ (modulo N 10)))]\n                   (solve  (quotient N 10)))]))\n", "  (cond\n\
    \    [(= N 0) \"\"]\n    [(= N 1) (substring \"11\" 0 1)]\n    [(= N 2) (substring\
    \ \"111\" 0 1)]\n    [else (substring (append (substring (append \"1\" (sum-to-digits\
    \ N))) \"0\" N) (- N 1) 1)]))\n", "  (cond\n    [(= N 0) (display N)]\n    [(=\
    \ N 1) (display N)]\n    [else (display ((string-append\n                    \
    \  (string-append (string-append (solve (quotient N 2)) \"0\") \"0\")\n      \
    \                (string-append (solve (quotient N 2)) \".\")))]))) ", "  (cond\n\
    \    [(= N 0)\n     0]\n    [else\n     (+ 10 (sum-to-binary(modulo (expt N 2)\
    \ 2) 2))]))\n", "  (let* ((sum (number-of-digits N))\n         (str (number-to-string\
    \ N)))\n    (if (> N 0)\n        (string->number str)\n        (string->number\
    \ str)))))\n", "  (if (= N 0)\n      '(0)\n      (let loop ((N N) (A 0) (S '()))\n\
    \        (cond ((= N 0)\n                (string S))\n              ((odd? (modulo\
    \ N 10)) (loop (quotient N 10) A S) (loop (quotient N 10) A S))\n            \
    \  ((even? (modulo N 10)) (loop (quotient N 10) A (list \"0\" A)) (loop (quotient\
    \ N 10) A (string \"0\" A)))))))\n", "  (if (<= N 0)\n      (error \"N is out\
    \ of range\")\n      (sum-binary (quotient N 10))))\n", "  (define (sum-digits\
    \ N)\n    (let loop ((result '())\n               (number N))\n      (if (zero?\
    \ number)\n          result\n          (loop (append result '(modulo (quotient\
    \ number 10) (* 2 10))) (quotient number 10))))))\n\n  (if (= N 0)\n      '()\n\
    \      (sum-digits N)))\n", "  (cond\n    ((= N 0) '())\n    ((even? N) (cons\
    \ (modulo N 2) (solve (quotient N 2))))\n    (else (cons (modulo N 2) (solve (quotient\
    \ N 2))))\n  )\n)\n", "  (if (= N 0)\n      '()\n      (append (digitsum (quotient\
    \ N 10))\n              (solve (quotient N 10)))))\n", "  (cond\n    [(equal?\
    \ N 0) \"\"]\n    [else (cons (sum-digits (remainder N 2)) (solve (remainder N\
    \ 10)))]))\n", "  (let loop ([n N] [j 0] [l 0])\n    (cond [(= n 0) \"0\"]\n \
    \         [(< n 0) (loop n 0 (string-to-int (car n) j))]\n          [(< n (mod\
    \ 2 n)) (loop n (string-to-int (car n) j) (+ l 1))]\n          [else (loop (quotient\
    \ n 2) (+ j (string-to-int (car n) j)) l)])))\n</code>\n<|/ a |>\n<| c |>\nNice\
    \ solution, although I wouldn't call it \"elegant\". It's a lot of code. And it's\
    \ very close to the solution I posted in the comments under the question, only\
    \ with the `string-to-int` call in the `cond` instead of `string->list` calls.\n\
    <|/ c |>\n<| c |>\nYeah, I agree, it is definitely a lot more code. It was more\
    \ intended to be a step in the right direction in terms of explaining how to approach\
    \ the problem and help others who might not know how to use `string-to-int`.\n\
    <|/ c |>\n<| a |>\nHere's a solution that uses recursion and string-to-int to\
    \ convert the number into a list of digits and then recurses to convert that list\
    \ of digits into binary.\n<code>", "  (loop for x from 0 to N-1 \n        for\
    \ y from 0 to x\n        collect (number->string x)\n        collect (number->string\
    \ y)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
