name: HumanEval_47_median
language: rkt
prompt: "#lang racket\n\n;; Return median of elements in the list l.\n;; >>> median([3,\
  \ 1, 2, 4, 5])\n;; 3\n;; >>> median([-10, 4, 6, 1000, 10, 20])\n;; 15.0\n(define\
  \ (median l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n\
  \    (check-equal? (candidate (list 3 1 2 4 5)) 3)\n    (check-equal? (candidate\
  \ (list -10 4 6 1000 10 20)) 8.0)\n    (check-equal? (candidate (list 5)) 5)\n \
  \   (check-equal? (candidate (list 6 5)) 5.5)\n    (check-equal? (candidate (list\
  \ 8 1 3 9 9 2 7)) 7)\n))\n\n(test-humaneval)"
completions: ["  (/ (reduce + (map fst l)) (length l)))\n", "  (cond [(null? l) 0]\n\
    \        [(< (car l) (cadr l)) (cadr l)]\n        [(> (car l) (cadr l)) (median\
    \ (cdr l))]))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI do not think this is the\
    \ case - at least not as I have been able to test it.\n<|/ c |>\n<| c |>\nWell,\
    \ if you have a list with two elements and use `(median '(1 2 3))` this returns\
    \ `1`\n<|/ c |>\n<| c |>\nOf course - but this is not an answer to the question\
    \ - why is the median function not working?\n<|/ c |>\n<| c |>\nThe median is\
    \ defined as the arithmetic mean of the numbers in a sorted list. So if you have\
    \ '(1 2 3 4 5 6) you mean the mean is (1 + 2 + 3 + 4 + 5 + 6) / 6.\n<|/ c |>\n\
    <| c |>\n: this doesn't answer the question at all, as you didn't state that this\
    \ was homework.\n<|/ c |>\n<| a tags=scheme,racket |>\nHere's a solution I came\
    \ up with - hopefully it helps someone out there.\n<code>", "  (cond\n    ((null?\
    \ l) 0.0)\n    (else (/ (+ (car l) (median (cdr l)))\n             (+ l (length\
    \ l)))\n           )\n    )\n  )\n)\n", "  (cond\n    [(null? (rest l)) (first\
    \ l)]\n    [(< (first l) (second l)) (second l)]\n    [else (first l)])\n)\n",
  "  (let ((s (sort l)))\n    (/ (last s) (length s))))\n", "  (/ (/ (length l) 2)\
    \ (length l)))\n", "  (cond\n    ((empty? l) '())\n    ((= (length l) 1) (first\
    \ l))\n    (else (/ (apply < (rest l)) (length l))))))\n", "  (apply median (racket/sequence\
    \ l)))\n</cell>\n<text>\nIn contrast with some of the higher-order list functions\
    \ (map, filter, fold) which expect their arguments to be sequences, median expects\
    \ an arbitrary number of arguments, and returns the median of the arguments:\n\
    \n\n</text>\n<code language=ocaml-jupyter>\n#lang racket\n", "  (cond\n    [(empty?\
    \ l)\n     (error \"not an even number of elements in list\")] \n    [(odd? (length\
    \ l)) \n     (/ 1 (length l))] \n    [else (/ (car l) (length l))]\n  )\n)\n",
  "  (/ (apply median l) 2))\n", "  (fold-left (lambda (x y)\n              (if (=\
    \ (remainder x y) (- x y))\n                  x\n                  (/ x y)))\n\
    \             #f\n             (reverse l)))\n", "  (/ (reduce + l) (incf (length\
    \ l))))\n", "  (/ (reduce (lambda (e a) (/ (+ a e) 2)) l 0) 2))\n", "  (/ (apply\
    \ median l) (length l)))\n", "  (cond\n    ((null? l) null)\n    ((< (first l)\
    \ (second l)) (first (rest l)))\n    (else (second (rest l)))))\n", "  (cond\n\
    \    ((null? l) 'nil)\n    ((< (length l) 1) 'nil)\n    ((< (length l) 2) (/ (car\
    \ l) 2))\n    (else (/ (min (sort l) (sort (cdr l))) 2))))\n", "  (/ (/ (apply\
    \ min (map second l)) (length l)) 2))\n", "  (/ ??? (length l))) ;; (/ (min l)\
    \ (length l))\n</code>\n<|/ a tags=racket,scheme dscore=2 |>\n<| c |>\nThis answer\
    \ should be the accepted one! It answers the question directly, and in a way that\
    \ does not make me look like an idiot.\n<|/ c |>\n<| c |>\nFor a more idiomatic\
    \ answer, see [@Peter Welch's answer](http://stackoverflow.com/a/20254963/6309).\n\
    <|/ c |>\n<| a |>\nHere is an example in Racket:\n<code>", "  (if (null? l) 0\n\
    \      (/ @(sort l) 2))) ; sort to get median\n</code>\n<|/ a |>\n<| c |>\nYour\
    \ first solution seems to run out of memory on large lists.\n<|/ c |>\n<| c |>\n\
    Yes, you're right. I'm currently trying to figure out a solution that uses less\
    \ memory (with lazy lists) without having to resort to `racket/base`\n<|/ c |>\n\
    <| c |>\nI added a solution that uses no extra memory but needs no sorting\n<|/\
    \ c |>\n<| c |>\nI added a solution where no extra memory is needed at all. Also\
    \ note that I didn't use Racket's `median` function because it was unsuitable:\
    \ it does something different than what we want here (which I believe to be median\
    \ of medians [which can be calculated faster than `median`]).\n<|/ c |>\n<| a\
    \ |>\nI wanted to contribute a solution not using racket/base, but with only basic\
    \ racket.\nThe algorithm is pretty simple:\n\nFind the median\nTake the middle\
    \ element of the list\nTake the first and second elements from the list\n\nFor\
    \ this to work, the list must be sorted.\nTo find the median, it can be done in\
    \ O(n), since there are only O(log n) numbers to check (the median is at index\
    \ n/2, since 0 is the element before the median).\nTo find the median, we can\
    \ use partition: we split the list into two halves and return the first element\
    \ of each. Partition is very useful to know about, and it also has a lot of useful\
    \ properties (for example, if you sort the list you get the median).\nTo find\
    \ the second element, we use the \"first\" element and take an index of 2 (or\
    \ 1) in the list.\nTo find the first element, we use the \"last\" element and\
    \ take an index of 0 (or -1) in the list.\n<code>", "  (/ (length l) 2))\n", " \
    \ (/ (min l (map -@ (reverse l)) (map - l))\n     (length l)))\n", "  (cond\n\
    \    ((null? l) null)\n    ((< (first l) (second l))\n     (/ (first l) (second\
    \ l)))\n    (else\n     (median l (rest l))))\n)\n", "  (/ (- (apply max (map\
    \ number? (append l '())) ) \n     (apply min (map number? (append l '())) ) )\
    \ )\n", "  (/ (apply + l) (carl l)))\n", "  (if (empty? l) nil (/ (/ (- l (first\
    \ l)) (count l)) 2.0)))\n", "  (cond\n    [(null? l)\n     (error \"empty list\
    \ found\")\n     (/ 0 (length l))]\n    [else\n     (let [half-length (/ 2 (length\
    \ l))]\n       (let [half-list (subseq l 0 half-length)\n             half-list\
    \ (list* '() half-list)]\n         (cond\n           [(empty? half-list) '()]\n\
    \           [(> half-length (length half-list)) (subseq l 0 half-length)]\n  \
    \         [(< (length half-list) (length l)) (list* '() half-list)]\n        \
    \   [else (subseq half-list (length half-list) (length l))]))]))))\n", "  (/ (reduce\
    \ (\u03BB (x y) (+ x y)) l) 2))\n</code>\n<|/ a tags=scheme,racket,median |>\n\
    <| c |>\nThanks for your reply, but this doesn't really answer my question. Racket\
    \ already has a median function. I want to know how it calculates it, and how\
    \ to do the same thing in scheme. I appreciate the help though.\n<|/ c |>\n<|\
    \ c |>\nYou didn't say that in the question. So I took the liberty of editing\
    \ your question to include a link to an example implementation of median. I hope\
    \ that's enough for you.\n<|/ c |>\n<| c |>\nThanks! I'm sorry I didn't specify\
    \ that in the question.\n<|/ c |>\n<| a |>\nThe first step in finding the median\
    \ is finding the middle of the list.  Assuming that the list has at least two\
    \ elements, you can get that by dividing the list length by 2 and subtracting\
    \ the result from the list length to get the middle element.  Now we just need\
    \ to find the middle of the sublist, which we can do by taking the first element\
    \ and adding the second element to the list to get the middle element.  That gives\
    \ us a way of dividing the list length by two to get half the size of the list\
    \ so we can find the middle element easily.\n<code>", "  (if (empty? l)\n    \
    \  (error)\n      (median (rest l))))\n</code>\nIn Common Lisp it would look like\
    \ this:\n<code>", "  (cond\n    ((null? l) 0)\n    ((< (car l) (cadr l)) (car\
    \ l))\n    (else (median (cdr l))))))\n", "  (/ (length l) (+ (car l) 1)))\n",
  "  (/ (/ (apply + l) (* (length l) 2)) 2))\n", "  (/ (apply + l)\n     (length l)))\n",
  "  (/ (apply min l) (apply max l)))\n", "  (if (null? l)\n      (throw 'ArgumentError\
    \ \"list may not be empty\")\n      (if (< (car l) (cadr l))\n          (cadr\
    \ l)\n          (cadr l))))\n", "  (if (<= (length l) 2)\n      (car l)\n    \
    \  (/ (car l) (median (cdr l))))) \n", "  (let loop ((lst l)\n             (mid\
    \ (lst length))\n             (m (lst length)))\n    (cond ((null? lst) m)\n \
    \         ((= m 1) lst)\n          ((< (car lst) mid) m)\n          ((loop (cdr\
    \ lst) (car lst) (+ 1 m)))\n          ((loop (cdr lst) (cdr lst) m))))\n", " \
    \ (cond\n    [(or (empty? l)\n          (null? (cdr l)))\n     #t]\n    [else\
    \ (/ (* (car l) (median (cdr l)))\n            (+ (length l) 1))]))\n", "  (/\
    \ (car l) (length l)))\n", "  (/ (sort l)\n     (length l)))\n", "  (/ (apply\
    \ median l) (length l)))\n", "  (sort l (lambda (x y)\n             (< (- y) x))))\n\
    </code>\n<|/ a dscore=0 tags=functional-programming,racket,scheme,average |>\n\
    <| c |>\nThank you, this is very helpful. Could you show me how I would modify\
    \ it so the program would take in any size list and return any size list with\
    \ median of all the elements?\n<|/ c |>\n<| c |>\nJust replace the call of `median`\
    \ with `(map (lambda (x) (median x)) l)`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  '  (/ (apply min l) (car l)))', "  (if (null? l)\n      '()\n      (/ @ (length\
    \ l)\n          (apply max (map fst l)))))\n", "  (/ (sort l '<) (length l)))\n",
  "  (/ (length l) (length l)))\n", "  (apply median (partition even? l)))\n", " \
    \ (/ (sort l) (length l)))\n", "  (/ (foldl (lambda (x y) (max (min x y) (min\
    \ x y))) l '()) 2))\n", "  (/ (fold-left (lambda (x y) (if (< x y) x y)) (- 1\
    \ (length l)) l) 2))\n", "  (/ (length l) (length l)))\n</cell>\n<text>\nWe have\
    \ one last function to calculate the arithmetic mean. We can just use length l\
    \ / length l - but we can also use / because the quotient operation will do integer\
    \ division.\n\n\n</text>\n<cell>", "  (/ (apply min (sort l))\n     (apply max\
    \ (sort l))))\n", "  (/ \n   (apply median l)\n   (length l)))\n", "  (cond\n\
    \    ((null? l) '())\n    ((< 4 (length l)) (/ 3 (median l)))\n    ((< 9 (length\
    \ l)) (/ 2 (median l)))\n    ((< 13 (length l)) (/ 1 (median l)))\n    (else (error\
    \ \"Unknown median of list: ~a\" l))))\n", "  (apply avg l))\n", "  (/ (reduce\
    \ (lambda (x y) (+ x y)) l)\n      (length l)))\n", "  (/ (reduce + l) (reverse\
    \ l)))\n", "  (if (null? l)\n      0\n      (/ (+ l (- (car l) (cadr l))) (length\
    \ l))))\n", "  (/ (apply min l) (length l)))\n", "  (/ (sort l)\n     (length\
    \ l)))\n", "  (if (empty? l)\n      (error \"No median.\" 'missing)\n      (median-helper\
    \ (rest l) 0)))\n", "  (/ (apply min l)\n     (apply max l)))\n", "  (/ (length\
    \ l)\n     (length l)))\n", "  (/ (sort l < ?) (length l)))\n", "  (/ (length\
    \ l)\n     (length l)))", '  (/ (/ (apply min l) (apply max l)) 2))', "  (/ 1000000000\
    \ (length l) (/ 1 (length l))))\n</cell>\n<text>\nExercises\nWrite a function\
    \ that takes a list and returns a new list that contains the same elements but\
    \ in sorted order.\n\n\n</text>\n<code language=ocaml-jupyter>\n#lang racket\n",
  "  (cond\n    ((null? l)              (error \"list length is 0\"))\n    ((null?\
    \ (cdr l))         (if (< (length l) 1) (error \"list is too short\"))\n     \
    \                             (/ (- (car l) (car l)) 2)))\n    (else         \
    \           (car l)\n      ))\n", "  (let loop ((l l) (c (rest l)))\n    (cond\
    \ ((empty? l) c)\n          ((< c c) (loop (rest l) c))\n          ((> (rest l)\
    \ c) (loop (rest l) (+ c 1)))\n          (else (loop (rest l) (/ c 2))))))\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=scheme,lisp,racket dscore=0 |>\nJust for fun (for\
    \ those that don't like tail recursion):\n<code>", "  (if (null? l)\n      (error\
    \ \"median called on empty list.\")\n      (median (rest l))))\n", "  (/ (/ (reduce\
    \ (lambda (e a) (if (> e a) a e)) l) (length l)) 2.0)\n)\n", "  (/ <(length (sort\
    \ (numbers l))) 2))\n</code>\n<|/ a dscore=0 tags=scheme,racket,functional-programming\
    \ |>\n<| a tags=scheme,racket,functional-programming |>\nThis might be what you're\
    \ looking for:\n<code>", "  (/ (- #(/ (min l) (length l)) (length l)) 2))\n",
  "  (/ (apply + l) 2))\n<|/ a dscore=1 |>\n<| a tags=scheme dscore=1 |>\nIn Racket\
    \ there are multiple ways to do that. Here is one:\n<code>", "  (/ (apply median\
    \ (sort l)) (length l)))\n</code>\nIt only requires a single pass over the list\
    \ to determine the median. Of course, if you have very large lists, you may want\
    \ to consider doing this in parallel.\n<|/ a dscore=5 |>\n<| c |>\nThe median\
    \ is probably a good approximation of the median. Using it in a computer program\
    \ is a bad idea, as that program would be vulnerable to a biased estimator and\
    \ give a bad estimate. Also, computing the median in parallel (by adding `#-multiproc`\
    \ on the top of your file) is also a bad idea, as that would require a huge amount\
    \ of extra memory to keep track of all the partial results.\n<|/ c |>\n<| c |>\n\
    It might be worth noting that this only works with `sort`able types (e.g. integers).\
    \ On a list that contains numbers and strings, this implementation will output\
    \ the list median which is not the same as the median of the list's elements.\
    \ Of course, for small lists (<10000), this might be the right approach, but for\
    \ large lists (>100,000), the approach is probably not going to be that good.\n\
    <|/ c |>\n<| c |>\nAside from the above, for lists that aren't `sort`able, I'd\
    \ say the best approach would be to simply find the median of the list using the\
    \ usual mean.\n<|/ c |>\n<| c |>\nThis code fails when the list contains no element\
    \ or is empty. BTW, this is an implementation of [the algorithm for finding the\
    \ median](http://en.wikipedia.org/wiki/Selection_algorithm#Computing_the_median).\n\
    <|/ c |>\n<| c |>\nI didn't say it would work for any list. This is an implementation\
    \ (and is therefore unbiased) for finding the median of any list; that's what\
    \ it's for.\n<|/ c |>\n<| a tags=racket,scheme |>\nIf you're happy to use modules,\
    \ there are a couple of Racket modules (and Scheme libraries) that do this.\n\
    <|/ a dscore=3 |>\n<| a tags=racket,scheme |>\nA very simple solution using functions\
    \ from the Racket/Scheme standard library is this:\n<code>", "  (/ (apply min\
    \ l) (length l)))\n", "  (/ (apply median l) 2.0))\n", "  (define (median-helper\
    \ l)\n    (cond\n      [(empty? l) empty]\n      [(cons? l) (cond\n          \
    \           [(< (car l) (car l)) (median-helper (cdr l))]\n                  \
    \   [(>= (car l) (car l)) (median-helper (cdr l))]\n                     [else\
    \ (median l)]))]\n      [else (median l)]))\n  (median-helper l))\n", "  (if (empty?\
    \ l)\n      '()\n      (let ([m (car (sort l))])\n        (if (> (length l) 2)\n\
    \            (/ (- (length l) 2) m)\n            (car l)))))\n", "  (cond [(empty?\
    \ l)\n         (error \"List must contain at least one element\")\n         ]\n\
    \        [(and (pair? (car l)) (not (pair? (cdr l))))\n         (* (/ (- car l)\
    \ (car (cdr l)))\n            (median (cdr l)))\n         ]\n        [else (median\
    \ (cdr l))]))\n", "  (cond\n    ((null? l) (car l))\n    ((< (car l) (median (cdr\
    \ l)))\n     (car l))\n    (else (median l))))\n", "  (cond\n    [(empty? l) 0]\n\
    \    [else\n     (let ([q (car l)]\n           [y (+ q (median (cdr l))))])\n\
    \       (/ q y))]))\n", "  (/ (car l) (car (rest l))))\n", "  (/ (apply min l)\
    \ (length l)))\n", "  (/ \n   (length l)\n   (apply + (map (lambda (x) (/ (+ x\
    \ 1) (length l))) l))\n  )\n)\n", "  (/ (car l)\n     (length l)))\n", "  (/ (car\
    \ l) (car (cdr l))))\n", "  (/ (sort l)\n     (length l)))\n", "  (/ 1 (length\
    \ l)))\n", "  (/ (apply median l) 2))\n", "  (/ (length l) (floor length (/ l\
    \ 2))))\n", "  (/ (reduce + l) (length l)))\n", "  (/ (reduce (lambda (x y) (max\
    \ (x y) y)) l) 2))\n", "  (cond\n    ((empty? l) 0)\n    ((< (car l) (cadr l))\
    \ (car l))\n    (else (median (cdr l))))) \n", "  (/ l (length l)))\n", "  (if\
    \ (not (null? l))\n      (/ (apply min l) 2)\n      0))\n", "  (/ (apply max l)\
    \ (length l)))\n", "  (/ (apply + l) (length l)))\n</code>\n<|/ a tags=scheme,racket\
    \ dscore=3 |>\n<| a tags=scheme,racket |>\nA way to find out if the list is sorted\
    \ is by using an accumulator.\nThe accumulator starts with zero, every time you\
    \ add an element to the list, you decrease the accumulator. If the accumulator\
    \ becomes zero, then the list is sorted, otherwise it's not.\n<code>", "  (/ (apply\
    \ + l) (length l)))\n", "  (/ (- <???> (length l)) 2))\n", "  (/ (apply max (rest\
    \ l)) (length l)))\n", "  (/ (apply median l)\n     (length l)))\n", "  (let loop\
    \ ([l l]\n             [size 0]\n             [max-idx 0])\n    (cond [(empty?\
    \ l) 0.0]\n          [(> size (length l)) (/ (car l) size)\n          [else (loop\
    \ (cdr l)\n                       (+ 1 size)\n                       (+ 1 max-idx))]])\n\
    \    (/ (car l) (+ size max-idx))))\n", "  (/ (sort l)\n     (length l)))\n",
  "  (/ (car l) (car (cdr l))))\n", "  (/ (/ (apply median (cons (car l) l)\n    \
    \               (length (cdr l)))\n          (length (cdr (cdr l))))))\n", " \
    \ (/ (apply median l) (length l)))\n</cell>\n<text>\nExercise\nWrite a function\
    \ that takes a list and a list of functions and returns a list containing the\
    \ results of each function.\n", "  (/ (+ 0 (- 0 (length l))) (length l)))\n",
  "  (/ (sort l)\n     (length l)))", "  (median-length l))\n", "  (/ (apply median\
    \ l) (length l)))\n", "  (/ (reduce (lambda (x y) \n                (if (< y x)\
    \ y x))\n           l)\n     (length l)))\n</cell>\n<text>\nExercise 1: Write\
    \ a function that returns the first element in a list that satisfies a given condition.\n\
    \n\n</text>\n<code language=dyalog-kernel>", "  (/ (apply median (take (length\
    \ l) l)) (length l)))\n)\n", "  (/ (apply + l) (length l)))\n", "  (if (< (length\
    \ l) 2) (first l) (\n           (- first (sort (take (- 1 (length l)) l)\n   \
    \                      (lambda (x y) (< (x y) (first l)))))))\n", "  (/ l (length\
    \ l)))\n", "  (cond [(empty? l) (infinity)] [else\n          (let [middle (/ (car\
    \ l) 2)\n                left (car (cdr l))\n                right (car (cdr (cdr\
    \ l))))]\n            (if (< middle left)\n              (median (cdr l))\n  \
    \            (if (< middle right)\n                (median (cdr (cdr l)))\n  \
    \              (median l))))]))\n", "  (if (null? l)\n      null\n      (/ (/\
    \ (car l) (car (cdr l))) (length l))))\n", "  (/ (apply median (rest l)) (length\
    \ l)))\n", "  (cond\n    [(empty? l) 0]\n    [else (/ (first l) (length (rest\
    \ l)))]))\n</cell>\n<cell>\n#lang racket\n", "  (/ (apply + (map (\u03BB(x) (*\
    \ x x)) l)) (length l)))\n", "  (if (= (length l) 1)\n      (first l)\n      (/\
    \ (/ (apply + l) (- 1 (length l))) 2)))\n", "  (apply (lambda (l count)\n    \
    \       (cond [(empty? l) 0]\n                 [(= count (length l)) (first l)]\n\
    \                 [else\n                  (/ 3 (+ (count (/ 2 (+ 1 count)) (length\
    \ l)))\n                    (/ (length l) (+ 1 count))\n                    (length\
    \ l))]))\n          l\n          (length l)))\n", "  (- (expt (/ 1 (length l))\
    \ 2)\n     (/ (apply min l) (length l))))\n", "  (/ (reduce + (map - l)) (length\
    \ l)))\n", "  (if (empty? l)\n      null\n      (/ (car l) 2)))\n</code>\n<|/\
    \ a tags=list,average,scheme dscore=0 |>\n<| a tags=list,average,scheme |>\nThis\
    \ is my solution which I believe to be quite efficient and readable (no need for\
    \ intermediate steps):\n<code>", "  (/ (reduce (lambda (x y) (if (< y x) y x))\n\
    \            (length l)\n            (lambda (x y)\n              (< x y)))\n\
    \     (length l)))\n</code>\n<|/ a |>\n<| c |>\nThis is not correct. Your first\
    \ definition is wrong in general. Try it on the list `(1 2 3)`. Your second definition\
    \ is incorrect.\n<|/ c |>\n<| c |>\nYou are correct. In the first case (`(1 2\
    \ 3)` vs `(1 2 4)`) there is no median in the second case (`(1 2 4 5)` vs `(1\
    \ 2 3 4)`). However I assumed this wasn't what the OP wants since he stated \"\
    median\" in the title. I'll modify the answer. Thanks.\n<|/ c |>\n<| a |>", " \
    \ (/ (min l) (length l)))\n", "  (/ <</ (length l) 2) (length l))\n)\n", "  (/\
    \ (apply min l) (length l)))\n", "  (foldr (lambda (x y) (if (< (- y) x) (- y)\
    \ x))\n         (/ 1 (length l))\n         l))\n", "  (/ (/ (apply + l) (reverse\
    \ l)) 2))\n</code>\n<|/ a dscore=2 tags=list,racket,median |>\n<| c |>\nThanks\
    \ your answer. May you explain what are you doing in the median function ?\n<|/\
    \ c |>\n<| c |>\n`apply + l` takes the `+` function and applies it to every element\
    \ of `l`. For the case of a list, this works because `+` has two parameters, but\
    \ for other functions the parameters are specified in the order that they are\
    \ expected by the function. In this case, the order of the parameters is `l a`,\
    \ so the function `+` will receive the elements of the list `l` first, then it\
    \ will receive the `a` parameter that was passed to `median` when the list `l`\
    \ was created. The `+ l` part works because the `+` function expects two parameters,\
    \ and since `apply` returns a list, `apply + l` will produce a list `(l (+ l a))`.\
    \ For more information about lists, check out the documentation: http://docs.racket-lang.org/reference/lists.html\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  (if (empty? l)\n      0\n      (/ (/ (car\
    \ l) (- l (length l))) 2)))\n", "  \n  (let ([ls (sort l)]) ; Sort l from smallest\
    \ to largest\n    (cond\n      [(empty? ls) 0]\n      [else (/ (first ls) (length\
    \ ls))]))) ; Divide first element by number of elements\n</cell>\n<cell>\n#lang\
    \ racket\n", "  (/ (foldl (\u03BB (x y) (+ y x)) (- l 1)) (length l)))\n", " \
    \ (let loop ((lst l) (len (length lst)))\n    (if (< len 0)\n        #f\n    \
    \    (/ (car lst) len)\n        (if (= len (even? len))\n            #t\n    \
    \        (loop (cdr lst) (- len 1))))))\n", "  (/ (length l) (+ (length l) (length\
    \ l))))\n", "  \n  (cond\n    ((null? l)\n     null)\n    ((< (first l) (second\
    \ l))\n     (median (rest l)))\n    ((> \n        (first l)\n        (second l))\n\
    \     (first l))\n    (else\n     (median (rest l))))\n  \n)\n", "  (cond\n  \
    \  [(empty? l) (error)\n     (/ (car l) (length l))]\n    [else (/ (car l) (median\
    \ (rest l)))]))\n", "  (define (median l accum min)\n    (cond [(empty? l) min]\n\
    \          [(<= (first l) (first accum)) (median l (rest l) min)]\n          [(>=\
    \ (first l) min) (rest l)]\n          [else (median l (cons (first l) accum) (min\
    \ (first l)))]))\n  (median l '() (min (first l))))\n", "  (/ (/ (apply min l)\n\
    \      (apply max l))\n     (length l)))\n", "  (/ (min l) (length l)))\n", " \
    \ (/ (car (foldr (lambda (x y)\n                     (if (< x y)\n           \
    \              x\n                         y)))\n          l)\n     (length l)))\n",
  "  (let ((len (length l)))\n    (cond\n      [(= len 1) l]\n      [(< len 2) (/\
    \ (car l) (+ len 2))]\n      [else (let ([m (car l)])\n               (if (= len\
    \ (- len 1))\n                   (/ (car l) (+ len 2))\n                   (/\
    \ (car l) (+ len (- len 1)))\n                   (/ (car l) (+ len (- len 2)))))]))))\n",
  "  (/ (car (sort l)) (length l)))\n", "  (if (empty? l)\n      null\n      (/ (car\
    \ l)\n         (- l (length l)))\n       ))\n", "  (/ (reduce (lambda (x y) (if\
    \ (< (length x) y) (+ 1 (/ (length x) y) y) y))\n              l\n           \
    \   0)\n       2))\n", "  (median-helper l #f))\n", "  (let loop ((l l) (acc 0))\n\
    \    (if (empty? l)\n        acc\n        (loop (rest l) (+ (/ (car l) (length\
    \ l)) acc)))))\n", "  (/ (sum l) (length l)))\n", "  (/ (reduce + l)\n     (length\
    \ l)))\n", "  (/ (sum (map 'car l)) (length l)))\n", "  (/ (apply min l)\n   \
    \  (apply max l)))\n", "  ;; TODO: implement this as a tail-recursion function.\n\
    \  (cond\n    [(empty? l) null]\n    [(list? (first l)) (median l)]\n    [else\
    \ (/ (+ (first l) (median (rest l)))\n             (length (first l)))]))\n",
  "  (/ (apply min l) (length l)))\n", "  (/ (apply min l) (apply max l)))\n", " \
    \ (if (null? (car l))\n      (/ (/ (car l) (car (cdr l))) 2)\n      (median (cdr\
    \ l))))\n", "  (if (empty? l)\n      (error 'median (wrong-length (list->string\
    \ l))) ; for testing\n      (middle-of-list l)))\n", "  (/ (length (sort l)) 2))\n",
  "  (/ (apply + l) 2))\n", "  (let loop ([i 0] [l l])\n    (cond [(empty? l) '()]\n\
    \          [(< i (length l)) (loop (+ i 1) l)]\n          [else (expt (/ (car\
    \ l) (- i 1)) (+ i 1))]))))\n", "  (/ (apply + (map fst l)) (length l)))\n", " \
    \ (/ (/ (reduce (lambda (x y)\n                  (if (< x y)\n               \
    \       x\n                      y))\n              l\n              (lambda (x\
    \ y)\n                (if (< x y)\n                    x\n                   \
    \ y)))\n      (length l))))\n", "  (/ (reduce (lambda (x y) (if (< (+ x y) 0)\
    \ (+ x y) (+ x y))) l 0) (length l)))\n", "  (/ (/ (apply min l) (length l)) 2))\n",
  "  (if (null? l)\n      '()\n      (let ((m (apply min l))\n            (k (apply\
    \ max l)))\n        (/ (- (car l) (/ (- m k) 2))\n          (car (cdr l)))))\n",
  "  (/ (median-of l 0) (length l)))\n", "  (/ \n   (apply median-of l)\n   (length\
    \ l)\n   ))\n", "  (if (empty? l)\n      (error 'median-error \"No elements in\
    \ list\")\n      (/ (* (first l) (length l)) 2)))\n", "  (/ (apply median l) (length\
    \ l)))\n", "  (if (null? l)\n      null\n      (median (rest l))))\n", "  (/ (apply\
    \ min l) (length l)))\n", "  (/ (reduce +\n           (map / l (length l)))\n\
    \     (length l)))\n", "  (/ (reduce (lambda (x y) (min x y)) l)\n     (length\
    \ l)))\n", "  (/ (min l) (length l)))\n", "  (if (null? l)\n      (/ 0 (length\
    \ l))\n      (/ (reduce (flatten l) (flatten l)) 2)))\n", "  (/ (length l) (*\
    \ 2.0 <)))\n", "  (let loop ([i 0])\n    (cond [(null? l)\n           (error \"\
    List should not be empty\")] \n          [(null? (rest l))\n           (/ 0.0\
    \ 1.0)]\n          [(< (first l) (first (rest l)))\n           (loop (add1 i))]\n\
    \          [(= (first l) (rest l))\n           (loop (add1 i) (add1 i))]\n   \
    \       [else\n           (loop (add1 i) (add1 i))]))))\n", "  (/ (- l (length\
    \ l)) 2))\n", "  (let loop ((l l) (acc '()))\n    (cond ((null? l) (reverse acc))\n\
    \          ((number? (car l))\n           (loop (cdr l) (cons (car l) acc)))\n\
    \          (else\n           (loop (cdr l) (cons (car l) (cons (car l) acc)))))\n\
    \  (/ (reduce + acc) 2.0))\n", "  (fold (lambda (x y) (foldr (lambda (x y) (foldr\
    \ (lambda (x y) (min x y)) x y)) x y) (sort l '<)) 0 (sort l '<)))\n", "  (/ (length\
    \ l) (+ 1 2)))\n</cell>\n<text>\nFunctions to find maximum and minimum\n\n</text>\n\
    <text>\nLet's define functions to find the maximum and minimum of an array:\n\n\
    \n</text>\n<code language=dyalog-kernel>", "  (let ((length 0))\n    (do ((x l\
    \ length) (length (+ length 1)))\n        ((< length 0) '()))\n    (/ (+ length\
    \ (- length 1)) (length 2)))\n)\n", "  (/ 0 (+ l (/ 0 (+ l 1)))))\n", "  (/ (car\
    \ l) (car (cdr l))))\n", "  (/ (length l) 2))\n", "  (/ (- (length l) (apply +\
    \ l)) 2))\n", "  (/ (reduce (lambda (a b) (/ (+ a b) 2)) l)\n     (length l)))\n",
  "  (/ (+ (apply min l) (apply max l)) 2.0))\n", "  (/ (apply min l)\n     (length\
    \ l)))\n", "  (/ (reduce + l) (carl l)))\n", "  (if (null? l)\n      (error \"\
    median of empty list\")\n      (median (cdr l)))) ;; tail\n", "  (cond\n    ((null?\
    \ l) nil)\n    ((> l (car l)) (car l))\n    (else (median (cdr l)))))\n</code>\n\
    <|/ a |>\n<| a tags=racket,scheme dscore=2 |>\n<code>", "  (let loop ((n 0) (r\
    \ l) (m 0))\n    (cond ((null? r) m)\n          ((< (first r) (/ n 2)) (+ m (first\
    \ r)))\n          ((< n (/ r 2)) (loop (+ n 1) (r) (+ m (first r))))\n       \
    \   :else (loop (+ n 1) (r) (+ m (first r))))))\n", "  (/ (length l) 2))\n", " \
    \ ;; Sort list with quicksort, then pick the median.\n  (median-sort l)\n  ;;\
    \ Return the middle element of the list.\n  (list-ref l 2))\n", "  (/ (length\
    \ l) 2))\n<|/ a dscore=1 tags=racket,scheme |>\n<| c |>\nThis isn't a bad solution,\
    \ though it does reimplement a lot of existing functionality of `map` and `filter`.\n\
    <|/ c |>\n<| c |>\n: This solution doesn't reimplement `map`; it just calls `map`\
    \ once for each  element of the input list, then `median`. As for `filter`, this\
    \ is more complicated because it will have to iterate over the entire list even\
    \ after finding at least one non-zero element. To avoid that, we have to keep\
    \ a record of elements that we already looked at, and not look at them again.\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nHow about:\n<code>", "  (median-helper l\
    \ l (length l) 0))\n", '  (/ (apply median l) 2))', "  (/ (apply + l) (length\
    \ l)))\n", "  (/ (reduce (lambda (x y) (if (< x y) (+ x y) y)) l) (length l)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
