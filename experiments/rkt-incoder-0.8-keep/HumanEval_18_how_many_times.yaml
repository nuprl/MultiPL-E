name: HumanEval_18_how_many_times
language: rkt
prompt: "#lang racket\n\n;; Find how many times a given substring can be found in\
  \ the original string. Count overlaping cases.\n;; >>> how_many_times('', 'a')\n\
  ;; 0\n;; >>> how_many_times('aaa', 'a')\n;; 3\n;; >>> how_many_times('aaaa', 'aa')\n\
  ;; 3\n(define (how_many_times string substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n\
  \    (check-equal? (candidate \"\" \"x\") 0)\n    (check-equal? (candidate \"xyxyxyx\"\
  \ \"x\") 4)\n    (check-equal? (candidate \"cacacacac\" \"cac\") 4)\n    (check-equal?\
  \ (candidate \"john doe\" \"john\") 1)\n))\n\n(test-humaneval)"
completions: ["  (define start 0\n           end (length string))\n  (define count\
    \ 0)\n  (while start < end\n    (define index (string-index string substring start\
    \ end))\n    (when (= index (string-length substring))\n      (set! count (+ count\
    \ 1)))\n    (set! start (+ index 1))))\n  count)\n", "  (if (empty? string) 0\n\
    \      (let ((pos (position (substring string) string))\n            (substring\
    \ (substring string 0 (add1 pos))))\n        (+ 0 (- pos 0)))))\n</code>\nThis\
    \ uses substring in order to avoid building unnecessary lists. Then it uses a\
    \ slightly more efficient position that uses only a single pass through the string.\n\
    <|/ a tags=racket,string,substring,scheme |>\n<| c |>\nThis solution has a flaw\
    \ -- it can give a wrong answer when there is more than one occurrence of the\
    \ substring.  (For example, try it with `(how_many_times \"aaaa\" \"aa\")`.)\n\
    <|/ c |>\n<| c |>\n- Good point, I missed that one. I've added a corrected version\
    \ which should work now.\n<|/ c |>\n<| c |>\n- I've added a version that uses\
    \ `substring` which should avoid the unnecessary lists while still being efficient.\n\
    <|/ c |>\n<| c |>\nBTW -- it looks like you're trying to learn Racket.  If you\
    \ want to do anything complicated (like counting overlapping strings) then you\
    \ really should learn the standard Racket functions.  `position` and `length`\
    \ are useful.  Also, you should read [the book](http://htdp.org/2003-09-26/Book/curriculum-Z-H-26.html).\
    \  It's very thorough.\n<|/ c |>\n<| a tags=racket,string,substring,scheme |>\n\
    The simplest way is to use index to find the location where your substring starts\
    \ in the string, and use substring to extract the substring you want.\n<code>",
  "  (length (remove-duplicates (fold (lambda (subs acc) (if (char=? (subs 0) substring)\
    \ (incf acc) acc)) 0 string))))\n", '  (length (string->list string) (string->length
    string) substring))', "  (length \n   (string-index\n    '()\n    (string-split\
    \ \n     (string->list string)\n     (string->list substring)))\n  )\n)\n", '  (string-count
    string substring string))', "  (string-length string)\n  (let ([count 0])\n  \
    \  (for ([i string])\n      (when (or (string=? substring i) (string=? substring\
    \ (string-ref string 1)))\n        (set! count (add1 count)))))\n  count)\n",
  "  (count-substrings string substring 0))\n", "  (match-string-at string substring\
    \ 0))\n", "  (let loop ((found 0) (counting 0) (index 0))\n    (cond ((= index\
    \ string) (add1 found))\n          ((memchar= substring string (memrchr index\
    \ string 0))\n           (loop (add1 found) (add1 counting) (sub1 index)))\n \
    \         (else (loop (add1 found) (add1 counting) (add1 index))))))\n", "  (count_substrings\
    \ '() string substring))\n", "  (let loop ((count-so-far 0)\n             (so-far\
    \ string)\n             (sub-string substring))\n    (cond\n      [(empty? so-far)\n\
    \       count-so-far]\n      [(equal? (first so-far) sub-string)\n       (loop\
    \ (+ count-so-far 1)\n             (rest so-far)\n             sub-string)]\n\
    \      [else\n       (loop (+ count-so-far 1)\n             (rest so-far)\n  \
    \           (first so-far))])))\n", "  (length\n   (remove-if-not (lambda (s)\
    \ (equal? (length s) (length substring))) (reverse string))))\n", "  (local ((define\
    \ (count-overlap i j)\n             (cond\n              [(or (eq? i (string-length\
    \ string)) (eq? j (string-length string)))\n               (if (< (char-code (substring\
    \ string i)) (char-code (substring string j)))\n                   (add1 i))]\n\
    \              [(< i (string-length string))\n               (add1 (count-overlap\
    \ (+ i (string-length string)) j))]\n              [else\n               (add1\
    \ (count-overlap i j))]))\n         (define (count-overlaps string substring)\n\
    \           (cond [(or (eq? i (string-length string)) (eq? j (string-length string)))\n\
    \                  (add1 0)]\n                 [(< i (string-length string))\n\
    \                  (add1 (count-overlaps (+ i (string-length string)) j))]\n \
    \                [else\n                  (add1 (count-overlaps i (substring string\
    \ i)))]))\n         (if (eq? (string-length string) 0)\n             0\n     \
    \        (if (eq? substring \"\")\n                 0\n                 (if (eq?\
    \ (substring string 0) \"\")\n                     0\n                     (if\
    \ (eq? (substring string 1) \"\")\n                         0\n              \
    \           (if (eq? (substring string 2) \"\")\n                            \
    \ 0\n                             (if (eq? (substring string 3) \"\")\n      \
    \                           0\n                                 (if (eq? (substring\
    \ string 4) \"\")\n                                     0\n                  \
    \                   (if (eq? (substring string 5) \"\")\n                    \
    \                     0\n                                         (if (eq? (substring\
    \ string 6) \"\")\n                                             0\n          \
    \                                   (if (eq? (substring string 7) \"\")\n    \
    \                                             0\n                            \
    \                     (if (eq? (substring string 8) \"\")\n                  \
    \                                   0\n                                      \
    \               (if (eq? (substring string 9) \"\")\n                        \
    \                                 0\n                                        \
    \                 (if (eq? (substring string 10) \"\")\n                     \
    \                                        0\n                                 \
    \                            (if (eq? (substring string 11) \"\")\n          \
    \                                                       0\n                  \
    \                                               (if (eq? (substring string 12)\
    \ \"\")\n                                                                    \
    \ 0\n                                                                     (if\
    \ (eq? (substring string 13) \"\")\n                                         \
    \                                0\n                                         \
    \                                (if (eq? (substring string 14) \"\")\n      \
    \                                                                       0\n  \
    \                                                                           (if\
    \ (eq? (substring string 15) \"\")\n                                         \
    \                                        0\n                                 \
    \                                                (if (eq? (substring string 16)\
    \ \"\")\n                                                                    \
    \                 0\n                                                        \
    \                             (if (eq? (substring string 17) \"\")\n         \
    \                                                                            \
    \    0\n                                                                     \
    \                    (if (eq? (substring string 18) \"\")\n                  \
    \                                                                           0\n\
    \                                                                            \
    \                 (if (eq? (substring string 19) ", "  (let ((count 0))\n    (loop\n\
    \       (cond [(empty? string) #f]\n             [(equal? (car string) substring)\n\
    \               (set! count (add1 count))\n               (set! string (rest string))]\n\
    \             [else\n               (set! string (rest string))])\n    (set! count\
    \ (sub1 count))\n    (return count)))\n", "  (define (how_many-times string substring\
    \ start end)\n    (cond [(null? string) 0]\n          [(substring (string-ref\
    \ string start)) (+ 1 (how_many-times string substring (+ start 1) end))]\n  \
    \        [else (if (and (null? substring) (equal? string substring)) (how_many-times\
    \ string substring (+ start 1) end) 0)]))\n  (how_many-times string substring\
    \ 0 string->length(string)))\n", "  (let ((count 0))\n    (for ((i (in-range 0\
    \ (length string)))\n           (j (in-range 0 (length substring)))\n        \
    \   (c (char-ord string i)\n               (char-ord substring j)))\n      (cond\
    \ ((char=? (char-ord substring j)\n                   c)\n             (incf count))\n\
    \            ((char=? (char-ord substring j) c)\n             (decf count))\n\
    \            (else #f))))\n", "  (cond\n    ((empty? string) 0)\n    ((string=?\
    \ substring (car string)) (+ (how_many_times (cdr string) substring) 1))\n   \
    \ (else (how_many_times (cdr string) substring))\n  )\n)\n</cell>\n<cell>\n#lang\
    \ racket\n", "  (count (lambda (c) (equal c substring))\n\t (string->list string)))\n",
  "  (define n 0)\n  (define start 0)\n  (define end 0)\n  (define index 0)\n  (define\
    \ length 0)\n  (while-not (equal? (string-length string) 0)\n    (set! n (+ n\
    \ 1))\n    (set! start (substring-index string 0))\n    (set! end (substring-index\
    \ string 1))\n    (set! index (substring-index string 2))\n    (set! length (substring-index\
    \ string 3))\n    (when (equal? (substring string start end index length 1) 0)\n\
    \      (set! n (+ n 1))\n      (set! start (substring-index string 0))\n     \
    \ (set! end (substring-index string 1))\n      (set! index (substring-index string\
    \ 2))\n      (set! length (substring-index string 3)))))\n  n)\n</code>\n<|/ a\
    \ tags=ocaml,ocaml-core,string,pattern-matching dscore=2 |>\n<| c |>\nI appreciate\
    \ that this is an old post, but could you add some explanation for your code?\n\
    <|/ c |>\n<| c |>\nI added some explanation\n<|/ c |>\n<| c |>\nI appreciate this\
    \ answer, but I believe there has been some movement in the ML community since\
    \ this was first posted. See the discussion [here](http://caml.inria.fr/permalink/15607/).\
    \ Also, please read [this answer](http://stackoverflow.com/questions/15646322/ocamls-string-manipulation-functions/15646521#15646521)\
    \ I wrote and give it another look.\n<|/ c |>\n<| c |>\nThis is indeed a very\
    \ old answer and I was still working on it after almost 2 years. That said, I\
    \ believe that my answer is still correct because I didn't find any better way\
    \ to achieve the goal while keeping the code as compact as possible. Moreover,\
    \ I believe that my answer is still valid because I wrote it more than 10 years\
    \ ago and I still use it.\n<|/ c |>\n<| a dscore=1 tags=ocaml,ocaml-core,string,pattern-matching\
    \ |>\nFor me the simplest solution in OCaml was:\n<code>\nlet find_all_matches\
    \ input pattern =\n  let rec aux pattern input = match input with\n  | \"\" ->\
    \ (ref [])\n  | c :: str ->\n    if c = pattern then \n      (let rec aux (_ ::\
    \ pattern :: list) = match pattern with\n        | [] -> aux str []\n        |\
    \ h :: t ", "  (count-substrings\n   (string-index string substring)\n   (lambda\
    \ (pos) (>= pos (string-length string)))\n   (lambda (pos)\n     (when (string-char-at\n\
    \              (string-substring string 0 (add1 (substring #0 pos))) pos)\n  \
    \     (lambda () (add1 (substring #0 pos)))\n       (lambda () (substring #0 pos)))))\n\
    </code>\n<|/ a tags=string,racket,string,scheme dscore=1 |>\n<| a |>\n<code>",
  "  (let* ((len (string-length string))\n         (indices (build-indices-string\
    \ string len)))\n    (map + (count-occurrences-string substring string indices))))\n",
  "  (cond\n    [(string? string) (string-length (string-lower (string->list (string-replace\
    \ string substring \"\")))) ]\n    [else 0]))\n", "  (define (help-out substring\
    \ string i)\n    (if (eq? i 0)\n        (length string)\n        (help-out substring\
    \ (string-copy string) (- i 1) (+ i 1))))\n  (let loop ((i 0)\n             (len\
    \ 0)\n             (count 0))\n    (if (eq? i 0)\n        count\n        (if (eq?\
    \ (string-index string substring) i)\n            (loop (+ i 1)\n            \
    \       (+ len 1)\n                   (+ count 1))\n            (loop (+ i 1)\n\
    \                   (length string)\n                   (+ count 1)))))\n  (if\
    \ len\n      count))", "  (length (string->list string) (string-index string substring)))\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work because you only count the length\
    \ of the sub-string if the substring is at the start of the string. Try calling\
    \ `how_many_times('aaaaaaa', 'a')` and you'll see what I mean.\n<|/ c |>\n<| c\
    \ |>\nYes, you are right, thank you. I have fixed the example.\n<|/ c |>\n<| a\
    \ tags=racket,string,substring |>\n<code>", "  (cond\n    ((string? substring)\
    \ 0)\n    ((string? (string-ref string 0))\n     (let ((count 0))\n       (cond\n\
    \         ((string-ref? substring 0)\n          (cond ((string? substring) (set!\
    \ count (+ (string-ref substring 0)\n                                        \
    \         (string-ref string 0)))\n                 ((char? substring)\n     \
    \             (set! count (+ (string-ref substring 0)\n                      \
    \           (string-ref string 0))))\n         ((char? substring)\n          (set!\
    \ count (+ count\n                         (string-length substring)))))\n   \
    \      ((char? substring)\n          (set! count (+ count\n                  \
    \       (string-length (string-ref substring 0)))))))\n    ((< 0 (string-length\
    \ string)) count)\n    (else (+ (how_many_times (string-ref string 0)\n      \
    \                substring)\n            (how_many_times (string-ref string 1)\n\
    \                          substring)))))\n</code>\n<|/ a tags=string,substring,scheme\
    \ |>\n<| c |>\nI didn't see you use Racket.  I added a version for it now.  You\
    \ might want to read up on what Racket has since it doesn't have many of the functions\
    \ your original version uses.\n<|/ c |>\n<| c |>\nYou know my function works,\
    \ but I wanted a more general version. Not because I like it (I do), but because\
    \ it is a homework assignment, and not because the assignment is important.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis solution is based upon what was presented in\
    \ Eli Bendersky's blog. \n<code>", "  (cond\n    [(empty? substring) 0]\n    [else\n\
    \     (+ (count-overlapping-chars string substring) (how_many_times substring\
    \ (cdr substring)))]))\n", "  (length (split-string string substring)))\n", " \
    \ (if (null? substring)\n      0\n      (count-substrings (string-ref string 0)\
    \ substring)))\n", "  (if (empty? string)\n      0\n      (let ((found (count-if-not\
    \ (lambda (c) (eq? c substring)) string)))\n        (+ found (how_many_times (substring\
    \ (substring 0 found)) substring)))))\n", "  (cond\n    [(empty? string) 0]\n\
    \    [(substring? (car string)) (+ 1 (how_many_times (cdr string) substring))]\n\
    \    [else (how_many_times (cdr string) (substring string))]))\n", "  (match (string\
    \ substring) [(empty _) 0])\n  (match (string substring) [(cons s1 s2) n] [(cons\
    \ s1 (cons s2 n))] (cons n (cons s1 n))))\n", "  (let loop ((idx 0)\n        \
    \     (count 0))\n    (cond ((eq? string \"\") count)\n          ((eq? (char-ref\
    \ string idx) substring)\n           (loop (+ idx 1) (+ count 1)))\n         \
    \ ((char-ref string idx) (incf idx))\n          (else (loop (+ idx 1) count))))))\n",
  "  (let loop ((count 0) (index 0) (substring substring))\n    (cond\n      ((null?\
    \ substring) count)\n      ((string=? index (string-length string)) count)\n \
    \     (else (loop (+ count 1) (+ index 1) (string-ref string index)))\n    )\n\
    \  )\n)\n", "  (if (empty? string)\n      0\n      (+ (string=? (substring string)\
    \ substring) (how_many_times (substring string) (substring string))))) ;; #lang\
    \ racket\n", "  (if (empty? substring) 0\n      (if (equal? string substring)\
    \ 1\n          (+ 1 (how_many_times (rest string) substring)))))\n</cell>\n<cell>\n\
    #lang racket\n", "  (count-substrings string substring))\n", "  (if (empty? substring)\n\
    \      0\n      (+ 1 (count (subseq string 0 (string->length (first substring)))\
    \ string))))\n", "  (cond\n    [(string? string) (string-length string)]\n   \
    \ [(number? string) 0]\n    [else (+ 1 (string-count string substring))]))\n",
  "  (cond ((zero? string) 0)\n        ((equal? string substring) 1)\n        (else\
    \ (+ 1 (how_many_times (rest string) substring)))))\n", "  (length (filter (lambda\
    \ (sub) (equal? sub substring)) (string-map string string))))\n", "  (cond [(empty?\
    \ string) 0]\n        [(eq? substring (car string)) (+ 1 (how_many_times (cdr\
    \ string) substring))]\n        [else (+ (how_many_times (car string) substring)\
    \ (how_many_times (cdr string) substring))]))\n", "  (let loop ((count 0)\n  \
    \           (result 0))\n    (cond\n      ((eqv? substring \"\") count)\n    \
    \  ((eqv? string \"\") (add1 count))\n      (else (loop (add1 (count (eqv? (string-contains\
    \ string substring))))\n                 (add1 count))))))\n", "  (if (null? substring)\n\
    \      0\n      (let ((position (string-index (string substring) string)))\n \
    \       (if (= (- position 0) (- string-length string))\n            0\n     \
    \       (+ 1 (how_many_times string (substring (string-sub (string position) 1)))))))\n",
  "  (define (count start end)\n    (cond\n      [(or (eq? end 0)\n           (eq?\
    \ start 0))\n       0]\n      [(string=? string substring)\n       (+ 1 (count\
    \ start end))]))\n  (count 0 0))\n", "  (cond\n    [(empty? string) 0]\n    [else\
    \ (add1 (count-times substring string))]))\n", "  (let ([str (string->list string)\n\
    \        loc (string->list substring)]\n        [count 0])\n    (cond [(and (empty?\
    \ str) (empty? loc)) count]\n          [(eq? (first str) (first loc)) (add (first\
    \ str) count)\n           (recur (rest str) (rest loc))]\n          [else (add\
    \ (first str) (how_many_times (rest str) (first loc)))]))", "  (define (count\
    \ string substring)\n    (if (empty? string)\n        0\n        (if (equal? (car\
    \ string) substring)\n            (+ 1 (count (cdr string) substring))\n     \
    \       (+ 1 (count (cdr string) substring)))))\n  (count string substring))\n",
  "  (cond ((or (string-empty? string) (string-empty? substring))\n         (eq? 0\
    \ 0))\n        (else\n         (let ((i (string-length string))\n            \
    \   (j (string-length substring))\n               (start (substring 0 i))\n  \
    \             (end (substring i j)))\n           (if (= end j)\n             \
    \  (+ 1 (substring start start))\n               (+ 1 (how_many_times (substring\
    \ (+ start 1) end) (substring start j))))))))\n", "  (let* ([start-index (position-if\
    \ substring string 0)\n         end-index (position-if substring string (string-length\
    \ string)))\n    (+ 0 (- end-index start-index))))\n", "  (if (empty? string)\n\
    \      0\n      (if (string=? substring (string/tail string))\n          1\n \
    \         (+ (how_many_times (string/substring string 0 string/length) substring)\n\
    \             (how_many_times (string/substring string (string/length string)\
    \ (length (string/substring string 0 string/length))) substring))))\n", "  (substring\
    \ (string-length string) (string-length substring)\n            (string=? string\
    \ substring)))\n", "  (cond [(empty? string) #f]\n        [else (+ 1 (string-contains-substring\
    \ string substring))]))\n", "  (count\n   (lambda (x)\n     (equal? (char-string-ref\
    \ x 0)\n               (char-string-ref substring 0))))\n  (string-length string))\n",
  "  (cond [(empty? string) 0]\n        [(empty? substring) 1]\n        [(equal? string\
    \ (substring (first string))) (add1 (how_many_times (rest string) substring))]\n\
    \        [else (add1 (how_many_times (rest string) substring))]))\n", "  (define\
    \ (helper pos str substr current-count)\n    (cond [(empty? str) current-count]\n\
    \          [(eq? substr (string-ref str (- pos 1)))\n           (helper (+ pos\
    \ 1) str (substring substr) current-count)]\n          [else (helper (+ pos 1)\
    \ str (substring substr) current-count)]))\n  (helper 0 string substring 0))\n",
  "  (count\n   (lambda (n)\n     (if (equal? string \"\")\n         (add n 1)\n \
    \        (if (equal? (string-ref string 0) substring)\n             (add n 1)\n\
    \             (if (equal? string substring)\n                 (add n 1)\n    \
    \             (recur n))))))\n", "  (let loop ((string-to-find string)\n     \
    \        (current-index 0)\n             (result 0))\n    (cond [(string-to-find\
    \ substring) result]\n          [else (loop (cdr string-to-find)\n           \
    \            (+ 1 current-index)\n                       (+ result 1))]))\n</code>\n\
    <|/ a tags=racket,lisp,scheme dscore=1 |>\n<| c |>\nThank you for your answer.\
    \ I'm going to try and implement it for myself, but I'm curious to know if this\
    \ would work on a racket implementation.\n<|/ c |>\n<| c |>\nYes, it should work\
    \ on any Scheme implementation that provides tail call optimization (Cray or MIT/GNU\
    \ Racket do).\n<|/ c |>\n<| c |>\nThank you for the tips. This is really good\
    \ to know that I can do this without the use of a tail recursion loop. I'm going\
    \ to try and implement it myself and see how it works.\n<|/ c |>\n<| c |>\n: Racket\
    \ doesn't have tail call optimization, so this won't work.\n<|/ c |>\n<| a tags=racket,lisp,scheme\
    \ |>\nScheme is actually a Lisp, so it isn't a difficult programming language\
    \ to learn and to implement.\nHowever, I would highly recommend using the \"Racket\"\
    \ language instead of \"Scheme\".  It's very different from both implementations\
    \ and has lots of goodies.  It's a very well documented language, with good libraries\
    \ for basic stuff, and easy to learn.  It has lots of good libraries for lots\
    \ of problems.  And it's got some good libraries for implementing your problem.\
    \  \nIt's called \"Racket\" and it's got lots of good libraries.  They have a\
    \ lot of examples.  And I bet if you just do a search for \"racket string search\"\
    \ there are lots of examples.  And it has a lot of good libraries too.  \nIt isn't\
    \ really \"Scheme\", though, because it's really an implementation of Racket which\
    \ is written in Scheme.\n<|/ a dscore=0 |>\n<| c |>\nI am using the racket implementation\
    \ for my professors homework, but I wanted to try and implement this in scheme\
    \ as well, since he seems to have written it for scheme anyway.\n<|/ c |>\n<|\
    \ c |>\n:  I really don't recommend using Racket, anyway ;-).  Racket is really\
    \ an implementation of Scheme which is written in Scheme.  It has lots of good\
    \ libraries for basic stuff, and easy to learn.  It's called \"Racket\" and ",
  "  (define (helper string substring)\n    (cond [(empty? string) 0]\n          [(substring?\
    \ (first string)) (+ 1 (helper (rest string) (first substring)))]\n          [else\
    \ (+ 1 (helper (rest string) substring))]))\n  (helper string substring))\n",
  "  (if (eq? string \"\")\n      0\n      (+ 1 (string-count substring string))))\n",
  "  (cond ((eqv? string \"\")\n         0)\n        ((eqv? substring \"\")\n    \
    \     (error \"Substring must not be empty\")))\n  (let ((count 0))\n    (loop\n\
    \       ((idx 0) (end string))\n       ((found false)\n        (string\n     \
    \    (cond\n           ((string-equal end substring)\n            (error \"Found\
    \ empty string!\"))\n           ((string-equal end string)\n            (error\
    \ \"Found substring at the end!\"))\n           (else\n             (substring\
    \ idx end)\n             (cond\n               ((string-equal idx 0)\n       \
    \         (error \"Found empty string!\"))\n               ((string-equal idx\
    \ end)\n                (error \"Found substring at the end!\"))\n           \
    \    (else\n                (substring idx (+ idx (length (substring idx end))))\n\
    \                (cond\n                   ((string-equal idx (+ idx (length (substring\
    \ idx end))))\n                   (found (+ 1 (count))))\n                   ((string-equal\
    \ idx (+ idx (length (substring idx end))))\n                   (found (+ count\
    \ (count idx))))\n                   (else\n                   (error \"Found\
    \ substring in middle of another string!\"))))))))\n    (cond\n      ((not found)\n\
    \       (+ count 1)))))\n", "  (cond ((or (= (string-length string) 0) (string-length\
    \ substring) (string-length substring) = 0)\n         0)\n        ((equal? (string-ref\
    \ string 0) substring)\n         (+ 1 (how_many_times (string->list string) substring)))\n\
    \        (else\n         (let ((index (string-index string substring))\n     \
    \         (count-1 (how_many_times (string->list string) (string-ref string 1)))\n\
    \              (count-2 (how_many_times (string->list string) (string-ref string\
    \ 2)))\n              (count-3 (how_many_times (string->list string) (string-ref\
    \ string 3))))\n           (cond ((> index 0)\n                  (cond ((> index\
    \ count-1)\n                         (cond ((> index count-2)\n              \
    \                   (cond ((> index count-3)\n                               \
    \          (cond ((> index 0)\n                                              \
    \   (+ 1 (how_many_times (string->list string) (substring 0 index)))\n       \
    \                                          (else 0))\n                       \
    \                   (else 0))\n                                     (else 0))\n\
    \                                 (else 0))\n                           (else\
    \ 0))\n                       (else 0))\n                     (else 0)))))\n \
    \       ;; Not found, return 0\n        (else 0))) ; <-- add this\n", "  (if (empty?\
    \ substring)\n      0\n      (let ((count (+ (string-index (string substring)\
    \ string) 1)))\n        (if (< count (length string))\n            count\n   \
    \         (how_many_times (string-append string substring) substring))))))\n",
  "  (length (filter (lambda (c)\n                    (and (equal? c substring)\n\
    \                         (equal? (string-index string c) (length (string-index\
    \ string substring))))\n                    (cdr string))\n               string)))\n",
  "  (if (string-empty? string)\n      0\n      (+ 1 (count (substring-before string\
    \ substring) string))))\n", "  (length (string->list string) (string->list substring)))\n",
  "  (count (hash-ref (hash-ref (hash-ref (string->hash string) substring) 0)\n  \
    \                   substring)\n          (hash-keys string)))\n", "  (count\n\
    \   (for-each (lambda (c)\n              (when (eq? c substring)\n           \
    \     (return-from how_many_times 1)))\n              string)))\n", "  (length\
    \ (string-contains? string substring)))\n", "  (let loop ([indices #(#f #f #f\
    \ #f #f #f)])\n    (if (null? substring)\n        (length (filter #(and (set?\
    \ %) (eq? % substring)) indices))\n        (loop (conj indices (member substring\
    \ (string-ref string 0))) (string-ref string 1))))))\n", "  (let ([len (length\
    \ string)])\n    (cond [(= len 0)\n           0]\n          [(string-equal? substring\
    \ \"\")\n           0]\n          [(string-equal? substring string\n         \
    \                  #true)\n           1]\n          [else\n           (cond [(>\
    \ len (string-length string))\n                  0]\n                 [(string-equal?\
    \ (substring string\n                                          (substring (string-ref\
    \ string 0))) \"\")\n                  0]\n                 [else\n          \
    \        (+ 1 (how_many_times (substring string\n                            \
    \                        (substring (string-ref string 0)))))]))))\n", "  (count\
    \ (lambda (x) (equal? (string x) substring)) string))\n", "  (if (empty? string)\n\
    \      0\n      (let ((start (substring string 0)))\n        (loop\n         \
    \  (let ((len (substring string 1)))\n             (if (equal? (substring string\
    \ 1) start)\n                 (add1 (in-range len string start))\n           \
    \      (recur (substring string 0 start) (add1 len)))))))\n", "  (loop for pos\
    \ in (range (length string))\n        for j = (substring length) below pos\n \
    \       when (string=? (substring string pos (- j substring)) substring)\n   \
    \     count j))\n", "  (match-count (match-string string substring))) ;; match-count\
    \ is defined in Racket as\n                                       ,(match string\
    \ substring :case-sensitive true)\n                                       ,(match\
    \ string substring :case-sensitive false))\n", "  (length string))\n", "  (let\
    \ loop ((len (string-length string))\n             (found 0))\n    (if (>= len\
    \ 0)\n        found\n        (let ((i (string-index string substring)))\n    \
    \      (if (>= i 0)\n              (loop (- len i) 1)\n              (loop (-\
    \ len i) 0)))))))\n", "  (count-substrings string substring))\n", "  (cond [(null?\
    \ string) 0]\n        [(eq? (string- (string-ref string 0) substring) (string-length\
    \ (string-ref string 0)))]\n        [else (+ 1 (how_many_times (string-downcase\
    \ string) (substring lowercase)))]))\n", "  (length\n   (remove-if\n    (lambda\
    \ (x)\n      (equal? (string-match substring x) (string-match substring (reverse-string\
    \ x)))) (string-to-list string))))\n", "  (let ((counter (substring (string 1)\
    \ (string 1) 0))\n        (index (substring (string 0) (string 0) 0)))\n    (cond\
    \ ((= index 0)\n           (+ counter 1))\n          ((not (equal? (char string\
    \ index) (string-ref string index))) \n           (+ counter 1))\n          (else\
    \ (substring index (+ index (substring index 1)))))))\n", "  (length \n   (remove-if\
    \ (lambda (x)\n                 (= (substring x) string))\n              (iterate\
    \ string))\n  ))\n", "  (length string))\n", "  (let ((count 0))\n    (if (string?\
    \ substring)\n        (let ((i (string-index string substring)))\n          (if\
    \ (<= i 0)\n              count\n              (set! count (+ count (if (or (=\
    \ i 0) (string-index string 0))\n                                     (string=\
    \ substring (string-tail string))\n                                     (1+ (string=\
    \ substring (string-head string)))))\n                     (string= substring\
    \ (string-tail string))))\n          count)\n      0)))\n", "  (let loop ((s string)\n\
    \             (t substring)\n             (i 0))\n    (cond\n      [(empty? s)\n\
    \       (if (empty? t)\n           i\n           (+ 1 (loop (rest s) t\n     \
    \                 (rest t)\n                      (+ i 1))))]\n      [(equal?\
    \ s (first t))\n       (if (= (length s) (length t))\n           (+ 1 (loop (rest\
    \ s) t\n                      (rest t)\n                      (+ i 1)))]\n   \
    \   [(equal? (first s) (first t))\n       (loop (rest s) t (first t)\n       \
    \      (+ i 1))]\n      [else\n       (loop (rest s) t (first t)\n           \
    \  (+ i 1))]\n      )))\n", "  (length string\n        (string=? substring (car\
    \ string) 0))\n)\n", "  (if (empty? substring)\n      0\n      (let loop ((start\
    \ (position substring string))\n                 (length (length string)))\n \
    \       (cond ((or (= start 0) (= start length) (= length 0)) 0)\n           \
    \   ((eq? start length) (if (eq? string '') 1 (+ 1 (loop (+ start 1) (length string))))\n\
    \                             (loop (+ start 1) (length string))))\n         \
    \     ((and (not (eq? string ''))\n                  (or (= (position substring\
    \ string) 0)\n                       (= (position substring string) start))\n\
    \                  (or (= (position substring string) length)\n              \
    \         (= (position substring string) start))\n                  (= (position\
    \ substring string)\n                     (substring (+ start (length substring))))\n\
    \                  (+ (loop (+ start 1) (length string))\n                   \
    \  (loop (+ start (length substring)) (length string))))\n              (t (loop\
    \ (+ start 1) (length string)))))) ; else recurse\n", "  (length (remove-if (\u03BB\
    \ (c)\n                       (equal? (string-length string) (length (string-width\
    \ c)))\n                       (equal? (substring c) (substring (string-width\
    \ string)))) string))) ;; #lang racket\n", "  (define (string->list string)\n\
    \    (let loop ((index 0)\n               (acc '())\n               (strings '()))\n\
    \      (if (<= index string-len)\n          (let ((c (string->char string index)))\n\
    \            (if (char=? c substring)\n                (loop (+ index 1)\n   \
    \                    (cons (string->string c) acc)\n                       (cons\
    \ c strings))\n                (loop (+ index 1)\n                       (cons\
    \ c acc)\n                       (cons (string->string c) strings)))))\n    (length\
    \ strings)))\n", "  (count-of (lambda (c) (equal? (string-ref string c) substring))\
    \ string))\n", "  (define (go current i)\n    (cond [(null? substring) (cons current\
    \ 0)]\n          [(equal? (substring 0) (string-ref string i))\n           (go\
    \ (cons current 1) (i + 1))]\n          [(equal? (substring 1) (string-ref string\
    \ i))\n           (go (cons current (+ current 1)) (i + 1))]\n          [else\
    \ (go (cons current 0) (i + 1))]))\n  (go null 0))\n", "  (let ([start (in-index\
    \ string substring 0)])\n    (- start (in-index string substring (in-index string\
    \ substring (in-index string substring (in-index string substring (in-index string\
    \ substring (in-index string substring))))))))))\n", "  (count-substrings string\
    \ substring))\n", "  (- 0 (string-length string) (string-length substring) (substring\
    \ (string-seq string 0 string) (substring (string-seq string 0 (string-length\
    \ string)))))\n)\n", "  (cond ((or (char=? substring #\\a) (char=? substring #\\\
    b))\n         (0))\n        ((or (char=? substring #\\A) (char=? substring #\\\
    B))\n         (0))\n        ((char=? substring #\\z)\n         (length (string->list\
    \ string)))\n        ((char=? substring #\\Z)\n         (length (string->list\
    \ string)))\n        ((or (char=? substring #\\a) (char=? substring #\\b))\n \
    \        (+ (length (string->list string)) (length (string->list substring))))\n\
    \        ((or (char=? substring #\\A) (char=? substring #\\B))\n         (+ (length\
    \ (string->list string)) (length (string->list substring))))\n        ((char=?\
    \ substring #\\z)\n         (length (string->list string)))\n        ((char=?\
    \ substring #\\Z)\n         (length (string->list string)))\n        ((or (char=?\
    \ substring #\\a) (char=? substring #\\b))\n         (+ (length (string->list\
    \ string)) (length (string->list substring))))\n        ((or (char=? substring\
    \ #\\A) (char=? substring #\\B))\n         (+ (length (string->list string)) (length\
    \ (string->list substring))))\n        ((char=? substring #\\z)\n         (length\
    \ (string->list string)))\n        ((char=? substring #\\Z)\n         (length\
    \ (string->list string))))\n  ;; If we're here then there's no match\n  (length\
    \ (string->list string)))\n", "  (define (helper string substring count)\n   \
    \ (cond [(null? string) count]\n          [(string=? substring (car string)) (helper\
    \ (cdr string) substring\n                                                 (+\
    \ count 1))]\n          [else (helper (cdr string) substring (+ count 1))]))\n\
    \  (helper string substring 0))\n", "  (cond [(empty? string) 0]\n        [(equal?\
    \ (substring string) (first string)) 1]\n        [else (+ 1 (how_many_times (rest\
    \ string) substring))]))\n", "  (let loop ((count 0)\n             (index 0)\n\
    \             (string string)\n             (substring substring))\n    (cond\n\
    \      [(empty? string) count]\n      [else (loop (+ count 1)\n              \
    \   index\n                 (string\\ (string-ref string index))\n           \
    \      (string\\ (string-ref string index)))]\n      [else\n       (loop (if (string\\\
    \ (string-ref string index)) (+ count 1)\n               count)\n            \
    \ (add1 (string\\ (string-ref string index)))\n             (substring (substring\
    \ index)))]))))\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=racket,scheme,lisp\
    \ |>\nA common way of doing this is to use set-car! and set-cdr!, as follows:\n\
    <code>", "  (count-substrings string substring))\n", "  (define (count chars start)\
    \ (if (< start (length chars)) 0 (+ (count (cdr chars) start))))\n  (count (filter\
    \ (lambda (c)(c = substring)) string) 0))\n", "  (length string))\n", "  (match\
    \ (string-length\n          (string-substring string 0 0)\n          (string-substring\
    \ string 1 0)\n          (string-substring string 1 1)\n          (string-substring\
    \ string 1 2)\n          (string-substring string 1 3)\n          (string-substring\
    \ string 1 4)\n          (string-substring string 1 5)\n          (string-substring\
    \ string 1 6)\n          (string-substring string 1 7)\n          (string-substring\
    \ string 1 8)\n          (string-substring string 1 9)\n          (string-substring\
    \ string 1 10)\n          (string-substring string 1 11)\n          (string-substring\
    \ string 1 12)\n          (string-substring string 1 13)\n          (string-substring\
    \ string 1 14)\n          (string-substring string 1 15)\n          (string-substring\
    \ string 1 16)\n          (string-substring string 1 17)\n          (string-substring\
    \ string 1 18)\n          (string-substring string 1 19)\n          (string-substring\
    \ string 1 20)\n          (string-substring string 1 21)\n          (string-substring\
    \ string 1 22)\n          (string-substring string 1 23)\n          (string-substring\
    \ string 1 24)\n          (string-substring string 1 25)\n          (string-substring\
    \ string 1 26)\n          (string-substring string 1 27)\n          (string-substring\
    \ string 1 28)\n          (string-substring string 1 29)\n          (string-substring\
    \ string 1 30)\n          (string-substring string 1 31)\n          (string-substring\
    \ string 1 32)\n          (string-substring string 1 33)\n          (string-substring\
    \ string 1 34)\n          (string-substring string 1 35)\n          (string-substring\
    \ string 1 36)\n          (string-substring string 1 37)\n          (string-substring\
    \ string 1 38)\n          (string-substring string 1 39)\n          (string-substring\
    \ string 1 40)\n          (string-substring string 1 41)\n          (string-substring\
    \ string 1 42)\n          (string-substring string 1 43)\n          (string-substring\
    \ string 1 44)\n          (string-substring string 1 45)\n          (string-substring\
    \ string 1 46)\n          (string-substring string 1 47)\n          (string-substring\
    \ string 1 48)\n          (string-substring string 1 49)\n          (string-substring\
    \ string 1 50)\n          (string-substring string 1 51)\n          (string-substring\
    \ string ", "  (length\n   (string-match-length\n    (string-compare\n     (string-append\
    \ string substring)\n     (string-append substring string))))\n)\n", "  (length\
    \ (remove-if (\u03BB (char) (equal? (char) substring)) string)))\n", "  (define\
    \ (check-substring substring string index)\n    (cond\n      [(not (equal? substring\
    \ string)) 1]\n      [(eq? (substring string) (string-ref string index)) (+ 1\
    \ (check-substring substring string (incf index)))]\n      [else 0]))\n  (check-substring\
    \ substring string 0))\n", "  (length (count-strings string substring)))\n", " \
    \ (define (helper lst char count)\n    (cond\n      [(empty? lst) (count 0))]\n\
    \      [(char=? (first lst) char) (helper (rest lst) char (+ count 1))]\n    \
    \  [else (helper (rest lst) (first lst) count)]\n    )\n  )\n  (helper string\
    \ substring 0)\n)\n", "  (match string\n    ((empty) (1))\n    ((substring #:c)\
    \ 1)\n    ((substring #:cs #:cs) 2)\n    ((substring #:cs #:css #:c) 2)\n    ((substring\
    \ #:cs #:css #:cs #:cs) 3)\n    ((substring #:cs #:css #:cs #:cs #:cs) 3)\n  \
    \  ((substring #:cs #:css #:cs #:cs #:cs #:cs) 4)\n    ((substring #:cs #:css\
    \ #:cs #:cs #:cs #:cs #:c) 4)\n    ((substring #:cs #:css #:cs #:cs #:cs #:cs\
    \ #:c #:cs) 4)\n    ((substring #:cs #:css #:cs #:cs #:cs #:cs #:c #:cs #:cs)\
    \ 4)\n    ((substring #:cs #:css #:cs #:cs #:cs #:cs #:c #:cs #:cs #:cs) 4)\n\
    \    ((substring #:cs #:css #:cs #:cs #:cs #:cs #:c #:cs #:cs #:cs #:cs) 4)\n\
    \    ((substring #:cs #:css #:cs #:cs #:cs #:cs #:c #:cs #:cs #:cs #:cs #:cs)\
    \ 4)\n    ((substring #:cs #:css #:cs #:cs #:cs #:cs #:c #:cs #:cs #:cs #:cs #:cs\
    \ #:cs) 4)\n    ((substring #:cs #:css #:cs #:cs #:cs #:cs #:c #:cs #:cs #:cs\
    \ #:cs #:cs #:cs) 4)\n    ((substring #:cs #:css #:cs #:cs #:cs #", "  (length\
    \ (remove-if (lambda (x) (equal? (char-after x substring) (char-after x 0))) string)))\n\
    </cell>\n<cell>\n#lang racket\n", "  (let loop ((count 0) (string string))\n \
    \   (if (= count (string-length string))\n        count\n        (loop (+ count\
    \ (substring string)) (string-append string substring)))))\n", "  (let ((count\
    \ 0))\n    (define (helper str substring)\n      (cond\n        ((null? str) count)\n\
    \        ((eq? (car str) substring) (helper (cdr str) (substring substring)))\n\
    \        (else (helper (cdr str) substring)))\n      (helper (cdr str) substring)\n\
    \    )\n    (helper string substring)\n    count))\n", "  (length string))\n",
  "  (let ([l (string-length string)])\n    (cond\n      [(empty? string) 0]\n   \
    \   [(equal? substring string) 1]\n      [(equal? (substring string) (string-ref\
    \ string 0)) 1]\n      [(equal? (substring string) (string-ref string l)) (+ 1\
    \ (how_many_times (string-append string substring) (substring string)))]\n   \
    \   [else (+ (how_many_times (string-append string substring) (string-ref string\
    \ 0)) 1)])))\n", "  (cond\n    [(empty? string) 0]\n    [(equal? (first string)\
    \ substring) 1]\n    [else (+ (how_many_times (rest string) substring))]))\n",
  "  (length (filter (lambda (s) (string=? (append string s) substring))\n       \
    \             (all-strings))))\n", "  (define (count-overlapping index string\
    \ substring result)\n    (cond\n      [(eq? index (string-length string)) (+ result\
    \ 0)]\n      [(eq? (string-ref string index) substring) (count-overlapping (incf\
    \ index) string substring result)]\n      [(< (string-length string) (- index\
    \ 1)) result]\n      [(> index 0) (count-overlapping (incf index) string substring\
    \ result)]\n      [else (count-overlapping (incf index) string substring (+ 1\
    \ (substring (- index 1))))]\n    )\n  )\n  (count-overlapping 0 (string substring)\
    \ 0 0))\n", "  (count-substrings string substring))\n", "  (cond [(empty? string)\
    \ 0]\n        [(equal? substring (car string)) (+ 1 (how_many_times (cdr string)\
    \ substring))]\n        [else (+ 1 (how_many_times (cdr string) substring))]))\n",
  "  (cond ((string-equal \"\" substring) 0)\n        ((string-equal substring \"\"\
    ) 1)\n        ((string=? (string-ref string 0) substring) (+ 1 (how_many_times\
    \ (string-ref string 1) substring)))\n        (else (how_many_times (string-ref\
    \ string 1) substring))))\n", "  (let ((i 0))\n    (loop while string\n      \
    \    for substring\n          for i from 0\n          count i)\n    i))\n", " \
    \ (let ([count 0])\n    (loop [start 0\n           end string-length\n       \
    \    string string\n           substring substring\n           i 0]\n      (cond\
    \ [(or (< i end) (eq? i string-length)) (add1 count)]\n            [(or (eq? i\
    \ (string-length substring)) (eq? end (string-length string))) (add1 count)]\n\
    \            [(eq? (string-ref string i) (string-ref substring 0)) (incf i)]\n\
    \            [else (incf i)])))\n  count)\n", "  (cond\n    [(empty? string) 0]\n\
    \    [(equal? (char-set-ref string 0) substring) 1]\n    [else\n     (+ 1 (how_many_times\
    \ (char-set-tail string) substring))]))\n", "  (local ((define (count-overlapping\
    \ start end)\n            (if (<= start end)\n                (+ 1 (count-overlapping\
    \ start end))\n                0))\n          (define (next-start start end)\n\
    \            (cond\n              [(<= start end)\n               (begin (set!\
    \ start (+ start (length substring))) (set! end (- end (length substring)))\n\
    \                     (begin (set! start (+ start (length substring))) (set! end\
    \ (- end (length substring)))\n                         (begin (set! start (+\
    \ start (length substring))) (set! end (- end (length substring)))\n         \
    \                  (begin (set! start (+ start (length substring))) (set! end\
    \ (- end (length substring)))\n                           end))\n            \
    \   (begin (set! start (+ start (length substring))) (set! end (- end (length\
    \ substring)))\n                     (begin (set! start (+ start (length substring)))\
    \ (set! end (- end (length substring)))\n                         (begin (set!\
    \ start (+ start (length substring))) (set! end (- end (length substring)))\n\
    \                         (begin (set! start (+ start (length substring))) (set!\
    \ end (- end (length substring)))\n                         (begin (set! start\
    \ (+ start (length substring))) (set! end (- end (length substring)))\n      \
    \                     (begin (set! start (+ start (length substring))) (set! end\
    \ (- end (length substring)))\n                           end))\n            \
    \   (begin (set! start (+ start (length substring))) (set! end (- end (length\
    \ substring)))\n                     (begin (set! start (+ start (length substring)))\
    \ (set! end (- end (length substring)))\n                         (begin (set!\
    \ start (+ start (length substring))) (set! end (- end (length substring)))\n\
    \                         (begin (set! start (+ start (length substring))) (set!\
    \ end (- end (length substring)))\n                         (begin (set! start\
    \ (+ start (length substring))) (set! end (- end (length substring)))\n      \
    \                     (begin (set! start (+ start (length substring))) (set! end\
    \ (- end (length substring)))\n                           end))\n            \
    \   (begin (set! start (+ start (length substring))) (set! end (- end (length\
    \ substring)))\n                     (begin (set! start (+ start ", "  (string-length\
    \ (string-index string substring)))\n", "  (define (match-pattern s p)\n    (if\
    \ (char=? s p)\n        (+ 1 (match-pattern s (cdr p)))\n        (match-pattern\
    \ s (cdr p))))\n  (match-pattern string substring))\n", "  (if (string-empty?\
    \ string)\n      0\n      (let ((found (find-index (lambda (c) (string-equal?\
    \ c substring)) string)))\n        (if (>= found 0)\n            (add1 found)\n\
    \            (add1 (how_many_times (substring string) substring)))))\n", "  (string-match\
    \ (lambda (s) (string-match s substring)) string))\n", "  (match substring\n \
    \   [()     _]\n    [(sub) 1]\n    [else   (+ 1 (how_many_times (string-tail-char\
    \ string sub) substring))]))\n", "  (cond [(empty? string) 0]\n        [(equal?\
    \ (first string) substring) (+ 1 (how_many_times (rest string) substring))]\n\
    \        [else (+ 1 (how_many_times (rest string) substring))]))\n", "  (cond\
    \ ((string= string \"\") 0)\n        ((string= string substring) 1)\n        (else\
    \ (+ (count-overlapping-characters string substring) (how_many_times string (substring\
    \ string))))))\n", "  (cond [(empty? string) 0]\n        [(equal? (substring string)\
    \ '') #f 0]\n        [else (+ 1 (how_many_times (rest string) (substring string)))]))\n",
  "  (length (filter (lambda (c) (string=? c substring)) string)))\n</code>\n<|/ a\
    \ tags=scheme,string,racket dscore=3 |>\n<| a dscore=2 |>\nThis can also be done\
    \ without string->list and without map\n<code>", "  (if (equal? string \"\")\n\
    \      0\n      (substring (index! string substring))))\n", "  (let ((count 0))\n\
    \    (loop for i from 0 below string-length(string)\n          for char from 0\n\
    \          below (string->length (string->substring string i i))\n          for\
    \ j from 0\n          below (string-length (string->substring string i j))\n \
    \         when (char=? substring (string->char string j j)) collect j\n      \
    \    finally (set! count (+ count j)))))\n", "  (let ((count 0))\n    (for ((i\
    \ (length string))\n           ((j (length substring)))\n           ((match #[(=\
    \ (substring i) (car substring) (substring j))\n                      (= (substring\
    \ i) (cadr substring) (substring j)\n                      (= (substring i) (caddr\
    \ substring) (substring j)\n                      (= (substring i) (car substring)\
    \ (cadr substring)\n                      (= (substring i) (cadr substring) (caddr\
    \ substring)\n                      (= (substring i) (car substring) (cadr substring)\n\
    \                      (= (substring i) (caddr substring) (caddr substring)\n\
    \                      (= (substring i) (car substring) (caddr substring)\n  \
    \                    (= (substring i) (cadr substring) (caddr substring))]))])))\n\
    \      (incf count 1))\n    count))\n", "  (length (string-match (string-replace-all\
    \ string substring '())) 2))\n</code>\n<|/ a tags=string,ocaml,racket,scheme dscore=3\
    \ |>\n<| c |>\nI added an example of a solution using `string-match` and `string-replace-all`\
    \ with the code I ended up using.\n<|/ c |>\n<| a |>\nOCaml solution\n<code>\n\
    let rec countOccurences string substring =\n  if String.length substring > String.length\
    \ string then\n    (substring :: string, (String.length substring) :: (String.length\
    \ string))\n  else\n    let (substring1, (length1)) = countOccurences string substring\
    \ in\n    let (substring2, (length2)) = countOccurences string substring in\n\
    \    (substring1 :: substring2, length1 + length2)\n\nlet rec countOccurences\
    \ string substring =\n  if String.length substring > String.length string then\n\
    \    (substring :: string, (String.length substring) :: (String.length string))\n\
    \  else\n    let substring = String.substring string 1 in\n    countOccurences\
    \ string substring +\n      countOccurences (String.substring string 2) substring\n\
    \nlet rec countOccurences string substring =\n  if String.length substring > String.length\
    \ string then\n    (substring :: string, (String.length substring) :: (String.length\
    \ string))\n  else\n    let substring = String.substring string 1 in\n    countOccurences\
    \ string substring +\n      countOccurences string substring +\n      countOccurences\
    \ (String.substring string 2) substring\n</code>\n<|/ a tags=string,ocaml,racket,scheme\
    \ dscore=2 |>\n<| a tags=string,ocaml,racket,scheme dscore=2 |>\nI came up with\
    \ this solution for Racket (using \"string-match\" from \"racket/string\"):\n\
    <code>\n#lang racket\n", "  (length string))\n", "  (cond\n    [(empty? substring)\
    \ 0]\n    [(equal? (string-ref string 0) substring) 1]\n    [else (+ (how_many_times\
    \ (string-ref string 1) substring) (how_many_times (string-ref string 2) substring))]))\n",
  "  (define (helper-count substring string index)\n    (cond\n      [(empty? string)\
    \ (add1 index)\n       (helper-count substring (rest string) (sub1 index) (add1\
    \ index))\n       ])\n    (cond\n      [(equal? string substring) (add1 index)\n\
    \       (helper-count substring (rest string) (sub1 index) (add1 index))\n   \
    \    ]\n      [(substring (string-index string index))\n       (helper-count substring\
    \ (rest string) (sub1 index) index)\n       ]\n      [else (add1 index)\n    \
    \   (helper-count substring (rest string) (sub1 index) (add1 index))\n       ]))\n\
    \  (helper-count substring string 0))\n", "  (/ (string-length string)\n     (string-length\
    \ substring)))\n", "  (count-substring-occurrences string substring))\n", "  (let\
    \ ([start (position-of? string substring)]\n        [end (+ start (length substring))])\n\
    \    (if (< start end)\n        (1+ \n         (count-overlaps-start (subseq string\
    \ start end)\n                                 substring))\n        0)))\n", " \
    \ (cond\n    [(empty? string) 0]\n    [(eq? (char-alphabetic? (car string)) substring)\
    \ (+ (char-alphabetic? (car string)) (how_many_times (cdr string) (concat substring\
    \ (car string))))]\n    [else (how_many_times (cdr string) (concat substring (car\
    \ string)))]))\n", "  (cond\n    [(string=? string substring) (length string)]\n\
    \    [else 0]))\n", "  (cond\n    [(empty? substring) 0]\n    [(equal? (substring\
    \ (first string))\n               (substring (first substring)))\n     (add1 (how_many_times\
    \ (rest string) substring))\n     ])\n  )\n", "  (if (string-length string)\n\
    \      (cond\n        ((equal? substring \"\")\n         (string-length string))\n\
    \        (else (string-length-including-equals substring string)))))\n", "  (length\
    \ string))\n", "  (length\n   (remove-if (lambda (c)\n              (and (char=?\
    \ c substring) (char=? (next-char) c)))\n            (string->list string))))\n\
    </code>\nEDIT 4:\nTo find how many characters are in the original string, just\
    \ use length\n<code>", "  (define (string-length string) (length string))\n  (define\
    \ (pos-of-substring index string) (substring index string))\n  (define (match-length\
    \ start-index end-index)\n    (- end-index start-index))\n  (define (find-length\
    \ start-index end-index)\n    (cond [(< start-index end-index) (match-length (+\
    \ start-index 1) end-index)]\n          [(> start-index end-index) (match-length\
    \ start-index (+ end-index 1))]))\n  (find-length (string-length string)\n   \
    \           (position (string-index string substring) string))\n  )\n", "  (let\
    \ ((count 0))\n    (if (string-empty? substring)\n        count\n        (loop\n\
    \           (set! count (add1 (string->number (substring 0))))\n           (if\
    \ (= (number->string (number->integer count)) 0)\n               count\n     \
    \          (loop\n                  (set! count (add1 (string->number (substring\
    \ 1))))\n                  (if (= (number->string (number->integer count)) 0)\n\
    \                     count\n                     (loop\n                    \
    \    (set! count (add1 (string->number (substring 2))))\n                    \
    \    (if (= (number->string (number->integer count)) 0)\n                    \
    \       count\n                           (loop\n                            \
    \  (set! count (add1 (string->number (substring 3))))\n                      \
    \        (if (= (number->string (number->integer count)) 0)\n                \
    \                 count\n                                 (return count)))))\n\
    \                  (if (= (number->string (number->integer count)) 0)\n      \
    \               count\n                     (loop\n                        (set!\
    \ count (add1 (string->number (substring 4))))\n                        (if (=\
    \ (number->string (number->integer count)) 0)\n                           count\n\
    \                           (return count)))))\n                  (if (= (number->string\
    \ (number->integer count)) 0)\n                     count\n                  \
    \   (return count)))))\n      (return count))))\n", "  (length (remove-if (lambda\
    \ (x) (eq? x substring)) (string-chars string))))\n", "  (count\n   (lambda (ch\
    \ i j)\n     (or (char=? ch substring)\n         (or (char=? (char-after ch i)\
    \ substring)\n             (char=? (char-after ch j) substring))))\n   string\
    \ 0 string))\n", "  (- 0 (string-length string) (string-length substring) (string-count\
    \ string substring)))\n", "  (cond [(empty? string) 0]\n        [(string-equal?\
    \ string substring) 1]\n        [else (+ (how_many_times (cdr string) substring)\
    \ 1)]))\n", "  (cond\n    [(empty? string) (length substring)\n     (= 0 (string-length\
    \ string) (string-length substring))]\n    [else (+ 1 (how_many_times (substring\
    \ string) (substring string)))]))\n", "  (length (filter (lambda (c) (equal? c\
    \ substring)) string)))\n", "  (define (how_many pos sub)\n    (cond\n      [(<\
    \ pos length) 0]\n      [else (cond\n               [(equal? (char string pos)\
    \ (char sub)) (+ pos (1- (length sub)))]\n               [else (how_many (+ pos\
    \ 1) sub)])]))\n  (how_many 0 substring))\n", "  (let loop ((found 0))\n    (cond\n\
    \      ((null? substring) found)\n      ((char=? (first substring) (string-char-code\
    \ string)) (loop (+ found 1)))\n      (else (loop (+ found (length substring)))))))\n",
  "  (cond\n    [(empty? string) 0]\n    [(string-equal? substring (resto string))\
    \ 1]\n    [else\n     (+ (count (resto string) substring) (how_many_times (resto\
    \ string) substring))]))\n", "  (length (remove-if (lambda (x) (= (length x) (string-length\
    \ substring))) (string->list string))))\n", "  (cond\n    [(empty? string) 0]\n\
    \    [(equal? (first string) substring) 1]\n    [else (+ 1 (how_many_times (rest\
    \ string) substring))]))\n", "  (count (subseq-count string substring)))\n", " \
    \ (let loop ((start-pos 0)\n             (end-pos string-length substring))\n\
    \    (cond ((or (>= start-pos end-pos)\n              (string-equal? string \"\
    \" \"#t\"))\n           0)\n          ((string-equal? string \"\" \"#t\")\n  \
    \         1)\n          ((equal? start-pos end-pos)\n           (string-equal?\
    \ string substring \"#t\"))\n          ((equal? (string-at (+ start-pos 1) substring)\
    \ \"#t\")\n           (loop (+ 1 start-pos)\n                 (+ 1 end-pos)))\n\
    \          (else\n           (loop (+ 1 start-pos)\n                 (+ 1 end-pos))))))\n",
  "  (cond\n    [(empty? string) 0]\n    [else (+ 1 (string-count string substring))]))\n",
  "  (define start (find_first_index string substring))\n  (define end (find_last_index\
    \ string substring))\n  (define length (- end start))\n  (+ (- length substring)\
    \ (- substring string start)))", "  (count\n   (lambda ()\n     (define start\
    \ 0)\n     (define end 0)\n     (define i 0)\n     (while true\n       (cond\n\
    \        ((null? string) #f)\n        ((string= (string-ref string end) substring)\
    \ #t)\n        ((null? (string= (string-ref string start) substring) #f)\n   \
    \      (begin (set! start (+ start 1)) (set! end (+ end 1)))\n         (set! i\
    \ (+ i 1))\n         (begin (set! start (+ start 1)) (set! end (+ end 1)))))\n\
    \       (set! i (+ i 1))\n       (set! start (+ start 1))\n       (set! end (+\
    \ end 1))\n       (when (< start end)\n         (return i))))\n   (lambda ()\n\
    \     (define start 0)\n     (define end 0)\n     (define i 0))\n", "  (if (string-empty?\
    \ string)\n      0\n      (+ (string-indexof string substring)\n         (how_many_times\
    \ (string-tail string) substring))))\n", "  (if (null? string) 0\n      (if (string=?\
    \ substring (string-ref string 0) 0) 1\n          (+ (how_many_times (string-ref\
    \ string 1) substring))))) ;; #lang racket\n", "  (let ([count 0])\n    (for [c\
    \ string]\n      (if (string=? c substring)\n          (begin\n            (set!\
    \ count (add1 count))\n            (set! count (- count 1))\n            count)\n\
    \        count)))\n", "  (count (lambda (x) (equal? x substring)) string))\n",
  "  (cond ((null? string)\n         0)\n        ((string-match-p substring string)\
    \ 1)\n        (else (+ 1 (how_many_times (rest string) substring))))\n)\n</code>\n\
    <|/ a tags=racket,substring |>\n<| c |>\nI didn't know about string-match-p! That\
    \ is a very useful function.\n<|/ c |>\n<| c |>\nI like this solution the best.\
    \ It doesn't require an extra package and uses some built-in functions. But I\
    \ wonder why `string-match` doesn't have this behavior?\n<|/ c |>\n<| c |>\n`string-match`\
    \ actually has a behavior as described in the question. It counts overlaping matches.\n\
    <|/ c |>\n<| a |>\nIn Racket you can use the regexp function. It allows you to\
    \ specify a regex pattern and use groups to capture text matches.\n<|/ a tags=racket,substring\
    \ dscore=1 |>\n<| c |>\nAnd this works perfectly well. Thanks!\n<|/ c |>\n<| a\
    \ tags=racket,substring |>\nFor an interesting answer I like Jonathan's solution\
    \ using string-match-p (which isn't really a built-in but a standard Racket package):\n\
    <code>", "  (substring (length string) 0))\n", "  (cond\n    [(empty? string)\
    \ 0]\n    [(empty? substring) 0]\n    [else (+ (substring (substring 0 1) (substring\
    \ 1 0))\n            (how_many_times (substring 1 0) substring))]))\n", "  (define\
    \ pos (string-index-of string substring))\n  (define (check-range start stop result)\n\
    \    (cond ((or (< start 0) (>= stop 0)) result)\n          (else (check-range\
    \ (+ start 1) stop result))))\n  (check-range pos 0 (string-length string))\n\
    )\n", "  (cond\n    [(empty? string) 0]\n    [(eq? (string-ref string 0) substring)\
    \ 1]\n    [else (+ 0 (how_many_times (string-tail string) (substring string)))]))\n",
  "  (cond [(empty? string) 0]\n        [(equal? (car string) substring) 1]\n    \
    \    [else (+ (how_many_times string substring) (+ 1 (how_many_times (cdr string)\
    \ substring)))]))\n", "  (length string)\n  (if (empty? string)\n      0\n   \
    \   (if (equal? string substring)\n          1\n          (+ (how_many_times (substring\
    \ string) substring) 1))))\n</code>\n<|/ a tags=racket,scheme,functional-programming\
    \ dscore=3 |>\n<| a |>\nIf you want a solution that works for arbitrary length\
    \ substring, you can use the following code:\n<code>\n#lang racket\n", "  (length\
    \ (remove-if\n           (lambda (e) (equal e (substring e)))\n           (remove-if\
    \ (lambda (e) (equal e (substring e)))\n                       (remove-if (lambda\
    \ (e) (equal e (substring e)))\n                                   (remove-if\
    \ (lambda (e) (equal e (substring e)))\n                                     \
    \          (remove-if (lambda (e) (equal e (substring e)))\n                 \
    \                                      string))))))\n", '  (- 0 (string-length
    string) (string-length substring) (string-length substring)))', "  (define (count-overlap\
    \ start end)\n    (if (zero? start)\n        (if (zero? end)\n            0\n\
    \            (reverse (+ 1 (count-overlap (- end 1) (length string))))\n     \
    \     (reverse (+ 1 (count-overlap (- start 1) (length string))))\n        (reverse\
    \ (+ 1 (count-overlap (- end 1) start))))\n      (if (zero? end)\n        (reverse\
    \ (+ 1 (count-overlap start (length string))))\n      (if (string-equal? (substring\
    \ string start) (substring string end))\n          (count-overlap start end)\n\
    \        (reverse (+ 1 (count-overlap start (length string)))))))\n  (count-overlap\
    \ 0 (length string)))\n", "  (cond\n    [(empty? string)     0]\n    [(empty?\
    \ substring)   0]\n    [else\n     (let ((c (string=? (first string) substring)))\n\
    \       (if (equal? c true)\n           (+ 1 (how_many_times (rest string) (first\
    \ substring)))\n           (+ (how_many_times (rest string) substring))\n    \
    \       (+ 1 (how_many_times (rest string) (first substring))))]))\n", "  (/ (string->length\
    \ (substring string)) (string->length string)))\n", "  (if (string? string) \n\
    \      (let ((count 0))\n        (for ([i (in-range (length string) exclusive-end)]\n\
    \              [ch (in-range (length substring) exclusive-end)]\n            \
    \  [count-same (= (substring string i) (substring substring ch))])\n         \
    \ (set! count (add1 count) count-same)))\n      (error \"Substring is not a string\"\
    ))))\n", "  (cond ((null? string) 0)\n        ((equal? (substring (car string))\
    \ (car substring)) (+ 1 (how_many_times (cdr string) (cons (car substring) (cdr\
    \ substring)))))\n        (else (how_many_times (cdr string) (cons (car substring)\
    \ (cdr substring))))))\n", "  (match string\n    [(_ (_)) 0]\n    [(_ (_ tail))\
    \ (+ (how_many_times (rest string) substring) (1+ how_many_times tail))]\n   \
    \ [(_ (_ tail rest)) (+ (how_many_times rest substring) (1+ how_many_times tail))]\n\
    \    [(_ _) 0]))\n</code>\n<|/ a |>\n<| c |>\nYour solution only works for strings\
    \ with the same number of letters. Try it with 'a' and 'aa'.\n<|/ c |>\n<| c |>\n\
    , fixed my answer based on your feedback, thank you.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but you seem to assume that \"aa\" is repeated twice. Try it\
    \ with \"aaa\" and \"aa\".\n<|/ c |>\n<| c |>\nThanks for pointing that out to\
    \ me, I've updated my answer to reflect that.\n<|/ c |>\n<| a dscore=1 |>\nThis\
    \ solution uses only built-in functions and recursive functions.\n<code>", " \
    \ (cond [(empty? string) #f]\n        [else (+ (count string substring 0)\n  \
    \               (how_many_times (rest string) substring))]))\n", "  (cond [(empty?\
    \ substring) #f]\n        [(equal? (char substring string) ?a) 1]\n        [else\
    \ (+ 1 (how_many_times string (rest substring)))]))\n", "  (+ (string-length (string-substring\
    \ string 0 substring)) (how_many_times (string-substring string 1 substring) substring)))\n",
  "  (define (how_many current substring)\n    (cond\n      [(or (string=? substring\
    \ current) (string=? substring (rest current))) (+ current 1)]\n      [else current]))\n\
    \  (let ((count 0))\n    (loop for i from 0 to (length string) do\n          (if\
    \ (or (>= i (length string))\n                  (string=? substring (string-ref\
    \ string i))\n                  (string=? substring (rest string)))\n        \
    \      count\n              (set! count (how_many (substring string i) substring))))\n\
    \    count))\n", "  (let loop ((count 0) (string-length string) (remainder string)\
    \ (count 0))\n    (cond\n      [(= 0 remainder) count]\n      [(> count (string-length\
    \ substring)) (if (string=? substring remainder) (loop (add1 count) (truncate\
    \ (string-length substring) 1) remainder)\n                                  \
    \         (if (string=? remainder (substring count)) (loop (add1 count) (string-length\
    \ substring) (substring count)) count))\n      (else (loop (add1 count) (truncate\
    \ (string-length substring) 1) (substring count))) (add1 count))]\n      (else\
    \ (loop (add1 count) (truncate (string-length substring) 1) remainder)))\n  count)\n\
    </cell>\n<text>\nExercise 5\nGiven the string \"Burning 'em, if you must\", find\
    \ the number of occurrences of \"Burning\" in the string.\n\nAs a reminder, the\
    \ count starts at 0.\n\n\"Burning\" starts at position 9 in \"Burning 'em, if\
    \ you must\", and 9 occurs three times in \"Burning\", so the function should\
    \ return 3.\n\nNotes:\n\nOnly considering the characters up to but not including\
    \ the first occurrence of the substring.\n\nTo find occurrences of multiple occurrences\
    \ of the substring, consider using \"Burning 'em, if you must\".indexOf(\"Burning\"\
    ).\n\n\n</text>\n<code language=dyalog-kernel>", "  (cond\n    [(empty? string)\
    \ 0]\n    [else\n     (define index (string-index string substring))\n     (cond\n\
    \       [(empty? index) 0]\n       [else (+ 1 (how_many_times (string->substring\
    \ string index) substring))]))]))\n", "  (loop for i below string.length while\
    \ (char=? string substring i))\n  (- i)))\n", "  (+ (string-length string) (apply\
    \ + (map (lambda (s) (string-index s substring)) (string-split string)))))\n",
  "  (let loop ((i 0)\n             (count 0))\n    (cond ((eq? i length) (+ count\
    \ 1))\n          ((eqv? (char-code string) (char-code (car substring))) loop)\n\
    \          ((char-code (substring i i)) (loop (+ i 1)\n                      \
    \                   (+ count 1)))\n          ((char-code (substring i i))\n  \
    \         (loop (+ i 1)\n                 (add1 count)))\n          ((> i 0)\n\
    \           (loop (substring i i)\n                 (add1 count))))))", "  (count-substrings-in-string\
    \ string substring))\n", "  (define (find_counts string substring)\n    (if (null?\
    \ string)\n        0\n        (if (equal? substring (car string))\n          \
    \  (+ 1 (find_counts (cdr string) substring))\n            (+ 1 (find_counts (cdr\
    \ string) (concat substring (car string)))))))\n  (find_counts string substring))\n",
  "  (cond\n    ((null? string) 0)\n    ((= 0 (string-length string)) 0)\n    ((equal?\
    \ (substring string) (string-ref string 0)) 0)\n    (else\n     (+ 1 (how_many_times\
    \ (string-downcase string) (substring string))))))\n", "  (if (null? string) 0\n\
    \      (let ((chars (string->list string)))\n        (if (string-contains? chars\
    \ substring)\n            (+ 1 (how_many_times (string->string (chars (string-index\
    \ chars substring))) substring)))))\n", "  (count-substrings string substring))\n",
  "  (let* ((result (memorize 0 substring string 0))\n         (counting (memorize\
    \ 0 substring string 1)))\n    (if (not result)\n        (add counting 1)\n  \
    \      result)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
