name: HumanEval_19_sort_numbers
language: rkt
prompt: "#lang racket\n\n;; Input is a space-delimited string of numberals from 'zero'\
  \ to 'nine'.\n;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
  \ 'six', 'seven', 'eight' and 'nine'.\n;; Return the string with numbers sorted\
  \ from smallest to largest\n;; >>> sort_numbers('three one five')\n;; 'one three\
  \ five'\n(define (sort_numbers numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"three\"\
  ) \"three\")\n    (check-equal? (candidate \"three five nine\") \"three five nine\"\
  )\n    (check-equal? (candidate \"five zero four seven nine eight\") \"zero four\
  \ five seven eight nine\")\n    (check-equal? (candidate \"six five four three two\
  \ one zero\") \"zero one two three four five six\")\n))\n\n(test-humaneval)"
completions: ["  (let ((nums '()))\n    (loop for word in (split numbers #\" \")\n\
    \          for val in (number-to-num word)\n          while (not (member val nums))\n\
    \          append (cons val nums))))\n", "  (cond [(empty? numbers) \"\"]\n  \
    \      [else (append (sort_numbers (substring numbers 0 (length numbers))) \n\
    \                    (string (car numbers) \" \" \n                          \
    \   (sort_numbers (substring numbers (+ 1 length) length))))]))\n", "  (let ((sorted\
    \ (make-array (length numbers) (quote number))))\n    (loop [[i 0] [j 0] res []]\n\
    \      (if (zero? i)\n          (set! sorted[j] (first numbers))\n          (set!\
    \ sorted[j] (first sorted))\n          (set! sorted[i] (rest sorted[j]))\n   \
    \       (set! sorted[i] (cons sorted[i] sorted))\n          (set! res (append\
    \ sorted (list res)))\n          (set! i 1)\n          (set! j 1)\n          (recur\
    \ (+ i 1) (+ j 1) res))\n      sorted)))\n", "  (cond\n    [(empty? numbers) 'zero']\n\
    \    [(equal? (first numbers) 'zero) 'zero]\n    [else (append (sort_numbers (rest\
    \ numbers)) (list 'one (first numbers))]))))\n", "  (cond\n    [(string-length\
    \ numbers) (string-append (sort (list numbers) < ) \"\")]\n    [else \"\"]))\n",
  "  (let loop ((nums '()))\n    (if (empty? numbers)\n        (list nums)\n     \
    \   (begin\n          (let ((num (first numbers)))\n            (set! nums (append\
    \ num (sort_numbers (rest numbers))))\n            (reverse nums)))))\n", "  (let\
    \ ([numbers (string->symbols numbers)])\n    (check-type numbers symbol-list)\n\
    \    (sort numbers\n          #(< (symbol-value %1 %2) (symbol-value %1 %2)) ;\
    \ order numbers\n          'lt)))\n", "  (if (empty? numbers)\n      '()\n   \
    \   (let ((head (first numbers))\n            (tail (sort_numbers (rest numbers))))\n\
    \        (cons (if (= 'zero head) 'zero head)\n               (sort_numbers (cons\
    \ head tail)))))) \n", "  (cond\n    ((numbers? (car numbers)) (sort_numbers (cdr\
    \ numbers)))\n    (else\n     (string-append (car numbers) (sort_numbers (cdr\
    \ numbers))))))\n", "  (cond [(empty? numbers)\n         '']\n        [(number?\
    \ (first numbers))\n         (cons (first numbers)\n              (sort_numbers\
    \ (rest numbers)))]\n        [else\n         (cons (first numbers)\n         \
    \     (sort_numbers (rest numbers))\n              (sort_numbers (rest numbers)))))])\n",
  "  (if (null? numbers)\n      '()\n      (append (sort (map number->symbol (string-split\
    \ (substring numbers (string-length numbers))))\n                   <)\n     \
    \          (sort_numbers substring (numbers (string-length numbers) 1)))))\n",
  "  (cond\n    [(empty? numbers) '']\n    [(equal? (car numbers) 'zero) 'zero]\n\
    \    [(equal? (car numbers) 'one) 'one]\n    [(equal? (car numbers) 'two) 'two]\n\
    \    [(equal? (car numbers) 'three) 'three]\n    [(equal? (car numbers) 'four)\
    \ 'four]\n    [(equal? (car numbers) 'five) 'five]\n    [(equal? (car numbers)\
    \ 'six) 'six]\n    [(equal? (car numbers) 'seven) 'seven]\n    [(equal? (car numbers)\
    \ 'eight) 'eight]\n    [(equal? (car numbers) 'nine) 'nine]\n    [else (cons (car\
    \ numbers) (sort_numbers (cdr numbers)))]))\n", "  (if (empty? numbers)\n    \
    \  '(empty)\n      (cons (first numbers)\n            (sort_numbers (subseq numbers\
    \ 1)))))\n", "  (if (null? numbers)\n      '()\n      (append (sort_numbers (substring\
    \ numbers 0 3))\n              (sort_numbers (substring numbers 3 6))\n      \
    \        (sort_numbers (substring numbers 6 9))))\n</code>\n<|/ a tags=scheme\
    \ |>\n<| a dscore=0 |>\nHere's a functional approach using Racket's built-in sort:\n\
    <code>", "  (define (to-integer n)\n    (if (number? n)\n        (modulo n 10)\n\
    \        n))\n  (let loop ((ns (string->list numbers)))\n    (cond ((null? ns)\
    \ '())\n          ((= (length ns) 1) (cons (to-integer (car ns)) '()))\n     \
    \     (else (loop (cdr ns))))))\n", "  (cond\n    [(empty? numbers) '']\n    [(=\
    \ 'nine? first) numbers]\n    [(empty? (rest numbers)) numbers]\n    [(empty?\
    \ (rest (rest numbers)))\n     (sort_numbers (sort_numbers (rest (rest numbers))))]\n\
    \    [else\n     (cons (sort_numbers (rest (rest numbers))) (sort_numbers (rest\
    \ (rest numbers))))]\n    [else (sort_numbers (rest numbers))]\n  )\n)\n", " \
    \ (define (swap number1 number2)\n    (cond [(< number1 number2) (list number1\
    \ number2)]\n          [(> number1 number2) (list number2 number1)]\n        \
    \  [(= number1 number2) (list number1 number2)]\n          [else (list number1\
    \ number2)]))\n  (define (split number)\n    (cond [(< number 'nine) (list 'zero\
    \ number)]\n          [(> number 'nine) (list 'nine 'zero)]\n          [else 'one\
    \ number 'two number 'three 'four 'five 'six 'seven 'eight 'nine]))\n  (define\
    \ (insert number)\n    (cond [(< number 'nine) (list number)]\n          [(> number\
    \ 'nine) (list 'nine number)])\n  (define (reduce left right)\n    (cond [(< left\
    \ 'nine) (cons 'nine right)]\n          [(> left 'nine) (cons left (reduce 'nine\
    \ right))]))\n  (reduce (reduce 'nine 'zero) (cons 'nine (cons 'nine 'zero)))\n\
    \  (let ([numbers (split-with #(> % 'nine) numbers)])\n    (reverse (map #(reduce\
    \ '(%) '(zero)) numbers))))\n", "  (define (sort-helper lst number)\n    (cond\n\
    \      [(number= number 'zero) (set! lst lst (list 'zero))]\n      [(number= number\
    \ 'one) (set! lst lst (list 'one))]\n      [(number= number 'two) (set! lst lst\
    \ (list 'two))]\n      [(number= number 'three) (set! lst lst (list 'three))]\n\
    \      [(number= number 'four) (set! lst lst (list 'four))]\n      [(number= number\
    \ 'five) (set! lst lst (list 'five))]\n      [(number= number 'six) (set! lst\
    \ lst (list 'six))]\n      [(number= number 'seven) (set! lst lst (list 'seven))]\n\
    \      [(number= number 'eight) (set! lst lst (list 'eight))]\n      [(number=\
    \ number 'nine) (set! lst lst (list 'nine))]\n      [else (set! lst (append lst\
    \ number))]))\n  (let ([lst '(())])\n    (sort-helper\n     (sort-helper lst 'zero)\n\
    \     (sort-helper lst 'one)\n     (sort-helper lst 'two)\n     (sort-helper lst\
    \ 'three)\n     (sort-helper lst 'four)\n     (sort-helper lst 'five)\n     (sort-helper\
    \ lst 'six)\n     (sort-helper lst 'seven)\n     (sort-helper lst 'eight)\n  \
    \   (sort-helper lst 'nine)\n     numbers)))\n", "  (cond\n    [(empty? numbers)\
    \ empty]\n    [(not (number? (first numbers))) empty]\n    [else (cons (first\
    \ numbers)\n              (sort_numbers (rest numbers)))]))\n", "  (sort-by (lambda\
    \ (num)\n            (case num\n              [(zero)  'one]\n              [(one)\
    \   'two]\n              [(two)   'three]\n              [(three) 'four]\n   \
    \           [(four)  'five]\n              [(five)  'six]\n              [(six)\
    \   'seven]\n              [(seven) 'eight]\n              [(eight)  'nine]\n\
    \              [(number)  'zero])))\n  numbers)\n</code>\n<|/ a tags=scheme,functional-programming\
    \ dscore=1 |>\n<| c |>\nThis is a beautiful solution, but I'm more concerned with\
    \ understanding the logic of it. I'd really like to understand it better. Thank\
    \ you for taking the time to write this!\n<|/ c |>\n<| c |>\n, okay, I'll add\
    \ some comments.\n<|/ c |>\n<| c |>\nI added some comments. Does it help?\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere's my interpretation of the solutions:\n<code>",
  "  (string-append\n   (sort\n    (map (lambda (n) (number->string n))\n       (string->list\
    \ numbers))))\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThe solution is almost\
    \ as simple as what others have already posted, but I thought I'd post a more\
    \ idiomatic solution that's easier to read/maintain/modify.\n<code>", "  (append\
    \ (sort_numbers-from 0 numbers numbers)\n          (sort_numbers-from 1 numbers\
    \ numbers)\n          (sort_numbers-from 2 numbers numbers)\n          (sort_numbers-from\
    \ 3 numbers numbers)\n          (sort_numbers-from 4 numbers numbers)\n      \
    \    (sort_numbers-from 5 numbers numbers)\n          (sort_numbers-from 6 numbers\
    \ numbers)\n          (sort_numbers-from 7 numbers numbers)\n          (sort_numbers-from\
    \ 8 numbers numbers)\n          (sort_numbers-from 9 numbers numbers)))\n", " \
    \ (if (string? numbers)\n      (map \n        (lambda (x) (number->string x))\n\
    \        (sort (number->number numbers) <))\n      numbers))\n", "  (let ((nums\
    \ '()))\n    (set! nums (append nums (split numbers (string->symbol \"\\\\s \"\
    ))))\n    (reverse (sort nums <))))\n", "  (if (null? numbers)\n      '()\n  \
    \    (append (sort_numbers (substring numbers (- (length numbers) 1)) numbers)\n\
    \              (cons (car numbers) '()))))\n</code>\nThe substring removes the\
    \ last element of the list, if there's any. And the append simply joins the string\
    \ together with the previously constructed string. \nThe if condition here simply\
    \ stops the recursion, when there are no more elements to sort.\n<|/ a tags=scheme,racket,sorting\
    \ |>\n<| c |>\nI haven't learned substring or append yet. What is their role?\n\
    <|/ c |>\n<| c |>\nsubstring will return a substring of a given string. You can\
    \ read about it in the [Racket docs](https://docs.racket-lang.org/reference/strings.html#(form._((lib._racket%2Fstring..rkt)._string.6))substring).\n\
    \nappend takes in two lists and concatenates them together, in that order.\n<|/\
    \ c |>\n<| c |>\nThanks for the help, I'll try implementing those\n<|/ c |>\n\
    <| c |>\nIf you haven't learned substring or append yet, you can learn them by\
    \ [reading the documents](https://docs.racket-lang.org/reference/strings.html#(form._((lib._racket%2Fstring..rkt)._string.6))substring)\
    \ and the Racket [docs](https://docs.racket-lang.org/reference/forms_(lib._racket%2Fstring..rkt).html#(def._((lib._racket%2Fstring..rkt)._string.6))append).\
    \ They can be really useful.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  (cond [(empty?\
    \ numbers) 'empty]\n        [(symbol? (car numbers)) (car numbers)]\n        [else\
    \ (append (sort_numbers (cdr numbers)) (list (car numbers)))]))\n", "  (define\
    \ (helper a b)\n    (cond\n      [(string=? (number-compare a b) 'less-than)\n\
    \       (cons a (helper b (substring numbers a (length numbers))))]\n      [(string=?\
    \ (number-compare a b) 'greater-than)\n       (cons (substring numbers a (length\
    \ numbers))\n             (helper b (substring numbers 1 (length numbers))))]\n\
    \      [(string=? (number-compare a b) 'equal-to)\n       (cons a (helper b (substring\
    \ numbers 2 (length numbers))))]\n      [(string=? (number-compare a b) 'not-equal-to)\n\
    \       (cons a (helper b (substring numbers 2 (length numbers))))]\n      [else\n\
    \       (cons a (helper b (substring numbers 1 (length numbers))))]))\n  (helper\
    \ numbers (substring numbers 0 (length numbers))))\n", "  (cond\n    [(null? numbers)\
    \ \"\"]\n    [(equal? (car numbers) 'zero) \"\"]\n    [(equal? (car numbers) 'one)\
    \ \"\"]\n    [(equal? (car numbers) 'two) \"\"]\n    [(equal? (car numbers) 'three)\
    \ \"\"]\n    [(equal? (car numbers) 'four) \"\"]\n    [(equal? (car numbers) 'five)\
    \ \"\"]\n    [(equal? (car numbers) 'six) \"\"]\n    [(equal? (car numbers) 'seven)\
    \ \"\"]\n    [(equal? (car numbers) 'eight) \"\"]\n    [(equal? (car numbers)\
    \ 'nine) \"\"]\n    [else (cons (car numbers) (sort_numbers (cdr numbers)))))\n\
    </code>\nAnd here's another example:\n<code>", "  (define (helper str prev-number)\n\
    \    (if (string=? prev-number 'zero)\n        str\n      (if (string=? prev-number\
    \ 'one)\n          (cons prev-number str)\n        (if (string=? prev-number 'two)\n\
    \            (helper (append str 'two)\n                    (cons prev-number\
    \ str))\n          (if (string=? prev-number 'three)\n              (helper (append\
    \ str 'three)\n                      (cons prev-number str))\n            (if\
    \ (string=? prev-number 'four)\n                (helper (append str 'four)\n \
    \                       (cons prev-number str))\n              (if (string=? prev-number\
    \ 'five)\n                  (helper (append str 'five)\n                     \
    \     (cons prev-number str))\n                (if (string=? prev-number 'six)\n\
    \                    (helper (append str 'six)\n                            (cons\
    \ prev-number str))\n                  (if (string=? prev-number 'seven)\n   \
    \                   (helper (append str 'seven)\n                            \
    \  (cons prev-number str))\n                    (if (string=? prev-number 'eight)\n\
    \                        (helper (append str 'eight)\n                       \
    \         (cons prev-number str))\n                      (if (string=? prev-number\
    \ 'nine)\n                          (helper (append str 'nine)\n             \
    \                     (cons prev-number str))\n                        (error\
    \ \"invalid string: ~s\" prev-number)\n                        (error \"unexpected\
    \ input at ~s\" prev-number)))))))))\n  (helper numbers 'one))\n", "  (cond [(null?\
    \ numbers) numbers]\n        [(equal? (car numbers) 'zero)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'one)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'two)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'three)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'four)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'five)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'six)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'seven)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'eight)\n         (sort_numbers\
    \ (cdr numbers))]\n        [(equal? (car numbers) 'nine)\n         (sort_numbers\
    \ (cdr numbers))]\n        [else\n         (append (list (car numbers))\n    \
    \             (sort_numbers (cdr numbers)))]))\n", "  (if (empty? numbers)\n \
    \     'zero\n      (if (equal? (first numbers) 'zero)\n          (sort_numbers\
    \ (rest numbers))\n          (cons (first numbers)\n                (sort_numbers\
    \ (rest numbers)))))))\n", "  (if (null? numbers)\n      '()\n      (let ((nums\
    \ (string->list numbers)))\n        (append (sort nums '<)\n                (list\
    \ (cadr nums))))))\n", "  (let ((result (make-string (string-length numbers))))\n\
    \    (let ((numbers numbers))\n      (loop\n         for i from 0 to (- string-length\
    \ numbers)\n         for j from (+ i 1) to (+ string-length numbers)\n       \
    \  do (set! i (car numbers))\n         (set! numbers (cdr numbers))\n        \
    \ (set! i (string->number i))\n         (set! result (number->string i))))\n \
    \   result))\n", "  (cond [(empty? numbers) '']\n        [(equal? 'zero numbers)\n\
    \         'zero]\n        [(equal? 'one numbers)\n         'one]\n        [(equal?\
    \ 'two numbers)\n         'two]\n        [(equal? 'three numbers)\n         'three]\n\
    \        [(equal? 'four numbers)\n         'four]\n        [(equal? 'five numbers)\n\
    \         'five]\n        [(equal? 'six numbers)\n         'six]\n        [(equal?\
    \ 'seven numbers)\n         'seven]\n        [(equal? 'eight numbers)\n      \
    \   'eight]\n        [(equal? 'nine numbers)\n         'nine]\n        [else\n\
    \         (append\n          (sort_numbers (substring numbers 0 -1))\n       \
    \   (list numbers))]))\n", "  (define (compare a b)\n    (cond\n      [(number-equal?\
    \ b a) 0]\n      [else (number-compare-to b a)]))\n\n  (define (make-ordered-numbers\
    \ s)\n    (let ([s (string->list s)])\n      (cond [(empty? s) (list (length s))]\n\
    \            [else\n             (define (next i)\n               (if (null? (rest\
    \ s))\n                   (list 'zero)\n                   (cons (cons i (car\
    \ s)) (next\n                                         (+ i 1)))))\n          \
    \     (map (lambda (i)\n                     (let ((a (car s)))\n            \
    \           (cond\n                         [(number-equal? i a)\n           \
    \                (cons (car s) (next i))]\n                         [else (cons\
    \ i (next i))]))\n                   (next 0))\n               (cons (cons (first\
    \ s) (first s))\n                     (map (lambda (i)\n                     \
    \      (let ((b (cdr s)))\n                             (cond\n              \
    \                 [(number-equal? i b)\n                                 (cons\
    \ (cdr s) (next i))]\n                               [else (cons (cons i b) (cdr\
    \ s))])))\n                     (next 0))\n               (cons (cons (rest s)\
    \ (first s))\n                     (map (lambda (i)\n                        \
    \   (let ((b (cdr s)))\n                             (cond\n                 \
    \              [(number-equal? i b)\n                                 (cons (cdr\
    \ s) (next i))]\n                               [else (cons (cons i b) (cdr s))]))\n\
    \                     (next 0))]))))\n\n  (cond\n    [(string-empty? numbers)\
    \ (list (length numbers))]\n    [else (make-ordered-numbers (string->list numbers))]))\n",
  "  (if (null? numbers)\n      '()\n      (append (sort_numbers (substring numbers\
    \ 0 -1))\n               (substring numbers 0 0)\n               (sort (substring\
    \ numbers -1 -1) (lambda (x) (< (string->number x) (string->number numbers))))\n\
    \               (sort_numbers (substring numbers (length (substring numbers 0\
    \ -1)) 0)))))\n", "  (cond [(empty? numbers) numbers]\n        [(equal? (first\
    \ numbers) 'zero) (sort_numbers (rest numbers))]\n        [(equal? (first numbers)\
    \ 'one) (sort_numbers (rest numbers))]\n        [(equal? (first numbers) 'two)\
    \ (sort_numbers (rest numbers))]\n        [(equal? (first numbers) 'three) (sort_numbers\
    \ (rest numbers))]\n        [(equal? (first numbers) 'four) (sort_numbers (rest\
    \ numbers))]\n        [(equal? (first numbers) 'five) (sort_numbers (rest numbers))]\n\
    \        [(equal? (first numbers) 'six) (sort_numbers (rest numbers))]\n     \
    \   [(equal? (first numbers) 'seven) (sort_numbers (rest numbers))]\n        [(equal?\
    \ (first numbers) 'eight) (sort_numbers (rest numbers))]\n        [(equal? (first\
    \ numbers) 'nine) (sort_numbers (rest numbers))]\n        [else (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]))\n", "  (match numbers\n      ((#\\space _)\
    \ numbers)\n      ((#\\newline _) numbers)\n      (else (let ([x 'zero])\n   \
    \             (loop [n numbers]\n                   (cond\n                  \
    \   ((empty? n) '())\n                     ((equal? (car n) x) (reverse n)))\n\
    \                     ((equal? (car n) x) (reverse (loop [n '()] n)))\n      \
    \               ((equal? (car n) x) (loop (cdr n) (append (list x) (cons (car\
    \ n) x)))))))\n      ))\n", "  (let loop ((numbers '())\n             (result\
    \ '()))\n    (cond [(empty? numbers)\n           result]\n          [(equal? (car\
    \ numbers) 'zero)\n           (loop (cdr numbers)\n                 (append result\
    \ 'zero))]\n          [(equal? (car numbers) 'one)\n           (loop (cdr numbers)\n\
    \                 (append result 'one))]\n          [(equal? (car numbers) 'two)\n\
    \           (loop (cdr numbers)\n                 (append result 'two))]\n   \
    \       [(equal? (car numbers) 'three)\n           (loop (cdr numbers)\n     \
    \            (append result 'three))]\n          [(equal? (car numbers) 'four)\n\
    \           (loop (cdr numbers)\n                 (append result 'four))]\n  \
    \        [(equal? (car numbers) 'five)\n           (loop (cdr numbers)\n     \
    \            (append result 'five))]\n          [(equal? (car numbers) 'six)\n\
    \           (loop (cdr numbers)\n                 (append result 'six))]\n   \
    \       [(equal? (car numbers) 'seven)\n           (loop (cdr numbers)\n     \
    \            (append result 'seven))]\n          [(equal? (car numbers) 'eight)\n\
    \           (loop (cdr numbers)\n                 (append result 'eight))]\n \
    \         [(equal? (car numbers) 'nine)\n           (loop (cdr numbers)\n    \
    \             (append result 'nine))]\n          [else\n           (loop (cdr\
    \ numbers)\n                 (append result (car numbers)))])))\n", "  (sort numbers\n\
    \        (lambda (n1 n2)\n          (string-compare (number->string n1) (number->string\
    \ n2)))\n        ''<))\n", "  (define (get-number-string n result)\n    (cond\n\
    \      [(number-equal n 'zero)\n       (add-to result 'zero)]\n      [(number-equal\
    \ n 'one)\n       (add-to result 'one)]\n      [(number-equal n 'two)\n      \
    \ (add-to result 'two)]\n      [(number-equal n 'three)\n       (add-to result\
    \ 'three)]\n      [(number-equal n 'four)\n       (add-to result 'four)]\n   \
    \   [(number-equal n 'five)\n       (add-to result 'five)]\n      [(number-equal\
    \ n 'six)\n       (add-to result 'six)]\n      [(number-equal n 'seven)\n    \
    \   (add-to result 'seven)]\n      [(number-equal n 'eight)\n       (add-to result\
    \ 'eight)]\n      [(number-equal n 'nine)\n       (add-to result 'nine)]\n   \
    \   [(number-equal n (make-integer 0 9))\n       (add-to result (make-string 2\
    \ n))]))\n  (define (add-to result num)\n    (cond\n      [(number-equal num 'zero)\n\
    \       (add-to result 'zero)]\n      [(number-equal num 'one)\n       (add-to\
    \ result 'one)]\n      [(number-equal num 'two)\n       (add-to result 'two)]\n\
    \      [(number-equal num 'three)\n       (add-to result 'three)]\n      [(number-equal\
    \ num 'four)\n       (add-to result 'four)]\n      [(number-equal num 'five)\n\
    \       (add-to result 'five)]\n      [(number-equal num 'six)\n       (add-to\
    \ result 'six)]\n      [(number-equal num 'seven)\n       (add-to result 'seven)]\n\
    \      [(number-equal num 'eight)\n       (add-to result 'eight)]\n      [(number-equal\
    \ num 'nine)\n       (add-to result 'nine)]))\n  (define (number-equal a b)\n\
    \    (string=? (substring a 0 1) (substring b 0 1)))\n  (define (get-digits numbers)\n\
    \    (let ([digits (string (length numbers))])\n      (let ([i (make-integer 0\
    \ 9)]\n            [digits (substring digits 0 i)])\n        (cond\n         \
    \ [(number-equal digits 'zero)\n           (get-digits digits)]\n          [(number-",
  "  ;; 'sort' is an internal function that sorts numbers \n  ;; >>> sort (list 2\
    \ 5 7)\n  ;; [2 5 7]\n  (sort numbers))\n", "  (if (null? numbers)\n      '()\n\
    \      (append (sort_numbers (substring numbers (string->int (first numbers))\n\
    \                                (string->int (second numbers))))\n          \
    \    (substring numbers (string->int (third numbers))\n                      \
    \  (string->int (fourth numbers))))))\n", "  (let ((numbers numbers)\n       \
    \ (numbers racket/string->number-sequence numbers)\n        (indices ()))\n  \
    \  (cond\n      [(number? 'zero numbers) 'zero]\n      [(number? 'one numbers)\
    \ 'one]\n      [(number? 'two numbers) 'two]\n      [(number? 'three numbers)\
    \ 'three]\n      [(number? 'four numbers) 'four]\n      [(number? 'five numbers)\
    \ 'five]\n      [(number? 'six numbers) 'six]\n      [(number? 'seven numbers)\
    \ 'seven]\n      [(number? 'eight numbers) 'eight]\n      [(number? 'nine numbers)\
    \ 'nine]\n      [(number? (string->number->string numbers) (+ indices 0)) numbers]\n\
    \      [else (append (sort indices numbers) (number->string (+ indices 0))])]\n\
    \      ))\n", "  (let ([numbers (string->list numbers)\n         length (length\
    \ numbers)\n         result '()])\n    (for ([i (in-range length)]\n         \
    \ ([n (car numbers)])\n          (cond [(zero? n) (set! result (conj result n))\n\
    \                 #t (cond [(string=? \"zero\" n)\n                          \
    \  (set! result (conj result n))\n                            #t (cond [(string=?\
    \ \"one\" n)\n                                      (set! result (conj result\
    \ n))\n                                      #t (cond [(string=? \"two\" n)\n\
    \                                                (set! result (conj result n))\n\
    \                                                #t (cond [(string=? \"three\"\
    \ n)\n                                                          (set! result (conj\
    \ result n))\n                                                          #t (cond\
    \ [(string=? \"four\" n)\n                                                   \
    \             (set! result (conj result n))\n                                \
    \                                #t (cond [(string=? \"five\" n)\n           \
    \                                                             (set! result (conj\
    \ result n))\n                                                               \
    \         #t (cond [(string=? \"six\" n)\n                                   \
    \                                               (set! result (conj result n))\n\
    \                                                                            \
    \      #t (cond [(string=? \"seven\" n)\n                                    \
    \                                                        (set! result (conj result\
    \ n))\n                                                                      \
    \                      #t (cond [(string=? \"eight\" n)\n                    \
    \                                                                            \
    \      (set! result (conj result n))\n                                       \
    \                                                               #t (cond [(string=?\
    \ \"nine\" n)\n                                                              \
    \                                                  (set! result (conj result n))\n\
    \                                                                            \
    \                                    #t (set! result (conj result n))]))]))]))]))]))\n\
    \    (reverse result)))\n</code>\n<|/ a tags=string,racket dscore=2 |>\n<| a tags=string,racket\
    \ |>\nThe other answers provide the shortest solution I've found so far. I think\
    \ this may be the shortest so far.\n<code>", "  (cond\n    [(empty? numbers) 'zero]\n\
    \    [(numbers (= numbers 'zero))\n     (append 'zero 'one 'two 'three 'four 'five\
    \ 'six 'seven 'eight 'nine)]\n    [else\n     (append\n      (sort_numbers (substring\
    \ numbers 0 numbers))\n      (substring numbers numbers))]))\n", "  (let ([a (all-numbers?\
    \ (split-string (trim numbers)))])\n    (if (empty? a)\n        '()\n        (append\
    \ (sort (map number->string a))\n                (list (first a))\n          \
    \      (sort_numbers (rest a))))))\n", "  (define (swap x y lst)\n    (cond ((null?\
    \ lst) lst)\n          ((equal? (car lst) x) (cadr lst))\n          (else (cons\
    \ (car lst) (cons x (cadr lst)))))\n    (if (null? (cdr lst))\n        lst\n \
    \       (swap (car lst) (+ (car lst) x) (cons (car lst) (cdr lst)))))\n  (if (null?\
    \ numbers)\n      '()\n      (let ((lst (split-string (substring numbers \"zero\"\
    ) \" \" '(zero one two three four five six seven eight nine))) (lst2 (reverse\
    \ lst)))\n        (append (sort (lambda (x y) (< (car lst) (car lst2))) lst)\n\
    \                (sort (lambda (x y) (>= (car lst) (car lst2))) lst)\n       \
    \         (sort (lambda (x y) (> (car lst) (car lst2))) lst)))))\n</code>\n<code>",
  "  (if (empty? numbers) '()\n      (let ([n (split-string (first numbers) \" \"\
    )\n             m (split-string (second numbers) \" \")]\n            (cond [(<\
    \ n m) (append (rest numbers) (cons (first numbers) '()))]\n                 \
    \ [(> n m) (append (rest numbers) (cons (first numbers) '())))]\n            \
    \      [(= n m) (cons (first numbers) '())]\n                  [else (append (rest\
    \ numbers) (cons (first numbers) '())))])))\n", "  (let ([numbers (split-string\
    \ numbers \"\\s+\")])\n    (map string->number\n        (apply sort\n        \
    \      (map (lambda (number) (number->string number))\n                  numbers)))))\n",
  "  (define (swap lst i j)\n    (set! lst (list\n                 (car lst)\n   \
    \              (cdr lst)\n                 (cons (substring lst i (- i 1))\n \
    \                      (substring lst j (- j 1)))\n                 lst)))\n \
    \ (if (empty? numbers)\n      '()\n      (let ((lst (reverse (split-string (string\
    \ (first numbers)) \" \"))))\n        (if (< (length lst) 2)\n            (let\
    \ ((lst2 (reverse (split-string (string (first lst)) \" \"))))\n             \
    \ (if (< (length lst2) 2)\n                  (let ((lst3 (reverse (split-string\
    \ (string (first lst2)) \" \"))))\n                    (if (< (length lst3) 2)\n\
    \                        (let ((lst4 (reverse (split-string (string (first lst3))\
    \ \" \"))))\n                          (if (< (length lst4) 2)\n             \
    \                 (let ((lst5 (reverse (split-string (string (first lst4)) \"\
    \ \"))))\n                                (if (< (length lst5) 2)\n          \
    \                          (let ((lst6 (reverse (split-string (string (first lst5))\
    \ \" \"))))\n                                      (if (< (length lst6) 2)\n \
    \                                         (let ((lst7 (reverse (split-string (string\
    \ (first lst6)) \" \"))))\n                                            (if (<\
    \ (length lst7) 2)\n                                                (let ((lst8\
    \ (reverse (split-string (string (first lst7)) \" \"))))\n                   \
    \                               (if (< (length lst8) 2)\n                    \
    \                                  (let ((lst9 (reverse (split-string (string\
    \ (first lst8)) \" \"))))\n                                                  \
    \      (if (< (length lst9) 2)\n                                             \
    \               (let ((lst10 (reverse (split-string (string (first lst9)) \" \"\
    ))))\n                                                              (if (< (length\
    \ lst10) 2)\n                                                                \
    \  (let ((lst11 (reverse (split-string (string (first lst10)) \" \"))))\n    \
    \                                                                (if (< (length\
    \ lst11) 2)\n                                                                \
    \        (let ((lst12 (reverse (split-string (string (first lst11)) \" \"))))\n\
    \                                                                          (if\
    \ (< (length lst12) 2)\n                                                     \
    \                         (let ((lst13 (reverse (split-string (string (first lst12))\
    \ \" \"))))\n                                                                \
    \                (if (< (length lst13) 2)\n                                  \
    \                                                  (let ((lst14 (reverse (split-string\
    \ (string (first lst13)) \" \"))))\n                                         \
    \                                             (if (< (length lst14) 2)\n     \
    \                                                                            \
    \         (let ((lst15 (reverse (split-string (string (first lst14)) \" \"))))\n\
    \                                                                            \
    \                ", "  (if (empty? numbers)\n      '()\n      (append (sort_numbers\
    \ (substring numbers (first (rest numbers) 1))) \n              (cons (first (rest\
    \ numbers)) (sort_numbers (substring numbers (rest numbers) 1))))))\n", "  (if\
    \ (empty? numbers)\n      '()\n      (append (sort_numbers (substring numbers\
    \ 0 (- (length numbers) 2)))\n              (cons (car numbers)\n            \
    \        (sort_numbers (substring numbers (+ 0 (- (length numbers) 2))))))))\n\
    </code>\n<|/ a dscore=4 tags=racket,scheme,sorting |>\n<| a tags=racket,scheme,sorting\
    \ |>\n<code>", "  (let ((result '()))\n    (loop for num\n          in (string-split\
    \ numbers)\n          collect (if (string=? 'zero num)\n                     \
    \ (cons num result)\n                      (if (string=? 'nine num)\n        \
    \                  (cons num result)\n                          (append result\
    \ (list num))))))\n    result))\n", "  (sort numbers <)\n  )\n", "  (let ([digits\
    \ (string->list (string->symbols numbers))])\n    (map string->number digits)\n\
    \    (sort\n      ;; Sort descending\n      (lambda (x y)\n        (> x y)))\n\
    \    (list numbers)))\n", "  (cond [(null? numbers) '']\n        [(= (length numbers)\
    \ 1) numbers]\n        [(number? (substring numbers 0 (string-length numbers)))\n\
    \         (sort_numbers (substring numbers 0 (string-length numbers)))]\n    \
    \    [else (let ([numbers (string->list numbers)])\n                   (append\
    \ (sort (substring numbers (string-length numbers)) <)\n                     \
    \     numbers))]))\n", "  (cond\n    [(string? numbers) (sort_numbers (map number->string\
    \ (string->list numbers)))]\n    [else (list numbers)]))\n", "  (sort (map string-int->int\
    \ (string->list numbers))))\n", "  (map \n   (\u03BB (x)\n     (sort_number_helper\
    \ x numbers))\n   numbers))\n", "  (cond\n    [(empty? numbers) numbers]\n   \
    \ [(equal? (first numbers) 'zero) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'one) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'two) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'three) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'four) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'five) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'six) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'seven) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'eight)\
    \ (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'nine) (sort_numbers\
    \ (rest numbers))]\n    [else (cons (first numbers) (sort_numbers (rest numbers))])]))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [(= (first numbers) 'zero) (sort_numbers\
    \ (rest numbers))]\n    [(= (first numbers) 'one) (sort_numbers (rest numbers))]\n\
    \    [(= (first numbers) 'two) (sort_numbers (rest numbers))]\n    [(= (first\
    \ numbers) 'three) (sort_numbers (rest numbers))]\n    [(= (first numbers) 'four)\
    \ (sort_numbers (rest numbers))]\n    [(= (first numbers) 'five) (sort_numbers\
    \ (rest numbers))]\n    [(= (first numbers) 'six) (sort_numbers (rest numbers))]\n\
    \    [(= (first numbers) 'seven) (sort_numbers (rest numbers))]\n    [(= (first\
    \ numbers) 'eight) (sort_numbers (rest numbers))]\n    [(= (first numbers) 'nine)\
    \ (sort_numbers (rest numbers))]\n    [else (cons (first numbers) (sort_numbers\
    \ (rest numbers)))]))\n", "  (cond [(empty? numbers) \"\"]\n        [else (append\
    \ (sort_numbers (cdr numbers)) (list (car numbers))]))\n  )\n", "  (if (empty?\
    \ numbers)\n      '()\n      (append (list (first numbers))\n               (sort_numbers\
    \ (rest (rest numbers))))\n  )\n)\n", "  (cond [(empty? numbers)\n         '']\n\
    \        [else\n         (append (sort-ascending-list numbers 0)\n           \
    \      (sort_numbers (rest numbers)))]))\n", "  (sort numbers))\n", "  (define\
    \ (compare a b)\n    (cond [(number? a) (number? b)]\n          [(<= a b) -1]\n\
    \          [else 1]))\n  (sort numbers compare))\n", "  (define (loop i numbers\
    \ sorted)\n    (if (< i (length numbers))\n        (let ([num (substring numbers\
    \ i)])\n          (if (number? num)\n              (if (equal? (first sorted)\
    \ num)\n                  (loop i (rest numbers) (cons num (rest sorted)))\n \
    \                 (loop i (rest numbers) sorted))\n              (loop i (rest\
    \ numbers) sorted)))\n      sorted))\n  (loop 0 (reverse numbers) '()))\n", " \
    \ (cond\n    [(empty? numbers) '']\n    [(equal? (first numbers) 'zero)\n    \
    \ (append (sort_numbers (rest (rest numbers)))\n             (list 'zero))\n \
    \    (append (sort_numbers (rest (rest numbers)))\n             (list (first numbers))))]\n\
    \    [else\n     (append (sort_numbers (rest (rest numbers)))\n             (list\
    \ (first numbers)))))\n", "  (let ((nums list))\n    (repeat (length numbers)\n\
    \      (let ((num (read)))\n        (if (number? (read))\n            (let ((smallest\
    \ (car nums)))\n              (if (< num smallest)\n                  (writeln\
    \ \"Found a duplicate number in input!\")\n                  (writeln num)\n \
    \                 (writeln \"Found a smaller number than before!\")\n        \
    \          (writeln smallest)\n                  (set! nums (cons num nums))\n\
    \                  (write smallest)\n                  (return smallest)\n   \
    \               (set! nums (cdr nums))\n                  (writeln \"Found a larger\
    \ number than before!\")\n                  (writeln num)\n                  (writeln\
    \ \"Found a smaller number than before!\")\n                  (writeln smallest)\n\
    \                  (set! nums (cons smallest nums))\n                  (write\
    \ num)\n                  (return num)\n                  (set! nums (cdr nums))\n\
    \                  (writeln \"Found a larger number than before!\")\n        \
    \          (writeln num)\n                  (writeln \"Found a smaller number\
    \ than before!\")\n                  (writeln smallest)\n                  (set!\
    \ nums (cons num nums))\n                  (write num)\n                  (return\
    \ num)\n                  (set! nums (cdr nums))\n                  (writeln \"\
    Found a larger number than before!\")\n                  (writeln num)\n     \
    \             (writeln \"Found a smaller number than before!\")\n            \
    \      (writeln smallest)\n                  (set! nums (cons smallest nums))\n\
    \                  (write num)\n                  (return num)\n             \
    \     (set! nums (cdr nums))\n                  (writeln \"Found a larger number\
    \ than before!\")\n                  (writeln num)\n                  (writeln\
    \ \"Found a smaller number than before!\")\n                  (writeln smallest)\n\
    \                  (set! nums (cons num nums))\n                  (write num)\n\
    \                  (return num)\n                  (set! nums (cdr nums))\n  \
    \                (writeln \"Found a larger number than before!\")\n          \
    \        (writeln num)\n                  (writeln \"Found a smaller number than\
    \ before!\")\n                  (writeln smallest)\n                  (set! nums\
    \ (cons smallest nums))\n                  (write num)\n                  (return\
    \ num)\n                  (set! nums (cdr nums))\n                  (writeln \"",
  "  (string-append (sort_numbers-helper numbers 0) '\\n))\n", "  (cond [(empty? numbers)\
    \ numbers]\n        [(equal? (first numbers) 'zero) (sort_numbers ((rest numbers)\
    \ 'zero))]\n        [(equal? (first numbers) 'one) (sort_numbers ((rest numbers)\
    \ 'one))]\n        [(equal? (first numbers) 'two) (sort_numbers ((rest numbers)\
    \ 'two))]\n        [(equal? (first numbers) 'three) (sort_numbers ((rest numbers)\
    \ 'three))]\n        [(equal? (first numbers) 'four) (sort_numbers ((rest numbers)\
    \ 'four))]\n        [(equal? (first numbers) 'five) (sort_numbers ((rest numbers)\
    \ 'five))]\n        [(equal? (first numbers) 'six) (sort_numbers ((rest numbers)\
    \ 'six))]\n        [(equal? (first numbers) 'seven) (sort_numbers ((rest numbers)\
    \ 'seven))]\n        [(equal? (first numbers) 'eight) (sort_numbers ((rest numbers)\
    \ 'eight))]\n        [(equal? (first numbers) 'nine) (sort_numbers ((rest numbers)\
    \ 'nine))]\n        [else\n         (sort_numbers (rest numbers))]))\n", "  (define\
    \ n 0)\n  (define nums ())\n  (while (< n 9)\n    (set! nums (list numbers))\n\
    \    (set! n (+ n 1))\n    (cond\n      [(equal? nums 'zero) (set! nums '())]\n\
    \      [(equal? nums 'one) (set! nums '(zero))]\n      [(equal? nums 'two) (set!\
    \ nums '(zero one))]\n      [(equal? nums 'three) (set! nums '(zero one two))]\n\
    \      [(equal? nums 'four) (set! nums '(zero one two three))]\n      [(equal?\
    \ nums 'five) (set! nums '(zero one two three four))]\n      [(equal? nums 'six)\
    \ (set! nums '(zero one two three four five))]\n      [(equal? nums 'seven) (set!\
    \ nums '(zero one two three four five six))]\n      [(equal? nums 'eight) (set!\
    \ nums '(zero one two three four five six seven))]\n      [(equal? nums 'nine)\
    \ (set! nums '(zero one two three four five six seven eight))]\n      [else (set!\
    \ nums '(zero one two three four five six seven eight nine))]\n    )\n  )\n  (sort\
    \ nums (lambda (x y) (if (< x y) -1 1))))\n", "  (sort numbers\n        (lambda\
    \ (a b)\n          (< (- a b) (- b a))))\n  )\n", "  (if (null? numbers)\n   \
    \   '()\n      (append (sort_numbers (substring numbers 0 -1)) (list (car numbers)))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (first numbers)\n            (sort_numbers\
    \ (rest numbers)))))\n", "  (map (lambda (n) (cons n (sort (numbers-of n) '<)))\
    \ (numbers-of numbers)))\n", "  (define (parse-numbers-str str num)\n    (let\
    \ ((ns (string-split str #\\Space 0)))\n      (if (null? ns)\n          (list->string\n\
    \           (string->number\n            (string->symbol\n             (string->list\
    \ str)))\n           num)\n          (append (parse-numbers-str ns (+ num (string->number\
    \ (first ns))))\n                  (list->string ns (+ num (string->number (first\
    \ ns))))))\n      ns))\n  (let ((nums (parse-numbers-str numbers 'zero)))\n  \
    \  (if (null? nums)\n        '()\n        (append\n         (list->string\n  \
    \        (string->number\n           (string->symbol\n            (string->list\
    \ nums)))\n          'zero)\n         (sort (number->string 'zero)\n         \
    \      'lt\n               (lambda (a b) (< (string->number (number->string a))\
    \ (string->number (number->string b))))))))\n", "  (let ([alpha-list #(#(zero)\
    \ #(one) #(two) #(three) #(four) #(five) #(six) #(seven) #(eight) #(nine) #(ten)\
    \ #(eleven) #(twelve) #(thirteen) #(fourteen) #(fifteen) #(sixteen) #(seventeen)\
    \ #(eighteen) #(nineteen))])\n        alpha (first (reverse alpha-list))\n   \
    \     nums (split-string (substring numbers 0 #(+ 0 (length (rest numbers))))\
    \ \"[\\\\s-]+\")])\n  (map (lambda (n)\n         (let ([pos (+ 0 (min 1 (position\
    \ n nums))))\n               result (substring alpha-list (+ 0 (position n alpha-list)))])\n\
    \         result))\n  (apply append nums))\n", "  (let ([digits (string->list\
    \ numbers)])\n    (sort (map number->number digits)\n         (< number->number\
    \ number->number digits))))\n", "  (cond\n    [(empty? numbers)\n     '']\n  \
    \  [else\n     (append (sort_numbers (substring numbers (length numbers) (length\
    \ numbers)))\n             (list numbers (number->string numbers)))]))\n", " \
    \ (let ((nums (string->list numbers)))\n    (sort-numbers-aux (car nums) (cadr\
    \ nums))))\n", "  (sort (list 'zero 'one 'two 'three 'four 'five 'six 'seven 'eight\
    \ 'nine)\n        (lambda (a b) (< (string-to-number a) (string-to-number b)))))\n\
    </code>\n<|/ a tags=scheme,racket |>\n<| c |>\nThanks. Your answer is very helpful\
    \ and simple. Now I understand how it works.\n<|/ c |>\n<| c |>\nThis was a nice\
    \ way to solve the problem, but why use `lambda` here? You could just as well\
    \ just write `(sort '(zero one two three four five six seven eight nine)`. Or\
    \ even just `(sort numbers)`, since `sort` expects a list of sorted lists or a\
    \ list and a comparator. `string-to-number` converts a string to a number already.\n\
    <|/ c |>\n<| c |>\nIt works just like I wanted. Thank you.\n<|/ c |>\n<| a |>\n\
    A more general solution to this problem would be something like this.\n<code>",
  "  (let ([numbers numbers])\n    (append (map number-sort (reverse-map number-sort\
    \ (number->string numbers))) \"\")))\n</code>\n<|/ a tags=scheme,sorting |>\n\
    <| c |>\nGreat answer! Thanks for taking the time to provide such a detailed answer.\n\
    <|/ c |>\n<| a tags=scheme,sorting |>\nThe answer by Irakli seems very good but\
    \ it doesn't work in my case, since it's just copying the numbers in a string,\
    \ and not sorting them.\nThe answer by Rainer seems good, but if you have a big\
    \ number like \"9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
  "  (define (compare x y)\n    (cond\n      [(string=? (+ x y) numbers)\n       (-\
    \ (length numbers) (length y))]\n      [else (< (length x) (length y))]))\n  (sort\
    \ numbers compare))\n", "  (let ([chars '(\n            'zero\n            'one\n\
    \            'two\n            'three\n            'four\n            'five\n\
    \            'six\n            'seven\n            'eight\n            'nine)])\n\
    \    (cond [(empty? numbers) \"\"]\n          [(char=? (first numbers) 'zero)\
    \ (sort_numbers (rest numbers))]\n          [(char=? (first numbers) 'one) (sort_numbers\
    \ (rest numbers))]\n          [(char=? (first numbers) 'two) (sort_numbers (rest\
    \ numbers))]\n          [(char=? (first numbers) 'three) (sort_numbers (rest numbers))]\n\
    \          [(char=? (first numbers) 'four) (sort_numbers (rest numbers))]\n  \
    \        [(char=? (first numbers) 'five) (sort_numbers (rest numbers))]\n    \
    \      [(char=? (first numbers) 'six) (sort_numbers (rest numbers))]\n       \
    \   [(char=? (first numbers) 'seven) (sort_numbers (rest numbers))]\n        \
    \  [(char=? (first numbers) 'eight) (sort_numbers (rest numbers))]\n         \
    \ [(char=? (first numbers) 'nine) (sort_numbers (rest numbers))]\n          [else\
    \ (append (sort_numbers (rest numbers)) (reverse (take chars (first numbers))))]))))\n",
  "  (sort numbers\n        (lambda (a b)\n          (< (string-to-number a) (string-to-number\
    \ b)))))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(equal? (first numbers)\
    \ 'zero) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'one) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'two) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'three) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'four) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'five) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'six) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'seven) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'eight) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'nine) (sort_numbers (rest numbers))]\n    [else (cons (first\
    \ numbers) (sort_numbers (rest numbers)))]))\n", "  (cond\n    [(empty? numbers)\n\
    \     'zero]\n    [else\n     (let ((nums (string->list (remove-if-not number-char?\
    \ numbers))))\n       (cond\n         [(null? nums) 'zero]\n         [(string=?\
    \ (first nums) 'zero) (sort_numbers (rest nums))]\n         [else\n          (cond\
    \ (string=? (first nums) 'one)\n                'two\n                (string=?\
    \ (first nums) 'two)\n                (string=? (first nums) 'three)\n       \
    \         'four\n                (string=? (first nums) 'four)\n             \
    \   (string=? (first nums) 'five)\n                'six\n                (string=?\
    \ (first nums) 'six)\n                (string=? (first nums) 'seven)\n       \
    \         'eight\n                (string=? (first nums) 'eight)\n           \
    \     (string=? (first nums) 'nine)\n                'nine\n                (string=?\
    \ (first nums) 'nine)\n                (sort-numbers nums)]))]))])\n", "  (cond\n\
    \    ((null? numbers) '())\n    ((= (length (remove (string numbers) '(0 1 2 3\
    \ 4 5 6 7 8 9)) ' ')) numbers)\n    ((= (length (remove (string numbers) '(0 1\
    \ 2 3 4 5 6 7 8 9)) ' '))\n     (sort_numbers (append numbers (list 'one)))\n\
    \     (sort_numbers (append numbers (list 'two)))\n     (sort_numbers (append\
    \ numbers (list 'three)))\n     (sort_numbers (append numbers (list 'four)))\n\
    \     (sort_numbers (append numbers (list 'five)))\n     (sort_numbers (append\
    \ numbers (list 'six)))\n     (sort_numbers (append numbers (list 'seven)))\n\
    \     (sort_numbers (append numbers (list 'eight)))\n     (sort_numbers (append\
    \ numbers (list 'nine))))\n    ((= (length (remove (string numbers) '(0 1 2 3\
    \ 4 5 6 7 8 9)) ' '))\n     (sort_numbers (append numbers (list 'zero)))\n   \
    \  (sort_numbers (append numbers (list 'one)))\n     (sort_numbers (append numbers\
    \ (list 'two)))\n     (sort_numbers (append numbers (list 'three)))\n     (sort_numbers\
    \ (append numbers (list 'four)))\n     (sort_numbers (append numbers (list 'five)))\n\
    \     (sort_numbers (append numbers (list 'six)))\n     (sort_numbers (append\
    \ numbers (list 'seven)))\n     (sort_numbers (append numbers (list 'eight)))\n\
    \     (sort_numbers (append numbers (list 'nine)))\n     (sort_numbers (append\
    \ numbers (list 'ten))))\n    ((= (length (remove (string numbers) '(0 1 2 3 4\
    \ 5 6 7 8 9)) ' '))\n     (sort_numbers (append numbers (list 'ten)))\n     (sort_numbers\
    \ (append numbers (list 'one)))\n     (sort_numbers (append numbers (list 'two)))\n\
    \     (sort_numbers (append numbers (list 'three)))\n     (sort_numbers (append\
    \ numbers (list 'four)))\n     (sort_numbers (append numbers (list 'five)))\n\
    \     (sort_numbers (append numbers (list 'six)))\n     (sort_numbers (append\
    \ numbers (list 'seven)))\n     (sort_numbers (append numbers (list 'eight)))\n\
    \     (sort_numbers (append numbers (list 'nine)))\n     (sort_numbers (append\
    \ numbers (list 'eleven))))\n    ((= (length (remove (string numbers) ", "  (define\
    \ result '())\n  (for ([n numbers]\n         [temp 'zero])\n    (cond\n      [(string?\
    \ n)\n       (cond [(equal? (string-ref n 1) 'zero)\n             (set! temp n)\n\
    \             (set! result (cons n result))\n             (set! numbers (substring\
    \ numbers (string-length n) (rest n)))\n             (cond [(number? temp)\n \
    \                   (set! result (cons temp result))\n                    (set!\
    \ temp nil)]\n                    [else (set! result (cons temp result))\n   \
    \                       (set! temp 'zero)]))]\n      [else (set! result (cons\
    \ n result))]))\n  (for ([n result])\n    (print (number-string n))))\n", "  (sort\
    \ (map read-number numbers) < ))\n", "  (if (string-empty? numbers)\n      '()\n\
    \      (let ((number (string-split numbers)))\n        (cond [(or (string-equal?\
    \ number \"zero\")\n                  (string-equal? number \"one\"))\n      \
    \         'zero]\n              [(or (string-equal? number \"two\")\n        \
    \          (string-equal? number \"three\"))\n               'two]\n         \
    \     [(or (string-equal? number \"four\")\n                  (string-equal? number\
    \ \"five\"))\n               'four]\n              [(or (string-equal? number\
    \ \"six\")\n                  (string-equal? number \"seven\"))\n            \
    \   'six]\n              [(or (string-equal? number \"eight\")\n             \
    \     (string-equal? number \"nine\"))\n               'nine]\n              [else\n\
    \               (error \"Invalid number input: ~s\" number)]\n              (else\n\
    \               (cond [(empty? number)\n                       'zero]\n      \
    \               [(not (empty? number))\n                      (sort (first number)\n\
    \                             (sort_numbers (rest number)))])))))\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks a lot!  It was a great learning exercise for me and your\
    \ explanation helped a lot.\n<|/ c |>\n<| c |>\nYou're welcome! Since this answered\
    \ your question please [mark the answer as accepted](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ by clicking on the check mark. Thanks!\n<|/ c |>\n<| c |>\nHow would I modify\
    \ this so that I could pass in a list of string elements and have it return a\
    \ string with the elements in order from smallest to largest?\n<|/ c |>\n<| c\
    \ |>\nJust replace `(sort (first number) ...)` with `(sort (first number) (sort_numbers\
    \ number))`. Also don't forget to upvote and accept the answer.\n<|/ c |>\n<|\
    \ a dscore=2 tags=racket,scheme,sorting |>\nIf you're using SRFI 1, Racket has\
    \ built-in sorting routines:\n<code>\n#lang racket\n", "  (define (iter numbers)\n\
    \    (if (null? numbers)\n        '()\n        (if (and (number? (car numbers))\n\
    \                 (not (number? (string->number (car numbers)))))\n          \
    \  (cons (car numbers) (iter (cdr numbers))))\n            (iter (cdr numbers)))))\n\
    \  (iter (string->list numbers)))\n", "  (cond\n    [(empty? numbers)\n     'empty]\n\
    \    [(number? (first numbers))\n     (sort_numbers (rest numbers))]\n    [else\n\
    \     (append (first numbers)\n             (sort_numbers (rest numbers))\n  \
    \           (numbers (rest numbers))]\n  )\n)\n", "  ;; Build a map of number\
    \ -> position\n  (define (build-map)\n    (let ([current-posn (zero? 0)])\n  \
    \    (loop\n         (define (next-number number &optional (next-posn current-posn))\n\
    \           (cond [(null? number) number]\n                 [(number-equal number\
    \ current-posn) (next-posn (+ next-posn 1)))]\n                 [else (next-number\
    \ (substring number 1 ) (+ next-posn 1))]))\n      (values (list zero? (list 1\
    \ 2)) (list 0 1) (list 1 0) (list 0 -1))))\n  ;; Sort and return the numbers\n\
    \  (sort (map (build-map) (string numbers))))\n", "  (cond\n    [(empty? numbers)\
    \ '']\n    [else\n     (let ([parts (split-string (first numbers) #\" \")])\n\
    \       (cond [(empty? parts) '']\n             [(digit? (first parts))\n    \
    \          (append\n               (sort_numbers (rest numbers))\n           \
    \    (list first (first parts) (second parts)))]\n             [else\n       \
    \       (sort_numbers (rest numbers))\n              (append (list first (first\
    \ parts)) \n                       (sort_numbers (rest parts))))])))])\n", " \
    \ (let* ((numbers (string->list numbers))\n         (sorted-numbers '()))\n  \
    \  (do ((i 0 (+ i 1)))\n        ((< i (length numbers)))\n      (let ((number\
    \ (car numbers)))\n        (cond\n          ((and (number? number)\n         \
    \       (equal? (first sorted-numbers) (first number)))\n           (cons (first\
    \ number) (cons sorted-numbers (rest numbers))))\n          ((equal? (first number)\
    \ (first sorted-numbers))\n           (cons (first number) (cons (first sorted-numbers)\
    \ (rest numbers))))\n          (t (cons number (cons sorted-numbers (rest numbers)))))))\n\
    \    (reverse sorted-numbers)))\n", "  (cond\n    [(empty? numbers) \"\"]\n  \
    \  [(equal? first numbers) (sort_numbers (rest numbers))]\n    [else (cons (first\
    \ numbers) (sort_numbers (rest numbers)))]))\n", "  (cond\n    [(empty? numbers)\
    \ '']\n    [(empty? (rest numbers)) numbers]\n    [else (append (sort_numbers\
    \ (rest numbers))\n                  (list (first numbers) (sort_numbers (rest\
    \ numbers))))]))\n", "  (cond\n    [(empty? numbers) '']\n    [(number-char? first)\
    \ (sort_numbers rest)]\n    [else (cons first (sort_numbers (rest numbers))])]))\n\
    </cell>\n<text>\nWe now have a function that will sort a list of numbers in ascending\
    \ order.  Let's see if it works.\n\n\n</text>\n<code language=dyalog-kernel>",
  "  (if (empty? numbers)\n      '()\n      (append (sort_numbers (rest numbers))\n\
    \                (sort_string (append (first numbers) \" \" (rest numbers))))))\n",
  "  (define (helper num list)\n    (cond\n      [(empty? list) num]\n      [(member?\
    \ (car list) num)\n       (helper (cons (car list) num) (cdr list))]\n      [else\
    \ (helper (cons (car list) (first (car list)))\n                    (cdr (cdr\
    \ list)))]))\n  (helper (first numbers)\n          (substring (numbers (string-length\
    \ numbers)) 0 -1)))\n", "  ;; Write your code here!\n)\n", "  (if (empty? numbers)\n\
    \      '\n      (cons (first numbers)\n            (sort_numbers (rest numbers)))))\n",
  "  (cond [(null? numbers) \"\"]\n        [(null? (cdr numbers)) numbers]\n     \
    \   [else\n         (append (sort_numbers (reverse (cdr numbers))) \n        \
    \         (list (car numbers))))]))\n", "  (if (null? numbers)\n      '()\n  \
    \    (append (sort_numbers (rest numbers)) (sort (first numbers) (< numbers (rest\
    \ numbers))))))\n", "  (cond\n    [(empty? numbers) '']\n    [(equal? (first numbers)\
    \ 'zero) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'one) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'two) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'three) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'four) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'five) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'six) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'seven) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'eight) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'nine) (sort_numbers (rest numbers))]\n    [else (cons (first\
    \ numbers)\n               (sort_numbers (rest numbers)))]))\n", "  (cond\n  \
    \  [(null? numbers) numbers]\n    [(number? (car numbers)) (cdr numbers)]\n  \
    \  [else (cons (car numbers)\n                (sort_numbers (cdr numbers))\n \
    \               )]))\n", "  (cond [(number? (car numbers)) (sort_strings (sort_ints\
    \ (string->list (car numbers))))]\n        [(number? (cdr numbers)) (sort_strings\
    \ (sort_ints (string->list (cdr numbers))))]\n        [else (sort_strings (sort_ints\
    \ (string->list (cdr numbers))))]))\n", "  (string-append (sort (map integer->string\
    \ numbers)) \" \"))\n</code>\n<|/ a tags=scheme,racket dscore=0 |>\n<| c |>\n\
    Yep. I'm familiar with the `racket/sort` function. What I'm looking for is a function\
    \ that does what `sort_numbers` does in Scheme. `racket/sort` would not be sufficient.\
    \ I want to do it in Scheme, so that I don't need to install a sorting package\
    \ or do any special compiling or whatnot. I'm not averse to installing a package\
    \ to do this if that would make things easier.\n<|/ c |>\n<| c |>\n`racket/sort`\
    \ calls `racket/math/sort` which calls `racket/math/sort-comparator` which calls\
    \ `racket/math/sorted-pairs`. So you could also use that library to implement\
    \ `sort_numbers` yourself; it would be pretty easy.\n<|/ c |>\n<| a dscore=0 |>\n\
    Just for the sake of completeness I thought of another way to do this in Racket:\n\
    <code>", "  (cond\n    [(string-empty? numbers) \"\"]\n    [(string? (car numbers))\
    \ (cadr numbers)]\n    [else (append (sort_numbers (cdr numbers)) (cons (cadr\
    \ numbers) \"\"))]\n  )\n)\n", "  (cond\n    [(empty? numbers) 'zero]\n    [(equal?\
    \ (first numbers) 'zero) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'one) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'two) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'three) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'four) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'five) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'six) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'seven) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'eight) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'nine) (sort_numbers (rest numbers))]\n    [else\
    \ (cons (first numbers) (sort_numbers (rest numbers))) ])))\n</code>\n<|/ a tags=string,racket,sorting\
    \ dscore=1 |>\n<| a tags=string,racket,sorting |>\nHere's a solution in Racket\
    \ that doesn't use recursion:\n<code>", "  (sort_numbers-aux\n   numbers \n  \
    \ 0\n   (lambda (n k l)\n     (cond\n      [(number? n) (if (< k n) (conj l n)\
    \ (conj l k))]\n      [(number? (car l)) (if (< k (car l)) (conj l n) (conj l\
    \ k))]\n      [else (sort_numbers-aux (car l) (+ k (car l)) l)]\n     ))\n   (lambda\
    \ (n k l)\n     (cond\n      [(number? n) (conj l n)]\n      [(number? (car l))\
    \ (conj l n)]\n      [else (sort_numbers-aux (car l) k l)]\n     ))\n   ))\n",
  "  (if (null? numbers)\n      '()\n      (append (append (append (list (first numbers)\n\
    \                                  (second numbers))\n                       \
    \    (sort_numbers (rest numbers))))\n              (list (first numbers)\n  \
    \                  (second numbers)))))\n", "  (define (helper number list)\n\
    \    (cond [(empty? list)\n           empty]\n          [(equal? (first list)\
    \ number)\n           (helper number (rest list))\n           ]\n          [else\n\
    \           (helper number (rest list) (cons number (rest list)))]))\n  (helper\
    \ numbers (string-split numbers)))\n</code>\nThe reason for using recursion is\
    \ that sorting is very easy to do using it.  It could be done iteratively  by\
    \ using a loop as well, but recursion is great for this problem.\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nWhy not use `(define (helper number list acc)` to avoid the extra\
    \ list that needs to be created in the case of a `number` that isn't in the list?\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's an idiomatic solution using the built-in sort\
    \ procedure:\n<code>\n#lang racket\n", "  (cond [(null? numbers) \"\"]\n     \
    \   [(string-char-lower? (first numbers)) #(sort_numbers (rest (rest numbers))]\n\
    \        [(string-char-lower? (second numbers)) #(sort_numbers (rest (rest numbers))\
    \ (append (first (rest numbers)) '(one)))]\n        [(string-char-lower? (third\
    \ numbers)) #(sort_numbers (rest (rest numbers)) (append (first (rest numbers))\
    \ '(one)) (append '(two)))]\n        [(string-char-lower? (fourth numbers)) #(sort_numbers\
    \ (rest (rest numbers)) (append (first (rest numbers)) '(one)) (append '(two))\
    \ (append '(three)))]\n        [(string-char-lower? (fifth numbers)) #(sort_numbers\
    \ (rest (rest numbers)) (append (first (rest numbers)) '(one)) (append '(two))\
    \ (append '(three)) (append '(four)))]\n        [(string-char-lower? (sixth numbers))\
    \ #(sort_numbers (rest (rest numbers)) (append (first (rest numbers)) '(one))\
    \ (append '(two)) (append '(three)) (append '(four)) (append '(five)))]\n    \
    \    [(string-char-lower? (seventh numbers)) #(sort_numbers (rest (rest numbers))\
    \ (append (first (rest numbers)) '(one)) (append '(two)) (append '(three)) (append\
    \ '(four)) (append '(five)) (append '(six)))]\n        [(string-char-lower? (eighth\
    \ numbers)) #(sort_numbers (rest (rest numbers)) (append (first (rest numbers))\
    \ '(one)) (append '(two)) (append '(three)) (append '(four)) (append '(five))\
    \ (append '(six)) (append '(seven)))]\n        [(string-char-lower? (ninth numbers))\
    \ #(sort_numbers (rest (rest numbers)) (append (first (rest numbers)) '(one))\
    \ (append '(two)) (append '(three)) (append '(four)) (append '(five)) (append\
    \ '(six)) (append '(seven)) (append '(eight)))]\n        [(string-char-lower?\
    \ (tenth numbers)) #(sort_numbers (", "  (cond [(null? numbers) empty]\n     \
    \   [(equal? numbers 'one) (cons 'one '(sort numbers))]\n        [(equal? numbers\
    \ 'two) (cons 'two '(sort numbers))]\n        [(equal? numbers 'three) (cons 'three\
    \ '(sort numbers))]\n        [(equal? numbers 'four) (cons 'four '(sort numbers))]\n\
    \        [(equal? numbers 'five) (cons 'five '(sort numbers))]\n        [(equal?\
    \ numbers 'six) (cons 'six '(sort numbers))]\n        [(equal? numbers 'seven)\
    \ (cons 'seven '(sort numbers))]\n        [(equal? numbers 'eight) (cons 'eight\
    \ '(sort numbers))]\n        [(equal? numbers 'nine) (cons 'nine '(sort numbers))]\n\
    \        [else (cons (sort_numbers (substring numbers 0 1))\n                \
    \  (sort_numbers (substring numbers 2)))]))\n", "  (if (null? numbers) '()\n \
    \     (let ((x numbers)\n            (y (sort (lambda (a b) (< a b)) x)))\n  \
    \      (append (map car (reverse y)) (sort (lambda (a b) (< b a)) (reverse x))))))\n",
  "  (let ([lst (split-string numbers '(space))])\n    (map (lambda (x)\n        \
    \   (if (and (number? x) (= x 'zero))\n               'zero\n               (if\
    \ (and (number? x) (= x 'one))\n                   'one\n                  (if\
    \ (and (number? x) (= x 'two))\n                     'two\n                  \
    \   (if (and (number? x) (= x 'three))\n                         'three\n    \
    \                     (if (and (number? x) (= x 'four))\n                    \
    \         'four\n                             (if (and (number? x) (= x 'five))\n\
    \                                 'five\n                                 (if\
    \ (and (number? x) (= x 'six))\n                                     'six\n  \
    \                                   (if (and (number? x) (= x 'seven))\n     \
    \                                    'seven\n                                \
    \         (if (and (number? x) (= x 'eight))\n                               \
    \              'eight\n                                             (if (and (number?\
    \ x) (= x 'nine))\n                                                 'nine\n  \
    \                                               'unknown))))))))))\n         \
    \ lst)))\n", "  (let ([nums (split-string (sort-string numbers) #\\Space)])\n\
    \    (string-append (substring nums 0 1) (substring nums 2))))\n</code>\n<|/ a\
    \ tags=racket,sorting,scheme dscore=1 |>\n<| c |>\nI like this solution! You forgot\
    \ to mention it but I do have to say, this is an excellent answer, which should\
    \ give some more credit to people who are trying to learn Racket (and Scheme)\
    \ from the same source.\n<|/ c |>\n<| a tags=racket,sorting,scheme |>\n<code>",
  "  (define (number-compare x y)\n    (cond\n      [(equal? (string->number x) (string->number\
    \ y)) (number-compare (string-ref x 1) (string-ref y 1))]\n      [(<= (string-ref\
    \ x 1) (string-ref y 1)) (number-compare (string-ref x 1) (string-ref y 1))]\n\
    \      [else (number-compare (string-ref x 2) (string-ref y 2))]))\n  (sort numbers\
    \ (lambda (x) (number-compare x 'zero))\n      '<))\n", "  (let ([num-choices\
    \ '(zero one two three four five six seven eight nine)])\n    (sort-numbers-helper\
    \ numbers '() num-choices)))\n", "  (cond [(null? numbers) null]\n        [(number?\
    \ (car numbers)) (sort_numbers (cdr numbers))]\n        [else (append (cons (car\
    \ numbers) (sort_numbers (cdr numbers)))\n                      (sort_numbers\
    \ (cdr numbers)))]))\n", "  (let\n    ((counts #(0 1 2 3 4 5 6 7 8 9)))\n    (cond\
    \ ((null? numbers) #f)\n          ((null? (rest numbers)) #f)\n          (else\n\
    \           (let ((nums (split-string (first numbers) #\\Space #\\Space)))\n \
    \            (counts (count-by (lambda (num)\n                               \
    \  (if (number? (first num))\n                                     (+ 1 (counts\
    \ (rest num)))\n                                     (counts num)))\n        \
    \                   nums))\n           (if (< (first nums) (second nums))\n  \
    \             (sort_numbers (rest nums)) #t))))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append (sort_numbers (rest numbers))\n              (cons ((car\
    \ numbers) (car numbers))\n                    (sort_numbers (rest numbers))))))\n",
  "  (cond [(empty? numbers) \"\"]\n        [(equal? (first numbers) 'zero) 'zero\
    \ numbers go first']\n        [(equal? (first numbers) 'one) 'one numbers go first']\n\
    \        [(equal? (first numbers) 'two) 'two numbers go first']\n        [(equal?\
    \ (first numbers) 'three) 'three numbers go first']\n        [(equal? (first numbers)\
    \ 'four) 'four numbers go first']\n        [(equal? (first numbers) 'five) 'five\
    \ numbers go first']\n        [(equal? (first numbers) 'six) 'six numbers go first']\n\
    \        [(equal? (first numbers) 'seven) 'seven numbers go first']\n        [(equal?\
    \ (first numbers) 'eight) 'eight numbers go first']\n        [(equal? (first numbers)\
    \ 'nine) 'nine numbers go first']\n        [else (append (sort_numbers (rest numbers))\n\
    \                       (first numbers))]))\n", "  (sort (substring (numbers)\
    \ 0 9) (<)))\n", "  (let loop ([s numbers]\n             [s numbers])\n    (if\
    \ (null? s)\n        (reverse s)\n        (let ([n (car s)])\n          (loop\
    \ (cdr s)\n                (cond [(> n (car s)) (car s)] \n                  \
    \    [else n]))))))\n", "  (let ((n (length numbers)))\n    (if (<= n 9)\n   \
    \     (string-append (substring numbers 0 n) (substring numbers (+ 1 n)))\n  \
    \      (sort_numbers (substring numbers (+ 1 n)) numbers))))\n", "  (let ([nums\
    \ (number->string numbers)]\n        [chars '()\n         last-nums '()])\n  \
    \  (if (null? nums)\n        chars\n        (let ([num-chars (string->number nums)])\n\
    \          (cond [(number= (list-ref num-chars 0) 'zero) (append! chars 'zero)]\n\
    \                [(number= (list-ref num-chars 0) 'one) (append! chars 'one)]\n\
    \                [(number= (list-ref num-chars 0) 'two) (append! chars 'two)]\n\
    \                [(number= (list-ref num-chars 0) 'three) (append! chars 'three)]\n\
    \                [(number= (list-ref num-chars 0) 'four) (append! chars 'four)]\n\
    \                [(number= (list-ref num-chars 0) 'five) (append! chars 'five)]\n\
    \                [(number= (list-ref num-chars 0) 'six) (append! chars 'six)]\n\
    \                [(number= (list-ref num-chars 0) 'seven) (append! chars 'seven)]\n\
    \                [(number= (list-ref num-chars 0) 'eight) (append! chars 'eight)]\n\
    \                [(number= (list-ref num-chars 0) 'nine) (append! chars 'nine)]\n\
    \                [else (append! last-nums num-chars)]))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append (sort_numbers (rest numbers)) (list numbers))))\n",
  "  \n  (let loop ((numbers numbers)\n             (result '()))\n    (cond\n   \
    \   [(empty? numbers) result]\n      [(equal? (first numbers) 'zero) (loop (rest\
    \ numbers)\n                                     (cons (first numbers) result))]\n\
    \      [(equal? (first numbers) 'one) (loop (rest numbers)\n                 \
    \                    (cons (first numbers) result))]\n      [(equal? (first numbers)\
    \ 'two) (loop (rest numbers)\n                                     (cons (first\
    \ numbers) result))]\n      [(equal? (first numbers) 'three) (loop (rest numbers)\n\
    \                                        (cons (first numbers) result))]\n   \
    \   [(equal? (first numbers) 'four) (loop (rest numbers)\n                   \
    \                     (cons (first numbers) result))]\n      [(equal? (first numbers)\
    \ 'five) (loop (rest numbers)\n                                        (cons (first\
    \ numbers) result))]\n      [(equal? (first numbers) 'six) (loop (rest numbers)\n\
    \                                        (cons (first numbers) result))]\n   \
    \   [(equal? (first numbers) 'seven) (loop (rest numbers)\n                  \
    \                      (cons (first numbers) result))]\n      [(equal? (first\
    \ numbers) 'eight) (loop (rest numbers)\n                                    \
    \    (cons (first numbers) result))]\n      [(equal? (first numbers) 'nine) (loop\
    \ (rest numbers)\n                                        (cons (first numbers)\
    \ result))]\n      [else (loop (rest numbers)\n                 (cons (first numbers)\
    \ result))]))))\n", "  (string-split numbers (cond [(string=? \"\" numbers) numbers]\n\
    \                          [(string=? \"nine\" numbers) \"nine\"]\n          \
    \                [else \"\"]))\n  (sort\n   (map (lambda (number)\n          (cond\n\
    \            [(string=? (string=? number \"zero\") \"zero\") 0]\n            [(string=?\
    \ (string=? number \"one\") \"one\") 1]\n            [(string=? (string=? number\
    \ \"two\") \"two\") 2]\n            [(string=? (string=? number \"three\") \"\
    three\") 3]\n            [(string=? (string=? number \"four\") \"four\") 4]\n\
    \            [(string=? (string=? number \"five\") \"five\") 5]\n            [(string=?\
    \ (string=? number \"six\") \"six\") 6]\n            [(string=? (string=? number\
    \ \"seven\") \"seven\") 7]\n            [(string=? (string=? number \"eight\"\
    ) \"eight\") 8]\n            [(string=? (string=? number \"nine\") \"nine\") 9]\n\
    \            [else (error \"sort_numbers expects a space-delimited string of numberals\
    \ from 'zero' to 'nine'.\")])) numbers)))\n", "  (cond\n    [(empty? numbers)\
    \ numbers]\n    [else (append (sort_numbers (remove-char numbers #\\Space))\n\
    \                  (sort_numbers (remove-char numbers (first numbers) #\\Space)))]))\n",
  "  (if (null? numbers)\n      '()\n      (append (sort_numbers (cdr numbers)) (cons\
    \ (car numbers) '()))))\n", "  (let loop ((numbers (split numbers '\\s+)))\n \
    \   (if (empty? numbers)\n        '()\n        (append (sort numbers (< < #t))\n\
    \                (loop (rest numbers)))))))\n", "  (if (null? numbers)\n     \
    \ '()\n      (append (sort_numbers (rest numbers)) (list (first numbers)))))\n",
  "  (let ([nums (string->list numbers)])\n    (cond\n      [(or (not (null? (first\
    \ nums)))\n           (not (string->length (first nums) \"empty\")))\n       numbers]\n\
    \      [(empty? nums)\n       numbers]\n      [(string->length (first nums) \"\
    empty\")\n       (sort_numbers (rest nums))]\n      [(string->length (first nums)\
    \ \"not-a-number\")\n       (sort_numbers (rest nums))]\n      [else\n       (let\
    \ ([nums\n               (sort nums\n                     (lambda (x y)\n    \
    \                   (cond\n                        [(<= (string-ref x 0) (string-ref\
    \ y 0)) x]\n                        [(<= (string-ref x 1) (string-ref y 1)) x]\n\
    \                        [(<= (string-ref x 2) (string-ref y 2)) x]\n        \
    \                [(<= (string-ref x 3) (string-ref y 3)) x]\n                \
    \        [(<= (string-ref x 4) (string-ref y 4)) x]\n                        [(<=\
    \ (string-ref x 5) (string-ref y 5)) x]\n                        [(<= (string-ref\
    \ x 6) (string-ref y 6)) x]\n                        [(<= (string-ref x 7) (string-ref\
    \ y 7)) x]\n                        [(<= (string-ref x 8) (string-ref y 8)) x]\n\
    \                        [(<= (string-ref x 9) (string-ref y 9)) x]\n        \
    \                [else y])))])\n       (list \"sorted\" nums)])))\n</code>\n<|/\
    \ a tags=racket,scheme dscore=2 |>\n<| c |>\nThanks for your efforts. I think\
    \ it's a bit too complicated for a simple exercise. I guess I'll try with my original\
    \ function and write a new one using your suggestion.\n<|/ c |>\n<| c |>\nI've\
    \ edited my original post with a new function using a `map` instead of `append`.\n\
    <|/ c |>\n<| a tags=racket,scheme dscore=2 |>\nTry this one: \n<code>", "  (cond\
    \ [(number? (car numbers))\n         (sort_numbers (cdr numbers))]\n        [else\n\
    \         (append (car numbers)\n                 (sort_numbers (cdr numbers)))]))\n",
  "  (let ([numbers (split numbers \" \")]\n        [out \"\"])\n    (for/fold ([out\
    \ \"\"])\n              (([first nil])\n               ([rest numbers])\n    \
    \           ([rest '()]))\n    (let* ([num (if (< first 'zero) (first 'zero) (first\
    \ 'one))\n           [last (- num 'zero)])\n      (cond\n        ((string? first)\n\
    \         (append\n          (cons (if (< last 'zero) (last 'zero) (last 'one))\n\
    \                out\n                (cons (- last 'zero)\n                 \
    \     out)))\n        (else [out (cons num out)])))\n    out)))\n\n#lang racket\n",
  "  (if (null? numbers)\n      '()\n      (append (sort numbers\n               \
    \    (lambda (a b)\n                     (< (string-to-number a) (string-to-number\
    \ b))))\n              (sort_numbers (substring numbers (length (string-to-number\
    \ numbers))))))\n", "  (let loop ([nums numbers]\n             [current (substring\
    \ nums 0 0)])\n    (cond ((null? nums)\n           nums)\n          ((equal? (car\
    \ nums) 'zero)\n           (loop (rest nums)\n                   (append (car\
    \ nums)\n                           current)))\n          ((equal? (car nums)\
    \ 'one)\n           (loop (rest nums)\n                   (append (car nums)\n\
    \                           'one)))\n          ((equal? (car nums) 'two)\n   \
    \        (loop (rest nums)\n                   (append (car nums)\n          \
    \                 'two)))\n          ((equal? (car nums) 'three)\n           (loop\
    \ (rest nums)\n                   (append (car nums)\n                       \
    \    'three)))\n          ((equal? (car nums) 'four)\n           (loop (rest nums)\n\
    \                   (append (car nums)\n                           'four)))\n\
    \          ((equal? (car nums) 'five)\n           (loop (rest nums)\n        \
    \           (append (car nums)\n                           'five)))\n        \
    \  ((equal? (car nums) 'six)\n           (loop (rest nums)\n                 \
    \  (append (car nums)\n                           'six)))\n          ((equal?\
    \ (car nums) 'seven)\n           (loop (rest nums)\n                   (append\
    \ (car nums)\n                           'seven)))\n          ((equal? (car nums)\
    \ 'eight)\n           (loop (rest nums)\n                   (append (car nums)\n\
    \                           'eight)))\n          ((equal? (car nums) 'nine)\n\
    \           (loop (rest nums)\n                   (append (car nums)\n       \
    \                    'nine))))))\n", "  (let ([number-string (string-split (substring\
    \ numbers 0 (string-length numbers)))])\n    (reverse (sort\n               (lambda\
    \ (n) (if (number? n) (number n) (error \"sort_numbers: not a number\")))\n  \
    \             (lambda (n) (if (string=? \"zero\" n) 0 (if (string=? \"one\" n)\
    \ 1 (if (string=? \"two\" n) 2 (if (string=? \"three\" n) 3 (if (string=? \"four\"\
    \ n) 4 (if (string=? \"five\" n) 5 (if (string=? \"six\" n) 6 (if (string=? \"\
    seven\" n) 7 (if (string=? \"eight\" n) 8 (if (string=? \"nine\" n) 9))))))))))))))\n",
  "  (if (empty? numbers)\n      '()\n      (let ((min (first numbers))\n        \
    \    (max-number (rest numbers)))\n        (append (sort_numbers (rest numbers))\n\
    \                (list (cond ((< min (first numbers))\n                      \
    \       'zero)\n                       ((> min (first numbers))\n            \
    \             'one)\n                       ((< max (first numbers))\n       \
    \                  'two)\n                       ((> max (first numbers))\n  \
    \                       'three)\n                       ((< min (first numbers))\n\
    \                         'four)\n                       ((> min (first numbers))\n\
    \                         'five)\n                       ((< max (first numbers))\n\
    \                         'six)\n                       ((> max (first numbers))\n\
    \                         'seven)\n                       ((< min (first numbers))\n\
    \                         'eight)\n                       ((> min (first numbers))\n\
    \                         'nine)\n                       (else\n             \
    \            'nine))\n                      (list (string-append (number-string\
    \ min) (number-string max-number))))))))\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ your answer! Do you know how to change it so the code can accept input of any\
    \ number of numbers? For example, if you input 'three one five' it should return\
    \ 'one three five', if you input 'one two three four five' it should return 'one\
    \ two three four five'.\n<|/ c |>\n<| c |>\nThe code already works with your example.\
    \ Just pass it a list of numbers. I updated the answer to show how you could do\
    \ that.\n<|/ c |>\n<| c |>\nSorry, I didn't clarify my question. I was wondering\
    \ if you could make it work if you had something like 'one two three four five'?\
    \ Thanks again!\n<|/ c |>\n<| c |>\nThe code already works just fine with the\
    \ example you gave in your comment. Just pass it a list of numbers: `(sort_numbers\
    \ '(one two three four five))`\n<|/ c |>\n<| a tags=racket,numbers,string,sorting\
    \ |>\nHere is my solution:\n<code>", "  (let loop ([s numbers]\n             [out\
    \ '()])\n    (cond\n      [(null? s) (append out out)]\n      [else\n       (let\
    \ ([n (car s)])\n         (cond\n           [(null n) (loop (cdr s) out)] \n \
    \          [(< n (cdr s)) (loop (cdr s) (cons n out))]\n           [(= n (cdr\
    \ s)) (loop (cdr s) out)]))]))))\n", "  (string-append (sort_numbers numbers)\
    \ \" \"))\n", "  (map \n   (lambda (x) (if (string=? (number->string x) \"zero\"\
    ) \n                  (number->string x) \n                  (number->string x)))\n\
    \   (number->list numbers)))\n", "  (if (empty? numbers)\n      '()\n      (let\
    \ ([n1 (string->number (first numbers))\n              n2 (string->number (second\
    \ numbers))])\n        (cons (< (first n1) (first n2))\n               (sort_numbers\
    \ (rest numbers))))))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(digits-equal?\
    \ (rest numbers) 'zero) \"\"]\n    [else\n      (append (sort (first numbers)\
    \ (compare))\n               (sort_numbers (rest numbers))])]))\n", "  (define\
    \ numbers (remove-duplicates numbers))\n  (if (null? numbers)\n      '()\n   \
    \   (if (= (length numbers) 1)\n          (cons (first numbers) '())\n       \
    \   (cons (first numbers)\n                (sort_numbers (remove-duplicates \n\
    \                              (sort_numbers (remove-duplicates \n           \
    \                     (sort_numbers (remove-duplicates \n                    \
    \            (remove-duplicates numbers))))))))))\n", "  (cond\n    [(empty? numbers)\
    \ \"\"]\n    [(equal? (first numbers) \"zero\") \"zero\"]\n    [(equal? (first\
    \ numbers) \"one\") \"one\"]\n    [(equal? (first numbers) \"two\") \"two\"]\n\
    \    [(equal? (first numbers) \"three\") \"three\"]\n    [(equal? (first numbers)\
    \ \"four\") \"four\"]\n    [(equal? (first numbers) \"five\") \"five\"]\n    [(equal?\
    \ (first numbers) \"six\") \"six\"]\n    [(equal? (first numbers) \"seven\") \"\
    seven\"]\n    [(equal? (first numbers) \"eight\") \"eight\"]\n    [(equal? (first\
    \ numbers) \"nine\") \"nine\"]\n    [else (cons (first numbers) (sort_numbers\
    \ (rest numbers))) ]))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(equal?\
    \ (first numbers) 'zero) \"zero \"]\n    [(equal? (first numbers) 'one) \"one\
    \ \"]\n    [(equal? (first numbers) 'two) \"two \"]\n    [(equal? (first numbers)\
    \ 'three) \"three \"]\n    [(equal? (first numbers) 'four) \"four \"]\n    [(equal?\
    \ (first numbers) 'five) \"five \"]\n    [(equal? (first numbers) 'six) \"six\
    \ \"]\n    [(equal? (first numbers) 'seven) \"seven \"]\n    [(equal? (first numbers)\
    \ 'eight) \"eight \"]\n    [(equal? (first numbers) 'nine) \"nine \"]\n    [else\
    \ (cons (first numbers) (sort_numbers (rest numbers)))]))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append (sort_numbers (rest numbers)) (list (first numbers)))))\n",
  "  (string-append (sort (numbers-split numbers '(0 1 2 3 4 5 6 7 8 9))) \" \"))\n",
  "  (cond\n    [(empty? numbers) numbers]\n    [(equal? (first numbers) 'zero) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'one) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'two) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'three) (sort_numbers (rest numbers))]\n    [(equal? (first\
    \ numbers) 'four) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'five) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'six) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'seven) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'eight) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'nine) (sort_numbers (rest numbers))]\n    [else (cons (first\
    \ numbers) (sort_numbers (rest numbers))) ])))\n", "  (if (empty? numbers) '()\n\
    \      (let ((next (substring numbers (+ 0 (string-length numbers))))\n      \
    \      (current (string-append next (if (char=? (car next) #\\Space) '\\Space))))\n\
    \        (append (sort_numbers (substring numbers (string-length numbers))) current)\n\
    \      )\n  )\n)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=scheme,racket,sorting\
    \ |>\nHere is my solution in Scheme:\n<code>", "  (let ([s\n         (string->list\
    \ numbers)\n         lst\n         (reverse (map list-length string->list s))]\n\
    \        (set! lst '())\n        (set! numbers (remove-duplicates numbers))))\n\
    \  (loop for i from 0\n        when (or (>= (length lst) i)\n                \
    \ (>= (length lst) (+ i 1))\n                 (string=? (car lst) (car (cdr lst))))\n\
    \        do begin\n          (set! lst (append lst\n                         \
    \ (list (substring (list-ref numbers i) (cdr lst))))\n                (set! numbers\
    \ (remove-duplicates numbers))))))\n", "  (cond\n    [(empty? numbers)\n     empty]\n\
    \    [(equal? (first numbers) 'zero)\n     (cons (first numbers) (sort_numbers\
    \ (rest numbers)))]\n    [else\n     (let [smallest (first numbers)\n        \
    \   rest (rest (rest numbers))]\n       (cons smallest sort_numbers (sort_numbers\
    \ rest))))]))\n", "  (cond\n    [(string-empty? numbers) numbers]\n    [(number?\
    \ numbers)\n     (sort numbers (lambda (a b) (< (length a) (length b)))))]\n \
    \   [else (error \"Invalid input: sort_numbers: Expecting a string\")]))\n", " \
    \ ;; Create a hash table of numbers\n  (define (make-number-table n)\n    (define-values\
    \ (table hx)\n      (let loop ((n n) (acc '()))\n        (cond ((= n 0) (list\
    \ acc))\n              ((member (char n (car table)) '(zero one two three four\
    \ five six seven eight nine))\n               (loop (sub1 (char->integer (car\
    \ table))) (rest hx acc)))\n              (else (loop (sub1 (char->integer (car\
    \ n))) (rest hx (cons (car n) acc))))))\n    (list->string (sort (make-number-table\
    \ (length numbers)) <))))\n", "  (append (subsequence-sort (all-subsequences numbers\
    \ 0))\n          (subsequence-sort (all-subsequences numbers (length numbers)))))\n",
  "  (let ((sorted-numbers '()))\n    (for ([(num idx) (in-list numbers)]\n      \
    \    [((= idx (length (in-list numbers))) sorted-numbers)\n           (if (number?\
    \ num) (append sorted-numbers num) sorted-numbers)])\n      sorted-numbers)))\n",
  "  (define (make-tree node children sorted)\n    (if (equal? node 'zero)\n     \
    \ sorted\n      (let ([next (or (make-tree (substring numbers 0 2) children (cons\
    \ (car sorted) sorted)) (make-tree (substring numbers 2 4) children (cons (cdr\
    \ sorted) sorted)))])\n        (make-tree (substring numbers 1 3) children (cons\
    \ next sorted)))))\n  (make-tree 'zero '() (number->string numbers)))\n", "  (sort\
    \ numbers\n        (lambda (x y)\n          (< (string-to-integer x)\n       \
    \      (string-to-integer y)))))\n", "  (cond [(empty? numbers) \"\"]\n      \
    \  [(number? (first numbers)) \n         (sort_numbers (rest numbers))]\n    \
    \    [else (cons (first numbers) (sort_numbers (rest numbers)))]))\n", "  (string-join\
    \ (sort (map number->string (substring (numbers-split numbers))) :reverse '<)\n\
    \               \" \"))\n", "  (sort (map number->integer numbers) <))\n", " \
    \ (cond\n    [(empty? numbers) 'zero]\n    [(string-equal? (first numbers) 'zero)\
    \ (sort_numbers rest)]\n    [(string-equal? (first numbers) 'one) (sort_numbers\
    \ rest)]\n    [(string-equal? (first numbers) 'two) (sort_numbers rest)]\n   \
    \ [(string-equal? (first numbers) 'three) (sort_numbers rest)]\n    [(string-equal?\
    \ (first numbers) 'four) (sort_numbers rest)]\n    [(string-equal? (first numbers)\
    \ 'five) (sort_numbers rest)]\n    [(string-equal? (first numbers) 'six) (sort_numbers\
    \ rest)]\n    [(string-equal? (first numbers) 'seven) (sort_numbers rest)]\n \
    \   [(string-equal? (first numbers) 'eight) (sort_numbers rest)]\n    [(string-equal?\
    \ (first numbers) 'nine) (sort_numbers rest)]\n    [else (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]))\n", "  (cond\n    [(string-char? numbers #\\\
    Space)\n     (sort_numbers (string-slice-after numbers #\\Space))]\n    [(number?\
    \ numbers)\n     (sort (number->string numbers) (lambda (x) (number->string (sort\
    \ x #f)))) ]\n    [(number? numbers) (number->string (sort (number->string numbers)\
    \ (lambda (x) (number->string x #f)))) ]\n    [(number? numbers) (sort (number->string\
    \ (number->string numbers) (lambda (x) (number->string x #f))) #f)]))\n", "  (let\
    \ ([count (length numbers)]\n        [str (string-append '()\n               \
    \           (map numbers-to-string (string->list (number->string 0)))\n      \
    \                    (map numbers-to-string (string->list (number->string count))))])\n\
    \    (if (or (equal? (caar str) 'zero)\n            (equal? (caar str) 'nine))\n\
    \        (string->list str)\n        ;; If the first character is 'zero', and\
    \ the final character is\n        ;; 'nine', then we've reached the final character,\
    \ so we can return\n        ;; a string of 'nine's\n        (let ([str1 (substring\
    \ str 0 (min (length str) (ceiling (/ count 9))))]\n              [str2 (substring\
    \ str (ceiling (/ count 9)) (min (length str) (ceiling (/ count 9))))])\n    \
    \      (if (equal? (car (string->list str1)) 'zero)\n              (cons (string->list\
    \ (string->string 'nine))\n                    str2)\n              (cons str1\
    \ str2))))))\n", "  (cond\n    [(empty? numbers) '']\n    [(equal? (first numbers)\
    \ 'zero) (sort_numbers (rest (rest numbers)))]\n    [(equal? (first numbers) 'one)\
    \ (sort_numbers (rest (rest numbers)))]\n    [(equal? (first numbers) 'two) (sort_numbers\
    \ (rest (rest numbers)))]\n    [(equal? (first numbers) 'three) (sort_numbers\
    \ (rest (rest numbers)))]\n    [(equal? (first numbers) 'four) (sort_numbers (rest\
    \ (rest numbers)))]\n    [(equal? (first numbers) 'five) (sort_numbers (rest (rest\
    \ numbers)))]\n    [(equal? (first numbers) 'six) (sort_numbers (rest (rest numbers)))]\n\
    \    [(equal? (first numbers) 'seven) (sort_numbers (rest (rest numbers)))]\n\
    \    [(equal? (first numbers) 'eight) (sort_numbers (rest (rest numbers)))]\n\
    \    [(equal? (first numbers) 'nine) (sort_numbers (rest (rest numbers)))]\n \
    \   [else (cons (first numbers) (sort_numbers (rest (rest numbers))))]\n  ))\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nHere are some more interesting ideas\
    \ that I thought of.\n<code>", "  (cond [(numbers =? 'zero) (list numbers)]\n\
    \        [(numbers =? 'one) (list numbers numbers)]\n        [(numbers =? 'two)\
    \ (list numbers numbers numbers)]\n        [(numbers =? 'three) (list numbers\
    \ numbers numbers numbers)]\n        [(numbers =? 'four) (list numbers numbers\
    \ numbers numbers numbers)]\n        [(numbers =? 'five) (list numbers numbers\
    \ numbers numbers numbers numbers)]\n        [(numbers =? 'six) (list numbers\
    \ numbers numbers numbers numbers numbers numbers)]\n        [(numbers =? 'seven)\
    \ (list numbers numbers numbers numbers numbers numbers numbers numbers)]\n  \
    \      [(numbers =? 'eight) (list numbers numbers numbers numbers numbers numbers\
    \ numbers numbers numbers)]\n        [(numbers =? 'nine) (list numbers numbers\
    \ numbers numbers numbers numbers numbers numbers numbers numbers)]\n        [else\
    \ (error 'sort_numbers 'numbers)]))\n", "  (cond\n    [(empty? numbers) '']\n\
    \    [(number? (first numbers)) (first numbers)]\n    [else (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]))\n", "  (let ([numbers (numbers-in-order numbers)])\n\
    \    (string-join numbers)))\n", "  (cond ((null? numbers) '())\n        ((string-equal?\
    \ (car numbers) 'zero) '())\n        ((string-equal? (car numbers) 'one) '(1))\n\
    \        ((string-equal? (car numbers) 'two) '(2 1))\n        ((string-equal?\
    \ (car numbers) 'three) '(3 2 1))\n        ((string-equal? (car numbers) 'four)\
    \ '(4 3 2 1))\n        ((string-equal? (car numbers) 'five) '(5 4 3 2 1))\n  \
    \      ((string-equal? (car numbers) 'six ) '(6 5 4 3 2 1))\n        ((string-equal?\
    \ (car numbers) 'seven) '(7 6 5 4 3 2 1))\n        ((string-equal? (car numbers)\
    \ 'eight ) '(8 7 6 5 4 3 2 1))\n        ((string-equal? (car numbers) 'nine) '(9\
    \ 8 7 6 5 4 3 2 1))\n        (else (cons (car (sort_numbers (cdr numbers)))\n\
    \                  (sort_numbers (cdr (sort_numbers (cdr numbers)))))))\n", " \
    \ (define (helper-sort start end)\n    (if (= start end)\n        '()\n      \
    \  (if (numbers-greater-than numbers (rest numbers))\n            (cons (first\
    \ numbers) (helper-sort (+ start 1) end))\n            (helper-sort (+ start 1)\
    \ end))))\n\n  (if (numbers-greater-than numbers '') '()\n      (helper-sort 0\
    \ length numbers)))\n", "  (if (null? numbers)\n      '()\n      (append (sort_numbers\
    \ (split-string (first numbers)\n                                        #\\Space))\n\
    \                (sort_numbers (rest numbers)))))\n", "  (match numbers\n    [(empty?\
    \ numbers) \"\"]\n    [(equal? (first numbers) 'zero) (sort_numbers (rest (split\
    \ (second numbers) #\\Space)))]\n    [(equal? (first numbers) 'one) (sort_numbers\
    \ (rest (split (second numbers) #\\Space)))]\n    [(equal? (first numbers) 'two)\
    \ (sort_numbers (rest (split (second numbers) #\\Space)))]\n    [(equal? (first\
    \ numbers) 'three) (sort_numbers (rest (split (second numbers) #\\Space)))]\n\
    \    [(equal? (first numbers) 'four) (sort_numbers (rest (split (second numbers)\
    \ #\\Space)))]\n    [(equal? (first numbers) 'five) (sort_numbers (rest (split\
    \ (second numbers) #\\Space)))]\n    [(equal? (first numbers) 'six) (sort_numbers\
    \ (rest (split (second numbers) #\\Space)))]\n    [(equal? (first numbers) 'seven)\
    \ (sort_numbers (rest (split (second numbers) #\\Space)))]\n    [(equal? (first\
    \ numbers) 'eight) (sort_numbers (rest (split (second numbers) #\\Space)))]\n\
    \    [(equal? (first numbers) 'nine) (sort_numbers (rest (split (second numbers)\
    \ #\\Space)))]\n    [else (cons (first numbers)\n                (sort_numbers\
    \ (rest (split (second numbers) #\\Space)))\n                )]))\n", "  (if (null?\
    \ numbers)\n      '()\n      (let ([parts\n              (remove-if (lambda (x)\n\
    \                          (and (integer? x) (<= x 9)))\n                    \
    \  (split-string numbers))])\n        (if (null? (length parts))\n           \
    \ numbers;\n            (append (sort_numbers (first parts))\n               \
    \     (sort_numbers (rest (rest parts)))))))\n", "  (define (helper num)\n   \
    \ (cond ((number? (string->list num)) (string->list num))\n          ((equal?\
    \ (number->string num) \"zero\") \"zero\")\n          ((equal? (number->string\
    \ num) \"one\") \"one\")\n          ((equal? (number->string num) \"two\") \"\
    two\")\n          ((equal? (number->string num) \"three\") \"three\")\n      \
    \    ((equal? (number->string num) \"four\") \"four\")\n          ((equal? (number->string\
    \ num) \"five\") \"five\")\n          ((equal? (number->string num) \"six\") \"\
    six\")\n          ((equal? (number->string num) \"seven\") \"seven\")\n      \
    \    ((equal? (number->string num) \"eight\") \"eight\")\n          ((equal? (number->string\
    \ num) \"nine\") \"nine\")\n          (else (string-append num \"\n\"))))\n  (let\
    \ loop ((input '())\n             (result '()))\n    (cond ((null? input) (string->list\
    \ result))\n          ((equal? (string->list input) \"zero\") '())\n         \
    \ ((equal? (string->list input) \"one\") '(\"one\"))\n          ((equal? (string->list\
    \ input) \"two\") '(\"two\"))\n          ((equal? (string->list input) \"three\"\
    ) '(\"three\"))\n          ((equal? (string->list input) \"four\") '(\"four\"\
    ))\n          ((equal? (string->list input) \"five\") '(\"five\"))\n         \
    \ ((equal? (string->list input) \"six\") '(\"six\"))\n          ((equal? (string->list\
    \ input) \"seven\") '(\"seven\"))\n          ((equal? (string->list input) \"\
    eight\") '(\"eight\"))\n          ((equal? (string->list input) \"nine\") '(\"\
    nine\"))\n          (else\n           (let ((val (car input)))\n             (if\
    \ (null? (cdr input))\n               (helper val)\n               (loop (cdr\
    \ input) (helper (cons val result)))))\n           (loop '() '()))))\n  (string->list\
    \ result))\n", "  (let ([numbers\n          (tokenize (join \" \" (map (string->number\
    \ numbers) string->symbols))\n                      #\\Space)\n          (symbols\
    \ (map (string->symbol numbers) string->symbols))\n          (length (length numbers))]\n\
    \        (lengths (cycle (length numbers)))\n        (out-str '())\n        (lengths-ptr\
    \ 0)))\n    (do ([i lengths]\n         ([s symbols]\n          (while (>= i 0)\n\
    \            (let ([a (substring numbers 0 i)]\n                  [sa (a-sort\
    \ s a)]\n                  [sb (b-sort s a)]\n                  [sc (c-sort s\
    \ a)]\n                  [sd (d-sort s a)]\n                  [se (e-sort s a)]\n\
    \                  [sf (f-sort s a)]\n                  [sg (g-sort s a)]\n  \
    \                [sh (h-sort s a)]\n                  [si (i-sort s a)])\n   \
    \           (if (null? sa)\n                  (append out-str a)\n           \
    \       (if (> (length sb) length)\n                      (concat out-str (list\
    \ (b-v-sort sb si))\n                              (list (c-v-sort sc sd))\n \
    \                             (list (e-v-sort se sf))\n                      \
    \        (list (g-v-sort sh sg))\n                              (list (h-v-sort\
    \ sh si))\n                              (list (i-v-sort si sb)))\n          \
    \            (concat out-str (list (b-v-sort sb si))\n                       \
    \       (list (c-v-sort sc sd))\n                              (list (e-v-sort\
    \ se sf))\n                              (list (g-v-sort sh sg))\n           \
    \                   (list (h-v-sort sh si))\n                              (list\
    \ (i-v-sort si sb)))))\n              (set! i (- i 1)))\n            (set! i 0))\n\
    \         [s out-str])\n      ((null? s) (printf \"SORTED NUMBERS: %s\" (string->symbols\
    \ out-str)))\n    (println \"SORTED NUMBERS: \" out-str))\n", "  (cond [(empty?\
    \ numbers) 'empty]\n        [(equal? 'empty (first numbers)) 'empty]\n       \
    \ [(equal? 'empty (rest numbers)) 'empty]\n        [else\n         (let [[number\
    \ remainder rest] numbers\n               [result 'empty]\n               [counter\
    \ 1]]\n           (cond [(empty? numbers)\n                  (cond [(= counter\
    \ 0) result]\n                        [(= counter 9) result]\n               \
    \         [else (list-append (number-sort (substring remainder 0) (substring remainder\
    \ 1))\n                                          (number-sort (substring rest\
    \ 0) (substring rest 1)))])))]\n        ))\n", "  (let ([chars '(zero one two\
    \ three four five six seven eight nine)])\n    (build-list 1000000 (lambda (x)\n\
    \                          (apply append (map #(substring numbers (quotient x\
    \ 10) 10) (quotient x 10))\n                                     chars)))))\n",
  "  (cond\n    ((string? numbers)\n     (sort-numbers->string numbers))\n    ((number?\
    \ numbers)\n     (sort-numbers->string numbers))\n    ((null? numbers)\n     (printf\
    \ \"Empty string\\n\")\n     (sort numbers >)))) ; default case is to return the\
    \ original numbers in sorted order\n", "  (cond\n    [(empty? numbers) '']\n \
    \   [(equal? numbers '') '']\n    [else (cond\n            [(equal? (car numbers)\
    \ 'zero') '']\n            [(equal? (car numbers) 'one') '']\n            [(equal?\
    \ (car numbers) 'two') '']\n            [(equal? (car numbers) 'three') '']\n\
    \            [(equal? (car numbers) 'four') '']\n            [(equal? (car numbers)\
    \ 'five') '']\n            [(equal? (car numbers) 'six') '']\n            [(equal?\
    \ (car numbers) 'seven') '']\n            [(equal? (car numbers) 'eight') '']\n\
    \            [(equal? (car numbers) 'nine') '']\n            [else (sort_numbers\
    \ (cdr numbers))]\n           )]))", "  (let ((sorted '()))\n    (for/or ((n numbers)\n\
    \              (temp nil))\n      (if (string=? (string-ref n 0) \"-\") ; Ignore\
    \ dashes\n          (if (string=? (string-ref n 1) \"-\")\n              (begin\n\
    \                (set! temp (append sorted (list (string-ref n 0) (string-ref\
    \ n 1) (list-ref sorted (- 2 1)))))\n                (set! n (string-ref n 2))\n\
    \                (set! numbers (append n (string-split (substring numbers 2))))\n\
    \                (set! numbers (append numbers (list (substring n 3))))\n    \
    \            (set! n (string-split (substring numbers (length numbers))))\n  \
    \              (set! numbers (append numbers (list-ref n 0)))\n              \
    \  (set! n (string-split (substring numbers (length numbers))))\n            \
    \    (set! numbers (append numbers (list-ref n 0)))\n                (set! n (string-split\
    \ (substring numbers (length numbers))))\n                (set! numbers (append\
    \ numbers (list-ref n 0))))\n          (if (string=? (string-ref n 0) \"+\") ;\
    \ Ignore plusses\n              (begin\n                (set! temp (append sorted\
    \ (list (string-ref n 0) (string-ref n 1) (list-ref sorted (- 2 1)))))\n     \
    \           (set! n (string-ref n 2))\n                (set! numbers (append n\
    \ (string-split (substring numbers 2))))\n                (set! numbers (append\
    \ numbers (list (substring n 3))))\n                (set! n (string-split (substring\
    \ numbers (length numbers))))\n                (set! numbers (append numbers (list-ref\
    \ n 0)))\n                (set! n (string-split (substring numbers (length numbers))))\n\
    \                (set! numbers (append numbers (list-ref n 0)))\n            \
    \    (set! n (string-split (substring numbers (length numbers))))\n          \
    \      (set! numbers (append numbers (list-ref n 0))))\n          (if (string=?\
    \ (string-ref n 0) \"#\") ; Ignore hashes\n              (begin\n            \
    \    (set! temp (append sorted (list (string-ref n 0) (string-ref n 1) (list-ref\
    \ sorted (- 2 1)))))\n                (set! n (string-ref n 2))\n            \
    \    (set! numbers (append n (string-split (substring numbers 2))))\n        \
    \        (set! numbers (append numbers (list (substring n 3))))\n            \
    \    (set! n (string-split (substring numbers (length numbers))))\n", "  (sort\
    \ numbers\n        #'<\n        #'equal))\n", "  (sort\n   (lambda (n)\n     (if\
    \ (number? n)\n         (cons n '())\n         (cons n (number->string n))))\n\
    \   (string->list numbers)))\n", "  (let ([current-number (first numbers)])\n\
    \    (cond\n      [(number? current-number) numbers]\n      [else (cons (first\
    \ numbers)\n                  (sort_numbers (rest numbers)))]\n    )\n  )\n)\n",
  "  (if (empty? numbers)\n      '()\n      (append (sort_numbers (substring numbers\
    \ 0 -1))\n                (list numbers)\n                (sort_numbers (substring\
    \ numbers (length numbers) -1))))\n", "  (sort numbers < (lambda (a b)\n     \
    \               (< (string->number a) (string->number b))))))\n</code>\n<|/ a\
    \ tags=racket,scheme dscore=2 |>\n<| c |>\nIf you're going to use Racket, you\
    \ may want to look at [the sort function](http://docs.racket-lang.org/reference/sort.html).\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n#lang racket\n", "  (if (equal? numbers '())\
    \ '()\n      (append (sort_numbers (split-string numbers (substring numbers 0\
    \ (string-length numbers)))))\n      (cons (sort (split-string numbers (substring\
    \ numbers 0 (string-length numbers))) <)\n            (sort_numbers (split-string\
    \ numbers (substring numbers (string-length numbers) (length numbers))))))", " \
    \ (let ([sorted (make-array (length numbers)\n                            :element-type\
    \ 'string\n                            :initial-element 'zero)])\n    (loop for\
    \ i from 0 to (length numbers)\n         for j from 0 to (length sorted)\n   \
    \      when (and (numbers = (reverse sorted))\n                  (>= i (length\
    \ numbers))\n                  (< j (length sorted)))\n         do (set! sorted\n\
    \                (append (substring sorted j 1)\n                        (substring\
    \ numbers i 1)))\n         finally (return sorted))))\n", "  (cond\n    [(empty?\
    \ numbers) \"\"]\n    [(number? (car numbers)) (sort_numbers (cdr numbers))]\n\
    \    [else (cons (car numbers)\n              (sort_numbers (cdr numbers)))]))\n",
  "  (let* ([numbers (string->list numbers)\n         (min (first numbers))\n    \
    \     (max (rest numbers))\n         (sortable-numbers (string->list (sort (lambda\
    \ (x) (- x min)) (lambda (x) (+ x max)) numbers)))]\n         (space-separated\
    \ (apply append (map (lambda (x) (apply str (interpose \" \" x))) sortable-numbers))))\n\
    \    space-separated))\n</code>\nThe code works by using the string->list function\
    \ to convert the input to a list. The list comprehension creates a list of lists,\
    \ where the inner list has one number in the correct order. The outer list flattens\
    \ this list of lists back into a single list of strings (space-separated list).\n\
    <|/ a tags=racket,scheme |>\n<| a dscore=2 |>\nThe answer is that you can do this\
    \ in Scheme, but it's more awkward than the other solutions.\nIf you know that\
    \ you're going to be sorting only a small set of numbers, you can just use the\
    \ sort function, and give it a custom comparator. The way this is implemented\
    \ is that it goes through every element in the list and then compares them one\
    \ by one to the first one, and if there's a difference it returns #t, otherwise\
    \ it returns #f.\nHere is an example that sorts a simple list of numbers from\
    \ low to high without changing their order in the list:\n<code>", "  (cond [(empty?\
    \ numbers) '']\n        [(string-char-equal? 'z' (first numbers)) 'z']\n     \
    \   [else (cons (first numbers) (sort_numbers (rest numbers))))]))\n", "  (cond\n\
    \    [(string? numbers)\n     (append (sort\n               (remove-if (string=?\
    \ 'zero) (remove-if (string=? 'nine) numbers)))\n             (string=? 'one)\
    \ (reverse numbers))]\n    [else\n     (remove-if (string=? 'zero) (remove-if\
    \ (string=? 'nine) (numbers))) (reverse numbers)]))\n", "  (let ((sorted (substring\
    \ numbers 0 (string-length numbers))))\n    (string-join (sort (sort (split sorted\
    \ #\\Space :key 'string) \n                           #(<) (first %)) \n     \
    \                    (lambda (x) (second x))) \n                  #\\Space :from\
    \ 0))))\n", "  (match numbers\n    ['#:(zero)\n     '#:(two)\n     '#:(three)\n\
    \     '#:(four)\n     '#:(five)\n     '#:(six)\n     '#:(seven)\n     '#:(eight)\n\
    \     '#:(nine)\n     '#:(ten)\n     #t '#:(broken)]\n    '#:(broken)\n    [(cons\
    \ '#:(zero) '#:(one))\n     (cons '#:(two) '#:(three))\n     (cons '#:(four) '#:(five))\n\
    \     (cons '#:(six) '#:(seven))\n     (cons '#:(eight) '#:(nine))\n     (cons\
    \ '#:(ten) '#:(ten))\n     '#t '#:(numbers)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
