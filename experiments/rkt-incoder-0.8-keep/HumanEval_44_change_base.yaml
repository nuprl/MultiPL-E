name: HumanEval_44_change_base
language: rkt
prompt: "#lang racket\n\n;; Change numerical base of input number x to base.\n;; return\
  \ string representation after the conversion.\n;; base numbers are less than 10.\n\
  ;; >>> change_base(8, 3)\n;; '22'\n;; >>> change_base(8, 2)\n;; '1000'\n;; >>> change_base(7,\
  \ 2)\n;; '111'\n(define (change_base x base)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n\
  \    (check-equal? (candidate 8 3) \"22\")\n    (check-equal? (candidate 9 3) \"\
  100\")\n    (check-equal? (candidate 234 2) \"11101010\")\n    (check-equal? (candidate\
  \ 16 2) \"10000\")\n    (check-equal? (candidate 8 2) \"1000\")\n    (check-equal?\
  \ (candidate 7 2) \"111\")\n    (check-equal? (candidate 2 3) \"2\")\n    (check-equal?\
  \ (candidate 3 4) \"3\")\n    (check-equal? (candidate 4 5) \"4\")\n    (check-equal?\
  \ (candidate 5 6) \"5\")\n    (check-equal? (candidate 6 7) \"6\")\n    (check-equal?\
  \ (candidate 7 8) \"7\")\n))\n\n(test-humaneval)"
completions: ["  (cond [(< base 10)\n         (string->number\n          (number->string\
    \ x (base-number base)))]\n        [else\n         (string->number\n         \
    \ (number->string x (base-10 (base-number base))))]))\n", "  (cond [(= x 0)\n\
    \         '0\n         ]\n        [(< base 10)\n         (string x)\n        \
    \ ]\n        [(= base 10)\n         (string x)\n         ]\n        [else\n  \
    \       (string-append (change_base (/ x base) (+ base base))\n              \
    \          (change_base x (- base base)))\n         ]\n        ))\n", "  (cond\
    \ [(< base 10)\n         (to-string (change-base-x (to-number (x)) base))\n  \
    \       ]\n        [(< base 2)\n         (to-string x)\n         ]\n        [else\n\
    \         (append (if (even? base)\n                     (- base)\n          \
    \           base)\n                  (change-base-x x (sub1 base)))\n        \
    \ ]\n       ))", "  (if (= base 10) \n      (cond [(< x 10) \n             (*\
    \ base (+ 10 (modulo x 10)))]\n            [else x]))\n  (cond [(> base 10) \n\
    \         (string-append \"0\" (change_base (/ x base) base))]\n        [else\
    \ (* base (change_base x base))]))\n", "  (define (to_string x base)\n    (if\
    \ (= base 0)\n        x\n        (concat (string-append \"10\" (to_string x (-\
    \ base 1))))))\n  (define (to_int x base)\n    (string->number ((cond [(= base\
    \ 0)\n                              x (* 10 x)]\n                            \
    \ [(< base 10)\n                              (* 10 base)\n                  \
    \            (+ x 10)])\n                        base)))\n  (define (to_fixed-point\
    \ x base)\n    (string->fixed-point (to_int x base)))\n  (to-string x base))\n",
  "  (+ x base))\n", "  (string->number (string->string x) (string->string (+ x base)\n\
    \                                        (substring (number->string x) 0 -1))))\n",
  "  (cond\n    [(zero? x) (list '())]\n    [(negative? x) (list '-)]\n    [else\n\
    \     (let ([s (quotient x base)])\n       (if (= s 0)\n         (list x)\n  \
    \       (list (* base s) (change_base s (- base s)))\n       )\n     )]))\n",
  "  (modulo-base (* x base) base))\n", "  (cond\n    [(< base 10) \n     (string->number\
    \ x (+ base base))\n     (string->number x (- base base))\n     (string->number\
    \ x base)]\n    [else (error \"Invalid Base\")]))\n", "  (let ([len (string->length\
    \ (string->string x)))]\n        (if (<= len 2)\n            (string->string (remainder\
    \ (quotient x base) base))\n          (if (<= len 4)\n              (string->string\
    \ (remainder (quotient x (quotient base 2)) base)\n                          \
    \     (quotient x base))\n            (if (<= len 6)\n                (string->string\
    \ (remainder (quotient x (quotient base 3)) base)\n                          \
    \       (quotient x base)\n                                 (quotient x base))\n\
    \                (if (<= len 8)\n                    (string->string (remainder\
    \ (quotient x (quotient base 4)) base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient x base)\n\
    \                                     (quotient x base)\n                    \
    \                 (quotient x base)\n                                     (quotient\
    \ x base)\n                                     (quotient x base)\n          \
    \                           (quotient x base)\n                              \
    \       (quotient x base)\n                                     (quotient ", " \
    \ (number->string (quotient x (expt base 10))))\n", "  (if (< x 10)\n      (number->string\
    \ x)\n      (let ([y (/ x base)])\n        (if (= y 0)\n            (string->number\
    \ ((+ x base) base))\n            (number->string (+ (* base y) (* x base)))))))\n",
  "  (if (= base 10)\n      (list x)\n      (if (= base 10)\n          (cons x (list\
    \ x))\n          (cons (string->number (string->string x) (- base 1)) (list x)))))\n",
  "  (cond [(< base 10) (x)\n         (cons #\\a x (change_base\n                \
    \      (quotient x base)\n                      base))\n         (cons #\\b x\
    \ (change_base\n                      (quotient x base)\n                    \
    \  base))\n         (cons #\\c x (change_base\n                      (quotient\
    \ x base)\n                      base))\n         (cons #\\d x (change_base\n\
    \                      (quotient x base)\n                      base))\n     \
    \    (cons #\\e x (change_base\n                      (quotient x base)\n    \
    \                  base))\n         (cons #\\f x (change_base\n              \
    \        (quotient x base)\n                      base))\n         (cons #\\g\
    \ x (change_base\n                      (quotient x base)\n                  \
    \    base))\n         (cons #\\h x (change_base\n                      (quotient\
    \ x base)\n                      base))\n         (cons #\\i x (change_base\n\
    \                      (quotient x base)\n                      base))\n     \
    \    (cons #\\j x (change_base\n                      (quotient x base)\n    \
    \                  base))\n         (cons #\\k x (change_base\n              \
    \        (quotient x base)\n                      base))\n         (cons #\\l\
    \ x (change_base\n                      (quotient x base)\n                  \
    \    base))\n         (cons #\\m x (change_base\n                      (quotient\
    \ x base)\n                      base))\n         (cons #\\n x (change_base\n\
    \                      (quotient x base)\n                      base))\n     \
    \    (cons #\\o x (change_base\n                      (quotient x base)\n    \
    \                  base))\n         (cons #\\p x (change_base\n              \
    \        (quotient x base)\n                      base))\n         (cons #\\q\
    \ x (change_base\n                      (quotient x base)\n                  \
    \    base))\n         (cons #\\r x (change_base\n                      (quotient\
    \ x base)\n                      base))\n         (cons #\\s x (change_base\n\
    \                      (quotient x base)\n                      base))\n     \
    \    (cons #\\t x (change_base\n                      (quotient x base)\n    \
    \                  base))\n         (cons #\\v x (change_base\n              \
    \        (quotient x base)\n                      base))\n         (cons #\\u\
    \ x (change_base\n                      (quotient x base)\n                  \
    \    base))\n         (cons #\\w x (change_base\n                      (quotient\
    \ x base)\n                      base))", "  (+ (string->number x (base-size base))\n\
    \     (* base (number->string x))))\n", "  (if (< base 10)\n      (* x base)\n\
    \      (string-append (modulo-base x base) (number->string x))))\n", "  (/ (mod\
    \ x base) base))\n", "  (number->string (regexp-match x \"^(?:\\\\(?(0)|0\\\\\
    )?[0-7]+|[1-9]\\\\d*)(?:\\\\.\\\\d*)?$\"\n                                (lambda\
    \ (y) (number->string y base))))))\n", "  (cond\n    [(< x 10) (string-append\
    \ (number->string x) (string->string base))\n     (cond\n       [(< base 10)\n\
    \        (string->string (number->string x))\n        (string->string base)]\n\
    \       [else\n        (change_base (quotient x base) (quotient base base))]))]\n\
    \    [else (error 'bad-args '(x base))]\n    )\n  )\n", "  (if (< base 10) \n\
    \      (+ (mod x base) base)\n      (quotient x base)))\n", "  (if (< base 10)\n\
    \      (cons (mod x base) (change_base (/ x base) base))\n      '()\n  ))\n",
  "  (/ x (expt base 10)))\n", "  (define (helper x base)\n    (if (zero? x) '()\n\
    \      (cons (digit-char (quotient x base))\n            (helper (quotient x base)\
    \ base))))\n  (helper x base))\n", "  (if (= base 1)\n      x\n      (change_base\n\
    \       (quotient x base)\n       base)))\n", "  (if (zero? x)\n      '0\n   \
    \   (+ x (* base (quotient x base)))))\n", "  (cond\n    [(zero? x) '()]\n   \
    \ [(< base 10)\n     (reverse (format '0 x))\n     (reverse (format '0 x))]\n\
    \    [else (cons (modulo-by-remainder (+ base base) (+ x base)) (change_base x\
    \ (+ base base)))]))\n", "  (cond\n    [(= base 10) (string->number x)\n     (cond\n\
    \       [(zero? (remainder x 10)) (quotient x 10)]\n       [else (string 0)]))]\n\
    \    [(< base 10) (string->number x)\n     (cond\n       [(= base 10) (string->number\
    \ x)\n        (cond\n          [(zero? (remainder x 10)) (quotient x 10)]\n  \
    \        [else (string 0)])]\n       [else (string 0)])]\n    [else (string 0)]))\n",
  "  (cond\n    [(< x 10) (number->string x))\n    [(= base 0) (string-append \"0\"\
    \ string->number (string->list x))]\n    [else (+ base\n               (change_base\n\
    \                (quotient\n                   (* 10 (string->number (string->list\
    \ x)))\n                 base)\n               x)]))\n", "  (let ((number (string->number\
    \ x))\n        (factor (cons-ref (list 10) (quotient number base))))\n    (if\
    \ (null? factor)\n        '()\n        (format nil \"~a\" (quotient (* number\
    \ factor) base)\n              (modulo (* number factor) base)))))\n", "  (cond\
    \ [(= base 10) (if (= x 0) '0 (+ x 1))]\n        [(even? base) (cond [(< x 0)\
    \ (cons 0 (change_base (-x) (/ base 10)))]\n                        [(< x 1) (cons\
    \ (- x base) (change_base (x) (/ base 10)))]\n                        [else (cons\
    \ x '())])]\n        [else (cons x (change_base (- x) (/ base 10)))]))\n</code>\n\
    <|/ a tags=scheme,racket |>\n<| c |>\nThanks for your answer. I'm very new to\
    \ the racket language so I'm still trying to figure out how to implement what\
    \ you posted. The base function works well. Your solution is almost perfect, it\
    \ only needs to return the number if it isn't a multiple of 10.\n<|/ c |>\n<|\
    \ c |>\n: I don't know how to fix your `change-base` function to solve the problem.\n\
    <|/ c |>\n<| c |>\nThe correct solution is posted below (by John Bollinger), but\
    \ I've learned quite a bit from your solution as well as the instructor of this\
    \ problem :-).\n<|/ c |>\n<| a |>\nSince you mentioned that you are new to Racket,\
    \ you should read up on how to structure your program. Some things to keep in\
    \ mind are the following:\n\nA function is a function which can take other functions\
    \ as arguments. In a Scheme function, you pass the arguments to the function in\
    \ parentheses, like so: f (a b c). \nAll variables used in a procedure must be\
    \ bound to values before you invoke the procedure. For example, if you have a\
    \ procedure that takes two arguments, a number and a power, and you want to print\
    \ the number to the power, you would have to first bind the number to a name with\
    \ the let statement, before you invoke the procedure: let (number 10) (powers\
    \ 5). \nA procedure can either return a value, or print a value (using print!\
    \ or return!). If you use return!, the value that the procedure returns is stored\
    \ in the variable you call 'return' on. The variable you call 'return' on is referred\
    \ to as the 'result' of the procedure. The value that is stored in the variable\
    \ is whatever value the procedure returned. \nIf you invoke a procedure, you can\
    \ optionally specify a result variable, that will contain the result of the procedure.\
    \ By default, nothing is returned and the procedure is invoked with no result\
    \ variable specified (this may be used to print a message, but not a return statement).\
    \ \nYou can also use multiple procedure invocations in one line. \nIf you invoke\
    \ a procedure with multiple arguments, the arguments are passed in pairs, and\
    \ the procedure is invoked with the first value as the 1st argument and the second\
    \ as the 2nd ", "  (if (= base 0)\n      x\n      (floor (x / base) * base)))\n",
  "  (cond\n    [(< x 10) (string-append (make-digit base (digit-value x)))]\n   \
    \ [else (make-digit (digit-value base) (make-digit (digit-value x) 0))]))\n",
  "  (string->number\n   (numerator/numerator x (/ base 10))))\n", "  (cond\n    [(<\
    \ base 10) (string->number (string->symbol (symbol->string x)))]\n    [else (change_base\
    \ (quotient x base) (quotient (modulo x base) base))]))\n", "  (cond\n    [(number?\
    \ x) (number->string x)\n     (cond [(= base 0) (number->string x))]\n       \
    \    [else (cond [(< base 10)\n                         (number->string\n    \
    \                      (number->string\n                            (number->list\
    \ (number->integer x (- base 10))))\n                        (* base (number->list\
    \ (number->integer x (- base 10))))])])]\n    [else '???']))", "  (if (< x 10)\n\
    \      (+ x (string->int (make-string\n                        '0\n          \
    \              (- base (string-length x))))\n          (make-string\n        \
    \    '0\n            (- base (string-length x))))\n      (+ (make-string\n   \
    \        '1\n           (- base (string-length x))))))\n", "  (cond\n    [(< x\
    \ 10) \n     (string-append (number->string x) (string->number base))] \n    [else\
    \ \n     (cond [(< base 10) (change_base x (- base 10))]\n           [(< base\
    \ 10) (change_base x (+ base 10))])]))\n", "  (if (< base 10)\n      (* x base)\n\
    \      (floor (/ x base)))) ;; Scheme doesn't have floor\n</code>\nAs for what\
    \ it means to \"change\" a number to a different base:\nA base number is a number\
    \ represented as a set of digits, where each digit is in its proper place (0-9,\
    \ 10-19, 20-29...). For example, 10 could be represented as a set {1, 0} because\
    \ that's how binary numbers are represented in numbers like base-10 (base-2 would\
    \ be {1, 011}). You can easily go from the base number to a base-10 number by\
    \ just adding the digits in the set (since we're working in decimal numbers this\
    \ doesn't matter too much, because we already have that right). For example, for\
    \ base 8, we could do the following:\n<code>\n> (+ 8 10)\n13\n</code>\nBut for\
    \ base 2 this doesn't make much sense because binary just has two digits in each\
    \ position.\nIn general, to convert between bases we need to add the digits in\
    \ the correct position. For example, if we need to change base 10 to base 20,\
    \ we must add the digits in the correct place, which means we'll need to add 10\
    \ in place 1 in the base 10 number, and 2 in place 3 in the base 2 number:\n<code>\n\
    > (+ (list 10 2) 10)\n20\n</code>\n<|/ a |>\n<| c |>\nThat `change_base` function\
    \ does not work for negative base numbers. `(change_base (-2 3) 2)` returns `0`,\
    \ not `-3`.\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers, because\
    \ base 10 numbers are positive. Negative numbers are represented in base-10, where\
    \ -1 is represented with a set {-1, 0} and -10 is represented as {1, 0}.\n<|/\
    \ c |>\n<| c |>\nI updated my answer to account for negative numbers. I believe\
    \ this is what you were getting at.\n<|/ c |>\n<| c |>\nI agree that `change_base`\
    \ works well for positive numbers. But I wonder how `change_base` works for negative\
    \ numbers. According to [Wikipedia on Binary numbers](https://en.wikipedia.org/wiki/Binary_number#Negative_numbers)\
    \ negative numbers have a sign bit and a binary digit that represents the magnitude\
    \ of the number.\n<|/ c |>\n<| c |>\nNegative numbers are represented in base\
    \ 10, with one more binary digit (0 to 9). In base 10, -10 would be represented\
    \ as {1, 0, -1}. Likewise, -3 is represented as {1, 0, 0, -1, 3}. Notice that\
    \ the binary digits after the negative sign are all 0s, because they are the magnitude\
    \ of the number.\n", "  (if (>= base 10)\n      (cons (mod x base) (change_base\
    \ (quotient x base) base))\n      (list (+ x (* (- base (modulo x base)) base)))))\n",
  "  (let ([digs (sub1 (remainder x base))])\n    (cond\n      [(= base 10) (append\
    \ \"0\" digs)]\n      [(< base 10) (append \"0\" digs)\n       (+ (+ (* base (+\
    \ base 1)) (first digs))\n           (list (second digs)))]\n      [else (list\
    \ digs)]))))\n", "  (cond\n    [(< base 10)\n     (cond [(< x 0)\n           \
    \ '0]\n           [else (append (number->string (x (- base 10)))\n           \
    \            (number->string (quotient x base)))]\n          )\n     ]\n    [else\n\
    \     (cond [(< x 0)\n            '0]\n           [else (number->string (quotient\
    \ x base))])]))\n", "  (if (= base 10)\n      (list x)\n      (append (list (modulo\
    \ (string->integer x) base))\n              (change_base (quotient x base) base))))\n",
  "  (cond\n    ((= base 0) x)\n    ((< base 10) (string-append (number->string x)\
    \ (number->string base)))\n    (else (change_base (quotient x base) (quotient\
    \ base base)))))\n", "  (if (number? x) (number->string (remainder x (expt 2 base)))\
    \ '?))\n", "  (cond [(< base 10) \n         (number->string \n          (expt\
    \ x (expt 10 base)))]\n        [else \n         (number->string (truncate x (expt\
    \ 10 base)))]))\n", "  (cond [(< base 10)\n         (number->string (exact->inexact\
    \ (* base x)))]\n        [else (number->string x)]))\n", "  (let ([new-base base\
    \ \n         new-str (string->list (number->string x))])\n    (cond\n      [(<=\
    \ new-base 10) \n       (string->symbol (string->list (string-append new-str\n\
    \                                                (number->string (quotient new-base\
    \ 10)))))]\n      [(= new-base 10)\n       (string->symbol (string->list (string-append\
    \ new-str\n                                                (number->string new-base))))]\n\
    \      [else \n       (string->symbol (string->list (string-append new-str\n \
    \                                               (number->string new-base))))])))\n",
  "  (cond [(< base 10) (string-append (str x) (string base))])\n        (else   (*\
    \ (string->number (str x)) base)\n               (change_base (str x) base))))\n",
  "  (cond\n    [(= base 10) (string->number (string->symbol x))]\n    [else (+ (change_base((/\
    \ x base) base)\n                      base)\n             (string->number (string->symbol\
    \ x))))]))\n", "  (cond [(< base 10) (number->string x)]\n        [else (number->string\
    \ (truncate x (expt base 10)))]))\n", "  (cond\n    [(> x 10) (string-append \"\
    0\"\n                            (make-number\n                              (-\
    \ x (min base\n                                       (char->integer (char->char\
    \ (char->integer (string->char (string->char (char->integer x))))))))\n      \
    \                    )\n     (cons '0\n           (change_base (- x (min base\
    \ 10)) base))\n     ]\n    [else (make-number\n               (* x (min base 10)))\n\
    \     ]\n    )\n  )\n", "  (cond\n    ((= x 0) #f)\n    ((= x 1) #t)\n    ((<\
    \ x base) #f)\n    (#t (number->string x (- base (number->int x))))))\n", "  (cond\
    \ [(= base 0) '0]\n        [(= base 1) '10]\n        [(= base 2) '100]\n     \
    \   [(= base 3) '1000]\n        [(= base 4) '10000]\n        [(= base 5) '100000]\n\
    \        [(= base 6) '1000000]\n        [(= base 7) '10000000]\n        [(= base\
    \ 8) '100000000]\n        [(= base 9) '1000000000]\n        [(= base 10) '10000000000]\n\
    \        [else (* x (change_base (/ x base) (add1 base)))]))\n", "  (cond [(<\
    \ base 10) \n         (string-append (number->string x) (number->string base))]\n\
    \        [else\n         (let ((base-string (string->number base)))\n        \
    \   (cond [(< base 10)\n                  (string-append (number->string x) base-string)]\n\
    \                 [else\n                  (let ((new-x (quotient x (expt base\
    \ 10))))\n                    (string-append (number->string x) \n           \
    \                       (number->string new-x) (number->string base))]))]))\n\
    </code>\n<|/ a |>\n<| c |>\nJust to point out, `(quotient (expt x base) base)`\
    \ will always produce an integer between `0` and `base-1`. You can get more mathematically\
    \ rigorous by using `floor`.\n<|/ c |>\n<| c |>\n: Thanks for pointing out. `floor`\
    \ is also an option, but I chose to stick to `exp` since it gives the correct\
    \ result for `base=10` and `x=5`.\n<|/ c |>\n<| c |>\nThe second version worked\
    \ for me after I removed 'return' from change_base. The first version didn't work\
    \ as intended when I tried it for 8 (base 10).\n<|/ c |>\n<| c |>\n: Good catch.\
    \ Fixed now. Thanks!\n<|/ c |>\n<| c |>\nThis solution is not working in Racket\
    \ for base 10\n<|/ c |>\n<| a |>\nI believe you mean\n<code>", "  (assert base\
    \ (< base 10) (base))\n  (check-type x (exact-integer? number))\n  (check-type\
    \ base (exact-integer? number))\n  (if (= x 0)\n      '0\n      (cond [(= base\
    \ 10)\n             (printf \"~s\" (string->number (number->string x)))]\n   \
    \         [else\n             (let ([res (string->number (number->string x))])\n\
    \               (cond\n                 [(= (remainder base 10)\n            \
    \         (modulo x base))\n                   (printf \"~s\" (string->number\
    \ (number->string (modulo x base))))]\n                 [else\n              \
    \     (printf \"~s\" (string->number (number->string (quotient x base))))])))\n\
    \  (number->string x))\n", "  (cond\n    [(< x 10) (+ x (base (- x 1)))]\n   \
    \ [(= x 0) '0]\n    [(= x base) '0]\n    [else (cond (= base 3) (+ x (base (-\
    \ x 1)))\n                (= base 2) (+ x (base (- x 1)))\n                (else\
    \ (+ x (change_base x (- base 1)))))]))\n", "  (if (and (number? x) (<= base 10))\n\
    \      (number->string x (/ base 10))\n      'invalid-input))\n", "  (cond\n \
    \   [(< base 10) `(* ,(number->string x) ,base)] \n    [else `(quotient x ,base)]))\n",
  "  (define (helper-change x)\n    (cond [(= base 0) x]\n          [(> base 10) (string-append\
    \ (number->string x) \"0\")]\n          [else (string-append (number->string x)\
    \ \"0\")]))\n  (helper-change x))\n", "  (if (< base 10)\n      (* base (+ (*\
    \ x base) (- base (quotient x base))))\n      (quotient x base)))\n", "  (cond\
    \ [(< base 10) (string-append (number->string x) \"0\")\n        (= base 10) (number->string\
    \ x)])) ; base10\n", "  (if (number? x)\n      (change-base-x (number->string\
    \ x) (number->string base))\n      (change-base-x x base)))\n", "  (let loop ((x\
    \ x) (res '()))\n    (cond\n      ((= base 0) res)\n      ((< base 10) (res (char\
    \ (+ (* base x 10) (- base 1)))))\n      (else\n       (loop (quotient x base)\n\
    \             (cons (- x quotient base) res)))))\n", "  (cond\n    [(< base 10)\
    \ x]\n    [else (quotient x base (- base 10)))]))\n", "  (if (= base 10)\n   \
    \   (number->string x)\n      (string-append (number->string x)\n            \
    \       (number->string (quotient x base))\n                   (number->string\
    \ (quotient x base (* 2 base)))\n                   )))\n", "  (cond [(< x 10)\
    \ (* base x)]\n        [else (change-base (/ x 10) (* base 10))]))\n", "  (let\
    \ ([result (make-base-string base x)])\n    (displayln result)\n    result))\n",
  "  (let ([res 0])\n    (cond\n      [(= x 0) (number->string res)]\n      [(< base\
    \ 10) (cond\n                     ((= x 1) \"1\")\n                     ((= x\
    \ 2) \"2\")\n                     ((= x 3) \"3\")\n                     ((= x\
    \ 4) \"4\")\n                     ((= x 5) \"5\")\n                     ((= x\
    \ 6) \"6\")\n                     ((= x 7) \"7\")\n                     ((= x\
    \ 8) \"8\")\n                     ((= x 9) \"9\")\n                     ((= x\
    \ 10) \"10\")\n                     ((= x 11) \"11\")\n                     ((=\
    \ x 12) \"12\")\n                     ((= x 13) \"13\")\n                    \
    \ ((= x 14) \"14\")\n                     ((= x 15) \"15\")\n                \
    \     ((= x 16) \"16\")\n                     ((= x 17) \"17\")\n            \
    \         ((= x 18) \"18\")\n                     ((= x 19) \"19\")\n        \
    \             ((= x 20) \"20\")\n                     ((= x 21) \"21\")\n    \
    \                 ((= x 22) \"22\")\n                     ((= x 23) \"23\")\n\
    \                     ((= x 24) \"24\")\n                     ((= x 25) \"25\"\
    )\n                     ((= x 26) \"26\")\n                     ((= x 27) \"27\"\
    )\n                     ((= x 28) \"28\")\n                     ((= x 29) \"29\"\
    )\n                     ((= x 30) \"30\")\n                     ((= x 31) \"31\"\
    )\n                     ((= x 32) \"32\")\n                     ((= x 33) \"33\"\
    )\n                     ((= x 34) \"34\")\n                     ((= x 35) \"35\"\
    )\n                     ((= x 36) \"36\")\n                     ((= x 37) \"37\"\
    )\n                     ((= x 38) \"38\")\n                     ((= x 39) \"39\"\
    )\n                     ((= x 40) \"40\")\n                     ((= x 41) \"41\"\
    )\n                     ((= x 42) \"42\")\n                     ((= x 43) \"43\"\
    )\n                     ((= x 44) \"44\")\n                     ((= x 45) \"45\"\
    )\n                     ((= x 46) \"46\")\n                     ((= x 47) \"47\"\
    )\n                     ((= x 48) \"48\")\n                     ((= x 49) \"49\"\
    )\n                     ((= x 50) \"50\")\n                     ((= x 51) \"51\"\
    )\n                     ((= x 52) \"52\")\n                     ((= x 53) \"53\"\
    )\n                     ((= x 54) \"54\")\n", "  (cond [(< base 10) (modulo (quotient\
    \ x base) (expt base base))] \n        [else (modulo (quotient x base) (expt base\
    \ base))]))\n", "  (string->number\n   (string->char (number->string x)\n    \
    \               (if (> base 10)\n                     (string->string base)\n\
    \                     (if (string->char (number->string x) base)\n           \
    \            '() 'x)))))\n", "  (if (zero? x)\n      '()\n      (cond [(equal?\
    \ base 0) (list x) ]\n            [(zero? (remainder x base))\n             (append\
    \ (remainder x base) (change_base (remainder x base) base))]\n            [else\
    \ (append (change_base (remainder x base) base) (remainder x base)])])))\n", " \
    \ (let* ((base-str (number->string base))\n         (digits (string->list base-str)))\n\
    \    (if (< base 10)\n        (number->string (number->integer x (- base 1))\n\
    \                        (lambda (i)\n                          (cond\n      \
    \                      [(equal? i 0) (string 0 digits)]\n                    \
    \        [(equal? i 1) (string 1 digits)]\n                            [(equal?\
    \ i 2) (string 2 digits)]\n                            [(equal? i 3) (string 3\
    \ digits)]\n                            [(equal? i 4) (string 4 digits)]\n   \
    \                         [(equal? i 5) (string 5 digits)]\n                 \
    \           [(equal? i 6) (string 6 digits)]\n                            [(equal?\
    \ i 7) (string 7 digits)]\n                            [(equal? i 8) (string 8\
    \ digits)]\n                            [(equal? i 9) (string 9 digits)]\n   \
    \                         [(equal? i 10) \"\"]\n                            [(else\
    \ \"\")]))\n        (number->string (* base (number->integer x (- base 1))\n \
    \                        (lambda (i)\n                          (cond\n      \
    \                      [(equal? i 0) (string 0 digits)]\n                    \
    \        [(equal? i 1) (string 1 digits)]\n                            [(equal?\
    \ i 2) (string 2 digits)]\n                            [(equal? i 3) (string 3\
    \ digits)]\n                            [(equal? i 4) (string 4 digits)]\n   \
    \                         [(equal? i 5) (string 5 digits)]\n                 \
    \           [(equal? i 6) (string 6 digits)]\n                            [(equal?\
    \ i 7) (string 7 digits)]\n                            [(equal? i 8) (string 8\
    \ digits)]\n                            [(equal? i 9) (string 9 digits)]\n   \
    \                         [(equal? i 10) \"\"]\n                            [(else\
    \ \"\")]))))))))\n</code>\n<|/ a |>\n<| c |>\nI agree with you that `(change-base\
    \ 10 3)` produces what you want, but `(change-base 5 2)` returns `\"1\xD72\xD7\
    2\xD72\xD72\xD72\xD72\"`, which is `'(5 x 2 x 2 x 2 x 2 x 2)` \u2014 not `'(5\
    \ x 2 5 x 2 5 x 2 5 x 2 5 x 2)`. Thus the `(change-base 5 2)` I provided doesn't\
    \ produce the result you were expecting.\n<|/ c |>\n<| c |>\nYou wrote that \"\
    *the above program only works for the numbers up to base 10*\", but you're not\
    \ using `(change-base 10 3)` as you wrote in your answer. Your `number->list`\
    \ call", "  (cond [(< base 10)\n         (+ x (* base base))]\n        [else\n\
    \         (* x (change_base (/ x base) (- base 2)))]));\n", "  (define (helper\
    \ x base)\n    (cond\n      [(zero? x) '0]\n      [(even? x) '((change_base (remainder\
    \ x base) base) (remainder x base))]\n      [else (helper (quotient x base) (base))]))\n\
    \  (helper (quotient x base) (base)))\n", "  (check-type base number)\n  (check-type\
    \ x number)\n  (let ((new-number (change-base-and-add x base 0)))\n    (number->string\
    \ new-number)))\n", "  (number->string (x (number->number base))))\n", "  (cond\
    \ [(< base 10)\n         (char->integer\n          (number->string\n         \
    \  (bignum->string x base))))]\n        [(equal? base 0)\n         '0]\n     \
    \   [else\n         (string->number\n          (number->string\n           (bignum->string\
    \ x base))\n          (- base 10))]))\n", "  (cond [(= base 0) x]\n        [else\
    \ (quotient x (mult base base))]))\n", "  (string->number x (make-instance 'bignum-base\n\
    \                                   :radix base)))\n", "  (cond [(< x 10) x]\n\
    \        [else (+ (* base (quotient x 10)) (number->string x)))]))\n", "  (if\
    \ (zero? base)\n      (if (negative? x)\n          '(- (quotient x base) base)\n\
    \          '(quotient x base))\n      (if (negative? x)\n          '(- (quotient\
    \ x base) base)\n          '(quotient x base))))\n", "  (let ((base-str (number->string\
    \ x)))\n    (if (> base 10)\n        (number->string\n         (quotient (expt\
    \ base base) 10)\n         (string->number (reverse base-str)))))\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nIf you're open to using Racket (and Racket's own math\
    \ library is pretty awesome), this could be easily done in a single function:\n\
    <code>", "  (cond\n    [(or (= x 0) (= base 0))\n     (if (>= base 10)\n     \
    \    (string x)\n         (string->char (+ (string->int x) base)))]\n    [(and\
    \ (number? x) (< base 10))\n     (if (>= base 10)\n         (change_base (- x\
    \ base) (- base 10))\n         (if (> (- x base) (- base 10))\n             (change_base\
    \ (- x base) base)\n             (string (- x (- base 10))))]\n    [(number? x)\n\
    \     (string x)]\n    [else\n     (error \"bad base\" base)]\n  ))\n", "  (cond\n\
    \    [(zero? x) (error \"Cannot change base of a zero number.\")]\n    [(zero?\
    \ (remainder x base)) x]\n    [(= base 0) (error \"Base cannot be zero.\")]\n\
    \    [else (quotient x base)\n          (+ x (* (quotient (quotient x base) (*\
    \ base base)) base))]))\n", "  (if (and (<= base 10) base)\n      (number->string\
    \ (inv (quotient x base))) \n      (make-string (- (length x) 1) #\\0))) ; fill\
    \ with zeroes.\n", "  (define (loop i acc base acc)\n    (cond\n      [(= i 0)\
    \ acc]\n      [(< i 10) (string-append (number->string x) (number->string acc))]\n\
    \      [else (loop (- i 1) (* acc base) (number->string base) (number->string\
    \ acc))]))\n  (loop 0 x base '0))\n", "  (- x (expt base (floor x))))\n", "  (cond\n\
    \    [(= base 0) (cond\n                     [(= x 0) \"0\"]\n               \
    \      [(< x 0) \"-\"]\n                     [else (string-append \"0\" x)]])]\n\
    \    [(= base 1) (cond\n                     [(= x 0) \"0\"]\n               \
    \      [(< x 0) \"-\"]\n                     [else (string-append \"0\" x)]])]\n\
    \    [(= base 10) (cond\n                     [(= x 0) \"0\"]\n              \
    \       [(< x 0) \"-\"]\n                     [else (string-append \"0\" x)]])]\n\
    \    [else\n     (cond\n       [(= base 0) (cond\n                         [(=\
    \ x 0) \"0\"]\n                         [(< x 0) \"-\"]\n                    \
    \     [else (string-append \"0\" x)]])]\n       [(= base 1) (cond\n          \
    \               [(= x 0) \"0\"]\n                         [(< x 0) \"-\"]\n  \
    \                       [else (string-append \"0\" x)]])]\n       [else (cond\n\
    \               [(= x 0) \"0\"]\n               [(< x 0) \"-\"]\n            \
    \   [else (expt x (/ base 10))])]))])", "  (cond [(= base 10) (number->string\
    \ x))]\n        [(= base 1) (number->string x 2)]\n        [(< base 10) \n   \
    \      (string->number (string-append (change_base (string-ref x 0 base) base)\n\
    \                                         (number->string x)))]))\n", "  (/ x\
    \ (expt base 10)))\n", "  (cond [(= base 0) x]\n        [(= base 1) (string-append\
    \ \"1\" x)]\n        [(< base 10) (string-append (+ x (change_base (mod x base)\
    \ base)) (change_base base base))]\n        [else x]))\n</code>\n<|/ a tags=scheme,racket,functional-programming\
    \ |>\n<| a dscore=2 |>\nYou were using append incorrectly - it only takes one\
    \ argument, and you're giving it two arguments.  Try (append '(a b) '(c d)) instead.\n\
    <|/ a tags=scheme,racket,functional-programming |>\n<| c |>\nYou're right, I changed\
    \ my code and it still didn't work.\n<|/ c |>\n<| c |>\nThe `(append '(a b) '(c\
    \ d))` expression works as I expect it to.  Can you provide a simple example that\
    \ fails?  It's not clear what you're actually seeing happen.\n<|/ c |>\n<| c |>\n\
    I have edited my code to the original question.  I ran it with DrRacket and get\
    \ the result `((a b) (c d))` as the answer.\n<|/ c |>\n<| a |>\n<code>", "  (+\
    \ x base))\n", "  (if (< base 10)\n      (number->string x (+ x base))\n     \
    \ (number->string (/ x base) (- x base))))\n", "  (let ([bases (string->list (num->string\
    \ x (+ x 1))))]\n        [result '()])\n    (cond (zero? x)\n          (set! result\
    \ (append result bases))\n          (return-from change_base result)\n       \
    \   :else\n          (let* ([left (car bases)\n                 right (cdr bases)]\n\
    \                 [num (modulo (+ x base) base)]\n                 [digits (string->list\
    \ (num->string num (+ x 1)))])\n            (cond\n              [(= x num) result]\n\
    \              [(= num 0) (set! result (append result digits))]\n            \
    \  [else (set! result (append result (list left))\n                          \
    \   (set! result (append result (list right)))\n                             (set!\
    \ result (append result digits))])))))))\n", "  (cond ((< base 10) (string-append\
    \ (number->string x) (number->string base)))\n        ((>= base 10) (string-append\
    \ (number->string x) (number->string base) (number->string base)))\n        (else\
    \ (string-append (number->string x) (number->string base) (number->string base))))\n",
  "  (/ (floor x) (expt base (- x 1))))\n", "  (let ((rem-base (- base 10)))\n   \
    \ (cond\n      [(< x 10) (string-append x \"0\")]\n      [(= x 0) \"\"]\n    \
    \  [(< rem-base 10) (string-append \"0\" x)]\n      [(= rem-base 0) (- x base)]\n\
    \      [else (/ (- x base) rem-base)])))\n", "  (if (< base 10)\n      (* base\
    \ (string x))\n      (error \"base number should be less than 10\" base)))\n",
  "  (let ([xstr (number->string x)]) ;; save original value\n    (cond\n      [(number?\
    \ xstr) (number->string 0)] ;; number 0\n      [(eqv? base 0) (number->string\
    \ x)] ;; base=0, return string\n      [(<= base 10) (string-append xstr (make-base-string\
    \ (- base base)))] ;; base > 10, return string\n      [(>= base 10) (string-append\
    \ xstr (make-base-string (- base 10)))] ;; base < 10, recurse\n      [else (let\
    \ ([nstr (make-base-string base)]) ;; base <10, make new string\n            \
    \  (cond\n                [(empty? nstr) (string-append xstr (make-base-string\
    \ (- base 10)))] ;; base < 10, recurse\n                [(eqv? base 0) (number->string\
    \ x)] ;; base=0, return string\n                [(<= base 10) (string-append xstr\
    \ (make-base-string (- base base)))] ;; base > 10, return string\n           \
    \     [(>= base 10) (string-append xstr (make-base-string (- base 10)))] ;; base\
    \ < 10, recurse\n                [else (string-append xstr (make-base-string base))]))])))\
    \ ;; base >= 10, return string", "  (cond ((< x 10) \"\"\n         ((= base 0)\
    \ (if (= x 0) x x))\n         ((= base 1) (+ x 1))\n         ((= base 2) (+ (*\
    \ x x) 2))\n         ((= base 3) (+ (* x x) (* x x)))\n         ((= base 4) (+\
    \ (* x x) (* x x) (* x x)))\n         ((= base 5) (+ (* x x) (* x x) (* x x) (*\
    \ x x)))\n         ((= base 6) (+ (* x x) (* x x) (* x x) (* x x) (* x x)))\n\
    \         ((= base 7) (+ (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x\
    \ x)))\n         ((= base 8) (+ (* x x) (* x x) (* x x) (* x x) (* x x) (* x x)\
    \ (* x x) (* x x) (* x x)))\n         ((= base 9) (+ (* x x) (* x x) (* x x) (*\
    \ x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x)))\n         ((=\
    \ base 10) (+ (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x)\
    \ (* x x) (* x x) (* x x) (* x x) (* x x)))\n         ((= base 11) (+ (* x x)\
    \ (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x\
    \ x) (* x x) (* x x) (* x x)))\n         ((= base 12) (+ (* x x) (* x x) (* x\
    \ x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (*\
    \ x x) (* x x) (* x x) (* x x)))\n         ((= base 13) (+ (* x x) (* x x) (*\
    \ x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* x x) (* ", " \
    \ (let ([digits (string-append '() (format \"~d\" (expt x base))))])\n    (let\
    \ ([len (string-length digits)])\n      (cond\n        ((= x 0)\n         (string-append\
    \ \"0\" digits))\n        ((< x base)\n         (cond ((= len (string-length digits))\n\
    \                (string-append \"0\" digits))\n               (else\n       \
    \         (string digits)\n                (change_base (/ x base) base)\n   \
    \             (cond ((= len (string-length digits))\n                       (string-append\
    \ \"0\" digits))\n                       (else digits)\n                    )\n\
    \                )\n              )\n          )\n        (else\n         (cond\
    \ ((= len (string-length digits))\n                (string-append \"0\" digits))\n\
    \               (else\n                (string digits)\n                (change_base\
    \ (* base (expt x base)) base)\n                (cond ((= len (string-length digits))\n\
    \                       (string-append \"0\" digits))\n                      \
    \ (else digits)\n                    )\n                )\n          )\n     \
    \   )\n      )\n    )\n  )\n);;#lang racket\n", "  (if (< x 10) \"\"\n      (let\
    \ ((base-string \"0123456789\"))\n        (if (< base 10)\n            (if (>\
    \ x 0)\n                (cons (string-append (string base-string) (string-at (-\
    \ x base) (+ base 10))) \n                      (change_base (- x base) base))\n\
    \                (cons \"\" x))))))\n", "  (if (> (base-digits (number->string\
    \ x)) base)\n      (number->string (make-number-from-string\n                \
    \            (number->string x)\n                            (lambda (d)\n   \
    \                           (make-number-from-string \n                      \
    \          (number->string (+ (base-digits (number->string x)) d))\n         \
    \                       (lambda (d)\n                                  (make-number-from-string\
    \ \n                                    (number->string (- d \n              \
    \                                    (base-digits (number->string x)))\n     \
    \                               base)\n                                    (lambda\
    \ (d)\n                                      (make-number-from-string \n     \
    \                                   (number->string x)\n                     \
    \                   (lambda (d)\n                                          (make-number-from-string\
    \ \n                                            (number->string (+ d d))\n   \
    \                                         (lambda (d)\n                      \
    \                        (make-number-from-string \n                         \
    \                       (number->string (- d d))\n                           \
    \                     (lambda (d)\n                                          \
    \        (make-number-from-string \n                                         \
    \           (number->string (+ d d))\n                                       \
    \             (lambda (d)\n                                                  \
    \    (make-number-from-string \n                                             \
    \           (number->string (- d d))\n                                       \
    \                 (lambda (d)\n                                              \
    \            (make-number-from-string \n                                     \
    \                       (number->string (+ d d))\n                           \
    \                                 (lambda (d)\n                              \
    \                                (make-number-from-string \n                 \
    \                                               (number->string (- d d))\n   \
    \                                                             (lambda (d)\n  \
    \                                                                (make-number-from-string\
    \ \n                                                                    (number->string\
    \ (+ d d))\n                                                                 \
    \   (lambda (d)\n                                                            \
    \          (make-number-from-string \n                                       \
    \                                 (number->string (- d d))\n                 \
    \                                                       (lambda (d)\n        \
    \                                                                  (make-number-from-string\
    \ \n                                                                         \
    \   (number->string (+ d d))\n                                               \
    \                             (lambda (d)\n                                  \
    \                                            (make-number-from-string \n     \
    \                                                                           (number->string\
    \ (- d d))\n                                                                 \
    \               (lambda (d)\n                                                \
    \                                  (make-number-from-string \n               \
    \                                                                     (number->string\
    \ (+ d d))\n                                                                 \
    \                   (lambda (d)\n                                            \
    \                                          (make-number-from-string \n       \
    \                                                                 (number->string\
    \ (- d d))\n                                                                 \
    \       (lambda (d)\n                                                        \
    \                                  (make-number-from-string \n               \
    \                                                                            \
    \ (number->string (+ d d))\n                                                 \
    \                                           (lambda (d)\n                    \
    \                                                                          (make-number-from-string\
    \ \n                                                                         \
    \                       (number->string (- d d))\n                           \
    \                                                                     (lambda\
    \ (d)\n                                                                      \
    \                            (make-number-from-string \n                     \
    \                                                                            \
    \   (number->string (+ d d))\n                                               \
    \                                                     (lambda (d)\n          \
    \                                                                            \
    \                (make-number-from", "  (if (zero? x) (one? base) (string x))\n\
    \  (let ((temp (/ x base)))\n    (if (= base 10)\n        (string temp) \n   \
    \     (change_base temp (+ base 1)))))\n", "  (if (< base 10)\n      (number->string\
    \ (inv base x))\n      (number->string (inv base x))))\n", "  (cond\n    [(< base\
    \ 10)\n     (string-append (number->string x)\n                    (number->string\
    \ base))]\n    [(< base 2)\n     (string-append (number->string x)\n         \
    \           '0')]\n    [else\n     (string-append (number->string base)\n    \
    \                (number->string x)]))\n", "  (cond [(< base 10)\n         (string-append\
    \ \"0\" (number->string x (- (+ base 1) 10)))]\n        [else\n         (cond\
    \ [(< base 2)\n                (+ (number->string x (- (+ base 1) 10)) 10)\n \
    \              ]\n              [else x]))", "  (define (make-digit-string base\
    \ x)\n    (cond [(= base 0) \"0\"]\n          [(< base 10) (string-append (make-digit-string\
    \ base (quotient x base)))]\n          [else (string-append (make-digit-string\
    \ (quotient x base) (quotient x base))]))\n  (make-digit-string base x))\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=scheme,racket |>\nThe above answers are all great.\
    \ Just want to add my two cents. I find this to be a great exercise to practice\
    \ recursion and functional programming. Here is the solution I wrote using Racket:\n\
    <code>", "  (let ([num-digits (string->number (string-length x)]\n         [int-digits\
    \ (round (num-digits / base))]\n         [new-str (string-append (number->string\
    \ x)\n                                 string->string int-digits)])\n    (cond\
    \ [(< base 10) new-str]\n          [(> (- num-digits base) 0)\n           (error\
    \ \"The base cannot be greater than 10.\")]))))\n", "  (check-base-range x base)\n\
    \  (let ((to-base (- base 10)))\n    (if (= base 10)\n        (if (< x 10)\n \
    \           (char (+ x to-base))\n            (char (+ x to-base 10)))\n     \
    \   (cons (char (+ x to-base))\n              (change_base x (- base 1))))))\n",
  "  (cond\n    [(zero? x) '0]\n    [(= base 0) x]\n    [(< base 10) (string-append\
    \ (number->string x) '(base '))\n     (number->string x)\n     (string->number\
    \ (string-append (number->string x) '(base '))\n       (number->string x)\n  \
    \     (number->string (/ (- x base) base))\n       (number->string (/ (- x base)\
    \ base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (/ (- x base) base))\n       (number->string (/ (- x base) base))\n       (number->string\
    \ (", "  (let ((nums (base-to-lst base)))\n    (cond\n      [(number? x) (number->string\
    \ x)]\n      [(member? x nums)\n       (begin (let ([x (string->number x)])\n\
    \                (let ([base (if (number? base) base (make-base-from-string base))])\n\
    \                  (cond\n                    [(zero? base) '0]\n            \
    \        [else (+ (* base x) '0)])))]\n      [else\n       (begin (let ([x (string->number\
    \ x)])\n                (let ([base (if (number? base) base (make-base-from-string\
    \ base))])\n                  (cond\n                    [(zero? base) (number->string\
    \ x)]\n                    [else (number->string (* (make-base-from-string base)\
    \ x))]))])]))]))))\n", "  (cond\n    [(zero? x)\n     (string->number '0o)]\n\
    \    [(>= base 10)\n     (string->number (string->symbol (string->symbol x) (-\
    \ base 10)))]\n    [else\n     (string->number (string->symbol (string->symbol\
    \ x) base))]))", "  (cond\n    [(< base 10) (string x base)]\n    [(< x 10) (change-base\
    \ (quotient x base) base)]))\n", "  (cond\n    [(< base 0) \"0\"]\n    [(< base\
    \ 10) \"0\"]\n    [(< base 11) \"10\"]\n    [else \"20\"]))\n", "  (cond\n   \
    \ [(= base 0) x]\n    [(< base 10) (string-append (str (modulo (expt x base) (expt\
    \ base base)))\n                               (string-append (number->string\
    \ (quotient x base))\n                                             number->string\
    \ (quotient (modulo x base) base)))]\n    [else (change_base (quotient x base)\
    \ (quotient base base))]))\n", "  (if (< base 10)\n      (format #%o x) ; print\
    \ in octal notation\n      (format \"~a\" (expt x (- base 1)))))\n", "  (if (zero?\
    \ x) '0\n    (/ x (- base 10)) ;; convert to base 10 and divide\n    (+ x base)))\n",
  "  (define (convert x base)\n    (cond\n      [(zero? x) '0]\n      [(< base x)\
    \ \n       (cons (- base x) (convert (quotient x base) base))]))\n  (convert x\
    \ base))\n", "  (cond [(zero? x) (error 'bases \"Base of 0 is invalid.\")]\n \
    \       [(equal? base 0) (error 'bases \"Base cannot be zero.\")]\n        [else\
    \ (cons (floor (/ x base)) (change_base (quotient x base) base))]\n  ))\n", " \
    \ (cond\n    [(or (< x 10) base) (number->string x)]\n    [(< base 10) (number->string\
    \ x)\n     (string-append (number->string base)\n                   (number->string\
    \ x))]))\n", "  (cond\n    ((= x 0) (list x))\n    ((< x base) (list x))\n   \
    \ (else (cons (mod x base) (change_base (/ x base) base)))))\n", "  (if (< base\
    \ 10)\n      (number->string ((/ x (base 10)) base)\n                   #:min-positive\
    \ (/ base 10))\n      (number->string x base)\n      x))\n", "  (cond ((= base\
    \ 10) (* x base))\n        (else (/ x base))))\n", "  (if (zero? x)\n      \"\"\
    \n      (append (format \"~w\" (digits (mod x base)))\n               (string->int\
    \ (mod x base))))) ;; #lang racket\n", "  (cond\n    [(< base 10) (string-append\
    \ (number->string x) (number->string base))]\n    [else (change_base x (quotient\
    \ x base))]))\n", "  (if (< base 10)\n      (- x)\n      (number->string x (+\
    \ x base))))\n", "  (cond ((< base 10) (reverse (map #(% base x) '(1 2 3 4 5 6\
    \ 7 8 9 10 11))\n                                 (reverse '(1 2 3 4 5 6 7 8 9\
    \ 10 11))))\n        (else (cond ((< base 2) (reverse (map #(* base (modulo x\
    \ base)) '(1 2 3 4 5 6 7 8 9))\n                                      (reverse\
    \ '(1 2 3 4 5 6 7 8 9))))\n                   ((< base 3) (reverse (map #(/ base\
    \ (modulo x base)) '(1 2 3 4))\n                                      (reverse\
    \ '(1 2 3 4))))\n                   ((< base 4) (reverse (map #(mod base x) '(1\
    \ 2 3 4))\n                                      (reverse '(1 2 3 4))))\n    \
    \               (else (reverse (map #(/ base (modulo x base)) '(1 2 3))\n    \
    \                                  (reverse '(1 2 3))))))\n", "  (cond [(= base\
    \ 10) (string-append \"0\" 'x)\n         (= base 9) (string-append 'x \"0\")\n\
    \         (< base 9) (cond [(< x (/ base 10)) (string-append \"0\" 'x)\n     \
    \                        (> x (/ base 10)) (change_base x (- base 10))]\n    \
    \                       [else (cond [(< x (/ base 10)) (string-append \"0\" 'x)\n\
    \                                       (> x (/ base 10)) (change_base x (- base\
    \ 10))]\n                                     [else (* base x (/ x base))])])]\n\
    \        [else (* base x (/ x base))]))\n", "  (if (< base 10)\n    (number->string\
    \ x)\n    (append (number->string (quotient x base)) (change_base (quotient x\
    \ base) (- base 2)))))\n", "  (let ((base (if (< base 10)\n                  (-\
    \ base)\n                  base)))\n    (+ x base)))\n", "  (cond\n    ((= base\
    \ 0) '0)\n    ((< base 0) (cond ((= x 0) '0)\n                       ((= base\
    \ 1) '10)\n                       ((= base 2) (* 10 (quotient x base))\n     \
    \                            (/ x base)))\n                     (else (change_base\
    \ (quotient x base) (- base 1)))\n                     (/ x base)))\n    (else\
    \ (cond ((= base 0) '0)\n               ((= base 1) (number->string x))\n    \
    \           ((< base 1) (cond ((= x 0) '0)\n                                ((=\
    \ base 1) '10)\n                                ((= base 2) (* 10 (quotient x\
    \ base))\n                                        (/ x base)))\n             \
    \                   (else (change_base (quotient x base) (- base 1)))\n      \
    \                          (/ x base)))))\n  )\n", "  (cond\n    ((= base 10)\
    \ (digits (string->number (string-append x (string base)))))\n    ((< base 10)\
    \ (cond ((= base 2) (string->number (string-append x (string base))))\n      \
    \                     (else (cons (digits (string->number (string-append x (string-append\
    \ \"0\" base))))\n                                    (change_base x (+ base 1))))))\n\
    \    (else (error \"Unknown base: ~s\" base))))\n", "  (cond [(< base 10) (string-append\
    \ (number->string x) \"0\")\n         (else (string-append (number->string x)\
    \ \"?\")\n               (number->string base (- base 10)))]))\n", "  (cond\n\
    \    [(zero? x) (string x)]\n    [(equal? base 0) (string x)]\n    [else (expt\
    \ x base)]))\n", "  (let ([remainder (remainder-x x base)\n         tens (quotient-x\
    \ x base)]\n        [tens-str (string->number tens)]\n        [remainder-str (string->number\
    \ remainder)]\n        [str (list tens-str remainder-str)]\n        [str-length\
    \ (str->length str)])\n    (if (= remainder-str 0)\n        (string->number str)\n\
    \        (change_base (remainder-str base) (quotient-x x base)))))\n", "  (cond\
    \ [(< base 10)\n         (iota (- base 1) (mod x base))\n         ]\n        [else\n\
    \         iota (- base 1) (mod x base)]\n        ))\n", "  (cond\n    ((= base\
    \ 10) x)\n    ((< base 10) (string-append (number->string x) (number->string base)))))\n",
  "  (check-type x number)\n  (check-type base number)\n  (assert (= base 10))\n \
    \ (cond [(= x 0) '0]\n        [(zero? (rem x base))\n         '0]\n        [(<\
    \ base 10)\n         (string->number\n          (+ (number->string (number->integer\
    \ x) (- base (number->integer x))))\n         (number->string base))]))\n</code>\n\
    <|/ a tags=racket,scheme dscore=3 |>\n<| a tags=racket,scheme |>\nHere is a solution\
    \ in Common Lisp which uses only integer arithmetic, no floating-point or string\
    \ manipulation:\n<code>", "  (if (= base 0)\n      x\n      (change_base\n   \
    \    (multiply x base)\n       (- base))\n      )\n    )\n  )", "  (cond\n   \
    \ ((> base 10)\n     (error \"Base must be less than 10.\"))\n    ((zero? base)\n\
    \     (cond\n       ((< x 0)\n        (error \"Value must be positive.\"))\n \
    \      ((equal? x 0)\n        (error \"Base must be greater than zero.\"))\n \
    \      ((< x 1)\n        (error \"Base must be greater than 1.\"))))\n    ((<\
    \ base 0)\n     (error \"Base must be greater than 0.\"))\n    ((< x 0)\n    \
    \ (error \"Value must be positive.\"))\n    ((equal? x 0)\n     (error \"Value\
    \ must be 0.\"))))\n", "  (/ x (* base (floor x base))))\n", "  (cond\n    [(zero?\
    \ x) x]\n    [(< base 10) (string-append x (string->number x base))]\n    [(<\
    \ base 3) (string->number x (base->string base))]\n    [else (raise (exn:fail:contract\n\
    \              (list \"Unexpected base (~a) of ~a.\" base x)\n              (list\
    \ \"The base must be less than 10.\" base))\n              (list \"The number\
    \ must be less than 10.\" x)]))))\n", "  (cond\n    [(< base 10) (* x (raise-to-integer\
    \ base))]\n    [else (error 'change_base \"invalid base\")]))\n", "  (if (< x\
    \ 10)\n      (cons (base-str base) (change_base (sub1 x) (add1 base)))\n     \
    \ (cons (char->digit x) '0)))\n", "  (assert (>= base 10))\n  (check-type x number)\n\
    \  (let ((new-string (number->string x)))\n    (cond ((string=? new-string \"\
    0\") (append \"0\" new-string))\n          ((string=? new-string \"1\") (append\
    \ \"1\" new-string))\n          ((string=? new-string \"2\") (append \"2\" new-string))\n\
    \          ((string=? new-string \"3\") (append \"3\" new-string))\n         \
    \ ((string=? new-string \"4\") (append \"4\" new-string))\n          ((string=?\
    \ new-string \"5\") (append \"5\" new-string))\n          ((string=? new-string\
    \ \"6\") (append \"6\" new-string))\n          ((string=? new-string \"7\") (append\
    \ \"7\" new-string))\n          ((string=? new-string \"8\") (append \"8\" new-string))\n\
    \          ((string=? new-string \"9\") (append \"9\" new-string))\n         \
    \ ((string=? new-string \"10\") (append \"10\" new-string))\n          (else new-string))))\n",
  "  (cond\n    [(< x 10) (string-append (string-append '0 x) '0)]\n    [else (string-append\
    \ (modulo (* x base) (* base base)) (change_base (quotient x base) (* base base)))]))\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nI believe this is an issue with\
    \ how strings are concatenated in Scheme.\nTry changing it to use string-append\
    \ or string-builder:\n<code>", "  (let ([number (number->string x)])\n    (cond\n\
    \      [(< base 10) number]\n      [else (cons base number)])))\n", "  (cond\n\
    \    [(< base 2) (if (even? x) '5 (- x))\n              (if (even? x) '7 (- x))]\n\
    \    [else (if (odd? x) '10 (+ x))\n            (if (odd? x) '13 (+ x))]))\n",
  "  (if (> base 10)\n      (error \"Base must be less than 10.\")\n      (floor (/\
    \ x base))\n  )\n)\n", "  (cond\n    [(zero? x) #t]\n    [(zero? (remainder x\
    \ base)) (+ x base)]\n    [else (+ x base)]))\n", "  (if (= base 0)\n      x\n\
    \      (if (zero? (/ x base))\n          (change-base (/ x base) base)\n     \
    \     (change_base (* base x) (- base 1)))))\n", "  (if (< base 10)\n      (if\
    \ (= base 0)\n          (number->string x)\n          (cons (change_base (/ x\
    \ base) (- base 1))\n                (number->string x)))))\n", "  (cond [(zero?\
    \ x) '0]\n        [(zero? (remainder x base)) (cons (remainder x base) (change_base\
    \ (quotient x base) base))]\n        [else (change_base (quotient x base) (* base\
    \ x))]))\n", "  (if (< x base)\n      (if (= x 0)\n          '0\n          (if\
    \ (= base 10)\n              (list-ref (list '0 '1) (rem x base))\n          \
    \    (list-ref (list '0 '1) (rem (- x base) base))))\n      (let (([remainder\
    \ (rem x base)\n                quotient\n                digit\n            \
    \    digits\n                digit-sum]\n            (list (if (= remainder 0)\n\
    \                     '0\n                     (if (< remainder 10)\n        \
    \                 (cons remainder '(0 1))\n                         (cons '(0)\
    \ '(1 0)))))\n            (base base\n               (if (< x base)\n        \
    \           digit-sum\n                   (if (< x base)\n                   \
    \    digits\n                       (list digit-sum))))\n        (if (= base 10)\n\
    \            (list-ref digits 0)\n            (append digits (list-ref digits\
    \ (+ remainder base)))\n            (append digits (list* quotient '(0 1)))))))\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nI made a solution for you using only (+ and\
    \ *). I'm sure you can make something more elegant.\n<code>", "  (cond [(< base\
    \ 10)\n         (format \"~d\" x)\n         (if (= base 3)\n           (cons \"\
    0\" \"\")\n           (cons \"\" \"\"))]\n        [(> base 10)\n         (format\
    \ \"~d\" (/ x (int base)))\n         (if (= base 3)\n           (cons \"0\" \"\
    \")\n           (cons \"\" \"\"))]\n        [(= base 3)\n         (format \"~d\"\
    \ x)\n         (if (= base 3)\n           (cons \"0\" \"\")\n           (cons\
    \ \"\" \"\"))]\n        [(= base 2)\n         (format \"~d\" x)\n         (cons\
    \ \"0\" \"\")]))\n", "  (let ([res (string->number (number->string x)))]\n   \
    \     (cond [(zero? res) (error \"base must be non-zero\")]\n              [(<\
    \ base 10)\n               (concat \"0\" (string->number (number->string (- (abs\
    \ res) base))))]\n              [(> (abs res) base) (error \"base must be less\
    \ than base 10\")]\n              [else res])))\n", "  (let ((x (string->number\
    \ (string->symbol (format #<x> x base))))\n        (base base))\n    (cond\n \
    \     [(< x base)\n       (number->string (round x base))]\n      [else\n    \
    \   (string->number (format (* base x) #<x>))])))\n", "  (cond\n    [(< base 10)\
    \ (/ x base)]\n    [else (* base x (change_base (/ x base) base))]))\n", "  (if\
    \ (< base 10)\n      (number->string x)\n      (number->string\n        (+ (number->number\
    \ (/ x base)) (number->number base)))))\n", "  (/ (string->number x) base))\n",
  "  (check-type base int)\n  (check-type x int)\n  (cond [(< base 10) (string->number\
    \ x)]\n        [else (change_base*(x div base) (base))]))\n", "  (let ((num (mod\
    \ x base))\n        (res (quotient num)))\n    (cond ((= base 0)\n           num)\n\
    \          ((< base 10)\n           (string-append (string-to-char (char->integer\
    \ num) base)\n                         (string-to-char (char->integer res) base)))\n\
    \          ((< res 10)\n           (string-append (string-to-char (char->integer\
    \ num) base)\n                         (string-to-char (char->integer (+ num 10))\
    \ base)))\n          (else\n           (string-append (string-to-char (char->integer\
    \ (+ num 10)) base)\n                         (string-to-char (char->integer res)\
    \ base))))))\n", "  (cond\n    [(zero? x)\n     'zero']\n    [(zero? (cdr x))\n\
    \     'one']\n    [(zero? (cddr x))\n     'minus']\n    [else\n     (append (change_base\
    \ (car x) base)\n             (change_base (car x) base)])]))\n</code>\n<|/ a\
    \ tags=racket,scheme |>\n<| c |>\nCan you explain to me what this line means? ",
  "  (cond [(number? x) (change-base1 (parse-integer x base))]))\n", "  (let ([result\
    \ (list x)])\n    (cond\n      [(< base 10) (cond\n                         [(<=\
    \ (length x) 0) \"\"]\n                         [(< x 0) (append result (list\
    \ 0))]\n                         [else (append result (list x))])]\n      [else\
    \ (cond\n              [(<= (length x) 0) \"\"]\n              [(< x 0) (append\
    \ result (list (build-string base (- x base))))]\n              [else (append\
    \ result (list (build-string base x)))])]\n      )\n    (reverse result)\n   \
    \ )\n  )\n", "  (cond\n    [(or (char-int x) (char-int #\\A)) x] ;; ASCII table\n\
    \    [(char-int #\\0) '0']\n    [else (cond [(char-int x) (make-char (/ base 10))\n\
    \                     (char-int #\\A)] ;; ASCII\n             [(> base 10) (cond\
    \ [(char-int x) (make-char (- (char-int x) (* base 10)))] ;; numbers\n       \
    \                   [else (make-char (* base x)))] ;; letters\n             [else\
    \ (make-char (* base (char-int #\\A)))] ;; numbers\n             [else (make-char\
    \ (- (char-int x) (* base (char-int #\\A))))] ;; letters\n             [else (make-char\
    \ (* base (char-int #\\z)))] ;; numbers\n             [else (make-char (* base\
    \ (char-int #\\Z)))] ;; letters\n             [else (make-char (* base (char-int\
    \ #\\a)))] ;; numbers\n             [else (make-char (* base (char-int #\\A)))]\
    \ ;; letters\n             [else (make-char (* base (char-int #\\z)))] ;; numbers\n\
    \             [else (make-char (* base (char-int #\\Z)))] ;; letters\n       \
    \      [else (make-char (* base (char-int #\\0)))] ;; numbers\n             [else\
    \ (make-char (* base (char-int #\\A)))] ;; letters\n             [else (make-char\
    \ (* base (char-int #\\z)))] ;; numbers\n             [else (make-char (* base\
    \ (char-int #\\Z)))] ;; letters\n             [else (make-char (* base (char-int\
    \ #\\a)))] ;; numbers\n             [else (make-char (* base (char-int #\\A)))]\
    \ ;; letters\n             [else (make-char (* base (char-int #\\z)))] ;; numbers\n\
    \             [else (make-char (* base (char-int #\\Z)))] ;; letters\n       \
    \      [else (make-char (* base (char-int #\\0))))))])) ;; numbers\n", "  (cond\
    \ [(= x 0) \"0\"]\n        [(= x 1) \"1\"]\n        [(= x base) \"0\"]\n     \
    \   [else (* x (change_base (/ x base) base))]))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "  (let loop ((n x) (s \"\") (rest (floor\
    \ (/ n base))))\n    (cond\n      [(= n 0) s]\n      [(< n base) (loop (+ n rest)\
    \ (append s #\\0) (rest base))]\n      [(< rest 10) (loop (+ n rest) (append s\
    \ #\\0) (rest (- rest 10)))]\n      [(= rest 0) (loop (+ n rest) (append s #\\\
    0) (rest base))]\n      [else (loop (+ n rest) (append s #\\0) (rest base))])))\n",
  "  (let loop ((x x)\n             (base base))\n    (if (> x base)\n        (cons\
    \ x base)\n        (loop (/ x base) (+ base 1)))))\n", "  (cond\n    [(zero? x)\
    \ '0']\n    [(< x 10) (string-append (number->string x) (number->string (base->number\
    \ (base))))]\n    [else (string-append (number->string (base->number (base)))\
    \ (string->number (number->string x)))]))\n", "  (if (and (number? x) (< base\
    \ 10))\n      (append (number->string x)\n              (if (even? base) (number->string\
    \ (inc x))\n                  (number->string (inc (quotient x base)))))\n   \
    \   (error 'base-not-support \"Invalid base for ~D.\" base)))\n", "  (modulo x\
    \ base))\n", "  (let ([digs (string->list x)]\n        [out '()])\n    (if (null?\
    \ digs)\n        out\n        (loop\n           (let ([dig (car digs)])\n    \
    \         (cond\n               ((number? dig) (cons dig (change_base dig (- base\
    \ base))))\n               (else (loop (cdr digs))))\n           (if (= base 0)\
    \ (cons out) out)))))\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nI realise\
    \ this is an old question but here's another simple solution:\n<code>", "  (cond\n\
    \    ((= base 0)\n     (cons (car x) (change_base (cdr x) base)))\n    ((= base\
    \ 1)\n     (cons (cdr x) '(0)))\n    ((= base 2)\n     (cons (cdr x) '(1)))\n\
    \    ((< base 10)\n     (change_base (cdr x) base))\n    ((< base 10)\n     (cons\
    \ ''\n           (concat (substring x 0 base)\n                  (change_base\
    \ (cdr x) base))))))\n", "  (cond\n    ((= base 10) `(~a ,x))\n    ((< base 10)\
    \ (cons (mod x base) (change_base x (sub1 base)))\n    )))\n", "  (cond [(< x\
    \ 10) (* base x)]\n        [(< base 10) (+ x (change_base (quotient x base) base))]))\n",
  "  (let loop ((n x) (acc '()))\n    (if (= n 0)\n        (reverse acc)\n       \
    \ (loop (quotient n base) (concat acc (list base))\n               (quotient (-\
    \ n base) base)))))\n", "  (if (= x 0)\n      '0\n      (if (< base 10)\n    \
    \      (- x (mod base 10))\n          (- x (/ base 10)))\n      (if (< base 10)\n\
    \          (if (= base 2)\n              (if (= x 0)\n                  '0\n \
    \                 (- x (mod base 10)))\n              '10\n              '11)))))\n",
  "  (cond\n    ((< x 10) '())\n    ((= base 10) x))\n  (cond\n    ((= base 2) (list\
    \ x))\n    ((= base 3) (concat x (list '('))\n                  (concat x (list\
    \ '9))))\n    ((= base 4) (concat x (list '(')\n                  (concat x (list\
    \ '8))\n                  (concat x (list '7))\n                  (concat x (list\
    \ '6))))\n    ((= base 5) (concat x (list '(')\n                  (concat x (list\
    \ '8))\n                  (concat x (list '7))\n                  (concat x (list\
    \ '6))\n                  (concat x (list '5))))\n    ((= base 6) (concat x (list\
    \ '(')\n                  (concat x (list '8))\n                  (concat x (list\
    \ '7))\n                  (concat x (list '6))\n                  (concat x (list\
    \ '5))\n                  (concat x (list '4)))\n    ((= base 7) (concat x (list\
    \ '(')\n                  (concat x (list '8))\n                  (concat x (list\
    \ '7))\n                  (concat x (list '6))\n                  (concat x (list\
    \ '5))\n                  (concat x (list '4))\n                  (concat x (list\
    \ '3))))\n    ((= base 8) (concat x (list '(')\n                  (concat x (list\
    \ '8))\n                  (concat x (list '7))\n                  (concat x (list\
    \ '6))\n                  (concat x (list '5))\n                  (concat x (list\
    \ '4))\n                  (concat x (list '3))\n                  (concat x (list\
    \ '2))))\n    ((= base 9) (concat x (list '(')\n                  (concat x (list\
    \ '8))\n                  (concat x (list '7))\n                  (concat x (list\
    \ '6))\n                  (concat x (list '5))\n                  (concat x (list\
    \ '4))\n                  (concat x (list '3))\n                  (concat x (list\
    \ '2))\n                  (concat x (list '1))))\n    ((= base 10) (concat x (list\
    \ '(')\n                  (concat x (list '8))\n                  (concat x (list\
    \ '7))\n                  (concat x (", "  (if (< base 10)\n      (number->string\
    \ x (/ base 10))\n      (number->string x (* base 10 (quotient x base)))))\n",
  "  (cond\n    ((< base 10) (string-append (number->string x base)\n            \
    \                    (number->string 10 (- base 1)))\n     (number->string x base))\n\
    \    ((= base 10) (string-append (number->string x base)\n                   \
    \             (number->string 10 0)))\n    ((= base 1) (string-append (number->string\
    \ x base)\n                                (number->string 10 0)))\n    (else\n\
    \     (number->string x base))))\n", "  (cond [(< base 10) (string-append (number->string\
    \ x) base)\n         :else\n         (cond\n           [(> base 10) (string-append\
    \ (number->string x)\n                                      (list->string (expt\
    \ x base)))]\n           [(> base 2) (string-append (number->string x)\n     \
    \                                 (list->string (expt x (- base 1)))])]\n    \
    \     [else (error \"Base has to be >= 2!\"))]))\n", "  (cond\n    [(= base 0)\
    \ (append '0\n                     (reverse (list (mod x base))))]\n    [(< base\
    \ 10) (string-append (list (list (mod x base) (mod x base))\n                \
    \               (change_base (/ x base) base)))]\n    [else (error \"bad base\"\
    )]))\n", "  (cond\n    ((= base 0) x)\n    ((< base 10) (number->string x (number->number\
    \ (quotient x base))))\n    (else '(change_base (remainder x base) (quotient x\
    \ base)))))\n", "  (cond\n    [(< base 10) \n     (cons (string->number (string->symbol\
    \ (number->string x))) (number->string x))]\n    [else (cons (change_base (number->string\
    \ x) (quotient base base)) (quotient base base))]))\n", "  (mod x base))\n", " \
    \ (cond\n    [(< base 10)\n     (string-append \"0\" x)]\n    [(< base 10)\n \
    \    (string->number (string->list x))]\n    [else\n     (string->number ((change\
    \ x base) base))]))\n", "  (cond [(<= base 10)\n         (* base x)\n        \
    \ (cons #\\0 '())]\n        [else\n         (quotient\n           (quotient\n\
    \            (quotient\n             (quotient x base)\n             (- base 1))\n\
    \             base)\n         (cons base '())]\n        [(< base 10)\n       \
    \  (change_base x (- base 1))]))\n", "  (let loop ((x x) (res \"\"))\n    (cond\n\
    \      [(< x 10)\n       (loop (/ x base)\n             (+ res (list->string res)))]\n\
    \      [(= x 0)\n       (loop (+ 1 (length (list->string res)))\n            \
    \ (+ res (list->string res)))]\n      [else\n       (loop (/ x base)\n       \
    \      (+ res (list->string res)))]\n      )))\n</code>\n<|/ a dscore=1 tags=racket,scheme\
    \ |>\n<| a dscore=1 tags=racket,scheme |>\nThe solution with recursion is simple\
    \ enough. \n<code>", "  (let loop ((x x) (acc '()))\n    (if (> x 0)\n       \
    \ (cond ((< base 10)\n              (cond ((equal? x (modulo x base))\n      \
    \                (append acc (list base)))\n                    (else\n      \
    \                (loop (quotient x base)\n                            (append\
    \ acc (list base))))))\n          ((< base 0)\n           (cond ((equal? x (modulo\
    \ x base))\n                  (append acc (list base)))\n                 (else\n\
    \                  (loop x (append acc (list base))))))\n        (cond ((equal?\
    \ x 0)\n               (append acc (list '0')))\n              (else\n       \
    \        (cond ((equal? (modulo x base) 0)\n                     (append acc (list\
    \ '0')))\n                       (else\n                       (loop x (append\
    \ acc (list '0')))))))))\n", "  (let loop ((x x) (acc '()) (len 0))\n    (if (<\
    \ len (length x)) (loop (substring x len) (cons (* base (substring x len)) acc)\
    \ len (+ len 1))\n      acc)))\n", "  (if (= base 10)\n      (+ x base)\n    \
    \  (+ (string->number (string->list 'base)\n                           (* x (expt\
    \ base (quotient base 10)))))))\n", "  (cond\n    [(zero? x) (number->string x)]\n\
    \    [(zero? (cdr x)) (number->string (car x))]\n    [else (number->string (+\
    \ (change_base (car x) base) (car (cdr x))))]))\n", "  (cond\n    [(or (< x 10)\
    \ base)\n     (list '0+ (append (list x) '0))]\n    [(= base 0) (list '0+ (list\
    \ x))]\n    [(< base 10)\n     (append (change_base x (- base 10))\n         \
    \    (list (modulo (number->string x) base)))]\n    [else (error 'change_base\
    \ \"base must be a non-negative integer\")]))\n", "  (let loop ((x x)\n      \
    \       (res ''))\n    (if (< base 10)\n        (if (<= (length x) base)\n   \
    \         (loop (substring x base (+ base 1)) (cons x res))\n            (loop\
    \ (substring x (+ base 1)) (cons (char (mod x base)) res)))\n        (loop (substring\
    \ x (length x) base) (cons (char (- x base)) res))))\n  (display res)\n  (newline)\n\
    \  res)\n", "  (cond [(< base 10) '()\n        [else (+ x (/ base 10))\n     \
    \         (change_base x (- base 10))]])) ; recursion base case\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\nUsing \"recursively\" is the right way to go.\
    \ You are essentially just trying to do the following:\n<code>", "  (cond [(<\
    \ base 10) (string-append (string-append #\\0 x) base)] \n        [else (number->string\
    \ x (- base 10))]))\n", "  (if (< base 10)\n      (+ x (* base (- x 1)))\n   \
    \   x))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
