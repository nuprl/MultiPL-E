name: HumanEval_65_circular_shift
language: rkt
prompt: "#lang racket\n\n;; Circular shift the digits of the integer x, shift the\
  \ digits right by shift\n;; and return the result as a string.\n;; If shift > number\
  \ of digits, return digits reversed.\n;; >>> circular_shift(12, 1)\n;; \"21\"\n\
  ;; >>> circular_shift(12, 2)\n;; \"12\"\n(define (circular_shift x shift)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n\
  \    (check-equal? (candidate 100 2) \"001\")\n    (check-equal? (candidate 12 2)\
  \ \"12\")\n    (check-equal? (candidate 97 8) \"79\")\n    (check-equal? (candidate\
  \ 12 1) \"21\")\n    (check-equal? (candidate 11 101) \"11\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((x x) (follows 1))\n    (cond ((= x 0) \"\")\n       \
    \   ((< shift (- #char (digit-value x))) \"\")\n          (else (cons (digit-to-char\
    \ (digit-value x)) (loop (quotient x 10) shift))))))\n", "  (define (shift x n)\n\
    \    (if (> n 0)\n        (modulo x 10) (* 10 (shift x (- n 1))))\n    x))\n \
    \ (define (shift x n)\n    (if (> n 0)\n        (modulo x 10) (* 10 (shift x (-\
    \ n 1))))\n    x))\n  (define (left-shifted x n)\n    (if (> n 0)\n        (left-shifted\
    \ (shift x n) (- n 1))\n        x))\n  (define (right-shifted x n)\n    (if (>\
    \ n 0)\n        (right-shifted (shift x n) (- n 1))\n        x))\n  (define (left-shifted_digit\
    \ x n)\n    (if (> n 0)\n        (left-shifted (shift x n) (- n 1))\n        x))\n\
    \  (define (right-shifted_digit x n)\n    (if (> n 0)\n        (right-shifted\
    \ (shift x n) (- n 1))\n        x))\n  (define (left-shifted_digits x n)\n   \
    \ (if (> n 0)\n        (left-shifted (shift x n) (- n 1))\n        x))\n  (define\
    \ (right-shifted_digits x n)\n    (if (> n 0)\n        (right-shifted (shift x\
    \ n) (- n 1))\n        x))\n  (define (left-shifted_digits_digits x n)\n    (if\
    \ (> n 0)\n        (left-shifted (shift x n) (- n 1))\n        x))\n  (define\
    \ (right-shifted_digits_digits x n)\n    (if (> n 0)\n        (right-shifted (shift\
    \ x n) (- n 1))\n        x))\n  (define (left-shifted_digits_digits_digits x n)\n\
    \    (if (> n 0)\n        (left-shifted (shift x n) (- n 1))\n        x))\n  (define\
    \ (right-shifted_digits_digits_digits x n)\n    (if (> n 0)\n        (right-shifted\
    \ (shift x n) (- n 1))\n        x))\n  (define (left-shifted_digits_digits_digits_digits\
    \ x n)\n    (if (> n 0)\n        (left-shifted (shift x n) (- n 1))\n        x))\n\
    \  (define (right-shifted_digits_digits_digits_digits x n)\n    (if (> n 0)\n\
    \        (right-shifted (shift x n) (- n 1))\n        x))\n  (define (left-shifted_digits_digits_digits_digits_digits\
    \ x n)\n    (if (> n 0)\n        (left-shifted (shift x n) (- n 1))\n        x))\n",
  "  (if (or (> shift (- x 10)) (negative? (expt x shift)))\n      (reverse-string\
    \ (number->string x))\n      (let ((digits (number->list (expt x shift))\n   \
    \         (tail (modulo x 10)))\n            (tail (cons digits tail)))\n    \
    \    (let ((n (reverse tail))\n              (acc (reverse (cons 0 (reverse n))))\n\
    \              (last (reverse (modulo n 10))))\n          (string acc)\n     \
    \     (cons last acc))))))\n", "  (let ([str (number->string x)])\n    (if (=\
    \ shift (length str))\n        (string-reverse str)\n        (string-append str\
    \ (substring (last str) (length str) (- shift (length str)))))\n    ))\n", " \
    \ (let loop ((x x) (shift shift))\n    (cond\n      ((zero? shift) '())\n    \
    \  ((zero? (modulo x 10))\n       (loop (quotient x 10) shift))\n      (else\n\
    \       (append (loop (quotient (* x 10) (- shift 1)) shift)\n               (list\
    \ (modulo x 10)))))))\n", "  (cond\n    ((null? x) (set-to-string x))\n    ((<\
    \ shift (length x)) (set-to-string (list-ref (reverse x) shift))))\n  (begin\n\
    \    (set! x (substring x 0 (+ shift (length x))))\n    (set! x (reverse x))\n\
    \    (set! x (string-append x (list->string (reverse (substring x shift)))))\n\
    \    (set! x (string->list x))\n    (set! x (string-append x (list->string (reverse\
    \ (substring x 0 (- shift (length x)))))))\n    (set! x (string->list x))))\n",
  "  (let loop ((x x) (acc '()))\n    (cond\n      ((or (< shift 0) (> shift (length\
    \ x)))\n       (reverse acc))\n      (else\n       (loop (quotient x 10) (cons\
    \ (remainder x 10) acc))))))\n", "  (let loop ((x x) (shift shift) (s 0))\n  \
    \  (cond\n      [(= shift (- x 10)) (string (reverse s))]\n      [(= shift 0)\
    \ (string s)]\n      [(>= shift (- x 10)) (loop (mod x 10) shift)]\n      [else\
    \ (loop (mod (* x 10) (+ shift 1)) (+ shift 1))]\n      )\n    )\n  )\n", "  (let\
    \ loop ([n x]\n             [str \"\"]\n             [cnt 0]\n             [len\
    \ (digits-in n)]\n             [shift (- shift len)])\n    (cond\n      [(< shift\
    \ len) str (reverse str)]\n      [else (cond [(zero? n) (cons (digit-out n) str)]\n\
    \                  [(zero? shift) str]\n                  [else\n            \
    \       (loop (remainder n (expt 2 shift))\n                         (+ (* cnt\
    \ shift) shift)\n                         (+ cnt shift)\n                    \
    \     (- len shift)))])]))\n", "  (let* ([digits (string->list x)]\n         [digits_r\
    \ (reverse-list digits)]\n         [shift (- shift (length digits))])\n    (string-append\
    \ (reverse\n                     (take shift digits)) (reverse (drop shift digits_r)))))\n",
  "  (cond\n    ((< shift (length x)) (substring x (- shift (length x))) \"\")\n \
    \   ((< shift (length x)) (substring x shift) \"\")\n    (else (cons (car x) (circular_shift\
    \ (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x)\
    \ (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift)))))\
    \ ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr\
    \ x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift\
    \ (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x)\
    \ (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift)))))\
    \ ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr\
    \ x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift\
    \ (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x)\
    \ (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift)))))\
    \ ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr\
    \ x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift\
    \ (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x)\
    \ (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr x) shift)))))\
    \ ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift (cdr\
    \ x) shift))))) ;; (car x) (circular_shift (cdr x) shift))))) ;; (car x) (circular_shift\
    \ (cdr x) shift))))) ;; (car x) (cir", "  (let loop ((n x) (s shift))\n    (if\
    \ (= s 0)\n        (reverse (list n))\n        (loop (quotient n 10) (sub1 s)))))\n",
  "  (if (= shift 0)\n      '()\n      (let ([y x])\n        (if (< shift (length\
    \ y))\n            (substring y 0 (- shift (length y)))\n            (substring\
    \ y 0 (- shift (length y))))\n        (let ([m (quotient x 10)])\n          (if\
    \ (< shift (length m))\n              (substring m 0 (- shift (length m)))\n \
    \             (substring m 0 (- shift (length m))))\n          (cond ((= m 0)\n\
    \                 (+ (circular_shift y shift) y))\n                ((= m 1)\n\
    \                 (+ (circular_shift y (- shift 1)) x))\n                (else\n\
    \                 (+ (circular_shift y (- shift 1)) x)))))))\n", "  (let loop\
    \ ((x x)\n             (digits '())\n             (shift shift))\n    (if (> shift\
    \ (length digits))\n        digits\n        (loop (quotient x 10)\n          \
    \    (cons x (quotient x (- shift (length digits))))\n              (+ shift (length\
    \ digits))))))\n", "  (let loop ((x x) (acc '()) (len 0))\n    (if (< len shift)\n\
    \        (begin (set! acc (append acc (subseq acc 0 len)))\n              (set!\
    \ x (expt x shift))\n              (loop (expt x shift) (cons x (reverse acc))\
    \ (+ len shift))\n              (set! acc (cons '() acc))\n              (cond\n\
    \                ( (= x 0) (set! acc '()))\n                ( (= x 1) (set! acc\
    \ (reverse acc)))\n                (else (loop (/ x 10) '() (- len 1))))))\n \
    \   (set! acc (reverse acc))\n    (reverse acc))\n", "  (let loop ((x x) (n 0)\
    \ (res \"\"))\n    (if (zero? x)\n        (reverse res)\n        (loop (quotient\
    \ x 10) (incf n) (cons (modulo x 10) res)))))\n", "  (let loop ((x x) (shift shift))\n\
    \    (if (zero? shift)\n        (string->symbol (reverse (modulo-by-digits (-\
    \ x 1) (remainder x))))\n        (loop (quotient x shift) (quotient shift 10)))))\n",
  "  (define (rotate x shift)\n    (string->list \n      (cond [(< shift (length x))\n\
    \              (string-append (substring x 0 (- shift (length x))) \n        \
    \                     \"0\"\n                             (substring x (+ shift\
    \ (length x))))]\n            [(< shift 0)\n              (string-append x (substring\
    \ x shift (length x)))]\n            [else\n              (string-append (substring\
    \ x (+ shift (- shift (length x))) \n                             \"\")\n    \
    \                       (substring x 0 shift)\n                           (substring\
    \ x (- shift (- shift (length x))))]\n            )))\n  (rotate x (modulo (+\
    \ (length x) shift) 10))\n  )\n", "  (define (shift_digits digits shift)\n   \
    \ (cond\n      [(<= shift (length digits)) \"\"]\n      [else (append (reverse\n\
    \                       (shift_digits (substring digits 0 shift)\n           \
    \                        shift (- shift 1))))]))\n  (if (< shift (length x))\n\
    \      (reverse (shift_digits x (- shift 1)))\n      (shift_digits x (- shift\
    \ 1))))\n", "  (let ([digits (string->list x)]\n        [shift (- shift (length\
    \ digits))])\n    (let ([result (list (car digits))]\n          [digit (cdr digits)]\n\
    \          [shift (- shift 1)])\n      (if (< shift 0)\n          (cdr result)\n\
    \          (let ([new-digit (car digits)]\n                [newdigit (sub1 new-digit\
    \ (* shift 2))])\n            (cond ((<= shift 0) result)\n                  ((<\
    \ shift 1) (cons new-digit result))\n                  (else (cons (sub1 newdigit)\
    \ \n                               (cons new-digit (circular_shift new-digit shift))))))))))\n",
  "  (if (= shift 0)\n      (number->string x)\n      (let ((x (string->number (number->string\
    \ x))))\n        (string->number (string-append (string-append (string-append\
    \ (number->string (modulo (expt x shift) (- shift 1))))\n                    \
    \                      (number->string (modulo (expt x shift) (- shift 1)))))))\n",
  "  (let loop ((x x)\n             (digits '(())) \n             (shift (- shift\
    \ 1)))\n    (if (< shift (length digits))\n        (digits)\n        (loop (quotient\
    \ x 10) \n               (cons \n                 (+ (quotient x (* 10 shift))\
    \ shift) \n                 digits)\n             shift)))))\n", "  (if (= x 0)\n\
    \      '0\n      (let ([d (string->digit x)]\n            [s (string->string (inc\
    \ (string->digit x)))]\n            [n (string->number (string->string (inc (string->digit\
    \ x)))) ])\n        (cond\n          [(< shift (length s))\n           (cond\n\
    \             [(string=? (string->string (inc (string->digit x))) s)\n       \
    \        (string->string (inc (string->digit x)))]\n             [else (cond [(number=\
    \ n (/ x 10)) (cons d (cons s (circular_shift (/ x 10) shift)))]\n           \
    \             [else (cond [(< shift (- shift (length s)))\n                  \
    \                  (cons d (reverse (circular_shift (/ x 10) shift))) ])])]\n\
    \          [else (cond [(number= n (/ x 10)) (cons (reverse s) (cons (reverse\
    \ d) (reverse (circular_shift (/ x 10) shift)))]\n                        [else\
    \ (cond [(< shift (- shift (length s))) (cons (reverse s) (cons (reverse d) (reverse\
    \ (circular_shift (/ x 10) shift)))])])]\n          [else (cond [(< shift (- shift\
    \ (length s))) (cons (reverse s) (cons (reverse d) (reverse (circular_shift (/\
    \ x 10) shift)))])])]\n          [else (cond [(< shift (- shift (length s))) (cons\
    \ (reverse s) (cons (reverse d) (reverse (circular_shift (/ x 10) shift)))])])]\n\
    \          [else (cond [(< shift (- shift (length s))) (cons (reverse s) (cons\
    \ (reverse d) (reverse (circular_shift (/ x 10) shift)))])])]\n          [else\
    \ (cond [(< shift (- shift (length s))) (cons (reverse s) (cons (reverse d) (reverse\
    \ (circular_shift (/ x 10) shift)))])])]\n          [else (cond [(< shift (- shift\
    \ (length s))) (cons (reverse s) (cons (reverse d) (reverse (circular_shift (/\
    \ x 10) shift)))])])]\n          [else (cond [(< shift (- shift (length s))) (cons\
    \ (reverse s) (cons (reverse d) (reverse (circular_shift (/ x 10) shift)))])])]\n\
    \          [else (cond [(< shift (- shift (length s))) (", "  (if (= shift 0)\n\
    \      \"\"\n      (append (% x (- shift (length x))) \n              (circular_shift\
    \ x (- shift 1)))))\n", "  (let loop ((x x) (res ''))\n    (cond\n      [(< shift\
    \ (floor (/ x 10)))\n       (reverse res)]\n      [(< shift (floor (/ x 10)))\n\
    \       (loop (quotient x 10) (reverse res))]\n      [else\n       (loop (quotient\
    \ x 10) res\n             (append res '(quotient x 10) (quotient x 10 shift)))])))\n",
  "  (define (shift_digits x shift)\n    (let loop ((n x) (s shift))\n      (if (zero?\
    \ s)\n          (reverse (substring n 0 (- (length n) s)))\n          (shift_digits\
    \ (rest n) (sub1 s)))))\n  (shift_digits x shift))\n", "  (let loop ((x x) (shift\
    \ shift) (acc '())\n            (acc (cons '() acc)))\n    (if (< shift (length\
    \ (number->string x)))\n        (let ((digits (string->list (number->string x))))\n\
    \          (cons (sub1 (length digits)) (loop (sub1 (length digits) shift)\n \
    \                                        (cons (sub1 (length digits)) acc)\n \
    \                                        digits))\n          (loop (sub1 (length\
    \ digits) shift) (cons (sub1 (length digits)) acc)\n                (cons (sub1\
    \ (length digits) shift) (number->string x)))\n      (reverse acc))))\n</code>\n\
    <|/ a dscore=1 tags=racket,scheme |>\n<| a dscore=1 |>\nHere's a function that\
    \ does this with Racket and it's functional programming principles:\n<code>",
  "  (let* ((number-length (length (number->string x)))\n         (shift-length (-\
    \ shift number-length)))\n    (cond ((>= shift-length number-length)\n       \
    \    (string->number x))\n          ((= shift-length 0)\n           (string->string\
    \ x))\n          ((= shift 0)\n           (string->string x))\n          (else\
    \ (append\n                   (string->string (substring x (+ shift-length 1))\n\
    \                                 (circular_shift (substring x shift) (substring\
    \ shift-length 1)))))))\n", "  (if (< shift (length x))\n      (let ([digits (take\
    \ x (- shift (length x)))])\n        (string-append (circular_shift digits shift)\
    \ (drop (length x) (+ shift (length x))))))\n  x)\n", "  (let loop ((x x) (shift\
    \ shift) (s \"\"))\n    (cond ((zero? x) (list s))\n          ((> shift (length\
    \ x))\n           (loop (quotient x 10) (- shift (length x)) s))\n          (else\n\
    \           (loop (quotient x 10)\n                   (+ shift (length s))\n \
    \                  (string->list s)))))\n", "  (cond\n    [(< shift (length x))\n\
    \     (reverse (take (length x) (subseq x 0 (- shift (length x)))))]\n    [else\
    \ (take (length x) (subseq x (- shift (length x)))))]))\n", "  (let* ((s (string-length\
    \ (string-ref x (- shift 0))))\n         (x (string-to-int (substring x 0 (+ shift\
    \ s)))))\n    (cond\n      [(> shift s)\n       (string->list x)]\n      [(< shift\
    \ (- s shift))\n       (reverse (circular_shift x (+ shift (- s shift))))]\n \
    \     [else (cons (string->char (string->list (substring x 0 (- shift s))))\n\
    \                  (circular_shift x (+ shift (- s shift))))])))\n", "  (if (<\
    \ shift (- x))\n      (list x)\n      (loop\n         for i = 0 to (- shift (-\
    \ x))\n         for remainder = (modulo (modulo x 10) (- shift (- x)))\n     \
    \    for output = (list remainder)\n         for carry = (if (< shift (- x))\n\
    \                       0\n                       (modulo remainder 10))\n   \
    \      for x = output\n         for y = x\n         for output = (cons y output)\n\
    \         for x = output\n         for output = circular_shift x shift\n     \
    \    for x = output\n         for output\n         for x = output\n         for\
    \ y = x\n         for output = (cons y output)\n         for x = output\n    \
    \     for output = circular_shift x shift\n         for x = output\n         for\
    \ output)))\n", "  (cond\n    [(zero? x) (list x)]\n    [(zero? (remainder x 10))\
    \ (cons (remainder x 10) x)]\n    [else (circular_shift (remainder x 10) shift)]))\n",
  "  (let loop ([n x] [r 0] [x '0])\n    (cond ((> n 0)\n           (set! x (mod n\
    \ 10)\n                   (set! n (/ n 10)))\n           (loop (- n 1) (+ r shift)\
    \ x))\n          ((= n 0)\n           (set! x r\n                   (set! n '0))\n\
    \           (loop (+ n 1) (+ r shift) x))\n          (else\n           (set! x\
    \ (+ x '(#f #f #f #f #f #f #f #f #f #f #f #f #f #f #f))\n                   (set!\
    \ n '0\n                         (set! r (+ r shift))))\n          (loop (+ n\
    \ 1) (+ r shift) x))))\n</code>\n<|/ a tags=scheme dscore=3 |>\n<| a tags=scheme\
    \ dscore=2 |>\nA bit late to the party, but if anyone was interested, here's an\
    \ implementation using loops:\n<code>", "  (let loop ((i x))\n    (cond\n    \
    \  [(< i 10) (cons i x)]\n      [(< shift (length x)) (cons x (circular_shift\
    \ (- i 10) shift))]\n      [(< shift (- shift (length x))) (cons x (loop (+ i\
    \ 1) shift))]\n      [else (loop (+ i 1) (- shift (length x)))])))\n", "  (define\
    \ (loop x acc)\n    (cond\n      [(< shift (digits-of x)) (loop x (reverse acc))]\n\
    \      [else (loop (quotient x 10) (rest acc))]))\n  (loop x '()))\n", "  (cond\
    \ [(< shift (length x))\n         (reverse (substring x 0 (- shift (length x))))]\n\
    \        [else (substring x (- shift (length x)) (length x))]))\n", "  (let loop\
    \ ((n x) (s shift) (ans \"\"))\n    (cond\n      [(zero? n) ans]\n      [(> n\
    \ s) (loop (quotient n s) (- s shift) (reverse (digit-string n)))]\n      [(<\
    \ n s) (loop (quotient n s) (- s shift) (append (digit-string n) ans))]\n    \
    \  [else (loop (quotient n s) (- s shift) (cons (digit-string n) ans))])))\n",
  "  (cond [(zero? x) \"\"]\n        [(< shift (length x)) (cons (char (modulo (char->int\
    \ x) (char->int (/ x shift)))) \"\")\n          (else (cons (char (modulo (char->int\
    \ x) (char->int (/ x shift)))) (circular_shift (char (modulo (char->int (/ x shift))\
    \ (* shift (- shift (length x))) x) shift))\n        )]\n        [else (cons (char\
    \ (modulo (char->int x) (char->int (/ x shift)))) (circular_shift (char (modulo\
    \ (char->int (/ x shift)) (* shift (- shift (length x))) x) shift))]))\n", " \
    \ (let loop ((x x) (astr (make-string) 0))\n    (cond ((< shift (length astr))\
    \ (append astr (list x)))\n          ((zero? (rem x 10)) (reverse astr))\n   \
    \       ((< x (quotient x 10)) (loop (quotient x 10) astr (+ shift 1)))\n    \
    \      (else (loop x (append astr (list x)))))\n  (cdr astr)))\n</cell>\n<cell>\n\
    #lang racket\n", "  (let loop ((x x) (res \"\") (remainder 0) (shift shift))\n\
    \    (if (< shift (length x))\n        (loop (modulo x 10) (cons 0 (modulo x 10))\
    \ (+ shift 1))\n        (loop (modulo x 10) (reverse (modulo x 10)) (- shift 1)))))\n\
    </code>\n<|/ a |>\n<| c |>\nIt's a great answer that helped me understand how\
    \ it works.\n<|/ c |>\n<| a |>\nHere's my version:\n<code>", "  (if (> shift (length\
    \ x))\n      (string (reverse (digits (reverse x)))))\n  (cond ((= shift 0) (cons\
    \ (car x) (circular-shift (cdr x) shift)))\n        ((even? (remainder x shift))\
    \ (cons (car x) (circular-shift (cdr x) shift)))\n        (else (circular-shift\
    \ (+ (remainder x (/ shift 2)) (/ shift 2)) (- shift 1)))\n  )\n)\n", "  (let\
    \ ([digits (string->list (number->string x)))\n        [shift (check-shift shift\
    \ digits)]])\n    (if (zero? shift)\n        (reverse digits)\n        (if (null?\
    \ digits)\n            (error \"shifted value out of range\")\n            (let\
    \ ([carry (+ (car digits) (- shift))])\n              (if (= shift 0)\n      \
    \            (reverse digits)\n                  (cons (string->number (number->string\
    \ carry)) (circular_shift (cdr digits) (- shift 1)))))))))\n", "  (if (or (= shift\
    \ 0) (= shift (length x)))\n      (reverse (reverse (list (car x))) \"\")\n  \
    \    (append (list (car x)) (circular_shift (cdr x) shift))))\n", "  (cond\n \
    \   ((> shift (length x))\n     (string-append (reverse (regexp-opt (substring\
    \ x (- shift (length x))) \"/\" \"g\" \"d\") x))\n    ((>= shift (length x))\n\
    \     (string-append (reverse (regexp-opt (substring x (- (length x) shift)) \"\
    /\" \"g\" \"d\") x))\n    ((= shift (length x))\n     (substring x 0 shift))\n\
    \    (else\n     (string-append (reverse (regexp-opt (substring x (- shift (length\
    \ x))) \"/\" \"g\" \"d\") (circular_shift (substring x (+ shift (length x)) (-\
    \ shift (length x))) shift))))\n  )  \n  )\n", "  (if (= shift (length x))\n \
    \     (make-string x (- shift (length x))) x))\n", "  (let loop ((x (modulo x\
    \ 10)) (digits '()))\n    (if (< shift (length digits))\n        (loop (modulo\
    \ x (* 10 shift))\n              (cons x (modulo x (* 10 shift))\n           \
    \         (cdr digits)))\n        (reverse digits)))) ;; (display digits) #lang\
    \ racket\n", "  (let loop ((digits x) (shift (- shift (length digits)))\n    \
    \         (s \"\") (i 0))\n    (if (< i shift)\n        (loop (quotient digits\
    \ shift) (- shift (length digits)) (+ s digits) (+ i 1))\n        (loop digits\
    \ shift s (+ i 1)))))\n", "  (let loop ((x x) (xs (x (quotient x 10)))\n     \
    \         (shift (- shift 1)))\n    (if (= shift 0)\n        xs\n        (loop\
    \ (quotient x 10)\n              (quotient xs 10)\n              (- shift 1)))))\n",
  "  (cond [(< shift (length x))\n         x]\n        [else\n         (string-append\
    \ (left-string x) (right-string x))\n         (circular_shift (right-string x)\
    \ (- shift 1))]))\n", "  (if (>= (length x) (- shift 1))\n      (string-reverse\
    \ (substring x 0 shift))\n      (substring x (- shift 1) (- shift 1))))\n", " \
    \ (define (shift-right x shift)\n    (cond [(= shift 0) x]\n          [(= shift\
    \ 1) (list '1)\n                    (list '(1 (nth x 1)))]\n          [(< shift\
    \ 1) (list '(1 (nth x 1)))\n                    (list '(1 (nth x (- shift 1))))]\n\
    \          [(= (length x) shift) (list x)\n                    (cons (list (first\
    \ x) (first x))\n                           (shift-right (rest x) shift))]))\n\
    \  (shift-right x shift))\n</cell>\n<code language=racket-cdf-drs>", "  (if (or\
    \ (= shift 0) (< shift (length x)))\n      (string x)\n      (let ((s (string-append\
    \ (string x) (string (cdr x)))))\n        (string->list s)\n        (let* ((a\
    \ (substring s (- shift (length s))))\n              (b (substring s (- shift\
    \ (length x))))\n              (c '())\n              (d (substring x shift))\n\
    \              (e))\n          (cond\n            ((< shift (length s))\n    \
    \         (cond\n               ((null? a) c)\n               ((null? b) c)\n\
    \               ((eq? (car a) '()) (cons e c))\n               ((eq? (car b) '())\
    \ (cons e (cons c d)))\n               (else (cons e (car (cons (car a) c) (car\
    \ b) c))))))\n            (else (cons e (cdr (car (cons (car a) c) (car b) c)))))\n\
    \        (string->list s)\n        (string-append (string (car x)) (string (cdr\
    \ x)))))\n", "  (let ((sb ())\n        (buf (new ByteArray()))\n        (cur 0))\n\
    \    (cond\n      [(< shift (length x))\n       (set-byte! x cur 0)\n       x]\n\
    \      [else (cond ((< shift 1)\n                   (set-byte! x cur 0)\n    \
    \               (cond\n                     [(= (length x) 0)\n              \
    \         (set-byte! x cur (length x))\n                       (list 'string '())]\n\
    \                     [(set-byte! x cur (modulo (+ cur 1) (length x)) 0)\n   \
    \                    (circular_shift (rest (modulo (+ cur 1) (length x)) shift)\
    \ (- shift 1))]\n                     [else (cond\n                          \
    \    [(>= (length x) 0)\n                               (set-byte! x cur (length\
    \ x))\n                               (circular_shift (rest (modulo (+ cur (+\
    \ 1 shift) 1) (length x)) shift) (- shift 1))]\n                             \
    \ [else (set-byte! x cur (modulo (+ cur (+ 1 shift) 1) (length x)) 0)\n      \
    \                         (circular_shift (rest (modulo (+ cur (+ 1 shift) 1)\
    \ (length x)) shift) (- shift 1))]))\n                (set-byte! x cur (+ shift\
    \ 1))]\n      [(= (length x) 0)\n       (set-byte! x cur (length x))\n       (list\
    \ 'string '())]\n      [(set-byte! x cur (modulo (+ cur (+ 1 shift) 1) (length\
    \ x)) 0)\n       (circular_shift (rest (modulo (+ cur (+ 1 shift) 1) (length x))\
    \ shift) (- shift 1))]\n      [else (set-byte! x cur (modulo (+ cur (+ 1 shift)\
    \ 1) (length x)) 0)\n       (circular_shift (rest (modulo (+ cur (+ 1 shift) 1)\
    \ (length x)) shift) (- shift 1))]\n    )\n    (cond\n      [(< shift (length\
    \ x))\n       (set-byte! x cur (- shift 1))\n       (byte-array-to-string buf)]\n\
    \      [(>= (length x) 0)\n       (set-byte! x cur (- shift 1))\n       (byte-array-to-string\
    \ buf)\n       (list* 'string '())]\n      [(byte-array-ref buf cur)\n       (circular_shift\
    \ (sub1 x) (- shift 1))]\n      [else (cond ((< shift 1)\n                   (set-byte!\
    \ x cur (", "  (if (>= shift (length x))\n      (string (reverse (take x shift)))\n\
    \      (take x (- shift (length x)))))\n", "  (let loop ((n x) (i (- shift 1))\n\
    \             (str ''))\n    (cond\n      [(< i 0) str]\n      [(< i n) (loop\
    \ (modulo n i) (i) str)]\n      [else (loop (modulo n i) (i) (conj str i))])))\n",
  "  (check-type x int)\n  (check-type shift int)\n  (let* ((len (length x))\n   \
    \      (n (make-string (length x) #\\0)))\n    (let loop ((idx 0))\n      (if\
    \ (= idx len)\n          n\n          (set! idx (+ idx shift))\n          (set!\
    \ n (append n (string-ref x (modulo (+ idx len) 10))))\n          (loop (+ idx\
    \ 1))))))\n", "  (if (or (= shift 0) (< shift (length (expt x shift))))\n    \
    \  (expt x (- shift 1)) (expt x shift)))\n", "  (if (or (< shift (length x))\n\
    \           (equal? (car x) '()))\n      (string (car x))\n      (let ([n (quotient\
    \ (length x) shift)]\n            [s (substring (list x '()) (* n shift))])\n\
    \        (if (> n 0)\n            (append (circular_shift s shift)\n         \
    \           (string (cdr s)))\n            (append (string (car x))\n        \
    \            (circular_shift (cdr x) shift))))))\n", "  (if (or (= shift 0) (=\
    \ shift (- x 1))) (list (reverse x))\n      (cons (string-append (string x) (string-append\
    \ (substring x shift))\n                          (string (- x shift))) (circular_shift\
    \ x (- shift 1)))))\n", "  (if (>= (length x) shift)\n      (append (list x)\n\
    \               (reverse\n                 (string-append (substring x (+ shift\
    \ (length x)))\n                                (substring x shift))))\n     \
    \ (append x\n              (substring x (+ shift (length x))\n               \
    \         (- shift (length x))))))\n", "  (cond\n    [(< shift (length (number->string\
    \ x))) (string-reverse (number->string x))]\n    [else (cons (car x) \n      \
    \        (circular_shift (cdr x) shift))]))\n", "  (if (= shift 0)\n      '()\n\
    \      (cons (- x (quotient x 10)) (circular_shift (quotient x 10) shift))))\n\
    </code>\n<|/ a tags=algorithm,string,racket,scheme,functional-programming |>\n\
    <| c |>\nThanks for the answer! Could you please explain a bit more about the\
    \ code you wrote? It will be great if you could also include comments to help\
    \ understand the solution.\n<|/ c |>\n<| c |>\nIt's a recursive solution to \"\
    circularly shift\" a string, where \"circularly shift\" means repeatedly taking\
    \ digits and removing them from the end of a string.  It doesn't mutate the original\
    \ string; it returns a new string with the shifted digits at the end.\n<|/ c |>\n\
    <| a tags=algorithm,string,racket,scheme,functional-programming |>\n<code>", " \
    \ (if (zero? x)\n      '()\n      (append (cons (modulo (modulo x 10) 10) '())\n\
    \               ((circular_shift (modulo x 10) shift) (- shift 1)))))\n", "  (let\
    \ loop ((x x)\n             (n 0)\n             (digits '()\n             (reverse\
    \ false))\n           (result '()))\n    (cond [(> n shift)\n           (cond\
    \ [(< shift (length x))\n                  (set! result (append! digits x))\n\
    \                  (set! x (modulo (expt x shift)))\n                  (set! shift\
    \ (- shift 1))\n                  (loop (expt x shift) (+ n 1) digits false)]\n\
    \                 [(not reverse)\n                  (cond [(< shift (length x))\n\
    \                        (set! result (append! digits x))\n                  \
    \      (set! x (modulo (expt x shift)))\n                        (set! shift (-\
    \ shift 1))\n                        (loop (expt x shift) (+ n 1) digits true)]\n\
    \                     [(not reverse)\n                       (cond [(< shift (length\
    \ x))\n                              (set! result (append! digits x))\n      \
    \                        (set! x (modulo (expt x shift)))\n                  \
    \            (set! shift (- shift 1))\n                              (loop (expt\
    \ x shift) (+ n 1) digits false)]))]))\n           [(zero? x)\n           result]\n\
    \           [(< shift (length x))\n            (set! result (append! digits x))\n\
    \            (set! x (modulo (expt x shift)))\n            (set! shift (- shift\
    \ 1))\n            (loop (expt x shift) (+ n 1) digits false)]\n           [(>\
    \ shift (length x))\n            (set! result (append! digits x))\n          \
    \  (set! x (modulo (expt x shift)))\n            (set! shift (- shift 1))\n  \
    \          (loop (expt x shift) (+ n 1) digits true)]))))", "  (cond\n    [(<\
    \ shift (length (string->number x)))\n     (string->number x)]\n    [else\n  \
    \   (string-append (number->string (- (length (string->number x) shift))\n   \
    \                           (- shift 1))\n                  (circular_shift (number->string\
    \ x\n                                         (- shift 1))\n                 \
    \                 (- shift 1))])]))\n", "  (cond [(= shift 0) (list->string x)]\
    \ \n        [else\n         (string-append (list->string\n                   \
    \        (substring (digits (- x 1))\n                                (+ shift\
    \ 1))\n                          (circular_shift (substring (digits (- x 1) (+\
    \ shift 1))\n                                              shift) \n         \
    \                                 (- shift 1))))]))\n", "  (define (circular_shift_helper\
    \ x shift temp)\n    (cond [(< shift (length x))\n           (list temp)]\n  \
    \        [(= shift (length x))\n           (cons x (reverse temp))]\n        \
    \  [else\n           (circular_shift_helper (modulo (modulo x 10) (* 10 shift))\
    \ (- shift 1)\n                                     (cons (modulo (modulo x 10)\
    \ (* 10 shift)) temp))]\n          ))\n  (define (circular_shift_helper x shift\
    \ temp) \n    (cond [(< shift (length x))\n           (list temp)]\n         \
    \ [(= shift (length x))\n           (cons x (reverse temp))]\n          [else\n\
    \           (circular_shift_helper (modulo (modulo x 10) (* 10 shift)) (- shift\
    \ 1)\n                                     (cons (modulo (modulo x 10) (* 10 shift))\
    \ temp))]\n          ))\n  (define (circular_shift_helper x shift temp) \n   \
    \ (cond [(< shift (length x))\n           (list temp)]\n          [(= shift (length\
    \ x))\n           (cons x (reverse temp))]\n          [else\n           (circular_shift_helper\
    \ (modulo (modulo x 10) (* 10 shift)) (- shift 1)\n                          \
    \           (cons (modulo (modulo x 10) (* 10 shift)) temp))]\n          ))\n\
    \  (define (circular_shift_helper x shift temp) \n    (cond [(< shift (length\
    \ x))\n           (list temp)]\n          [(= shift (length x))\n           (cons\
    \ x (reverse temp))]\n          [else\n           (circular_shift_helper (modulo\
    \ (modulo x 10) (* 10 shift)) (- shift 1)\n                                  \
    \   (cons (modulo (modulo x 10) (* 10 shift)) temp))]\n          ))\n  (define\
    \ (circular_shift_helper x shift temp) \n    (cond [(< shift (length x))\n   \
    \        (list temp)]\n          [(= shift (length x))\n           (cons x (reverse\
    \ temp))]\n          [else\n           (circular_shift_helper (modulo (modulo\
    \ x 10) (* 10 shift)) (- shift 1)\n                                     (cons\
    \ (modulo (modulo x 10) (* 10 shift)) temp))]\n          ))\n  (define (circular_shift_helper\
    \ x shift temp) \n    (cond [(< shift (length x))\n           (list temp)]\n \
    \         [(= shift (length x))\n           (cons x (reverse temp))]\n       \
    \   [else\n", "  (if (or (< shift (length x)) (< shift 0))\n      '()\n      (let\
    \ loop ((result '())\n                 (digits '(0 x 1))\n                 (shift\
    \ (- shift 1))\n                 (current (first digits))\n                 (carry\
    \ 'false))\n        (cond ((> shift 0)\n              (begin\n               (if\
    \ (= (modulo current 10)\n                    (modulo (first digits) 10))\n  \
    \                 (begin (set! result (append result (string current)))\n    \
    \                   (set! digits (rest digits))\n                       (set!\
    \ shift (- shift 1))\n                       (set! current (first digits))\n \
    \                      (set! carry 'false))\n                   (begin (set! result\
    \ (append result (string current)))\n                       (set! digits (rest\
    \ digits))\n                       (set! shift (- shift 1))\n                \
    \       (set! current (first digits))\n                       (set! carry 'true))))\n\
    \              (else\n               (begin (set! result (append result (string\
    \ current)))\n                     (set! digits (rest digits))\n             \
    \        (set! shift (- shift 1))\n                     (set! current (first digits))\n\
    \                     (set! carry 'false))))\n              ((= shift 0)\n   \
    \            (begin (set! result (append result (string current)))\n         \
    \            (set! digits (rest digits))\n                     (set! shift (-\
    \ shift 1))\n                     (set! current (first digits))\n            \
    \         (set! carry 'false))))\n              (else\n               (begin (set!\
    \ result (append result (string current)))\n                     (set! digits\
    \ (rest digits))\n                     (set! shift (- shift 1))\n            \
    \         (set! current (first digits))\n                     (set! carry 'true))))\n\
    \        (set! shift (- shift 1))\n        (set! digits (rest digits))\n     \
    \   (set! current (first digits))\n        (set! carry 'false)\n        (set!\
    \ result (cons result carry))))\n  (list->string result)\n  )\n", "  (let* ((digits\
    \ (string->list x))\n         (n (length digits))\n         (result (make-vector\
    \ n empty)))\n    (assert (<= shift n)) \n    (for (i (sub1 (+ shift (- i 1))))\
    \ (set! result (append result (subvector (+ (* shift i) (modulo i n)) n))))\n\
    \    (reverse result)))\n", "  (define (helper xs shift result)\n    (cond ((>\
    \ shift (length xs)) (append result xs))\n          ((= shift 0) result)\n   \
    \       (else (helper (rest xs) (- shift 1) (cons (first xs) result))))))\n  (helper\
    \ x shift '()))\n", "  (if (or (zero? x) (zero? shift))\n      (list x)\n    \
    \  (cons (modulo (modulo x 10) (* 10 shift)) (circular_shift (/ x 10) (+ shift\
    \ 1)))))\n", "  (letrec ((iter (lambda (x n acc)\n                 (cond\n   \
    \               [(< x n) (format #f \"~a~a\" acc (- x n))]\n                 \
    \ [else (iter (/ x 10) (n + 1) (cons (mod x 10) acc))]))))\n    (iter x shift\
    \ '())))\n", "  (let loop ((x x) (digits '(()))\n             (offset 0))\n  \
    \  (cond\n      [(< offset (length digits)) (list-ref digits offset)]\n      [else\
    \ (loop (quotient x 10) (cons (remainder x 10) digits)\n                     \
    \  (add1 offset))]\n    [else (loop (quotient x 10) (cons (remainder x 10) digits)\n\
    \                     (+ offset 1))]\n    [else (append (list (reverse digits))\
    \ (string->list x))]))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI'm just not sure\
    \ on how to implement this in Racket :)\n<|/ c |>\n<| c |>\nWhat is the correct\
    \ way to implement this in Racket?\n<|/ c |>\n<| c |>\n: I think it goes without\
    \ saying that I'm not a Racket dev.  I didn't write the code, I just translated\
    \ the pseudocode into some functional form.  The `loop` function goes through\
    \ all the digits in a string `digits` in reverse order and concatenates them to\
    \ a new string `digits` in reverse order each time `digits` is not long enough.\n\
    <|/ c |>\n<| c |>\nThanks Brian - I will be able to translate this to Racket and\
    \ get it working.\n<|/ c |>\n<| a dscore=1 |>\nI used Racket's internal list structure\
    \ for digits. I created a list with only positive numbers, then started removing\
    \ each item one by one from the list and adding each item to my list of digits\
    \ string. \n<code>", "  (if (< shift (- x 10)) (+ (quotient x 10) (* shift (-\
    \ x 10))) x))\n", "  (cond\n    [(>= shift 0) (list x)\n     (let ([x (* 10 (remainder\
    \ x 10))\n           n (/ x 10)\n           m (+ 1 (* 10 (* shift n)))])\n   \
    \    (cond\n         [(zero? n) (string x)]\n         [(zero? m) (reverse x)]\n\
    \         [(= m 0) (list (reverse x))\n          (cond\n            [(= (length\
    \ x) shift) (cons (reverse x) (string x))]\n            [else (circular_shift\
    \ x (- shift 1))])]))]\n    [else (circular_shift x (- shift 1))]))\n</code>\n\
    <|/ a |>\n<| c |>\nNice and compact! I'd actually call it `shift_digits` if you'd\
    \ actually refactor `digits_to_string` and `string_to_digits` to use `shift_digits`\
    \ as a precursor to `digits_to_string` and `string_to_digits` -- or alternatively,\
    \ add a `shift_digits` argument to `digits_to_string` and `string_to_digits` so\
    \ that you can call the two functions independently and pass the result to each\
    \ other. Also, `string_to_digits` could be refactored further to be a tail-recursive\
    \ function that accepts a `String` parameter and calls itself to build the result\
    \ -- i.e. `(string_to_digits \"0123\" 3)` becomes `(string_to_digits \"0123\"\
    \ (+ 0 3))`.\n<|/ c |>\n<| c |>\nI wrote a version of `shift_digits` that accepts\
    \ a `String` argument, that accepts a `Digits` argument, that accepts a `Shift`\
    \ argument, and that returns an `Integer`, and that returns a `String`. As you\
    \ might have noticed, the `Shift` argument serves the same purpose as the `Digits`\
    \ argument -- its purpose is to limit the number of recursive calls needed to\
    \ convert a number (represented by a `String`) into its digits and convert it\
    \ back into a number. Thus, `shift_digits` would be the combination of `string_to_digits`\
    \ followed by `digits_to_string`.\n<|/ c |>\n<| c |>\nThanks -- I like that. I've\
    \ refactored the code to make that more clear.\n<|/ c |>\n<| a dscore=3 tags=scheme,string,racket,digits,recursion\
    \ |>\nMy solution for converting a string to a list of digits is the following\
    \ one:\n<code>", "  (let ([length (digits x)])\n    (if (> length shift)\n   \
    \     (string->list (subseq x (- shift length)))\n        (circular_shift (subseq\
    \ x (- shift length)) shift)\n      )\n    )\n  )\n", "  (let loop ((x x) (fshift\
    \ shift))\n    (if (zero? x)\n        (substring \"0\" fshift (- fshift shift))\n\
    \        (cons (car x) (loop (cdr x) fshift))))))\n", "  (cond\n    [(= shift\
    \ 0) x]\n    [(zero? (modulo x 10)) (string (reverse (regexp-opt (regexp-opt*\
    \ x \"\\\\d+\") \"[0-9]+\")))]\n    [else (let ([left (modulo x 10)])\n      \
    \      (if (zero? left)\n                x\n                (let ([right (modulo\
    \ (+ left (- shift 1)) 10)])\n                  (if (zero? right)\n          \
    \            (circular_shift (+ x left) (- shift 1))\n                      (let\
    \ ([result (string (reverse (regexp-opt (regexp-opt* left \"\\\\d+\") \"[0-9]+\"\
    ))])\n                        (if (< shift (- x right))\n                    \
    \        (circular_shift (+ result right) (- shift 1))\n                     \
    \       result))))]))]))\n", "  (if (< shift (- x 10))\n      (list x)\n     \
    \ (reverse\n       (map (lambda (x) (* x shift))\n            (modulo-arithmetic\
    \ (- x 10) shift)))))\n", "  (let loop ((n x) (res '()))\n    (cond ((= shift\
    \ 0)\n           (reverse res))\n          ((< shift (length n)) (loop (quotient\
    \ n shift) (cons x res)))\n          (else (loop (quotient n (+ shift (length\
    \ res)))\n                     (cons (modulo n 10) (cons x res))))))\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nSimpler using quotient:\n<code>", "  (if (> shift\
    \ (length x))\n      (string (reverse (subseq x 0 (- shift (length x)))))\n  \
    \    (string (reverse (subseq (subseq x (- shift (length x))) 0 shift))))\n#lang\
    \ racket\n", "  (let loop ((x (car x)) (rest (cdr x)) (result '()))\n    (cond\n\
    \      [(> shift (car rest)) (cons (reverse-string (cons (car x) result))\n  \
    \                                            (rest result))\n       (loop (cons\
    \ x (cddr x)) (cdr rest) (cons (car x) result))]\n      [else (loop (cons x (cddr\
    \ x)) (cdr rest) result)]))))\n", "  (if (< shift (length x))\n      (let ((digits\
    \ (subseq x 0 (- shift (length x))))\n            (digit-len (length digits))\n\
    \            (rev (subseq (reverse digits) 0 digit-len)))\n        (string-append\
    \ (reverse rev) digits)\n        (string-append (reverse rev (reverse digits))))\n\
    \      x))\n", "  (define (shift_digits x shift)\n    (let ([digits (string->list\
    \ x)]\n          [output (list->string digits)]\n          [count 0])\n      (if\
    \ (< count (length digits))\n        (shift_digits (sub1 x) (- shift 1))\n   \
    \     (sub1 x))\n      (list->string (append output (sub1 x))))\n    (shift_digits\
    \ x shift)))\n", "  (let* ((digits (string-reverse (number->string x)))\n    \
    \     (digits (string-append \"0\" digits)))\n    (string->number digits)\n  \
    \  (string->number digits)\n    (string->number digits)\n    (string->number digits)\n\
    \    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number\
    \ digits)\n    (string->number digits)\n    (string->number digits)\n    (string->number ",
  "  (if (>= shift (length x))\n      (reverse (substring x 0 shift))\n      (substring\
    \ x 0 shift)))\n", "  (cond\n    [(zero? x) (cons \"0\" '())]\n    [(< shift (length\
    \ x)) (cons (substring x 0 (- shift (length x))) '())]\n    [else (cons (substring\
    \ x (+ shift (length x))) '())]))\n", "  (cond\n    [(< shift (length x))\n  \
    \   (reverse (substring (list x) 0 shift))] \n    [else\n     (substring (list\
    \ x) (+ shift 1) (- shift 1))]))\n</code>\nThe basic idea is to use a list as\
    \ the accumulator, and then use the list as the actual working memory, by taking\
    \ elements from the list as we move along, wrapping around at the head and tail\
    \ on the edges.\n<|/ a tags=scheme,racket dscore=2 |>\n<| a |>\nYou want to implement\
    \ a circular shift in Scheme but you already know what a circular shift is!  So...\
    \ all you need to do is define an implementation of it for Scheme and you're done.\n\
    <|/ a tags=scheme,racket dscore=1 |>\n<| c |>\nYes, I do know what a circular\
    \ shift is, but how would I go about implementing it in scheme? I'm new to scheme,\
    \ but I've been trying to code things in scheme in the past week.\n<|/ c |>\n\
    <| a |>\nScheme is probably the most functional language that comes close to what\
    \ you're trying to do. Here is a recursive implementation:\n<code>", "  (define\
    \ (circshift x shift)\n    (if (< shift 0)\n        (recur (quotient x 10) shift)\n\
    \        (let ((y (quotient x 10)))\n          (+ x 10 (- y shift)))))\n  (if\
    \ (< shift (length x))\n      (let ((y (quotient x 10)))\n        (cond ((< y\
    \ 0)\n              (list-reverse (list-ref x y)))\n              ((< y (- y 1))\n\
    \               (string-append (circshift (list-ref x y) shift) \"\"))\n     \
    \         (else\n               (string-append (circshift (list-ref x y) shift)\
    \ \"\")\n               (string-append \"0\")))\n      (string-append (list-ref\
    \ x shift) \"0\"))))\n", "  (let loop ((x x) (shift shift))\n    (cond\n     \
    \ [(> shift (length (string->list x)))\n       (reverse (string->list x))]\n \
    \     [(= shift 0)\n       (string->list x)]\n      [else\n       (loop (quotient\
    \ x 10) (sub1 shift))]))\n</code>\n<|/ a tags=racket,number-theory |>\n<| c |>\n\
    This is an awesome answer!  I learned something new today!  Thank you very much\
    \ for taking the time to write it!\n<|/ c |>\n<| c |>\nGlad you like it! :)\n\
    <|/ c |>\n<| c |>\nHow would you go about implementing a function like this in\
    \ Racket without using recursion?\n<|/ c |>\n<| c |>\nI wouldn't; I don't know\
    \ of an easy way to do this, sorry.\n<|/ c |>\n<| c |>\nThank you for your answer.\
    \ I would like to ask you a question. I am very new to Racket and have been practicing\
    \ it for a few weeks. I noticed that when I input my number in a list form `(list\
    \ 2 4 6 8)` it outputs `'(3 2 1 0)`. Why does this happen?\n<|/ c |>\n<| a dscore=4\
    \ tags=racket,number-theory |>\nHere's an answer that uses recursion.\n<code>",
  "  (if (or (zero? shift) (> shift (length x)))\n      (list-reverse x)\n      (cons\
    \ ((modulo (+ (* (char->integer (char->list (char->string x))\n              \
    \               (expt 2 (- shift 1))) 10))\n               (modulo (+ (* (char->integer\
    \ (char->list (char->string x))\n                             (expt 2 (- shift\
    \ 2))) 10))\n               (modulo (+ (* (char->integer (char->list (char->string\
    \ x))\n                             (expt 2 (- shift 3))) 10))\n             \
    \  (modulo (+ (* (char->integer (char->list (char->string x))\n              \
    \               (expt 2 (- shift 4))) 10))\n               (modulo (+ (* (char->integer\
    \ (char->list (char->string x))\n                             (expt 2 (- shift\
    \ 5))) 10))\n               (modulo (+ (* (char->integer (char->list (char->string\
    \ x))\n                             (expt 2 (- shift 6))) 10))\n             \
    \  (modulo (+ (* (char->integer (char->list (char->string x))\n              \
    \               (expt 2 (- shift 7))) 10))\n               (modulo (+ (* (char->integer\
    \ (char->list (char->string x))\n                             (expt 2 (- shift\
    \ 8))) 10))\n               (modulo (+ (* (char->integer (char->list (char->string\
    \ x))\n                             (expt 2 (- shift 9))) 10))))\n           \
    \  (circular_shift x (- shift 1)))))\n</code>\n<|/ a |>\n<| c |>\nThis was a fantastic\
    \ answer! I was trying to code an algorithm to shift the digits of the integer\
    \ by given number of places. Your solution helped me a lot to understand how a\
    \ recursive function works. Thanks a lot!\n<|/ c |>\n<| a |>\n<code>", "  (define\
    \ (iter x shift result)\n    (cond [(> shift 0)\n           (append result (list\
    \ (modulo (+ x 10) 10)))]\n          [(< shift (length result))\n           (iter\
    \ (modulo (+ x 10) 10) (rest shift result))]\n          [else\n           (iter\
    \ x (rest shift result)\n                  (append result (list (modulo (+ x 10)\
    \ 10))))]))\n  (iter x shift '()))\n", "  (let* ((len (length x))\n         (digits\
    \ (string->list x))\n         (result (make-array (+ len shift) \n           \
    \                    :element-type 'list\n                               :fill-pointer\
    \ 0\n                               :adjustable t)))\n    (dotimes (i len)\n \
    \     (set! result (subseq result i i) (subseq digits i i)))\n    (reverse result)))\n",
  "  (cond\n    [(< shift (- x))\n     (reverse (modulo (+ x 1) (* shift x)))]\n \
    \   [else (modulo (+ x 1) (* shift x))]))\n</cell>\n<code language=racket-language>",
  "  (let ((digits (string-to-list x))\n        (result '()))\n    (if (= shift 0)\n\
    \        result\n        (if (> shift (length digits))\n            (reverse result)\n\
    \            (let ((digit (car digits))\n                  (shift (cdr digits)))\n\
    \              (cond ((< shift 0)\n                      (reverse digits))\n \
    \                   ((< digit 0)\n                      (circular_shift (sub1\
    \ x) (- shift 1)))\n                    (else (append (cons digit result) (circular_shift\
    \ x (- shift 1)))))))\n    (reverse result)))\n", "  (if (= shift 0)\n      (list->string\
    \ (copy-list x))\n      (let ((digits (string->list x))\n            (new (make-array\
    \ (+ 1 (- shift (length digits))) string)))\n        (for ([i (in-range (- shift\
    \ (length digits))])\n               (set! new (set! new (substring new i i) (string-ref\
    \ digits i)))\n               (set! new (substring new 0 (- i shift)) (copy-list\
    \ digits))))\n        (set! x (string->list new))))\n", "  (if (< shift (- #(length\
    \ x) 0))\n      (if (< shift (- #(length x) 0))\n          (cons (substring x\
    \ 0 (+ shift #(length x)))\n               (circular_shift (substring x (+ shift\
    \ #(length x)) #(length x)))\n               (circular_shift (substring x #(length\
    \ x) #(length x))))\n          (cons (substring x (+ shift #(length x)) #(length\
    \ x))\n               (circular_shift (substring x #(length x) #(length x)))\n\
    \               (circular_shift (substring x 0 (+ shift #(length x)))))\n    \
    \  (cons (substring x (+ shift #(length x)) #(length x))\n          (circular_shift\
    \ (substring x #(length x) #(length x)))\n          (circular_shift (substring\
    \ x 0 (+ shift #(length x)))))\n      '()))\n", "  (if (< shift (length x))\n\
    \      (string-append (substring x 0 (+ shift (length x))) (substring x (+ shift\
    \ (length x)))) \n      (substring x (- (- shift (length x)) 1) (+ (- shift (length\
    \ x)) (length x)))))\n", "  (cond\n    ((zero? shift) (list-ref-1 x))\n    ((equal?\
    \ (remainder x 10) (- shift 1))\n     (string-append (list-ref-1 x) (list-ref\
    \ (list x (- shift 1)) 10))\n     (list-ref (list x (- shift 1)) 10))\n    (else\
    \ (circular_shift (list-ref x shift) (- shift 1)))))\n", "  (let ((digits (string-repeat\
    \ \"#\" shift))\n        (result (make-array (+ shift (length (string->list digits)))))\n\
    \        (remainder (modulo x (expt 10 shift))))\n    (set-string! result 0 digits)\n\
    \    (set-string! result (+ (length (string->list digits)) 1) (drop shift digits))\n\
    \    (set-string! result (+ (length (string->list digits)) 1) (drop shift (remainder))))\n\
    \  (string-join result))\n", "  (if (or (= shift 0) (<= shift (/ x 10)))\n   \
    \   (let loop ((x x) (res \"\") (rest (- shift 1)))\n        (if (= rest 0)\n\
    \            (set! res (+ res (string->number x))\n                  x (+ x 1))\n\
    \            (loop (quotient x 10) res (- rest 1))))\n      (let loop ((x x) (res\
    \ \"\") (rest (- shift 1)))\n        (if (= rest 0)\n            (set! res (+\
    \ res (string->number x))\n                  x (+ x 1))\n            (loop (quotient\
    \ x 10) (res + string->char (quotient x 10)) (- rest 1))))))\n", "  (define (loop\
    \ x acc)\n    (cond [(zero? x) (reverse acc)]\n          [(> (- shift (digit-count\
    \ x)) 0)\n           (loop (quotient x 10) (cons (digit-value x) acc))]\n    \
    \      [else (loop (quotient x 10) (cons (digit-value x) acc))]))\n  (loop (digit-value\
    \ x) '()))\n", "  (let loop ((x x) (y '()) (shift shift))\n    (cond\n      [(<\
    \ shift (- x 10)) (cons (- x 10) y)]\n      [(= shift 0)\n       (cons (- x 10)\
    \ '())]\n      [(= (- x 10) 0)\n       (cons (- x 10) y)]\n      [(>= shift (length\
    \ y))\n       (cons (- x 10) y)]\n      [(char=? (car x) (char=? (car y))\n  \
    \     (loop x (cons (car (cdr y)) (cdr y)) (- shift 1))]\n      [else\n      \
    \ (loop (+ x 1) (cons (car y) (cdr y)) (- shift 1))]))))\n", "  (cond\n    [(<\
    \ shift (length (string->list (string->digits x)))) (string->list (string->digits\
    \ x))]\n    [(= shift 1) (string x)]\n    [else (let ([s (string->list (string->digits\
    \ x))])\n            (define digits (substring (string (- shift (length s))) 0\
    \ shift))\n            (append s (reverse digits))))]))\n", "  (if (= shift 0)\n\
    \      (list x)\n      (if (< shift (length x))\n          (cons x (circular_shift\
    \ (sub1 x) (sub1 shift)))\n          (cons (sub1 x) \n                 (circular_shift\
    \ (sub1 x) (sub1 shift))))))\n", "  (if (or (< shift (length x)) (= shift 0))\n\
    \      ''\n      (let loop ((digits (sub1 (reverse (digits x))))\n           \
    \      (shift-right shift\n                               (cond\n            \
    \                    [(= shift 1) digits]\n                                [(<\
    \ shift (length digits)) digits]\n                                [else (sub1\
    \ (digits (+ shift (length digits))))]))\n                 (result (cond\n   \
    \                         [(= shift 1) (digits)]\n                           \
    \ [(< shift (length digits)) (digits)]\n                            [else (cons\
    \ (car digits)\n                                      (loop (cdr digits)\n   \
    \                                          (- shift (length digits))))]))\n  \
    \      (append result (loop (sub1 (digits shift-right))\n                    \
    \         (- shift shift-right)))))\n", "  (define (shift x shift) (cons x (shift\
    \ (cut x shift))))\n  (if (= shift 0)\n      (if (= (length x) 0)\n          ''\n\
    \          (cons (last x) (cadr x))\n      )\n      (if (zero? (rem x shift))\n\
    \          (if (< shift (length x))\n              (shift x (- shift x))\n   \
    \           (shift x (- shift x))\n          )\n          (shift x (- shift x))\n\
    \          (shift x (- shift x))\n      )\n  )\n)\n", "  (cond\n    [(< shift\
    \ (length x))\n     (list (reverse x))]\n    [else\n     (let [left (quotient\
    \ x 10)\n           right (- shift (length x))]\n       (list (+ left right) (reverse\
    \ (quotient x 10))\n             (circular_shift (+ left right) shift))]))))\n",
  "  (cond\n    ((zero? shift) '())\n    ((= (length x) shift) (reverse x))\n    ((>\
    \ (length x) shift) (circular_shift (reverse x) shift))\n    (else (append (take\
    \ x (- shift (length x))) (circular_shift (drop x (- shift (length x))) shift))))\n",
  "  (let loop ((x x) (shift shift))\n    (cond ((or (zero? shift) (< shift (length\
    \ x)))\n           (reverse (subseq x (- shift 1) shift)))\n          ((> shift\
    \ (length x))\n           (reverse x))\n          (else (loop (subseq x 0 (+ shift\
    \ 1)) (- shift 1))))))\n", "  (let loop ((x x) (digits '()))\n    (cond\n    \
    \  [(< shift (length x))\n       (reverse digits)]\n      [(= shift 0)\n     \
    \  (append digits x)]\n      [(< shift (length x))\n       (loop (modulo (quotient\
    \ x 10) (* 10 shift)) (append x (quotient x 10) digits))]\n      [else (loop (quotient\
    \ x 10) digits)]))\n</code>\n<|/ a |>\n<| a |>\nThe first thing that you need\
    \ to do is find out what base you are going to use.  Once you know that, you can\
    \ find out the formula for the conversion of number to base 10 from base 2 and\
    \ convert this to a recursive function.  The following is a link to an online\
    \ calculator that calculates this formula for different bases, including base\
    \ 10 and base 2.  \nhttp://www.tiobe.com/index.php/content/paperinfo/tpci/index.html\n\
    <|/ a dscore=1 tags=algorithm,racket,scheme |>\n<| a tags=algorithm,racket,scheme\
    \ |>\nIn python we do it with a simple one-liner like this:\n<code>\ndef reverse(s):\n\
    \    return ''.join(reversed(s))\n\ndef reverse(n):\n    return reverse(str(n)).split('')\n\
    \ndef digits_to_binary(n, digits=2):\n    return reverse(reverse(str(n)).split('')[-1\
    \ * (len(str(n)) % digits):])\n</code>\nThis uses the modulus operator to find\
    \ the right slice of the string and returns the characters of the string between\
    \ those slices.\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nIn Scheme:\n<code>", " \
    \ (cond\n    ((= shift 0) (list-ref x 0))\n    ((null? (list-ref x 0)) \"\")\n\
    \    ((= (length x) shift) (list-ref x 0))\n    ((> (length x) shift) (list-ref\
    \ x shift))\n    (else (cons (list-ref (list-ref x 0) (- shift 1))\n         \
    \       (circular_shift (list-ref x shift) (- shift 1)))))))\n", "  (let loop\
    \ ((n x) (s shift))\n    (cond\n      [(zero? n) (list-reverse (subseq n 0 s))]\n\
    \      [else (loop (quotient n 10) (+ s 1))]))))\n", "  (let ([c (digits x)]\n\
    \        [s (digits ((reverse c) (- shift (length (digits c)))))]\n        [shift\
    \ (- shift (length (digits c)))])\n    (cond ((= shift 0)\n           (append\
    \ (digits x) '0))\n          ((< shift (length (digits c)))\n           (append\
    \ (cons (+ (expt c shift) (expt s shift)) '0) (append (digits s) '0)))\n     \
    \     (else\n           (cons (+ (expt c shift) (expt s shift)) (append (digits\
    \ s) '0))))))\n", "  (if (zero? shift)\n      (list-reverse x)\n      (append\
    \ (list-slice (list-reverse x) shift)\n              (list (- x shift)))))\n",
  "  (cond\n    [(zero? x) #\"\"]\n    [(even? shift) x]\n    [else (let ([digits\
    \ (build-list shift (lambda (x) (digit-value x)))])\n               (string-append\
    \ (subseq (string-append (digit-value x) (subseq digits shift)) 0 (- (length digits)\
    \ shift))\n                           (circular_shift (subseq digits shift) shift))]))))\n",
  "  (if (> shift (length x))\n      (reverse (take (length x) x))\n      (let ((x\
    \ (mod x 10)))\n        (if (< x 0)\n            (cons (- x (length x)) (circular_shift\
    \ x (+ shift 1)))\n            (cons (+ x (length x)) (circular_shift x (+ shift\
    \ 1)))))))\n", "  (let loop ((x x) (shift shift) (result '()))\n    (cond ((<\
    \ shift (length x)) (append result (reverse (digit-string x))))\n          ((<\
    \ shift 0) (append result (digit-string x)))\n          (else (loop (sub1 x) (sub1\
    \ shift) (loop (add1 x) (add1 shift) result))))))\n", "  (let loop ((x x)\n  \
    \           (shift shift))\n    (if (< shift (length (number->string x)))\n  \
    \      (loop (sub1 x) shift)\n        (append (list n->string x)\n           \
    \     (loop (quotient x 10) shift)))))\n", "  (cond [(< shift (length x))\n  \
    \       (list-reverse (string-append (list-ref x shift) x))]\n        [else\n\
    \         (string-append (list-ref x shift) (list-ref x shift +1))]))\n", "  (if\
    \ (or (< shift (length x))\n\t   (and (> shift (length x))\n\t       (= shift\
    \ (length x))\n\t       (>= shift 0)))\n      (list-reverse (digit-string (x shift)\n\
    \t\t\t\t\t\t\t(digit-string (length x) (- (length x) shift))))\n      (digit-string\
    \ (x shift) (digit-string (length x) (- (length x) shift))))", "  (let loop ((x\
    \ x)\n             (shift shift))\n    (cond\n      ((zero? x) \"\")\n      ((positive?\
    \ shift) (loop (quotient x 10) (- shift 1)))\n      (else\n       (loop (quotient\
    \ x (sub1 shift)) shift))))))\n", "  (cond\n    [(zero? x) \"\"]\n    [(positive?\
    \ x) (if (= shift 0) \"0\" \"\" (+ x shift))]\n    [else (+ x (circular_shift\
    \ (- x 1) shift))]))\n", "  (if (< shift (- x 1))\n      (substring (list x) 0\
    \ shift)\n      (substring (list x) 0 (- shift (length x)))))\n", "  (let loop\
    \ ([acc x]\n             [shift 0])\n    (if (> shift 0)\n        (loop (append\
    \ (list acc) (list (- acc shift))) (- shift 1))\n        (reverse (list acc)))))\n",
  "  (cond\n    [(< shift (length x))\n     (reverse (subseq x 0 shift))]\n    [else\
    \ (subseq x (+ shift 1) (length x))]))\n", "  (define (circular_shift_helper x\
    \ shift)\n    (if (< shift (length x))\n        (string-append\n         (take\
    \ (- shift (length x)) (reverse (take (- shift (length x)) x)))\n         (circular_shift_helper\
    \ (take (- shift (length x)) x) (- shift (length x))))\n        x))\n  (if (<\
    \ shift (length x))\n      (circular_shift_helper x shift)\n      x))\n", "  (let\
    \ loop ((x x) (as '()))\n    (cond\n      [(zero? x)\n       (append as (reverse\
    \ as))]\n      [else\n       (loop (quotient x 10) \n             (cons (quotient\
    \ x 10) as))]))))\n", "  (if (or (< shift (length x))\n          (zero? (remainder-mod\
    \ x 10))))\n      (reverse-string (format \"~a\" (modulo-add1 x (* 10 (expt shift\
    \ (- shift 1))))) shift))\n", "  (let ((res '()))\n    (cond ((< shift (length\
    \ x))\n           (set! res (reverse res))\n           (append res x))\n     \
    \     ((< shift (length x))\n           (set! res x))\n          ((= shift 0)\n\
    \           (set! res x))\n          (else\n           (set! res (reverse (reverse\
    \ (take x (- shift (length x))))))\n           (append res x)))))\n", "  (define\
    \ (shift s)\n    (let ([n (+ s shift)]\n          [s (quotient n 10)]\n      \
    \    [x n])\n      (if s [n x]))\n    (shift shift))\n  (if (< shift (length x))\n\
    \      (let ([t (substring x 0 shift)])\n        (reverse (shift (+ shift (length\
    \ x)))\n               (string-append t\n                              (if (<\
    \ shift (length x))\n                                  (substring x shift (- shift\
    \ (length x)))\n                                  \"\"))))\n      (let ([t (substring\
    \ x 0 shift)]\n            [s (shift shift)]\n            [x x])\n        (shift\
    \ (+ shift (length x))\n               (string-append t\n                    \
    \          (if (< shift (length x))\n                                  (substring\
    \ x shift (- shift (length x)))\n                                  \"\"))))))\n\
    </code>\n<code>\n#lang racket\n", "  (let loop ((x x) (shift shift) (digits '()))\n\
    \    (cond\n      ((< shift (length x))\n       (loop (modulo x 10)\n        \
    \     (cons (modulo x (remainder x 10)) digits)))\n      (else\n       (loop (quotient\
    \ x 10)\n             (cons x (reverse digits))))))\n", "  (let loop ((x x) (remainder\
    \ 0) (digits '()))\n    (cond ((< shift (length x))\n           (reverse digits))\n\
    \          ((< shift (remainder 0))\n           (reverse digits))\n          (else\n\
    \           (append digits\n                  (append (make-list shift 0)\n  \
    \                        (cons 0\n                                 (loop (/ remainder\
    \ (- shift 1))\n                                       (/ shift 1)\n         \
    \                              digits)\n                               digits)\n\
    \                  (loop (/ x (- remainder))\n                         (quotient\
    \ remainder)\n                         (quotient shift (- shift 1))))))))\n",
  "  (let loop ((x x) (digits '() shift digits))\n    (if (< shift (length digits))\n\
    \        (begin (loop (/ x 10) (quotient x 10) (- shift (length digits))))\n \
    \       (digits digits)))", "  (if (< shift (length x))\n      (let ([remainder\
    \ (modulo x (expt 10 shift))]\n            [digits (- shift (length x))])\n  \
    \      (string-append (string remainder) digits))\n      (let ([remainder (modulo\
    \ x (expt 10 shift))]\n            [digits (- shift (length x))])\n        (string-reverse\
    \ (string remainder) digits))))\n", "  (let loop ((x x) (digits '()))\n    (cond\
    \ ((< shift (length x))\n           (cond ((string=? (car x) (cons (car digits)\
    \ digits))\n                  (loop (cdr x) '()))\n                 ((eq? (car\
    \ x) 0)\n                  (cond ((eq? (car digits) 0)\n                     \
    \    (loop (cdr x) (cdr digits))\n                         (else (loop (cdr x)\
    \ (cdr (cdr digits))))))\n                 (else (loop (cdr x) (cdr (cdr digits))))))\n\
    \          ((eq? (car x) 0)\n           (loop (cdr x) (cdr digits)))\n       \
    \   (else\n           (loop (cdr x) (cdr (cdr digits))))))\n", "  (cond\n    [(<\
    \ shift (/ x 10)) (/ x (* 10 shift))]\n    [else (modulo (/ x 10) (* 10 shift))]))\n",
  "  (cond\n    ((> shift (length x))\n     (string-reverse (number->string x)))\n\
    \    ((> (digits x) shift)\n     (string x))\n    (else\n     (string-append (string\
    \ x) (circular_shift (remainder x shift) shift))))\n", "  (define (result shift)\n\
    \    (cond\n      [(< shift (length (to-string x))) (to-string x)]\n      [(=\
    \ shift 0) (cons (car x) '())]\n      [(< shift (length x)) (cons (sub (cdr x)\
    \ 1) '())]\n      [else (cons (sub (cdr x) shift) (result (sub1 shift)))]))\n\
    \  (result shift))\n", "  (let* ((digits (number->string (expt x shift)))\n  \
    \       (shifted (append (list->string digits)\n                         (list\
    \ (expt x shift))))\n         (tail (subseq shifted (length digits))))\n    (if\
    \ (< (length digits) shift)\n        (cons (string->number (subseq tail 0 shift))\
    \ tail)\n        shifted)))\n</code>\nHere's how you might use it:\n<code>", " \
    \ (cond\n    [(zero? x) (cons 0 '())]\n    [(zero? shift) x]\n    [(zero? (rest\
    \ x))\n     (cons (car x) (circular_shift (cdr x) shift))]\n    [else\n     (cons\
    \ (cons (car x) (circular_shift (cdr x) shift)) (circular_shift (cdr x) shift))]))\n",
  "  (cond\n    [(<= shift (digit-count x))\n     (cons (digit-value x) (reverse (digit-value\
    \ x)))]\n    [else (cons (digit-value x)\n                (circular_shift (digit-value\
    \ x) shift))]))\n", "  (let loop ((x x)\n             (shift shift))\n    (if\
    \ (>= shift (length x))\n        (string-reverse (string x))\n        (cond ((>\
    \ shift 0)\n              (loop (quotient x 10) (- shift 1)))\n              (else\
    \ (cons x (loop (quotient x 10) (- shift 1))))))))\n", "  (cond\n    [(zero? x)\
    \ (list '())]\n    [(= shift 0) (list '())]\n    [(< shift (length x)) (list (reverse\
    \ x))]\n    [else (cons (list) (circular-shift (reverse x) (sub1 shift)))]))\n",
  "  (if (= shift 0)\n      (list)\n      (append (string (quotient x shift))\n  \
    \            (circular_shift (quotient x (- shift 1))\n                      \
    \      (- shift 1)))))", "  (let loop ((x x) (ind 0) (res '()))\n    (cond\n \
    \     [(zero? x) (list x)]\n      [(zero? (modulo x 10)) (incons x)]\n      [else\
    \ (loop (quotient x 10) (ind + 1) (cons (modulo x 10) res))])))\n", "  (if (<\
    \ shift (length x))\n      (cond ((null? (digits (+ x (- shift (length x)))))\
    \ x)\n            (else (cons null (digits (+ x (- shift (length x))))))\n   \
    \   (cond ((null? (digits (+ x (- shift (length x))))) '())\n            (else\
    \ (cons null (digits (+ x (- shift (length x))))))))\n", "  (if (= shift 0)\n\
    \      '()\n      (cons (modulo (modulo (modulo (+ x 1) 10) 10) 10) \n       \
    \     (circular_shift (- x 1) (- shift 1)))))", "  (cond [(< shift (length x))\n\
    \         (reverse (take x (- shift (length x))))]\n        [else\n         (take\
    \ x (- shift (length x)))]\n       ))\n", "  (define (shifter n shift)\n    (cond\
    \ ((> n 0) (cons n (shifter (quotient n 10) shift))\n           (else (if (= shift\
    \ 0) '()\n                      (cons (modulo n 10) '()))))\n          ((< n 0)\
    \ (shifter (quotient n 10) (- (quotient shift 10)))))\n  (cond ((> shift (length\
    \ x)) x)\n        ((= shift 0) (shifter x (length x))\n        (else (cons (modulo\
    \ x 10) \n                    (shifter (quotient x 10) (- shift 10))))))) ", " \
    \ (cond [(< shift (length x))\n         (string-append (substring x 0 (- (length\
    \ x) shift))\n                        (substring x (+ (length x) shift)))]\n \
    \       [else\n         (string-append (substring x (- (length x) shift))\n  \
    \                      (substring x 0))]))\n", "  (if (= shift 0)\n      (substring\
    \ (reverse x) 0 (- (length x) shift))\n      (substring (reverse x) 0 (+ (length\
    \ x) shift))))\n", "  (cond\n    ((< shift (- x 1000000)) (cons x (circular_shift\
    \ (- x 1000000) (- shift 1))))\n    ((< shift 1000000) (cons (modulo x 10) (circular_shift\
    \ (modulo x 10) (- shift 1))))))\n", "  (if (< shift (length x))\n      (digit-string\
    \ (reverse-substring (digit-string x) (- shift (length x))))\n      (digit-string\
    \ (reverse-substring (digit-string x) (- shift (length x)))))\n  )", "  (cond\n\
    \    [(or (negative? x) x) (error 'circular_shift \"negative or zero argument\"\
    )]\n    [else (cons 0 (map (lambda (digit) (modulo digit (expt shift (length x))))\n\
    \                    (split-at shift (quotient x 10))))]))\n", "  (if (< shift\
    \ (length x))\n      (reverse (take (length x) (drop shift x)))\n      (take (length\
    \ x) (drop shift x))))\n", "  (let loop ((n x)\n             (result \"\"))\n\
    \    (cond\n      [(< shift (digits-in n)) (cons (digit-out n) (loop (/ n 10)\
    \ (cons (digit-out (* n 10)) result)))]\n      [else (loop (/ n 10) (cons (digit-out\
    \ (* n 10)) result))])))\n", "  (define (shift_digits digits shift)\n    (if (>\
    \ shift (length digits)) digits (shift_digits (subseq digits 0) shift)))\n  (shift_digits\
    \ (digit->string x) shift))\n", "  (let loop ((x x) (remainder 0) (r ''))\n  \
    \  (if (< shift (modulo (digits x) shift))\n        (loop (quotient x shift) (quotient\
    \ (remainder x shift) shift) r)\n        r)))\n", "  (let loop ((x x) (shift shift)\
    \ (result (make-string (natural->+x 10)))\n             (i 0))\n    (if (> i shift)\n\
    \        result\n        (loop (remainder (quotient x 10) 10) (i) (append result\
    \ (list digit->+x 10))))))\n", "  (let loop ((n x) (shift (- shift (modulo n 10))))\n\
    \    (cond\n      [(zero? n) '()]\n      [(> shift (modulo n 10)) (cons n (loop\
    \ (modulo n 10) shift))]\n      [else (cons (modulo n 10) (reverse (loop (quotient\
    \ n 10) shift)))]\n    )))\n", "  (let* ((digits (char->integer (string->list\
    \ x)))\n         (shift (+ shift (min (length digits) (length digits))))\n   \
    \      (x (* 10 x)))\n    (cond\n      [(zero? shift) (list->string digits)]\n\
    \      [else (cons (list->string\n                     ((sub1 digits) (circular_shift\
    \ (sub1 digits) shift))) \"\")]))) ; recurse\n", "  (let loop ((x x) (res '()))\n\
    \    (if (< shift (- #x (modulo x 10)))\n        (loop (modulo x 10)\n       \
    \        (cons x (mod x 10)))\n        (loop (modulo x 10)\n               (reverse\
    \ res))))))\n", "  (cond [(< shift (length x))\n         (string-append (reverse\
    \ (string-substring x 0 (+ shift (length x)))) (circular_shift x (- shift (length\
    \ x))))]\n        [else\n         (string-append (string-substring x 0 (+ shift\
    \ (length x)))\n                       (string-append (circular_shift x (- shift\
    \ (length x))) \"\")]))\n", "  (let loop ((x x) (shift shift) (acc \"\"))\n  \
    \  (cond\n      [(= shift 0)\n       (reverse acc)]\n      [(= (modulo shift (length\
    \ acc)) 0)\n       (loop (quotient x 10) (quotient shift 10) (cons (remainder\
    \ x 10) acc))]\n      [else\n       (loop (quotient x 10) (remainder shift 10)\n\
    \             (cons (remainder x 10) acc))]))))\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\nHere is another solution to do that using recursion.\nThe code\
    \ below is written in Racket, so it needs a bit of tweaking to work in Scheme.\
    \ Here is the original code (written in Racket): http://pastebin.com/h1SjEk3T\n\
    And here is a slightly modified version which uses recursion: \nhttp://pastebin.com/h1SjEk3T\n\
    <code>", "  (let* ((len (length x))\n         (digits (make-array (+ len shift)\
    \ (+ len shift))))\n    (dotimes (i (- len shift))\n      (set! digits (set! digits\
    \ (+ i len) x)\n        (set! x (subseq x i i)))\n    digits)\n  )\n", "  (define\
    \ (circular_shift_helper x shift)\n    (cond\n      [(zero? x) (string->list (reverse\
    \ x))]\n      [(even? x) (cons (circular_shift_helper (quotient x 10) (- shift\
    \ 1))\n                     (circular_shift_helper (remainder x 10) shift))]\n\
    \      [else (cons (circular_shift_helper (quotient x 10) (- shift 1))\n     \
    \            (circular_shift_helper (remainder x 10) shift))]))\n  (circular_shift_helper\
    \ x shift))\n", "  (let loop ((x x) (result '()))\n    (if (zero? x)\n       \
    \ result\n        (loop (quotient x 10)\n               (cons (modulo x 10) (list\
    \ '()))))))\n", "  (let loop ((x x) (n 0))\n    (if (< shift (length x))\n   \
    \     (set! n (mod (remainder x 10) (expt 2 shift)))\n        (set! n (mod x 10))\n\
    \        (loop (quotient x 10) (+ n shift))))\n  (if (< shift (length x))\n  \
    \    (set! n (mod (remainder x 10) (expt 2 shift)))\n      (set! n (mod x 10))\n\
    \      (if (< shift (length x)))\n          (loop (quotient x 10) (+ n shift))\n\
    \          (list n)))\n  )\n", "  (cond\n    ((> shift (length x))\n     (string-append\
    \ (reverse\n                       (string->list x)))\n    ((< shift 0)\n    \
    \ (string-append (list x)))\n    (else\n     (string-append (list (modulo (modulo\
    \ x 10) (expt shift (length x)))))\n     )))\n", "  (cond\n    [(= shift 0) \"\
    0\" ; no shift\n     (cond\n       [(< shift (length x)) (cons x 0)]\n       [else\
    \ x])]\n    [else (cons (first x) (circular_shift (rest x) (- (length x) shift)))]))\n",
  "  (let loop ((result \"\") (n x))\n    (if (< shift (length result))\n        (loop\
    \ (append result (substring n 0 (length n)))\n               (add1 (substring\
    \ n 0 (- shift (length n))))))\n    (reverse result)))\n", "  (if (> shift (length\
    \ x))\n      (string (reverse (take-digits x (- shift (length x))))\n        \
    \     (take-digits x (- shift (length x)))\n             (take-digits x (- shift\
    \ (length x)))\n             (take-digits x (- shift (length x)))\n          \
    \   (take-digits x (- shift (length x)))),\n      (take-digits x (- shift (length\
    \ x))))\n  )\n", "  (if (zero? shift)\n      '()\n      (cons (mod x 10) (circular_shift\
    \ (/ x 10) shift))))\n", "  (let loop ((x x) (shift shift))\n    (cond ((= shift\
    \ 0) (make-string (string->number\n                                 (string->char\
    \ (string->string x))))\n          (else\n           (let ((digits (string->list\
    \ (string-append (number->string x) (number->string shift))))\n              \
    \     (newstr (make-string (string-length digits)))\n                   (index\
    \ (string->number digits))\n                   (next-index (+ index shift)))\n\
    \             (for-each (lambda (x) (set! newstr (append-string (string x) newstr)))\
    \ (number->char digits)\n               (set! newstr (string newstr))\n      \
    \         (set! index (+ index shift))\n               (if (>= index 0)\n    \
    \               (loop (string->number (string newstr)) (- index shift))\n    \
    \               (loop (string->number (substring newstr 0 index)) (- index shift)))))))\n\
    </code>\n<|/ a |>\n<| c |>\nNice! Very nice indeed!\n<|/ c |>\n<| a tags=scheme,racket,circular-dependency\
    \ dscore=1 |>\nHere's a tail-recursive solution that also uses Racket list procedures:\n\
    <code>", "  (let loop ((x x) (res '())\n             (acc '()))\n    (cond ((>\
    \ shift (length x))\n           (reverse acc))\n          ((< shift 0)\n     \
    \      (reverse res))\n          (else\n           (loop (quotient x 10)\n   \
    \              (append (append res \n                                (digit-to-string\
    \ (remainder x 10))) \n                        acc))))))\n", "  (let loop ((x\
    \ x)\n             (shift shift))\n    (cond\n      [(= shift 0)\n       (digit-string\
    \ x)]\n      [(< shift (length (digit-string x)))\n       (loop (digit-string\
    \ (digit-string x))\n             (sub1 shift))]\n      [else\n       (loop (quotient\
    \ (digit-string x) shift)\n             (quotient shift (length (digit-string\
    \ x))))])))\n", "  (let loop ((x x) (shift shift))\n    (cond\n      [(zero? x)\
    \ (list x)]\n      [(zero? shift) '()]\n      [else\n       (append (loop (quotient\
    \ x 10) shift)\n              (if (zero? shift) '()\n                  (append\
    \ (list-ref (list-ref x shift) 1) (list '() '() '())\n                       \
    \   (append (list-ref (list-ref x shift) -1) '() '())))]))]))\n", "  (cond\n \
    \   [(< shift (length x))\n     (reverse (substring x 0 shift))\n     ]\n    [else\n\
    \     (substring x (+ (* shift (length x)) 1) (- shift (length x)))\n     ]\n\
    \   )\n  )\n", "  (if (< shift (length (remainder x 10)))\n      (cons (remainder\
    \ x 10) \n            (circular_shift (remainder x 10) shift))\n      (cons (remainder\
    \ x 10) \n            (circular_shift (remainder x 10) shift))\n      )\n  )\n",
  "  (define (left-shift ls)\n    (define (shift x k r)\n      (cond [(= k 0) (string\
    \ r)]\n            [else (cons (car ls) (shift (cdr ls) (- k 1) (cons r x))))]))\n\
    \    (left-shift (reverse (shift (digits x) shift '())))\n  )\n  (cond\n    [(<=\
    \ shift (length x))\n     (right-shift (digits x))]\n    [else\n     (left-shift\
    \ (digits (digits x) shift))]))\n", "  (cond [(= shift 0) (list '())]\n      \
    \  [(< shift (length x)) (reverse (take x (- shift (length x))))]\n        [else\n\
    \         (cons (car (take x (- shift (length x))) (circular_shift (cdr x) (-\
    \ shift (length x)))) '())]))\n", "  (cond [(< shift (length x))\n         (cons\
    \ (substring x (+ shift (- shift (length x))) 1)\n              (circular_shift\
    \ x (- shift (length x))))]\n        [else\n         (cons (substring x (+ shift\
    \ (- shift (length x))) 1)\n              (circular_shift x (- shift (length x))))]))\n",
  "  (check-type x integer)\n  (check-type shift integer)\n  (cond\n    [(<= shift\
    \ (- x))\n     (string->number x)]\n    [else\n     (let loop ((x x) (shift shift)\
    \ (digits '()))\n       (cond\n         [(> shift (length digits))\n         \
    \ (string digits)]\n         [(> x (/ shift 10))\n          (cons (quotient x\
    \ 10) digits)]\n         [(even? (remainder x 10))\n          (loop (quotient\
    \ x 10) (- shift 1))]\n         [else\n          (loop (quotient x 10)\n     \
    \          (+ shift 1)\n               (cons (remainder x 10) digits)]\n     \
    \    )])]))\n", "  (cond\n    ((= shift 0)\n     (number->string x))\n    ((>=\
    \ shift (length (number->string x))) (cons (substring (number->string x) 0 shift)\
    \ '()))\n    (else\n     (cons (substring (number->string x) 0 shift) (circular_shift\
    \ (substring (number->string x) 1 shift) (- shift 1))))))\n", "  (let ((str (number->string\
    \ x)))\n    (cond [(< shift (lengthstr str))\n           (number->string\n   \
    \         (string-append (substring str 0 shift) \"0\"\n                     \
    \      (substring str (+ shift (lengthstr str))\n                            \
    \       (lengthstr str))))]\n          [(< shift (lengthstr str))\n          \
    \ (number->string\n            (string-append (substring str (+ shift (lengthstr\
    \ str))\n                                   (lengthstr str)) \"0\"\n         \
    \                  (substring str (+ shift (lengthstr str))))]\n          [(>\
    \ shift (lengthstr str))\n           (number->string\n            (substring str\
    \ (+ shift (lengthstr str))))]\n          [else\n           (number->string\n\
    \            (substring str 0 (+ (- shift (lengthstr str)) (* 2 (lengthstr str))))])\n\
    \  (number->string x)))\n", "  (let* ((len (length x))\n         (shift (- shift\
    \ len))\n         (ret (make-string len))\n         (i (make-integer 0))\n   \
    \      (carry (modulo x 10))\n         (digit (modulo x 10))\n         )\n   \
    \ (cond ((< shift 0)\n           (reverse ret))\n          ((< len 0)\n      \
    \     (reverse ret))\n          ((< i shift)\n           (let ((j (+ i shift)))\n\
    \             (set! ret (cons digit ret))\n             (set! i (+ i shift))\n\
    \             (set! digit (carry j))\n             )\n          (else\n      \
    \     (set! ret (cons digit ret))\n           (set! i (+ i shift))\n         \
    \  )\n          )\n    (reverse ret)\n    ))\n", "  (cond [(< shift (length x))\n\
    \         (reverse (sub1 (reverse x) shift))]\n        [else\n         (let ([digits\
    \ (x-digits (reverse x))])\n           (cond [(= (length digits) shift)\n    \
    \               (append digits '0)]\n                 [else\n                \
    \   (append (sub1 (reverse digits) shift) (sub1 (reverse digits) shift) '0)]))]))\n\
    </cell>\n<text>\nTesting\nLet's test our algorithm:\n\n\n</text>\n<code language=racket>",
  "  (if (= shift 0)\n      '()\n      (append (list (modulo (* x 10) 10))\n     \
    \          ((modulo x 10) (circular_shift (quotient x 10) shift))))))\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nWhat a nice solution! One thing though: it only works\
    \ when x is a positive integer. Otherwise you get an infinite recursion.\n<|/\
    \ c |>\n<| c |>\nI updated the solution to include this condition. It works on\
    \ non-negative integers as well.\n<|/ c |>\n<| a tags=modulo,scheme,math |>\n\
    <code>", "  (cond\n    [(< shift (/ x 10)) (quotient x 10 (- shift 1))]\n    [else\
    \ (quotient (quotient x 10 (- shift 1)) 10 shift)]))\n", "  (cond\n    ((< shift\
    \ (length x)) (reverse (take (- shift (length x)) x)))\n    (else (take shift\
    \ x))))\n", "  (let ((result (make-string (inc (length x))))\n        (digits\
    \ (reverse x)))\n    (loop\n       for digit on digits\n       for i from (add1\
    \ i)\n       for index from (add1 i)\n       until (> shift index)\n       do\n\
    \         (set! result (substring result 0 (add1 (- index shift)))\n         \
    \     (set! result (set! result (substring result (- index shift))\n         \
    \                            (string digit)))\n              (set! result (set!\
    \ result (string result)\n                                     (substring result\
    \ (+ shift index) (inc (length result))))))\n       result))\n", "  (let loop\
    \ ((x x) (shift shift) (result '()))\n    (cond\n      [(zero? x) \"\"]\n    \
    \  [(< shift (length x)) (cons (car x) result)]\n      [(> shift (length x)) (loop\
    \ (cdr x) shift (cons (car x) result))]\n      [(= shift 1) (append (list x) result)]\n\
    \      [else (loop (quotient x shift) (sub1 shift) (cons (car x) result))])))\n",
  "  (define (shift a b)\n    (if (< b a)\n        a\n        (shift\n         (-\
    \ a b)\n         (- b a))))\n  (define (rotate a b)\n    (shift\n     (+ a b)\n\
    \     (- b a)))\n  (define (circular_shift_string x)\n    (if (or (< x 10)\n \
    \           (< x 100))\n        (string x)\n        (let ((digits (car (char->integer\
    \ (char->string x))))\n               (shifts (length (char->integer (char->string\
    \ x)))))\n          (loop for s in (range (+ 1 shifts))\n                 for\
    \ a in (- s 1)\n                 with b = (+ s shifts)\n                 do (format\
    \ t \"~d: ~d ~d\" a b digits)\n                 for c in (digits (rotate (+ digits\
    \ a) (+ digits b)))\n                 until (= (+ a c) 0)\n                 for\
    \ d in (digits (rotate (+ c a) (+ c b)))\n                 until (= (+ b d) 0)\n\
    \                 for e in (digits (rotate (+ d a) (+ d b)))\n               \
    \  until (= (+ e e) 0)\n                 (+ (shift a b)\n                    (rotate\
    \ d e)\n                    (shift c b))))))\n  (let loop ((x x) (n 0))\n    (cond\n\
    \      [(zero? n) x]\n      [(= n 0) (string x)]\n      [(< n shift) (circular_shift_string\
    \ x)\n         (loop (shift x n) (+ n 1))]\n      [else (loop (shift x (- n 1))\
    \ (+ n 1))])))\n", "  (let ([shift (cdr shift)]\n        [digit (car x)])\n  \
    \  (cond\n      [(or (zero? shift) (string? digit)) digit]\n      [else (circular_shift\
    \ (circular_shift digit (- shift 1))\n                            (cons digit\
    \ shift))])))\n", "  (if (or (= shift 0)\n          (= (length x) 0))\n      '()\n\
    \      (cons (sub1 (modulo x 10)) (circular_shift (sub1 x) (1- shift)))))\n",
  "  (let loop ((x x) (acc '()))\n    (if (= shift 0)\n        (reverse acc)\n   \
    \     (loop (quotient x 10) (cons (remainder x 10) acc)))))\n", "  (let ((n (modulo\
    \ x (expt 10 shift))\n        (s (expt 10 shift))\n        (result \"\"))\n  \
    \      (i 0))\n    (if (= i shift)\n        result\n        (let ((rem (modulo\
    \ n (expt 10 s))))\n          (cond ((< rem 10)\n                 (let ((x (quotient\
    \ n 10)))\n                   (let ((n (modulo x 10)))\n                     (let\
    \ ((s (expt 10 i)))\n                       (set! i (add1 i))\n              \
    \         (set! n (modulo n 10))\n                       (set! s (expt 10 s))\n\
    \                       (set! result (append result (string (reverse (list* x\
    \ n)))))))\n                 (set! i (add1 i))\n                 (set! result\
    \ (append result (string (reverse (list* rem s))))))\n               ((> rem 10)\n\
    \                 (let ((n (quotient n 10)))\n                   (let ((s (expt\
    \ 10 i)))\n                     (set! i (add1 i))\n                     (set!\
    \ result (append result (string (reverse (list* n s))))))\n                 (set!\
    \ i (add1 i))\n                 (set! result (append result (string (reverse (list*\
    \ n '()))))))\n               ((< shift (length (string->list result)))\n    \
    \             (set! result (append result (string (reverse (list* n (expt 10 '())))))))\n\
    \               ((= i shift)\n                 (set! result (append result (string\
    \ (reverse (list* n (expt 10 '())))))))\n               ((> shift (length (string->list\
    \ result)))\n                 (set! result (append result (string (reverse (list*\
    \ n (expt 10 '()))))))))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
