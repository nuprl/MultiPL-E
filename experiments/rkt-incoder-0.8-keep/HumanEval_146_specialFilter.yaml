name: HumanEval_146_specialFilter
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes an array of numbers as input\
  \ and returns \n;; the number of elements in the array that are greater than 10\
  \ and both \n;; first and last digits of a number are odd (1, 3, 5, 7, 9).\n;; For\
  \ example:\n;; specialFilter([15, -73, 14, -15]) => 1 \n;; specialFilter([33, -2,\
  \ -3, 45, 21, 109]) => 2\n(define (specialFilter nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n\
  \    (check-equal? (candidate (list 5 -2 1 -5)) 0)\n    (check-equal? (candidate\
  \ (list 15 -73 14 -15)) 1)\n    (check-equal? (candidate (list 33 -2 -3 45 21 109))\
  \ 2)\n    (check-equal? (candidate (list 43 -12 93 125 121 109)) 4)\n    (check-equal?\
  \ (candidate (list 71 -2 -33 75 21 19)) 3)\n    (check-equal? (candidate (list 1))\
  \ 0)\n    (check-equal? (candidate (list )) 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(null? (rest nums)) 0]\n    [(> (first nums) 10) 1]\n\
    \    [(even? (first nums)) 2]\n    [else (+ 1 specialFilter (rest nums))]\n  \
    \  ))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [(= (even? (first nums)) (odd? (first nums)) ) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n\
    \    [(empty? nums) 0]\n    [(> (first nums) 10) (second nums)\n    (odd (first\
    \ nums)) (odd (last nums))\n    (even? (first nums)) (even? (last nums))\n   \
    \ (odd? (first nums)) (odd? (last nums))]\n    [else (+ 1 (specialFilter (rest\
    \ nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(greater-equal 10 ?a) 1]\n\
    \    [(odd? (first ?a)) 2]\n    [(odd? (last ?a)) 1]\n    [else (+ 0 (specialFilter\
    \ (rest nums))) ]))\n", "  \n  ;; count the number of elements in the array that\
    \ are greater than 10\n  (cond [(null? nums) 0]\n        ((null? (cdr nums))\n\
    \         (if (even? (car nums))\n             (+ 1 (specialFilter (cdr nums)))\n\
    \             (+ 1 (specialFilter (cdr nums))))\n        ((odd? (car nums)) 1)\n\
    \        ((even? (car nums)) 2)\n        (else (specialFilter (cdr nums)))))\n",
  "  \n  ; Your code here\n  (define len (length nums))\n  (define arr (make-array\
    \ (+ 2 1) #:initial-contents (list 0 1)))\n  (define (helper cur prev)\n    (if\
    \ (<= len 1)\n        (arr (+ 1 cur) (+ 1 prev))\n        (helper (+ 1 cur) (+\
    \ 1 prev) (+ 1 cur) (+ 1 prev))))\n  (helper 1 0 1)\n  (display (arr (+ 1 1) (+\
    \ 1 1)))\n  (display \"\\n\"))\n", "  (cond\n    [(empty? nums) 0]\n    [(equal?\
    \ (first nums) 1) (+ 1 (second nums))]\n    [(odd? (first nums)) (+ 1 (second\
    \ nums))]\n    [else (+ 1 (specialFilter (rest nums))))))", "  (cond\n    [(empty?\
    \ nums) 0]\n    [else (cond [(even? (first nums)) (+ 1 (specialFilter (rest nums)))]\n\
    \                   [(odd? (first nums)) (+ 1 (specialFilter (rest nums)))]\n\
    \                   [(even? (last nums)) (+ 1 (specialFilter (rest nums)))]\n\
    \                   [(odd? (last nums)) (+ 1 (specialFilter (rest nums)))])]))\n",
  "  (cond\n    ((null? nums) 0)\n    ((> (first nums) 10) (+ (count nums (lambda\
    \ (x y)\n                                          ((even? y) 0))\n          \
    \                        (even? x)))\n    (and (> (first nums) 10) (< (last nums)\
    \ 10) (odd? x))\n    (else (+ (count nums (lambda (x y)\n                    \
    \         ((even? y) 0))\n                         (odd? x)))))\n  )\n)\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nthank you very much for the effort. I would like to\
    \ add that `null?` is racket, and `null?` doesn't exist in Scheme.\n<|/ c |>\n\
    <| c |>\nI revised my code based on your answer above, and am currently working\
    \ on understanding yours.\n<|/ c |>\n<| c |>\nThank you so much for the explanation,\
    \ I really appreciate it.\n<|/ c |>\n<| a |>\nI think this may be the correct\
    \ answer to the question. I tried it out and it works. \n<code>", "  (cond\n \
    \   [(null? nums) 0]\n    [(> (car nums) 10) (specialFilter (cdr nums))]\n   \
    \ [(and (odd? (car nums)) (odd? (cddr nums))) (specialFilter (cdr nums))]\n  \
    \  [else (+ 1 (specialFilter (cdr nums)))]))\n", "  (cond\n    ((null? (rest nums))\
    \ (if (null? (rest nums)) 0 0))\n    ((= (modulo nums 10) 0) (cond\n         \
    \               ((= (modulo (first nums) 2) 1) (specialFilter (rest nums)))\n\
    \                        ((= (modulo (first nums) 2) 0) (+ 1 )))\n           \
    \             ((= (modulo (first nums) 1) 1) (+ 1 )))\n                      \
    \  ))\n    (else (+ 1 (specialFilter (rest nums))))))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(> (first nums) 10) 0]\n    [(odd? (first nums)) 0]\n    [(odd?\
    \ (last nums)) 0]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n\
    \    ;; The first element of the list will be greater than 10\n    ;; And also\
    \ an odd digit\n    [(> (first nums) 10) oddDigits oddDigits2]\n    ;; The last\
    \ element of the list will be greater than 10\n    [(> (last nums) 10) oddDigits2\
    \ oddDigits]\n    ;; Else the list does not include any odd digits at all\n  \
    \  [else 0]))\n</code>\nI changed the function to be called oddDigits2 instead\
    \ of oddDigits. You can't refer to a variable in the cond clause using its name\
    \ which is oddDigits2. \nSo you can call oddDigits instead of oddDigits2. \nNow\
    \ we can rewrite specialFilter a little bit so that we can call it with a list\
    \ of numbers and have it return a list of only odd digits.\n<code>", "  (cond\n\
    \    [(null? nums) 0]\n    [(= (remainder (car nums) 10) 0) 0]\n    [else 1]\n\
    \    [(and (odd? (car nums)) (odd? (remainder (car nums) 10)))\n     (+ 1 (specialFilter\
    \ (cdr nums)))]\n    [else 0]))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first\
    \ nums) 10) (+ 1 (specialFilter (rest nums)))]\n    [(odd? (first nums)) (+ 1\
    \ (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n",
  "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) 0]\n    [(odd? (first\
    \ nums)) 0]\n    [(odd? (last nums)) 0]\n    [else (+ 1 (specialFilter (rest nums)))\
    \ ]\n    )\n  )\n", "  (cond\n    [(null? nums) 0]\n    [(> (first nums) 10) (length\
    \ (filter odd? (rest nums)))]\n    [(odd? (first nums)) (+ (length (filter odd?\
    \ (rest nums))))]\n    [else (length (filter odd? (rest nums)))]))\n", "  (cond\n\
    \    [(empty? nums) 0]\n    [(> (first nums) 10) 0]\n    [(even? (first nums))\
    \ 0]\n    [(odd? (first nums)) 1]\n    [(even? (last nums)) 1]\n    [(odd? (last\
    \ nums)) 0]\n    [else (+ 1 (specialFilter (rest nums)))]))", "  (cond ((null?\
    \ nums) 0)\n        ((> (car nums) 10) 0)\n        ((odd? (car nums)) (+ 1 (specialFilter\
    \ (cdr nums))))\n        (else (+ 1 (specialFilter (cdr nums))))))\n", "  ;; Write\
    \ your code here\n  (cond\n    [(empty? nums) 0]\n    [(even? (car nums))\n  \
    \    (cond\n        [(odd? (car nums)) (+ 1 (specialFilter (cdr nums)))]\n   \
    \     [(even? (cdr nums)) (+ 1 (specialFilter (cdr nums)))]))]\n    [else (+ 1\
    \ (specialFilter (cdr nums))))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a dscore=2\
    \ tags=racket,scheme |>", "  (cond\n    [(empty? nums) 0]\n    [(not (odd? (first\
    \ nums)))\n     (cond\n       [(odd? (last nums)) (+ 1 0)]\n       [(odd? (first\
    \ nums)) (+ 1 0)]\n       [else 0])]\n    [else (+ 1 (specialFilter (rest nums)))\
    \ ]\n   ))\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  (let loop ((nums\
    \ (filter odd? nums)) (count 0))\n    (cond ((empty? nums) count)\n          ((=\
    \ (remainder first (first nums)) 1)\n           (loop (rest nums) (+ count 1)))\n\
    \          (else (loop (rest nums) count))))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=0 |>\n<| a |>\n<code>\n#lang racket\n", "  (cond\n    [(null? nums) 0]\n\
    \    [(> (first nums) 10) 0]\n    [(odd? (first nums)) (+ 1 (specialFilter (rest\
    \ nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    [(null?\
    \ nums) 0]\n    [(>= (car nums) 10) (+ 1 (specialFilter (cdr nums)))]\n    [else\
    \ (+ 1 (specialFilter (cdr nums)))]\n    )\n  )\n", "  (cond\n    ((null? nums)\
    \ 0)\n    ((< (length (first nums)) 3) (+ (length (first nums)) (length (last\
    \ nums))))\n    ((< 1 (first nums)) (+ (length (first nums)) (length (last nums))))\n\
    \    ((< 1 (first nums)) (+ (length (first nums)) (length (last nums))))\n   \
    \ ((< (first nums) (first nums)) (+ (length (first nums)) (length (last nums))))\n\
    \    ((< (first nums) (first nums)) (+ (length (first nums)) (length (last nums))))\n\
    \    ((< 1 (last nums)) (+ (length (first nums)) (length (last nums))))\n    ((<\
    \ 1 (last nums)) (+ (length (first nums)) (length (last nums))))\n    ((< 1 (last\
    \ nums)) (+ (length (first nums)) (length (last nums))))\n    ((< (last nums)\
    \ (last nums)) (+ (length (first nums)) (length (last nums))))\n    ((< (last\
    \ nums) (last nums)) (+ (length (first nums)) (length (last nums))))\n    ((<\
    \ (last nums) (last nums)) (+ (length (first nums)) (length (last nums))))\n \
    \   ((< 1 (first nums)) (+ (length (first nums)) (length (last nums))))\n    ((<\
    \ 1 (first nums)) (+ (length (first nums)) (length (last nums))))\n    ((< 1 (first\
    \ nums)) (+ (length (first nums)) (length (last nums))))\n    ((< 1 (last nums))\
    \ (+ (length (first nums)) (length (last nums))))\n    ((< 1 (last nums)) (+ (length\
    \ (first nums)) (length (last nums))))\n    ((< 1 (last nums)) (+ (length (first\
    \ nums)) (length (last nums))))\n    ((< (first nums) (first nums)) (+ (length\
    \ (first nums)) (length (last nums))))\n    ((< (first nums) (first nums)) (+\
    \ (length (first nums)) (length (last nums))))\n    ((< (first nums) (first nums))\
    \ (+ (length (first nums)) (length (last nums))))\n    ((< (first nums) (last\
    \ nums)) (+ (length (first nums)) (length (last nums))))\n    ((< (first nums)\
    \ (last nums)) (+ (length (first nums)) (length (last nums))))\n    ((< (first\
    \ nums) (last ", "  (if (null? nums)\n      '()\n      (if (number? (car nums))\n\
    \          (if (odd? (car nums))\n              (odd?-odd (car nums))\n      \
    \        (even?-even (car nums))\n              (even?-odd  (car nums)))\n   \
    \       (if (odd? (car (reverse (nums))))\n              (even?-even (car (reverse\
    \ (nums)))) \n              (odd?-odd  (car (reverse (nums))))))\n          (if\
    \ (odd? (car nums))\n              (odd?-odd (car nums))\n              (even?-even\
    \ (car nums))\n              (even?-odd  (car nums))))\n          (if (odd? (car\
    \ (reverse (nums))))\n              (even?-even (car (reverse (nums))))\n    \
    \          (odd?-odd  (car (reverse (nums)))))))\n          (if (odd? (car nums))\n\
    \              (odd?-odd (car nums))\n              (even?-even (car nums))\n\
    \              (even?-odd  (car nums))))\n          (if (odd? (car (reverse (nums))))\n\
    \              (even?-even (car (reverse (nums))))\n              (odd?-odd  (car\
    \ (reverse (nums)))))))\n          (if (odd? (car nums))\n              (odd?-odd\
    \ (car nums))\n              (even?-even (car nums))\n              (even?-odd\
    \  (car nums))))\n          (if (odd? (car (reverse (nums))))\n              (even?-even\
    \ (car (reverse (nums))))\n              (odd?-odd  (car (reverse (nums))))))\n\
    \          (if (odd? (car nums))\n              (odd?-odd (car nums))\n      \
    \        (even?-even (car nums))\n              (even?-odd  (car nums))))\n  \
    \        (if (odd? (car (reverse (nums))))\n              (even?-even (car (reverse\
    \ (nums))))\n              (odd?-odd  (car (reverse (nums))))))))))\n", "  (cond\n\
    \    [(null? nums) 0]\n    [(> (first nums) 10) (+ (specialFilter (rest nums))\
    \ 1)]\n    [(odd? (first nums)) (+ (specialFilter (rest nums)) 1)]\n    [(odd?\
    \ (last nums)) (+ (specialFilter (rest nums)) 1)]\n    [else (+ (specialFilter\
    \ (rest nums)) 1)]\n    ))\n", "  (if (null? nums)\n      0\n      (if (> (car\
    \ nums) 10)\n          (+ 1 (specialFilter (cdr nums)))\n          (+ 1 (specialFilter\
    \ (cdr nums))))))\n", "  (define (helper accum num)\n    (cond\n      [(> num\
    \ 10) (+ accum 1)]\n      [(even? num) (+ accum 1)]\n      [(odd? num) (+ accum\
    \ 1)]\n      [else accum]))\n  (helper 0 nums))\n", "  (cond [(empty? nums) 0]\n\
    \        [(> (first nums) 10)\n         (if (odd? (first nums))\n            \
    \ (+ 1 (specialFilter (rest nums)))\n             (specialFilter (rest nums)))]\n\
    \        [(odd? (first nums))\n         (+ 1 (specialFilter (rest nums)))]\n \
    \       [else\n         (specialFilter (rest nums))]))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(> (first nums) 10) (cond \n                        [(even? (first\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(odd? (first\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(even? (last\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (last\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (rest\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n                        [(even? (rest\
    \ nums)) (+ 2 (specialFilter (rest nums)))]\n                        [(odd? (",
  "  (cond [(null? nums) 0]\n        [(and (number? (car nums)) (odd? (car nums)))\
    \ (+ 1 (length (filter (odd? (car nums)) (cdr nums))))]\n        [(odd? (car nums))\
    \ (+ 1 (length (filter (odd? (car nums)) (cdr nums))))]\n        [else (+ 1 (length\
    \ (filter ((lambda (x) (and (odd? (car nums)) (odd? (car nums)))) (cdr nums))))]\n\
    \    )\n)\n", "  (cond\n    [(empty? nums) 0]\n    [(odd? (car nums)) (odd? (cdr\
    \ nums))]\n    [(even? (car nums)) (even? (cdr nums))]\n    [else (+ 1 (specialFilter\
    \ (cdr nums)))]))\n</code>\n<|/ a dscore=1 |>\n<| a tags=racket,scheme |>\nI think\
    \ your code is good enough.\nYou can simplify your code this way:\n<code>", " \
    \ (cond\n    ((null? nums) 0)\n    ((> (car nums) 10) (specialFilter (cdr nums)))\n\
    \    ((odd? (car nums)) \n     (if (odd? (car nums)) \n           (+ 1 (specialFilter\
    \ (cdr nums))) \n           (specialFilter (cdr nums))))\n    ((odd? (cdr nums))\
    \ \n     (if (odd? (cdr nums)) \n           (+ 1 (specialFilter (cdr nums))) \n\
    \           (specialFilter (cdr nums))))))", "  (cond [(null? (car nums)) #f]\n\
    \        [(even? (car nums)) (+ 1 (specialFilter (cdr nums)))]\n        [(odd?\
    \ (car nums)) (+ 1 (specialFilter (cdr nums)))]\n        [else (+ 1 (specialFilter\
    \ (cdr nums)))]))\n", "  (count-if (lambda (x) \n                (and (> x 10)\
    \ (odd? (first x)) (odd? (last x))))\n            nums))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(odd? (first nums)) (+ 1 (specialFilter (rest nums)))]\n    [else\
    \ (+ 1 (specialFilter (rest nums)))]))\n  ", "  (cond\n    [(empty? nums) 0]\n\
    \    [(member (car nums) (list 1 3 5 7 9)) (+ 1 (specialFilter (cdr nums)))]\n\
    \    [else (+ 1 (specialFilter (cdr nums)))]))\n</code>\n<|/ a dscore=0 tags=racket,scheme,functional-programming\
    \ |>\n<| c |>\nThe `member` check is redundant, since `(list 1 3 5 7 9)` already\
    \ contains those elements.\n<|/ c |>\n<| a tags=racket,scheme,functional-programming\
    \ |>\nIn your first attempt you defined specialFilter as a recursive function\
    \ and used an accumulator to store the values you compute.\nIn your second attempt\
    \ you used a named let which has access to the accumulator so you can output the\
    \ result of the accumulator at the end. Though this can be accomplished in a single\
    \ function, it would be much clearer if it were written as a loop.\n<code>", " \
    \ (cond\n    [(null? nums) 0]\n    [(> (length nums) 1)\n      (if (odd? (first\
    \ nums))\n         (odd? (last nums))\n         0))]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(not (even? (first\
    \ nums)))\n     (cond\n       [(even? (last nums))\n        (+ 1 (specialFilter\
    \ (rest nums)))]\n       [else\n        (+ 1 (specialFilter (rest nums)))]\n \
    \      )]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    ((=\
    \ (length nums) 0) 0)\n    ((= (odd? (first nums))) 0)\n    (else (+ (specialFilter\
    \ (rest nums)) 1))))\n", "  (cond\n    [(null? nums) 0]\n    [(= (length nums)\
    \ 1) 1]\n    [(> (first nums) 10) (+ 1 (specialFilter (rest nums)))]\n    [else\
    \ (+ 1 (specialFilter (rest nums)))]))\n", "  (cond ((null? nums) 0)\n       \
    \ (else (and (> first nums) (odd? (rest nums)) (odd? (first nums)) (odd? (last\
    \ nums)))\n               (+ 1 (specialFilter (rest nums))))))\n", "  (cond\n\
    \    [(empty? nums) 0]\n    [else (cond\n\t    [(number? (first nums)) 1]\n\t\
    \    [(number? (last (first nums))) 1]\n\t    [(odd? (first nums)) (cons (first\
    \ nums) 1)]\n\t    [(odd? (last (first nums))) (cons (last nums) 1)]\n\t    [else\
    \ (+ 1 (specialFilter (rest nums)))]))])\n</code>\n<|/ a |>\n<| c |>\nthank you\
    \ for the answer, but i just started learning racket and am struggling to implement\
    \ what you wrote here. would you mind explaining what your code actually does?\n\
    <|/ c |>\n<| c |>\nHi, I added some explanations to my answer.\n<|/ c |>\n<| c\
    \ |>\nHi Jack , I noticed that you used cond two times, I have never seen this\
    \ type of syntax before. Could you explain what exactly the purpose of the code\
    \ is? Also, where is the second cond coming from?\n<|/ c |>\n<| c |>\nThe `cond`\
    \ has three conditional branches.  If the first condition is true, it continues\
    \ to the next condition, if it is the other two, it adds the result from the two\
    \ branches together, then goes to the next condition.  The `cond` function evaluates\
    \ the first condition and returns the value from the first branch of the `cond`\
    \ if the condition is true.  If the first condition isn't true, the function doesn't\
    \ continue to evaluate the other conditions, it just returns `0`.  I hope that\
    \ clears it up.\n<|/ c |>\n<| a dscore=0 tags=scheme |>\n<code>", "  (cond [(null?\
    \ nums) 0]\n        [else (+ 1 (apply filter (lambda (x) (and (odd? (first x))\
    \ \n                                                   (odd? (last x)))\n    \
    \                                    nums))))])\n", "  (cond\n    [(empty? nums)\
    \ 0]\n    [(odd? (first nums)) (+ 1 (specialFilter (rest nums)))]\n    [(even?\
    \ (first nums)) (+ 1 (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter\
    \ (rest nums))) ]\n))\n", "  (cond\n    [(null? nums) 0]\n    [(> (first nums)\
    \ 10) 0]\n    [(odd? (first nums)) 0]\n    [(odd? (last (rest nums))) 0]\n   \
    \ [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    [(empty? nums)\
    \ 0]\n    [(even? (car nums)) 1]\n    [(odd? (car (rest nums))) 1]\n    [else\
    \ (+ \n             (specialFilter (rest nums))\n             (specialFilter (cdr\
    \ nums))\n             )]))\n", "  (cond \n    ((null nums) 0)\n    ((= (length\
    \ nums) 1) (if (odd? (first nums)) (+ 1 (odd? (first nums))) (odd? (first nums))))\n\
    \    ((= (length nums) 2) (if (odd? (first nums)) (+ 1 (odd? (first nums))) (odd?\
    \ (first nums))))\n    (else\n     (if (odd? (first nums)) (+ 1 (odd? (first nums)))\
    \ (odd? (first nums)))))\n)\n", "  (if (empty? nums)\n      0\n      (+ (* (expt\
    \ (* (first (first nums)) (+ 2 (last (first nums))))) \n          (expt (* (last\
    \ (first nums)) (+ 2 (first (last nums))))))))\n</code>\n<|/ a dscore=2 tags=racket,scheme\
    \ |>\n<| c |>\nThanks! I am quite new to scheme and Racket and I didn't know about\
    \ those procedures\n<|/ c |>\n<| c |>\nAh so I should write procedures to do this\
    \ problem and then I can call them in my code?\n<|/ c |>\n<| c |>\nYes, exactly.\
    \ The function should take an array of numbers and return the number of elements\
    \ in the array that are greater than 10 and both first and last digits of a number\
    \ are odd (1,3,5,7,9).\n<|/ c |>\n<| c |>\nI wrote the code in the question to\
    \ give you some idea of what I'm supposed to do. I don't have any idea of how\
    \ to get the function to work.\n<|/ c |>\n<| c |>\nI edited the code in the question\
    \ to show what I have so far, but I don't know how to get the function to work\n\
    <|/ c |>\n<| a |>\nI used the code provided to complete the solution to the problem.\
    \ \n<code>", "  (cond [(= (remainder nums 10) 10) 0]\n        [(and (odd? (first\
    \ nums)) (odd? (last nums))) 1]))\n</cell>\n<code language=dyalog-kernel>\n#lang\
    \ racket\n", "  (cond\n    [(empty? nums) 0]\n    [(> first first last) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [(= first 1) (+ 1 (specialFilter (rest nums)))]\n    [(=\
    \ last 1) (+ 1 (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter (rest\
    \ nums)))]))\n</code>\n<|/ q dscore=2 |>\n<| c |>\n\"Write a function that takes\
    \ an array of numbers as input and returns the number of elements in the array\
    \ that are greater than 10 and both first and last digits of a number are odd\
    \ (1, 3, 5, 7, 9).\"  What do you mean by \"digits\"?  Do you mean only the first\
    \ and last digits (so if your input was 123, should the result be 1, because 1\
    \ and 3 are both odd)?\n<|/ c |>\n<| c |>\nYes, my bad.  I meant first and last\
    \ digits of a number to be odd.  Sorry for the confusion.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nOne way to implement this functionality is to first convert the input list\
    \ into a list, where each element of the list is either #t (the first element\
    \ is an odd digit) or #f (the other elements are odd digits).  Then count the\
    \ elements that are #t, which is the number of elements that are odd, and then\
    \ subtract the count that are not #t\n<code>", "  (define (helper-loop n count)\n\
    \    (if (zero? n)\n        count\n        (helper-loop (quotient n 10) (inc count))))\n\
    \  (if (and (not (null? nums)) (not (null count)))\n      (helper-loop (car nums)\
    \ (cond [(= n 0) (cons n count)] [(even? (car nums)) (cons (car nums) count)]\
    \ [(odd? (car nums)) (cons (car nums) count)]))\n      '()))\n", "  (cond\n  \
    \  [(empty? nums) 0]\n    [(odd? (first nums)) (+ 1 (specialFilter (rest nums)))]\n\
    \    [(odd? (last nums)) (+ 1 (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  (cond\n     ;; Check that the list is not empty.\n \
    \    ((null? nums) 0)\n     ;; Check that all elements are numbers.\n     ((number?\
    \ nums) \n       ;; Filter out all numbers that are less than 10.\n       ;; If\
    \ an element is not a number, then it is filtered out.\n       (filter (lambda\
    \ (x) (> x 10))\n              (map number? (reverse nums))))\n     ;; Filter\
    \ out all odd digits.\n     ((odd? (first nums))\n       ;; Filter out all odd\
    \ digits of first number.\n       ;; If an element is not a number, then it is\
    \ filtered out.\n       (filter (lambda (x) (odd? (first x)))\n              (map\
    \ number? (reverse nums))))\n     ;; Filter out all even digits.\n     ((even?\
    \ (first nums))\n       ;; Filter out all even digits of first number.\n     \
    \  ;; If an element is not a number, then it is filtered out.\n       (filter\
    \ (lambda (x) (even? (first x)))\n              (map number? (reverse nums))))\n\
    \     ;; Otherwise, there is an odd first and even last digit.\n     ((odd? (last\
    \ nums))\n       ;; Filter out all odd digits of last number.\n       ;; If an\
    \ element is not a number, then it is filtered out.\n       (filter (lambda (x)\
    \ (odd? (last x)))\n              (map number? (reverse nums))))\n     ;; Filter\
    \ out all even digits.\n     ((even? (last nums))\n       ;; Filter out all even\
    \ digits of last number.\n       ;; If an element is not a number, then it is\
    \ filtered out.\n       (filter (lambda (x) (even? (last x)))\n              (map\
    \ number? (reverse nums))))))\n</code>\n<|/ a |>\n<| c |>\nThis works too, but\
    \ I prefer the answer that uses `take` and `drop`, which can be written in a functional\
    \ way using [`take`](http://docs.racket-lang.org/reference/pairs.html#(def.%28%28lib._racket%2Fprivate%2Flist..rkt%29._take%29))\
    \ and [`drop`](http://docs.racket-lang.org/reference/pairs.html#(def.%28%28lib._racket%2Fprivate%2Flist..rkt%29._drop%29)).\n\
    <|/ c |>\n<| c |>\nThanks a lot. I added your code to my answer since this question\
    \ seems to be getting a lot of views and also this one is already answered. Of\
    \ course if you prefer using libraries then it would be even better.\n<|/ c |>\n\
    <| c |>\nI like yours better too - ", "  (cond\n    [(null? nums) 0]\n    [(and\
    \ (> first first last) (odd? first)) (+ 1 (specialFilter (rest nums)))]\n    [else\
    \ (+ 1 (specialFilter (rest nums)))]))", "  (cond\n    ((empty? nums) 0)\n   \
    \ ((even? (first nums)) and (odd? (last (rest nums))))\n    (else (+ 1 (specialFilter\
    \ (rest nums))))\n    )\n  )\n)\n", "  (let ((i 0))\n    (cond\n      [(null?\
    \ (car nums)) 0]\n      [else (cond [(or (odd (first (car nums)))\n          \
    \              (odd (last (car nums))))\n                       (+ 1 (specialFilter\
    \ (cdr nums)))]\n                    [else (+ 1 (specialFilter (cdr nums)))]))]))\n",
  "  (cond\n    [(empty? nums) 0]\n    [(even? (first nums)) 1]\n    [(odd? (first\
    \ nums)) 0]\n    [else\n     (if (odd? (last nums)) (add1 (specialFilter (sub1\
    \ nums))))\n     (add1 (specialFilter (sub1 nums)))]))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(number? nums) 1]\n    [else (+ 1 (specialFilter (filter (number?\
    \ (car nums)) (map car nums))))]))\n", "  (count-odd\n   (count-odd (count-odd\
    \ (cdr nums)) (car nums))))\n", "  (let ((len (length nums)))\n    (cond ((zero?\
    \ len) (+ (- 1 len) 1))\n          ((odd? first) (odd? last))\n          (else\
    \ (+ 1 (specialFilter nums))))))\n</code>\n<|/ q dscore=0 |>\n<| c |>\nYour code\
    \ is wrong (it returns 0 for an empty list instead of 1), and you shouldn't use\
    \ `first` and `last` at all.\n<|/ c |>\n<| c |>\nI thought it was obvious, that's\
    \ why I didn't include it into the question. I didn't get how you got that result,\
    \ can you explain it a bit? I thought I understood it. Also, I didn't get what\
    \ do you mean by I shouldn't use `first` and `last`, can you explain it a bit?\n\
    <|/ c |>\n<| c |>\nYeah, that's why I didn't put it into the question. I'm actually\
    \ not sure if it's even correct and what should I use instead. Can you please\
    \ help me with it?\n<|/ c |>\n<| c |>\nIt's not obvious to you as to how you got\
    \ that result.  You are using the variable names as if they are defined in terms\
    \ of the functions `first` and `last`.  These are predefined in the Racket language.\
    \  `first` is the first element of an array, `last` is the last element, and they\
    \ don't appear in your code.  If you want to write your function so that it works\
    \ with arrays, it has to accept an array.  That means you can't use `first` and\
    \ `last`, because they don't exist in arrays.\n<|/ c |>\n<| c |>\nI see, but how\
    \ should I modify it to make it accept arrays?\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nThe problem is with your function; it doesn't accept arrays. It only accepts\
    \ lists.\nWhat you can do is use the array library to convert your list to an\
    \ array, and then use your function to compute the length of the array.\n<code>\n\
    #lang racket", "  (cond\n    ((null? nums) 0)\n    ((> (first nums) 10) 1)\n \
    \   ((odd (first nums)) 2)\n    ((odd (last nums)) 2)\n    (else (+ (specialFilter\
    \ rest nums) 1))))\n", "  (cond\n    [(null? nums) 0]\n    [(< 0 (car nums)) 0]\n\
    \    [else (+ 1 (lengthOfEvenAndOdds (car nums) (cadr nums))\n              (lengthOfEvenAndOdds\
    \ (caddr nums) (cadddr nums))\n              (lengthOfEvenAndOdds (caaddr nums)\
    \ (caadddr nums))\n              (lengthOfEvenAndOdds (caadddr nums) (caadddr\
    \ nums)))]))\n", "  (if (null? nums) 0\n      (if (> (car nums) 10) (+ 1 (specialFilter\
    \ (cdr nums)))\n          (if (odd? (car nums)) and (odd? (last nums)) (+ 1 (specialFilter\
    \ (cdr nums)))))))", "  (if (empty? nums)\n      0\n      (if (> (first nums)\
    \ 10) \n          1\n          (if (odd? (first nums)) \n              1\n   \
    \           (if (odd? (last nums)) \n                  1\n                  (if\
    \ (odd? (first nums) (last nums)) \n                      2\n                \
    \      (if (odd? (first nums) (last nums) (second nums)) \n                  \
    \        (+ 1 2))))))))\n", "  (cond\n    [(empty? nums) 0]\n    [(number? (car\
    \ nums)) 1]\n    [else (+ (specialFilter (cdr nums)) \n            (specialFilter\
    \ (map (lambda (n) (if (even? (car n)) (cdr n) (car n)) n)) nums))]))\n</code>\n\
    <|/ q |>\n<| c |>\nThis looks like a homework problem.  Can you share the code\
    \ that you have already tried?\n<|/ c |>\n<| c |>\nWhat do you think this `nums`\
    \ represents: `[(number? (car nums)) 1]` ?\n<|/ c |>\n<| a dscore=1 tags=scheme,racket\
    \ |>\nIt can be done with this:\n<code>", "  (cond\n    [(empty? nums) 0]\n  \
    \  [(> (first nums) 10) 0]\n    [(and (odd? (first nums)) (odd? (last nums)))\
    \ 1]\n    [else 2]\n   ))\n", "  (define (oddAndFirstLastOdd n)\n    (cond\n \
    \     [(= (remainder n 2) 0) (odd? (first n) (remainder (first n) 2))]\n     \
    \ [(= (remainder n 2) 0) (odd? (first n) (remainder (first n) 2))]\n      [else\
    \ (odd? (first n) (remainder (first n) 2))]))\n  (cond\n    [(null? nums) 0]\n\
    \    [else (+ 1 (length (remove-if (lambda (n) (oddAndFirstLastOdd n)) nums)))]))\n",
  "  (cond\n    ((null? nums) 0)\n    ((null? (cdr nums)) 0)\n    ((odd? (first nums))\
    \ and (odd? (last nums))) 1))\n", "  (let loop ([nums nums sum 0])\n    (if (null?\
    \ nums) \n        sum\n        (loop (cdr nums)\n             (+ sum (- 10 (expt\
    \ (first nums) 2))\n                (expt (last nums) 2))\n             (if (odd\
    \ (expt (first nums) 2))\n                1 (if (even (expt (last nums) 2))\n\
    \                     1 (+ sum 1)))))))\n</code>\nNote that I'm using a named\
    \ let for loop instead of for/sum. This is just personal preference.\n<|/ a tags=scheme\
    \ |>\n<| c |>\n+1 I like this solution for its comprehensibility. I'm still trying\
    \ to figure out how to do it in Racket though.\n<|/ c |>\n<| a tags=scheme dscore=1\
    \ |>\n<code>", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) 0]\n\
    \    [(odd? (first nums)) 0]\n    [(odd? (last nums)) 0]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(odd? first last)\
    \ 1]\n    [else 0]))\n", "  (cond\n    ((= (length nums) 0) 0)\n    ((= (% nums\
    \ 10) 0) 0)\n    ((= (/ nums 10) 1) (+ 1 (specialFilter (/ nums 10))))\n    (else\
    \ (+ 1 (specialFilter (/ nums 10))))\n    (else (+ 2 (specialFilter (/ nums 10))))))\n",
  "  (cond\n    ((empty? nums) 0)\n    ((> (first nums) 10) 1)\n    ((odd? (first\
    \ nums)) 1)\n    ((odd? (last nums)) 1)\n    (else (+ (specialFilter (rest nums))\
    \ (specialFilter (rest nums))))))\n", "  (cond\n    [(empty? nums) 0]\n    [(even?\
    \ (first nums)) (+ 1 (specialFilter (rest nums)))]\n    [(odd? (first nums)) (+\
    \ 2 (specialFilter (rest nums)))]\n    [else (+ 3 (specialFilter (rest nums)))]\n\
    \    )\n  )\n  )\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10)\
    \ 1]\n    [(and (even? (first nums))\n           (odd? (second nums)))\n    2]\n\
    \    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (define (oddDigits-first\
    \ nums)\n    (cond ((or (zero? nums) (odd? nums)) (set! nums (filter odd? nums)))\n\
    \          ((odd? nums) nums)\n          (else (oddDigits-first nums))))\n\n \
    \ (define (oddDigits-last nums)\n    (cond ((or (zero? nums) (odd? nums)) (set!\
    \ nums (filter odd? nums)))\n          ((odd? nums) nums)\n          (else (oddDigits-last\
    \ nums))))\n\n  (define (oddDigits-all nums)\n    (cond ((or (zero? nums) (odd?\
    \ nums)) (set! nums (filter odd? nums)))\n          ((odd? nums) nums)\n     \
    \     (else (oddDigits-all nums))))\n\n  (define (specialFilter-helper nums count)\n\
    \    (if (or (null? nums) (= count 0))\n        (count-1)\n        (if (oddDigits-first\
    \ nums)\n            (specialFilter-helper (oddDigits-last nums) (- count 1))\n\
    \            (specialFilter-helper nums (+ count 1)))))\n\n  (specialFilter-helper\
    \ nums 0))\n", "  (cond\n    ((null? nums) 0)\n    ((null? (cdr nums)) (+ 1 (length\
    \ (filter (lambda (n v) (and (odd? (first n)) (odd? (last n))))\n            \
    \                             (rest nums))))\n    ((and (odd? (first nums)) (odd?\
    \ (last nums))) (+ 1 (length (filter (lambda (n v) (and (odd? (first n)) (odd?\
    \ (last n))))\n                                                   (rest nums))))\n\
    \    (else (+ 1 (length (filter (lambda (n v) (and (odd? (first n)) (odd? (last\
    \ n))))\n                                     (rest nums))))))\n", "  (define\
    \ (loop nums count)\n    (cond ((null? nums) count)\n          ((> 1 (car nums)\
    \ 10) (loop (cdr nums) (+ count 1)))\n          (else (loop (cdr nums) count))))\n\
    \  (loop nums 0))\n", "  (let ((sum (car nums))\n        (carry (cons 0 (cdr nums))))\n\
    \    (cond ((= sum 10) (car nums))\n          ((odd? sum) (+ 1 (odd? (car nums))))\n\
    \          ((even? (car (first nums)))\n           (cond ((odd? (first nums))\
    \ (+ 1 (odd? (first nums))))\n                 ((even? (last nums)) (+ 1 (even?\
    \ (last nums))))))\n          ((even? sum) (+ 1 (even? (car nums))))\n       \
    \   ((odd? (first nums)) (+ 1 (odd? (first nums))))\n          ((odd? (last nums))\
    \ (+ 1 (odd? (last nums))))\n          (else (cond ((odd? (first nums)) (+ 1 (odd?\
    \ (first nums))))\n                     ((even? (last nums)) (+ 1 (even? (last\
    \ nums)))))))))\n", "  (cond\n    [(or (>= (length nums) 0) (> (length nums) 0))\
    \ 0]\n    [(and (number? (first nums)) (odd? (first nums))) 0]\n    [(and (number?\
    \ (last nums)) (odd? (last nums))) 0]\n    [(and (number? (first nums)) (odd?\
    \ (first nums)) (odd? (last nums))) 0]\n    [(and (number? (last nums)) (odd?\
    \ (first nums)) (odd? (last nums)) (odd? (second (last nums)))) 0]\n    [else\
    \ (+ 1 (specialFilter (rest nums)))]))", "  (define (odd n m)\n    (cond\n   \
    \   [(= (modulo n 2) 1) (+ m 1)]\n      [else (odd  n (- m 1))]))\n  (let ([i\
    \ (length nums)])\n    (cond\n      [(= i 0) 0]\n      [(odd  (first nums) 0)\n\
    \       (odd  (first nums) (first nums))]\n      [else\n       (even (last nums)\
    \ (first nums))\n       (even (last nums) (first nums))]\n      (* i (+ 1 i)))\n\
    \  ))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nAm I misunderstanding the\
    \ question?  I thought this was supposed to be a challenge for Racket :-)\n<|/\
    \ c |>\n<| a tags=racket,scheme |>\nI know I'm late to the party, but here's a\
    \ version using \"foldr\":\n<code>", "  (cond\n    [(null? nums) 0]\n    [else\
    \ (cond\n             [(< nums 10) 1]\n             [(< 0 (remainder nums 10)\
    \ odd)\n              (and\n               (= 0 (remainder nums 10))\n       \
    \        (odd? (remainder nums 10)))]\n             )]))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(> (first nums) 10) (+ 1 (specialFilter (rest nums)))]\n    [(and\
    \ (odd (last nums))\n           (odd (first nums))) (+ 1 (specialFilter (rest\
    \ nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    ((null?\
    \ nums) 0)\n    ((equal? (first nums) (last (first nums))) (odd? (first nums)))\n\
    \    (else\n     (cond\n       ((equal? (first nums) (first (first nums))) (odd?\
    \ (first nums)))\n       ((equal? (first (first nums)) (last (first nums))) (odd?\
    \ (first nums)))\n       (else (+ (specialFilter (rest nums)) (* 2 (specialFilter\
    \ (first nums)))))\n       )\n     )\n   )\n  )\n)\n", "  (cond\n    ((null? nums)\
    \ 0)\n    ((equal? (car nums) 10) (+ 1 (specialFilter (cdr nums))))\n    ((odd?\
    \ (car nums)) \n     (if (odd? (cdr nums)) \n        (+ 1 (specialFilter (cdr\
    \ nums))) \n        (specialFilter (cdr nums))))\n    (else (+ 1 (specialFilter\
    \ (cdr nums))))\n    )\n  )\n)\n", "  (if (null? (rest nums))\n      0\n     \
    \ (if (> (car nums) 10)\n          (if (odd? (car nums))\n              (+ 1 (specialFilter\
    \ (cdr nums)))\n              (+ 1 (specialFilter (cdr nums))))\n          (if\
    \ (even? (car nums))\n              (+ 1 (specialFilter (cdr nums)))\n       \
    \       (+ 1 (specialFilter (cdr nums)))))))\n", "  (cond [(empty? nums) 0]\n\
    \        [(> (first nums) 10) 1]\n        [(odd? (first nums)) 1]))\n", "  (define\
    \ (helper nums index)\n    (if (null? nums)\n        0\n        (if (> (car nums)\
    \ 10)\n            (if (and (odd? (car nums)) (odd? (cdr nums)))\n           \
    \     (helper (cdr nums) (+ index 1))\n                (helper (cdr nums) index))))))\n\
    \n  (if (null? nums)\n      0\n      (helper (cdr nums) 0)))\n", "  (cond\n  \
    \  [(or (empty? nums) (null? nums)) 0]\n    [(> (first nums) 10) 1]\n    [(or\
    \ (odd? (first nums)) (even? (last nums))) 2]\n    [else (+ (specialFilter (rest\
    \ nums)) 1)]\n  )\n)\n", "  (cond\n    [(null? (car nums)) 0]\n    [(odd? (first\
    \ nums)) (+ 1 (specialFilter (rest nums)))]\n    [(odd? (first nums)) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]\n  )\n)\n", " \
    \ (cond\n    [(null? nums) 0]\n    [(> (car nums) 10) 0]\n    [(even? (car nums))\
    \ (+ (odd? (car nums)) (odd? (cdr nums)))]\n    [(odd? (car nums)) (+ 1 \n   \
    \                     (specialFilter (cdr nums))))]\n    [else (+ 1 \n       \
    \        (specialFilter (cdr nums))))]))", "  (cond\n    [(empty? nums) 0]\n \
    \   [(= (remainder nums 10) 10) 1]\n    [else (cond [(even? (car nums)) (cond\
    \ [(odd? (car nums)) (cond [(odd? (cdr nums)) (cond [(even? (car nums)) (cond\
    \ [(odd? (cdr nums)) (cond [(even? (cdr nums)) (specialFilter (cdr nums))]))])])])]))\n",
  "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) 0]\n    [(even? (first\
    \ nums)) (add1 (last (rest (rest nums))))]\n    [else (add1 (last (rest nums)))]))\n",
  "  (cond\n    [(null? nums) 0]\n    [(> (car nums) 10) 0]\n    [(odd? (car nums))\
    \ 0]\n    [(even? (car nums)) (+ 1 (specialFilter (cdr nums))) ]\n    [else (+\
    \ 1 (specialFilter (cdr nums)))]\n   )\n  )\n)\n", "  (cond\n    [(empty? nums)\
    \ 0]\n    [(> (first nums) 10) 0]\n    [(odd? (first nums)) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n\
    \    [(null? nums) 0]\n    [(odd? (first nums)) (+ 1 (odd? (first nums)))]\n \
    \   [(odd? (last nums)) (+ 1 (odd? (last nums)))]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  (cond\n    ((null? nums) 0)\n    ((= (length nums) 0)\
    \ 0)\n    ((or (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car nums))) (specialFilter (cdr nums)))\n\
    \    ((and (even? (car nums))(odd? (car ", "  (cond\n    [(null? (first nums))\
    \ (null? (last nums))]\n    [(or (> first last) (odd? (first nums))) (odd? (last\
    \ nums))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (let ([f (lambda\
    \ (n l b)\n               (cond\n                [ (= (modulo n 10) 0) (if (=\
    \ (modulo l 2) 1) (+ b 1) b) ]\n                [ (= (modulo n 10) 0) (if (= (modulo\
    \ l 2) 0) (+ b 1) b) ]\n                [ (and (= (modulo n 10) 0) (= (modulo\
    \ l 2) 0)) (b + 1) ]\n                [ (and (= (modulo n 10) 0) (= (modulo l\
    \ 2) 1)) (b + 1) ]\n                [ (and (= (modulo n 10) 1) (= (modulo l 2)\
    \ 0)) (b + 1) ]\n                [ (and (= (modulo n 10) 1) (= (modulo l 2) 1))\
    \ (b + 1) ]\n                [ (and (= (modulo n 10) 2) (= (modulo l 2) 0)) (b\
    \ + 1) ]\n                [ (and (= (modulo n 10) 2) (= (modulo l 2) 1)) (b +\
    \ 1) ]\n                [ (and (= (modulo n 10) 3) (= (modulo l 2) 0)) (b + 1)\
    \ ]\n                [ (and (= (modulo n 10) 3) (= (modulo l 2) 1)) (b + 1) ]\n\
    \                [ (and (= (modulo n 10) 4) (= (modulo l 2) 0)) (b + 1) ]\n  \
    \              [ (and (= (modulo n 10) 4) (= (modulo l 2) 1)) (b + 1) ]\n    \
    \            [ (and (= (modulo n 10) 5) (= (modulo l 2) 0)) (b + 1) ]\n      \
    \          [ (and (= (modulo n 10) 5) (= (modulo l 2) 1)) (b + 1) ]\n        \
    \        [ (and (= (modulo n 10) 6) (= (modulo l 2) 0)) (b + 1) ]\n          \
    \      [ (and (= (modulo n 10) 6) (= (modulo l 2) 1)) (b + 1) ]\n            \
    \    [ (and (= (modulo n 10) 7) (= (modulo l 2) 0)) (b + 1) ]\n              \
    \  [ (and (= (modulo n 10) 7) (= (modulo l 2) 1)) (b + 1) ]\n                [\
    \ (and (= (modulo n 10) 8) (= (modulo l 2) 0)) (b + 1) ]\n                [ (and\
    \ (= (modulo n 10) 8) (= (modulo l 2) 1)) (b + 1) ]\n                [ (and (=\
    \ (modulo n 10) 9) (= (modulo l 2) 0)) (b + 1) ]\n                [ (and (= (modulo\
    \ n ", "  (cond\n    [(empty? nums) 0]\n    [(= (modulo \n          (+ (first\
    \ nums) (last nums)) \n          10)\n       1)\n      (+ 1 (specialFilter (rest\
    \ nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    [(null?\
    \ nums) 0]\n    [(> (first nums) 10) 0]\n    [(odd? (first nums)) 0]\n    [else\
    \ (+ 1 (specialFilter (rest nums)))]))\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    You might want to add an explanation of what your code does and how it works.\n\
    <|/ c |>\n<| a tags=racket,filter,scheme |>\nHere is another solution. It works\
    \ on a single list and a list (or list of lists) of lists.\n<code>", "  (cond\n\
    \    [(empty? nums) 0]\n    [(number? nums) (nums)]\n    [else \n     (if (> (first\
    \ nums) 10) \n         (if (even? (last nums)) \n             1\n            \
    \ ; else 0\n             )\n       (if (odd? (first nums)) \n             1\n\
    \             ; else 0\n             )\n       ;; else 0\n       )\n    ]\n  \
    \  )\n  )\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [else (and (even? (first nums))\n              (odd? (last\
    \ (rest nums))))\n           ]\n  )\n)\n", "  (cond [(null? (cdr nums)) 0]\n \
    \       [(> (car nums) 10) 1]\n        [(odd? (car nums)) 1]\n        [(odd? (cadr\
    \ nums)) 1]\n        [else 0]))\n</code>\n<|/ q |>\n<| c |>\nPlease try to format\
    \ the code with four spaces in front of each line and see how it looks like.\n\
    <|/ c |>\n<| c |>\nPlease edit your question and put it in proper code formatting.\
    \  It seems that you have one long line which doesn't help us.  Also, please show\
    \ us the code that you tried to write.  It doesn't have to be an exact copy from\
    \ your editor, just something that we can run and see what you have.\n<|/ c |>\n\
    <| c |>\nOkay, I got it formatted now.\n<|/ c |>\n<| c |>\nI have added my code\n\
    <|/ c |>\n<| c |>\nThe answer you gave me is completely different than what I\
    \ wanted. Thank you though.\n<|/ c |>\n<| a tags=racket,scheme,functional-programming\
    \ |>\nI think you are supposed to implement your own version of map for this.\
    \ A map function takes a list as its input and produces a new list with the return\
    \ value for each element in the list.  So you need to implement a map function\
    \ which takes a list as its input.  It should produce a new list where each element\
    \ is the result of applying the function to the corresponding element in the input.\n\
    <|/ a dscore=0 |>\n<| a tags=racket,scheme,functional-programming |>\n<code>",
  "  (cond\n    [(empty? nums) 0]\n    [(not (number? (first nums)))\n     (cond\n\
    \       [(not (odd? (first nums)))\n        (cond (empty? nums) 0]\n         \
    \     [(- (first nums)) (specialFilter (rest nums))])]\n       [(not (odd? (last\
    \ nums)))\n        (cond (empty? nums) 0]\n              [(+ (last nums)) (specialFilter\
    \ (rest nums))])]\n       [(odd? (first nums))\n        (cond\n          [(empty?\
    \ nums) 0]\n          [(odd? (last nums)) 1]]\n          [(not (odd? (last nums)))\n\
    \           (cond\n             [(empty? nums) 0]\n             [(odd? (first\
    \ nums)) 1]]\n             [(not (odd? (first nums)))\n              (cond\n \
    \                [(empty? nums) 0]\n                 [(- (first nums)) (specialFilter\
    \ (rest nums))])])])]\n    [(odd? (last nums))\n     (cond\n       [(empty? nums)\
    \ 0]\n       [(odd? (first nums)) 1]]\n       [(not (odd? (first nums)))\n   \
    \     (cond\n          [(empty? nums) 0]\n          [(odd? (last nums)) 1]]\n\
    \          [(not (odd? (last nums)))\n           (cond\n             [(empty?\
    \ nums) 0]\n             [(odd? (first nums)) 1]]\n             [(not (odd? (first\
    \ nums)))\n              (cond\n                 [(empty? nums) 0]\n         \
    \        [(- (last nums)) (specialFilter (rest nums))])])])]\n    [else (cons\
    \ (first nums) (specialFilter (rest nums))])]))\n", "  (cond\n    [(empty? nums)\
    \ 0]\n    [(equal? (first nums) 10) 1]\n    [(odd? (first nums)) 1]\n    [(odd?\
    \ (last nums)) 1]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (define\
    \ (filter arr evil odd)\n    (cond\n      [(null? arr) 0]\n      [(evil first\
    \ last) (filter (cdr arr) (not evil) (not odd))]\n      [(odd? (first last)) (+\
    \ 1 (filter (cdr arr) evil odd))]\n      [else (+ 1 (filter arr (not evil) (not\
    \ odd))]))\n    (filter nums #f #t))\n  (filter nums #t (odd? (first last)))\n\
    )\n</cell>\n<cell>", "  (cond\n    ((null nums) 0)\n    ((> (first nums) 10) (and\
    \ (odd? first) (odd? last)))\n    (else (+ 1 (specialFilter (rest nums))))))\n",
  "  (cond\n    [(empty? nums) 0]\n    [(> first nums 10) 1]\n    [(= (mod first nums\
    \ 10) 1) (+ 1 (specialFilter (rest nums)))]\n    [else (+ (specialFilter (rest\
    \ nums)) (specialFilter nums)) ]\n    )\n  )\n", "  (* (length nums) (countGreaterThan\
    \ nums '10)))", "  (cond\n    ((null? nums) 0)\n    ((odd? (car nums)) 1)\n  \
    \  (else \n      (cond\n        ((odd? (cdr nums)) 2)\n        (else (specialFilter\
    \ (cdr nums)))))))\n", "  (if (null? nums)\n      0\n      (+ (count (car nums)\n\
    \              (lambda (x)\n                 (and (> (car x) 10)\n           \
    \            (and (odd? (car x))\n                              (and (odd? (cdr\
    \ x))\n                                      (odd? (cdddr x))))))))))\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  (cond [(empty? nums) 0]\n        [(even?\
    \ (first nums)) (+ 1 (specialFilter (rest nums)))]\n        [(odd? (first nums))\
    \ (+ 1 (specialFilter (rest nums)))]\n        [else (+ 1 (specialFilter (rest\
    \ nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) 1]\n\
    \    [(odd (first nums)) (+ (first nums) 1)]\n    [else (+ (specialFilter (rest\
    \ nums)) (first nums))]))\n", "  (cond\n    [(null? nums) 0]\n    [(list? nums)\
    \ (length (filter odd? (first nums)\n                                  (last nums))))]\n\
    \    [else (+ 1 (specialFilter (rest nums)))]))\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=racket,lisp,scheme |>\nA more elegant solution using Racket's List/filter:\n\
    <code>", "  (cond\n    ((null? nums) 0)\n    ((> (first nums) 10) (cons (first\
    \ nums) (specialFilter (rest nums))))\n    ((odd? (first nums)) (cons (first nums)\
    \ (specialFilter (rest nums))))\n    (else (cons (first nums) (specialFilter (rest\
    \ nums))))\n    )\n  )\n)", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums)\
    \ 10) 1]\n    [(= (odd? (first nums)) 1) 1]\n    [(= (odd? (last nums)) 1) 1]\n\
    \    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (length (filter odd? (zip\
    \ nums (reverse nums)))))\n", "  (cond ((= 0 (length nums)) 0)\n        (else\
    \ (if (odd? (first nums))\n                   (if (odd? (last nums))\n       \
    \                (+ 1 (specialFilter (rest nums))))\n                     (specialFilter\
    \ (rest nums))))\n        ))\n", "  (cond [(empty? nums) 0]\n        [(> (first\
    \ nums) 10)\n         (odd? (first nums))]\n        [(odd? (last nums))\n    \
    \     (even? (first nums))]\n        [else\n         (+ 1 (specialFilter (rest\
    \ nums))))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10) 1]\n\
    \    [(even? (first nums)) (odd? (first nums)) (even? (first nums))]\n    [else\
    \ (odd? (first nums)) (even? (first nums)) (odd? (first nums))]\n    [else (odd?\
    \ (first nums)) (even? (first nums)) (odd? (first nums))]\n    [else (odd? (first\
    \ nums)) (even? (first nums)) (odd? (first nums))]\n    [else (odd? (first nums))\
    \ (even? (first nums)) (odd? (first nums))]\n    [else (odd? (first nums)) (even?\
    \ (first nums)) (odd? (first nums))]\n    [else (odd? (first nums)) (even? (first\
    \ nums)) (odd? (first nums))]\n    [else (odd? (first nums)) (even? (first nums))\
    \ (odd? (first nums))]\n    [else (odd? (first nums)) (even? (first nums)) (odd?\
    \ (first nums))]\n    [else (odd? (first nums)) (even? (first nums)) (odd? (first\
    \ nums))]\n    [else (odd? (first nums)) (even? (first nums)) (odd? (first nums))]\n\
    \    [else (odd? (first nums)) (even? (first nums)) (odd? (first nums))]\n   \
    \ [else (odd? (first nums)) (even? (first nums)) (odd? (first nums))]\n    [else\
    \ (odd? (first nums)) (even? (first nums)) (odd? (first nums))]\n    [else (odd?\
    \ (first nums)) (even? (first nums)) (odd? (first nums))]\n    [else (odd? (first\
    \ nums)) (even? (first nums)) (odd? (first nums))]\n    [else (odd? (first nums))\
    \ (even? (first nums)) (odd? (first nums))]\n    [else (odd? (first nums)) (even?\
    \ (first nums)) (odd? (first nums))]\n    [else (odd? (first nums)) (even? (first\
    \ nums)) (odd? (first nums))]\n    [else (odd? (first nums)) (even? (first nums))\
    \ (odd? (first nums))]\n    [else (odd? (first nums)) (even? (first nums)) (odd?\
    \ (first nums))]\n    [else (odd? (first nums)) (even? (first nums)) (odd? (first\
    \ nums))]\n    [else (odd? (first nums)) (", "  (cond [(empty? nums) 0]\n    \
    \    [(and (odd? (first nums))\n              (odd? (last nums)))\n         (+\
    \ 1 (specialFilter (rest nums)))]\n        [else (+ 1 (specialFilter (rest nums)))\
    \ 0]))\n", "  (cond\n    [(empty? nums) 0]\n    [(< 0 (first nums)) 0]\n    [(<\
    \ 0 (last nums)) 0]\n    [(odd? (first nums)) 1]\n    [(odd? (last nums)) 1]\n\
    \    [else (+ (specialFilter (rest nums)) (specialFilter (first nums))) ])) \n",
  "  (cond\n    [(null? nums) 0]\n    [(odd? (car nums)) 2]\n    [(even? (car nums))\
    \ (+ 1 (specialFilter (cdr nums)))]\n    [else (+ 1 (specialFilter (cdr nums)))]))\n",
  "  (define (odd-first n)\n    (cond\n      [(= (modulo n 10) 0) (and (odd? (modulo\
    \ n 10)) (even? (mod n 10)))]\n      [(= (modulo n 10) 0) (and (odd? (modulo n\
    \ 10)) (not (even? (mod n 10))))]\n      [(= (modulo n 10) 0) (not (and (odd?\
    \ (modulo n 10)) (even? (mod n 10))))]))\n  (define (odd-last n)\n    (cond\n\
    \      [(= (modulo n 10) 0) (and (odd? (modulo n 10)) (even? (mod n 10)))]\n \
    \     [(= (modulo n 10) 0) (and (odd? (modulo n 10)) (not (even? (mod n 10))))]\n\
    \      [(= (modulo n 10) 0) (not (and (odd? (modulo n 10)) (even? (mod n 10))))]))\n\
    \  (define (even-first n)\n    (cond\n      [(= (modulo n 10) 0) (and (even? (modulo\
    \ n 10)))]\n      [(= (modulo n 10) 0) (and (not (even? (modulo n 10))))]\n  \
    \    [(= (modulo n 10) 0) (not (and (even? (modulo n 10))))]))\n  (define (even-last\
    \ n)\n    (cond\n      [(= (modulo n 10) 0) (and (even? (modulo n 10)))]\n   \
    \   [(= (modulo n 10) 0) (and (not (even? (modulo n 10))))]\n      [(= (modulo\
    \ n 10) 0) (not (and (even? (modulo n 10))))]))\n  (define (odd-first n) (odd-first\
    \ n))\n  (define (odd-last n) (odd-last n))\n  (define (even-first n) (even-first\
    \ n))\n  (define (even-last n) (even-last n))\n  (define (equals n) (equals n))\n\
    \  (define (add n) (add n))\n  (define (sub1 n) (sub1 n))\n  (define (sub2 n)\
    \ (sub2 n))\n  (define (sub3 n) (sub3 n))\n  (define (eq n) (eq n))\n  (define\
    \ (leq n) (leq n))\n  (define (geq n) (geq n))\n  (define (gt n) (gt n))\n  (define\
    \ (lt n) (lt n))\n  (define (< n) (< n))\n  (define (>) >)\n  (define ", "  (cond\
    \ [(null? nums) 0]\n        [(odd? (first nums)) (+ 1 (specialFilter nums))]\n\
    \        [(even? (first nums)) (+ 1 (specialFilter nums))]\n        [else (+ 1\
    \ (specialFilter nums))]))", "  (length (filter #(= (mod % (* 2 2)) 0) nums)))\n\
    </code>\n<|/ a tags=racket,scheme,sicp |>\n<| c |>\nYeah that's it! The book I\
    \ was using said to use filter, but I never knew what it was. Thank you so much!\n\
    <|/ c |>\n<| a tags=racket,scheme,sicp |>\nThe solution using only (map and filter)\
    \ will work for lists of up to 10 elements, but will explode when given larger\
    \ lists. An alternative is to use recursion:\n<code>", "  (let loop ((nums nums)\
    \ (acc 0))\n    (if (null? nums) acc\n    (loop (rest nums)\n          (if (>\
    \ (first nums) 10) \n              (if (odd? (first nums)) \n                \
    \  (loop (rest nums) (+ 1 acc))\n              acc)\n          (loop (rest nums)\n\
    \              (if (odd? (first nums)) \n                  (loop (rest nums) (+\
    \ 1 acc))\n              acc))))))\n</code>\n<|/ a tags=racket,scheme dscore=2\
    \ |>\n<| a |>\nHow about this one?\n<code>", "  (cond\n    [(empty? nums) 0]\n\
    \    [(odd? (car nums)) 1]\n    [else (+ 1 (specialFilter (cdr nums)))]))\n",
  "  (let ((count 0))\n    (for ([i nums]) \n      (if (= (mod i (expt 2 1)) 1)\n\
    \          (set! count (+ count 1))\n        (set! count (+ count 0)))))\n  count)\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis code doesn't compile: `Error: bad syntax\
    \ in: count\n   context...` It should be `(let ((count 0))...` not `(let count\
    \ ...`.\n<|/ c |>\n<| c |>\nThanks, I was just fixing the code. Thanks for catching\
    \ that.\n<|/ c |>\n<| a |>\nHere is another approach that doesn't use recursion.\
    \ \n<code>", "  (cond\n    [(empty? nums) 0]\n    [(not (even? (first nums)))\
    \ (+ 0 (specialFilter (rest nums)))]\n    [(even? (first nums)) (+ 0 (specialFilter\
    \ (rest nums)))]\n    [(odd? (first nums)) (+ 1 (specialFilter (rest nums)))]\n\
    \    [else (+ 1 (specialFilter (rest nums)))]))\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI tried to convert it to Scheme, it looks fine to me, but I got this\
    \ error message: \"specialFilter: bad syntax (in: specialFilter nums)\n  context...:\
    \ specialFilter nums)\"\n<|/ c |>\n<| a dscore=0 |>\nIf you have the time and\
    \ inclination to do this, I'd recommend using Racket instead of Scheme.  You can\
    \ download Racket as a zip file here, or you can download a pre-compiled version\
    \ of Racket from the Racket site here (you'll have to register on that site).\
    \  You can then install the Racket IDE using the installer.  You can then write\
    \ your program like this:\n<code>\n#lang racket\n", "  (cond\n    [(empty? nums)\
    \ 0]\n    [(> first nums 10) 1]\n    [(odd? (first nums)) 1]\n    [(odd? (last\
    \ nums)) 1]\n    [else (+ 1 (specialFilter (rest nums))) ]))", "  (let ([evens\
    \ odds (first last odds) (first last evens)])\n    (cond\n      [(null? nums)\
    \ 0]\n      [(< last odds 10) (+ first odds)]\n      [(< first evens 10) (+ first\
    \ evens)]\n      [else (+ 1 (specialFilter rest odds evens))])))\n", "  (cond\n\
    \    [(empty? nums) 0]\n    [(odd? (first nums)) (add 1 (specialFilter (rest nums)))]\n\
    \    [(even? (first nums)) 0 (add 1 (specialFilter (rest nums)))]\n    [else (add\
    \ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(and\
    \ (number? (first nums)) (even? (first nums))) 1]\n    [(and (number? (last nums))\
    \ (even? (last nums))) 1]\n    [else (+ (specialFilter (rest nums)) 1)]\n  )\n\
    )\n", "  (cond\n    [(empty? nums) 0]\n    [(= (first nums) 10)\n     (if (odd?\
    \ (first nums))\n         1\n         (even? (first nums))\n       )\n     ]\n\
    \    [else (+ 1 (specialFilter (rest nums))) ]\n  )\n)\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(> (first nums) 10) (+ 1 specialFilter (rest nums))]\n    [(>\
    \ (last nums) 10) (+ 1 specialFilter (rest nums))]\n    [else (+ 1 specialFilter\
    \ (rest nums))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(greater-than 10 head)\
    \ 1])\n  (cond\n    [(odd? (first nums))\n     (if (odd? (last nums))\n      \
    \ (+ 1 (specialFilter (rest nums)))\n       (specialFilter (rest nums)))]\n  \
    \  [(even? (first nums))\n     (if (even? (last nums))\n       (+ 1 (specialFilter\
    \ (rest nums)))\n       (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  ;; TODO: Write a filter that uses this idea.\n  (if\
    \ (null? nums)\n    0 \n    (if (even? (first nums))\n      (if (even? (last nums))\n\
    \        (if (odd? (first nums))\n          (+ 1 \n            (specialFilter\
    \ (rest nums))) \n          (specialFilter (rest nums))) \n      (specialFilter\
    \ (rest nums)))))\n  ", "  (cond [(< 1 (length nums)) 0]\n        [(> (first nums)\
    \ 0) 0]\n        [(> (last nums) 0) 0]\n        [(even? (first nums)) (+ 1 (specialFilter\
    \ (rest nums)))]\n        [(odd? (first nums)) (+ 1 (specialFilter (rest nums)))]\n\
    \        [(even? (last nums)) (+ 1 (specialFilter (rest nums)))]\n        [(odd?\
    \ (last nums)) (+ 1 (specialFilter (rest nums)))]\n        [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n</code>\n<|/ a |>\n<| c |>\n`count-if` is not in the Racket\
    \ standard library. Racket comes with [`count-if`](https://racket-lang.org/docs/reference/lists.html#%28def._%28%28lib._racket%2Flist.rkt%29._count-if%29%29)\
    \ and [`filter`](https://racket-lang.org/docs/reference/lists.html#%28def._%28%28lib._racket%2Flist.rkt%29._filter%29%29).\
    \ `filter` is for filtering out elements of a list, not counting them. `count-if`\
    \ takes a predicate and returns a new list with the number of elements that returned\
    \ `true`.\n<|/ c |>\n<| a |>\nYou can easily do it in one line using recursion\
    \ and some Racket specific functions. First, you have to define your function\
    \ which can tell you the odd number in a list:\n<code>", "  (cond\n    [(null?\
    \ (cdr nums)) 0]\n    [(> (car nums) 10) 0]\n    [(odd? (car nums)) (+ 1 (specialFilter\
    \ (cdr nums)))]\n    [(odd? (car nums)) (+ 1 (specialFilter (cdr nums)))]\n  \
    \  [else (+ 1 (specialFilter (cdr nums)))]))\n", "  (cond\n    [(empty? nums)\
    \ 0]\n    [(and (even? (first nums))\n          (even? (last nums)))\n      (+\
    \ 1 (specialFilter (rest nums)))]\n    [(and (odd? (first nums))\n          (even?\
    \ (last nums)))\n      (+ 1 (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10)\
    \ (+ (count (odd? first) nums) 1)]\n    [(and (> (last nums) 10) (odd? (last nums)))(+\
    \ (count (odd? last) nums) 1)]\n    [else (+ (count (odd? first) nums) 1)]))\n",
  "  (cond ((null? nums) 0)\n        ((equal? (car nums) 0) 0)\n        ((odd? (car\
    \ nums)) 0)\n        (else\n         (cond ((equal? (car nums) 10) 0)\n      \
    \        ((odd? (car nums)) (specialFilter (cdr nums)))))\n        ((odd? (cdr\
    \ nums)) (specialFilter (cdr nums)))))\n</code>\n<code>", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(> (first nums) 10) 0]\n    [(odd? (first nums)) 0]\n    [(odd?\
    \ (last nums)) 0]\n    [else 1]\n  ))\n", "  (cond\n    [(empty? nums) 0]\n  \
    \  [(> head nums 10)\n     (cond\n       [(odd? last) (+ 1 specialFilter (tail\
    \ nums))]\n       [else (specialFilter (tail nums))])]\n    [else (+ 1 specialFilter\
    \ (tail nums))]))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10)\
    \ 1]\n    [(even? (first nums)) 2]\n    [else (+ 1 (specialFilter (rest nums)))]))\n",
  "  (cond\n    [(empty? nums) 0]\n    [(< first nums) (+ 1 (specialFilter (rest nums)))]\n\
    \    [(even? first nums) (+ 1 (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter\
    \ (rest nums)))]))\n", "  (cond\n    [(null? nums) 0]\n    [(> (first nums) 10)\
    \ 0]\n    [(and (string-char-odd? first (first nums))\n          (string-char-odd?\
    \ last (first nums)))\n     (+ 1 (specialFilter (rest nums)))]\n    [else 0]))\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThe OP is clearly using Racket rather than\
    \ Scheme, since Racket has a built-in `string->number` function. Your use of `string->number`\
    \ is redundant with the use of `first` and `last` as you do so in your code. Also,\
    \ there's no need to use [`cond-exp`](http://docs.racket-lang.org/reference/condprog.html)\
    \ with `or` and `and`. Finally, your `cond` list is indented four spaces while\
    \ your code has `cond` with an extra level of indentation. Also, please fix your\
    \ indentation so it's clear that your code is intended to be run as an infix procedure\
    \ expression.\n<|/ c |>\n<| a |>\n<code>", "  (cond ((null? nums) 0)\n       \
    \ ((even? (car nums)) 1)\n        (else (+ (specialFilter (cdr nums)) \n     \
    \               (odd? (first nums)) \n                    (odd? (last nums))))))\n",
  "  (cond\n    [(empty? nums) 0]\n    [else (if (>= (first nums) 10)\n        (cond\n\
    \          [(even? (first nums)) (add1 (second nums))]\n          [else (cond\n\
    \                    [(in? (last nums) (second nums)) (add1 (last nums))]\n  \
    \                  [else (add1 (first nums))]))])]))\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nHere's my solution. It has both O(n) time and O(1) space.\n\
    <code>", "  (cond\n    [(empty? nums) 0]\n    [else (+ 1 (length (filter odd?\
    \ (first nums))\n                              (filter odd? (last nums))))]))\n",
  "  (cond\n    [(empty? nums) 0]\n    [(member? (mod first last) odd) 1]\n    [else\
    \ (+ 1 0)]))\n", "  (cond\n    ((null? nums) 0)\n    ((equal? (first nums) 10)\n\
    \      (odd? (first nums) (first nums))))\n    (else (+ 1 (specialFilter (rest\
    \ nums))))\n  )\n)\n", "  (cond\n    [(empty? nums) 0]\n    [(> 10 first last)\
    \ (+ 1 (specialFilter (rest nums)))]\n    [(odd? (first nums)) (+ 1 (specialFilter\
    \ (rest nums)))]\n    [else  (+ 1 (specialFilter (rest nums)))]\n  )\n)\n", " \
    \ (let ([even-digits (filter (lambda (x) (and (oddp? x) (evenp? x)))\n       \
    \                        nums)]\n        [odd-digits (filter (lambda (x) (and\
    \ (oddp? x) (oddp? x)))\n                           nums)])\n    (if (null? even-digits)\n\
    \        0\n        (if (null? odd-digits)\n            0\n            (if (>\
    \ (length (first even-digits)) (length (first odd-digits)))\n                0\n\
    \                (if (> (length (first odd-digits)) (length (first even-digits)))\n\
    \                    1\n                    (if (and (equal? (first even-digits)\
    \ (first odd-digits))\n                         (odd? (first odd-digits))\n  \
    \                       (even? (first even-digits)))\n                       \
    \ 0\n                        2))))))\n", "  (cond\n    ;; only odd numbers\n \
    \   [(odd? (car nums)) (cond \n                      ;; only even numbers\n  \
    \                    [(even? (cdr nums)) 0]\n                      ;; otherwise\n\
    \                      [else 1])]\n    ;; otherwise\n    [else (+ 1 (specialFilter\
    \ (cdr nums))) ]))", "  (cond\n    [(empty? nums) 0]\n    [(odd? (first (first\
    \ nums))) 1]\n    [(odd? (last (first nums))) 1]\n    [(odd? (first (last nums)))\
    \ 1]\n    [(odd? (last (last nums))) 1]\n    [else (+ 1 (specialFilter (rest nums)))]))\n",
  "  (if (null? nums) 0\n      (if (odd? (first nums))\n          (if (odd? (last\
    \ nums))\n              (+ 1 (specialFilter (rest nums)))\n              (+ 1\
    \ (specialFilter (rest nums))))\n          (+ 1 (specialFilter (rest nums))))))\n",
  "  (cond\n    [(null? nums) 0]\n    [(> (car nums) 10) (if (even? (car nums)) (+\
    \ 1 (specialFilter (cdr nums)))\n                                      (+ 1 (specialFilter\
    \ (cdr nums))))\n     (if (odd? (car (car nums)))\n         (if (even? (car nums))\
    \ (+ 1 (specialFilter (cdr nums)))\n           (+ 1 (specialFilter (cdr nums))))\n\
    \      1)]\n    [(odd? (car (car nums))) (if (odd? (car nums)) (+ 1 (specialFilter\
    \ (cdr nums)))\n                                            (+ 1 (specialFilter\
    \ (cdr nums))))\n     (if (even? (car nums)) (+ 1 (specialFilter (cdr nums)))\n\
    \           (+ 1 (specialFilter (cdr nums))))\n     1]\n    [else (+ 1 (specialFilter\
    \ (cdr nums)))]))\n", "  (dorun (map (\u03BB (x) (if (> x 10) 1 0)) nums))\n \
    \ \n)\n", "  (cond\n    ((empty? nums) 0)\n    ((> (first nums) 10) 1)\n    ((odd?\
    \ (first nums)) 1)\n    ((odd? (last nums)) 1)\n    (else (+ (specialFilter (rest\
    \ nums)) 1))))", "  (cond [(null? nums) 0]\n        [(odd? (first nums)) (odd?\
    \ (last nums))]\n        [else (+ (specialFilter (rest nums)) 1)]))\n", "  (cond\n\
    \    [(null? (cdr nums)) 0]\n    [(equal? (first nums) 10) 1]\n    [else (+ 1\
    \ (specialFilter (cdr nums))) ] ))\n    ", "  (cond ((null? nums) 0)\n       \
    \ ((< 10 (car nums))\n         (cond ((even? (car nums))\n                (cond\
    \ ((even? (cdr nums)) (cons (car nums) (specialFilter (cdr nums)))))\n       \
    \               (else (cons (car nums) (specialFilter (cdr nums))))))\n      \
    \  (else (specialFilter (cdr nums))))))\n", "  (let loop ((lst nums)\n       \
    \      (acc 0))\n    (if (null? lst)\n        acc\n        (loop (rest lst)\n\
    \              (if (odd? (first lst))\n                  (if (odd? (last lst))\n\
    \                      (+ acc 1)\n                      (+ 1 (loop (rest lst)\
    \ (+ 1 (odd? (first lst)) (odd? (last lst)))))\n                  acc)\n     \
    \         (+ acc (odd? (first lst))\n                  (+ acc (odd? (last lst))\n\
    \                      (loop (rest lst) (+ 1 (odd? (first lst)) (odd? (last lst)))))\n\
    \              acc))))\n", "  (count\n   (for/fold ([acc 0])\n     ([i nums])\n\
    \   (cond ((< i (/ 10 2)) (inc acc))\n         ((even? (remainder i 2)) (inc acc))\n\
    \         (else acc))\n         ))\n  \n)\n", "  (count\n   (lambda (num)\n  \
    \   (and (>= num 10)\n          (even? (first num))\n          (odd? (last num))))\n\
    \   nums))\n", "  (cond\n    [(empty? nums) 0]\n    [(greaterThan10 (first nums)\
    \ (last nums)) \n     (add1 (count nums))]\n    [else (add1 (count nums))]))\n",
  "  (cond\n    [(or (= (length nums) 0) (= (length (last nums)) 0)) 0]\n    [(and\
    \ (= (first nums) 1) (= (last nums) 1)) 0]\n    [else (+ 1 (specialFilter (rest\
    \ nums)))]))\n</cell>\n<code language=ocaml-jupyter>\nspecialFilter (Array.rev\
    \ [15, -73, 14, -15])\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ an integer as input and returns the number of digits of \nthat integer:\nThe\
    \ function should work for negative integers as well.\nFor example:\nspecialFilter(27)\
    \ => 3\nspecialFilter(42) => 1\nspecialFilter(-27) => -1\nspecialFilter(-42) =>\
    \ -2\n\n</text>\n<code language=ocaml-jupyter>\n#lang racket\n", "  (cond\n  \
    \  ((empty? nums) 0)\n    ((> (car nums) 10) 0)\n    ((odd? (car nums)) 1)\n \
    \   ((odd? (cdr nums)) 0)\n    (else (+ (specialFilter (cdr nums)) 1))))\n", " \
    \ (cond\n    [(empty? nums) 0]\n    [(equal? (first nums) 10) 1]\n    [(even?\
    \ (first nums)) (+ 1 (specialFilter (rest nums)))]\n    [(odd? (first nums)) (+\
    \ 1 (specialFilter (rest nums)))]\n    [else (+ 1 (specialFilter (rest nums)))]))\n",
  "  ;; use \"and\" & the length property to determine the number of elements \n \
    \ ;; greater than 10 and their first and last digits are odd\n  (and (length (filter\
    \ odd? nums)) \n       (and (length nums) \n            (even? (car nums))\n \
    \           (odd? (cddr nums)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a\
    \ dscore=2 tags=racket,scheme |>\nThis code will help you:\n<code>", "  (cond\n\
    \    ((null? nums) 0)\n    ((number? (car nums)) (car nums))\n    ((odd? (firstDigit\
    \ (car nums))) (odd? (lastDigit (car nums))))\n    (else\n      (specialFilter\
    \ (cdr nums)))))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 10)\n\
    \     (+ (specialFilter rest) 1)]\n    [(odd? (first nums))\n     (cond\n    \
    \   [(even? (rest nums)) (+ 1 (specialFilter nums))]\n       [(odd? (rest nums))\
    \ (+ (specialFilter nums) 1)]\n       [(even? (first nums)) (+ 1 (specialFilter\
    \ nums))]])]\n    [else (+ (specialFilter nums) 1)])))\n", "  (cond\n    [(null?\
    \ nums) 0]\n    [(> (car nums) 10) (+ 1 (specialFilter (cdr nums)))]\n    [else\
    \ (+ 1 (specialFilter (cdr nums)))]))", "  (cond\n    ((null? nums) 0)\n    ((>\
    \ (first nums) 10) 1)\n    ((odd? (first nums)) 0)\n    ((odd? (last nums)) 0)\n\
    \    (else\n     (cond\n       ((odd? (first nums))\n        (cond\n         \
    \ ((< (last nums) 9) 0)\n          (else (+ 1 (specialFilter (rest nums))))))\n\
    \       ((odd? (last nums))\n        (cond\n          ((< (first nums) 9) 0)\n\
    \          (else (+ 1 (specialFilter (rest nums))))))\n       (else (+ 1 (specialFilter\
    \ (rest nums)))))))) \n</code>\n<|/ a |>\n<| a |>\n<code>", "  (cond\n    [(null?\
    \ nums) 0]\n    [(> (car nums) 10) (+ 1 (specialFilter (cdr nums)))]\n    [(and\
    \ (odd (first nums))\n           (odd (last (last nums)))) \n      (+ 1 (specialFilter\
    \ (cdr nums))))]\n    [else (specialFilter (cdr nums))]))\n    ", "  (count-if\n\
    \   (lambda (num)\n     (and (= (first num) 1)\n          (= (last num) 1)\n \
    \         (odd? num))) nums))\n", "  (cond\n    [(empty? nums) 0]\n    [(> (first\
    \ nums) 10) 1]\n    [(= (mod (rest nums) 10) 1) (+ 1 (specialFilter (rest nums)))]\n\
    \    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    [(null? nums)\
    \ 0]\n    [(< 0 (car nums)) 0]\n    [(< (car nums) 10) 0]\n    [(even? (car nums))\
    \ (specialFilter (cdr nums))]\n    [(odd? (car nums)) (specialFilter (cdr nums))]\n\
    \    [else (+ 1 (specialFilter (cdr nums)))]))\n  \n  ", "  (let ((counter 0))\n\
    \    (for-each ((n nums)\n                 (f (lambda (x) (cond\n            \
    \                        [(< x 10) (set! counter 1)]\n                       \
    \             [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n       \
    \                             [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter\
    \ 1)]\n                                    [(and (= (% x 10) 1) (odd? (% x 1)))\
    \ (set! counter 1)]\n                                    [(and (= (% x 10) 1)\
    \ (odd? (% x 1))) (set! counter 1)]\n                                    [(and\
    \ (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n                         \
    \           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n         \
    \                           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter\
    \ 1)]\n                                    [(and (= (% x 10) 1) (odd? (% x 1)))\
    \ (set! counter 1)]\n                                    [(and (= (% x 10) 1)\
    \ (odd? (% x 1))) (set! counter 1)]\n                                    [(and\
    \ (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n                         \
    \           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n         \
    \                           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter\
    \ 1)]\n                                    [(and (= (% x 10) 1) (odd? (% x 1)))\
    \ (set! counter 1)]\n                                    [(and (= (% x 10) 1)\
    \ (odd? (% x 1))) (set! counter 1)]\n                                    [(and\
    \ (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n                         \
    \           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n         \
    \                           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter\
    \ 1)]\n                                    [(and (= (% x 10) 1) (odd? (% x 1)))\
    \ (set! counter 1)]\n                                    [(and (= (% x 10) 1)\
    \ (odd? (% x 1))) (set! counter 1)]\n                                    [(and\
    \ (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n                         \
    \           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter 1)]\n         \
    \                           [(and (= (% x 10) 1) (odd? (% x 1))) (set! counter\
    \ 1)]\n                                    [(and (= (% x 10) 1) (odd? (% x 1)))\
    \ (", "  (cond\n    [(empty? nums) 0]\n    [(not (odd? (first nums)))\n     (cons\
    \ (first nums) (specialFilter (rest nums)))]\n    [(not (odd? (last nums)))\n\
    \     (cons (last nums) (specialFilter (rest nums)))]\n    [(odd? (first nums))\
    \ and (odd? (last nums))\n     (cons (first nums) (specialFilter (rest nums)))]\n\
    \    [else (+ 1 (specialFilter (rest nums)))])))\n</code>\n<|/ a |>\n<| c |>\n\
    While `length` is perfectly adequate in many cases, there are also cases where\
    \ `count` would be more appropriate.  For example, consider a list `[1 2 3]`.\
    \  With a count function, you'd get `[1 2]`.  But a length function would give\
    \ you `[3 3]`.  In this case, count is definitely the best option.\n<|/ c |>\n\
    <| c |>\n`count` could also be used to count how many of any element in a list\
    \ satisfy a predicate.  E.g. `length` is used to find the length of a list of\
    \ numbers.\n<|/ c |>\n<| c |>\nBut count will return the number of 1s in the list,\
    \ not the number of elements in the list that are greater than 10 and both first\
    \ and last digits of a number are odd.\n<|/ c |>\n<| c |>\nThat's true.  I guess\
    \ I should stop coding at 3am.\n<|/ c |>\n<| c |>\nYou're right. I misread the\
    \ question.  I thought it was counting how many elements were odd.  But it's counting\
    \ the number of elements that are greater than 10.\n<|/ c |>\n<| a |>\nTo find\
    \ out the count of all the numbers greater than 10 that are odd numbers and are\
    \ in the range of first and last digit of any number, you could use a recursive\
    \ function like this:\n<code>", "  (cond\n    [(empty? nums) 0]\n    [(> (first\
    \ nums) 10) 1]\n    [(odd? (first nums)) 1]\n    [(odd? (last nums)) 1]\n    [else\
    \ (+ (specialFilter rest) 1)]\n  )\n)\n", "  (cond\n    [(empty? nums) 0]\n  \
    \  [(and (odd? (first nums))\n           (odd? (last nums))\n           (odd?\
    \ (rest nums)))\n      1]\n    [else 2]))\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    <code>", "  (if (null? nums)\n      0\n      (if (odd? (car nums))\n         \
    \ (if (odd? (last nums))\n              (+ 1 (specialFilter (cdr nums)))\n   \
    \           (specialFilter (cdr nums)))\n          (specialFilter (cdr nums)))))\n",
  "  (define (oddFirst n)\n    (if (odd? n) (quotient n 10) (quotient n 1)))\n\n \
    \ (define (oddLast n)\n    (if (odd? n) (quotient n 10) (quotient n 10)))\n\n\
    \  (define (evenFirst n)\n    (if (even? n) (quotient n 10) (quotient n 1)))\n\
    \n  (define (evenLast n)\n    (if (even? n) (quotient n 10) (quotient n 10)))\n\
    \n  (define (bothEvenFirst n)\n    (if (even? n) (quotient n 10) (quotient n 1)))\n\
    \n  (define (bothEvenLast n)\n    (if (even? n) (quotient n 10) (quotient n 10)))\n\
    \n  (define (bothOddFirst n)\n    (if (odd? n) (quotient n 10) (quotient n 1)))\n\
    \n  (define (bothOddLast n)\n    (if (odd? n) (quotient n 10) (quotient n 10)))\n\
    \n  (define (bothEvenAndOddFirst n)\n    (if (and (even? n) (odd? n)) (quotient\
    \ n 10) (quotient n 1)))\n\n  (define (bothEvenAndOddLast n)\n    (if (and (even?\
    \ n) (odd? n)) (quotient n 10) (quotient n 10)))\n\n  (define (bothEvenAndOddBothFirst\
    \ n)\n    (if (and (even? n) (odd? n)) (quotient n 10) (quotient n 1)))\n\n  (define\
    \ (bothEvenAndOddBothLast n)\n    (if (and (even? n) (odd? n)) (quotient n 10)\
    \ (quotient n 10)))\n\n  (define (bothEvenAndOddBothBothFirst n)\n    (if (and\
    \ (even? n) (odd? n)) (quotient n 10) (quotient n 1)))\n\n  (define (bothEvenAndOddBothBothLast\
    \ n)\n    (if (and (even? n) (odd? n)) (quotient n 10) (quotient n 10)))\n\n \
    \ (if (null? nums) 0)\n  (if (null? (cdr nums)) 0)\n\n  (if (or (null? (car nums))\
    \ (null? (cdr (car nums))))\n      0\n      (cond \n          (oddFirst (car nums))\
    \ (+ 1 oddFirst (car nums))\n          (oddLast (car nums)) (+ 1 oddLast (car\
    \ nums))\n          (evenFirst (car nums)) (+ 1 evenFirst (car nums))\n      \
    \    (evenLast", "  (cond\n    [(empty? nums) 0]\n    [(= (mod (* (first nums)\
    \ (first nums)) 2) 1) (+ 1 (length (filter (lambda (x) (= (mod (* (first nums)\
    \ (first nums)) 2) 1) nums)))]\n    [else (+ 1 (length (filter (lambda (x) (=\
    \ (mod (* (first nums) (first nums)) 2) 1) nums)))]))\n", "  (cond\n    [(null?\
    \ nums) 0]\n    [(equal? (first nums) (first nums)) 0]\n    [(equal? (first nums)\
    \ (last nums)) 0]\n    [(equal? (first nums) (first nums)) (+ 1 (specialFilter\
    \ (rest nums))) ]\n    [(equal? (last nums) (last nums)) (+ 1 (specialFilter (rest\
    \ nums))) ]\n    [(equal? (first nums) (last nums)) (+ 1 (specialFilter (rest\
    \ nums))) ]\n    [else (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n   \
    \ [(empty? nums) 0]\n    [else (+ 1\n             (if (odd? (first nums))\n  \
    \               (+ 1 (specialFilter (rest nums)))\n                 (specialFilter\
    \ (rest nums))))]))\n", "  (cond\n    [(null? (rest nums)) (length nums)]\n  \
    \  [(> (first nums) 10) 0]\n    [(odd? (first nums)) (+ 1 (specialFilter (rest\
    \ nums)))]\n    [(odd? (last nums)) (+ 1 (specialFilter (rest nums)))]\n    [else\
    \ (+ 1 (specialFilter (rest nums)))]))\n", "  (cond\n    [(empty? nums) 0]\n \
    \   [(odd? (first nums)) (add1 (length (filter odd? (rest nums))))]\n    [(odd?\
    \ (last nums)) (add1 (length (filter odd? (rest nums))))]\n    [else (add1 (length\
    \ (filter odd? (rest nums))))]))\n</code>\n<|/ q tags=racket,scheme dscore=1 |>\n\
    <| a dscore=1 |>\nI suggest to break down the problem into two parts, the first\
    \ is to find all even numbers that are not divisible by 3, the second is to find\
    \ all odd numbers that are not divisible by 3.\nSo we would have two procedures,\
    \ one that finds odd numbers and one that finds even numbers. \n<code>", "  (cond\n\
    \    [(empty? nums) 0]\n    [(> (first nums) 10) 0]\n    [(even? (first nums))\
    \ 0]\n    [else (+ 1 (specialFilter (rest nums)))]))", "  (cond\n    ((null? nums)\
    \ 0)\n    ((> (first nums) 10) (odd? (first nums))))\n    (t (and (odd? (first\
    \ nums)) (odd? (last nums)))))\n", "  (cond\n    [(empty? nums) 0]\n    [(and\
    \ (even? (car nums)) (odd? (first nums))) 1]\n    [(and (even? (car nums)) (even?\
    \ (first nums))) 2]\n    [else (+ 1 (specialFilter (cdr nums)))]))\n", "  (cond\n\
    \    [(null? nums) 0]\n    [(> (car nums) 10) 1]\n    [(and\n      (and\n    \
    \    (even? (car nums))\n        (odd? (cdr nums))\n        (even? (car nums)\
    \ (cdr nums)))\n      1)]))\n", "  (cond\n    [(or (null? nums) (null? (cdr nums)))\
    \  0]\n    [(even? (car nums)) (+ (car nums) 1)]\n    [(odd? (car nums)) (+ (car\
    \ nums) 1)]\n    [else (+ 1 (specialFilter (cdr nums)))]))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(> (car nums) 10) 0]\n    [(even? (first nums)) 0]\n    [(odd?\
    \ (first nums)) 1]\n    [(even? (last nums)) 1]\n    [(odd? (last nums)) 0]\n\
    \    [else (+ 1 (specialFilter (cdr nums)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
