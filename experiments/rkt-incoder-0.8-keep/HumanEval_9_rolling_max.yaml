name: HumanEval_9_rolling_max
language: rkt
prompt: "#lang racket\n\n;; From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n;; in the sequence.\n;; >>> rolling_max([1,\
  \ 2, 3, 2, 3, 4, 2])\n;; [1, 2, 3, 3, 3, 4, 4]\n(define (rolling_max numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 4 3 2 1)) (list\
  \ 4 4 4 4))\n    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))\n\
  ))\n\n(test-humaneval)"
completions: ["  (if (null? numbers)\n      '()\n      (let ((max-so-far #f) (max-so-far-so-far\
    \ #f))\n        (if (< max-so-far max-so-far-so-far)\n            (cons max-so-far\
    \ max-so-far-so-far)\n            (let ((n (car numbers)))\n              (let\
    \ ((m (max n max-so-far-so-far)))\n                (if (< n m)\n             \
    \       (let ((newmax-so-far n) (newmax-so-far-so-far m))\n                  \
    \    (if (< newmax-so-far max-so-far)\n                          (cons newmax-so-far\
    \ max-so-far-so-far)\n                          (let ((newmax-so-far n) (newmax-so-far-so-far\
    \ m))\n                            (if (< newmax-so-far max-so-far-so-far)\n \
    \                               (cons newmax-so-far max-so-far-so-far)\n     \
    \                           (let ((newmax-so-far n) (newmax-so-far-so-far m))\n\
    \                                  (if (< newmax-so-far max-so-far-so-far)\n \
    \                                     (cons newmax-so-far max-so-far-so-far)\n\
    \                                      (let ((newmax-so-far n) (newmax-so-far-so-far\
    \ m))\n                                        (if (< newmax-so-far max-so-far-so-far)\n\
    \                                            (cons newmax-so-far max-so-far-so-far)\n\
    \                                            (let ((newmax-so-far n) (newmax-so-far-so-far\
    \ m))\n                                              (if (< newmax-so-far max-so-far-so-far)\n\
    \                                                  (cons newmax-so-far max-so-far-so-far)\n\
    \                                                  (let ((newmax-so-far n) (newmax-so-far-so-far\
    \ m))\n                                                    (if (< newmax-so-far\
    \ max-so-far-so-far)\n                                                       \
    \ (cons newmax-so-far max-so-far-so-far)\n                                   \
    \                     (let ((newmax-so-far n) (newmax-so-far-so-far m))\n    \
    \                                                      (if (< newmax-so-far max-so-far-so-far)\n\
    \                                                              (cons newmax-so-far ",
  "  (let ((found (make-empty-vector numbers)))\n    (loop [i 0 (+ i 1)\n        \
    \   found found]\n      (if (= i (length numbers))\n          found\n        \
    \  (let ([number (cdr numbers)])\n            (if (> (first found) number)\n \
    \               (set! found (cons number found))\n                (loop (+ i 1)\
    \ found (cons number found)))))))))\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`numbers`\
    \ does not need to be a list, since it only ever contains one element.\n<|/ c\
    \ |>\n<| c |>\nYes, you're right, I edited the code to reflect this. Thanks\n\
    <|/ c |>\n<| a |>\nThe other answers are correct but are too complicated for someone\
    \ that does not yet have a good idea of how to use the language. Here is a simple\
    \ solution that will work with most programming languages.\n<code>\nlet rollingMax\
    \ numbers = \n    let maxNum = List.fold max () numbers\n    List.filter (fun\
    \ elem -> elem > maxNum) numbers\n</code>\nThe first line makes the max function\
    \ work as expected. The second line creates a list with only the max elements.\
    \ Lastly, the third line creates a list with only the elements that match the\
    \ criteria. \nYou can test it by doing rollingMax [10, 20, 30, 20, 10, 20, 40]\n\
    <|/ a tags=racket,scheme dscore=0 |>\n<| c |>\nIt would make sense to also test\
    \ the performance of the `filter` vs the `fold` solution. But a good answer doesn't\
    \ require an explanation of how it works.\n<|/ c |>\n<| c |>\nI disagree. I think\
    \ `fold` is more elegant and more understandable. It also has an advantage over\
    \ `filter` because `filter` has to iterate through the entire list while `fold`\
    \ stops as soon as it finds the first element that is greater than the maximal\
    \ element. This is what makes them different in other languages.\n<|/ c |>\n<|\
    \ c |>\n`fold` can be more efficient than the `filter` because it doesn't have\
    \ to keep track of the previous maximum element. `filter` has to keep track of\
    \ the previous maximum element (which it keeps in `found`) and so it will keep\
    \ searching all the remaining elements in the list even though they have already\
    \ been filtered out.\n<|/ c |>\n<| a tags=racket,scheme |>\nWith Racket's (let\
    \ ...) you could write\n<code>", "  (let loop ((numbers numbers) (max #f) (accum\
    \ #f))\n    (if (null? numbers)\n        accum\n        (loop (rest numbers)\n\
    \              (if (>= max number)\n                  max\n                  (loop\
    \ (rest numbers)\n                        (if (< number max)\n               \
    \             (cons number accum)\n                            accum))\n     \
    \         (cons max accum)))))\n</code>\n<|/ a |>\n<| c |>\nI like your solution.\
    \ Could you maybe add an explanation on how it works?\n<|/ c |>\n<| a tags=clojure,list,fold\
    \ |>\nHere is another way with a function that uses reduce:\n<code>", "  (let\
    \ loop ((numbers numbers)\n             (max #f))\n    (if (null? numbers)\n \
    \       max\n        (let ((max (car numbers))\n              (index (1+ index)))\n\
    \          (let ((new (cdr numbers))\n                (rest (rest numbers)))\n\
    \            (cond\n              ((null? new) (loop (rest new) (cons max max)))\n\
    \              (#t (loop (rest new) (cons max (car new))))))))))\n", "  (let loop\
    \ ((numbers numbers)\n             (max-list '()))\n    (if (null? numbers)\n\
    \        max-list\n        (let ((max-num (car numbers))\n              (max-list\
    \ (cons max-num max-list))\n              (next-number (cdr numbers))\n      \
    \        (next-numbers (loop (cons next-number next-numbers) max-list)))\n   \
    \       (cond ((> max-num max-list)\n                  (loop (cdr numbers) max-list))\n\
    \                (else\n                 (loop next-numbers max-list)))))\n  max-list)",
  "  (if (null? numbers) \n      numbers\n      (cons (max (car numbers) (rolling_max\
    \ (cdr numbers))) \n            (rolling_max (cdr numbers)))))\n", "  (let ([x\
    \ (first numbers)])\n    (cond\n      [(null? (rest numbers)) x]\n      [(< x\
    \ numbers) (rolling_max (rest numbers))]\n      [(> x numbers) (rolling_max (rest\
    \ numbers))]\n      [else (cons x numbers)])\n  )\n)\n", "  (if (null? (rest numbers))\n\
    \      (first numbers)\n      (let ((max (first numbers)))\n        (if (null?\
    \ (rest numbers))\n            max\n            (let ((curr (rest numbers)))\n\
    \              (if (> (first curr) max)\n                  (first curr)\n    \
    \              (let ((res (cons (first curr) res)))\n                    (if (null?\
    \ (rest curr))\n                        res\n                        (let ((max\
    \ (rolling_max (rest curr))))\n                          (if (null? (rest curr))\n\
    \                              max\n                              (cons max res)))))\n\
    \                (cons max res)))))\n      (- (first numbers) (rolling_max (rest\
    \ numbers)))))\n", "  (if (= (length numbers) 0)\n      '()\n      (let ([m (first\
    \ numbers)])\n        (if (= m 0)\n            (reverse (rolling_max (rest numbers)))\n\
    \            (let ([r (rolling_max numbers)])\n              (if (null? r)\n \
    \                 (cons m r)\n                  (cons (max m (car r)) r)))))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (max (car numbers)) (rolling_max\
    \ (cdr numbers)))))\n", "  (if (empty? numbers)\n      (list)\n      (let ((max-element\
    \ (first numbers)))\n        (if (empty? (rest numbers))\n            (list max-element)\n\
    \            (let ((next-number (rest numbers)))\n              (if (> next-element\
    \ max-element)\n                  (list max-element)\n                  (rolling_max\
    \ (cdr numbers) max-element next-element))\n              (rolling_max next-number\
    \ max-element next-element)))))\n", "  (cond ((empty? numbers) '())\n        ((null?\
    \ numbers) (list numbers))\n        ((> (car numbers) (last (rolling_max (cdr\
    \ numbers)))))\n        (else (cons (car numbers) (rolling_max (cdr numbers))))\n\
    \      )\n)\n", "  ;; (if (< current-max-value max-value)\n  (let loop ((max-value\
    \ numbers))\n    (if (empty? max-value)\n      '()\n      (let ((current-max-value\
    \ (car max-value)))\n        (cons (if (> current-max-value max-value)\n     \
    \              current-max-value\n                   max-value)\n            \
    \   (loop (cdr max-value)))))))\n", "  (cond ((null? numbers)\n         nil)\n\
    \        ((null? (cdr numbers))\n         (car numbers))\n        (else\n    \
    \     (max (car numbers)\n               (rolling_max (cdr numbers))))))\n", " \
    \ (let ((max 0 (length numbers))\n        (max-count 0 (- max 1)))\n    (do ((i\
    \ 0 (+ i 1)))\n        ((< i (length numbers)))\n      (let ((cur (car numbers))\n\
    \            (cur-count (cdr numbers)))\n        (when (< cur-count max-count)\n\
    \          (set! max (+ cur max))\n          (set! max-count cur-count)))))\n\
    \  max)\n", "  (let loop ((numbers numbers)\n             (maxs ()))\n    (cond\
    \ [(null? numbers)\n           maxs]\n          [(>= (first numbers) (first maxs))\n\
    \           (loop (rest numbers) (cons (first maxs) maxs))]\n          [else\n\
    \           (loop (rest numbers)\n                 (cons (first numbers)\n   \
    \                   maxs\n                      (cons (first maxs) maxs))))]))\n",
  "  (define (rolling-max-loop result n max)\n    (cond [(null? n) result]\n     \
    \     [(< n max) (rolling-max-loop result (1+ n) (max max))]\n          [else\
    \ (rolling-max-loop (cons n (first result)) (1+ n) (max max))]))\n  (let ((max\
    \ numbers))\n    (rolling-max-loop empty 0 max)))\n", "  (let ((result '()))\n\
    \    (for-each ((i numbers))\n               ((> (length result) i))\n       \
    \        ((set! result (append result i)))\n               ((set! result (append\
    \ result (list (maximum result)))))\n               ((set! result (append result\
    \ (list (car result)))))))\n    result))\n", "  (cond (<???>) <???>\n        (<???>)\
    \ <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n\
    \        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n       \
    \ (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>)\
    \ <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n\
    \        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n       \
    \ (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>)\
    \ <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n\
    \        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n       \
    \ (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>)\
    \ <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n\
    \        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n       \
    \ (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>)\
    \ <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n\
    \        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n       \
    \ (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>)\
    \ <???>\n        (<???>) <???>\n        (<???>) <???>\n        (<???>) <???>\n\
    \        (<???>) <???>\n        (<???>) <?", "  (let ((max (first numbers)))\n\
    \    (if (null? numbers)\n        numbers\n        (append (tail numbers) (list\
    \ (max max))))))\n", "  (define (rolling_max_helper numbers)\n    (define (rolling_max_helper-aux\n\
    \          (max-acc last-acc-nr)\n          (current-acc-nr numbers-nr)\n    \
    \      (current-acc max-acc))\n      (let ((max-acc-nr max-acc))\n        (if\
    \ (< numbers-nr 0)\n            (rolling_max_helper-aux max-acc-nr numbers-nr\
    \ current-acc)\n            (current-acc))))\n    (rolling_max_helper-aux max-acc\
    \ 0 (car numbers)))\n  (rolling_max_helper numbers))\n", "  (if (null? (cdr numbers))\n\
    \      (cons (car numbers) '())\n      (let ((max-val (car numbers))\n       \
    \     (max-list (cdr numbers)))\n        (cond ((< max-val (car max-list))\n \
    \              (cons (car max-list) max-list)) ; Return the current element\n\
    \              ((< max-val (car max-list) (list-ref max-list 1))) ; Return the\
    \ current element and skip 1 element\n              (else (cons (car max-list)\
    \ (list-ref max-list 2))) ; Return the current element and skip 2 elements\n \
    \             (else (cons (car max-list) max-list))))))\n", "  (if (empty? numbers)\n\
    \      numbers\n      (let ((max (car numbers))\n            (tail (cdr numbers))\n\
    \            (rolling_max (tail numbers))\n            (newMax (max max)))\n \
    \       (if (< newMax max)\n            (cons newMax\n                  rolling_max)\n\
    \            (cons max rolling_max)))))\n", "  (let ((max null))\n    (loop for\
    \ x from 1 to (list->length numbers)\n         with y = (list-ref numbers x)\n\
    \         for z from 0 to (list-length numbers) - 1\n         while (< z (+ x\
    \ 1))\n         collect (max y)))\n  )\n", "  (let loop ((m (first numbers)) (i\
    \ 0) (max-list '()))\n    (if (null? numbers)\n        (reverse max-list)\n  \
    \      (let ((n-i (first numbers))\n              (max-i (rest numbers)))\n  \
    \        (if (= i n-i)\n              (loop (first max-list) i (append max-list\
    \ (list max-i)))\n              (loop (first max-list) (+ i 1) (append max-list\
    \ (list max-i))))))))\n", "  (define (rolling_max-helper current maximums maxes)\n\
    \    (cond\n      [(null? maximums) maxes]\n      [else (if (> current maximums)\
    \ maximums maxes) (rolling_max-helper current (cons current maximums) maxes)]\n\
    \    )\n  )\n  (rolling_max-helper 0 (reverse numbers) '())\n)\n", "  (let loop\
    \ ((numbers (list numbers)) (max #f) (max_index #f))\n    (cond ((null? numbers)\
    \ (list max))\n          ((>= (length (remove max numbers)) max_index) (list max))\n\
    \          ((< max_index (length (remove max numbers)))\n           (loop (remove\
    \ max numbers)\n                  (max (car numbers))\n                  (+ 1\
    \ max_index)))\n          ((> (car numbers) max)\n           (loop (remove max\
    \ numbers)\n                  max\n                  max_index))\n          (else\
    \ (loop (remove max numbers)\n                       max\n                   \
    \    (+ 1 max_index))))))\n", "  (if (empty? numbers)\n      '()\n      (let ([max-el\
    \ (car numbers)])\n        (if (> (car numbers) max-el)\n            (append (list\
    \ (car numbers))\n                    (rolling_max (cdr numbers)))\n         \
    \   (rolling_max (cdr numbers))))))\n", "  (cond [(null? numbers) numbers]\n \
    \       [(null? (rest numbers)) (cons (car numbers) numbers)]\n        [(> (car\
    \ numbers) (last (rest numbers))) (cons (car numbers) numbers)]\n        [else\
    \ (cons (car numbers)\n                    (rolling_max (cdr numbers))))]))\n",
  "  (cond\n    [(empty? numbers) numbers]\n    [else (cons\n           (max (first\
    \ numbers))\n           (rolling_max (rest numbers)))]))\n", "  (define (rolling_max-recurse\
    \ numbers moment)\n    (cond\n      [(null? numbers) numbers]\n      [else\n \
    \      (cons (max (car numbers) moment) (rolling_max-recurse (cdr numbers) moment))])))\n\
    \  (rolling_max-recurse numbers null))\n", "  (cond [(null? numbers) numbers]\n\
    \        [(= 1 (length numbers)) (first numbers)]\n        [(= 1 (cdr numbers))\
    \ (rolling_max (rest numbers))]\n        [else (if (< (car numbers) (first numbers))\n\
    \                  (cons (car numbers)\n                        (rolling_max (rest\
    \ numbers)))\n                  (rolling_max (rest numbers)))))])\n", "  (define\
    \ (rolling max idx acc)\n    (if (null? numbers)\n        acc\n        (rolling\
    \ (max numbers (- idx 1) acc)\n                idx (cons (max numbers (- idx 1)\
    \ acc) acc))))\n  (rolling numbers (length numbers) '()))\n", "  (cond (empty?\
    \ numbers)\n        '()\n        (else\n         (let ([max (first numbers)])\n\
    \           (cond ((> max numbers)\n                  (list numbers))\n      \
    \           (else \n                  (cons (max (rest numbers)) \n          \
    \               (rolling_max (rest numbers)))))))) \n", "  (if (empty? numbers)\n\
    \      '()\n      (append (max_in_sub_list (rest numbers) (first numbers))\n \
    \             (rolling_max (rest numbers)))))\n", "  (if (null? numbers)\n   \
    \   '()\n      (let ([max-element (car numbers)])\n        (append\n         (rolling_max\
    \ (cdr numbers))\n         (if (> max-element (car numbers))\n             (list\
    \ max-element)\n             (list numbers))))))\n", "  (map max (map (lambda\
    \ (n)\n                    (take (- n 1) (cycle numbers))))\n         numbers))\n",
  "  (if (null? (cdr numbers))\n      (first numbers)\n      (let ((max (first numbers))\n\
    \            (rolling (list)))\n        (if (null? numbers)\n            (cons\
    \ max rolling)\n            (begin\n              (set! rolling (cons (first numbers)\
    \ rolling))\n              (set! max (first numbers))\n              (rolling_max\
    \ (rest numbers))))))))\n", "  (define (rolling_max-aux (max-so-far current-max\
    \ previous-max current-index)\n                         (max-so-far-prev max-so-far-prev-max\
    \ previous-index\n                                          current-index) current-list)\n\
    \    (if (null? current-list)\n        current-max\n        (if (= current-index\
    \ previous-index)\n            (if (> current-max previous-max)\n            \
    \    (cons current-max max-so-far-prev-max)\n                max-so-far-prev-max)\n\
    \            (rolling_max-aux (max current-max (first current-list))\n       \
    \                      (max-so-far-prev max-so-far-prev-max (first current-list)\n\
    \                                               (second current-list))\n     \
    \                        current-list (rest current-list))))))\n  (define (rolling_max-list\
    \ current-index max-so-far-prev-max previous-max current-list)\n    (if (null?\
    \ current-list)\n        max-so-far-prev-max\n        (rolling_max-aux (max current-max\
    \ (first current-list))\n                         (max-so-far-prev-max (first\
    \ current-list)\n                                             (second current-list)\n\
    \                                             current-list)\n                \
    \         current-list (rest current-list))))\n  (define (rolling_max-aux-1 (max-so-far\
    \ previous-max current-index)\n                         (max-so-far-prev max-so-far-prev-max\
    \ previous-index\n                                          current-index) current-list)\n\
    \    (if (null? current-list)\n        current-max\n        (if (= current-index\
    \ previous-index)\n            (if (> current-max previous-max)\n            \
    \    (cons current-max max-so-far-prev-max)\n                max-so-far-prev-max)\n\
    \            (rolling_max-aux-1 (max current-max (first current-list))\n     \
    \                         (max-so-far-prev max-so-far-prev-max (first current-list)\n\
    \                                               (second current-list)\n      \
    \                                         current-list) current-list)))))\n  (define\
    \ (rolling_max-aux-2 (max-so-far previous-max current-index)\n               \
    \          (max-so-far-prev max-so-far-prev-max previous-index\n             \
    \                             current-index) current-list)\n    (if (null? current-list)\n\
    \        current-max\n        (if (= current-index previous-index)\n         \
    \   (if (> current-max previous-max)\n                (cons current-max ", " \
    \ (cond\n    [(null? numbers) numbers]\n    [(null? (rest numbers)) numbers]\n\
    \    [else (max (car numbers) (rolling_max (cdr numbers))) ]))\n", "  (if (null?\
    \ numbers)\n      '()\n      (append (max (rest numbers))\n              (rolling_max\
    \ (rest numbers)))))\n", "  (if (null? (rest numbers))\n      numbers\n      (let\
    \ ((max (car numbers)))\n        (if (> (cdr numbers) max)\n            (cons\
    \ max numbers)\n            (cons (car numbers) (rolling_max (cdr numbers)))))))\n",
  "  (if (empty? numbers)\n      '()\n      (let ([number (car numbers)])\n      \
    \  (cons (max number \n                  (rolling_max (cdr numbers)))))))\n",
  "  (let loop ((res []) (remainder 0)\n             (current-max numbers))\n    (cond\n\
    \      [(empty? current-max) res]\n      [(> remainder numbers)\n       (loop\
    \ (conj res current-max)\n             (dec remainder)\n             (car current-max))]\n\
    \      [else\n       (loop (conj res current-max)\n             (sub1 remainder)\n\
    \             (cdr current-max))])))\n", "  (if (null? numbers)\n      '()\n \
    \     (let ((max (car numbers))\n            (found (equal? max numbers))\n  \
    \          (roll (cdr numbers)))\n        (if (or? found)\n            (if (equal?\
    \ found true)\n                (rolling_max roll)\n                roll)\n   \
    \         (if (equal? found false)\n                max\n                (rolling_max\
    \ (cdr roll)))))\n        )\n      )\n", "  (define (rolling_max-rec numbers current-max)\n\
    \    (if (null? numbers)\n        current-max\n        (rolling_max-rec (cdr numbers)\n\
    \                         (if (< current-max (car numbers))\n                \
    \             (car numbers)\n                             current-max))))\n  (rolling_max-rec\
    \ numbers 0))\n", "  (if (< (length numbers) 1)\n      (cons (car numbers) (rolling_max\
    \ (cdr numbers))) ; We take the head and recur on the rest of the list\n     \
    \ (let ((head (car numbers)))\n        (if (> (car numbers) head)\n          \
    \  (let ((max (car numbers)))\n              (cons head (rolling_max (cdr numbers))))\n\
    \            (cons head (rolling_max (cdr numbers)))))))\n", "  (if (null? numbers)\n\
    \      '()\n      (let ((curr (car numbers)))\n        (if (= curr (car numbers))\n\
    \            (append-reverse (list curr curr) (rolling_max (cdr numbers))))\n\
    \            (append-reverse (list (car numbers) curr) (rolling_max (cdr numbers)))))))\n",
  "  (define (max-roller number last-max)\n    (cond ((null? numbers) (list number))\n\
    \          ((> number (car numbers)) (cons (car numbers) max-roller (cdr numbers)))\n\
    \          (else (max-roller (cdr numbers) number))))\n  (max-roller (reverse\
    \ numbers) 0))\n", "  (if (null? numbers) numbers\n      (if (> numbers (cdr numbers))\n\
    \          (cons numbers (rolling_max (cdr numbers))) ; Max number found after\
    \ moment\n          (cons (car numbers) (rolling_max (cdr numbers))))))\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=racket,recursion,lisp,scheme,functional-programming\
    \ |>\nI wanted to solve this using a recursive function. Here's my solution:\n\
    <code>", "  (cond (empty? numbers)\n        '()\n        (> (first numbers) (last\
    \ numbers))\n        (cons first numbers)\n        (cons (rolling_max (rest numbers))\
    \ (rolling_max (rest numbers))))))\n", "  (define (rolling_max-loop start acc\
    \ numbers)\n    (if (null? numbers)\n        acc\n        (rolling_max-loop (+\
    \ start 1)\n                        (if (< start acc)\n                      \
    \      acc\n                            start)\n                        (rest\
    \ numbers))))\n\n  (rolling_max-loop 0 null numbers))\n", "  (cond [(null? numbers)\
    \ numbers]\n        [(null? (rest numbers)) (last numbers)]\n        [else (if\
    \ (< last (last numbers))\n                  (cons (last numbers)\n          \
    \              (rolling_max (rest numbers))\n                        (max numbers\
    \ (map last numbers))))\n                  (max numbers (map last numbers))]\n\
    \  )\n)\n", "  (cond ((empty? numbers) #f)\n        ((equal? (first numbers) (last))\
    \ (tail numbers))\n        (else (append (rolling_max (rest numbers)) (list (last))))))\n",
  "  (define (helper numbers index)\n    (cond\n      [(null? numbers) numbers]\n\
    \      [(> index 0) (cons (car numbers)\n                          (helper (cdr\
    \ numbers) (- index 1)))]\n      [else (helper (cdr numbers) index)]\n    ))\n\
    \  (helper numbers 0))\n", "  (define (rolling list m n)\n    (cond\n      [(empty?\
    \ list) list]\n      [(<= m n) (append (max list n) (rolling (sub1 list) m n))]\n\
    \      [(> m n) (rolling (max list n) m n)]\n      [else (rolling list n (+ m\
    \ 1))]))\n  (rolling numbers 0 0))\n", "  (cond [(null? (rest numbers)) #f]\n\
    \        [(> (first numbers) (first results)) (cons (first numbers) results)]\n\
    \        [else (rolling_max (rest numbers))]))", "  (cond [(empty? numbers) empty]\n\
    \        [(and (not (pair? numbers)) (empty? (cdr numbers)))\n         (append\
    \ (list (car numbers))\n                 (rolling_max (cdr numbers)))]\n     \
    \   [else (rolling_max (cdr numbers))]))\n", "  (let loop ([numbers numbers]\n\
    \             [max #f]\n             [rolling_max #f])\n    (cond\n      [(empty?\
    \ numbers) rolling_max]\n      [(not (pair? (first numbers))) (begin\n       \
    \                           (set! rolling_max (cons max (first numbers) rolling_max))\n\
    \                                  (loop (rest numbers) max (first numbers) rolling_max))\n\
    \                                 (rolling_max (rest numbers))]\n      [else (loop\
    \ (rest numbers) (max max (first numbers)) (first numbers) rolling_max)])))\n",
  "  (let ((max-rolling-numbers (list numbers)))\n    (define (loop i max-rolling-numbers)\n\
    \      (if (null? max-rolling-numbers)\n          numbers\n          (loop (+\
    \ i 1) (max max-rolling-numbers (rest max-rolling-numbers)))))\n    (loop 1 max-rolling-numbers)))\n\
    </code>\nThe above function implements a rolling maximum - the function calls\
    \ itself recursively with a list of at most two elements less - each time the\
    \ rolling maximum becomes larger than the current maximum.\nHere are some timing\
    \ tests:\n<code>", "  (define (max_rolling current previous)\n    (if (null? previous)\n\
    \        current\n        (if (> (first previous) (first current))\n         \
    \   (max_rolling (first previous) current)\n            (max_rolling (first previous)\
    \ (cons (first current) previous)))))\n  (if (null? numbers)\n      (list '())\n\
    \      (max_rolling (first numbers) (cons (first numbers) (rolling_max (rest numbers))))))\n",
  "  (cond\n    [(empty? numbers) (first numbers)]\n    [(null? (rest numbers)) (first\
    \ numbers)]\n    [else (cons (max (first numbers) (rolling_max (rest numbers)))\
    \ (rolling_max (rest numbers)))]))\n", "  (let ((result '()))\n    (if (null?\
    \ numbers)\n        result\n        (let ((element (car numbers)))\n         \
    \ (append result\n                  (if (> (car numbers) element)\n          \
    \            (list element)\n                      (rolling_max (cdr numbers))))))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (max numbers)\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (define (helper l m)\n    (cond [(empty? l) m]\n  \
    \        [(> (car l) m)\n           (cons m (helper (cdr l) (+ m (car l))))]\n\
    \          [else (helper (cdr l) m)]))\n  (helper (cdr numbers) -inf))\n", " \
    \ (let loop ((numbers '()) (result '()))\n    (cond ((empty? numbers) (append\
    \ result '()))\n          ((> (car numbers) result) (loop (cdr numbers) (cdr result)))\n\
    \          (else (loop (cdr numbers) (cons (car numbers) result)))))\n  (loop\
    \ '() '()))\n", "  (let ((max-so-far 0))\n    (for ([num (in-list numbers)])\n\
    \      (let ((next-num (min num (+ max-so-far num))))\n        (if (<= num next-num)\n\
    \            (set! max-so-far next-num)\n            (set! num (+ num (- max-so-far\
    \ num))))))\n    max-so-far))\n", "  (cond\n    ((null? numbers) '())\n    ((=\
    \ (length numbers) 1) numbers)\n    (else (max numbers (rolling_max (rest numbers))))))\n",
  "  (let loop ((result '())\n             (rolling-numbers numbers)\n           \
    \  (rolling-numbers numbers (reverse rolling-numbers))\n             (index 0))\n\
    \    (cond\n      [(empty? rolling-numbers) (cons result '())]\n      [(> index\
    \ (length rolling-numbers)) (loop (cons result '()) (tail rolling-numbers) (+\
    \ index 1))]\n      [else (loop (cons (max result (first rolling-numbers)) result)\
    \ (rest rolling-numbers)\n                   (+ index 1))]\n    )\n  )\n)\n",
  "  (if (null? numbers)\n      '()\n      (if (= (car numbers) (car (cdr numbers)))\n\
    \          (cons (car numbers) (rolling_max (cdr numbers))))\n          (rolling_max\
    \ (cdr numbers)))))\n", "  (if (null? numbers)\n      '()\n      (append\n   \
    \    (if (> (first numbers) (second numbers))\n           (list first numbers)\n\
    \           (rolling_max (rest numbers)))))) ;#lang racket\n", "  (if (null? numbers)\n\
    \      '()\n      (append (max numbers last)\n              (rolling_max (rest\
    \ numbers)))))\n", "  (if (empty? numbers)\n      '()\n      (cond [(> (first\
    \ numbers) (first list)) (first list)]\n            [(<= (first numbers) (first\
    \ list)) (rolling_max (rest numbers))]\n            [else (cons (first list) (rolling_max\
    \ (rest numbers))))]))\n", "  \n  (let loop ((numbers '())\n             (max-list\
    \ '()))\n    (if (empty? numbers)\n        (reverse max-list)\n        (loop (rest\
    \ numbers)\n              (cons (flatten numbers)\n                    (if (>\
    \ (first numbers) (first max-list))\n                        (cons (first numbers)\n\
    \                              max-list)\n                        max-list))))))\n",
  "  (if (empty? numbers)\n      '()\n      (cons (max (first numbers))\n        \
    \    (rolling_max (rest numbers)))))\n", "  (if (null? numbers)\n      '()\n \
    \     (append (take-tail (rest numbers) (lambda (x y z)\n                    \
    \                (cond\n                                      [(< x y) z]\n  \
    \                                    [(< y z) y]\n                           \
    \           [else x])))\n              (rolling_max (drop-tail numbers 1)))))\n\
    </cell>\n<cell>\n#lang racket\n", "  (if (null? numbers)\n      null\n      (cons\
    \ (max (car numbers)) (rolling_max (cdr numbers)))))\n", "  (if (null? numbers)\n\
    \      (list numbers)\n      (let ([m (first numbers)])\n        (if (null? (rest\
    \ numbers))\n            (list (cons m (rolling_max (rest numbers))))\n      \
    \      (let ([n (first numbers)])\n              (if (> (first numbers) m)\n \
    \                 (list (cons m (rolling_max (rest numbers))))\n             \
    \     (list (cons n (rolling_max (rest numbers))))))))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append (max head tail)\n              (rolling_max (cdr numbers)))))\n",
  "  (let loop ((i numbers) (max #f) (max #f) (rolled-max #f))\n    (cond ((null?\
    \ i) \n           (if (< max #f)\n               (reverse rolled-max)\n      \
    \         (reverse (list max))))\n          ((null? (cdr i)) (if (< max #f)\n\
    \                               (reverse rolled-max)\n                       \
    \        (reverse (list max))))\n          ((> max (car i)) (loop (cdr i) max\
    \ max rolled-max))\n          ((< max (car i))\n           (loop (cdr i) (max\
    \ (car i)) (car i) (cons (car i) rolled-max)))\n          (else\n           (loop\
    \ (cdr i) max (car i) rolled-max)))))\n</code>\n<|/ a dscore=0 tags=racket,scheme\
    \ |>\n<| c |>\nthank you for all the effort. it still isn't working for me. i\
    \ am sure i am using it incorrectly but i am not able to figure out why. i will\
    \ update my question with what my code looks like now.\n<|/ c |>\n<| c |>\n- I\
    \ just edited my answer to add a test case.  It works for me (it also works for\
    \ other test cases).  Can you post your new code so we can see what's different?\n\
    <|/ c |>\n<| c |>\ni edited my question to include my new code. i am still not\
    \ getting it. my test case was `rolling_max (list (list 1))` which is what i was\
    \ given as a sample. i know my code isn't exactly correct but i don't know where\
    \ to start. thank you for all your help.\n<|/ c |>\n<| c |>\n- Your new code doesn't\
    \ work because your test case is wrong.  For `rolling_max (list 1)`, the correct\
    \ result should be `(reverse (list 1))`.  It works correctly for the first test\
    \ case, but when you call `rolling_max (list (list 1 2))` it gets stuck in the\
    \ `else` branch and never terminates.\n<|/ c |>\n<| c |>\nyes sorry, i didn't\
    \ realize the test case was wrong. i just updated my question with the new test\
    \ case. thank you\n<|/ c |>\n<| a tags=racket,scheme dscore=0 |>\nI wrote a recursive\
    \ function max_of_list that takes an arbitrary number of lists and returns the\
    \ largest one:\n<code>", "  (let loop ((numbers numbers)\n             (maxs ()))\n\
    \    (if (null? numbers)\n        maxs\n        (loop (rest numbers)\n       \
    \        (cond [(< (first numbers) (first maxs))\n                       (cons\
    \ numbers (rest maxs))]\n                     [else (cons numbers (append maxs\
    \ (first maxs)))])))\n    ))\n", "  (define (rolling_max_accum numbers current_maximum)\n\
    \    (cond [(null? numbers) current_maximum]\n          [(< (first numbers) current_maximum)\
    \ (rolling_max_accum numbers (first numbers))]\n          [else (rolling_max_accum\
    \ (rest numbers) (max current_maximum (first numbers)))]))\n  (rolling_max_accum\
    \ numbers (first numbers)))\n", '  (nth (rolling numbers) (rolling numbers) (rolling
    numbers) (rolling numbers) (rolling numbers) (rolling numbers) (rolling numbers)
    (rolling numbers) (rolling numbers) (rolling numbers) (rolling numbers) (rolling
    numbers)))', "  (let loop ((current 0))\n    (if (null? (cdr numbers))\n     \
    \   (reverse current)\n        (loop (cons (max (car numbers) current) current)\n\
    \              (cdr numbers)))))\n", "  (let loop ((n numbers) (max #f) (i 0)\
    \ (result #f))\n    (if (null? n)\n        (if (not max)\n            (begin (set!\
    \ result (append result (list max))) (set! max #f) (set! i 0))\n            (begin\
    \ (set! result (append result (list max))) (set! max #f) (set! i 0) (set! result\
    \ #f))))\n      (let ((n' (remove n numbers))) (if (not max)\n               \
    \                     (loop (cdr n') (max #f) (+ i 1) (append result (list max)))\n\
    \                                    (loop (cdr n') (max (car n')) (+ i 1) (append\
    \ result (list max)))))))\n  (reverse result))\n", "  (let loop ((n numbers)\n\
    \             (acc '()))\n    (if (< n 1)\n        acc\n        (loop (- n 1)\n\
    \              (cons (max n (car acc))\n                    acc)))))\n", "  (define\
    \ (helper numbers current)\n    (cond\n      [(null? numbers) current]\n     \
    \ [(= current (max numbers))\n       (helper numbers (max numbers current))]\n\
    \      [else (helper numbers (max numbers current))]\n    ))\n  (helper numbers\
    \ 0))", "  (let loop ((min-max numbers) (result '()))\n    (if (null? numbers)\n\
    \        result\n        (loop (first numbers)\n              (cons (max (first\
    \ numbers) (first min-max))\n                    (loop numbers (rest min-max)))))))\n\
    </code>\n<|/ a tags=functional-programming,racket,scheme |>\n<| c |>\nThank you\
    \ for the help. I just want to add one more thing that I didn't notice earlier,\
    \ but this algorithm can be done in O(n) time with dynamic programming. Using\
    \ memoization we can do it in a linear time complexity. Do you think it's possible\
    \ for you to modify the algorithm to make it run faster?\n<|/ c |>\n<| c |>\n\
    You can try this by taking out the `max` function and replacing `max-tail` with\
    \ `(lambda (list) (let loop ((min list) (max-result (first list)))) (if (null?\
    \ (rest list)) (first list) (loop (rest list) (cons (first list) max-result))))`\n\
    <|/ c |>\n<| c |>\nYes you can, although it will give you an incorrect answer\
    \ if the list is empty. Check out the code I posted in my answer.\n<|/ c |>\n\
    <| c |>\nThat's true, but you can easily fix that by taking the `max` out of the\
    \ `loop` function. Anyway, the idea is to do it in linear time with `memorization`\
    \ right?\n<|/ c |>\n<| c |>\nThe point of memoization is exactly to take advantage\
    \ of that fact.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (let loop ((tail (car\
    \ numbers))\n             (max-list (reverse numbers)))\n    (if (null? tail)\n\
    \        max-list\n        (loop (cdr tail)\n              (cons (max (car tail)\
    \ (max max-list))\n                    max-list))))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append\n       (scan (partial max numbers)\n             (quotient\
    \ (length numbers) 2))\n       (tail numbers))))\n", "  (map (lambda (x)\n   \
    \      (let ((cur (max (car numbers) x)))\n           (cond\n            ((null?\
    \ numbers) x)\n            (else (max (car numbers) x))\n            (else cur))))\n\
    \       numbers))", "  (cond (empty? numbers) numbers (recur numbers (cdr numbers)\
    \ 0))\n  (let ((rolling numbers))\n    (if (empty? (cdr rolling))\n        (cons\
    \ (car rolling) rolling)\n        (recur (cdr rolling) (max 0 (car rolling)))))))\n",
  "  (let loop [result (make-array (length numbers) #min-value 0)\n            counter\
    \ 0]\n    (cond\n      [(empty? numbers) result]\n      [else (loop (loop-tail\
    \ numbers result) (incf counter) (- counter 1))]))))\n", "  (let loop ((rolling\
    \ '()) (max -inf))\n    (if (empty? numbers)\n        (reverse rolling)\n    \
    \    (loop (cons (max rolling) rolling)\n               (car numbers)))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (max (first numbers)\n          \
    \      (second numbers))\n            (rolling_max (rest numbers)))))\n", "  (if\
    \ (or (null? numbers)\n          (zero? (car numbers)))\n      numbers\n     \
    \ (append (list* (car numbers)\n                  (rolling_max (cdr numbers))))\n\
    \      )\n  )\n", "  (define (next x)\n    (if (null? numbers)\n        x\n  \
    \      (max x (car numbers))))\n  (define (max x y)\n    (if (> x y)\n       \
    \ x\n        y))\n  (reduce next '() numbers))\n", "  (define (rolling_max-helper\
    \ result current index nums)\n    (cond [(null? nums) result]\n          [(> current\
    \ (first nums)) (rolling_max-helper result current (+ index 1) (rest nums))]\n\
    \          [else (rolling_max-helper (cons current result) (first nums) (+ index\
    \ 1) (rest nums))]))\n  (rolling_max-helper #f #f 0 numbers))\n", "  (define (rolling-max-helper\
    \ numbers current-max)\n    (if (null? numbers)\n        current-max\n       \
    \ (rolling-max-helper (cdr numbers)\n                          (if (> current-max\
    \ (car numbers)\n                                  current-max)\n            \
    \                  current-max\n                              (car numbers)))))\n\
    \  (rolling-max-helper numbers 0))\n", "  (if (null? numbers)\n      '()\n   \
    \   (cons (max-element numbers)\n            (rolling_max (tail numbers)))))\n",
  "  (let loop ((max-number numbers)\n             (max-counter 0))\n    (cond\n \
    \     [(null? max-number) numbers]\n      [else (cons (max (car max-number) max-counter)\n\
    \                  (loop (cdr max-number)\n                         (add1 max-counter)))])))\n",
  "  (cond [(empty? numbers) empty]\n        [(> (first numbers) (last (first numbers)))\
    \ (rest numbers)]\n        [else (cons (last (first numbers)) (rolling_max (rest\
    \ numbers))) ]))\n", "  (cond [(empty? numbers) numbers]\n        [(<= (first\
    \ numbers) (first rest)) (cons (first numbers) (rolling_max (rest numbers)))]\n\
    \        [else (rolling_max (rest numbers))]))\n", "  (if (null? (car numbers))\n\
    \      (cons 1 (rolling_max (cdr numbers))) ; cons current element with next rolling\
    \ maximum\n      (cons (max (car numbers)) (rolling_max (cdr numbers)))))\n",
  "  (let ((m (length numbers)))\n    (let loop ((i 0))\n      (if (< m i)\n     \
    \     (list numbers (expt numbers (- m i)))\n          (loop (+ i 1))))))\n",
  "  (let loop ((acc '()) (rolling '()) (max 0))\n    (cond\n      [(empty? numbers)\
    \ (cons max acc)]\n      [(null? (rest numbers)) (cons max acc)]\n      [else\
    \ (loop (cons (max max (first numbers)) acc) (cons (first numbers) rolling) (max\
    \ max (first numbers)))]\n    )\n  )\n)", "  (let loop ([numbers numbers]\n  \
    \           [max -inf]\n             [count 0])\n    (cond\n      [(null? numbers)\
    \ (list max)]\n      [(< max first numbers) (loop (rest numbers) first 1)]\n \
    \     [else (loop (rest numbers) (first numbers) (add1 count))]))))\n", "  ;;\
    \ rolling_max_aux: The auxiliary procedure for rolling max algorithm.\n  ;; numbers:\
    \ The input list of integers.\n  (define (rolling_max_aux numbers)\n    (if (null?\
    \ numbers)\n        numbers\n        (let ((number (first numbers))\n        \
    \      (max (car numbers)))\n          (if (>= max number)\n              (rolling_max_aux\
    \ (rest numbers))\n              (cons max rolling_max_aux (rest numbers))))))\n\
    \  (rolling_max_aux numbers))\n", "  (if (null? numbers)\n      '()\n      (let\
    \ ((max (first numbers))\n            (rolling (list max))\n            (num (rest\
    \ numbers)))\n        (if (null? num)\n            (append-copy max rolling)\n\
    \            (append-copy (max num) rolling))))))\n", "  (define (helper-fn n\
    \ rolling max-so-far max-so-far-last)\n    (cond\n      [(< n rolling) (max? max-so-far\
    \ max-so-far-last)]\n      [else (helper-fn (- n 1) (max max-so-far n) (max max-so-far-last\
    \ n))]))\n  (define (rolling-max n max-so-far)\n    (cond\n      [(< n 0) max-so-far]\n\
    \      [else (helper-fn n (max max-so-far n) 0)]))\n  (define (rolling-max-iter\
    \ numbers max-so-far)\n    (cond\n      [(null? numbers) max-so-far]\n      [else\
    \ (rolling-max-iter (cdr numbers) (max max-so-far first))]))\n  (rolling-max-iter\
    \ numbers 0))\n", "  (let ((max-list (build-list 0 max (lambda (x y) (if (> x\
    \ y) x y)))))\n    (for-each (lambda (x) (set! (sub1 (cdr max-list) (car max-list))\
    \ x)) numbers)\n    (append (cdr max-list) max-list)))\n", "  (let loop ((max\
    \ #f) (numbers numbers))\n    (cond [(empty? numbers) #t]\n          [else (loop\
    \ (max max (first numbers)) (drop 1 (rest numbers)))]\n          [else (cons (first\
    \ numbers) (loop (max max (first numbers)) (drop 1 numbers)))])))", "  (if (null?\
    \ numbers)\n      '()\n      (append (apply max numbers)\n              (rolling_max\
    \ (subseq numbers 0 10)))))\n</code>\nNote that I am using a subsequence here,\
    \ which is a more efficient way to use recursion.\n<|/ a |>\n<| c |>\nWhy not\
    \ `max` instead of `apply`?\n<|/ c |>\n<| c |>\n`max` takes any number of arguments,\
    \ so I would have to call `apply` to pass my list as the argument list\n<|/ c\
    \ |>\n<| c |>\nIn most languages, that would work as well. Why do you need to\
    \ use apply anyway?\n<|/ c |>\n<| c |>\n`max` takes any number of arguments, so\
    \ I can just pass the whole list as argument. `apply` takes an unlimited number\
    \ of arguments. That's what I meant by my comment above\n<|/ c |>\n<| a tags=racket,scheme\
    \ dscore=0 |>\nMy approach would be to define a helper function which returns\
    \ a list with n consecutive elements of the original list and then use foldl to\
    \ go over those elements. For example:\n<code>", "  ;; Find rolling maximum using\
    \ backtracking\n  (define (max rolling current-max)\n    (cond [(or (null? rolling)\
    \ (equal? current-max maximum))\n           maximum]\n          [else (max @(take-last\
    \ rolling numbers) maximum)]))\n  (max @(take-last numbers (- @(length numbers)\
    \ 2))\n       maximum))\n", "  (cond [(null? numbers) numbers]\n        [(< (first\
    \ numbers) (first numbers)) (rolling_max (rest numbers))]\n        [(null? (rest\
    \ numbers)) (first numbers)]\n        [else (rolling_max (rest numbers))]))\n",
  "  ;; (* -1 -1 (- 2 3))\n  (define (helper numbers moment)\n    (cond\n      [(null?\
    \ numbers)\n       numbers]\n      [(= moment 0)\n       (max (car numbers) (helper\
    \ (cdr numbers) (- moment 1)))]\n      [else\n       (helper (cdr numbers) moment)]))\n\
    \  (helper numbers 0))\n", "  (let loop ((min-max 0) (current '()))\n    (if (empty?\
    \ numbers)\n        current\n        (loop (add1 min-max) (cons min-max\n    \
    \                                 (loop (sub1 min-max) (first numbers))))))\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nAh, this works perfectly for me, thanks a\
    \ lot! I'm wondering if I can get the algorithm to work even when the window length\
    \ is larger than the length of the input list. For example, I was hoping that\
    \ it would work for a list of 3 numbers and a window length of 2.\n<|/ c |>\n\
    <| c |>\nI added a section to show how it handles windows of arbitrary length.\n\
    <|/ c |>\n<| c |>\nSorry that I'm so late to this thread, but this doesn't seem\
    \ to work for the case where you use 'cons' in the looping condition. I think\
    \ that it only works with 'cons' when you are using 'first' as the base case in\
    \ the recursive looping. However, using 'first' as the base case is incorrect.\n\
    <|/ c |>\n<| c |>\nThe use of `first` was only to match what the OP had. My version\
    \ also handles windows of arbitrary length, using only `cons` and not `first`.\
    \ When you use `cons` inside the loop, you just use `(first list)` inside the\
    \ loop. `first` is necessary because that's how we find the minimum and maximum\
    \ elements in the subsequence.\n<|/ c |>\n<| c |>\nI've got an additional follow\
    \ up question here if you could take a look: https://stackoverflow.com/questions/63239170/how-to-replace-window-with-a-function-instead-of-a-number\n\
    <|/ c |>\n<| a tags=scheme |>\nHere is another solution:\n<code>", "  (if (empty?\
    \ numbers)\n      '()\n      (let ([window (cdr (rest numbers))])\n        (if\
    \ (< (first window) (first numbers))\n            (cons (first window) (rolling_max\
    \ (rest numbers)))\n            (cons (first numbers) (rolling_max (rest numbers)))))))\n",
  "  (let loop ((max-list '()) (index 0) (max-list-length 0))\n    (if (null? numbers)\n\
    \        (reverse max-list)\n        (loop (append max-list numbers) (+ index\
    \ 1) (if (>= index max-list-length) (+ 1 (length max-list))\n                \
    \                                              (length max-list))))))\n", "  (if\
    \ (null? numbers)\n      '()\n      (cons (max numbers nil)\n            (rolling_max\
    \ (rest numbers)))))\n", "  (define (rolling_max-loop n acc)\n    (if (null? n)\n\
    \        acc\n        (rolling_max-loop (rest n) (max (first n) acc))))\n  (rolling_max-loop\
    \ numbers 0))\n", "  (cond ((null? numbers) (quote ()))\n        ((equal? (first\
    \ numbers) (last (rest numbers))) (cons (first numbers) (rolling_max (rest (rest\
    \ numbers)))))\n        (else (cons (first numbers) (rolling_max (rest (rest numbers)))))))\n",
  "  (cond\n    ((null? numbers) '())\n    ((number? (car numbers)) (cons (car numbers)\n\
    \                                   (rolling_max (cdr numbers))))\n    (else (rolling_max\
    \ (cdr numbers)))))\n", "  (let loop ((max-list '())\n             (max-num '()))\n\
    \    (cond ((null? numbers) max-list)\n          ((null? (rest numbers)) (cons\
    \ max-num max-list))\n          ((> (car numbers) (caar max-num)) (cons max-num\
    \ max-list))\n          (else (loop (cons (car numbers)\n                    \
    \         (cons max-num (caar max-list))\n                             (cdr max-list))\n\
    \                      (cons (car numbers)\n                             (caar\
    \ max-num))\n                      (cdr numbers)))))))\n", "  (define (helper\
    \ current prev-number max-so-far)\n    (cond [(= current prev-number) max-so-far]\n\
    \          [(< (first numbers) current) (helper current (first numbers) max-so-far)]\n\
    \          [else (helper (first numbers)\n                        (first numbers)\n\
    \                        (cond (< (rest numbers) max-so-far)\n               \
    \               (cons (first numbers) max-so-far)\n                          \
    \    max-so-far))])))\n  (helper numbers numbers numbers))\n</code>\n<|/ a dscore=0\
    \ tags=scheme,racket |>\n<| a |>\nA simple solution to find the maximum in a list\
    \ can be implemented using a list recursion which keeps track of the maximum and\
    \ the index. It keeps track of the current and previous number and the maximum\
    \ so far.\n<code>", "  (cond ((null? numbers) '())\n        ((null? (cdr numbers))\
    \ (car numbers))\n        (else (cons (car numbers)\n                   (rolling_max\
    \ (cdr numbers))))))\n", "  (cond [(empty? numbers) empty]\n        [else (if\
    \ (= (remainder 1 (car numbers)) (car numbers))\n                 (cons (car numbers)\
    \ (rolling_max (cdr numbers)))\n                 (rolling_max (cdr numbers)))]))\n\
    </code>\n<|/ a tags=racket,list |>\n<| a dscore=0 |>\nHere's a solution using\
    \ a tail-recursive function and list comprehension.\n<code>", "  (cond [(null?\
    \ numbers)\n         null]\n        [(> (first numbers) (second numbers))\n  \
    \       (cons (first numbers) (rolling_max (rest numbers)))]\n        [else\n\
    \         (cons (second numbers)\n               (rolling_max (rest (rest numbers))))]))\n",
  "  (let loop ((a numbers)\n             (n 0)\n             (max-list '()))\n  \
    \  (if (null? a)\n        (reverse max-list)\n        (let ((n-copy (+ n 1)))\n\
    \          (if (> (car a) (cadr a))\n              (loop a\n                 \
    \   (add1 n)\n                    (cons (car a) max-list))\n              (loop\
    \ a\n                    (add1 n-copy)\n                    (cons (acar a) max-list)))))\n\
    \  (loop numbers '() max-list))\n", "  (define (helper-func nums n max-so-far\
    \ max-so-far-prev)\n    (cond\n      [(null? nums) max-so-far-prev]\n      [(=\
    \ n (length nums)) (cons max-so-far max-so-far-prev)]\n      [else (helper-func\
    \ (cdr nums) (+ n 1) (cons (car nums) max-so-far) (cons (car nums) max-so-far-prev))]))\n\
    \  (helper-func numbers 1 '() (cons '() '())))\n", "  (if (null? numbers)\n  \
    \    '()\n      (append (take-while add1 (tail numbers))\n              (rolling_max\
    \ (drop-right numbers (- tail numbers))))))\n", "  (if (empty? numbers)\n    \
    \  '()\n      (append (max numbers)\n               (rolling_max (rest numbers)))))\n",
  "  (cond [(null? numbers) '()]\n        [(= 1 (length numbers)) numbers]\n     \
    \   [(= 2 (length numbers)) numbers]\n        [(> (tail numbers) (head numbers))\
    \ (cons (tail numbers) (rolling_max (tail numbers)))]\n        [else (rolling_max\
    \ (tail numbers))]))\n", "  (cond ((null? numbers) numbers)\n        ((null? (cdr\
    \ numbers)) (car numbers))\n        (else (rolling_max (cdr numbers) (apply max\
    \ (map (lambda (n) (max (car numbers) n)) numbers))))))\n", "  (if (null? numbers)\n\
    \      '()\n      (let loop ((number numbers)\n                 (result '()))\n\
    \        (cond ((null? (rest numbers)) #f)\n              ((= (length (rest numbers))\
    \ 0)\n               result)\n              ((> (car number) (car result))\n \
    \              (loop (rest numbers) (cons (car number) result)))\n           \
    \   (else\n               (loop (rest numbers) (cons (car number) result)))))\n\
    \        result))\n", "  (if (empty? numbers) numbers\n      (max numbers (rolling_max\
    \ (rest (rest numbers))))))\n", "  (cond\n    [(empty? numbers) numbers]\n   \
    \ [else (if (= (first numbers) (last)) numbers (cons (last (rolling_max (rest\
    \ numbers))) (rolling_max (rest numbers))))]\n    )\n  )\n", "  (define (helper\
    \ numbers acc)\n    (if (empty? numbers)\n        acc\n        (helper (rest numbers)\
    \ (max numbers (car numbers)))))\n  (helper numbers 0))\n", "  (define (rolling-max-loop\
    \ numbers count)\n    (cond [(empty? numbers) numbers]\n          [(< count (length\
    \ numbers)) (cons (car numbers) (rolling-max-loop (cdr numbers) (add1 count)))]\n\
    \          [else (rolling-max-loop (cdr numbers) count)]))\n  (rolling-max-loop\
    \ numbers 0))\n", "  (let loop ((numbers numbers)\n             (acc '()))\n \
    \   (if (null? numbers)\n        acc\n        (loop (cdr numbers)\n          \
    \    (cons (car numbers)\n                    (if (< (car numbers) acc)\n    \
    \                    (cons (car numbers) acc)\n                        acc))))))\n",
  "  (if (null? numbers) numbers\n      (let loop ((numbers numbers)\n           \
    \      (max 0)\n                 (max 0))\n        (if (null? numbers)\n     \
    \       max\n            (loop (rest numbers)\n                  (max max)\n \
    \                 (if (> (car numbers) max)\n                      max\n     \
    \                 (loop (cdr numbers)\n                            max\n     \
    \                       (car numbers))))))))\n", "  (let loop ((numbers numbers)\n\
    \             (max-so-far #f)\n             (max-so-far #f)\n             (max-so-far\
    \ #f)\n             (max-so-far #f))\n    (if (empty? numbers)\n        max-so-far\n\
    \        (let ((new (car numbers))\n               (max-so-far max-so-far))\n\
    \          (if (> new max-so-far)\n              (loop (cdr numbers) new-so-far\
    \ max-so-far (max new-so-far max-so-far))\n              (loop (cdr numbers) new-so-far\
    \ max-so-far max-so-far))))))\n", "  (let loop ((numbers numbers)\n          \
    \   (max 0))\n    (if (empty? numbers)\n        max\n        (let ((number (first\
    \ numbers))\n              (next-number (rest numbers)))\n          (if (< number\
    \ max)\n              (loop (rest next-number) max)\n              (loop (rest\
    \ next-number) number)))))\n", "  ;; Base case: no elements to check\n  (if (empty?\
    \ numbers)\n      '()\n      ;; Compute the rolling maximum of the first element\n\
    \      (cons \n         (max (car numbers) \n              (rolling_max (cdr numbers))))))\
    \ ; <-- THIS LINE CAUSE IT DOES NOT WORK\n", "  (let loop ((max-list '() (list-length\
    \ (rolling_window (max 0 numbers)))))\n    (if (empty? numbers)\n        (reverse\
    \ max-list)\n        (loop (cons (car max-list)\n                      (loop (cdr\
    \ max-list)))))))\n", "  (if (null? numbers)\n      '()\n      (let ((result (loop\
    \ for elt in numbers\n                         unless (> (loop for i from 0\n\
    \                                        collect elt\n                       \
    \                 until (= (length result) i))\n                             \
    \     collect elt)))\n            (index (loop for i from 0\n                \
    \         collect i)))\n        (append result\n                 (rolling_max\
    \ (remove (lambda (i) (> (first result) elt))\n                              \
    \   (remove (lambda (i) (> (first index) i))\n                               \
    \          (remove (lambda (i) (< i length))\n                               \
    \                 index)))))))\n</code>\n<|/ a tags=lisp,recursion,scheme dscore=1\
    \ |>\n<| a dscore=1 |>\nUsing Racket:\n<code>\n#lang racket\n", "  (cond\n   \
    \ [(empty? numbers) numbers]\n    [(> (first numbers) (first numbers)) (rolling_max\
    \ (rest numbers))]\n    [else (cons (first numbers) (rolling_max (rest numbers)))]))\n",
  "  (cond [(null? numbers) 0]\n        [else\n         (let ([sum (apply + numbers)])\n\
    \           (cond [(< sum numbers) (cons sum (rolling_max (rest numbers)))]\n\
    \                 [else (cons sum (rolling_max (rest numbers)))]))]))\n", "  (cond\
    \ [(empty? numbers)\n         (list numbers)]\n        [(< (car numbers) (car\
    \ (cdr numbers)))\n         (rolling_max (cdr numbers))]\n        [else\n    \
    \     (cons (car numbers)\n              (rolling_max (cdr numbers))]))\n)\n</cell>\n\
    <code language=dyalog-kernel>", "  (let loop ((max-list '())\n             (current-list\
    \ numbers)\n             (result '()))\n    (cond ((null? current-list) result)\n\
    \          ((null? max-list)\n           (loop (cons max-list result)\n      \
    \           (cdr current-list) result))\n          ((< current-list (car max-list))\n\
    \           (loop (cons current-list (car max-list))\n                 (cdr current-list)\
    \ result))\n          (else\n           (loop (cons current-list (car max-list))\n\
    \                 (cdr max-list) result))))\n  result)\n", "  (cond ((null? numbers)\
    \ '())\n        (else\n         (let ((max '()))\n           (do ((i 0 (+ i 1))\n\
    \                (max (if (< (length numbers) i) (max numbers)\n             \
    \             (cons (car numbers) max))))\n                 ((null? max) max)))))\n",
  "  (if (null? numbers)\n      '()\n      (let loop ((numbers (sort numbers))\n \
    \                (max-length '()))\n        (if (empty? numbers)\n           \
    \ (if (or (empty? max-length) (null? max-length))\n                numbers\n \
    \               (append max-length (list numbers))))\n        (loop (cdr numbers)\n\
    \             (if (= 0 (car numbers))\n                 max-length\n         \
    \        (loop (cdr numbers)\n                       (cons (car numbers) max-length)))))))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for all the comments and edits, I\
    \ have tried to make a minimal and reproducible example. Hopefully, this will\
    \ also help people answer questions more clearly!\n<|/ c |>\n<| a |>\n<code>",
  "  (let loop ((head numbers)\n             (result '()))\n    (cond ((null? head)\
    \ result)\n          ((< head (list? (car head))) (loop (cdr head) (cons (car\
    \ head) result)))\n          (else (loop (cdr head) (cons head result))))))\n",
  "  (cond [(empty? numbers) 0]\n        [(> (last numbers) (first numbers)) (cons\
    \ (first numbers) (rolling_max (rest numbers)))]\n        [else (rolling_max (rest\
    \ numbers))]))\n", "  (define (rolling_max-loop max count numbers)\n    (if (null?\
    \ numbers)\n        max\n        (let ((next (first numbers)))\n          (if\
    \ (< count (length (rest numbers)))\n              (rolling_max-loop (max next)\n\
    \                                (+ count 1)\n                               \
    \ (rest numbers))\n              (rolling_max-loop max\n                     \
    \           count\n                                (rest numbers)))))\n  (rolling_max-loop\
    \ #f 0 numbers))\n", "  (define (find-max numbers end-index)\n    (if (< end-index\
    \ 0)\n        '()\n        (if (equal? (first numbers) (last (rest numbers)))\n\
    \            (last numbers)\n            (find-max (rest numbers) (sub1 end-index))))))\n\
    \  (find-max numbers 0))\n</cell>\n<cell>\n#lang racket", "  (cond\n    [(empty?\
    \ numbers) '()]\n    [(= 1 (length numbers)) (list numbers)]\n    [else (append\
    \ (list (max (first numbers))) (rolling_max (rest numbers))))]))\n", "  (let loop\
    \ ((max number) (carry '()))\n    (if (null? numbers)\n        carry\n       \
    \ (loop (max carry (first numbers))\n              (cdr numbers)))))\n", "  (let\
    \ loop ()\n    (if (empty? numbers)\n        (reverse numbers)\n        (let ((max\
    \ (car numbers))\n              (tail (cdr numbers))\n              (max-index\
    \ (length numbers)))\n          (if (< max-index 0)\n              (loop () max-index\
    \ 0 max tail)\n              (let ((n (+ max-index 1)))\n                (if (=\
    \ n max-index)\n                    (reverse tail)\n                    (if (>\
    \ max tail)\n                        (loop () max-index n max tail)\n        \
    \                (loop () (- n 1) (+ n 1) max tail))))))))\n", "  (let loop ((number\
    \ numbers)\n             (max-list '())\n             (index 0))\n    (if (null?\
    \ number)\n        (reverse max-list)\n        (let ((max (car number)))\n   \
    \       (if (null? max-list)\n              (if (= index 0)\n                \
    \  (if (< max number)\n                      (list max)\n                    \
    \  (list number))\n                  (if (> max number)\n                    \
    \  (list max)\n                      (list number))))\n          (if (null? (cdr\
    \ numbers))\n              (if (= index 0)\n                  (if (< max number)\n\
    \                      (list max)\n                      (list number))\n    \
    \              (if (> max number)\n                      (list max)\n        \
    \              (list number))))\n          (loop (cdr number) (reverse max-list)\
    \ (add1 index))))))\n", "  (cond [(empty? numbers) numbers]\n        [(= (first\
    \ (rest numbers)) (rest (first numbers)))\n         (cons ((first (rest numbers))\
    \ (rest (first numbers))) numbers)\n         numbers]\n        [else (cons (first\
    \ numbers)\n                    (rolling_max (tail (rest numbers))))]))\n", " \
    \ (if (empty? numbers)\n      '()\n      (let ((largest (car numbers)))\n    \
    \    (if (> (car numbers) largest)\n            (cons largest numbers)\n     \
    \       (rolling_max (cdr numbers))))))\n", "  (let loop ((max numbers) (accum\
    \ []) (num (length numbers)) (index (modulo num 2)))\n    (cond\n      [(null?\
    \ num) (reverse accum)]\n      [(= index 0) (loop (max numbers) (conj accum max)\
    \ (dec num) (- (+ index 1) 2)))]\n      [(= index 1) (loop (max numbers) (conj\
    \ accum max) num (- (+ index 1) 2)))]\n      [else (loop (max numbers) (conj accum\
    \ max) (+ index 1) 0))]\n    )\n  )\n", "  (cond [(empty? numbers) numbers]\n\
    \        [else\n         (let ([max-number ((max numbers) (last numbers))])\n\
    \           (rolling_max (cdr numbers) max-number))]))\n", "  (map (lambda (x)\n\
    \         (cond [(<= x numbers) x]\n               [else (+ x (rolling_max (rest\
    \ numbers))) ]))\n       numbers))\n", "  (if (null? numbers)\n      '()\n   \
    \   (cond ((= (length numbers) 1) (first numbers))\n            (else\n      \
    \       (let ((max (first numbers))\n                   (max-tail (rest numbers)))\n\
    \               (if (null? (rest numbers))\n                   (list max)\n  \
    \                 (cond ((< max max-tail) (list max))\n                      \
    \   ((> max max-tail) (list max-tail max))\n                         (else (cons\
    \ (first numbers) (rolling_max (rest numbers)))))))\n             (rolling_max\
    \ (rest numbers)))))", "  (cond\n    ((null? numbers) numbers)\n    ((null? (cdr\
    \ numbers)) (first numbers))\n    ((> (car numbers) (second numbers)) (cons (car\
    \ numbers) (rolling_max (cdr numbers))))\n    (else (rolling_max (cdr numbers)))))\n",
  "  (cond\n    [(empty? numbers) 'empty]\n    [(equal? (first numbers) (last numbers))\
    \ (last numbers)]\n    [else (cons (max numbers) (rolling_max (rest numbers)))]))\n",
  "  (cond ((null? (rest numbers))\n         (last numbers))\n        (else (cons\n\
    \               (if (> (first numbers) (first rest))\n                   (first\
    \ numbers)\n                   (first rest))\n               (rolling_max (rest\
    \ numbers)))))\n</code>\n<|/ a dscore=3 |>\n<| c |>\n+1 for the \"tail recursion\"\
    \ hint. However, I do not believe that tail recursion is really needed here. It\
    \ is just one function calling other functions (with arguments) to achieve the\
    \ goal. Just make use of \"loop\" function in place of \"cons\" and \"last\" function\
    \ in place of \"rest\".\n<|/ c |>\n<| c |>\n: I didn't realize there was a `loop`\
    \ function until just now, but it does exactly what I need. Thank you!\n<|/ c\
    \ |>\n<| c |>\n, if you post the final code as an answer, I'd be happy to accept\
    \ it.\n<|/ c |>\n<| c |>\n: Done.\n<|/ c |>\n<| a dscore=3 tags=racket,scheme\
    \ |>\nYou can do this with recursion with a mutable list - it's an interesting\
    \ exercise, but if you have some more time, it'll be interesting. \n<code>", " \
    \ (let loop ([numbers numbers]\n             [max-list '()]\n             [index\
    \ 0])\n    (cond [(empty? numbers) max-list]\n          [else (loop (rest numbers)\n\
    \                      (cond [(< index (length max-list))\n                  \
    \             (cons (car max-list) max-list)\n                               (else\
    \ (cons (max numbers (car max-list)) max-list))]\n                           \
    \ [(= index (length max-list))\n                             max-list]\n     \
    \                       [else max-list]))]))))\n", "  (define (max-over n acc)\n\
    \    (cond\n      [(= n 0) acc]\n      [(number? (- n 1))\n       (max-over (-\
    \ n 1) (cons n (max acc)))]\n      [else (max-over (- n 1) (max acc))]))\n  (max-over\
    \ 1 (cons (max numbers) nil)))\n", "  (if (null? numbers) '()\n      (let ([head\
    \ (car numbers)])\n        (if (< head (max head (rest numbers))) \n         \
    \   (list head) \n            (append (rolling_max (cons (cdr numbers) numbers))\
    \ \n                    (list (max head (rest numbers)))))))) \n", "  (let ([roll\
    \ (make-list numbers)])\n    (define (rolling_max sum roll)\n      (cond ((null?\
    \ roll) (append sum (reverse roll)))\n            ((<= (first roll) (second roll))\n\
    \             (rolling_max (first roll) (append (second roll) (reverse roll))))\n\
    \            (else (rolling_max (first roll) (append (second roll) (append (reverse\
    \ roll) (first roll)))))\n      )\n      (rolling_max (rest roll) (reverse roll))\n\
    \    )\n    (rolling_max 0 (reverse numbers))\n  )\n)\n", "  (let loop ((i 0))\n\
    \    (cond [(null? (cdr numbers)) numbers]\n          [(< i 10) (reverse (rolling_max\
    \ (cdr (rest numbers))))]\n          [else (cons (max numbers (nthcdr (+ i 1)\
    \ numbers)) (reverse (loop (+ i 1))))]))) ;; #lang racket\n", "  (if (null? numbers)\n\
    \      '()\n      (let ((head (car numbers))\n            (tail (cdr numbers)))\n\
    \        (cond ((>= head tail) (cons head (rolling_max (tail))))\n           \
    \   (else (cons head (rolling_max (cons head tail)))))))\n", "  (if (null? numbers)\n\
    \      '()\n      (let loop ((n numbers)\n                 (result '()))\n   \
    \     (cond ((null? (rest n)) result)\n              (else (loop (rest n) (cons\
    \ (car n) result)))))\n      (apply append (map max-el (reverse result)))))",
  "  (let loop ((numbers numbers) (result '())\n             (i 0))\n    (cond ((null?\
    \ numbers) result)\n          ((> i 0) (loop (rest numbers) (conj result (max\
    \ 0 (car numbers))) (add1 i)))\n          (else (loop (rest numbers) result (add1\
    \ i)))))\n  result)\n", "  (cond [(empty? numbers) nil]\n        [(>= (first numbers)\
    \ (first results)) results]\n        [else (rolling_max (rest numbers))]))\n",
  "  (cond [(null? numbers) (list nil)]\n        [(zero? (car numbers)) (car numbers)]\n\
    \        [else (rolling_max (cdr numbers)\n                          (if (< (car\
    \ numbers) (max numbers))\n                              (cons (max numbers) numbers)\n\
    \                              numbers))]))\n", "  (map max\n       (take (ceiling\
    \ (- m (length numbers))) numbers)))\n", "  (if (or (null? numbers) (null? (cdr\
    \ numbers)))\n      (first numbers)\n      (let ([r (car numbers)])\n        (if\
    \ (or (null? (cdr numbers)) (< r r))\n            r\n            (if (> (car numbers)\
    \ (rolling_max (cdr numbers)))\n                (let ([r (car numbers)])\n   \
    \               (if (or (null? (cdr numbers)) (< r r))\n                     \
    \ r\n                      (if (< (car numbers) r)\n                         \
    \ (car numbers)\n                          (rolling_max (cdr numbers)))))))))\n\
    </code>\nIn Racket this would be:\n<code>", "  (let loop ((max-list '())\n   \
    \          (max-so-far #f)\n             (max-so-far-idx 0))\n    (cond\n    \
    \  ((empty? numbers) max-list)\n      ((< max-so-far max-so-far-idx) (loop (cons\
    \ max-so-far max-list) (- max-so-far-idx 1) max-so-far-idx))\n      (else (loop\
    \ (cons max-so-far max-list) max-so-far-idx (add1 max-so-far-idx)))\n    )\n \
    \ )\n)\n", "  (if (null? numbers)\n      '()\n      (append (maximum (cdr numbers))\n\
    \              (rolling_max (cdr numbers)))))\n", "  (let loop ((tail [null])\
    \ (res []))\n    (cond\n      [(empty? numbers) res]\n      [else (loop (tail\
    \ (rest tail))\n                (if (> head tail)\n                    (cons head\
    \ res)\n                    (loop (rest tail)\n                           (cons\
    \ head res))))]\n    ))\n", "  (cond ((null? numbers) numbers)\n        ((null?\
    \ (cdr numbers)) (list numbers))\n        (else (max (car numbers)\n         \
    \         (rolling_max (cdr numbers))))))\n", "  (if (null? numbers) '()\n   \
    \   (cons (max (first numbers) (rolling_max (rest numbers))) (rolling_max (rest\
    \ numbers)))))\n", "  (if (empty? numbers)\n      '()\n      (append (tail numbers)\n\
    \              (cons (max (rest numbers)\n                         (first numbers))\n\
    \                    (rolling_max (rest numbers))))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (cons\n       (foldr (lambda (element max_so_far) (max element\
    \ max_so_far)) (first numbers)\n             (rest (rest numbers)))\n       numbers)))\n",
  "  (cond [(null? numbers) numbers]\n        [else (append (max (rest numbers)) (rolling_max\
    \ (rest numbers))))]))\n", "  (define (rolling_max-helper numbers max-so-far current-max\
    \ current-index)\n    (cond [(null? numbers)\n           (list current-max)\n\
    \           (let ([next-number (car numbers)])\n             (rolling_max-helper\n\
    \               (cdr numbers)\n               (cond [(< next-number current-max)\n\
    \                       (cons current-max max-so-far)\n                      \
    \ (cons next-number max-so-far)\n                       (rolling_max-helper numbers\
    \ max-so-far current-max current-index)]\n                      [(< next-number\
    \ current-index)]\n                      [(< next-number max-so-far)]\n      \
    \                [(> next-number max-so-far)])\n               (cons next-number\
    \ max-so-far)\n               (current-max next-number))\n             (rolling_max-helper\
    \ numbers max-so-far current-max current-index)])\n           [(> current-index\
    \ 0)\n            (rolling_max-helper\n             numbers\n             max-so-far\n\
    \             (car numbers)\n             (add1 current-index))]\n           [else\
    \ (rolling_max-helper numbers max-so-far current-max current-index)]))\n  (rolling_max-helper\
    \ numbers 0 #f 0))\n", "  (let loop ([numbers numbers]\n             [result '()]\n\
    \             [i 0])\n    (if (empty? numbers)\n        (reverse result)\n   \
    \     (let ((number (first numbers))\n              (new (sub1 (rest numbers))))\n\
    \          (if (< i new)\n              (loop (rest numbers)\n               \
    \     (append result (list number)))\n              (loop (rest new) result (i\
    \ + 1))))))))\n", "  (let loop ((result '())\n             (max (first numbers))\n\
    \             (rest numbers))\n    (if (empty? rest)\n        result\n       \
    \ (let ((new_max (max result)))\n          (loop (cons new_max\n             \
    \          (rest result))\n                (new_max (first rest))\n          \
    \      (rest rest))))))\n", "  (let loop ((number numbers)\n             (rolling_max\
    \ '()))\n    (cond ((null? number) rolling_max)\n          ((<= number (car numbers))\n\
    \           (loop (cdr number) \n                 (cons (car numbers) rolling_max)))\n\
    \          (else\n           (loop (cdr number) \n                 (cons (car\
    \ number) rolling_max)))))\n", "  (map max-by-time numbers))\n", "  (let loop\
    \ ((rolling-max #f)\n             (numbers numbers)\n             (rolled-up #f))\n\
    \    (cond ((null? numbers) rolling-max)\n          ((< rolling-max numbers) rolling-max)\n\
    \          ((< numbers (first numbers)) (loop (first numbers)\n              \
    \                                     (rest numbers)\n                       \
    \                            (set! rolling-max (first numbers))))\n          (else\
    \ (set! rolled-up (first numbers))\n                (loop (rest numbers)\n   \
    \                    (rest numbers)\n                       (set! rolling-max\
    \ (first numbers)))))\n    rolled-up))\n", "  (if (null? numbers)\n      '()\n\
    \      (cons (max (car numbers)) (rolling_max (cdr numbers)))))\n", "  (if (null?\
    \ numbers)\n      '()\n      (append\n       (if (or (null? numbers) (= (count\
    \ numbers) 1))\n           (first numbers)\n           (rolling_max (rest numbers)))\n\
    \       (max numbers))))\n", "  (if (null? (car numbers))\n      '()\n      (append\
    \ (max (car numbers)) (rolling_max (cdr numbers)))))", "  (if (null? numbers)\n\
    \      '()\n      (if (> (first numbers) (second numbers))\n          (cons (first\
    \ numbers)\n                (rolling_max (cdr numbers))))\n          (rolling_max\
    \ (cdr numbers)))))\n", "  (let ([rolling-max-element null]\n         [rolling-max-index\
    \ 0])\n    (cond\n      [(null? numbers) rolling-max-element]\n      [else (loop\
    \ (+ 1 rolling-max-index)\n                   (let ([new-element (first numbers)])\n\
    \                     (if (<= new-element rolling-max-element)\n             \
    \            new-element\n                         (recur (rest numbers)\n   \
    \                                (if (>= rolling-max-index 4)\n              \
    \                         (+ 1 rolling-max-index)\n                          \
    \             rolling-max-index))))))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
