name: HumanEval_156_int_to_mini_roman
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n;; and return it in lowercase.\n;; Restrictions: 1 <= num <= 1000\n\
  ;; Examples:\n;; >>> int_to_mini_roman(19) == 'xix'\n;; >>> int_to_mini_roman(152)\
  \ == 'clii'\n;; >>> int_to_mini_roman(426) == 'cdxxvi'\n(define (int_to_mini_roman\
  \ number)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n\
  \    (check-equal? (candidate 19) \"xix\")\n    (check-equal? (candidate 152) \"\
  clii\")\n    (check-equal? (candidate 251) \"ccli\")\n    (check-equal? (candidate\
  \ 426) \"cdxxvi\")\n    (check-equal? (candidate 500) \"d\")\n    (check-equal?\
  \ (candidate 1) \"i\")\n    (check-equal? (candidate 4) \"iv\")\n    (check-equal?\
  \ (candidate 43) \"xliii\")\n    (check-equal? (candidate 90) \"xc\")\n    (check-equal?\
  \ (candidate 94) \"xciv\")\n    (check-equal? (candidate 532) \"dxxxii\")\n    (check-equal?\
  \ (candidate 900) \"cm\")\n    (check-equal? (candidate 994) \"cmxciv\")\n    (check-equal?\
  \ (candidate 1000) \"m\")\n))\n\n(test-humaneval)"
completions: ["  (define (to_int_map number base map) (map (\u03BB(x) (* base x))\
    \ (cons number map)))\n  (define (roman_map map base num) (if (eq? num (car map))\
    \ (cdr map) (cdr (cdr map))))\n  (define (roman_num_map map base num) (if (eq?\
    \ num (car map)) (cdr map) (cdr (cdr map))))\n  (define (roman_map_map map base\
    \ num)\n    (if (eq? num (car map))\n      (cadr map)\n      (cons (car map) (cons\
    \ (cadr map) (roman_map_map (cadr map) base num)))\n    )\n  )\n  (let ((map '()))\n\
    \    (if (< 1 number)\n        '()\n        (let ((map (cons (car map) (list '()))))\n\
    \          (roman_map (roman_num_map (roman_map map 26 number)) 26 number)\n \
    \       )\n      )\n    )\n  )\n", "  (cond [(> number 0)\n         (string-append\
    \ (string-to-lower (char->string (roman-numeral number)))\n                  \
    \     (string-to-lower (char->string (roman-numeral (- number 1000))))]\n    \
    \    [else\n         (string-to-lower (char->string (roman-numeral (- number 1000))))]))\n",
  "  (define (helper n)\n    (if (= n 0)\n        #t\n        (helper (- n 1))))\n\
    \  (helper (expt number 100)))\n", "  (define (helper num acc)\n    (cond\n  \
    \    [(= num 0) acc]\n      [(< num 1000) (helper (- num (/ num (+ 100 1))) (concat\
    \ acc \"M\"))]\n      [(< num 500) (helper (- num (/ num (+ 500 1))) (concat acc\
    \ \"D\"))]\n      [(< num 100) (helper (- num (/ num (+ 100 1))) (concat acc \"\
    C\"))]\n      [(< num 50) (helper (- num (/ num (+ 50 1))) (concat acc \"L\"))]\n\
    \      [else (helper (- num (/ num 1)) (concat acc \"X\"))]))\n  (helper number\
    \ \"\"))\n  ;; >>> int_to_mini_roman(19)\n  ;; 'xix'\n  ;; >>> int_to_mini_roman(152)\n\
    \  ;; 'clii'\n  ;; >>> int_to_mini_roman(426)\n  ;; 'cdxxvi'\n", "  (let loop\
    \ ((number number) (r ''))\n    (cond\n      [(= number 0) r]\n      [(< number\
    \ 1000) (loop (- number 1) (append r #|m|))]\n      [(< number 100) (loop (- number\
    \ 100) (append r #|c|))]\n      [(< number 10)\n       (loop (- number 10) (append\
    \ r #|v|))]\n      [(< number 1)\n       (loop (- number 1) (append r #|i|))]\n\
    \      [else (loop (- number 10) r)])))\n", "  (cond\n    [(= number 0)\n    \
    \ \"\"]\n    [(< number 1)\n     \"\"]\n    [else\n     (let ((remainder (modulo\
    \ (- number 1)\n                               (string-length \"MCMXC\"))))\n\
    \       (cond\n         [(string-equal? remainder \"I\")\n          (append \"\
    i\" \"v\")]\n         [(string-equal? remainder \"II\")\n          (append \"\
    ii\" \"vi\")]\n         [(string-equal? remainder \"III\")\n          (append\
    \ \"iii\" \"vii\")]\n         [(string-equal? remainder \"IV\")\n          (append\
    \ \"iv\" \"vi\")]\n         [(string-equal? remainder \"V\")\n          (append\
    \ \"v\" \"vi\")]\n         [else\n          (append \"m\" (substring (reverse\
    \ (substring \"MCMXC\" 0 number)\n                                     \"I\"))\n\
    \                   \"x\"\n                  (substring (reverse (substring \"\
    MCMXC\" number 1))\n                           \"I\"))]))]))\n", "  (if (< number\
    \ 1000)\n      (roman_to_mini_roman (- number 1))\n      '?))\n", "  (if (or (>\
    \ number 1)\n          (< number 1000))\n      (error \"Number too large for Roman\
    \ numerals\" number)\n      (cond ((= number 0)\n             (error \"Number\
    \ must be positive\" number))\n            ((even? number)\n             (error\
    \ \"Number must be odd\" number))\n            (else (cond ((> number (floor (/\
    \ number 10)))\n                         (error \"Number too large for Roman numerals\"\
    \ number))\n                      ((< number (floor (* 10 1000))))\n         \
    \             ((= number (floor (* 10 100)))\n                       (cons ' f'\
    \ (int_to_mini_roman number)))\n                      ((= number (floor (* 10\
    \ 10)))\n                       (cons ' d' (int_to_mini_roman number)))\n    \
    \                  ((= number (floor (* 10 1)))\n                       (cons\
    \ ' c' (int_to_mini_roman number)))\n                      ((= number (floor (*\
    \ 10 0)))\n                       (cons ' x' (int_to_mini_roman number)))))))\n",
  "  (let ((roman-numerals '(i v x l c d))\n        (position (- number 1)))\n   \
    \ (cond\n      [(= number 0) \"\"]\n      [(> number 1000) (error \"Number too\
    \ big for int_to_mini_roman\")]\n      [else (cond [(< position 3) (concat roman-numerals\
    \ (int_to_mini_roman position))] [(= position 3) (concat roman-numerals 'i)] [(=\
    \ position 2) (concat roman-numerals 'i)] [(= position 1) (concat roman-numerals\
    \ 'i)]])]))\n", "  (cond [(or (< number 1) (> number 1000)) \"?\"]\n        [(<\
    \ number 100) (string-append \"c\" (int_to_mini_roman 100))]\n        [else (string-append\
    \ \"d\" (int_to_mini_roman 100)\n                                (string-append\
    \ (int_to_mini_roman number - 100) \"i\"))]))\n", "  (cond\n    [(= number 0)\
    \ '']\n    [(< number 1) (if (even? (modulo number 100)) (modulo number 100) (modulo\
    \ number 10))]\n    [else (int_to_mini_roman #(quotient number 100) (+ 1 number))]))\n",
  "  (if (= number 0)\n      'zero\n      (let ([remainder (modulo (- number 1) 1000)])\n\
    \        (cond ((< remainder 10)\n               (string-append '(' (string-append\
    \ 'I (int_to_mini_roman remainder)) ')'))\n              ((< remainder 100)\n\
    \               (string-append 'M (int_to_mini_roman remainder)))))\n      'invalid))\n",
  "  (cond\n    ((< number 0) \"\")\n    ((<= number 1000) (substring 'i 1 number))\n\
    \    ((<= number 5000) (substring 'I 1 number))\n    ((<= number 7500) (substring\
    \ 'II 1 number))\n    ((<= number 10000) (substring 'III 1 number))\n    ((<=\
    \ number 15000) (substring 'IV 1 number))\n    ((<= number 20000) (substring 'V\
    \ 1 number))\n    ((<= number 25000) (substring 'V I 1 number))\n    ((<= number\
    \ 30000) (substring 'VII 1 number))\n    ((<= number 35000) (substring 'VIII 1\
    \ number))\n    ((<= number 40000) (substring 'VIIII 1 number))\n    ((<= number\
    \ 45000) (substring 'IX' 1 number))\n    ((<= number 50000) (substring 'X' 1 number))\n\
    \    ((<= number 55000) (substring 'XI' 1 number))\n    ((<= number 60000) (substring\
    \ 'XII' 1 number))\n    ((<= number 65000) (substring 'XIII' 1 number))\n    ((<=\
    \ number 70000) (substring 'XIV' 1 number))\n    ((<= number 75000) (substring\
    \ 'XV' 1 number))\n    ((<= number 80000) (substring 'XVI' 1 number))\n    ((<=\
    \ number 85000) (substring 'XVII' 1 number))\n    ((<= number 90000) (substring\
    \ 'XVIII' 1 number))\n    ((<= number 95000) (substring 'XIX' 1 number))\n   \
    \ ((<= number 100000) (substring 'X' 2 number))\n    ((<= number 100001) (substring\
    \ 'XX' 2 number))\n    ((<= number 100002) (substring 'XXX' 2 number))\n    ((<=\
    \ number 100003) (substring 'XXXX' 2 number))\n    ((<= number 100004) (substring\
    \ 'XXV' 2 number))\n    ((<= number 100005) (substring 'XXVI' 2 number))\n   \
    \ ((<= number 100006) (substring 'XXVII' 2 number))\n    ((<= number 100007) (substring\
    \ 'XXVIII' 2 number))\n    ((<= number 100008) (substring 'XXIX' 2 number))\n\
    \    ((<= number 100009) (substring 'XX ' 2 number))\n    ((<= number 100010)\
    \ (substring 'XX ' 2 number))\n    ((<= number 1000", "  (cond [(< number 1)\n\
    \         empty]\n        [(< number 1000)\n         (roman_to_int (floor (/ number\
    \ 100)))]\n        [(and (< number 1000) (< number (+ 1 (floor (/ number 100))))\n\
    \             (< (floor (/ number 100)) 50))\n         (roman_to_int\n       \
    \   (+ (floor (/ number 100)) 50))]\n        [else\n         (roman_to_int\n \
    \         (+ (floor (/ number 100)) (* 10 (floor (/ number 100))))]\n      )\n\
    \  )\n", "  (let ([m (/ (- number 1) 100)])\n    (cond\n      [(= m 0)\n     \
    \  (string-append \"M\" (string-append \"C\" (int_to_mini_roman number)))]\n \
    \     [(< m 11)\n       (string-append (sub (- number 1) (+ number 1)) \"Ix\"\
    )]\n      [else\n       (string-append (sub (- number 1) (+ number 1)) \"x\")\n\
    \       (int_to_mini_roman number)]))))\n", "  (cond\n    [(< 1 number)\n    \
    \ (error \"Invalid argument: \" number)]\n    [(< number 1000)\n     (list roman\
    \ number (romanize number))]\n    [else\n     (let ([remainder number\n      \
    \      next (floor (/ number 1000))])\n       (cond\n         [(< next 1000)\n\
    \          (if (= number 0) 'm\n              (list roman number (int_to_mini_roman\
    \ next))))]\n         [(< remainder 1000)\n          (append (int_to_mini_roman\
    \ next) (mini_to_romanize remainder))]\n         [else\n          (append (int_to_mini_roman\
    \ next)\n                  (mini_to_romanize (remainder 1000))]))]))) ; else error\n",
  "  (cond\n    ((< 1 number)\n     'zero)\n    ((< 1000 number)\n     (cond\n   \
    \    ((< number 1000)\n        (cond\n         ((< number 5000)\n          (cond\n\
    \           ((< number 3999)\n            (cond\n             ((< number 4999)\n\
    \              (cond\n               ((< number 6999)\n                (cond\n\
    \                 ((< number 7999)\n                  (cond\n                \
    \   ((< number 9999)\n                   (cond\n                   ((< number\
    \ 99999)\n                   'nine)\n                   ((= number 99999)\n  \
    \                 'one))\n                   ((= number 99999)\n             \
    \      'ten))\n                   ((= number 99999)\n                   'hundred))\n\
    \                   ((= number 99999)\n                   'thousand)))\n     \
    \              ((= number 99999)\n                   'million))\n            \
    \       ((= number 99999)\n                   'billion))\n                   ((=\
    \ number 99999)\n                   'trillion))\n                   ((= number\
    \ 99999)\n                   'quadrillion))\n                   ((= number 99999)\n\
    \                   'quintillion))\n                   ((= number 99999)\n   \
    \                'sextillion))))\n             ((= number 50001)\n           \
    \   (cond\n               ((= number 50011)\n                (cond\n         \
    \        ((= number 50021)\n                  (cond\n                   ((= number\
    \ 50031)\n                    (cond\n                    ((= number 50041)\n \
    \                    (cond\n                     ((= number 50051)\n         \
    \             (cond\n                       ((= number 50061)\n              \
    \          (cond\n                        ((= number 50071)\n                \
    \         (cond\n                         ((= number 50081)\n                \
    \           (cond\n                           ((= number 50091)\n            \
    \               (cond\n                           ((= number 50101)\n        \
    \                   (cond\n                           ((= number 50111)\n    \
    \                       (cond\n                           ((= number 50121)\n\
    \                           (cond\n                           ((= number 50131)\n\
    \                           (cond\n                           ((= number 50141)\n\
    \                           (cond\n                           ((= number 50151)\n\
    \                           (cond\n                           ((= number 50161)\n\
    \                           (cond\n                           ((= number 50171)\n\
    \                           (cond\n                           ((= number 50181)\n\
    \                           (cond\n                           ((= number 50191)\n\
    \                           (cond\n                           ((= ", "  (let loop\
    \ ((x number) (roman '()))\n    (cond ((< x 1000) (append roman x))\n        \
    \  ((< x 900) (append (list (cons x 'I))\n                              roman))\n\
    \          ((< x 500) (append (list (cons x (if (< x 100) 'V 'X))\n          \
    \                    roman))\n          ((< x 400) (append (list (cons x (if (<\
    \ x 100) 'L 'X))\n                              roman))\n          ((< x 100)\
    \ (append (list (cons x (if (< x 100) 'C 'M))\n                              roman))\n\
    \          ((< x 90) (append (list (cons x (if (< x 100) 'D 'M))\n           \
    \                   roman))\n          ((< x 50) (append (list (cons x (if (<\
    \ x 100) 'M 'D))\n                              roman))\n          ((< x 40) (append\
    \ (list (cons x (if (< x 100) 'C 'D))\n                              roman))\n\
    \          ((< x 10) (append (list (cons x (if (< x 100) 'X 'C))\n           \
    \                   roman))\n          ((< x 9) (append (list (cons x (if (< x\
    \ 100) 'X 'M))\n                              roman))\n          ((< x 5) (append\
    \ (list (cons x (if (< x 100) 'X 'D))\n                              roman))\n\
    \          ((< x 4) (append (list (cons x (if (< x 100) 'X 'C))\n            \
    \                  roman))\n          ((< x 1) (append (list (cons x (if (< x\
    \ 100) 'I (if (< x 10) 'V 'X))))\n                              roman)\n     \
    \     ((< x 0) (append (list (cons x (if (< x 100) 'I (if (< x 10) 'V 'X))\n \
    \                             roman))\n          ((= x 0) (return roman))\n  \
    \        ((< x 10) (cdr roman))\n          ((< x 100) (loop (quotient x 100) (cons\
    \ x (if (< x 100) 'I (if (< x 10) 'V 'X))))\n          ((< x 1000) (loop (quotient\
    \ x 1000) (cons x (if (< x 100) 'I (if (< x 10) 'V 'X))))\n          (else (loop\
    \ (quoti", "  (let loop ((number number)\n             (romans ((lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (lambda (z) (cons z (lambda (w) (cons w (lambda (x) (cons\
    \ x (lambda (y) (cons y (", "  (cond [(< number 1000) (string-append \"M\" (string-append\
    \ (modulo-divide-remainder number 1000 'M) (modulo-divide-remainder 'I 10 'M)))]\n\
    \        [(= number 100) (cons 'I 'M)]\n        [else (cons 'I (int_to_mini_roman\
    \ number))]))\n", "  (if (positive? number)\n      (let ((digits (make-array (floor\
    \ (/ number 100)) #:initial-contents (make-array (floor (/ number 100)) #:element-type\
    \ 'string))))\n        (roman-numeral->string digits number)\n        (apply string-join\
    \ digits))\n      '?))\n", "  (if (< number 1000)\n      (roman-to-int (mini-roman-to-int\
    \ number))\n      (error \"int_to_mini_roman: non-positive number ~d\" (- number\
    \ 1000)))\n  (string-append \"i\" (int_to_roman_string number)))\n", "  (let roman\
    \ ((count 0) (roman-map '() '()))\n    (cond [(number< 1 0)\n           (error\
    \ \"Invalid input number: \" number)]\n          [(number< 1 1000)\n         \
    \  (error \"Invalid input number: \" number)]\n          [(= (mod number 100)\
    \ 0)\n           (roman (+ count 1) (append roman-map (list 'i) (list 'x)))]\n\
    \          [else\n           (roman (+ count 1) (append roman-map (list 'i) \n\
    \                                                (int_to_mini_roman \n       \
    \                                           (/ number 100))))]\n          [roman\
    \ (+ count 1) (append roman-map (list 'v) \n                                 \
    \      (int_to_mini_roman \n                                        (/ (- number\
    \ 100) 100)))]\n          [roman (+ count 1) (append roman-map (list 'x) (int_to_mini_roman\
    \ \n                                                  (/ (- number 100) 10)))]\n\
    \          [roman (+ count 1) (append roman-map (list 'l) (int_to_mini_roman \n\
    \                                                  (/ (- number 100) 1)))]\n \
    \         [roman (+ count 1) (append roman-map (list 'c) (int_to_mini_roman \n\
    \                                                  (/ number 1)))]\n         \
    \ [roman (+ count 1) (append roman-map (list 'd) (int_to_mini_roman \n       \
    \                                           (/ (- number 100) 10)))]\n       \
    \   [roman (+ count 1) (append roman-map (list 'm) (int_to_mini_roman \n     \
    \                                             (/ number 10)))]\n          [roman\
    \ (+ count 1) (append roman-map (list 'v) (int_to_mini_roman \n              \
    \                                    (/ number 1)))]\n          [roman (+ count\
    \ 1) (append roman-map (list 'm) (int_to_mini_roman \n                       \
    \                           (/ (- number 100) 10)))]\n          [roman (+ count\
    \ 1) (append roman-map (list 'x) (int_to_mini_roman \n                       \
    \                           (/ (- number 100) 1)))]\n          [roman (+ count\
    \ 1) (append roman-map (list 'l) (int_to_mini_roman \n                       \
    \                           (/ (- number 100) 10)))]\n          [roman (+ count\
    \ 1) (append roman-map (list 'x) (int_to_mini_", "  (define (helper num remainder\
    \ result)\n    (cond ((= num 0) result) (helper (- num 1) (- remainder 1) (cons\
    \ (char result number) result)))\n    (helper (- num 1) remainder (cons (char\
    \ result number) result)))\n  (helper number 0 '()))\n", "  (if (< number 1000)\n\
    \      (if (< number 900)\n          (if (< number 500) \n              (cons\
    \ 'i \n                    (int_to_mini_roman (- number 1)))\n              (cons\
    \ 'x \n                    (int_to_mini_roman (- number 9)))\n              (int_to_mini_roman\
    \ (- number 49)))\n          (if (< number 400) \n              (cons 'c \n  \
    \                  (int_to_mini_roman (- number 1)))\n              (cons 'l \n\
    \                    (int_to_mini_roman (- number 4)))\n              (int_to_mini_roman\
    \ (- number 40))))\n      (if (< number 900)\n          (if (< number 500) \n\
    \              (cons 'v \n                    (int_to_mini_roman (- number 1)))\n\
    \              (cons 'l \n                    (int_to_mini_roman (- number 9)))\n\
    \              (int_to_mini_roman (- number 49)))\n          (if (< number 400)\
    \ \n              (cons 'c \n                    (int_to_mini_roman (- number\
    \ 1)))\n              (cons 'l \n                    (int_to_mini_roman (- number\
    \ 4)))\n              (int_to_mini_roman (- number 40))))\n      (if (< number\
    \ 900)\n          (if (< number 500) \n              (cons 'i \n             \
    \       (int_to_mini_roman (- number 1)))\n              (cons 'x \n         \
    \           (int_to_mini_roman (- number 9)))\n              (int_to_mini_roman\
    \ (- number 49)))\n          (if (< number 400) \n              (cons 'c \n  \
    \                  (int_to_mini_roman (- number 1)))\n              (cons 'l \n\
    \                    (int_to_mini_roman (- number 4)))\n              (int_to_mini_roman\
    \ (- number 40))))\n      (if (< number 900)\n          (if (< number 500) \n\
    \              (cons 'v \n                    (int_to_mini_roman (- number 1)))\n\
    \              (cons 'l \n                    (int_to_mini_roman (- number 9)))\n\
    \              (int_to_mini_roman (- number 49)))\n          (if (< number 400)\
    \ \n              (cons 'c \n                    (int_to_mini_roman (- number\
    \ 1)))\n              (cons 'l \n                    (int_to_mini_roman (- number\
    \ 4)))\n              (int_to_mini_roman (- number 40))))\n      (if (< number\
    \ 900)", "  (cond [(= number 1) 'x]\n        [(= (mod number 4) 0) 'c]\n     \
    \   [(= (mod number 10) 0) 'l]\n        [(= (mod number 100) 0) 'i]\n        [else\
    \ 'm]))\n", "  (let* ((a (big-mod number 1000))\n         (b (/ number 1000))\n\
    \         (c (modulo number 1000))\n         (d (quotient b 100)))\n    (cond\n\
    \      [(equal? a 0) 'm']\n      [(equal? a 1) 'd']\n      [(equal? c 0) 'c']\n\
    \      [(equal? c 1) 'l']\n      [(equal? c 2) 'xl']\n      [(equal? c 3) or 'xc']\n\
    \      [(equal? c 4) or 'cd']\n      [(equal? c 5) or 'cl']\n      [(equal? c\
    \ 6) or 'xlc']\n      [(equal? c 7) or 'xld']\n      [(equal? c 8) or 'cxl']\n\
    \      [(equal? c 9) or 'ccx']\n      [(equal? c 10) or 'cdl']\n      [(equal?\
    \ c 11) or 'cld']\n      [(equal? c 12) or 'xlc']\n      [(equal? c 13) or 'xld']\n\
    \      [(equal? c 14) or 'cxl']\n      [(equal? c 15) or 'ccx']\n      [(equal?\
    \ c 16) or 'cdl']\n      [(equal? c 17) or 'cld']\n      [(equal? c 18) or 'xlc']\n\
    \      [(equal? c 19) or 'xld']\n      [(equal? c 20) or 'cxl']\n      [(equal?\
    \ c 21) or 'ccx']\n      [(equal? c 22) or 'cdl']\n      [(equal? c 23) or 'cld']\n\
    \      [(equal? c 24) or 'xlc']\n      [(equal? c 25) or 'xld']\n      [(equal?\
    \ c 26) or 'cxl']\n      [(equal? c 27) or 'ccx']\n      [(equal? c 28) or 'cdl']\n\
    \      [(equal? c 29) or 'cld']\n      [(equal? c 30) or 'xlc']\n      [(equal?\
    \ c 31) or 'xld']\n      [(equal? c 32) or 'cxl']\n      [(equal? c 33) or 'ccx']\n\
    \      [(equal? c 34) or 'cdl']\n      [(equal? c 35) or 'cld']\n      [(equal?\
    \ c 36) or 'xlc']\n      [(equal? c 37) or 'xld']\n      [(equal? c 38) or 'c",
  "  (cond [(< number 1000) (append \"M\"\n                             ((int_to_mini_roman\
    \ floor (- number 1000)) \n                              (int_to_mini_roman floor\
    \ (/ number 1000)))\n                           )\n         ]\n        [(< number\
    \ 5000) (append \"CM\"\n                               ((int_to_mini_roman floor\
    \ (/ number 100)) \n                                (int_to_mini_roman floor (-\
    \ number (- 100 number)))\n                               )\n                \
    \           )\n         ]\n        [(< number 10000) (append \"D\"\n         \
    \                      ((int_to_mini_roman floor (/ number 10)) \n           \
    \                     (int_to_mini_roman floor (- number (- 10 number)))\n   \
    \                            )\n                           )\n         ]\n   \
    \     [(< number 20000) (append \"CD\"\n                               ((int_to_mini_roman\
    \ floor (/ number 100)) \n                                (int_to_mini_roman floor\
    \ (/ number 10)) \n                                (int_to_mini_roman floor (-\
    \ number (- 100 number)))\n                               )\n                \
    \           )\n         ]\n        [(< number 40000) (append \"C\"\n         \
    \                      ((int_to_mini_roman floor (/ number 10)) \n           \
    \                     (int_to_mini_roman floor (/ number 100)) \n            \
    \                    (int_to_mini_roman floor (- number (- 10 number)))\n    \
    \                           )\n                           )\n         ]\n    \
    \    [else (append \"M\"\n                       ((int_to_mini_roman floor (/\
    \ number 1000))\n                        (int_to_mini_roman floor (/ number 100))\
    \ \n                        (int_to_mini_roman floor (/ number 10)) \n       \
    \                 (int_to_mini_roman floor (/ number 1)) \n                  \
    \     )\n                      )\n         ]\n        )\n)\n", "  (cond [(< number\
    \ 1000) (int_to_mini_roman 1000) (int_to_mini_roman number)\n         (string-append\
    \ (int_to_roman_char number) (int_to_mini_roman 1000))])\n  (if (< number 1000)\n\
    \      (int_to_mini_roman number)\n      (int_to_mini_roman 1000) (int_to_mini_roman\
    \ 1000)))\n\f", "  (define (roman-digit digit)\n    (cond [(= 0 digit) (char #\\\
    0)]\n          [(= 1 digit) (char #\\a)]\n          [(= 2 digit) (char #\\b)]\n\
    \          [(= 3 digit) (char #\\c)]\n          [(= 4 digit) (char #\\d)]\n  \
    \        [(= 5 digit) (char #\\e)]\n          [(= 6 digit) (char #\\f)]\n    \
    \      [(= 7 digit) (char #\\g)]\n          [(= 8 digit) (char #\\h)]\n      \
    \    [(= 9 digit) (char #\\i)]\n          [(= 10 digit) (char #\\j)]\n       \
    \   [(= 11 digit) (char #\\k)]\n          [(= 12 digit) (char #\\l)]\n       \
    \   [(= 13 digit) (char #\\m)]\n          [(= 14 digit) (char #\\n)]\n       \
    \   [(= 15 digit) (char #\\o)]\n          [(= 16 digit) (char #\\p)]\n       \
    \   [(= 17 digit) (char #\\q)]\n          [(= 18 digit) (char #\\r)]\n       \
    \   [(= 19 digit) (char #\\s)]\n          [(= 20 digit) (char #\\t)]\n       \
    \   [(= 21 digit) (char #\\v)]\n          [(= 22 digit) (char #\\w)]\n       \
    \   [(= 23 digit) (char #\\x)]\n          [(= 24 digit) (char #\\y)]\n       \
    \   [(= 25 digit) (char #\\z)]\n          [(= 26 digit) (char #\\A)]\n       \
    \   [(= 27 digit) (char #\\B)]\n          [(= 28 digit) (char #\\C)]\n       \
    \   [(= 29 digit) (char #\\D)]\n          [(= 30 digit) (char #\\E)]\n       \
    \   [(= 31 digit) (char #\\F)]\n          [(= 32 digit) (char #\\G)]\n       \
    \   [(= 33 digit) (char #\\H)]\n          [(= 34 digit) (char #\\I)]\n       \
    \   [(= 35 digit) (char #\\J)]\n          [(= 36 digit) (char #\\K)]\n       \
    \   [(= 37 digit) (char #\\L)]\n          [(= 38 digit) (char #\\M)]\n       \
    \   [(= 39 digit) (char #\\N)]\n          [(= 40 digit) (char #\\O)]\n       \
    \   [(= 41 digit) (char #\\P", "  (define (helper number acc)\n    (cond\n   \
    \   [(= number 0) acc]\n      [(= (mod number 100) 0) (helper (sub1 number) acc\
    \ (append 'M (int_to_mini_roman (/ number 100))))]\n      [(= (mod number 10)\
    \ 0) (helper (sub1 number) acc (append 'I (int_to_mini_roman (/ number 10))))]\n\
    \      [(= number 1) (helper (sub1 number) acc (append 'V (int_to_mini_roman (/\
    \ number 100))))]\n      [(= (mod number 5) 0) (helper (sub1 number) acc (append\
    \ 'L (int_to_mini_roman (/ number 10))))]\n      [(= number 2) (helper (sub1 number)\
    \ acc (append 'C (int_to_mini_roman (/ number 100))))]\n      [(= (mod number\
    \ 4) 0) (helper (sub1 number) acc (append 'D (int_to_mini_roman (/ number 10))))]\n\
    \      [(= number 3) (helper (sub1 number) acc (append 'M (int_to_mini_roman (/\
    \ number 100))))]\n      [(= (mod number 3) 0) (helper (sub1 number) acc (append\
    \ 'I (int_to_mini_roman (/ number 10))))]\n      [(= number 4) (helper (sub1 number)\
    \ acc (append 'V (int_to_mini_roman (/ number 100))))]\n      [(= (mod number\
    \ 5) 0) (helper (sub1 number) acc (append 'L (int_to_mini_roman (/ number 10))))]\n\
    \      [(= number 6) (helper (sub1 number) acc (append 'C (int_to_mini_roman (/\
    \ number 100))))]\n      [(= (mod number 4) 0) (helper (sub1 number) acc (append\
    \ 'D (int_to_mini_roman (/ number 10))))]\n      [(= number 7) (helper (sub1 number)\
    \ acc (append 'M (int_to_mini_roman (/ number 100))))]\n      [(= (mod number\
    \ 3) 0) (helper (sub1 number) acc (append 'I (int_to_mini_roman (/ number 10))))]\n\
    \      [(= number 8) (helper (sub1 number) acc (append 'V (int_to_mini_roman (/\
    \ number 100))))]\n      [(= (mod number 5) 0) (helper (sub1 number) acc (append\
    \ '", "  (cond\n    [(= number 0) 'zero']\n    [(< number 1000) (int_to_mini_roman\
    \ number)]\n    [(>= number 1000) (int_to_mini_roman number 1000)]\n    [else\
    \ (make-string 3 #\\0 '())]\n    [(>= number 4000)\n     (string-append\n    \
    \  (string-append\n       (string-append\n        (string-append\n         (string-append\n\
    \          (string-append\n           (string-append\n            (string-append\n\
    \             (string-append\n              (make-string (- number (floor (/ number\
    \ 4000)))\n                           #\\0 '())\n             #\\0 '())\n    \
    \       #\\0 '())\n         #\\0 '())\n       #\\0 '())\n     (make-string 3 (string->list\
    \ (substring 'IV number (floor number 4000))))]\n    [(>= number 4000) (string-append\n\
    \     (string-append\n      (make-string 3 #\\0 '())\n      (string->list (substring\
    \ 'I number (floor (+ number (floor number 4000)))))]\n    [else (string-append\n\
    \     (make-string 3 #\\0 '())\n     (string->list (substring 'V number (floor\
    \ (+ number (floor number 4000)))))]\n    [(>= number 4000) (string-append\n \
    \    (string-append\n      (make-string 3 #\\0 '())\n      (string->list (substring\
    \ 'X number (floor (+ number (floor number 4000)))))]\n    [else (string-append\n\
    \     (make-string 3 #\\0 '())\n     (string->list (substring 'I number (floor\
    \ (+ number (floor number 4000)))))]\n    [(>= number 4000) (string-append\n \
    \    (make-string 3 #\\0 '())\n     (string->list (substring 'I number (floor\
    \ (+ number (floor number 4000)))))]\n    [else (string-append\n     (make-string\
    \ 3 #\\0 '())\n     (string->list (substring 'I number (floor (+ number (floor\
    \ number 4000)))))]\n    [(>= number 4000) (string-append\n     (make-string 3\
    \ #\\0 '())\n     (string->list (substring 'I number (floor (+ number (floor number\
    \ 4000)))))]\n    [else (string-append\n     (make-string 3 #\\0 '())\n     (string->list\
    \ (substring 'I number (floor (+ number (floor number 4000)))))]\n    [(>= number\
    \ 4000) (string-append\n     (make-string 3 #\\0 '())\n     (string", "  (define\
    \ (helper n acc)\n    (cond ((> n 1000) (helper (- n 1000) acc))\n          ((<\
    \ n 1) (cons n (append acc (list n))))\n          (else (helper (- n 1) (cons\
    \ n (list n)))\n            (helper (- n 1) acc))))\n  (helper number '()))\n",
  "  (cond\n    [(= number 1) 'x]\n    [(= number 3) 'cx]\n    [(= number 5) 'lx]\n\
    \    [(= number 7) 'xl]\n    [(= number 9) 'xc]\n    [(= number 11) 'ix]\n   \
    \ [(= number 13) 'lc]\n    [(= number 17) 'xlc]\n    [(= number 19) 'xix]\n  \
    \  [(= number 21) 'ixl]\n    [(= number 23) 'ilc]\n    [(= number 25) 'ixxl]\n\
    \    [(= number 27) 'ixlc]\n    [else (int_to_mini_roman number)])\n)\n", "  (if\
    \ (< number 1000)\n      (let ((i (mod number 100)))\n        (roman-to-mini i\
    \ \"IV\"))\n      (let ((i1 (mod number 1000)))\n        (roman-to-mini i1 \"\
    V\"))\n      (let ((i2 (mod number 1000)))\n        (roman-to-mini i2 \"I\"))\n\
    \      (let ((i3 (mod number 1000)))\n        (roman-to-mini i3 \"X\"))))\n",
  "  (roman_numerals number (lambda (roman letter) (cond [(< roman 'M) (cons letter\
    \ roman)]\n                                                   [(< roman 'MM) (cons\
    \ letter roman)]\n                                                   [(< roman\
    \ 'MMM) (cons letter roman)]\n                                               \
    \    [(< roman 'MMMM) (cons letter roman)]\n                                 \
    \                  [(< roman 'MMMMM) (cons letter roman)]\n                  \
    \                                 [(< roman 'MMMMMMM) (cons letter roman)]\n \
    \                                                  [(< roman 'MMMMMMMM) (cons\
    \ letter roman)]\n                                                   [(< roman\
    \ 'MMMMMMMMM) (cons letter roman)]\n                                         \
    \          [(< roman 'MMMMMMMMMMM) (cons letter roman)]\n                    \
    \                               [(< roman 'MMMMMMMMMMMM) (cons letter roman)]\n\
    \                                                   [(< roman 'MMMMMMMMMMMMM)\
    \ (cons letter roman)]\n                                                   [(<\
    \ roman 'MMMMMMMMMMMMMMM) (cons letter roman)]\n                             \
    \                      [(< roman 'MMMMMMMMMMMMMMMM) (cons letter roman)]\n   \
    \                                                [(< roman 'MMMMMMMMMMMMMMMMM)\
    \ (cons letter roman)]\n                                                   [(<\
    \ roman 'MMMMMMMMMMMMMMMMMMM) (cons letter roman)]\n                         \
    \                          [(< roman 'MMMMMMMMMMMMMMMMMMMM) (cons letter roman)]\n\
    \                                                   [(< roman 'MMMMMMMMMMMMMMMMMMMMM)\
    \ (cons letter roman)]\n                                                   [(<\
    \ roman 'MMMMMMMMMMMMMMMMMMMMMMM) (cons letter roman)]\n                     \
    \                              [(< roman 'MMMMMMMMMMMMMMMMMMMMMMMM) (cons letter\
    \ roman)]\n                                                   [(< roman 'MMMMMMMMMMMMMMMMMMMMMMMMM)\
    \ (cons letter roman)]\n                                                   [(<\
    \ roman 'MMMMMMMMMMMMMMMMMMMMMMMMMMM) (cons letter roman)]\n                 \
    \                                  [(< roman 'MMMMMMMMMMMMMMMMMMMMMMMMMMMM) (cons\
    \ letter roman)]\n                                                   [(< roman\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMM) (cons letter roman)]\n                     \
    \                              [(< roman 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM) (cons\
    \ letter roman)]\n                                                   [(< roman\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM) (cons letter roman)]\n                  \
    \                                 [(< roman 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM)\
    \ (cons letter roman)]\n                                                   [(<\
    \ roman 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM) (", "  (let romans '(\n        \
    \ ((IX X CL LX) (10) (1 7) (1 9) (1 11) (1 13) (1 15) (1 17) (1 19) (1 21) (1\
    \ 23) (1 25) (1 27) (1 29) (1 31))\n         ((IV X CD DL) (10) (2 7) (2 9) (2\
    \ 11) (2 13) (2 15) (2 17) (2 19) (2 21) (2 23) (2 25) (2 27) (2 29) (2 31))\n\
    \         ((III X CM ML) (10) (3 7) (3 9) (3 11) (3 13) (3 15) (3 17) (3 19) (3\
    \ 21) (3 23) (3 25) (3 27) (3 29) (3 31))\n         ((IIX X CA AL) (10) (4 7)\
    \ (4 9) (4 11) (4 13) (4 15) (4 17) (4 19) (4 21) (4 23) (4 25) (4 27) (4 29)\
    \ (4 31))\n         ((IX X CB BL) (10) (5 7) (5 9) (5 11) (5 13) (5 15) (5 17)\
    \ (5 19) (5 21) (5 23) (5 25) (5 27) (5 29) (5 31))\n         ((II X CC CL) (10)\
    \ (6 7) (6 9) (6 11) (6 13) (6 15) (6 17) (6 19) (6 21) (6 23) (6 25) (6 27) (6\
    \ 29) (6 31))\n         ((IX X CD DL) (10) (7 7) (7 9) (7 11) (7 13) (7 15) (7\
    \ 17) (7 19) (7 21) (7 23) (7 25) (7 27) (7 29) (7 31))\n         ((II X CE CL)\
    \ (10) (8 7) (8 9) (8 11) (8 13) (8 15) (8 17) (8 19) (8 21) (8 23) (8 25) (8\
    \ 27) (8 29) (8 31))\n         ((IX X CF DL) (10) (9 7) (9 9) (9 11) (9 13) (9\
    \ 15) (9 17) (9 19) (9 21) (9 23) (9 25) (9 27) (9 29) (9 31))\n         ((II\
    \ X CG CL) (10) (10 7) (10 9) (10 11) (10 13) (10 15) (10 17) (10 19) (10 21)\
    \ (", "  (cond\n    [(< number 1)\n     (error \"Argument must be positive\")\n\
    \     (empty-string)]\n    [else\n     (string-append (string-to-lower (number->string\
    \ number)) \n\t\t     (make-string-roman number \n\t\t\t\t      (string-append\
    \ \"i\" \n\t\t\t\t\t\t    (string-to-lower (substring (- (length number) \n\t\t\
    \t\t\t\t\t\t\t\t\t\t   number 1))))\n\t\t\t\t      (string-to-lower (substring\
    \ (- (length number) \n\t\t\t\t\t\t\t\t\t\t\t\t   number 2)))))]))\n", "  (if\
    \ (> number 1)\n      (string-append (int_to_mini_roman floor (/ number 10))\n\
    \                     (int_to_mini_roman ceiling (% number 10))\n            \
    \         (string->lower (int_to_mini_roman number)))\n      \"\"))\n", "  (cond\n\
    \    [(< number 1) '']\n    [else (loop\n             [minus '']\n           \
    \  [num '0']\n             [roman '']\n             (+ roman 1)\n            \
    \ (cond\n               [(= (modulo number 100) 0)\n                (append 'c\
    \ (int_to_mini_roman number))]\n               [(= (modulo number 10) 0)\n   \
    \             (append 'i (int_to_mini_roman number))]\n               [(= (modulo\
    \ number 5) 0)\n                (append 'v (int_to_mini_roman number))]\n    \
    \           [(= (modulo number 1) 0)\n                (append 'x (int_to_mini_roman\
    \ number))]\n               [(= (modulo number 1) 1)\n                (append\
    \ 'x (int_to_mini_roman number))]\n               [(< number 100)\n          \
    \      (append 'm (int_to_mini_roman number))]\n               [(< number 10)\n\
    \                (append 'l (int_to_mini_roman number))]\n               [(< number\
    \ 5)\n                (append 'c (int_to_mini_roman number))]\n              \
    \ [(< number 1)\n                (append 'x (int_to_mini_roman number))]))]))\n",
  "  (let ((table (make-array 1001 :initial-contents '()))\n        (values (make-array\
    \ 1000 :initial-contents 0))\n        (average (/ (reduce + (map count (list-ref\
    \ (array-set values 0 1) (array-set values 0 0))) values) (length values)))\n\
    \        (left (/ (- average 100) 10))\n        (right (/ (- average 100) 10)))\n\
    \    (loop for i from 0 to ((- number 100) downto 1) do\n          (let* ((val\
    \ (list-ref (array-set values 0 (+ i (* 10 (length values))))) (val-count (array-get\
    \ values i 0))\n                 (idx (+ i (* 10 left)))\n                 (next\
    \ (+ i (* 10 right)))\n                 (temp (+ val-count (* 10 idx)))\n    \
    \             (temp2 (+ val-count (* 10 next))))\n            (set! values (array-set\
    \ values i (+ val-count (* 10 idx))) (+ val-count (* 10 next))) (set! average\
    \ (+ average temp))\n            (set! values (array-set values i (+ val-count\
    \ (* 10 next))) (+ val-count (* 10 idx)))\n            (set! left (- average temp))\n\
    \            (set! values (array-set values i (+ val-count (* 10 idx))) (+ val-count\
    \ (* 10 next))) (set! right (+ average temp2)))\n            (inc! val) (dec!\
    \ val-count))))\n    (string->list values))\n", "  (cond\n    ((= number 1) 'one)\n\
    \    ((= number 2) 'two)\n    ((= number 3) 'three)\n    ((= number 4) 'four)\n\
    \    ((= number 5) 'five)\n    ((= number 6) 'six)\n    ((= number 7) 'seven)\n\
    \    ((= number 8) 'eight)\n    ((= number 9) 'nine)\n    ((= number 10) 'ten)\n\
    \    ((= number 11) 'eleven)\n    ((= number 12) 'twelve)\n    ((= number 13)\
    \ 'thirteen)\n    ((= number 14) 'fourteen)\n    ((= number 15) 'fifteen)\n  \
    \  ((= number 16) 'sixteen)\n    ((= number 17) 'seventeen)\n    ((= number 18)\
    \ 'eighteen)\n    ((= number 19) 'nineteen)\n    ((= number 20) 'twenty)\n   \
    \ ((= number 21) 'twenty one)\n    ((= number 22) 'twenty two)\n    ((= number\
    \ 23) 'twenty three)\n    ((= number 24) 'twenty four)\n    ((= number 25) 'twenty\
    \ five)\n    ((= number 26) 'twenty six)\n    ((= number 27) 'twenty seven)\n\
    \    ((= number 28) 'twenty eight)\n    ((= number 29) 'twenty nine)\n    ((=\
    \ number 30) 'thirty)\n    ((= number 31) 'thirty one)\n    ((= number 32) 'thirty\
    \ two)\n    ((= number 33) 'thirty three)\n    ((= number 34) 'thirty four)\n\
    \    ((= number 35) 'thirty five)\n    ((= number 36) 'thirty six)\n    ((= number\
    \ 37) 'thirty seven)\n    ((= number 38) 'thirty eight)\n    ((= number 39) 'thirty\
    \ nine)\n    ((= number 40) 'forty)\n    ((= number 41) 'forty one)\n    ((= number\
    \ 42) 'forty two)\n    ((= number 43) 'forty three)\n    ((= number 44) 'forty\
    \ four)\n    ((= number 45) 'forty five)\n    ((= number 46) 'forty six)\n   \
    \ ((= number 47) 'forty seven)\n    ((= number 48) '", "  (cond\n    [(= number\
    \ 0) '0]\n    [(= number 1) 'i]\n    [(= number 2) 'vi]\n    [(= number 3) 'vii]\n\
    \    [(= number 4) 'viii]\n    [(= number 5) 'viiii]\n    [(= number 6) 'viiiii]\n\
    \    [(= number 7) 'viiiiii]\n    [(= number 8) 'viiiiiii]\n    [(= number 9)\
    \ 'viiiiiiii]\n    [(= number 10) 'viiiiiiiii]\n    [(= number 11) 'viiiiiiiiii]\n\
    \    [(= number 12) 'viiiiiiiiiii]\n    [(= number 13) 'viiiiiiiiiiii]\n    [(=\
    \ number 14) 'viiiiiiiiiiiii]\n    [(= number 15) 'viiiiiiiiiiiiii]\n    [(= number\
    \ 16) 'viiiiiiiiiiiiiii]\n    [(= number 17) 'viiiiiiiiiiiiiiii]\n    [(= number\
    \ 18) 'viiiiiiiiiiiiiiiii]\n    [(= number 19) 'viiiiiiiiiiiiiiiiii]\n    [(=\
    \ number 20) 'viiiiiiiiiiiiiiiiiii]\n    [(= number 21) 'viiiiiiiiiiiiiiiiiiii]\n\
    \    [(= number 22) 'viiiiiiiiiiiiiiiiiiiii]\n    [(= number 23) 'viiiiiiiiiiiiiiiiiiiiii]\n\
    \    [(= number 24) 'viiiiiiiiiiiiiiiiiiiiiii]\n    [(= number 25) 'viiiiiiiiiiiiiiiiiiiiiiii]\n\
    \    [(= number 26) 'viiiiiiiiiiiiiiiiiiiiiiiii]\n    [(= number 27) 'viiiiiiiiiiiiiiiiiiiiiiiii]\n\
    \    [(= number 28) 'viiiiiiiiiiiiiiiiiiiiiiiiiii]\n    [(= number 29) 'viiiiiiiiiiiiiiiiiiiiiiiiiiiii]\n\
    \    [(= number 30) 'viiiiiiiiiiiiiiiiiiiiiiiiiiiiiii]\n    [(= number 31) 'viiiiiiiiiii",
  "  (cond\n    [(< number 1) '']\n    [(< number 1000) (cons number '')]\n    [else\
    \ (cons ((roman-numeral number) '-') (int_to_mini_roman number))]))\n", "  (cond\n\
    \    [(= number 0) \"\"]\n    [(< number 1000) (string-append \"C\" (int_to_mini_roman\
    \ number))\n     (cond\n\t[(= (modulo number 100) 0)\n\t  (string-append \"M\"\
    \ (int_to_mini_roman number))\n\t  (string-append \"D\" (int_to_mini_roman number))\n\
    \t  (string-append \"C\" (int_to_mini_roman number))]\n\t[(= (modulo number 10)\
    \ 0)\n\t  (string-append \"L\" (int_to_mini_roman number))\n\t  (string-append\
    \ \"X\" (int_to_mini_roman number))]\n\t[(= (modulo number 5) 0)\n\t  (string-append\
    \ \"V\" (int_to_mini_roman number))\n\t  (string-append \"I\" (int_to_mini_roman\
    \ number))]\n\t[(= (modulo number 1) 0)\n\t  (string-append \"I\" (int_to_mini_roman\
    \ number))]\n\t[(> number 1000) (error \"int_to_mini_roman: number too large for\
    \ roman numeral\")]\n\t[else (error \"int_to_mini_roman: unhandled case: \" number)]])]\n\
    \    [else (string-append \"II\" (int_to_mini_roman number))]))\n", "  (if (<\
    \ number 1000)\n      (if (< number 900)\n          (roman-numeral (- number 901))\n\
    \          (roman-numeral (- number 900)))\n      (if (< number 400)\n       \
    \   (roman-numeral (- number 499))\n          (roman-numeral (- number 400))))\n\
    \  number)\n", "  (define (roman-rom-map roman)\n    (cond ((= roman '') \"\"\
    )\n          ((< roman 'a) \"\")\n          ((= roman 'i) (roman-rom-map 'roman\
    \ (sub1 roman)))\n          ((= roman 'o) (roman-rom-map 'roman (sub1 roman)))\n\
    \          ((= roman 'u) (roman-rom-map 'roman (add1 roman)))\n          ((= roman\
    \ 'n) (roman-rom-map 'roman (sub1 roman)))\n          ((= roman 'p) (roman-rom-map\
    \ 'roman (add1 roman)))\n          ((= roman 'm) (roman-rom-map 'roman (add1 roman)))\n\
    \          ((= roman 'v) (roman-rom-map 'roman (add1 roman)))\n          ((= roman\
    \ 'l) (roman-rom-map 'roman (add1 roman)))\n          ((= roman 'c) (roman-rom-map\
    \ 'roman (sub1 roman)))\n          ((= roman 'd) (roman-rom-map 'roman (add1 roman)))))\n\
    \  (let ((result (make-array (+ 1 (expt number 4)) #f)))\n    (roman-rom-map 'roman\
    \ 'm)\n    (roman-rom-map 'roman 'd)\n    (roman-rom-map 'roman 'l)\n    (roman-rom-map\
    \ 'roman 'v)\n    (roman-rom-map 'roman 'c)\n    (roman-rom-map 'roman 'o)\n \
    \   (roman-rom-map 'roman 'u)\n    (roman-rom-map 'roman 'n)\n    (roman-rom-map\
    \ 'roman 'p)\n    (roman-rom-map 'roman 'i)\n    (roman-rom-map 'roman 'm)\n \
    \   (array-set! result 0 (string-append 'x (string-to-char (expt number 2))))\n\
    \    (array-set! result 1 (string-append 'xi (string-to-char (expt number 2)))\n\
    \                      (sub1 result))\n    (array-set! result 2 (string-append\
    \ 'xix (string-to-char (expt number 2)))\n                      (sub1 ", "  (cond\n\
    \    [(< 1 number) \"\"]\n    [(< 1000 number) \"\"]\n    [else (make-string 2\
    \ \"#f\")\n         (cond [(< 0 number) (string-append \"0\" \"#f\")]\n      \
    \         [else (string-append (roman_numeral number)\n                      \
    \             (string-downcase (int_to_mini_roman (-number))))]))]))\n", "  (cond\
    \ [(< number 1)\n         (string-append \"I\" (int_to_mini_roman number) (string-downcase\
    \ number))\n         (else\n          (let ([remainder (remainder number 1000)])\n\
    \            (cond [(> remainder 100)\n                   (string-append \"M\"\
    \ (int_to_mini_roman remainder) (string-downcase number))\n                  \
    \ (else\n                    (remainder\n                     (int_to_mini_roman\
    \ remainder)\n                     (string-append (string-downcase (remainder\
    \ 1000) number))))])\n         (string-append \"X\" (int_to_mini_roman number)\
    \ (string-downcase number))])\n  )\n", "  (cond\n    [(< number 1) '']\n    [(<\
    \ number 4) (string-append \"m\" (int_to_mini_roman number))] \n    [(< number\
    \ 100) (string-append \"cm\" (int_to_mini_roman number))] \n    [(< number 400)\
    \ (string-append \"d\" (int_to_mini_roman number))] \n    [(< number 1000) (string-append\
    \ \"cd\" (int_to_mini_roman number))] \n    [else (string-append \"c\" (int_to_mini_roman\
    \ number))]))\n", "  (if (= number 1)\n      'i\n      (if (= (mod number 10)\
    \ 0)\n          '(int_to_mini_roman 10)\n          '(int_to_mini_roman 10) (+\
    \ number (- number (mod number 10))))))\n", "  (define (helper n result)\n   \
    \ (cond [(= n 0) (cons result '())]\n          [(< n 0)\n           (if (< result\
    \ '())\n               (helper (- n 1) (cons result '()))\n               (helper\
    \ (- n 1) result))]))\n  (helper (quotient number 10000) ''))\n", "  (let* ((f\
    \ (floor (/ number 1000)))\n         (i (mod (/ number 100) 10))\n         (j\
    \ (quotient number 10))\n         (k (quotient j 10)))\n    (if (= i 0)\n    \
    \    (if (= j 0)\n            (mini_roman f k)\n            (mini_roman f k j)\n\
    \            (mini_roman f i j))\n        (if (= k 0)\n            (mini_roman\
    \ f i)\n            (mini_roman f i j)\n            (mini_roman f i j)))\n   \
    \ (mini_roman f i j)))\n", "  (define (roman-part number)\n    (cond [(< number\
    \ 0) '']\n          [(< number 1000) (string-append 'x' (int_to_mini_roman (/\
    \ number 100)))]\n          [(< number 4000) (string-append 'c' (int_to_mini_roman\
    \ (/ number 400)))]\n          [(< number 6000) (string-append 'd' (int_to_mini_roman\
    \ (/ number 600)))]\n          [(< number 8000) (string-append 'd' (int_to_mini_roman\
    \ (/ number 800)))]\n          [(< number 10000) (string-append 'x' (int_to_mini_roman\
    \ (/ number 1000)))]\n          [(< number 12000) (string-append 'c' (int_to_mini_roman\
    \ (/ number 1200)))]\n          [(< number 14400) (string-append 'd' (int_to_mini_roman\
    \ (/ number 1440)))]\n          [(< number 16000) (string-append 'x' (int_to_mini_roman\
    \ (/ number 1600)))]\n          [(< number 18000) (string-append 'c' (int_to_mini_roman\
    \ (/ number 1800)))]\n          [(< number 20000) (string-append 'd' (int_to_mini_roman\
    \ (/ number 2000)))]\n          [(< number 21000) (string-append 'x' (int_to_mini_roman\
    \ (/ number 2100)))]\n          [(< number 22000) (string-append 'c' (int_to_mini_roman\
    \ (/ number 2200)))]\n          [(< number 23400) (string-append 'd' (int_to_mini_roman\
    \ (/ number 2340)))]\n          [(< number 24000) (string-append 'x' (int_to_mini_roman\
    \ (/ number 2400)))]\n          [(< number 25000) (string-append 'c' (int_to_mini_roman\
    \ (/ number 2500)))]\n          [(< number 26000) (string-append 'd' (int_to_mini_roman\
    \ (/ number 2600)))]\n          [(< number 27000) (string-append 'x' (int_to_mini_roman\
    \ (/ number 2700)))]\n          [(< number 28000) (string-append 'c' (int_to_mini_roman\
    \ (/ number 2800)))]\n          [(< number 29000) (string-append 'd' (int_to_mini_roman\
    \ (/ number 29", "  (cond\n    [(< 1 number) '?']\n    [(< 1000 number) '?']\n\
    \    [(< 1000000 number) '?']\n    [(< 1000000000 number) '?']\n    [else (if\
    \ (< 1000000000000 number)\n              (int_to_mini_roman (/ number 1000))\n\
    \              (if (< 10000000 number)\n                  (int_to_mini_roman (/\
    \ number 1000000))\n                  (int_to_mini_roman (/ number 1000000000))))]))\n",
  "  (cond\n    ((= number 0) \"\")\n    ((< number 1000) (string-append \"m\" (int_to_mini_roman\
    \ (- number 1000))))\n    ((< number 5000) (string-append \"c\" (int_to_mini_roman\
    \ (- number 5000))))\n    ((< number 4000) (string-append \"d\" (int_to_mini_roman\
    \ (- number 4000))))\n    ((< number 3000) (string-append \"i\" (int_to_mini_roman\
    \ (- number 3000))))\n    ((< number 2000) (string-append \"v\" (int_to_mini_roman\
    \ (- number 2000))))\n    ((< number 1000) (string-append \"x\" (int_to_mini_roman\
    \ (- number 1000))))\n    ((< number 5000) (string-append \"l\" (int_to_mini_roman\
    \ (- number 5000))))\n    ((< number 4000) (string-append \"c\" (int_to_mini_roman\
    \ (- number 4000))))\n    ((< number 3000) (string-append \"x\" (int_to_mini_roman\
    \ (- number 3000))))\n    ((< number 2000) (string-append \"i\" (int_to_mini_roman\
    \ (- number 2000))))\n    ((< number 1000) (string-append \"v\" (int_to_mini_roman\
    \ (- number 1000))))\n    ((< number 5000) (string-append \"l\" (int_to_mini_roman\
    \ (- number 5000))))\n    ((< number 4000) (string-append \"c\" (int_to_mini_roman\
    \ (- number 4000))))\n    ((< number 3000) (string-append \"x\" (int_to_mini_roman\
    \ (- number 3000))))\n    ((< number 2000) (string-append \"i\" (int_to_mini_roman\
    \ (- number 2000))))\n    ((< number 1000) (string-append \"v\" (int_to_mini_roman\
    \ (- number 1000))))\n    ((< number 5000) (string-append \"l\" (int_to_mini_roman\
    \ (- number 5000))))\n    ((< number 4000) (string-append \"c\" (int_to_mini_roman\
    \ (- number 4000))))\n    ((< number 3000) (string-append \"x\" (int_to_mini_roman\
    \ (- number 3000))))\n    ((< number 2000) (string-append \"i\" (int_to_mini_roman\
    \ (- number 2000))))\n    ((< number 1000) (string-append \"v\" (int_to_mini_roman\
    \ (- number 1000))))\n    ((< number 5000) (string-append \"l\" (int_to_mini_ro",
  "  (let loop ((num number) (rnum '() '() '()))\n    (cond [(< num 100)\n       \
    \    (loop (quotient num 100) rnum)\n           (cond [(= (modulo num 100) 0)\n\
    \                   (let ((l (quotient num 1000)))\n                     (loop\
    \ l (cons (cons (mod num 1000) 'ix) rnum))\n                     (loop (quotient\
    \ num 100) (cons 'x (reverse rnum))))]\n            [else\n             (let ((m\
    \ (mod num 1000))\n                   (i (quotient num 100))\n               \
    \    (l (quotient (- num 1) 100)))\n               (loop m (cons (cons (if (<\
    \ i 100) 'I 'V) (mod i 1000) 'X) rnum))\n               (loop l (cons (mod i 1000)\
    \ rnum))]))]))\n", "  (let* ((tens (map (lambda (n) (floor (/ number 10)))\n \
    \                     (range 1 10))\n         (tens_low (map (lambda (n) (* 10\
    \ n))\n                         tens))\n         (tens_low_rev (reverse tens_low)))\n\
    \    (cond\n      [(< number 1)\n       (error 'int_to_mini_roman \"number must\
    \ be at least 1\")]\n      [else\n       (cond\n         [(< number 10)\n    \
    \      (cond\n            [(> (car tens) 1)\n             (error 'int_to_mini_roman\
    \ \"number too big\")]\n            [else\n             (cond\n              [(<\
    \ number (car tens_low))\n               (error 'int_to_mini_roman \"number too\
    \ big\")]\n              [(> (car tens) 10)\n               (error 'int_to_mini_roman\
    \ \"number too big\")]\n              [else\n               (cond\n          \
    \       [(= (car tens) 1)\n                   (cond\n                     [(<\
    \ (car tens_low) 5)\n                       (error 'int_to_mini_roman \"number\
    \ too big\")]\n                     [else\n                       (cond\n    \
    \                     [(< (car tens_low) 10)\n                          (error\
    \ 'int_to_mini_roman \"number too big\")]\n                         [else\n  \
    \                        (cond\n                            [(< (car tens_low)\
    \ 25)\n                             (error 'int_to_mini_roman \"number too big\"\
    )]\n                            [else\n                             (cond\n  \
    \                             [(< (car tens_low) 30)\n                       \
    \        (error 'int_to_mini_roman \"number too big\")]\n                    \
    \           [else\n                               (cond\n                    \
    \             [(< (car tens_low) 40)\n                                 (error\
    \ 'int_to_mini_roman \"number too big\")]\n                                 [else\n\
    \                                 (cond\n                                   [(<\
    \ (car tens_low) 50)\n                                    (error 'int_to_mini_roman\
    \ \"number too big\")]\n                                   [else\n           \
    \                         (error 'int_to_mini_roman \"number too big\")]\n   \
    \                                [end]\n                                   [end]\n\
    \                                   [end]\n                                  \
    \ [end]\n                                   [end]\n                          \
    \         [end]\n                                   [end]\n                  \
    \                 [end]\n                                   [end]\n          \
    \                         [end]\n                                   [end]\n  \
    \                                 [end]\n                                   [end]\n\
    \                                   [end]\n                                  \
    \ [end]\n                                   [end]\n                          \
    \         [end]\n                                   [end]\n                  \
    \                 [end]\n                                   [end]\n          \
    \                         [end]\n                                   [end]\n  \
    \                                 [end]\n", "  (if (or (not (= number 0))\n  \
    \        (not (positive? number)))\n      '()\n      (cons (cond [(< number 1000)\
    \ (append (list (int_to_mini_roman 0 (sub1 number)))) (list 'i 'v 'x)\n      \
    \                [(= number 1000)\n                       (append (list (int_to_mini_roman\
    \ 0 1)) (list 'x 'x)\n                      [(< number 1000000) (append (list\
    \ (int_to_mini_roman 0 (sub1 number)))\n                                     \
    \              (list (int_to_mini_roman 1 (add1 number))))\n                 \
    \      (list 'l (int_to_mini_roman 0 (add1 number)) 'x)\n                    \
    \  [(< number 1000000000)\n                       (append (list (int_to_mini_roman\
    \ 0 (sub1 number)))\n                               (list (int_to_mini_roman 1\
    \ (add1 number)) 'x)\n                       (list 'll (int_to_mini_roman 0 (add1\
    \ number)) (int_to_mini_roman 1 (add1 number)) 'x)\n                       (list\
    \ 'lll (int_to_mini_roman 0 (add1 number)) (int_to_mini_roman 1 (add1 number))\n\
    \                                                        (int_to_mini_roman 2\
    \ (add1 number)) 'x)\n                       (list 'llll (int_to_mini_roman 0\
    \ (add1 number)) (int_to_mini_roman 1 (add1 number))\n                       \
    \                                 (int_to_mini_roman 2 (add1 number))\n      \
    \                                                  (int_to_mini_roman 3 (add1\
    \ number)) 'x)\n                       (list 'lllll (int_to_mini_roman 0 (add1\
    \ number)) (int_to_mini_roman 1 (add1 number))\n                             \
    \                             (int_to_mini_roman 2 (add1 number))\n          \
    \                                                (int_to_mini_roman 3 (add1 number))\
    \ (int_to_mini_roman 4 (add1 number)) 'x)\n                       (list 'llllll\
    \ (int_to_mini_roman 0 (add1 number)) (int_to_mini_roman 1 (add1 number))\n  \
    \                                                        (int_to_mini_roman 2\
    \ (add1 number))\n                                                          (int_to_mini_roman\
    \ 3 (add1 number))\n                                                         \
    \ (int_to_mini_roman 4 (add1 number))\n                                      \
    \                    (int_to_mini_roman 5 (add1 number)) 'x)\n               \
    \        (list 'lllllll (int_to_mini_roman 0 (add1 number)) (int_to_mini_roman\
    \ 1 (", "  (let romans (list (list 'M 'MM 'MMM 'MMMM) (list 'C 'CC 'CCC 'CCCC\
    \ 'CCCCC) (list 'X 'XC 'XCC 'XCCC 'XCCCC 'XCCCCC) (list 'L 'LC 'LCC 'LCCC 'LCCCC\
    \ 'LCCCCC) (list 'D 'DC 'DCC 'DCCC 'DCCCC 'DCCCCC) (list 'V 'VC 'VCC 'VCCC 'VCCCC\
    \ 'VCCCCC) (list 'I (list 'II 'III))) ; list of roman numerals for numbers 1-1000\n\
    \    (if (> number 1000) (subst romans number 'XXX) (subst romans (- number 1)\
    \ 'XXX))))\n", "  (cond\n    [(> number 0) (int_to_mini_roman number '())]\n \
    \   [(= number 0) (append '() 'i)]\n    [(= number 1) (append 'i 'm)]\n    [(=\
    \ number 9) (append 'i 'm)]\n    [else (append (int_to_mini_roman number '(m))\
    \ (append 'm 'x))]))\n", "  (if (= number 1)\n      (list 'x)\n      (cond [(<\
    \ number 1000)\n             (append (list (list (int_to_mini_roman floor((/ number\
    \ 10))))\n                       (list (int_to_mini_roman floor((quotient number\
    \ 10))))\n                       (list (int_to_mini_roman floor((% number 10))))))\n\
    \             (< (% number 10)\n                  (int_to_mini_roman floor((/\
    \ number 10))))\n             (< (quotient number 10)\n                  (int_to_mini_roman\
    \ floor((% number 10))))]\n            [(< (quotient number 10)\n            \
    \      (int_to_mini_roman floor((/ number 10))))\n             (append (list (int_to_mini_roman\
    \ floor((% number 10))))\n                     (list (int_to_mini_roman floor((/\
    \ number 10))))\n                     (list (int_to_mini_roman floor((quotient\
    \ number 10))))\n                     (list (list (int_to_mini_roman floor((%\
    \ number 10))))\n                          (list (int_to_mini_roman floor((/ number\
    \ 10))))\n                          (list (int_to_mini_roman floor((quotient number\
    \ 10)))))))]\n            [(< (quotient number 10)\n                  (int_to_mini_roman\
    \ floor((/ number 10))))\n             (append (list (int_to_mini_roman floor((%\
    \ number 10))))\n                     (list (int_to_mini_roman floor((/ number\
    \ 10))))\n                     (list (int_to_mini_roman floor((quotient number\
    \ 10))))\n                     (list (int_to_mini_roman floor((% number 10))))\n\
    \                     (list (int_to_mini_roman floor((/ number 10))))\n      \
    \               (list (int_to_mini_roman floor((quotient number 10)))))))]\n \
    \           [(< (quotient number 10)\n                  (int_to_mini_roman floor((/\
    \ number 10))))\n             (append (list (int_to_mini_roman floor((% number\
    \ 10))))\n                     (list (int_to_mini_roman floor((/ number 10))))\n\
    \                     (list (int_to_mini_roman floor((quotient number 10))))\n\
    \                     (list (int_to_mini_roman floor((% number 10))))\n      \
    \               (list (int_to_mini_roman floor((/ number 10))))\n            \
    \         (list (int_to_mini_roman floor((quotient number 10)))))))]\n       \
    \     [(< (quotient number 10)\n                  (int_to_mini_roman floor((/\
    \ number 10))))\n             (append (list (int_to_mini_roman floor((% number ",
  "  (cond\n    ((<= number 1) 'x)\n    ((< number 1000) (int_to_mini_roman number))\n\
    \    ((and (<= (quotient number 100) 10)\n           (= (mod number 100) 0))\n\
    \     (int_to_mini_roman number))\n    ((and (<= (quotient number 100) 10)\n \
    \          (= (mod number 100) 1))\n     ((int_to_mini_roman number) (int_to_mini_roman\
    \ number))\n    ((<= (quotient number 100) 10)\n     (int_to_mini_roman number))\n\
    \    ((<= (quotient number 100) 10)\n     ((int_to_mini_roman number) 'v))))\n",
  "  (cond\n    ((= number 0)\n     '0)\n    ((= number 1)\n     'i)\n    ((= number\
    \ 2)\n     'ii)\n    ((= number 3)\n     'iii)\n    ((= number 4)\n     'x)\n\
    \    ((= number 5)\n     'xi)\n    ((= number 6)\n     'xii')\n    ((= number\
    \ 7)\n     'xiii')\n    ((= number 8)\n     'xiv')\n    ((= number 9)\n     'xvi')\n\
    \    ((= number 10)\n     'xvii')\n    ((= number 11)\n     'xviii')\n    ((=\
    \ number 12)\n     'xix')\n    ((= number 13)\n     'xixi')\n    ((= number 14)\n\
    \     'xixii')\n    ((= number 15)\n     'xixiii')\n    ((= number 16)\n     'xixiv')\n\
    \    ((= number 17)\n     'xixvi')\n    ((= number 18)\n     'xixvii')\n    ((=\
    \ number 19)\n     'xixviii')\n    ((= number 20)\n     'xixix')\n    ((= number\
    \ 21)\n     'xixixi')\n    ((= number 22)\n     'xixixii')\n    ((= number 23)\n\
    \     'xixixiii')\n    ((= number 24)\n     'xixixiv')\n    ((= number 25)\n \
    \    'xixixvi')\n    ((= number 26)\n     'xixixvii')\n    ((= number 27)\n  \
    \   'xixixviii')\n    ((= number 28)\n     'xixixix')\n    ((= number 29)\n  \
    \   'xixixixi')\n    ((= number 30)\n     'xixixixii')\n    ((= number 31)\n \
    \    'xixixixiii')\n    ((= number 32)\n     'xixixixiv')\n    ((= number 33)\n\
    \     'xixixixvi')\n    ((= number 34)\n     'xixixixvii')\n    ((= number 35)\n\
    \     'xixixixviii')\n    ((= number 36)\n     'xixixixix')\n    ((= number 37)\n\
    \     'xixixixixi')\n    ((= number 38)\n     'xixixixixii')\n    ((= number 39)\n\
    \     'xixixixixiii')\n    ((= number 40)\n     'xixixixixiv')\n    ((= number\
    \ 41)\n     'xixixixixvi')\n    ((= number ", "  (cond\n    [(= number 0) \"\"\
    ]\n    [(= number 1) \"I\"]\n    [(< number 1) (int_to_mini_roman (sub1 number))])\n\
    \  (cond\n    [(= number 100) \"\"]\n    [(< number 100) (int_to_mini_roman (sub1\
    \ number))])\n  (cond\n    [(= number 500) \"\"]\n    [(< number 500) (int_to_mini_roman\
    \ (sub1 number))])\n  (cond\n    [(= number 1000) \"\"]\n    [(< number 1000)\
    \ (int_to_mini_roman (sub1 number))])\n  (cond\n    [(= number 5000) \"\"]\n \
    \   [(< number 5000) (int_to_mini_roman (sub1 number))])\n  (cond\n    [(= number\
    \ 10000) \"\"]\n    [(< number 10000) (int_to_mini_roman (sub1 number))])\n  (cond\n\
    \    [(= number 100000) \"\"]\n    [(< number 100000) (int_to_mini_roman (sub1\
    \ number))])\n  (cond\n    [(= number 1000000) \"\"]\n    [(< number 1000000)\
    \ (int_to_mini_roman (sub1 number))])\n  (cond\n    [(= number 10000000) \"\"\
    ]\n    [(< number 10000000) (int_to_mini_roman (sub1 number))])\n  (cond\n   \
    \ [(= number 100000000) \"\"]\n    [(< number 100000000) (int_to_mini_roman (sub1\
    \ number))])\n  (cond\n    [(= number 1000000000) \"\"]\n    [(< number 1000000000)\
    \ (int_to_mini_roman (sub1 number))])\n  (cond\n    [(= number 10000000000) \"\
    \"]\n    [(< number 10000000000) (int_to_mini_roman (sub1 number))])\n  (cond\n\
    \    [(= number 100000000000) \"\"]\n    [(< number 100000000000) (int_to_mini_roman\
    \ (sub1 number))])\n  (cond\n    [(= number 1000000000000) \"\"]\n    [(< number\
    \ 1000000000000) (int_to_mini_roman (sub1 number))])\n  (cond\n    [(= number\
    \ 10000000000000) \"\"]\n    [(< number 10000000000000) (int_to_mini_roman (sub1\
    \ number))])\n  (cond\n    [(= number 100000000000000) \"\"]\n    [(< number 10000000000",
  "  (cond\n    [(< number 1) '']\n    [(< number 4) (string-append \"i\" (int_to_mini_roman\
    \ number (- number 1)))]\n    [(< number 9) (string-append \"ii\" (int_to_mini_roman\
    \ number (- number 1)))]\n    [(< number 14) (string-append \"iii\" (int_to_mini_roman\
    \ number (- number 1)))]\n    [(< number 19) (string-append \"x\" (int_to_mini_roman\
    \ number (- number 1)))]\n    [else (string-append \"x\" (int_to_mini_roman number\
    \ (- number 1)) \"i\" \n                        (int_to_mini_roman number (- number\
    \ 1)))]\n  )\n)\n", "  (cond [(< number 1000) (int_to_mini_roman 1000)]\n    \
    \    [else (string-append (int_to_mini_roman number (- number 1000))\n       \
    \                     (string-append 'i (substring #lang racket))))])\n", "  (define\
    \ numerals '(m d c l x vi l'))\n  (define romans '(m c d x l vi l))\n  (let ((count\
    \ 0))\n    (for/or ((i number) (p romans))\n      (when (and (> i 0) (< i 1000))\n\
    \        (let ((n (mod i 10)))\n          (when (eqv? n 0)\n            (cond\n\
    \              ((< i 100) (+ i 100))\n              ((< i 500) (+ i 500))\n  \
    \            ((< i 1000) (+ i 1000))\n              ((< i 5000) (+ i 5000))\n\
    \              ((< i 10000) (+ i 10000))\n              ((< i 20000) (+ i 20000))\n\
    \              ((< i 30000) (+ i 30000))\n              ((< i 40000) (+ i 40000))\n\
    \              ((< i 50000) (+ i 50000))\n              ((< i 60000) (+ i 60000))\n\
    \              ((< i 70000) (+ i 70000))\n              ((< i 80000) (+ i 80000))\n\
    \              ((< i 90000) (+ i 90000))\n              ((< i 100000) (+ i 100000))\n\
    \              ((< i 200000) (+ i 200000))\n              ((< i 300000) (+ i 300000))\n\
    \              ((< i 400000) (+ i 400000))\n              ((< i 500000) (+ i 500000))\n\
    \              ((< i 600000) (+ i 600000))\n              ((< i 700000) (+ i 700000))\n\
    \              ((< i 800000) (+ i 800000))\n              ((< i 900000) (+ i 900000))\n\
    \              ((< i 1000000) (+ i 100000))\n              ((< i 2000000) (+ i\
    \ 200000))\n              ((< i 3000000) (+ i 300000))\n              ((< i 4000000)\
    \ (+ i 400000))\n              ((< i 5000000) (+ i 500000))\n              ((<\
    \ i 6000000) (+ i 600000))\n              ((< i 7000000) (+ i 700000))\n     \
    \         ((< i 8000000) (+ i 800000))\n              ((< i 9000000) (+ i 900000))\n\
    \              ((< i 10000000) (+ i 100000))\n              ((< i 20000000) (+\
    \ i 200000))\n              ((< i 30000000) (+ i 300000))\n              ((< i\
    \ 40000000) (+ i 400000))", "  (cond\n    [(zero? number) (error 'int_to_mini_roman\
    \ \"invalid number: ~s\" number)]\n    [(or (= (modulo number 100) 0) (= (modulo\
    \ number 100) 1)) (list 'I 'IV 'V 'IX 'X 'XL 'L 'XC 'C 'D 'CM 'M)]\n    [(= (modulo\
    \ number 10) 0) (list 'X 'XL 'L 'XC 'C 'D 'CM 'M)]\n    [else (list 'I 'II 'III\
    \ 'IV 'V 'VI 'VII 'IX 'X 'XI 'XII 'XIII 'XIV 'XV 'XVI 'XVII 'XIX 'XX 'XXI 'XXII\
    \ 'XXIII 'XXIV 'XXV 'XXVI 'XXVII 'XXIX 'XXX 'XXXI 'XXXII 'XXXIII 'XXXIV 'XXXV\
    \ 'XXXVI 'XXXVII 'XXXIX 'XL 'XLI 'XLII 'XLIII 'XLIIII 'XLIIV 'XLIV 'XLIVI 'XLIVII\
    \ 'XLIIX 'XC 'XCI 'XCII 'XCIII 'XCIIII 'XCIV 'XCIVI 'XCIVII 'XCIX 'XD 'XDI 'XDII\
    \ 'XDIII 'XDIIII 'XDIIV 'XDIV 'XDIVI 'XDIVII 'XDIIX 'XM 'XMI 'XMII 'XMIII 'XMIIV\
    \ 'XMIV 'XMIVI 'XMIVII 'XMIIX 'XZ 'XZI 'XZII 'XZIII 'XZIV 'XZV 'XZVI 'XZVII 'XZIX\
    \ 'XL 'XL ' ' ' 'I 'II))]))\n\n", "  (let loop ((num number) (front 'a) (res '()))\n\
    \    (if (<= num 1000)\n        (let ((next (/ (num - 1) (roman-num-length front)))\
    \ (tail (- num next)))\n          (cond\n            ((= tail 0) (cons front res))\n\
    \            ((< tail 0)\n             (loop (+ next 1) (front next) (cons next\
    \ res)))\n            (else (loop (+ next 1) (front next) (cons tail (cons (roman-num-symbol-name\
    \ front) (cons next res))))))\n      (loop (+ num 1) front res))))\n", "  (cond\n\
    \    [(< number 0) '']\n    [(< number 1000) (number->string number)]\n    [else\
    \ (mini-roman-numeral->string number)]))\n", "  (if (< 1 number)\n      '()\n\
    \      (append (int_to_roman_roman (- number 1)) \n              (string #\\M)\n\
    \              (int_to_mini_roman number))))\n", "  (cond\n    [(= number 1) (string\
    \ \"I\")]\n    [(< number 1) (string \"M\")]\n    [else (if (< number 1000) (string\
    \ \"C\") (string \"D\"))\n          (if (< number 400) (string \"M\") (string\
    \ \"CM\"))]))\n", "  (if (< number 0)\n      0\n      (let ((remainder (mod-roman\
    \ (sub1 number) 1000)))\n        (cond\n          [(zero? remainder) '']\n   \
    \       [(not (<= remainder 90)) (recur (sub1 remainder))]\n          [(not (=\
    \ remainder 100)) (append (recur 'x) (sub1 remainder))]\n          [(not (= remainder\
    \ 1000)) (append (recur 'lx) (sub1 remainder))]))))\n", "  (define (int_to_roman\
    \ number)\n    (cond [(= number 0) 'zero]\n          [(= number 1) 'one]\n   \
    \       [(= number 2) 'two]\n          [(= number 3) 'three]\n          [(= number\
    \ 4) 'four]\n          [(= number 5) 'five]\n          [(= number 6) 'six]\n \
    \         [(= number 7) 'seven]\n          [(= number 8) 'eight]\n          [(=\
    \ number 9) 'nine]\n          [(= number 10) 'ten]\n          [(= number 11) 'eleven]\n\
    \          [(= number 12) 'twelve]\n          [(= number 13) 'thirteen]\n    \
    \      [(= number 14) 'fourteen]\n          [(= number 15) 'fifteen]\n       \
    \   [(= number 16) 'sixteen]\n          [(= number 17) 'seventeen]\n         \
    \ [(= number 18) 'eighteen]\n          [(= number 19) 'nineteen]\n          [(=\
    \ number 20) 'twenty]\n          [(= number 21) 'twenty-one]\n          [(= number\
    \ 22) 'twenty-two]\n          [(= number 23) 'twenty-three]\n          [(= number\
    \ 24) 'twenty-four]\n          [(= number 25) 'twenty-five]\n          [(= number\
    \ 26) 'twenty-six]\n          [(= number 27) 'twenty-seven]\n          [(= number\
    \ 28) 'twenty-eight]\n          [(= number 29) 'twenty-nine]\n          [(= number\
    \ 30) 'thirty]\n          [(= number 31) 'thirty-one]\n          [(= number 32)\
    \ 'thirty-two]\n          [(= number 33) 'thirty-three]\n          [(= number\
    \ 34) 'thirty-four]\n          [(= number 35) 'thirty-five]\n          [(= number\
    \ 36) 'thirty-six]\n          [(= number 37) 'thirty-seven]\n          [(= number\
    \ 38) 'thirty-eight]\n          [(= number 39) 'thirty-nine]\n          [(= number\
    \ 40) 'forty]\n          [(= number 41) 'forty-one]\n          [(= number 42)\
    \ 'for", "  (if (= number 0)\n      '0\n      (let ([first-value (int_to_mini_roman\
    \ number)]\n            [remainder   (- number first-value)]\n            [second-value\
    \ (foldr add-to-result '0 remainder)])\n        (string-append first-value second-value))))\n",
  "  (if (<= number 1000)\n      (cond [(= number 1) (list 'I 'IV 'V 'IX 'X 'XL 'L\
    \ 'XL 'C 'D 'CM 'M)]\n            ;; 'III', 'IV' ...\n            [(= (- number\
    \ 1) 2) (cons 'I (int_to_mini_roman 2))]\n            [(= (- number 1) 3) (cons\
    \ 'I (int_to_mini_roman 3) 'V)]\n            [else (cons 'I (int_to_mini_roman\
    \ 3) (cons 'V (int_to_mini_roman 4)))]))\n  ;; 'III', 'IV' ...\n  [else (cons\
    \ 'I (int_to_mini_roman 1) (cons 'I (int_to_mini_roman 2)))]))\n", "  (let loop\
    \ ((i number) (res '()))\n    (cond\n      ((= i 0)\n       (reverse res))\n \
    \     (else\n       (loop (- i 1)\n             (cons (char->int (number->char\
    \ (mod i 1000))) res))))))\n", "  (if (< number 1000)\n      (let ((num (- number\
    \ 1))\n            (roman (make-array '(4) '(lambda (a b) (+ a b))\n         \
    \                          '(lambda (a b) (+ b a))\n                         \
    \          '(lambda (a b) (+ a b))))\n            (num-roman (make-array '(4)\
    \ '(lambda (a b) (+ a b))\n                                         '(lambda (a\
    \ b) (+ b a))\n                                         '(lambda (a b) (+ a b))))\n\
    \            (rom-num (make-array '(4) '(lambda (a b) (+ a b))\n             \
    \                    '(lambda (a b) (+ b a))\n                               \
    \  '(lambda (a b) (+ a b))))\n            (result \"\"))\n      (let ((num (-\
    \ number 1))\n            (roman (make-array '(4) '(lambda (a b) (+ a b))\n  \
    \                                 '(lambda (a b) (+ b a))\n                  \
    \                 '(lambda (a b) (+ a b))))\n        (num-roman (make-array '(4)\
    \ '(lambda (a b) (+ a b))\n                                   '(lambda (a b) (+\
    \ b a))\n                                   '(lambda (a b) (+ a b))))\n      \
    \  (rom-num (make-array '(4) '(lambda (a b) (+ a b))\n                       \
    \          '(lambda (a b) (+ b a))\n                                 '(lambda\
    \ (a b) (+ a b))))\n        (append (append (list num)\n                     \
    \ (mini-roman (- num 1) roman))\n                (mini-roman (- num 1) rom-num))))))\n",
  "  (cond\n    [(< number 1)\n     \"\"]\n    [(< number 1000)\n     (cond\n    \
    \   [(= (modulo number 1000) 0)\n        (cond\n         [(= (modulo number 100)\
    \ 0)\n          (cond\n            [(= (modulo number 10) 0)\n             (append\
    \ \"c\" (int_to_mini_roman number (- number 10)))]\n            [(= (modulo number\
    \ 10) 1)\n             (append \"c\" (int_to_mini_roman number (- number 10)))]\n\
    \            [(= (modulo number 10) 2)\n             (append \"c\" (int_to_mini_roman\
    \ number (- number 10)))]\n            [(= (modulo number 10) 3)\n           \
    \  (append \"c\" (int_to_mini_roman number (- number 10)))]\n            [(= (modulo\
    \ number 10) 4)\n             (append \"c\" (int_to_mini_roman number (- number\
    \ 10)))]\n            [(= (modulo number 10) 5)\n             (append \"c\" (int_to_mini_roman\
    \ number (- number 10)))]\n            [(= (modulo number 10) 6)\n           \
    \  (append \"c\" (int_to_mini_roman number (- number 10)))]\n            [(= (modulo\
    \ number 10) 7)\n             (append \"c\" (int_to_mini_roman number (- number\
    \ 10)))]\n            [(= (modulo number 10) 8)\n             (append \"c\" (int_to_mini_roman\
    \ number (- number 10)))]\n            [(= (modulo number 10) 9)\n           \
    \  (append \"c\" (int_to_mini_roman number (- number 10)))]\n            [else\n\
    \             (append \"c\" (int_to_mini_roman number (- number 10)))]\n     \
    \       )]\n         [(= (modulo number 10) 1)\n          (append \"c\" (int_to_mini_roman\
    \ number (- number 10)))]\n         [(= (modulo number 10) 2)\n          (append\
    \ \"c\" (int_to_mini_roman number (- number 10)))]\n         [(= (modulo number\
    \ 10) 3)\n          (append \"c\" (int_to_mini_roman number (- number 10)))]\n\
    \         [(= (modulo number 10) 4)\n          (append \"c\" (int_to_mini_roman\
    \ number (- number 10)))]\n         [(= (modulo number 10) 5)\n          (append\
    \ \"c\" (int_to_mini_roman number (- number 10)))]\n         [(= (modulo number\
    \ 10) 6)\n          (", "  (let ((num-string (gensym \"NUM-STRING\")))\n    (set!\
    \ num-string\n          (append num-string\n                  (list (list 'I number\
    \ number 'I))\n                  (list 'I number number 'IV 'V 'VI)))\n    (string->symbol\
    \ (mini-roman-string num-string))))\n", "  (cond\n    [(and (<= number 1) (< number\
    \ 100)) (substring 'x 1 number)] \n    [(and (<= number 1000) (< number 2000))\
    \ (substring 'c 1 number)] \n    [(and (<= number 2000) (< number 3000)) (substring\
    \ 'l 1 number)] \n    [(and (<= number 3000) (< number 4000)) (substring 'i 1\
    \ number)] \n    [(and (<= number 4000) (< number 5000)) (substring 'x 1 number)]\
    \ \n    [(and (<= number 5000) (< number 6000)) (substring 'c 1 number)] \n  \
    \  [(and (<= number 6000) (< number 7000)) (substring 'l 1 number)] \n    [(and\
    \ (<= number 7000) (< number 8000)) (substring 'i 1 number)] \n    [(and (<= number\
    \ 8000) (< number 9000)) (substring 'x 1 number)] \n    [(and (<= number 9000)\
    \ (< number 10000)) (substring 'c 1 number)] \n    [(and (<= number 10000) (<\
    \ number 11000)) (substring 'l 1 number)] \n    [(and (<= number 11000) (< number\
    \ 12000)) (substring 'i 1 number)] \n    [(and (<= number 12000) (< number 13000))\
    \ (substring 'x 1 number)] \n    [(and (<= number 13000)\n         (< number 14000))\
    \ (substring 'c 1 number)] \n    [(and (<= number 14000) (< number 15000)) (substring\
    \ 'l 1 number)] \n    [(and (<= number 15000) (< number 16000)) (substring 'i\
    \ 1 number)] \n    [(and (<= number 16000) (< number 17000)) (substring 'x 1 number)]\
    \ \n    [(and (<= number 17000) (< number 18000)) (substring 'c 1 number)] \n\
    \    [(and (<= number 18000) (< number 19000)) (substring 'l 1 number)] \n   \
    \ [(and (<= number 19000) (< number 20000)) (substring 'i 1 number)] \n    [(and\
    \ (<= number 20000) (< number 21000)) (substring 'x 1 number)] \n    [(and (<=\
    \ number 21000) (< number 22000)) (substring 'c 1 number)] \n    [(and (<= number\
    \ 22000) (< number 23000)) (substring 'l 1 number)] \n    [(and (<= number 23000)\
    \ (< number 24000)) (substring 'i 1 number)] \n    [(and (<= ", "  (if (<= number\
    \ 1000)\n      (let ([thousand-digit (/ (- number 1000) 1000)])\n        (string-append\
    \ (int_to_mini_roman thousand-digit)\n                       (if (= thousand-digit\
    \ 0) \"\" \"\" \"\" \"\" \"c\"))))\n", "  (cond\n    [(> number 1) '']\n    [(<\
    \ number 1000) (string-append (symbol->string 'M) (int_to_mini_roman number))]))\n",
  "  (let ((result '()))\n    (cond ((< number 1000)\n           (append result (list\
    \ (char (expt number 1000)))))\n          ((< number 1000000)\n           (int_to_mini_roman\
    \ number\n                          (expt number 1000000))\n           (append\
    \ result (list (char (expt number 1000)))))\n          ((< number 1000000000)\n\
    \           (int_to_mini_roman number\n                          (expt number\
    \ 1000000000))\n           (append result (list (char (expt number 1000000)))))\n\
    \          ((< number 1000000000000)\n           (int_to_mini_roman number\n \
    \                         (expt number 1000000000000))\n           (append result\
    \ (list (char (expt number 1000000000)))))\n          ((< number 100000000000000)\n\
    \           (int_to_mini_roman number\n                          (expt number\
    \ 100000000000000))\n           (append result (list (char (expt number 1000000000000)))))\n\
    \          ((< number 10000000000000000)\n           (int_to_mini_roman number\n\
    \                          (expt number 10000000000000000))\n           (append\
    \ result (list (char (expt number 100000000000000)))))\n          ((< number 1000000000000000000)\n\
    \           (int_to_mini_roman number\n                          (expt number\
    \ 1000000000000000000))\n           (append result (list (char (expt number 10000000000000000)))))\n\
    \          (else\n           (int_to_mini_roman number))))\n", "  (cond [(= number\
    \ 0) \"\"]\n        [(< number 1) (substring '(i v x l c d) 1 1)]\n        [(<\
    \ number 10) (string-append (int_to_mini_roman floor (/ number 100)) \"vi\")]\n\
    \        [(< number 100) (substring '(c d x v i) 1 1)]\n        [else (substring\
    \ '(i v x l c d) 0 2)]))\n", "  (let loop ((n number)\n             (r #f)\n \
    \            (i 0))\n    (cond\n      ((< i 9) (let ((roman (nth-value i (lookup\
    \ #(\n                                         (roman-numeral i #f)\n        \
    \                                 (roman-numeral i #t)\n                     \
    \                    (roman-numeral i #f)) #t)\n                          (numeral\
    \ (roman-numeral i #f)))\n                 (cond\n                   ((> n 1000)\
    \ (cons x \"m\"))\n                   ((< n 100) (cons x \"d\"))\n           \
    \        ((< n 10) (cons x \"c\"))\n                   ((< n 1) (cons x \"x\"\
    ))\n                   (else (cons x (roman-numeral i #f))))))\n      ((< n 1000)\
    \ (cons (roman-numeral i #f) x))\n      (else (let ((roman (nth-value i (lookup\
    \ #(\n                                       (roman-numeral i #f)\n          \
    \                             (roman-numeral i #t)\n                         \
    \              (roman-numeral i #f)) #t)))\n                (cond\n          \
    \        ((> n 1000) (cons roman \"m\"))\n                  ((< n 100) (cons roman\
    \ \"d\"))\n                  ((< n 10) (cons roman \"c\"))\n                 \
    \ ((< n 1) (cons roman \"x\"))\n                  ((else (cons roman (int_to_mini_roman\
    \ n))))))))))\n", "  (cond\n    [(= number 1) 'x]\n    [(= number 4) 'c]\n   \
    \ [(= number 9) 'd]\n    [(= number 400) 'mi]\n    [(= number 500) 'vi]\n    [(=\
    \ number 1000) 'l]\n    [else (cons (substring \"IVXLCDM\" 0 (char-code (+ number\
    \ 1))) (int_to_mini_roman number))]))\n", "  (cond [(= number 0)\n         '0']\n\
    \        [(< number 0)\n         '']\n        [else\n         (let* ((tens (floor\
    \ (/ (expt number 10) 10) 10))\n                (ones (- number tens)))\n    \
    \       (cond [(= ones 0)\n                   (format \"~a\" tens)]\n        \
    \         [(= tens 0)\n                   (format \"~a\" (- ones (floor (/ number\
    \ 10) 10)))]\n                 [(= tens 1)\n                   (cond [(= (- number\
    \ ones) 1)\n                         (format \"~a\" (- ones (floor (/ number 10)\
    \ 10)))]\n                         [else\n                         (cond [(= (-\
    \ number ones) 0)\n                                (format \"~a\" 'e)\n      \
    \                          [else\n                                 (format \"\
    ~a\" (- ones (floor (/ number 10) 10)))]\n                               ]\n \
    \                         )\n                          ]\n                   \
    \   )\n                     ]\n                  [else\n                   (let*\
    \ ((twentys (floor (/ (expt number 20) 20) 10))\n                         (tens\
    \ (- number twentys))\n                         (ones (- number tens)))\n    \
    \               (cond [(= ones 0)\n                         (format \"~a\" tens)]\n\
    \                     [(= tens 0)\n                       (format \"~a\" (- ones\
    \ (floor (/ number 20) 20)))]\n                     [(= tens 1)\n            \
    \           (cond [(= (- number ones) 1)\n                              (format\
    \ \"~a\" (- ones (floor (/ number 20) 20)))]\n                             [else\n\
    \                              (cond [(= (- number ones) 0)\n                \
    \                    (format \"~a\" 'e)\n                                    [else\n\
    \                                     (format \"~a\" (- ones (floor (/ number\
    \ 20) 20)))]\n                                   ]\n                         \
    \     )\n                              ]\n                          )\n      \
    \                    ]\n                      [else\n                       (let*\
    \ ((ten 10 (floor (/ number 10)))\n                              (ones (- number\
    \ ten)))\n                       (cond [(= ones 0)\n                         \
    \   (format \"~a\" ten)]\n                         [(= tens 0)\n             \
    \             (format \"~a\" (- ones (floor (/ number 10))))]\n              \
    \           [(= tens 1)\n                          (cond [(= (- number ones) 1)\n\
    \                                (format \"~a\" (- ones (floor (/ number 10))))]\n\
    \                             [else\n                                (cond [(",
  "  (let ([numerals (list* 'I 'IV 'III 'IV 'V 'IV 'V)\n             denominations\
    \ (list* 1 6 4 3 2 5 4)])\n    (cond\n      [(<= number 1) numerals]\n      [(and\
    \ (<= number 1000) (= (modulo number 10) 0)) (numerals 'X)]\n      [else (cons\
    \ (int_to_mini_roman floor (/ number 10)) (numerals (drop number 10)))]\n    \
    \  (else (cons (int_to_mini_roman floor (/ number denominations)) (numerals (drop\
    \ denominations number))))]))\n", "  (cond\n    [(< number 1)\n     (error \"\
    number must be >= 1\")]\n    [(< number 1000)\n     (cond\n       [(< number 10)\n\
    \        (cond\n         [(< number 5)\n          (error \"number must be >= 5\"\
    )] \n         [else (cons \"mno\"\n                     (int_to_mini_roman number))]\n\
    \         )]\n       [else (cons \"cm\"\n                  (int_to_mini_roman\
    \ number))]\n       )]\n    [else (cond\n             [(< number 500)\n      \
    \        (cond\n               [(< number 50)\n                (error \"number\
    \ must be >= 50\")] \n               [else (cons \"cd\"\n                    \
    \       (int_to_mini_roman number))]\n               )]\n             [else (cond\n\
    \                       [(< number 400)\n                        (cond\n     \
    \                    [(< number 40)\n                          (error \"number\
    \ must be >= 40\")] \n                         [else (cons \"xc\"\n          \
    \                          (int_to_mini_roman number))]\n                    \
    \     )]\n                       [else (cond\n                               \
    \ [(< number 300)\n                                 (error \"number must be >=\
    \ 300\")] \n                                [else (cons \"ix\"\n             \
    \                             (int_to_mini_roman number))]\n                 \
    \               )]\n                       )]\n                       )]\n   \
    \ ))\n", "  (let loop ((result #f) (count #f) (digit (floor number 1000)))\n \
    \   (cond\n      ((< digit 1000) (if (< count 10000)\n                       \
    \  (loop (* result 10) (+ count 1) (- digit 100))\n                         (loop\
    \ (* result 10) (+ count 1) (- digit 100)))\n        (if (< count 1000)\n    \
    \        (loop (* result 10) (+ count 1) digit)\n            result)))))\n", " \
    \ (let* ((num-digits (string->number (string->list number))\n           (num-roman-digits\
    \ '())\n           (i 0 (+ i 1)))\n         (add-one (+ i 1)))\n    (if (< i 1000)\n\
    \        (let ((digits (sub1 num-digits))\n               (roman-digits (sub1\
    \ num-roman-digits)))\n          (cond\n           ((null? digits) (cons i roman-digits))\n\
    \           ((= (modulo i 100) 4) (cons i roman-digits))\n           ((= (modulo\
    \ i 100) 4) (cons i roman-digits))\n           ((= (modulo i 100) 400) (cons i\
    \ roman-digits))\n           ((= (modulo i 100) 1000) (cons i roman-digits))\n\
    \           (else (cons (* i 100) (append roman-digits (sub1 digits))))))))\n",
  "  (cond\n    [(< 1 number)\n     'zero]\n    [(< 1000 number)\n     (string->char\
    \ (list number))]\n    [else\n     (let ([digits (r_num_to_list (string->char\
    \ (int_to_r_num (+ 1 number))))])\n       (cond\n         [(and (eq? (length digits)\
    \ 1) (eq? (first digits) \"0\"))\n          (let ([last-digit (first digits)])\n\
    \            (let ([next-digit (second digits)])\n              (if (not (eq?\
    \ last-digit next-digit))\n                (let ([result (mini_to_int\n      \
    \                       (mini_to_roman_num (first (rest digits)))\n          \
    \                   (mini_to_roman_num (second (rest digits))))])\n          \
    \        (string->string result))\n                'zero)))]\n        [else\n\
    \         (let ([digit-sum (+ 0 (length digits))\n               result (mini_to_int\n\
    \                         (mini_to_roman_num (first digits))\n               \
    \          (mini_to_roman_num (second digits))])\n           (cond\n         \
    \    [(and (eq? (length digits) 1) (eq? (first digits) \"0\"))\n             (let\
    \ ([last-digit (first digits)])\n               (let ([next-digit (second digits)])\n\
    \                 (if (not (eq? last-digit next-digit))\n                   (let\
    \ ([result (mini_to_int\n                                   (mini_to_roman_num\
    \ (first (rest digits)))\n                                   (mini_to_roman_num\
    \ (second (rest digits))))])\n                     (mini_to_mini_roman result))\n\
    \                 'zero)))]\n             [else\n               (let ([remainder\
    \ (modulo (first digits) 10)\n                       first-remainder (modulo (first\
    \ digits) 10)\n                       remainders (concat (list remainder)\n  \
    \                                         (map (lambda (x)\n                 \
    \                                roman_digits)\n                             \
    \                  digits)\n                                           (map (lambda\
    \ (x)\n                                                 roman_digits)\n      \
    \                                         digit-sum)\n                       \
    \                    (map (lambda (x)\n                                      \
    \           roman_digits)\n                                               digit-sum))\n\
    \                       remainder-result (mini_to_int\n                      \
    \                     (mini_to_roman_num (first remainders))\n               \
    \                            (mini_to_roman_num (second remainders)))])\n    \
    \             (cond\n                   [(< first-remainder (length remainders))\n\
    \                    (let ([last-remainder (last remainders)])\n             \
    \         (let ([next-remainder (rest remainders)])\n                        (cond\n\
    \                          [(and (eq? (length remainders) ", "  (define (mini_roman_numerals\
    \ n roman_numerals)\n    (cond ((> n 0) (mini_roman_numerals (- n 1)\n       \
    \                             (cons (cons roman_numerals 'i) (mini_roman_numerals\
    \ (+ n 1) 'i)))\n          (= n 0)\n          (= roman_numerals '())\n       \
    \   (= n (+ 1 (length roman_numerals))\n            (mini_roman_numerals (- n\
    \ 1)\n                              roman_numerals)\n          (else (mini_roman_numerals\
    \ n (append roman_numerals 'i))))))\n  (define (roman_numeral n)\n    (cond\n\
    \      ((= n 0) 'i')\n      ((= n 1) 'i')\n      (else\n       (let ((digits (mini_roman_numerals\
    \ n '())))\n         (cond ((<= (length digits) 1)\n                (string-append\
    \ digits (string-append 'i)))\n              (else (string-append (first digits)\
    \ 'i)))))))\n  (define (roman_numerals number)\n    (let* ((roman_numerals '())\n\
    \           (remainder (modulo number 1000))\n           (value (quotient number\
    \ 1000))\n           (numerals (mini_roman_numerals value roman_numerals)))\n\
    \      (cond\n        (zero? (remainder number)) roman_numerals\n        (one?\
    \ (remainder number)) (cons (roman_numeral value) roman_numerals)\n        (else\
    \ (roman_numerals (cons (roman_numeral value) roman_numerals)))))))\n  (roman_numerals\
    \ number))\n", "  (if (or (< number 1) (> number 1000)) \"\")\n  (let\n      ((numerals\
    \ (list\n                  (list \"I\" 1)\n                  (list \"II\" 2)\n\
    \                  (list \"III\" 3)\n                  (list \"IV\" 4)\n     \
    \             (list \"V\" 5)\n                  (list \"VI\" 6)\n            \
    \      (list \"VII\" 7)\n                  (list \"VIII\" 8)\n               \
    \   (list \"IX\" 9)\n                  (list \"X\" 10)\n                  (list\
    \ \"XI\" 11)\n                  (list \"XII\" 12)\n                  (list \"\
    XIII\" 13)\n                  (list \"XIV\" 14)\n                  (list \"XV\"\
    \ 15)\n                  (list \"XVI\" 16)\n                  (list \"XVII\" 17)\n\
    \                  (list \"XVIII\" 18)\n                  (list \"XIX\" 19)\n\
    \                  (list \"XX\" 20)\n                  (list \"XXI\" 21)\n   \
    \               (list \"XXII\" 22)\n                  (list \"XXIII\" 23)\n  \
    \                (list \"XXIV\" 24)\n                  (list \"XXV\" 25)\n   \
    \               (list \"XXVI\" 26)\n                  (list \"XXVII\" 27)\n  \
    \                (list \"XXVIII\" 28)\n                  (list \"XXIX\" 29)\n\
    \                  (list \"XXX\" 30)\n                  (list \"XXXI\" 31)\n \
    \                 (list \"XXXII\" 32)\n                  (list \"XXXIII\" 33)\n\
    \                  (list \"XXXIV\" 34)\n                  (list \"XXXV\" 35)\n\
    \                  (list \"XXXVI\" 36)\n                  (list \"XXXVII\" 37)\n\
    \                  (list \"XXXVIII\" 38)\n                  (list \"XXXIX\" 39)\n\
    \                  (list \"XX\" 40)\n                  (list \"XXI\" 41)\n   \
    \               (list \"XXII\" 42)\n                  (list \"XXIII\" 43)\n  \
    \                (list \"XXIV\" 44)\n                  (list \"XXV\" 45)\n   \
    \               (list \"XXVI\" 46)\n                  (list \"XXVII\" 47)\n  \
    \                (list \"XXVIII\" 48)\n                  (list \"XXIX\" 49)\n\
    \                  (list \"XXX\" 50)\n                  (list \"XXXI\" ", "  (cond\n\
    \    [(<= number 0) \"\"]\n    [(< number 1000) (string-append \"x\" (int_to_mini_roman\
    \ 1 (- number 1)))]\n    [(< number 5000) (string-append \"c\" (int_to_mini_roman\
    \ 1 (- number 2)))]\n    [(< number 10000) (string-append \"d\" (int_to_mini_roman\
    \ 1 (- number 3)))]\n    [(< number 15000) (string-append \"dx\" (int_to_mini_roman\
    \ 1 (- number 4)))]\n    [(< number 200000) (string-append \"ex\" (int_to_mini_roman\
    \ 1 (- number 5)))]\n    [(< number 250000) (string-append \"fx\" (int_to_mini_roman\
    \ 1 (- number 6)))]\n    [(< number 300000 (- number 6)) (string-append \"g\"\
    \ (int_to_mini_roman 1 (- number 7)))]\n    [(< number 350000 (- number 7)) (string-append\
    \ \"hx\" (int_to_mini_roman 1 (- number 8)))]\n    [(< number 400000 (- number\
    \ 8)) (string-append \"ix\" (int_to_mini_roman 1 (- number 9)))]\n    [(< number\
    \ 450000 (- number 9)) (string-append \"jx\" (int_to_mini_roman 1 (- number 10)))]\n\
    \    [(< number 500000 (- number 10)) (string-append \"k\" (int_to_mini_roman\
    \ 1 (- number 11)))]\n    [(< number 550000 (- number 11)) (string-append \"l\"\
    \ (int_to_mini_roman 1 (- number 12)))]\n    [(< number 600000 (- number 12))\
    \ (string-append \"m\" (int_to_mini_roman 1 (- number 13)))]\n    [(< number 650000\
    \ (- number 13)) (string-append \"n\" (int_to_mini_roman 1 (- number 14)))]\n\
    \    [(< number 700000 (- number 14)) (string-append \"o\" (int_to_mini_roman\
    \ 1 (- number 15)))]\n    [(< number 750000 (- number 15)) (string-append \"p\"\
    \ (int_to_mini_roman 1 (- number 16)))]\n    [(< number 800000 (- number 16))\
    \ (string-append \"q\" (int_to_mini_roman 1 (- number 17)))]\n    [(< number 850000\
    \ (- number 17)) (string-append \"r\" (int_to_mini", "  (cond [(< number 1)\n\
    \         'zero']\n        [(= number 1)\n         'one']\n        [(< number\
    \ 7)\n         (cons ((char 'i number) (int_to_mini_roman 1))\n              \
    \ 'one')\n         (cons ((char 'v number) (int_to_mini_roman 1))\n          \
    \     'one')]\n        [(< number 13)\n         (cons ((char 'x number) (int_to_mini_roman\
    \ 1))\n               'one')\n         (cons ((char 'l number) (int_to_mini_roman\
    \ 1))\n               'one')\n         (cons ((char 'c number) (int_to_mini_roman\
    \ 1))\n               'one')\n         (cons ((char 'd number) (int_to_mini_roman\
    \ 2))\n               'one')\n         (cons ((char 'm number) (int_to_mini_roman\
    \ 1))\n               'one')]\n        [(< number 20)\n         (cons ((char 'v\
    \ number) (int_to_mini_roman 2))\n               'one')\n         (cons ((char\
    \ 'l number) (int_to_mini_roman 1))\n               'one')\n         (cons ((char\
    \ 'c number) (int_to_mini_roman 1))\n               'one')\n         (cons ((char\
    \ 'd number) (int_to_mini_roman 2))\n               'one')\n         (cons ((char\
    \ 'm number) (int_to_mini_roman 1))\n               'one')]\n        [else\n \
    \        (cons ((char 'i number) (((int_to_mini_roman number) (sub (char 'i number)\
    \ 'one)))\n               'one')\n         (cons ((char 'v number) (((int_to_mini_roman\
    \ number) (sub (char 'v number) 'one)))\n               'one')\n         (cons\
    \ ((char 'l number) (((int_to_mini_roman number) (sub (char 'l number) 'one)))\n\
    \               'one')\n         (cons ((char 'c number) (((int_to_mini_roman\
    \ number) (sub (char 'c number) 'one)))\n               'one')\n         (cons\
    \ ((char 'd number) (((int_to_mini_roman number) (sub (char 'd number) 'one)))\n\
    \               'one')\n         (cons ((char 'm number) (((int_to_mini_roman\
    \ number) (sub (char 'm number) 'one)))\n               'one')])]))\n", "  (cond\n\
    \    ((= number 0) (error \"Argument must be positive.\"))\n    ((< number 1000)\
    \ (error \"Argument must be between 1 and 999.\"))\n    ((< number 4000) (error\
    \ \"Argument must be between 1 and 4999.\"))\n    ((< number 5000) (error \"Argument\
    \ must be between 1 and 9999.\"))\n    ((< number 6000) (error \"Argument must\
    \ be between 1 and 7999.\"))\n    ((< number 8000) (error \"Argument must be between\
    \ 1 and 9999.\"))\n    ((< number 10000) (error \"Argument must be between 1 and\
    \ 19999.\"))\n    ((< number 12000) (error \"Argument must be between 1 and 49999.\"\
    ))\n    ((< number 14000) (error \"Argument must be between 1 and 99999.\"))\n\
    \    ((< number 16000) (error \"Argument must be between 1 and 49999.\"))\n  \
    \  ((< number 18000) (error \"Argument must be between 1 and 999999.\"))\n   \
    \ ((< number 20000) (error \"Argument must be between 1 and 999999.\"))\n    ((<\
    \ number 21000) (error \"Argument must be between 1 and 49999.\"))\n    ((< number\
    \ 24000) (error \"Argument must be between 1 and 9999999.\"))\n    ((< number\
    \ 25000) (error \"Argument must be between 1 and 9999999.\"))\n    ((< number\
    \ 26000) (error \"Argument must be between 1 and 999999.\"))\n    ((< number 28000)\
    \ (error \"Argument must be between 1 and 9999999.\"))\n    ((< number 30000)\
    \ (error \"Argument must be between 1 and 9999999.\"))\n    ((< number 32000)\
    \ (error \"Argument must be between 1 and 999999.\"))\n    ((< number 34000) (error\
    \ \"Argument must be between 1 and 9999999.\"))\n    ((< number 35000) (error\
    \ \"Argument must be between 1 and 9999999.\"))\n    ((< number 36000) (error\
    \ \"Argument must be between 1 and 999999.\"))\n    ((< number 38000) (error \"\
    Argument must be between 1 and 9999999.\"))\n    ((< number 40000) (error \"Argument\
    \ must be between 1 and 9999999.\"))\n    ((< number 42000) (error \"Argument\
    \ must be between 1 and 999999.\"))\n    ((< number 44000) (error \"Argument must\
    \ be between 1 and 9999999.\"))\n    ((< number 45000) (error \"Argument must\
    \ be between 1 and 9999999.\"))\n    ((< number 46000) (error \"Argument must\
    \ be between 1 and 999999.\"))\n    ((< number 47000) (error \"Argument must be\
    \ between 1 and 9999999.\"))\n    ((< number 48000) (", "  (if (zero? number)\n\
    \      '()\n      (cond [(<= number 10)\n             (append (list '(list '(cons\
    \ '(cons number '())))))]\n            [else\n             (append (list (int_to_mini_roman\
    \ / 10 ) (int_to_mini_roman % 10)))]))) ; <<< HERE\n</cell>\n<text>\nConvert the\
    \ number to a string of the form \"[integer]x[ii][mm]m[ii]\". Restrict\nthe number\
    \ to be a positive integer.\n\n\n</text>\n<code language=racket-lang>", "  (let\
    \ loop ([roman '()])\n    (cond [(= number 0) roman]\n          [(< number 1000)\
    \ (loop (append roman 'x))]\n          [(< number 4000)\n           (loop (append\
    \ roman 'cx))\n           (loop (append roman 'dxx))]\n          [(< number 10000)\n\
    \           (loop (append roman 'ccx))\n           (loop (append roman 'dxcx))\n\
    \           (loop (append roman 'dccx))\n           (loop (append roman 'cdxx))]\n\
    \          [(< number 40000)\n           (loop (append roman 'cccx))\n       \
    \    (loop (append roman 'dxccx))\n           (loop (append roman 'dcxcx))\n \
    \          (loop (append roman 'dcccx))\n           (loop (append roman 'cdxxx))]\n\
    \          [(< number 100000)\n           (loop (append roman 'cxxx))\n      \
    \     (loop (append roman 'dxxx))]\n          [(< number 400000)\n           (loop\
    \ (append roman 'cccx))\n           (loop (append roman 'dxccx))\n           (loop\
    \ (append roman 'dcxcx))\n           (loop (append roman 'dcccx))\n          \
    \ (loop (append roman 'cdxxx))]\n          [(< number 1000000)\n           (loop\
    \ (append roman 'cxxxx))]\n          [(< number 4000000)\n           (loop (append\
    \ roman 'cccxx))\n           (loop (append roman 'dxccx))\n           (loop (append\
    \ roman 'dcxcx))\n           (loop (append roman 'dcccx))\n           (loop (append\
    \ roman 'cdxxx))]\n          [(< number 100000000)\n           (loop (append roman\
    \ 'cxxxxx))]\n          [(< number 400000000)\n           (loop (append roman\
    \ 'cccxx))\n           (loop (append roman 'dxccx))\n           (loop (append\
    \ roman 'dcxcx))\n           (loop (append roman 'dcccx))\n           (loop (append\
    \ roman 'cdxxxx))]\n          [(< number 1000000000)\n           (loop (append\
    \ roman 'cxxxxxx))]\n          [(< number 4000000000)\n           (loop (append\
    \ roman 'cccxxx))\n           (loop (append roman 'dxccx))\n           (loop (append\
    \ roman 'dcxcx))\n           (loop (append roman ", "  (if (< number 1000)\n \
    \     (let ((roman (make-array 26 :initial-element 0)))\n        (roman (/ number\
    \ 1000))\n        (loop for i from 0 to (length roman) - 1 do\n              (cond\n\
    \                [(= i 0) (add1 roman (make-array 26 :initial-element 0))]\n \
    \               [(= i 1) (add1 (nth (sub1 roman) 0) roman)]\n                [(=\
    \ i 2) (add1 (nth (sub1 roman) 1) roman)]\n                [(= i 3) (add1 (nth\
    \ (sub1 roman) 2) roman)]\n                [(= i 4) (add1 (nth (sub1 roman) 3)\
    \ roman)]\n                [(= i 5) (add1 (nth (sub1 roman) 4) roman)]\n     \
    \           [(= i 6) (add1 (nth (sub1 roman) 5) roman)]\n                [(= i\
    \ 7) (add1 (nth (sub1 roman) 6) roman)]\n                [(= i 8) (add1 (nth (sub1\
    \ roman) 7) roman)]\n                [(= i 9) (add1 (nth (sub1 roman) 8) roman)]\n\
    \                [(= i 10) (add1 (nth (sub1 roman) 9) roman)]\n              \
    \  [(= i 11) (add1 (nth (sub1 roman) 10) roman)]\n                [(= i 12) (add1\
    \ (nth (sub1 roman) 11) roman)]\n                [(= i 13) (add1 (nth (sub1 roman)\
    \ 12) roman)]\n                [(= i 14) (add1 (nth (sub1 roman) 13) roman)]\n\
    \                [(= i 15) (add1 (nth (sub1 roman) 14) roman)]\n             \
    \   [(= i 16) (add1 (nth (sub1 roman) 15) roman)]\n                [(= i 17) (add1\
    \ (nth (sub1 roman) 16) roman)]\n                [(= i 18) (add1 (nth (sub1 roman)\
    \ 17) roman)]\n                [(= i 19) (add1 (nth (sub1 roman) 18) roman)]\n\
    \                [(= i 20) (add1 (nth (sub1 roman) 19) roman)]\n             \
    \   [(= i 21) (add1 (nth (sub1 roman) 20) roman)]\n                [(= i 22) (add1\
    \ (nth (sub1 ", "  (if (or (= number 0) (zero? number))\n      '()\n      (append\
    \ (mini_roman_iter (- number 1))\n              (mini_roman_iter number))))\n",
  "  (let loop ([i number] [num 0])\n    (cond [(< i 1000)\n           (let* ([remainder\
    \ (modulo i 1000)\n                    digits (quotient i 1000)])\n          \
    \   (loop (+ i 1) (+ num 1) (cond [(< remainder 10)\n                        \
    \                        (cons (digit->string remainder) digits)\n           \
    \                                     (else digits)]))))\n          [(zero? i)\n\
    \           (cond [(< num 1)\n                  (digit->string 0)]\n         \
    \        [else (cons 9 (digit->string (- num (+ i 1))))])]\n          [else\n\
    \           (let* ([remainder (modulo i 100)\n                    digits (quotient\
    \ i 100)])\n             (loop (+ i 1) (+ num 1) (cond [(< remainder 10)\n   \
    \                                             (cons (digit->string remainder)\
    \ digits)\n                                                (else digits)]))]))]))\n",
  "  (let ((num (roman_numeral_to_int number)))\n    (int_to_mini_roman num number)))\n",
  "  (let ((tens '(f t s m l c x)))\n    (cond ((< number 0) (error \"Number out of\
    \ range\" number))\n          ((< number 20) (list \"x\"))\n          (else (cond\
    \ ((< number 10) (cond ((= (mod number 10) 1) \"x\")\n                       \
    \                 ((eq? (mod number 10) 2) \"l\")\n                          \
    \              ((eq? (mod number 10) 3) \"c\")\n                             \
    \           ((eq? (mod number 10) 4) \"d\")\n                                \
    \        ((eq? (mod number 10) 5) \"m\")\n                                   \
    \     ((eq? (mod number 10) 6) \"x\")\n                                      \
    \  ((eq? (mod number 10) 7) \"c\")\n                                        ((eq?\
    \ (mod number 10) 8) \"l\")\n                                        ((eq? (mod\
    \ number 10) 9) \"m\")\n                                        ((eq? (mod number\
    \ 10) 10) \"x\")))\n                    (else (cond ((> number 1000) (error \"\
    Number out of range\" number))\n                              (else (let ((remainder\
    \ (mod number 100)))\n                                     (cond ((< remainder\
    \ 0) (list \"i\"))\n                                          ((= remainder 10)\
    \ \"v\")\n                                          ((= remainder 20) \"x\")\n\
    \                                          ((= remainder 30) \"l\")\n        \
    \                                  ((= remainder 40) \"c\")\n                \
    \                          ((= remainder 50) \"d\")\n                        \
    \                  ((= remainder 60) \"m\")\n                                \
    \          ((= remainder 70) \"x\")\n                                        \
    \  ((= remainder 80) \"c\")\n                                          ((= remainder\
    \ 90) \"l\")\n                                          ((= remainder 100) \"\
    m\")\n                                          ((= remainder 110) \"x\")\n  \
    \                                        ((= remainder 120) \"c\")\n         \
    \                                 ((= remainder 130) \"l\")\n                \
    \                          ((= remainder 140) \"m\")\n                       \
    \                   ((= remainder 150) \"x\")\n                              \
    \            ((= remainder 160) \"c\")\n                                     \
    \     ((= remainder 170) \"l\")\n                                          ((=\
    \ remainder 180) \"m\")\n                                          ((= remainder\
    \ 190) \"x\")\n                                          ((= remainder 200) \"\
    c\")\n                                          ((= remainder 210) \"l\")\n  \
    \                                        ((= remainder 220) \"m\")\n         \
    \                                 ((= remainder 230) \"x\")\n                \
    \                          ((= remainder 240) \"c\")\n                       \
    \                   ((= remainder 250) \"l\")\n                              \
    \            ((= remainder 260) \"m\")\n                                     \
    \     ((= remainder 270) \"x\")\n                                          ((=\
    \ remainder 280) \"c\")\n                                          ((= remainder\
    \ 290) \"l", "  (cond\n    [(= number 0) \"\"]\n    [else (concat (int_to_mini_roman\
    \ trunc_to_int (/ number 1000)) (mini_roman_letters number))]))\n", "  (let loop\
    \ ((num number) (r \"\") (i 1))\n    (if (< num 1000)\n        (if (even? num)\n\
    \            (loop (- num 1) (cons (char->string\n                           \
    \    (char->digit\n                                (modulo (+ num (* i 1000) 10000)))\
    \ r) i)\n                  (+ i 1))\n            (loop (- num 1) r i)))\n    (loop\
    \ (- num 1) r i)))\n", "  (let ((letters '((c 1) (l 2) (m 3) (d 4) (m 5) (i 6)\
    \ (xi 7))\n         (tens '((x 10) (v 9) (x 9) (c 8) (s 7) (s 6) (c 5) (s 4) (x\
    \ 4))\n         (tens '((x 10) (v 9) (x 9) (c 8) (s 7) (s 6) (c 5) (s 4) (x 4)\
    \ (s 3))\n         (hundreds '((c 100) (l 99) (m 98) (d 97) (m 96) (i 96) (xi\
    \ 95)\n                       (v 94) (c 93) (s 92) (s 91) (c 90) (s 89) (c 88)\n\
    \                       (s 87) (c 86) (s 85) (c 84) (s 83) (c 82) (s 81)\n   \
    \                    (c 80) (s 79) (c 78) (s 77) (c 76) (s 75) (c 74)\n      \
    \                 (s 73) (c 72) (s 71) (c 70) (s 69) (c 68) (s 67)\n         \
    \              (c 66) (s 65) (c 64) (s 63) (c 62) (s 61) (c 60)\n            \
    \           (s 59) (c 58) (s 57) (c 56) (s 55) (c 54) (s 53)\n               \
    \        (c 52) (s 51) (c 50) (s 49) (c 48) (s 47) (c 46)\n                  \
    \     (s 45) (c 44) (s 43) (c 42) (s 41) (c 40) (s 39)\n                     \
    \  (c 38) (s 37) (c 36) (s 35) (c 34) (s 33) (c 32)\n                       (s\
    \ 31) (c 30) (s 29) (c 28) (s 27) (c 26) (s 25)\n                       (c 24)\
    \ (s 23) (c 22) (s 21) (c 20) (s 19) (c 18)\n                       (s 17) (c\
    \ 16) (s 15) (c 14) (s 13) (c 12) (s 11)\n                       (c 10) (s 9)\
    \ (c 8) (s 7) (c 6) (s 5) (c 4) (s 3)\n                       (c 2) (s 1) (c 0)))\n\
    \    (cond ((< number 0) (error \"Invalid input: number must be positive\"))\n\
    \          ((> number 1000)\n           (error \"Invalid input: number too large\"\
    ))\n          ((eq? (modulo number 100) 0)\n           (int_to_mini_roman number))\n\
    \          (else (let ((remainder (", "  (cond\n    [(<= 0 number) '']\n    [(<=\
    \ 1000 number) (string-append \"M\"\n                                 (string_append\
    \ \"C\"\n                                              (int_to_mini_roman number)))]\n\
    \    [else (string-append \"M\"\n                       (int_to_mini_roman number\n\
    \                                       (- number (int_to_mini_roman 1))))]\n\
    \    ))\n", "  (let loop ([num number] [result ''])\n    (cond\n      [(<= num\
    \ 1000)\n       (cons result (substring 'II 'I num))]\n      [(< num 1000)\n \
    \      (let ([remainder (modulo (- num 1000) 1000)])\n         (cons result (substring\
    \ 'IV 'I remainder))])\n      [(>= num 1000)\n       (let ([remainder (modulo\
    \ (- num 1000) 1000)])\n         (cons result (substring 'IX 'I remainder))])\n\
    \      [(not (< num 1000))\n       (let ([remainder (modulo (- num 1000) 1000)])\n\
    \         (cons result (substring 'V 'I remainder))])\n      [(not (> num 1000))\n\
    \       (let ([remainder (modulo (- num 1000) 1000)])\n         (cons result (substring\
    \ 'X 'I remainder))])\n      [else\n       (let ([remainder (modulo (- num 1000)\
    \ 1000)])\n         (cons result (substring 'I 'I remainder))])]))))\n", "  (cond\n\
    \    [(< number 1) 'm]\n    [(< number 4) 'm]\n    [(< number 7) 'mm]\n    [(<\
    \ number 9) 'cm]\n    [else (let* ([remainder (modulo number 1000)])\n       \
    \         (cond\n                 [(< remainder 100) 'd]\n                 [(<\
    \ remainder 500) 'c]\n                 [(< remainder 1000) 'x]\n             \
    \    [(< remainder 5000)\n                  'v]\n                 [(< remainder\
    \ 10000) 'l]\n                 [(< remainder 50000) 'll]\n                 [(<\
    \ remainder 100000) 'c]\n                 [(< remainder 500000) 'cl]\n       \
    \          [(< remainder 1000000) 'xc]\n                 [(< remainder 5000000)\
    \ 'xcc]\n                 [(< remainder 10000000) 'xl]\n                 [(< remainder\
    \ 50000000) 'xll]\n                 [(< remainder 100000000) 'xxl]\n         \
    \        [(< remainder 500000000) 'xxll]\n                 [(< remainder 1000000000)\
    \ 'xl]\n                 [(< remainder 5000000000) 'xll]\n                 [(<\
    \ remainder 10000000000) 'xxll]\n                 [(< remainder 50000000000) 'xxxl]\n\
    \                 [(< remainder 100000000000) 'xll]\n                 [(< remainder\
    \ 500000000000) 'xll]\n                 [(< remainder 1000000000000) 'xxll]\n\
    \                 [(< remainder 5000000000000) 'xxxl]\n                 [(< remainder\
    \ 10000000000000) 'xll]\n                 [(< remainder 50000000000000) 'xll]\n\
    \                 [(< remainder 100000000000000) 'xxll]\n                 [(<\
    \ remainder 500000000000000) 'xxxl]\n                 [(< remainder 1000000000000000)\
    \ 'xll]\n                 [(< remainder 5000000000000000) 'xxxl]\n           \
    \      [(< remainder 1000000000000000000) 'xll]\n                 [(< remainder\
    \ 50000000000000000) 'xxxl]\n                 [(< remainder 10000000000000000000)\
    \ 'xll]\n                 [(< remainder 500000000000000000) 'xxxl]\n         \
    \        [(< remainder 100000000000000000000) 'xll]\n                 [(< remainder\
    \ 50000000000000000000) 'xxxl]\n                 [(< remainder 1000000000000000000000)\
    \ 'xll]\n                 [(< remainder ", "  (if (<= number 1000)\n      (cond\
    \ [(< number 1000) (int_to_mini_roman (/ number 1000))]\n            [(< number\
    \ 100) (int_to_mini_roman (/ number 100))]\n            [else (mini_roman_numeral\
    \ (- number 1000))]))\n  (mini_roman_numeral (- number 1000)))\n", "  (let loop\
    \ ((num (if (= number 0) \"0\" number)))\n    (cond\n      [(< num \"999\") (append\
    \ (substring num \"1\" #:end \"9\") \"x\")]\n      [(< num \"100\") (append (substring\
    \ num \"1\" #:end \"9\") \"c\")]\n      [(< num \"400\") (append (substring num\
    \ \"1\" #:end \"9\") \"d\")]\n      [(< num \"900\") (append (substring num \"\
    1\" #:end \"9\") \"m\")]\n      [(< num \"900\") (append (substring num \"1\"\
    \ #:end \"9\") \"i\")]\n      [(< num \"900\") (append (substring num \"1\" #:end\
    \ \"9\") \"v\")]\n      [(< num \"900\") (append (substring num \"1\" #:end \"\
    9\") \"n\")]\n      [(< num \"900\") (append (substring num \"1\" #:end \"9\"\
    ) \"x\")]\n      [(< num \"900\") (append (substring num \"1\" #:end \"9\") \"\
    m\")]\n      [(< num \"900\") (append (substring num \"1\" #:end \"9\") \"i\"\
    )]\n      [(< num \"900\") (append (substring num \"1\" #:end \"9\") \"v\")]\n\
    \      [(< num \"900\") (append (substring num \"1\" #:end \"9\") \"n\")]\n  \
    \    [(< num \"900\") (append (substring num \"1\" #:end \"9\") \"x\")]\n    \
    \  [(< num \"900\") (append (substring num \"1\" #:end \"9\") \"m\")]\n      [(<\
    \ num \"900\") (append (substring num \"1\" #:end \"9\") \"i\")]\n      [(< num\
    \ \"900\") (append (substring num \"1\" #:end \"9\") \"v\")]\n      [(< num \"\
    900\") (append (substring num \"1\" #:end \"9\") \"n\")]\n      [(< num \"900\"\
    ) (append (substring num \"1\" #:end \"9\") \"x\")]\n      [(< num \"900\") (append\
    \ (substring num \"1\" #:end \"9\") \"m\")]\n      [(< num \"900\") (append (substring\
    \ num \"1\" #:end ", "  (roman-numeral->string number))\n", "  (cond\n    [(<\
    \ number 1)\n     (error \"Number to roman conversion out of range ~a\" number)]\n\
    \    [else (cond [(= (modulo number 1000) 0)\n                (concat \"i\" (int_to_mini_roman\
    \ floor (/ number 1000)))]\n                  [(= (modulo number 500) 0)\n   \
    \             (concat \"v\" (int_to_mini_roman floor (/ number 500)))]\n     \
    \             [(= (modulo number 100) 0)\n                (concat \"c\" (int_to_mini_roman\
    \ floor (/ number 100)))]\n                  [(= (modulo number 50) 0)\n     \
    \           (concat \"d\" (int_to_mini_roman floor (/ number 50)))]\n        \
    \          [(= (modulo number 10) 0)\n                (concat \"m\" (int_to_mini_roman\
    \ floor (/ number 10)))]\n                  [(= (modulo number 5) 0)\n       \
    \         (concat \"l\" (int_to_mini_roman floor (/ number 5)))]\n           \
    \       [(= (modulo number 1) 0)\n                (concat \"x\" (int_to_mini_roman\
    \ floor (/ number 1)))]\n                  [(< number 1000)\n                (error\
    \ \"Number to roman conversion out of range ~a\" number)]\n                  [(>\
    \ number 1)\n                (error \"Number to roman conversion out of range\
    \ ~a\" number)]\n              )\n    ]\n  )\n)\n", "  (let ([result '()])\n \
    \   (if (< number 0)\n        '()\n        (let ([remainder (modulo number 10)])\n\
    \          (cond [(= remainder 0)\n                 (reverse result)\n       \
    \          (append result (list->string number))]\n                [else (int_to_mini_roman\
    \ remainder)])))))\n", "  (cond\n    ((= number 0) \"\")\n    ((< number 100)\
    \ \"\")\n    ((= (mod number 100) 0) \"\")\n    ((< number 400) (string-append\
    \ \"c\" (int_to_mini_roman \n                                     (floor (/ number\
    \ 100))))\n    ((< number 500) (string-append \"i\" (int_to_mini_roman \n    \
    \                                 (floor (/ number 100))))\n    ((< number 500)\
    \ (string-append \"x\" (int_to_mini_roman \n                                 \
    \    (floor (/ number 100))))\n    ((< number 1000) (string-append \"l\" (int_to_mini_roman\
    \ \n                                      (floor (/ number 100))))\n    ((< number\
    \ 1000) (string-append \"v\" (int_to_mini_roman \n                           \
    \           (floor (/ number 100))))\n    ((< number 1000) (string-append \"d\"\
    \ (int_to_mini_roman \n                                      (floor (/ number\
    \ 100))))\n    ((< number 1000) (string-append \"c\" (int_to_mini_roman \n   \
    \                                   (floor (/ number 100))))\n    ((< number 1000)\
    \ (string-append \"m\" (int_to_mini_roman \n                                 \
    \     (floor (/ number 100))))\n    ((< number 1000) (string-append \"i\" (int_to_mini_roman\
    \ \n                                      (floor (/ number 100))))\n    ((< number\
    \ 1000) (string-append \"n\" (int_to_mini_roman \n                           \
    \           (floor (/ number 100))))\n    ((< number 1000) (string-append \"x\"\
    \ (int_to_mini_roman \n                                      (floor (/ number\
    \ 100))))\n    ((< number 1000) (string-append \"l\" (int_to_mini_roman \n   \
    \                                   (floor (/ number 100))))\n    ((< number 1000)\
    \ (string-append \"v\" (int_to_mini_roman \n                                 \
    \     (floor (/ number 100))))\n    ((< number 1000) (string-append \"d\" (int_to_mini_roman\
    \ \n                                      (floor (/ number 100))))\n    ((< number\
    \ 1000) (string-append \"c\" (int_to_mini_roman \n                           \
    \           (floor (/ number 100))))\n    ((< number 1000) (string-append \"m\"\
    \ (int_to_mini_roman \n                                      (floor (/ number\
    \ 100))))\n    ((< number 1000) (string-append \"i\" (int_to_mini_roman \n   \
    \                                   (floor (/ number 100))))\n    ((< number 1000)\
    \ (string-append \"n\" (int_to_mini_roman \n                                 \
    \     (floor (/ number 100))))\n", "  (cond\n    [(< number 1) (error \"Argument\
    \ must be positive\")]\n    [(= number 0) \"\"]\n    [else\n     (cond\n     \
    \  [(< number 1000) (cons (string->symbol (- number 1000)\n                  \
    \                       \"x\")\n                       (int_to_mini_roman number))\n\
    \      (< number 400) (cons (string->symbol (- number 400)\n                 \
    \                        \"l\")\n                        (int_to_mini_roman number))\n\
    \      (< number 900) (cons (string->symbol (- number 900)\n                 \
    \                        \"c\"\n                                         \"x\"\
    )\n                        (int_to_mini_roman number))\n      (< number 1400)\
    \ (cons (string->symbol (- number 1400)\n                                    \
    \     \"i\"\n                                         \"x\")\n               \
    \         (int_to_mini_roman number))\n      (< number 1900) (cons (string->symbol\
    \ (- number 1900)\n                                         \"x\"\n          \
    \                               \"i\")\n                        (int_to_mini_roman\
    \ number))\n      (< number 2400) (cons (string->symbol (- number 2400)\n    \
    \                                     \"l\"\n                                \
    \         \"i\")\n                        (int_to_mini_roman number))\n      (<\
    \ number 2999) (cons (string->symbol (- number 2999)\n                       \
    \                  \"c\"\n                                         \"l\"\n   \
    \                                      \"i\"\n                               \
    \          \"x\")\n                        (int_to_mini_roman number))\n     \
    \ (< number 3400) (cons (string->symbol (- number 3400)\n                    \
    \                     \"i\"\n                                         \"l\"\n\
    \                                         \"x\"\n                            \
    \             \"i\")\n                        (int_to_mini_roman number))\n  \
    \    (< number 3999) (cons (string->symbol (- number 3999)\n                 \
    \                        \"c\"\n                                         \"l\"\
    \n                                         \"i\"\n                           \
    \              \"x\"\n                                         \"x\")\n      \
    \                  (int_to_mini_roman number))\n      (< number 4000) (cons (string->symbol\
    \ (- number 4000)\n                                         \"l\"\n          \
    \                               \"i\"\n                                      \
    \   \"x\"\n                                         \"x\")\n                 \
    \       (int_to_mini_roman number))\n      (< number 4999) (cons (string->symbol\
    \ (- number 4999)\n                                         \"c\"\n          \
    \                               \"l\"\n                                      \
    \   \"i\"\n                                         \"x\"\n                  \
    \                       \"x\"\n                                         \"x\"\
    )\n                        (int_to_mini_roman number))\n      (< number 5000)\
    \ (cons (string->symbol (- number 5000)\n                                    \
    \     \"l\"\n", "  (cond\n    [(= number 0) '0]\n    [(< number 100) (string-append\
    \ \"i\" (string-append \"v\" (string-append \"c\" (string-append \"n\" (int_to_mini_roman\
    \ floor (/ number 100)))) (int_to_mini_roman floor (/ number 10))))]\n    [else\
    \ (cond [(< number 900) (string-append \"x\" (int_to_mini_roman floor (/ number\
    \ 900)))]\n              [(< number 5000) (string-append \"c\" (int_to_mini_roman\
    \ floor (/ number 5000)))]\n              [(< number 4000) (string-append \"d\"\
    \ (int_to_mini_roman floor (/ number 4000)))]\n              [(< number 3000)\
    \ (string-append \"e\" (int_to_mini_roman floor (/ number 3000)))]\n         \
    \     [(< number 2000) (string-append \"f\" (int_to_mini_roman floor (/ number\
    \ 2000)))]\n              [(< number 1000) (string-append \"g\" (int_to_mini_roman\
    \ floor (/ number 1000)))]\n              [(< number 900) (string-append \"h\"\
    \ (int_to_mini_roman floor (/ number 900)))]\n              [(< number 5000) (string-append\
    \ \"i\" (int_to_mini_roman floor (/ number 5000)))]\n              [(< number\
    \ 4000) (string-append \"j\" (int_to_mini_roman floor (/ number 4000)))]\n   \
    \           [(< number 3000) (string-append \"k\" (int_to_mini_roman floor (/\
    \ number 3000)))]\n              [(< number 2000) (string-append \"l\" (int_to_mini_roman\
    \ floor (/ number 2000)))]\n              [(< number 1000) (string-append \"m\"\
    \ (int_to_mini_roman floor (/ number 1000)))]\n              [(< number 900) (string-append\
    \ \"n\" (int_to_mini_roman floor (/ number 900)))]\n              [(< number 5000)\
    \ (string-append \"o\" (int_to_mini_roman floor (/ number 5000)))]\n         \
    \     [(< number 4000) (string-append \"p\" (int_to_mini_roman floor (/ number\
    \ 4000)))]\n              [(< number 3000) (string-append \"q\" (int_to_mini_roman\
    \ floor (/ number 3000)))]\n              [(< number 2000) (string-append \"r\"\
    \ (int_to_mini_roman floor (/ number 2000)))", "  (cond\n    [(> number 1) (int_to_mini_roman\
    \ number) (make-string 1 number #\\0))]\n    [(<= number 1000)\n     (make-string\
    \ 1 number #\\0)\n     (cond [(= (% number 100) 49) '(I V) (cons 'I 'V) (cons\
    \ 'V 'I)]\n           [(= (% number 100) 50) '(II X) (cons 'II 'X) (cons 'X 'II)]\n\
    \           [(= (% number 100) 51) '(III L) (cons 'III 'L) (cons 'L 'III)]\n \
    \          [(= (% number 100) 52) '(IV XL) (cons 'IV 'XL) (cons 'XL 'IV)]\n  \
    \         [(= (% number 100) 53) '(V XC) (cons 'V 'XC) (cons 'XC 'V)]\n      \
    \     [(= (% number 100) 54) '(VCD CCL) (cons 'VCD 'CCL) (cons 'CCL 'VCD)]\n \
    \          [(= (% number 100) 55) '(D CD CC) (cons 'D 'CD CC) (cons 'C 'CD CD)]\n\
    \           [(= (% number 100) 56) '(DC CL) (cons 'DC CL) (cons 'L CL)]\n    \
    \       [(= (% number 100) 57) '(C XC) (cons 'C 'XC) (cons 'XC 'C)]\n        \
    \   [(= (% number 100) 58) '(CD CCC) (cons 'CD CCC) (cons 'CCC 'CD)]\n       \
    \    [(= (% number 100) 59) '(C CC CCC) (cons 'C 'CC CCC) (cons 'CCC 'C)]\n  \
    \         [(= (% number 100) 60) '(LX) (cons 'LX 'X) (cons 'X 'LX)]\n        \
    \   [(= (% number 100) 61) '(LXL) (cons 'LXL 'XL) (cons 'XL 'LXL)]\n         \
    \  [(= (% number 100) 62) '(XC) (cons 'XC 'C) (cons 'C 'XC)]\n           [(= (%\
    \ number 100) 63) '(XCD CCCX) (cons 'XCD CCCX) (cons 'CCCX 'XCD)]\n          \
    \ [(= (% ", "  (let loop ((n number)\n             (s \"\")\n             (acc\
    \ \"\"))\n    (cond ((zero? n) (append acc s))\n          ((< n 1000)\n      \
    \     (loop (quotient n 1000)\n                 (append s (reverse (mini_roman_to_int\
    \ (quotient n 1000)))))\n           (loop (quotient n 1000)\n                \
    \ (append acc (mini_roman_to_int (quotient n 1000)))))\n          (else\n    \
    \       (loop (quotient n 10)\n                 (append s (reverse (mini_roman_to_int\
    \ (quotient n 10)))))\n           (loop (quotient n 10)\n                 (append\
    \ acc (mini_roman_to_int (quotient n 10)))))))\n", "  (cond\n    [(< 1 number)\
    \ (error 'int_to_mini_roman \"input must be positive\")]\n    [(< number 1000)\
    \ (error 'int_to_mini_roman \"input must be less than 1000\")]\n    [else (cond\n\
    \            [(= (mod number 100) 0)\n             (cond\n              [(= (mod\
    \ number 500) 0)\n               (cond\n                 [(= (mod number 1000)\
    \ 0)\n                  (cond\n                   [(= (mod number 5000) 0)\n \
    \                   (cond\n                     [(= (mod number 100000) 0)\n \
    \                    (cond\n                      [(= (mod number 1000000) 0)\n\
    \                       (error 'int_to_mini_roman \"input too large\")]\n    \
    \                  [else (error 'int_to_mini_roman \"input too large\")]\n   \
    \                  )]\n                   [else (error 'int_to_mini_roman \"input\
    \ too large\")]\n                  )]\n                 [else (error 'int_to_mini_roman\
    \ \"input too large\")]\n               )]\n              [else (error 'int_to_mini_roman\
    \ \"input too large\")]\n             )]\n            [else (error 'int_to_mini_roman\
    \ \"input too large\")]\n          )]\n    [else (error 'int_to_mini_roman \"\
    input too large\")]\n   ))\n", "  (cond\n    [(<= 1 number)  '']\n    [(< number\
    \ 1000)  (cons (string->char (mod-from-positive number 1000))\n              \
    \              (int_to_mini_roman number))])\n    [else          '']))\n", " \
    \ (cond [(<= number 1000)\n         (string-append (substring (roman (modulo (+\
    \ number 1) 1000)) 0 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 2 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 3 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 4 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 5 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 6 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 7 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 8 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 9 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 10 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 11 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 12 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 13 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 14 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 15 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 16 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 17 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 18 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 19 1\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 20 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 21 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 22 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 23 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 24 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 25 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 26 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 27 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 28 1)\n                        (substring (roman (modulo (+\
    \ number 1) 1000)) 29 1)\n                        (substring (roman (modulo",
  "  (cond\n    [(< 1 number) \"\"]\n    [(< 1000 number) (string-append (int_to_mini_roman\
    \ / 10) (int_to_mini_roman % 10))]\n    [else (if (< 1000 number) (string-append\
    \ (int_to_mini_roman / 100) (int_to_mini_roman % 100)) (string-append (int_to_mini_roman\
    \ / 10) (int_to_mini_roman % 10)))))\n", "  (cond [(< number 1000) (string-append\
    \ (int_to_mini_roman floor (- number 1000)) 'x)]\n        [else (let ([num (floor\
    \ number)])\n              (string-append (int_to_mini_roman num) (mini_roman_numeral\
    \ number))])])) ;; #lang racket\n", "  (cond\n    ((= number 0)'')\n    ((< number\
    \ 1000)\n     (cons (char (mod(number 1000))) (int_to_mini_roman number)))\n \
    \   ((> number 1000)\n     (let ((hundreds (/ number 100)))\n       (cond\n  \
    \       ((> hundreds 0)\n          (cons (char (mod(hundreds 100))) 'thousand))\n\
    \         ((= hundreds 0)\n          (let ((tens (/ hundreds 10)))\n         \
    \   (cond\n              ((> tens 0)\n               (cons (char (mod(tens 10)))\
    \ 'ten))\n              ((= tens 0)\n               (char 'one)))))\n        \
    \ ((< hundreds 0)\n          (cons (char (mod hundreds 100)) 'hundred))\n    \
    \     ((= hundreds 0)\n          (let ((ones (/ hundreds 1)))\n            (cond\n\
    \              ((> ones 0)\n               (cons (char (mod(ones 1))) 'one))\n\
    \              ((= ones 0)\n               (char 'zero)))))))))\n</code>\n<|/\
    \ a tags=racket,roman-numerals,scheme dscore=2 |>\n<| a dscore=1 |>\nI have just\
    \ found this page and I am working on an Racket program that converts a Roman\
    \ number to its actual value (like M is 1000 and IV is 4).\nI thought it could\
    \ be interesting to implement it into my own Racket program and I got it to work.\n\
    The Roman number system is described in this link: http://en.wikipedia.org/wiki/Roman_numerals\n\
    The code below converts a Roman number to its actual value. I have implemented\
    \ this by taking the Roman numeral as a string, so I first converted the Roman\
    \ numeral into a string, and then converted each character into a numerical value\
    \ using char->digit.\n<code>", "  (cond\n    [(< number 1000) (list number)]\n\
    \    [(< number 10000) (list (sub (number 1000) 100) (sub (number 100) 10))]\n\
    \    [else (int_to_mini_roman number)]))\n", "  (cond [(< number 0) \"0\"]\n \
    \       [(< number 100) \"M\"]\n        [(< number 500) \"D\"]\n        [(< number\
    \ 1000) \"C\"]\n        [(< number 2000) \"L\"]\n        [(< number 4000) \"X\"\
    ]\n        [else (string (string-to-int (number)))]))\n", "  (let ((roman '()))\n\
    \    (while (> number 0)\n      (cond\n        ((= (mod number 100) 0) (set! roman\
    \ '(xs)))\n        ((= (mod number 100) 1) (set! roman '(xl)))\n        ((= (mod\
    \ number 100) 2) (set! roman '(xl)))\n        ((= (mod number 100) 3) (set! roman\
    \ '(xl)))\n        ((= (mod number 100) 4) (set! roman '(xl)))\n        ((= (mod\
    \ number 100) 5) (set! roman '(vi)))\n        ((= (mod number 100) 6) (set! roman\
    \ '(vi)))\n        ((= (mod number 100) 7) (set! roman '(vi)))\n        ((= (mod\
    \ number 100) 8) (set! roman '(vi)))\n        ((= (mod number 100) 9) (set! roman\
    \ '(vi)))\n        ((= (mod number 100) 10) (set! roman '(vi)))\n        ((= (mod\
    \ number 100) 11) (set! roman '(xi)))\n        ((= (mod number 100) 12) (set!\
    \ roman '(xi)))\n        ((= (mod number 100) 13) (set! roman '(xi)))\n      \
    \  ((= (mod number 100) 14) (set! roman '(xi)))\n        ((= (mod number 100)\
    \ 15) (set! roman '(xi)))\n        ((= (mod number 100) 16) (set! roman '(xi)))\n\
    \        ((= (mod number 100) 17) (set! roman '(xi)))\n        ((= (mod number\
    \ 100) 18) (set! roman '(xi)))\n        ((= (mod number 100) 19) (set! roman '(xi)))\n\
    \        ((= (mod number 100) 20) (set! roman '(xi)))\n        ((= (mod number\
    \ 100) 21) (set! roman '(xi)))\n        ((= (mod number 100) 22) (set! roman '(xi)))\n\
    \        ((= (mod number 100) 23) (set! roman '(xi)))\n        ((= (mod number\
    \ 100) 24) (set! roman '(xi)))\n        ((= (mod number 100) 25) (set! roman '(xi)))\n\
    \        ", "  (cond [(< number 1) '']\n        [(< number 1000) (int_to_mini_roman\
    \ number)\n         (append (substring 'vain 'roman (int_to_roman_roman number)))]\n\
    \        [else (append (substring 'Ixx 'roman 'x (int_to_roman_roman number)))]))\n",
  "  (cond\n    [(<= number 1) '']\n    [(= number 1000) (concat (list (string->list\
    \ (list 'm)))\n                              (sub1 number))\n     (return (concat\
    \ (list (string->list (list 'm))\n                          (sub1 number)))\n\
    \            (string->list \"\"))]\n    [(= number 400) (string->list (concat\
    \ [list (string->list (list 'd))\n                                          (sub1\
    \ number)]))]\n    [(= number 400) (sub1 number (string->list (list 'd)))]\n \
    \   [else (string->list (concat [list (string->list (list 'c))\n             \
    \                   (sub1 number)]))]))\n", "  (define (helper n str)\n    (if\
    \ (= n 0)\n        str\n        (helper (quotient n 10) (append str\n        \
    \                               (cons (if (> n 0)\n                          \
    \                      'M'\n                                                'I')\n\
    \                                       (int_to_mini_roman n)))))\n  (helper number\
    \ '()))\n</cell>\n<cell>", "  (let loop ((number number)\n             (roman-form\
    \ '()))\n    (cond [(= number 0)\n           (append (list roman-form))\n    \
    \       (loop (- number 1)\n                 (cons roman-form '()))]\n       \
    \   [else\n           (cond [(< number 1000)\n                  (loop (+ number\
    \ 1)\n                        (cons roman-form '()))]\n                 [else\
    \ ; if (number < 1000)\n                     (loop (+ number 1)\n            \
    \              (append roman-form))]))]))\n", "  (cond [(= number 0)   '']\n \
    \       [(= number 1)   'm']\n        [(= number 2)   'mm']\n        [(= number\
    \ 3)   'MMM']\n        [(= number 4)   'MMMM']\n        [(= number 5)   'MMMMM']\n\
    \        [(= number 6)   'MMMMMM']\n        [(= number 7)   'MMMMMMM']\n     \
    \   [(= number 8)   'MMMMMMMM']\n        [(= number 9)   'MMMMMMMMM']\n      \
    \  [(= number 10) 'MMMMMMMMMM']\n        [(= number 11) 'MMMMMMMMMMM']\n     \
    \   [(= number 12) 'MMMMMMMMMMMM']\n        [(= number 13) 'MMMMMMMMMMMMM']\n\
    \        [(= number 14) 'MMMMMMMMMMMMMM']\n        [(= number 15) 'MMMMMMMMMMMMMMM']\n\
    \        [(= number 16) 'MMMMMMMMMMMMMMMM']\n        [(= number 17) 'MMMMMMMMMMMMMMMMM']\n\
    \        [(= number 18) 'MMMMMMMMMMMMMMMMMM']\n        [(= number 19) 'MMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 20) 'MMMMMMMMMMMMMMMMMMMM']\n        [(= number 21) 'MMMMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 22) 'MMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 23) 'MMMMMMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 24) 'MMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 25) 'MMMMMMMMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 26) 'MMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 27)\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 28) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 29) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 30)\
    \ 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 31) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 32) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number\
    \ 33) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 34) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n\
    \        [(= number 35) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number\
    \ 36) 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM']\n        [(= number 37) 'MMMM",
  "  (cond\n    [(< number 1)\n     (error 'int_to_mini_roman \"number too small:\
    \ ~a\" number)]\n    [(<= number 1000)\n     (string-append (number->mini_roman\
    \ number)\n                    (string-downcase (number->mini_roman number 1000\
    \ #false)))]\n    [(> number 1000)\n     (string-append (number->mini_roman number)\n\
    \                    (string-downcase (number->mini_roman number 1000 #false))\n\
    \                    (number->mini_roman number (+ number 1000)))]))\n", "  (let\
    \ roman_numerals ((i number) (result '()))\n    (cond ((< number 1) '())\n   \
    \       ((< i 9) (string-append (roman_numerals i (append result '(') )))\n  \
    \        ((< i 27) (string-append (roman_numerals (- i 9) result (append 'x' ))\
    \ ))\n          ((< i 50) (string-append (roman_numerals (- i 27) result (append\
    \ 'vi' )) ))\n          ((< i 75) (string-append (roman_numerals (- i 50) result\
    \ (append 'ix' )) ))\n          ((< i 100) (string-append (roman_numerals (- i\
    \ 75) result (append 'xvi' )) ))\n          ((< i 121) (string-append (roman_numerals\
    \ (- i 100) result (append 'xix' )) ))\n          ((< i 150) (string-append (roman_numerals\
    \ (- i 121) result (append 'cli' )) ))\n          ((< i 170) (string-append (roman_numerals\
    \ (- i 150) result (append 'cde' )) ))\n          ((< i 200) (string-append (roman_numerals\
    \ (- i 170) result (append 'ccx' )) ))\n          ((< i 225) (string-append (roman_numerals\
    \ (- i 200) result (append 'ccc' )) ))\n          ((< i 250) (string-append (roman_numerals\
    \ (- i 225) result (append 'cdx' )) ))\n          ((< i 275) (string-append (roman_numerals\
    \ (- i 250) result (append 'cdd' )) ))\n          ((< i 300) (string-append (roman_numerals\
    \ (- i 275) result (append 'ccdx' )) ))\n          ((< i 325) (string-append (roman_numerals\
    \ (- i 300) result (append 'ccc' )) ))\n          ((< i 350) (string-append (roman_numerals\
    \ (- i 325) result (append 'cdx' )) ))\n          ((< i 375) (string-append (roman_numerals\
    \ (- i 350) result (append 'cdd' )) ))\n          ((< i 400) (string-append (roman_numerals\
    \ (- i 375) result (append 'ccdx' )) ))\n          ((< i ", "  (if (> number 0)\n\
    \      (let ((value 'i)) (set! value (- number)) (let ((value (* value 'i))) (cons\
    \ (string value) '()))\n      false))\n", "  (roman (quotient number 100) 'im\
    \ (quotient (- number 100) 10) (quotient (- number 1000) 1)))\n", "  (if (< number\
    \ 1000)\n      (let ((roman-digits (make-hash (string-length (string->list '(xxx)))))\n\
    \            (roman-digit-count 0))\n        (roman-digits \n         (let ((i\
    \ (modulo number 1000)))\n           (roman-digit-count (+ roman-digit-count 1))\n\
    \           (when (< i 1000)\n             (string-set! roman-digits (string-ref\
    \ '(xxx) i)\n                             (let ((j (modulo i 1000)))\n       \
    \                       (roman-digit-count (+ roman-digit-count 1))\n        \
    \                      (when (< j 1000)\n                                (string-set!\
    \ roman-digits (string-ref roman-digits j)\n                                 \
    \                 (let ((k (modulo j 1000)))\n                               \
    \                     (roman-digit-count (+ roman-digit-count 1))\n          \
    \                                          (when (< k 1000)\n                \
    \                                      (string-set! roman-digits\n           \
    \                                                 roman-digits (string-ref roman-digits\
    \ k)\n                                                            (let ((l (modulo\
    \ k 1000)))\n                                                              (roman-digit-count\
    \ (+ roman-digit-count 1))\n                                                 \
    \             (string-append\n                                               \
    \                  (string->list\n                                           \
    \                        '(mm l))))))))))\n           (string-set! roman-digits\
    \ '(mm i) '(i x))\n           roman-digit-count)\n        roman-digits)\n    (let\
    \ ((roman-digits (make-hash (string-length (string->list '(xxx)))))\n        \
    \  (roman-digit-count 0))\n      (roman-digits \n       (let ((i (modulo number\
    \ 1000)))\n         (roman-digit-count (+ roman-digit-count 1))\n         (when\
    \ (< i 1000)\n           (string-set! roman-digits (string-ref '(xxx) i)\n   \
    \                       (let ((j (modulo i 1000)))\n                         \
    \   (roman-digit-count (+ roman-digit-count 1))\n                            (when\
    \ (< j 1000)\n                              (string-set! roman-digits (string-ref\
    \ roman-digits j)\n                                                (let ((k (modulo\
    \ j 1000)))\n                                                  (roman-digit-count\
    \ (+ roman-digit-count 1))\n                                                 \
    \ (when (< k 1000)\n                                                    (string-set!\
    \ roman-digits\n                                                             \
    \ roman-digits (string-ref roman-digits k)\n                                 \
    \                             (let ((l (modulo ", "  (cond\n    [(= number 1)\
    \ 'i']\n    [(= number 7) 'ii']\n    [(= number 8) 'iii']\n    [(= number 9) 'iv']\n\
    \    [(= number 10) 'v']\n    [(= number 20) 'vi']\n    [(= number 30) 'vii']\n\
    \    [(= number 40) 'viii']\n    [(= number 50) 'ix']\n    [(= number 60) 'x']\n\
    \    [(= number 90) 'xix']\n    [else (int_to_mini_roman number)]\n  )\n)\n",
  "  (let ((letters (make-array '(1000) #:element-type 'symbol)))\n    (for ((i number))\n\
    \      (let* ((a (/ (- number i) 100) 10)\n             (b (- i a)))\n       \
    \ (set! letters a)\n        (set! letters (set! letters (aref letters b) car letters))\n\
    \        (set! letters (set! letters (aref letters a) cdr letters))\n        (set!\
    \ letters (append letters 'i)))\n    (string letters)))\n", "  (define (iter current\
    \ numeral roman)\n    (if (> current 1000)\n        roman\n        (iter (+ current\
    \ 1) (cons numeral roman) \n               (reverse roman))))\n  (iter number\
    \ '() 'mcm))\n", "  (cond\n    [(> number 0)\n     (string-append (string-to-list\
    \ (num-to-string number))\n                  (if (>= number (floor (/ number 1000)))\n\
    \                      (cons \"M\" (int_to_mini_roman number (- number 1000)))\n\
    \                      (cons \"D\" (int_to_mini_roman number (- number 1000))))]\n\
    \    [(= number 0)\n     (cons \"0\" (int_to_mini_roman 0 (+ 1 number)))]\n  \
    \  [else\n     (int_to_mini_roman number (- number 1000))]))\n", "  (if (= number\
    \ 0)\n      '0'\n      (let ((remainder (modulo number 1000000)))\n        (if\
    \ (< remainder 1000)\n            (string-append (int_to_mini_roman remainder)\
    \ 'x'\n                           (int_to_mini_roman (remainder - 1000)))\n  \
    \          (int_to_mini_roman number 'xvi')))))\n", "  (cond\n    [(< number 1)\
    \ '']\n    [(< number 1000) (string-append \"M\" (int_to_mini_roman floor (- number\
    \ 1)))]\n    [else\n     (string\n      (cond\n\t[(= number 0) '']\n\t[(= number\
    \ 1) 'i']\n\t[(= number 2) 'ii']\n\t[(= number 3) 'iii']\n\t[(= number 4) 'iv']\n\
    \t[(= number 5) 'v']\n\t[(= number 6) 'vi']\n\t[(= number 7) 'vii']\n\t[(= number\
    \ 8) 'viii']\n\t[(= number 9) 'ix']\n\t[(= number 10) 'x']\n\t[(= number 11) 'xix']\n\
    \t[(= number 12) 'xixi']\n\t[(= number 13) 'xixii']\n\t[(= number 14) 'xixiii']\n\
    \t[(= number 15) 'xixiv']\n\t[(= number 16) 'xixv']\n\t[(= number 17) 'xixvi']\n\
    \t[(= number 18) 'xixvii']\n\t[(= number 19) 'xixviii']\n\t[(= number 20) 'xixix']\n\
    \t[(= number 21) 'xixixi']\n\t[(= number 22) 'xixixii']\n\t[(= number 23) 'xixixiii']\n\
    \t[(= number 24) 'xixixiv']\n\t[(= number 25) 'xixixv']\n\t[(= number 26) 'xixixvi']\n\
    \t[(= number 27) 'xixixvii']\n\t[(= number 28) 'xixixviii']\n\t[(= number 29)\
    \ 'xixixix']\n\t[(= number 30) 'xixixixi']\n\t[(= number 31) 'xixixixii']\n\t\
    [(= number 32) 'xixixixiii']\n\t[(= number 33) 'xixixixiv']\n\t[(= number 34)\
    \ 'xixixixv']\n\t[(= number 35) 'xixixixvi']\n\t[(= number 36) 'xixixixvii']\n\
    \t[(= number 37) 'xixixixviii']\n\t[(= number 38) 'x", "  (cond [(<= number 0)\
    \ \"\"]\n        [(= number 1) \"i\"]\n        [(< number 1000) \"x\" (int_to_mini_roman\
    \ floor (/ number 100))]\n        [(< number 4000) \"l\" (int_to_mini_roman floor\
    \ (/ number 400))]\n        [(< number 6000) \"c\" (int_to_mini_roman floor (/\
    \ number 600))]\n        [else (int_to_mini_roman floor (/ number 1000))]))\n",
  "  (define (roman-list number)\n    (cond\n      [(<= number 1) (list (list 1 'i)\
    \ (list 'i) (list 'i))]\n      [(<= number 2) (list (list 1 'ii) (list 'ii) (list\
    \ 'ii))] \n      [(<= number 3) (list (list 1 'iii) (list 'iii) (list 'iii))]\n\
    \      [(<= number 4) (list (list 1 'iv) (list 'iv) (list 'iv))] \n      [(<=\
    \ number 5) (list (list 1 'v) (list 'v) (list 'v))] \n      [(<= number 6) (list\
    \ (list 1 'vi) (list 'vi) (list 'vi))] \n      [(<= number 7) (list (list 1 'vii)\
    \ (list 'vii) (list 'vii))] \n      [(<= number 8) (list (list 1 'viii) (list\
    \ 'viii) (list 'viii))] \n      [(<= number 9) (list (list 1 'ix) (list 'ix) (list\
    \ 'ix))] \n      [(<= number 10) (list (list 1 'x) (list 'x) (list 'x))]\n   \
    \   [(<= number 11) (list (list 1 'xi) (list 'xi) (list 'xi))] \n      [(<= number\
    \ 12) (list (list 1 'xiv) (list 'xiv) (list 'xiv))] \n      [(<= number 13) (list\
    \ (list 1 'xv) (list 'xv) (list 'xv))] \n      [(<= number 14) (list (list 1 'xvi)\
    \ (list 'xvi) (list 'xvi))] \n      [(<= number 15) (list (list 1 'xvii) (list\
    \ 'xvii) (list 'xvii))] \n      [(<= number 16) (list (list 1 'xviii) (list 'xviii)\
    \ (list 'xviii))] \n      [(<= number 17) (list (list 1 'ixx) (list 'ixx) (list\
    \ 'ixx))]\n      [(<= number 18) (list (list 1 'xx) (list 'xx) (list 'xx))] \n\
    \      [(<= number 19) (list (list 1 'xxi) (list 'xxi) (list 'xxi))] \n      [(<=\
    \ number 20) (list (list 1 'xxii) (list 'xxii) (list 'xxii))] \n      [(<= number\
    \ 21) (list (list 1 'xxiv) (list 'xxiv) (list 'xxiv))] \n      [(<= number 22)\
    \ (list (", "  (cond\n    [(= number 0) 'zero']\n    [(= number 1) 'one']\n  \
    \  [(= number 2) 'two']\n    [(< number 1000) (int_to_mini_roman number-2)(cons\
    \ (- number 1000) 'hundred thousand'(cons (- number 1000) 'hundred thousand'))]\n\
    \    [else (int_to_mini_roman number-2)(cons (- number 1000) 'hundred thousand'(cons\
    \ (- number 1000) 'hundred thousand')))]\n)\n", "  (let ((num (modulo number 1000)))\n\
    \    (cond\n      ((< num 1000) (set! num (/ number 1000))\n        (if (< num\
    \ 100) (set! num (/ num 100))\n          (set! num (/ num 10))))\n      (else\
    \ (set! num (/ num 10))))\n    (cond ((< num 400) '(((- 1000 num) . roman))\n\
    \          ((= num 100) '(nu))\n          ((= num 900) '(deux))\n          ((=\
    \ num 500) '(du))\n          ((= num 400) '(vi))\n          ((= num 100) '(ca))\n\
    \          ((= num 90) '(sa))\n          ((= num 50) '(da))\n          ((= num\
    \ 40) '(sua))\n          ((= num 10) '(a))\n          ((= num 9) '(ea))\n    \
    \      ((= num 5) '(ii))\n          ((= num 4) '(we))\n          ((= num 3) '(oa))\n\
    \          ((= num 2) '(nea))\n          ((= num 1) '(ei)))\n      )))\n", " \
    \ (cond [(> number 1)\n         (append (int_to_mini_roman division remainder)\
    \ (string 'x))]\n        [(< number 1000)\n         (append\n            (append\
    \ (int_to_mini_roman division remainder) (list 'l))\n            (int_to_mini_roman\
    \ division (- remainder 10)))]\n        [(= number 0)\n         (append (string\
    \ '0'))]\n        [(= number 1000)\n         (append (string 'M'))]\n        [else\n\
    \         (append\n           (if (< division 10)\n               (int_to_mini_roman\
    \ division (- remainder 10))\n               (int_to_mini_roman division remainder))\n\
    \           (append (list (list (char (mod number 10) 'I))\n                 \
    \      (int_to_mini_roman division (- remainder 10))))]))\n", "  (define (aux\
    \ number acc)\n    (cond\n      [(= number 1) (cons 'x acc)]\n      [(= number\
    \ 2) (cons 'c acc)]\n      [(= number 3) (cons 'd acc)]\n      [(= number 4) (cons\
    \ 'di acc)]\n      [(= number 5) (cons 'x acc)]\n      [(= number 6) (cons 'c\
    \ acc)]\n      [(= number 7) (cons 'd acc)]\n      [(= number 8) (cons 'i acc)]\n\
    \      [(= number 9) (cons 'x acc)]\n      [(= number 10) (cons 'c acc)]\n   \
    \   [(= number 11) (cons 'd acc)]\n      [(= number 12) (cons 'i acc)]\n     \
    \ [(= number 13) (cons 'x acc)]\n      [(= number 14) (cons 'c acc)]\n      [(=\
    \ number 15) (cons 'd acc)]\n      [(= number 16) (cons 'i acc)]\n      [(= number\
    \ 17) (cons 'x acc)]\n      [(= number 18) (cons 'c acc)]\n      [(= number 19)\
    \ (cons 'd acc)]\n      [(= number 20) (cons 'i acc)]\n      [(= number 21) (cons\
    \ 'x acc)]\n      [(= number 22) (cons 'c acc)]\n      [(= number 23) (cons 'd\
    \ acc)]\n      [(= number 24) (cons 'i acc)]\n      [(= number 25) (cons 'x acc)]\n\
    \      [(= number 26) (cons 'c acc)]\n      [(= number 27) (cons 'd acc)]\n  \
    \    [(= number 28) (cons 'i acc)]\n      [(= number 29) (cons 'x acc)]\n    \
    \  [(= number 30) (cons 'c acc)]\n      [(= number 31) (cons 'd acc)]\n      [(=\
    \ number 32) (cons 'i acc)]\n      [(= number 33) (cons 'x acc)]\n      [(= number\
    \ 34) (cons 'c acc)]\n      [(= number 35) (cons 'd acc)]\n      [(= number 36)\
    \ (cons 'i acc)]\n      [(= number 37) (cons 'x acc)]\n      [(= number 38) (cons\
    \ 'c acc)]\n      [(= number 39) (cons 'd acc)]\n      [(= number 40) (cons 'i\
    \ acc)]\n      [(= number 41) (cons 'x acc)]\n      [(= number 42) (", "  (cond\n\
    \    [(< number 1) \"M\"]\n    [(< number 6) \"CM\"]\n    [(< number 9) \"D\"\
    ]\n    [(< number 10) \"C\"]\n    [(< number 40) \"XC\"]\n    [(< number 100)\
    \ \"L\"]\n    [(< number 400) \"XL\"]\n    [(< number 1000) \"XC\"]\n    [(< number\
    \ 4000) \"XL\"]\n    [else (int_to_mini_roman (- number 1))\n         (+ number\
    \ 1)\n         (int_to_mini_roman number)]))\n", "  (if (< number 1000)\n    \
    \  (int_to_mini_roman_helper number 0 \"\")\n      \"invalid\"))\n", "  (cond\n\
    \    [(< 1 number) \"\"]\n    [(< 1000 number) (string-append (int_to_mini_roman\
    \ sub1 number)\n                                   (string->lower (char->roman\
    \ 'i')))]\n    [else (int_to_mini_roman sub1 number\n                      (string-append\
    \ (int_to_mini_roman sub2 number)\n                                     (string->lower\
    \ (char->roman 'i')))\n                      (string-append (int_to_mini_roman\
    \ sub3 number)\n                                     (string->lower (char->roman\
    \ 'i')))\n                      (string-append (int_to_mini_roman sub4 number)\n\
    \                                     (string->lower (char->roman 'i')))\n   \
    \                   (string-append (int_to_mini_roman sub5 number)\n         \
    \                            (string->lower (char->roman 'i')))\n            \
    \          (string-append (int_to_mini_roman sub6 number)\n                  \
    \                   (string->lower (char->roman 'i')))\n                     \
    \ (string-append (int_to_mini_roman sub7 number)\n                           \
    \          (string->lower (char->roman 'i')))\n                      (string-append\
    \ (int_to_mini_roman sub8 number)\n                                     (string->lower\
    \ (char->roman 'i')))\n                      (string-append (int_to_mini_roman\
    \ sub9 number)\n                                     (string->lower (char->roman\
    \ 'i')))\n                      (string-append (int_to_mini_roman sub10 number)\n\
    \                                     (string->lower (char->roman 'i')))\n   \
    \                   (string-append (int_to_mini_roman sub11 number)\n        \
    \                             (string->lower (char->roman 'i')))\n           \
    \           (string-append (int_to_mini_roman sub12 number)\n                \
    \                     (string->lower (char->roman 'i')))\n                   \
    \   (string-append (int_to_mini_roman sub13 number)\n                        \
    \             (string->lower (char->roman 'i')))\n                      (string-append\
    \ (int_to_mini_roman sub14 number)\n                                     (string->lower\
    \ (char->roman 'i')))\n                      (string-append (int_to_mini_roman\
    \ sub15 number)\n                                     (string->lower (char->roman\
    \ 'i')))\n                      (string-append (int_to_mini_roman sub16 number)\n\
    \                                     (string->lower (char->roman 'i')))\n   \
    \                   (string-append (int_to_mini_roman sub17 number)\n        \
    \                             (string->", "  (cond\n    [(= number 0) '']\n  \
    \  [(= number 1) 'i']\n    [(= number 2) 'ii']\n    [(= number 3) 'iii']\n   \
    \ [(= number 4) 'iv']\n    [(= number 5) 'v']\n    [(= number 6) 'vi']\n    [(=\
    \ number 7) 'vii']\n    [(= number 8) 'viii']\n    [(= number 9) 'ix']\n    [(=\
    \ number 10) 'x']\n    [(= number 11) 'xi']\n    [(= number 12) 'xii']\n    [(=\
    \ number 13) 'xiii']\n    [(= number 14) 'xiv']\n    [(= number 15) 'xvi']\n \
    \   [(= number 16) 'xvii']\n    [(= number 17) 'xviii']\n    [(= number 18) 'xix']\n\
    \    [(= number 19) 'xx']\n    [(= number 20) 'xxi']\n    [(= number 21) 'xxii']\n\
    \    [(= number 22) 'xxiii']\n    [(= number 23) 'xxiv']\n    [(= number 24) 'xxv']\n\
    \    [(= number 25) 'xxvi']\n    [(= number 26) 'xxvii']\n    [(= number 27) 'xxviii']\n\
    \    [(= number 28) 'xxix']\n    [(= number 29) 'xxx']\n    [(= number 30) 'xxxi']\n\
    \    [(= number 31) 'xxxii']\n    [(= number 32) 'xxxiii']\n    [(= number 33)\
    \ 'xxxiv']\n    [(= number 34) 'xxxv']\n    [(= number 35) 'xxxvi']\n    [(= number\
    \ 36) 'xxxvii']\n    [(= number 37) 'xxxviii']\n    [(= number 38) 'xxxiv']\n\
    \    [(= number 39) 'xxxv']\n    [(= number 40) 'xxxvi']\n    [(= number 41) 'xxxvii']\n\
    \    [(= number 42) 'xxxviii']\n    [(= number 43) 'xxxix']\n    [(= number 44)\
    \ 'xxxx']\n    [(= number 45) 'xxxxi']\n    [(= number 46) 'xxxxii']\n    [(=\
    \ number 47", "  (let loop ([num number]\n             [result (make-array (+\
    \ 3 (logand (- number 1) 1000))\n                             :element-type 'char\n\
    \                             :initial-contents '')])\n    (cond\n      [(< num\
    \ 1000)\n       (set! result (append result (list number))) ; no roman numerals\n\
    \       result]\n      [(< num 5000)\n       (set! result (append result (list\
    \ \"M\"\n                                      (int_to_mini_roman floor (/ num\
    \ 1000)))))\n       result]\n      [(< num 9000)\n       (set! result (append\
    \ result (list \"CM\"\n                                      (int_to_mini_roman\
    \ floor (/ num 500)))))\n       result]\n      [(< num 14000)\n       (set! result\
    \ (append result (list \"D\"\n                                      (int_to_mini_roman\
    \ floor (/ num 100)))))\n       result]\n      [(< num 21000)\n       (set! result\
    \ (append result (list \"CD\"\n                                      (int_to_mini_roman\
    \ floor (/ num 25)))))\n       result]\n      [(< num 28000)\n       (set! result\
    \ (append result (list \"C\"\n                                      (int_to_mini_roman\
    \ floor (/ num 10)))))\n       result]\n      [(< num 32000)\n       (set! result\
    \ (append result (list \"XC\"\n                                      (int_to_mini_roman\
    \ floor (/ num 5)))))\n       result]\n      [(< num 40000)\n       (set! result\
    \ (append result (list \"L\"\n                                      (int_to_mini_roman\
    \ floor (/ num 4)))))\n       result]\n      [(< num 46000)\n       (set! result\
    \ (append result (list \"XL\"\n                                      (int_to_mini_roman\
    \ floor (/ num 3)))))\n       result]\n      [(< num 50000)\n       (set! result\
    \ (append result (list \"X\"\n                                      (int_to_mini_roman\
    \ floor (/ num 2)))))\n       result]\n      [(< num 55000)\n       (set! result\
    \ (append result (list \"IX\"\n                                      (int_to_mini_roman\
    \ floor (/ num 1)))))\n       result]\n      [(< num 60000)\n       (set! result\
    \ (append result (list \"V\"\n                                      (int_to_mini_roman\
    \ floor (/ num 1)))))\n       result]\n      [(< ", "  (cond [(= number 0) \"\"\
    ]\n        [(= number 1) \"I\"]\n        [(< number 1000000) (string->char (floor\
    \ (number/100)) #\\I)]\n        [else (string->char (floor (number/1000)) #\\\
    I\n                         (int_to_mini_roman number (- number 1000000))\n  \
    \                       (string->char (- (floor (number/1000)) 1000000) #\\I))]\n\
    \        ))\n", "  (let ((str (string->list '())))\n    (cond [(< number 1)\n\
    \           (string-append \"I\" str)\n           ]\n          [(< number 1000)\n\
    \           (cond [(< number (- number 1))\n                  (cond [(number =\
    \ 0)\n                         str\n                         ]\n             \
    \           [else (append str (list 'M))])\n                      ]\n        \
    \            [else (append str (int_to_mini_roman number (sub1 number)))])\n \
    \                     ]\n          [(< number 1000000)\n           (cond [(< number\
    \ (- number 1000))\n                  (cond [(number = 0)\n                  \
    \       str\n                         ]\n                        [else (append\
    \ str (list 'D))])\n                      ]\n                    [else (append\
    \ str (int_to_mini_roman number (sub1 number)))])\n                      ]\n \
    \         [(< number 1000000000)\n           (cond [(< number (- number 1000000))\n\
    \                  (cond [(number = 0)\n                         str\n       \
    \                  ]\n                        [else (append str (list 'C))])\n\
    \                      ]\n                    [else (append str (int_to_mini_roman\
    \ number (sub1 number)))])\n                      ]\n          [(< number 10000000000)\n\
    \           (cond [(< number (- number 1000000000))\n                  (cond [(number\
    \ = 0)\n                         str\n                         ]\n           \
    \             [else (append str (list 'L))])\n                      ]\n      \
    \              [else (append str (int_to_mini_roman number (sub1 number)))])\n\
    \                      ]\n          [(< number 100000000000)\n           (cond\
    \ [(< number (- number 10000000000))\n                  (cond [(number = 0)\n\
    \                         str\n                         ]\n                  \
    \      [else (append str (list 'X))])\n                      ]\n             \
    \       [else (append str (int_to_mini_roman number (sub1 number)))])\n      \
    \                ]\n          [else (append str (int_to_mini_roman number (sub1\
    \ number)))])\n    str))\n", "  (cond\n    [(< number 1) '']\n    [(< number 100)\
    \ 'M']\n    [(< number 400) 'MM']\n    [else (int_to_mini_roman_helper (- number\
    \ 1000)\n                                 100\n                              \
    \   (- number 400)\n                                 (- number 100)))]))\n", " \
    \ (cond [(< number 1) '?]\n        [(< number 1000) (int_to_mini_roman 100)]\n\
    \        [else (append (int_to_mini_roman 10) (int_to_mini_roman number mod 10))]))\n",
  "  (cond\n    [(< number 1) \"\"]\n    [(= number 1) \"i\"]\n    [else (define value\
    \ (floor (- number 1)) (int_to_mini_roman value) (conj value \"i\"))]\n  ))\n",
  "  (cond [(< number 1)\n         'one']\n        [else\n         (cond [(= (mod\
    \ number 100) 0)\n                (cond [(< number 4000)\n                   \
    \    'vi']\n                      [(< number 4999)\n                       'i']\n\
    \                      [(< number 5000)\n                       'ii']\n      \
    \                [(< number 5999)\n                       'iii']\n           \
    \           [(< number 6000)\n                       'iv']\n                 \
    \     [(< number 6999)\n                       'v']\n                      [(<\
    \ number 7000)\n                       'vii']\n                      [(< number\
    \ 7999)\n                       'viii']\n                      [(< number 8000)\n\
    \                       'ix']\n                      [(< number 8999)\n      \
    \                 'x']\n                      [(< number 9000)\n             \
    \          'xii']\n                      [(< number 9999)\n                  \
    \     'xiii']\n                      [(< number 10000)\n                     \
    \  'xiii']\n                      [(< number 11999)\n                       'xiv']\n\
    \                      [(< number 12000)\n                       'xv']\n     \
    \                 [(< number 13000)\n                       'xl']\n          \
    \            [(< number 14000)\n                       'l']\n                \
    \      [(< number 15000)\n                       'l']\n                      [(<\
    \ number 15999)\n                       'l']\n                      [(< number\
    \ 16000)\n                       'l']\n                      [(< number 17000)\n\
    \                       'l']\n                      [(< number 18000)\n      \
    \                 'l']\n                      [(< number 19000)\n            \
    \           'l']\n                      [(< number 20000 'o')\n              \
    \         'o']\n                      [(< number 21000)\n                    \
    \   'o']\n                      [(< number 22000)\n                       'o']\n\
    \                      [(< number 23000)\n                       'o']\n      \
    \                [(< number 24000)\n                       'o']\n            \
    \          [(< number 25000)\n                       'o']\n                  \
    \    [(< number 26000)\n                       'o']\n                      [(<\
    \ number 27000)\n                       'o']\n                      [(< number\
    \ 28000)\n                       'o']\n                      [(< number 29000)\n\
    \                       'o']\n                      [(< number 30000)\n      \
    \                 'o']\n                      [(< number 31000)\n            \
    \           'o']\n                      [(< number 32000)\n                  \
    \     'o']\n                      [(< number 33000)\n                       'o']\n\
    \                      [(< number 34000)\n                       'o']\n      \
    \                [(< number 35000)\n                       'o']\n            \
    \          [(< number 36000)\n                       'o']\n                  \
    \    [(< number 37000)\n                       'o']\n                      [(< ",
  "  (let loop ([i number] [str \"\"])\n    (cond [(< i 1000)\n           (loop (+\
    \ i 1) (+ str (char i)))]\n          [else\n           (loop (+ i 1)\n       \
    \          (+ str (sub1 i))\n                 (cond (string=? (sub1 i) 'i)\n \
    \                      \"I\"\n                       (string=? (sub1 i) 'one)\n\
    \                       \"II\"\n                       (string=? (sub1 i) 'two)\n\
    \                       \"III\"\n                       (string=? (sub1 i) 'three)\n\
    \                       \"IV\"\n                       (string=? (sub1 i) 'four)\n\
    \                       \"V\"\n                       (string=? (sub1 i) 'five)\n\
    \                       \"VI\"\n                       (string=? (sub1 i) 'six)\n\
    \                       \"VII\"\n                       (string=? (sub1 i) 'seven)\n\
    \                       \"VIII\"\n                       (string=? (sub1 i) 'eight)\n\
    \                       \"IX\"\n                       (string=? (sub1 i) 'nine)\n\
    \                       \"X\"\n                       (str)))]))\n", "  (define\
    \ (iter n roman)\n    (cond ((= n 0) (cons roman '()))\n          ((even? n) (iter\
    \ (/ n 2) (cons (mod n 10) roman)))\n          (else (iter (- n 1) roman))))\n\
    \  (iter number '()))\n", "  (let loop ((x number)\n             (acc '()))\n\
    \    (cond [(= x 0) (cons acc '())]\n          [(< x 1000)\n           (loop (quotient\
    \ x 100) (cons acc '()))]\n          [(= (modulo x 100) 0)\n           (loop (quotient\
    \ x 10) (cons (- x 100) acc))]\n          [else\n           (loop (quotient x\
    \ 10)\n                 (cons (- x 100) (- x 10) acc))])))\n", "  (cond\n    [(=\
    \ number 0)\n     \"\"]\n    [(= number 1)\n     \"\"]\n    [(= number 2)\n  \
    \   \"M\"]\n    [(= number 3)\n     \"MM\"]\n    [(= number 4)\n     \"MMM\"]\n\
    \    [(= number 5)\n     \"MMMM\"]\n    [(= number 6)\n     \"C\"]\n    [(= number\
    \ 7)\n     \"CC\"]\n    [(= number 8)\n     \"CCC\"]\n    [(= number 9)\n    \
    \ \"CD\"]\n    [(= number 10)\n     \"D\"]\n    [(= number 11)\n     \"DC\"]\n\
    \    [(= number 12)\n     \"DCC\"]\n    [(= number 13)\n     \"DCCC\"]\n    [(=\
    \ number 14)\n     \"CM\"]\n    [(= number 15)\n     \"XC\"]\n    [(= number 16)\n\
    \     \"LX\"]\n    [(= number 17)\n     \"XL\"]\n    [(= number 18)\n     \"L\"\
    ]\n    [(= number 19)\n     \"XL\"]\n    [(= number 20)\n     \"XC\"]\n    [(=\
    \ number 21)\n     \"IX\"]\n    [(= number 22)\n     \"V\"]\n    [(= number 23)\n\
    \     \"IV\"]\n    [(= number 24)\n     \"I\"]\n    [(= number 25)\n     \"IV\"\
    ]\n    [(= number 26)\n     \"X\"]\n    [(= number 27)\n     \"XL\"]\n    [(=\
    \ number 28)\n     \"LX\"]\n    [(= number 29)\n     \"XC\"]\n    [(= number 30)\n\
    \     \"IV\"]\n    [(= number 31)\n     \"I\"]\n    [else\n     (let ([first (sub1\
    \ number)]\n           [second (sub2 number)])\n       (cond\n         [(< first\
    \ 26)\n          (int_to_mini_roman first)]\n         [(< second 26)\n       \
    \   (int_to_mini_roman second)]\n         [(>= first 26)\n          (int_to_mini_roman\
    \ first)\n          (int_to_mini_roman second)]))]))\n", "  (cond [(< number 1000)\n\
    \         (string-append (roman-numeral-string number) \"\")\n         ]\n   \
    \     [(< number 5000)\n         (string-append (roman-numeral-string number)\
    \ (substring \"IV\" 0 0))\n         ]\n        [(< number 10000)\n         (string-append\
    \ (roman-numeral-string number) (substring \"III\" 0 0))\n         ]\n       \
    \ [else\n         (string-append (roman-numeral-string number) (substring \"II\"\
    \ 0 0))\n         ]\n        ))\n", "  (if (or (< number 1) (> number 1000))\n\
    \      'error\n      (let ((letters (make-array 26 '(unsigned-byte))))\n     \
    \   (loop for i from 0 to 25 do (set! letters (+ letters (array-ref letters i)))\
    \ ; set every letter to its index\n          (if (and (< number 1000)\n      \
    \            (>= i (mod number 1000))) ; check for valid roman numerals\n    \
    \          (let ((roman '()))\n                (cond\n                  ((< number\
    \ 1000) (set! roman 'x)) ; less than 1 thousand\n                  ((>= number\
    \ 1000) (set! roman 'vi)) ; less than 1 million\n                  (else (set!\
    \ roman 'x 'vi 'i)) ; greater than 1 million\n                  (else (set! roman\
    \ 'x 'vi 'i (string->list (substring number-string i (add1 i))))) ; greater than\
    \ 1 thousand\n                  (else (set! roman 'x 'vi 'i (string->list (substring\
    \ number-string i (add1 i) 'vi'))))) ; greater than 1 million\n              \
    \  (set! letters (array-set! letters (mod number 1000) roman 'x)))\n         \
    \     (array-set! letters (mod number 1000) (+ roman 'x))) ; check for invalid\
    \ numbers\n          (array-set! letters (mod number 1000) 'error 'error)))))\n",
  "  (cond\n    [(= number 0) \"0\"\n     (cond\n       [(= (modulo number 1000) 0)\
    \ (mini_roman number 1000)]\n       [(= (modulo number 1000) 1) (mini_roman number\
    \ 1000 'x)]\n       [(= (modulo number 1000) 2) (mini_roman number 1000 'x 'x)]\n\
    \       [(= (modulo number 1000) 3) (mini_roman number 1000 'x 'x 'x)]\n     \
    \  [(= (modulo number 1000) 4) (mini_roman number 1000 'x 'x 'x 'x)]\n       [(=\
    \ (modulo number 1000) 5) (mini_roman number 1000 'x 'x 'x 'x 'x)]\n       [(=\
    \ (modulo number 1000) 6) (mini_roman number 1000 'x 'x 'x 'x 'x 'x)]\n      \
    \ [(= (modulo number 1000) 7) (mini_roman number 1000 'x 'x 'x 'x 'x 'x 'x)]\n\
    \       [(= (modulo number 1000) 8) (mini_roman number 1000 'x 'x 'x 'x 'x 'x\
    \ 'x 'x)]\n       [(= (modulo number 1000) 9) (mini_roman number 1000 'x 'x 'x\
    \ 'x 'x 'x 'x 'x 'x)]\n       [(= (modulo number 1000) 10) (mini_roman number\
    \ 1000 'x 'x 'x 'x 'x 'x 'x 'x 'x)]\n       [(= (modulo number 1000) 11) (mini_roman\
    \ number 1000 'x 'x 'x 'x 'x 'x 'x 'x 'x 'x)]\n       [(= (modulo number 1000)\
    \ 12) (mini_roman number 1000 'x 'x 'x 'x 'x 'x 'x 'x 'x 'x 'x)]\n       [(= (modulo\
    \ number 1000) 13) (mini_roman number 1000 'x 'x 'x 'x 'x 'x 'x 'x 'x 'x 'x)]\n\
    \       [(= (modulo number 1000) 14) (mini_roman number 1000 'x 'x 'x 'x 'x 'x\
    \ 'x 'x 'x 'x 'x)]\n       [(= (modulo number 1000) 15) (mini_roman number 1000\
    \ 'x ", "  (cond [(<= number 1) 'm']\n        [(< number 1000 ) 'l']\n       \
    \ [(< number 4000 ) 'x']\n        [(< number 5000 ) 'c']\n        [(< number 6000\
    \ ) 'd']\n        [(< number 7000 ) 'v']\n        [(< number 8000 ) 'f']\n   \
    \     [(< number 9000 ) 'g']\n        [(< number 10000 ) 'm']\n        [else (int_to_mini_roman\
    \ number / 1000))]\n  )\n)\n", "  (let loop ([num number])\n    (cond [(< num\
    \ 1000)\n           (string-append (list 'I 'IV 'V 'IX 'X ) (- num (floor num)))]\n\
    \          [(< num 900)\n           (string-append (list 'I 'II 'III 'IV 'V 'VI\
    \ 'VII 'IX 'X 'XI )\n                          (- num (floor num)))]\n       \
    \   [(< num 5000)\n           (string-append (list 'I 'II 'III 'IV 'V 'VI 'VII\
    \ 'IX 'X 'XI 'XII)\n                          (- num (floor num)))]\n        \
    \  [(< num 4000)\n           (string-append (list 'I 'II 'III 'IV 'V 'VI 'VII\
    \ 'IX 'X 'XI 'XII\n                                      'XIII 'XIV 'XV 'XVI 'XVII\
    \ 'XIX 'XX 'XXI\n                                      'XXII 'XXIII 'XXIV 'XXV\
    \ 'XXVI 'XXVII\n                                      'XXIX 'XXX 'XXXI 'XXXII\
    \ 'XXXIII 'XXXIV\n                                      'XXXV 'XXXVI 'XXXVII 'XXXIX\
    \ 'XXX)\n                          (- num (floor num)))]\n          [(< num 3000)\n\
    \           (string-append (list 'I 'II 'III 'IV 'V 'VI 'VII 'IX 'X 'XI 'XII\n\
    \                                      'XIII 'XIV 'XV 'XVI 'XVII 'XIX 'XX 'XXI\n\
    \                                      'XXII 'XXIII 'XXIV 'XXV 'XXVI 'XXVII\n\
    \                                      'XXIX 'XXX 'XXXI 'XXXII 'XXXIII 'XXXIV\n\
    \                                      'XXXV 'XXXVI 'XXXVII 'XXXIX 'XXX)\n   \
    \                       (- num (floor num))\n                          (list 'II))\n\
    \          [(< num 2999)\n           (string-append (list 'I 'II 'III 'IV 'V 'VI\
    \ 'VII 'IX 'X 'XI 'XII\n                                      'XIII 'XIV 'XV 'XVI\
    \ 'XVII 'XIX 'XX", "  (cond\n    [(< number 1)\n     (error \"Invalid input: invalid\
    \ roman-numeral number\" (number))]\n    [(< number 1000)\n     (cond\n      \
    \ [(even? number) (cons (car roman number (+ 3 (/ number 10)))\n             \
    \            (int_to_mini_roman number (+ 3 number)))]\n       [(odd? number)\n\
    \        (cond\n         [(= 1 (mod number 10))\n          (cons (car roman number\
    \ 1)\n                (int_to_mini_roman number (+ 1 number)))]\n         [(=\
    \ 3 (mod number 10))\n          (cons (car roman number 2)\n                (int_to_mini_roman\
    \ number (+ 2 number)))]\n         [(= 5 (mod number 10))\n          (cons (car\
    \ roman number 3)\n                (int_to_mini_roman number (+ 3 number)))]\n\
    \         [(= 7 (mod number 10))\n          (cons (car roman number 4)\n     \
    \           (int_to_mini_roman number (+ 4 number)))]\n         [(= 9 (mod number\
    \ 10))\n          (cons (car roman number 5)\n                (int_to_mini_roman\
    \ number (+ 5 number)))]\n         [(= 11 (mod number 10))\n          (cons (car\
    \ roman number 6)\n                (int_to_mini_roman number (+ 6 number)))]\n\
    \         [(= 13 (mod number 10))\n          (cons (car roman number 7)\n    \
    \            (int_to_mini_roman number (+ 7 number)))]\n         [(= 15 (mod number\
    \ 10))\n          (cons (car roman number 8)\n                (int_to_mini_roman\
    \ number (+ 8 number)))]\n         [(= 17 (mod number 10))\n          (cons (car\
    \ roman number 9)\n                (int_to_mini_roman number (+ 9 number)))]\n\
    \         [(= 19 (mod number 10))\n          (cons (car roman number 10)\n   \
    \             (int_to_mini_roman number (+ 10 number)))]\n         [(= 21 (mod\
    \ number 10))\n          (cons (car roman number 11)\n                (int_to_mini_roman\
    \ number (+ 11 number)))]\n         [(= 23 (mod number 10))\n          (cons (car\
    \ roman number 12)\n                (int_to_mini_roman number (+ 12 number)))]\n\
    \         [(= 25 (mod number 10))\n          (cons (car roman number 13)\n   \
    \             (int_to_mini_roman ", "  (if (< number 1)\n      '?\n      (let\
    \ ((vals (make-vector 5 empty)))\n        (cond\n          [(< number 10) (set!\
    \ vals ((vector 'i 'v 'x 'l) (list 'i 'v 'x 'l)))]\n          [(< number 100)\
    \ (set! vals ((vector 'c 'l'i) (list 'c 'l'i)))]\n          [(< number 1000) (set!\
    \ vals ((vector 'c 'd'l) (list 'c 'd'l)))]\n          [(< number 10000) (set!\
    \ vals ((vector 'c 'd'x) (list 'c 'd'x)))]\n          [(< number 100000) (set!\
    \ vals ((vector 'c 'd'x) (list 'c 'd'x)))]\n          [(< number 1000000) (set!\
    \ vals ((vector 'c 'd'xi) (list 'c 'd'xi)))]\n          [(< number 10000000) (set!\
    \ vals ((vector 'c 'd'xvi) (list 'c 'd'xvi)))]\n          [(< number 100000000)\
    \ (set! vals ((vector 'c 'd'xxi) (list 'c 'd'xxi)))]\n          [(< number 1000000000)\
    \ (set! vals ((vector 'c 'd'xxxvi) (list 'c 'd'xxxvi)))]\n          [(< number\
    \ 10000000000) (set! vals ((vector 'c 'd'xxxvi) (list 'c 'd'xxxvi)))]\n      \
    \    [(< number 100000000000) (set! vals ((vector 'c 'd'xxxviii) (list 'c 'd'xxxviii)))]\n\
    \          [(< number 1000000000000) (set! vals ((vector 'c 'd'xxxviiii) (list\
    \ 'c 'd'xxxviiii)))]\n          [(< number 10000000000000) (set! vals ((vector\
    \ 'c 'd'xxxviiii) (list 'c 'd'xxxviiii)))]\n          [(< number 100000000000000)\
    \ (set! vals ((vector 'c 'd'xxxviiiii) (list 'c 'd'xxxviiiii)))]\n          [(<\
    \ number 1000000000000000) (set! vals ((vector 'c 'd'xxxviiiiii) (list 'c 'd'xxxviiiiii)))]\n\
    \          [(< number 10000000000000000) (set! vals ((vector 'c 'd'xxxviiiiiii)\
    \ (list ", "  (define (roman-char code)\n    (cond [(= code 0) #\\0]\n       \
    \   [(= code 1) #\\1]\n          [(= code 2) #\\2]\n          [(= code 3) #\\\
    3]\n          [(= code 4) #\\4]\n          [(= code 5) #\\5])\n  )\n  (define\
    \ (convert-to-roman number)\n    (define (get-char-and-remainder code)\n     \
    \ (let ([char (roman-char code)]\n            [rest (mod number 10)])\n      \
    \  (list char rest)))\n    (get-char-and-remainder number))\n\n  (define (roman-str\
    \ code)\n    (cond [(< code 0) '']\n          [(< code 1) 'I']\n          [(<\
    \ code 2) 'II']\n          [(< code 3) 'III']\n          [(< code 4) 'IV']\n \
    \         [(< code 5) 'V']\n          [(< code 6) 'VI']\n          [(< code 7)\
    \ 'VII']\n          [(< code 8) 'VIII']\n          [(< code 9) 'IX']\n       \
    \   [(< code 10) 'X']\n          [(< code 11) 'XI']\n          [(< code 12) 'XII']\n\
    \          [(< code 13) 'XIII']\n          [(< code 14) 'XIV']\n          [(<\
    \ code 15) 'XV']\n          [(< code 16) 'XVI']\n          [(< code 17) 'XVII']\n\
    \          [(< code 18) 'XVIII']\n          [(< code 19) 'XIX']\n          [(<\
    \ code 20) 'XX']\n          [(< code 21) 'XXI']\n          [(< code 22) 'XXII']\n\
    \          [(< code 23) 'XXIII']\n          [(< code 24) 'XXIV']\n          [(<\
    \ code 25) 'XXV']\n          [(< code 26) 'XXVI']\n          [(< code 27) 'XXVII']\n\
    \          [(< code 28) 'XXVIII']\n          [(< code 29) 'XXIX']\n          [(<\
    \ code 30) 'XXX']\n          [(< code 31) 'XXXI']\n          [(< code 32) 'XXXII']\n\
    \          [(< code 33) 'XXXIII']\n          [(< code 34) 'XXXIV']\n         \
    \ [(< ", "  (cond\n    [(<= 0 number) #f]\n    [(zero? number) 'zero]\n    [(=\
    \ 1 number) 'i]\n    [(= 2 number) 'ii]\n    [(= 3 number) 'iii]\n    [(= 4 number)\
    \ 'iv]\n    [(= 5 number) 'v]\n    [(= 6 number) 'vi]\n    [(= 7 number) 'vii]\n\
    \    [(= 8 number) 'viii]\n    [(= 9 number) 'ix]\n    [else (if (= (quotient\
    \ number 100) 10)\n           'x (int_to_mini_roman (quotient number 10))\n  \
    \         'x (int_to_mini_roman (quotient number 10))\n           'x (int_to_mini_roman\
    \ (quotient number 10))))]))\n", "  (cond\n    [(< number 1) '']\n    [(< number\
    \ 1000) (substring (list->string (string->list \"MCMXCDE\")) 0 (- number 1))]\n\
    \    [(< number 5000) (substring (list->string (string->list \"DCLXV\")) 0 (-\
    \ number 1))]\n    [else (substring (list->string (string->list \"MIODT\")) 0\
    \ (- number 1))]))\n", "  (cond\n    [(< 1 number) \"\"]\n    [(< 1000 number)\
    \ (string-append (int_to_mini_roman floor-quotient (- number 1000)) 'mi)]\n  \
    \  [else (string-append (int_to_mini_roman floor-quotient (- number 1000)) 'vi)]\n\
    \  ))\n", "  (let loop ((number (floor (/ number 1000)))\n             (result\
    \ 'empty))\n    (cond ((<= number 1) result)\n          ((= (- number 1) 0) (append\
    \ 'e result))\n          ((< number 1000)\n           (loop (ceiling (/ number\
    \ 1000))\n                 (append (mini_roman (- number 1) 'd) (append 'c (mini_roman\
    \ number 'd))))\n          (else\n           (loop (ceiling (/ number 1000))\n\
    \                 (append (mini_roman number 'd) (append 'c (mini_roman (- number\
    \ 1) 'd)))))))\n", "  (cond [(< number 1) (string 'roman-numeral)]\n        [else\
    \ (int_to_mini_roman (- number 1)\n                           & (append (map (lambda\
    \ (c) (case-one-of '(c c c c c c c c) '(m m m m m m m m m m m)) '(i v x c l d\
    \ x x x x x))\n                                       (make-string\n         \
    \                               (+ 1 (math-min (math-floor number) 1000))\n  \
    \                                      'right)))]))\n", "  (cond\n    ((<= number\
    \ 1) 'x)\n    ((<= number 4) 'c)\n    ((<= number 10) 'd)\n    ((<= number 100)\
    \ 'ccc)\n    ((<= number 500) 'dcc)\n    ((<= number 1000) 'cccx)\n    ((<= number\
    \ 5000) 'dccx)\n    ((<= number 10000) 'cccxi)\n    ((<= number 50000) 'dccxi)\n\
    \    ((<= number 10000) 'cccxii)\n    ((<= number 50000) 'dccxii)\n    ((<= number\
    \ 10000) 'cccci)\n    ((<= number 50000) 'dccci)\n    ((<= number 10000) 'ccccii)\n\
    \    ((<= number 50000) 'dcccii)\n    ((<= number 10000) 'ccci)\n    ((<= number\
    \ 50000) 'dccci)\n    ((<= number 10000) 'cccii)\n    ((<= number 50000) 'dcccii)\n\
    \    ((<= number 10000) 'ci)\n    ((<= number 50000) 'dii)\n    ((<= number 10000)\
    \ 'cii)\n    ((<= number 50000) 'diii)\n    ((<= number 10000) 'ciii)\n    ((<=\
    \ number 50000) 'diii)\n    ((<= number 10000) 'ciiii)\n    ((<= number 50000)\
    \ 'diiii)\n    ((<= number 10000) 'ciiiii)\n    ((<= number 50000) 'diiiii)\n\
    \    ((<= number 10000) 'ciiiiii)\n    ((<= number 50000) 'diiiiii)\n    ((<=\
    \ number 10000) 'ciiiiiii)\n    ((<= number 50000) 'diiiiiii)\n    ((<= number\
    \ 10000) 'ciiiiiiii)\n    ((<= number 50000) 'diiiiiiii)\n    ((<= number 10000)\
    \ 'ciiiiiiiii)\n    ((<= number 50000) 'diiiiiiiii)\n    ((<= number 10000) 'ciiiiiiiiii)\n\
    \    ((<= number 50000) 'diiiiiiiiii)\n    ((<= number 10000) 'ciiiiiiiiiii)\n\
    \    ((<= number 50000) 'diiiiiiiiiii)\n    ((<= number 10000) 'ciiiiiiiiiiii)\n\
    \    ((<= number 50000) 'diiiiiiiiiiii)\n    ((<= number 10000) 'ciiiiiiiiiiiii)\n\
    \    ((<= number 50000) 'diiiii", "  (define (helper digit acc)\n    (cond [(>\
    \ digit 0) (helper (- digit 1) acc)]\n          [else (append acc (substring (reverse\
    \ digit) 1) 'm))])\n  (helper number 'm))\n", "  (cond\n    [(<= 0 number)\n \
    \     (error 'int_to_mini_roman \"cannot compute romanization for negative integer:\
    \ ~d\" number)]\n    [(< number 1000)\n      (cond\n        [(= (mod number 100)\
    \ 0)\n         (cond\n          [(= (mod number 10) 0)\n           (cond\n   \
    \          [(= (mod number 5) 0)\n              (cond\n                [((= (mod\
    \ number 4) 0)\n                 (cond\n                  [(= (mod number 2) 0)\n\
    \                   (cond\n                     [(= (mod number 1) 0)\n      \
    \               (error 'int_to_mini_roman \"cannot compute romanization for number\
    \ less than 1000: ~d\" number)]\n                   (error 'int_to_mini_roman\
    \ \"cannot compute romanization for number less than 1000: ~d\" number)])]\n \
    \               (error 'int_to_mini_roman \"cannot compute romanization for number\
    \ less than 1000: ~d\" number)])]\n              (error 'int_to_mini_roman \"\
    cannot compute romanization for number less than 1000: ~d\" number)])]\n     \
    \      (error 'int_to_mini_roman \"cannot compute romanization for number less\
    \ than 1000: ~d\" number)])]\n        (error 'int_to_mini_roman \"cannot compute\
    \ romanization for number less than 1000: ~d\" number)])]\n    (error 'int_to_mini_roman\
    \ \"cannot compute romanization for number less than 1000: ~d\" number)))\n",
  "  (define (roman-digits num)\n    (cond\n      [(= num 1) 'I']\n      [(= num 2)\
    \ 'II']\n      [(= num 3) 'III']\n      [(= num 4) 'IV']\n      [(= num 5) 'V']\n\
    \      [(= num 6) 'VI']\n      [(= num 7) 'VII']\n      [(= num 8) 'VIII']\n \
    \     [(= num 9) 'IX']\n      [else (cond [(= num 10) 'X']\n                 \
    \  [(= num 11) 'XI']\n                   [(= num 12) 'XII']\n                \
    \   [(= num 13) 'XIII']\n                   [(= num 14) 'XIV']\n             \
    \      [(= num 15) 'XV']\n                   [(= num 16) 'XVI']\n            \
    \       [(= num 17) 'XVII']\n                   [(= num 18) 'XVIII']\n       \
    \            [(= num 19) 'XIX']\n                   [else (cond [(= num 20) 'XX']\n\
    \                               [(= num 21) 'XXI']\n                         \
    \      [(= num 22) 'XXII']\n                               [(= num 23) 'XXIII']\n\
    \                               [(= num 24) 'XXIV']\n                        \
    \       [(= num 25) 'XXV']\n                               [(= num 26) 'XXVI']\n\
    \                               [(= num 27) 'XXVII']\n                       \
    \        [(= num 28) 'XXVIII']\n                               [(= num 29) 'XXIX']\n\
    \                               [else (cond [(= num 30) 'XXX']\n             \
    \                              [(= num 31) 'XXI']\n                          \
    \                 [(= num 32) 'XXII']\n                                      \
    \     [(= num 33) 'XXIII']\n                                           [(= num\
    \ 34) 'XXIV']\n                                           [(= num 35) 'XXV']\n\
    \                                           [(= num 36) 'XXVI']\n            \
    \                               [(= num 37) 'XXVII']\n                       \
    \                    [(= num 38) 'XXVIII']\n                                 \
    \          [(= num 39) 'XXIX']\n                                           [else\
    \ (cond [(= num 40) 'XL']\n                                                  \
    \     [(= num 41) 'LX']\n                                                    \
    \   [(= num 42) 'LXI']\n                                                     \
    \  [(= num 43) 'LXII']\n                                                     \
    \  [(= num 44) 'LXII", "  (define (roman-part number)\n    (define (roman-part\
    \ number remainder acc)\n      (cond\n        [(= remainder 0) acc]\n        [(<\
    \ remainder 1000) (roman-part (remainder 1000) (sub1 remainder) acc)]\n      \
    \  [else (roman-part (remainder 1000) (sub1 remainder) (append acc (list remainder)))]))\n\
    \    (roman-part number number '()))\n  (roman-part number number '()))\n", " \
    \ (cond [(< number 1)\n         '']\n        [(< number 1000)\n         (string->char\
    \ (number->roman number))]\n        [else\n         (string->char (number->roman\
    \ number) (- number 1))]\n))\n", "  (cond [(< number 1) '']\n        [(< number\
    \ 100) '']\n        [(< number 4000) '']\n        [else (cond [(> number 1000)\
    \ (cond [(> number 4000)\n                                                  (cond\
    \ [(> number 9000)\n                                                        (cond\
    \ [(> number 3000)\n                                                         \
    \     (cond [(> number 1000)\n                                               \
    \                  '']\n                                                     \
    \           [(else '')\n                                                     \
    \            int_to_mini_roman (- number 1000)]\n                            \
    \                                  [(else '')\n                              \
    \                                   int_to_mini_roman (- number 9000)]\n     \
    \                                                       [(else '')\n         \
    \                                                        int_to_mini_roman (-\
    \ number 4000)]\n                                                          [(else\
    \ '')\n                                                                 int_to_mini_roman\
    \ (- number 3000)]\n                                                        [(else\
    \ '')\n                                                                 int_to_mini_roman\
    \ (- number 2000)]\n                                                      [(else\
    \ '')\n                                                                 int_to_mini_roman\
    \ (- number 1000)]\n                                                    [(else\
    \ '')\n                                                                 int_to_mini_roman\
    \ (- number 900)]\n                                                  [(else '')\n\
    \                                                                 int_to_mini_roman\
    \ (- number 400)]\n                                                [(else '')\n\
    \                                                                 int_to_mini_roman\
    \ (- number 300)]\n                                              [(else '')\n\
    \                                                                 int_to_mini_roman\
    \ (- number 200)]\n                                            [(else '')\n  \
    \                                                               int_to_mini_roman\
    \ (- number 100)]\n                                          [(else '')\n    \
    \                                                             int_to_mini_roman\
    \ (- number 50)]\n                                        [(else '')\n       \
    \                                                          int_to_mini_roman (-\
    \ number 50)]\n                                      [(else '')\n            \
    \                                                     int_to_mini_roman (- number\
    \ 10)]\n                                    [(else '')\n                     \
    \                                            int_to_mini_roman (- number 5)]\n\
    \                                  [(else '')\n                              \
    \                                   int_to_mini_roman (- number 1)])]\n      \
    \                     [(else '')\n                                (int_to_mini_roman\
    \ number)]))]))\n", "  (if (<= number 1000) (string (car numerals)) (string-append\
    \ (int_to_mini_roman (/ number 1000))\n                                      \
    \     (if (= (modulo number 1000) 0) 'm'\n                                   \
    \            (if (= (modulo number 1000) 100) 'd'\n                          \
    \                         (if (= (modulo number 1000) 0) 'c'\n               \
    \                                      (if (= (modulo number 1000) 500) 'l'\n\
    \                                                        (if (= (modulo number\
    \ 1000) 1000) 'x')))))))\n", "  (define (helper n x result)\n    (cond [(= n 0)\
    \ (set! result x)]\n          [(= n 1)\n           (helper (quotient n 10) 'im\
    \ (set! result (cons x result)))]\n          [(> n 10)\n           (helper (quotient\
    \ n 10) 'x (cons x result))]\n          [(< n 1000)\n           (helper (quotient\
    \ n 100) 'v (cons x result))]\n          [else (helper (quotient n 10) 'i (cons\
    \ x result))]))\n  (helper number 'im 'im))\n", "  (cond\n    ((= number 0) 'zero)\n\
    \    ((< number 1) 'one)\n    ((= number 2) 'two)\n    ((< number 4) 'four)\n\
    \    ((= number 9) 'nine)\n    ((< number 10) 'ten)\n    ((= number 20) 'twenty)\n\
    \    ((< number 30) 'thirty)\n    ((= number 40) 'forty)\n    ((< number 50) 'fifty)\n\
    \    ((= number 60) 'sixty)\n    ((< number 70) 'seventy)\n    ((= number 80)\
    \ 'eighty)\n    ((< number 90) 'ninety)\n    ((< number 100) 'hundred)\n    ((=\
    \ number 400) 'fourhundred)\n    ((< number 500) 'fifty)\n    ((= number 600)\
    \ 'sixty)\n    ((< number 700) 'seventy)\n    ((= number 800) 'eighty)\n    ((<\
    \ number 900) 'ninety)\n    ((< number 1000) 'thousand)\n    ((= number 1000)\
    \ 'million)\n    ((< number 10000) 'billion)\n    ((= number 10000) 'quadrillion)\n\
    \    ((< number 100000) 'quintillion)\n    ((= number 100000) 'trillion)\n   \
    \ ((< number 1000000) 'quadrillion)\n    ((= number 1000000) 'quintillion)\n \
    \   ((< number 10000000) 'billion)\n    ((= number 10000000) 'trillion)\n    ((<\
    \ number 100000000) 'billion)\n    ((= number 100000000) 'trillion)\n    ((< number\
    \ 1000000000) 'trillion)\n    ((= number 1000000000) 'billion)\n    ((< number\
    \ 10000000000) 'quadrillion)\n    ((= number 10000000000) 'trillion)\n    ((<\
    \ number 100000000000) 'quadrillion)\n    ((= number 100000000000) 'trillion)\n\
    \    ((< number 1000000000000) 'quintillion)\n    ((= number 1000000000000) 'trillion)\n\
    \    ((< number 10000000000000) 'quadrillion)\n    ((= number 10000000000000)\
    \ 'trillion)\n    ((< number 100000000000000) 'quadrillion)\n    ((= number 100000000000000)\
    \ 'trillion)\n    ((< number 1000000000000000) 'quad", "  (let ([number (string->int\
    \ number)])\n    (cond [(< number 1) \"0\"]\n          [(< number 100) (string-append\
    \ (int_to_mini_roman number) (list->string (list->list (list (- number 1)))) \"\
    i\")]\n          [(< number 500) (string-append (int_to_mini_roman number) (list->string\
    \ (list->list (list (- number 100) (- number 1))) \"x\")]\n          [(< number\
    \ 1000) (string-append (int_to_mini_roman number) (list->string (list->list (list\
    \ (- number 500) (- number 100)) \"l\"))\n                                   \
    \  (list->string (list->list (list (- number 1000) (- number 500))) \"c\")]\n\
    \          [(< number 5000)\n           (string-append (int_to_mini_roman number)\
    \ (list->string (list->list (list (- number 1000)) (list \"d\"))\n           \
    \                                        (list->string (list->list (list (- number\
    \ 5000) (- number 1000)) \"m\")))]\n          [(< number 10000)\n           (string-append\
    \ (int_to_mini_roman number) (list->string (list->list (list (- number 10000)\
    \ (- number 10000))\n                                                        \
    \            \"c\"))\n                                     (list->string (list->list\
    \ (list (- number 10000) (- number 10000))\n                                 \
    \                   \"l\"))]\n          [(< number 100000)\n           (string-append\
    \ (int_to_mini_roman number) (list->string (list->list (list (- number 100000)\
    \ (- number 100000)) \"x\")\n                                                \
    \                    (list->string (list->list (list (- number 100000) (- number\
    \ 100000)) \"l\"))]\n          [(< number 1000000)\n           (string-append\
    \ (int_to_mini_roman number) (list->string (list->list (list (- number 1000000)\
    \ (- number 1000000))\n                                                      \
    \              \"x\"))\n                                     (list->string (list->list\
    \ (list (- number 1000000) (- number 1000000))\n                             \
    \                       \"l\"))]\n          [(< number 10000000)\n           (string-append\
    \ (int_to_mini_roman number) (list->string (list->list (list (- number 10000000)\
    \ (- number 10000000))\n                                                     \
    \               \"x\"))\n                                     (list->string (list->list\
    \ (list (- number 10000000) (- number 10000000))\n                           \
    \                         \"l\"))]\n          [(< number 100000000)\n        \
    \   (string-append (int_to_mini_roman number) (list->string (list->list (list\
    \ (- number 100000000) (- number 100000000))\n                               \
    \                                     \"x\"))\n                              \
    \       (list->string (list->list (list (- number ", "  (cond [(< number 1) '?]\n\
    \        [(< number 1000) (cons (char-code (digit-char (- number 1))) '?)]\n \
    \       [else (int_to_mini_roman number)]))\n", "  (let* ((num-length (floor number\
    \ 1000))\n         (num-digits (/ (- number 1000) (quotient number 1000)))\n \
    \        (first-digit (modulo num-length num-digits))\n         (last-digit (num-length\
    \ num-digits))\n         (last-dig-roman (number->roman (- last-digit num-digits))))\n\
    \    (cond ((< last-digit num-digits)\n           (number->string number))\n \
    \         ((eq? (first last-dig-roman) 'M))\n          ((eq? (first last-dig-roman)\
    \ 'D))\n          ((eq? (first last-dig-roman) 'C))\n          ((eq? (first last-dig-roman)\
    \ 'L))\n          ((eq? (first last-dig-roman) 'X))\n          ((eq? (first last-dig-roman)\
    \ 'V))\n          ((eq? (first last-dig-roman) 'I))\n          ((<= (- last-digit\
    \ num-digits) 9))\n          ((eq? (first last-dig-roman) 'VI))\n          ((eq?\
    \ (first last-dig-roman) 'IX))\n          ((eq? (first last-dig-roman) 'XV))\n\
    \          ((eq? (first last-dig-roman) 'XL))\n          ((eq? (first last-dig-roman)\
    \ 'LX))\n          ((eq? (first last-dig-roman) 'IXL))\n          ((eq? (first\
    \ last-dig-roman) 'XCL))\n          ((eq? (first last-dig-roman) 'CML))\n    \
    \      ((eq? (first last-dig-roman) 'MCMXC))\n          ((eq? (first last-dig-roman)\
    \ 'MCMXCL))\n          ((eq? (first last-dig-roman) 'XCML))\n          ((eq? (first\
    \ last-dig-roman) 'MCMXCCL))\n          ((eq? (first last-dig-roman) 'MMXCCL))\n\
    \          ((eq? (first last-dig-roman) 'MMMCMXCCL))\n          ((eq? (first last-dig-roman)\
    \ 'MMMMCMXCCL))\n          ((eq? (first last-dig-roman) 'CLXXXVI))\n         \
    \ ((eq? (first last-dig-roman) 'CLXXXVII))\n          ((eq? (first last-dig-",
  "  (roman_to_int number 'lower))\n", "  (cond\n    [(< number 1) (error 'int_to_mini_roman\
    \ \"num too small\")]\n    [(= number 1) 'x]\n    [(= number 2) 'c]\n    [(= number\
    \ 3) 'l]\n    [(= number 4) 'xl]\n    [(= number 5) 'lx]\n    [(= number 6) 'xc]\n\
    \    [(= number 7) 'v]\n    [(= number 8) 'iv]\n    [(= number 9) 'v]\n    [(=\
    \ number 10) 'xvi]\n    [(= number 100) 'cm]\n    [(= number 1000) 'mm]\n    [else\
    \ (cond [(numberp (- number 1000)) (error 'int_to_mini_roman \"too large\")]\n\
    \              [else (cond [(< number 1000000) (cons (int_to_mini_roman number\
    \ / 100) (cons 'm (int_to_mini_roman number % 100)))]\n                      \
    \  [else (cons (int_to_mini_roman number / 1000) (cons 'm (int_to_mini_roman number\
    \ % 1000)))]\n                        [else (cons (int_to_mini_roman number /\
    \ 100) (cons 'm (int_to_mini_roman number % 100)))]\n                        [else\
    \ (error 'int_to_mini_roman \"unreachable\")]))]))\n", "  (roman-numeral-to-string\
    \ number))\n", "  (roman->string number))\n", "  (cond\n    [(< 1 number) '']\n\
    \    [(< 1000 number) '']\n    [else (cond [(< number 1000) (int_to_mini_roman\
    \ number)]\n              [(< number 500) (cons 'I 'II)]\n              [(< number\
    \ 100) (cons 'I (int_to_mini_roman #(- number 100)))]\n              [(< number\
    \ 50) (cons 'I II)]))]))\n", "  (cond ((= number 0) 'zero)\n        ((< number\
    \ 1000000) (string-append 'croc' (int_to_mini_roman number))))\n  (string-append\
    \ (int_to_mini_roman number) (int_to_mini_roman number / 1000)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
