name: HumanEval_43_pairs_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; pairs_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns True if there are two distinct elements in the list that\n;; sum to\
  \ zero, and False otherwise.\n;; >>> pairs_sum_to_zero([1, 3, 5, 0])\n;; False\n\
  ;; >>> pairs_sum_to_zero([1, 3, -2, 1])\n;; False\n;; >>> pairs_sum_to_zero([1,\
  \ 2, 3, 7])\n;; False\n;; >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n;; True\n\
  ;; >>> pairs_sum_to_zero([1])\n;; False\n(define (pairs_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 -2 1)) #f)\n    (check-equal? (candidate (list 1 2 3 7)) #f)\n    (check-equal?\
  \ (candidate (list 2 4 -5 3 5 7)) #t)\n    (check-equal? (candidate (list 1)) #f)\n\
  \    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)\n    (check-equal? (candidate\
  \ (list -3 9 -1 3 2 31)) #t)\n    (check-equal? (candidate (list -3 9 -1 4 2 30))\
  \ #f)\n    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond [(null? l)\n         #t]\n        [else (pair? (car l))\n \
    \            (let ([x (car l)]\n                   [y (remove (car l) l)])\n \
    \              #t\n               (if (= x (- y 0))\n                   (and (not\
    \ (pair? (car y)))\n                       (pairs_sum_to_zero y))\n          \
    \         (and (not (pair? (car y)))\n                       (pairs_sum_to_zero\
    \ y)))]))))\n", "  (let ((a (subtotal l))\n        (z (filter-map f (filter-all\
    \ g l))))\n    (and (= a 0) (= (length a) 2)) (not (or (= a 0) (= (length a) 2)))))\n",
  "  (cond\n    [(empty? l)\n     (bool? '(True False))]\n    [else\n     (bool? (and\
    \ (= 0 (reduce + l)))\n            (pairs_sum_to_zero (rest l)))]))\n", "  (let\
    \ ((sum (apply + l)))\n    (and (not (= (modulo sum 0) 0))\n         (= (modulo\
    \ sum (rest l)) 0))))\n", "  (if (or (null? l) (null? (cdr l)))\n      null\n\
    \      (let ((c (car l)))\n        (if (>= (abs (- c c)) 0)\n            null\n\
    \            (let ((d (car l)))\n              (if (or (null? l) (null? (cdr l)))\n\
    \                  (and (eq? (abs (- c c)) 0) (eq? d c))\n                  (and\
    \ (eq? (abs (- c c)) 0) (eq? d d))\n                  (and (eq? (abs (- c c))\
    \ 0) (eq? d (cdr l)))\n                  (pairs_sum_to_zero (cdr l))))))\n  null))\n",
  "  (cond [(null? l) #t]\n        [(= (first l) (first '())) (= (first l) '())]\n\
    \        [else (equal? (+ (first l) (first '())) (pairs_sum_to_zero (rest l)))]))\n",
  "  (and (not (empty? l))\n       (= (first l) (reduce (lambda (x y) (+ (first x)\
    \ (first y)) l)))\n       (= (first l) (reduce (lambda (x y) (if (and (> (first\
    \ x) (first y)) (= (first x) (first y)) (first y) x)) 0 y)) l))))\n", "  (or\n\
    \   (null? l)\n   (or (null? (cdr l)) (> (cadr (car l)) 0))))\n", "  (cond ((null?\
    \ l) false)\n        ((null? (cdr l)) (= (car l) 0))\n        (else (let ((elem\
    \ (car l))\n                     (cdr (cdr l)))\n               (if (= (- elem\
    \ 0) (- cdr 0))\n                   (if (null? (cdr l))\n                    \
    \   (= elem 0)\n                       (pairs_sum_to_zero (cdr l))\n         \
    \              (= elem (- elem 0)))\n                   (if (= (- elem 0) (- cdr\
    \ 0))\n                       (= (pairs_sum_to_zero cdr) true)\n             \
    \          (= (pairs_sum_to_zero cdr) false)))))))\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI love the recursive approach, although it requires O(n^2) memory for\
    \ large lists. My solution would require O(n) memory, but uses O(n) comparisons\
    \ for large lists.\n<|/ c |>\n<| a dscore=0 |>\nHere's my solution. It uses only\
    \ one pass over the list, and requires O(n) memory usage.\n<code>", '  (< (length
    l) (* 2 (length l))))', "  (cond\n    [(empty? l) true]\n    [(pair? (cdr l))\
    \ (equal? (sum (car l)) 0)]\n    [else false]))\n", "  (let ((pairs '()))\n  \
    \  (cond\n      [(empty? l)\n       (empty? (cons (first l) pairs))]\n      [(>\
    \ (car l) (car (cdr l)))\n       (append (cons (first l) pairs)\n            \
    \  (pairs_sum_to_zero (cdr l)))]\n      [else\n       (let ((result (pairs_sum_to_zero\
    \ (cdr l))))\n         (cond\n           [result\n            (append pairs (list\
    \ (list (first l) 0 (- (second l) 0))))]\n           [else (append pairs (list\
    \ (first l) (second l) result))]))]))))\n", "  (cond\n    [(empty? l) false]\n\
    \    [(= (first l) 0) true]\n    [else (pairs_sum_to_zero (rest l))]))\n", " \
    \ (cond\n    [(empty? l) #t]\n    [else (and (pair? (car l))\n               (not\
    \ (equal? (sum (car l) (car l))\n                              0))\n         \
    \      (pair? (cdr l)))]\n  ))\n", "  (cond ((null? l) false)\n        ((pair?\
    \ l) (and (equal? (pair-sum (car l)) 0)\n                         (equal? (pair-sum\
    \ (cdr l)) 0))\n             (pairs_sum_to_zero (cdr l)))\n        (else (equal?\
    \ (pair-sum (car l)) 0)\n              (pairs_sum_to_zero (cdr l)))))\n</cell>\n\
    <text>\nProblem 3\nWrite a function named even? that takes one integer argument.\
    \ The function returns true if the argument is even, and false if the argument\
    \ is odd.\n\nExample:\n", "  (or (null? l)\n      (empty? l)\n      (< (reduce\
    \ + l) 0)))\n", "  (let* ((a (car l))\n         (b (cdr l))\n         (c (+ a\
    \ b))\n         (d (length l))\n         (e '()))\n    (if (= c 0)\n        (not\
    \ (= (length e) d))\n        (cond ((= a 0)\n              (not (= b 0))\n   \
    \           (cons e '()))\n              ((= b 0)\n              (not (= a 0))\n\
    \              (cons e '()))\n              (else\n              (if (= c d)\n\
    \                  (cons e '())\n                  (let* ((a (- a 1))\n      \
    \                  (b (- b 1))\n                        (c (+ a b))\n        \
    \                (d (length l))\n                        (e (cons e '()))))\n\
    \                (let* ((a (- a 1))\n                      (b (- b 1))\n     \
    \                 (c (+ a b))\n                      (d (length l))\n        \
    \              (e (cons e '()))))\n                (let* ((a (- a 1))\n      \
    \                (b (- b 1))\n                      (c (+ a b))\n            \
    \          (d (length l))\n                      (e (cons e '()))))\n        \
    \        (let* ((a (- a 1))\n                      (b (- b 1))\n             \
    \         (c (+ a b))\n                      (d (length l))\n                \
    \      (e (cons e '()))))\n                (let* ((a (- a 1))\n              \
    \        (b (- b 1))\n                      (c (+ a b))\n                    \
    \  (d (length l))\n                      (e (cons e '()))))\n                (let*\
    \ ((a (- a 1))\n                      (b (- b 1))\n                      (c (+\
    \ a b))\n                      (d (length l))\n                      (e (cons\
    \ e '()))))\n                (let* ((a (- a 1))\n                      (b (- b\
    \ 1))\n                      (c (+ a b))\n                      (d (length l))\n\
    \                      (e (cons e '()))))\n                (let* ((a (- a 1))\n\
    \                      (b (- b 1))\n                      (c (+ a b))\n      \
    \                (d (length l))\n                      (e (cons e '()))))\n  \
    \              (let* ((a (- a 1))\n                      (b (- b 1))\n       \
    \               (c (+ a b))\n                      (d (length l))\n          \
    \            (e (cons e '()))))\n                (let* ((a (- a 1))\n        \
    \              (b (- b 1))\n                      (c (+ a b))\n              \
    \        (d (length l))\n                      (e (cons e '()))", "  (and (= (length\
    \ l) 1)\n       (= (first (rest l)) 0)\n       (= (rest (rest l)) 0)\n       (=\
    \ (- 0 (+ (first l) (second l)))\n          0)))\n", "  (cond ((null? l) #f)\n\
    \        ((pair? (car l))\n         (pairs_sum_to_zero (cdr l)))\n        ((equal?\
    \ (car l) 0)\n         (equal? (cdr l) #f)\n         (true? #f))\n        (else\
    \ #f)))\n", "  (for/fold ((p null) (i 0))\n            (p cons (car l))\n    \
    \        (p '() (let ((p (cdr p)))\n                        (if (= (+ (car p)\
    \ (car l)) 0)\n                            #t\n                            (set!\
    \ p (cons (car l) (cons (car p) (cdr p))))))))\n  p\n)\n</cell>\n<code language=conda-env-adventofcode-py>\n\
    #lang racket\n", "  (define (helper lst index)\n    (cond ((null? lst) True)\n\
    \          ((equal? (car lst) 0) True)\n          ((= (+ (car lst) index) (- index\
    \ (car lst)))\n           (helper (cdr lst) index))\n          (else (helper (cdr\
    \ lst) index))))\n  (helper (reverse l) 0))\n", "  (let loop ((l l))\n    (cond\
    \ ((null? l) '())\n          ((null? (cdr l)) (= (car l) 0))\n          ((= (car\
    \ l) (cadr l))\n           (loop (cdr l)))\n          (else\n           (loop\
    \ (cdr l)))))\n", "  (for/fold ([true false] [false true])\n            [(sum\
    \ 0)\n             (count 0)]\n            (if (null? l)\n                [true\
    \ false]\n                (let ([e (first l)]\n                      [s (- e sum)])\n\
    \                  (if (or (= s 0)\n                          (= count (length\
    \ l)))\n                      [true false]\n                      (set! true (=\
    \ (- sum s) 0))\n                      (set! false (= (- sum s) 0))\n        \
    \              (set! sum (+ sum e))\n                      (set! count (+ count\
    \ 1)))))))\n", "  (cond\n    [(null? l) '()]\n    [(pair? l) (let* ([a (first\
    \ l)\n                        b (second l)])\n                  (cond\n      \
    \              [(= (+ a b) 0) (cons [a b] '())]\n                    [else (cons\
    \ [a b] (pairs_sum_to_zero (rest l)))]\n                  ))])\n    (else #f)))\n",
  "  (let ((x (car l))\n        (y (cadr l)))\n    (cond\n      [(= x y) true]\n \
    \     [(and (number? x)\n           (number? y))\n        false]\n      [(< x\
    \ y)\n        (pairs_sum_to_zero (cdr l))]\n      [(> x y)\n        (pairs_sum_to_zero\
    \ (cdr l))]))", "  (cond [(null? l)\n         (bool (< (car l) 0))\n         ]\n\
    \        [else (and (pair? (car l))\n                  (pairs_sum_to_zero (cdr\
    \ l)))]\n        ))\n", "  (let loop ((l l) (acc '()))\n    (cond ((null? l) acc)\n\
    \          ((null? (cdr l)) #f)\n          ((= (+ (car l) (car acc)) 0)\n    \
    \       (loop (cdr l)\n                 (cons (car l) acc)))\n          (else\n\
    \           (loop (cdr l)\n                 (cons (car l) acc))))))\n", '  (or
    (= (length l) 2) (= (apply + (map - l)) 0)))', "  (cond ((null? l) '())\n    \
    \    ((member (car l) l) '(()))\n        (else (cons (car l)\n               \
    \     (pairs_sum_to_zero (cdr l)))))\n  )\n", "  (let loop ((i 0) (sum 0) (count\
    \ 0))\n    (if (null? l)\n        (null? l)\n        (let ((x (car l)) (y (cadr\
    \ l)))\n          (if (= (+ sum x) 0)\n              (loop i (- sum x) (+ count\
    \ 1))\n              (if (= (- sum y) 0)\n                  (loop i (+ sum x)\
    \ (+ count 1))\n                  (loop i (+ sum x) (+ count 1))))))))\n", " \
    \ (define (helper i j) \n    (cond\n      [(= i (length l))\n       (= j 0)\n\
    \       true]\n      [(and (< i (length l)) (< j (length l)))\n       (if (= (+\
    \ (car l) (car l)) 0)\n           (helper i (add1 j))\n           (helper i (sub1\
    \ j)))]\n      [(= j 0)\n       (= (+ (car l) (car l)) 0)\n       (helper i (add1\
    \ j))\n       true]\n      [else\n       (helper (add1 i) j)\n       (helper (sub1\
    \ i) j)\n       true])))\n  (helper 0 0))\n", "  (and (empty? l) \n       (null?\
    \ (rest l))\n       (= (+ (first l) (second l)) 0)\n       (= (length l) 2)))\n",
  "  (let ([x (first l)]\n        [y (second l)]\n        [sum (+ x y)])\n    (cond\n\
    \      [(= sum 0) #f]\n      [else (and (equal? (first l) y)\n               \
    \ (pairs_sum_to_zero (rest l)))])))\n", "  (cond\n    [(null? l) false]\n    [(pair?\
    \ (car l)) (pairs_sum_to_zero (cdr l))])\n    [else (= (+ (car l) (cadr l)) 0)]))\n",
  "  (or (null? l) (null? (cdr l)))\n  (or (> (car l) 0) (< (car l) 0))\n  (= (sum\
    \ (cons (car l) (cdr l)))\n     (+ (sum (cons (- car l) (cdr l)) (car l)))\n \
    \ )\n)\n", '  (= (car l) 0))', "  (and (< (length l) 2)\n       (let ([head (car\
    \ l)\n              tail (cdr l)])\n         (if (or (< head 0) (< head tail))\n\
    \             (or (= head tail) (= head 0))\n             (or (= tail 0) (= tail\
    \ head))\n             (or (= head tail) (= tail head))\n             (and (=\
    \ head 0) (= tail 0))\n             (= head tail))))))\n", "  (define (helper\
    \ lst index)\n    (if (null? lst)\n        #t\n        (if (= (+ (car lst) (car\
    \ lst)) 0)\n            #f\n            (if (= index (- l (length lst)))\n   \
    \             #t\n                (helper (cdr lst) (incar index)))))\n    (helper\
    \ (cdr lst) 0)))\n", "  (let ([s (sort l <)])\n    (let loop ([s s])\n      (cond\n\
    \t[(null? s) (and (null? (car s)) (null? (cdr s)))]\n\t[(< (car s) (car cdr s))\
    \ (loop (cdr s))]\n\t[(equal? (car s) (car cdr s)) (and (equal? (car s) (cdr s))\
    \ (loop (cdr s)))]\n\t[else (loop (cdr s))])))\n  ;; (null? (cdr s)) (cdr s))\
    \ [(< (car s) (car cdr s)) (loop (cdr s))]\n  ;; (equal? (car s) (car cdr s))\
    \ (and (equal? (car s) (cdr s)) (loop (cdr s)))\n  ;; (else (loop (cdr s)))))\n\
    \  ))\n", "  (cond\n    [(null? l) True]\n    [(equal? (first l) (first (rest\
    \ l)))\n     (pairs_sum_to_zero (rest l))]\n    [else\n     (equal? (first l)\
    \ (+ (first l) (pair-sum (rest l))))]\n   )\n)\n", "  (cond [(empty? l) empty]\n\
    \        [(cons? l) (if (equal? (first l) 0)\n                      (equal? (second\
    \ l) 0))\n                      (if (equal? (first l) 0)\n                   \
    \       (equal? (second l) 0))]\n        [else (if (equal? (first l) 0)\n    \
    \              (and (equal? (second l) 0)\n                       (pairs_sum_to_zero\
    \ (rest l)))\n                  (and (equal? (second l) 0)\n                 \
    \      (not (pairs_sum_to_zero (rest l))))]))", "  (cond ((null? l) True)\n  \
    \      ((and (pair? (car l))\n              (pair? (caddr l)))\n         (and\
    \ (pair? (car (car l)))\n               (null? (caddr l))\n               (pairs_sum_to_zero\
    \ (cdr l))))\n        (else (and (pair? (car l))\n                  (pairs_sum_to_zero\
    \ (cdr l))))))\n", "  (cond [(empty? l) #t]\n        [(or (number? (first l))\n\
    \             (> (first l) 0))\n         (or (number? (second l))\n          \
    \   (> (second l) 0))\n         (or (< (first l) (second l))\n             (>\
    \ (second l) 0))]\n        [else\n         (or (equal? (first l) (second l))\n\
    \             (= (first l) (second l)))]\n        [(pairs_sum_to_zero (rest l))]))\n",
  "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n        ((equal? (+ (car\
    \ l) (car l)) 0)\n         (false)\n         (else (pairs_sum_to_zero (cdr l))))\n\
    \        (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond ((null? l) #f)\n  \
    \      ((equal? (car l) (cadr l)) #t)\n        (else (and (equal? (car l) (cadr\
    \ l))\n                   (pairs_sum_to_zero (cdr l)))))\n))\n", "  (cond\n  \
    \  [(null? l) false]\n    [(pair? (car l)) (pairs_sum_to_zero (cdr l))]\n    [else\
    \ (= 0 (+ (car l) (sum (cdr l))))]\n  )\n)\n", "  (and (null? (rest l))\n    \
    \   (not (null? (rest l))))\n  (and (equal? (first l) (first (rest l)))\n    \
    \   (equal? (second l) (second (rest l))))\n  (if (equal? (first l) (second l))\n\
    \      True\n      (pairs_sum_to_zero (rest l))))\n", "  (and\n    (for/fold ([acc\
    \ '()] [(i '())]) (i l)\n      (cond\n        ((or (< i 0) (< i (first acc)))\n\
    \         (set! acc (cons i (rest acc))))\n        ((equal? (first acc) (first\
    \ i)) (and (rest (rest acc)) (rest (rest i))))\n        ((equal? (first acc) (first\
    \ i)) (and (rest (rest acc)) (rest (rest i))))\n        ((equal? (first acc) (first\
    \ i)) (and (rest (rest acc)) (rest (rest i))))\n        ((equal? (first acc) (first\
    \ i)) (and (rest (rest acc)) (rest (rest i))))\n        (else (and (rest (rest\
    \ acc)) (rest (rest i))))))\n    (< (length acc) 2)))\n", "  (let loop ((l l)\
    \ (acc #t) (i 0))\n    (cond\n      [(null? l) (= acc #t)]\n      [(null? (cdr\
    \ l)) (= acc #f)]\n      [(< (car l) (car (cdr acc))) (loop (cdr l) (not acc (+\
    \ i 1))))]\n      [else (loop (cdr l) (or (equal? (sum (cdr acc)) 0)\n       \
    \                    (equal? (sum (cdr acc)) (- i (car acc)))))])))\n", "  (cond\
    \ [(null? l) false]\n        [(pair? (car l)) (pairs_sum_to_zero (cdr l))]\n \
    \       [else (= (car (foldr (lambda (x y) (+ x y)) 0 l)) 0)]))\n", "  (or (null?\
    \ l)\n      (and (pair? (car l)) (or (pairs_sum_to_zero (cdr l)) (equal? (cdr\
    \ (car l))\n                                            (sub1 (car l)))))))\n",
  "  (letrec\n    ((sift-pair (lambda (a b res idx)\n                  (cond [(not\
    \ (< idx 0))\n                         (letrec\n                          ((pair-element\
    \ (lambda (a b res idx elts)\n                                         (let ((x\
    \ a))\n                                           (set! idx (+ idx 1))\n     \
    \                                      (cond [(< idx 2)\n                    \
    \                               (set! idx (+ idx 1))\n                       \
    \                            (pair-element b a (cons x res) idx elts)\n      \
    \                                             (return-from pair-element res)]\n\
    \                                                [(> (+ b x) 0)\n            \
    \                                      (pair-element b (+ b x) res (cons x res)\
    \ idx)\n                                                  (pair-element a b (cons\
    \ x res) idx elts)\n                                                  (return-from\
    \ pair-element res)]\n                                                [else (pair-element\
    \ a b res (cons x res) idx)\n                                                \
    \  (return-from pair-element res)]))]))\n                     (set! idx (+ idx\
    \ 1))\n                     (pair-element a b res (cons idx '()) elts))\n    \
    \                 (pair-element a b res '() elts))))\n    (sift-pair '() '() '()\
    \ 0)))\n", "  (if (null? l)\n      #f\n      ;; two distinct elements are in the\
    \ list\n      (let ([s (car l)])\n        (cond (s (not (pair? s)) (not (null?\
    \ (cdr l))))\n              (else (not (= s 0)))))))\n", "  (let loop ([l l]\n\
    \             [m 0]\n             [result #f])\n    (cond\n      [(empty? l)\n\
    \       (if (= m 2)\n           (not result)\n           (loop (rest l) (add1\
    \ m) (not result)))]\n      [(equal? (car l) (cadr l))\n       (loop (rest l)\
    \ (add1 m) result)]\n      [else\n       (loop (rest l) (add1 m) (or (eq? (car\
    \ l) (cadr l)) result))]))))\n", "  (cond\n    [(empty? l) empty]\n    [(> (first\
    \ l) (first l)) false]\n    [else (or (pairs_sum_to_zero (rest l)) (pairs_sum_to_zero\
    \ (rest l))) (lists_equal? (first l) (first l)) ]\n  ))\n", "  (cond ((null? l)\n\
    \         (bool '#f))\n        ((equal? (car (car l)) 0)\n         (bool '#f))\n\
    \        (else (or (equal? (+ (car l) (car (cdr l)))) \n                   (pairs_sum_to_zero\
    \ (cdr l))))))\n", "  (for/fold ([acc #f])\n            (i [0 1]) (list (car l)\n\
    \                             (+ acc (car l))\n                             (-\
    \ acc (cdr l))))\n  (= acc 0))\n", "  (cond ((null? l) false)\n        ((equal?\
    \ (first l) (first (cdr l)))\n         (pairs_sum_to_zero (cdr l)))\n        (else\
    \ (equal? (first l) (first (cdr l)))\n              (pairs_sum_to_zero (cdr l))))))\n",
  "  (cond\n    [(empty? l) false]\n    [(member (last l) l) true]\n    [else (and\
    \ (pairs_sum_to_zero (cdr l)) (pairs_sum_to_zero (cdr l)))]))\n", "  (define (helper\
    \ lst so_far)\n    (cond ((null? lst) so_far)\n          ((= (first lst) so_far)\
    \ true)\n          ((helper (rest lst) so_far)\n           (helper (rest lst)\
    \ (+ so_far (first lst)))\n           (helper (rest lst) so_far))\n          (else\
    \ false)))\n  (helper (sort l) 0))\n", "  (and (= 2 (length l))\n       (= 0 (0\
    \ (car l)\n               (+ (car l)\n                  (cadr l))))))\n", "  (or\
    \ (null? l)\n      (and (pair? l) (= (first l) 0)\n              (= (second l)\
    \ 0))))\n", "  (for/fold ([acc '()])\n            ([elt (car l)])\n    (if (>\
    \ (* elt (cadr acc)) 0)\n        (cons elt (cons (car acc) (cons 0 (cddr acc))))\n\
    \        (cons elt acc))))\n", "  (for/fold ([pairs #f])\n            ([([x y\
    \ z] (and (= (+ x y z) 0) (or (pair? x) (pair? y) (pair? z))))]\n            \
    \ (if (pair? x)\n                 (if (pairs? y)\n                     (if (pairs?\
    \ z)\n                         (if (= (pairs x) (pairs y) (pairs z))\n       \
    \                  (set! pairs (cons (x (pairs y)) pairs))\n                 \
    \        (set! pairs (cons (y (pairs x)) pairs))\n                         (set!\
    \ pairs (cons (z (pairs x)) pairs))\n                         (pairs #f))\n  \
    \                   (if (= (pairs x) (pairs y))\n                       (set!\
    \ pairs (cons x (pairs z)))\n                       (set! pairs (cons y (pairs\
    \ z)))\n                       (pairs #f))\n                     (pairs #f))\n\
    \                 (if (pair? y)\n                     (if (pairs? z)\n       \
    \                  (if (= (pairs x) (pairs y) (pairs z))\n                   \
    \      (set! pairs (cons (x (pairs z)) pairs))\n                         (set!\
    \ pairs (cons (y (pairs x)) pairs))\n                         (set! pairs (cons\
    \ (z (pairs x)) pairs))\n                         (pairs #f))\n              \
    \       (if (= (pairs x) (pairs y))\n                       (set! pairs (cons\
    \ x (pairs z)))\n                       (set! pairs (cons y (pairs z)))\n    \
    \                   (pairs #f))\n                     (pairs #f))\n          \
    \       (if (pair? z)\n                     (if (pairs? x)\n                 \
    \        (if (pairs? y)\n                             (if (= (pairs x) (pairs\
    \ y) (pairs z))\n                             (set! pairs (cons (x (pairs z))\
    \ pairs))\n                             (set! pairs (cons (y (pairs x)) pairs))\n\
    \                             (set! pairs (cons (z (pairs x)) pairs))\n      \
    \                       (pairs #f))\n                         (if (= (pairs x)\
    \ (pairs y))\n                           (set! pairs (cons x (pairs z)))\n   \
    \                        (set! pairs (cons y (pairs z)))\n                   \
    \        (pairs #f))\n                         (pairs #f))\n                 \
    \    (if (pairs? y)\n                         (if (pairs? z)\n               \
    \              (if (= (pairs x) (pairs y) (pairs z))\n                       \
    \      (set! pair", "  (local ((define (helper lst sum)\n              (cond ((null?\
    \ lst)\n                     (eq? sum 0)))\n                ((pair? (car lst))\n\
    \                 (helper (cdr lst) (- (car lst) sum)))\n                (else\
    \ (helper (cdr lst) sum))))\n        (helper l 0))\n  (eq? true (local ((define\
    \ (helper lst sum)\n                      (cond ((null? lst)\n               \
    \             (eq? sum 0)))\n                     ((pair? (car lst))\n       \
    \                 (helper (cdr lst) (- (car lst) sum)))\n                    \
    \ (else (helper (cdr lst) sum))))\n          0)))\n", "  (cond [(empty? l) false]\n\
    \        [(equal? (first l) (first (rest l))) (pairs_sum_to_zero (rest l))]\n\
    \        [(< (sum (rest l)) 0)\n         (pairs_sum_to_zero (rest l))]\n     \
    \   [else true]))\n", "  (cond [(null? l) #t]\n        [(= (length l) 1) #t]\n\
    \        [else (and (null? (rest l)) (= (car l) 0))\n                (or (pairs_sum_to_zero\
    \ (cdr l))\n                    (= 0 (- car l))\n                    (= (car l)\
    \ (- 1 (cdr l))))])))\n</code>\n<|/ a dscore=3 tags=racket,scheme,functional-programming\
    \ |>\n<| c |>\nThis solution is elegant and elegantly simple to read. Can it be\
    \ modified to give false for a list containing `#t` at the end? For instance `pairs_sum_to_zero([1,2,3,#t])`\
    \ should be `false` and not `#t`. I don't want `#t` to be counted as a zero.\n\
    <|/ c |>\n<| c |>\nYou could check for `#f` in `pairs_sum_to_zero`.\n<|/ c |>\n\
    <| c |>\nYes, but it's already in `(= (length l) 1)`. Just add an extra `cond`\
    \ for the last one.\n<|/ c |>\n<| c |>\nThanks. I've been stuck on this for so\
    \ long, I was getting too annoyed.\n<|/ c |>\n<| c |>\nIt is not as elegant as\
    \ I expected :) I must admit that I'm not quite sure how it works. I would just\
    \ like to understand how it works, that's why I asked this question in the first\
    \ place. Anyway, thank you very much!\n<|/ c |>\n<| a |>\nHere is another solution:\n\
    <code>", "  (define (helper l acc pairs)\n    (cond [(null? l) (= acc 0)]\n  \
    \        [(helper (cdr l) (* (car l) acc) (car pairs))\n           (helper (cdr\
    \ l) acc (cdr pairs))]\n          [else\n           (helper (cdr l) (+ (car l)\
    \ acc) (car pairs))]))\n  (helper (cdr l) 0 '()))\n", "  (let loop ((result '())\n\
    \             (l l))\n    (cond\n      [(null? l) result]\n      [(zero? head\
    \ l)\n       (loop (cons (first l) result)\n             (rest l))]\n      [else\n\
    \       (loop (cons (first l) result)\n             (rest l))]))))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #t]\n    [else (and (pair? l)\n \
    \              (let ([x (first l)]\n                       [y (second l)])\n \
    \                (= (+ x y) 0))\n               (pairs_sum_to_zero (rest l))]))))\n",
  "  (cond [(empty? l) empty]\n        [(= (first l) (first l)) empty]\n        [else\
    \ (cons (first l) (pairs_sum_to_zero (rest l)))]))\n", "  (cond\n    [(empty?\
    \ l) (if (empty? l) (equal? l '()) '()) (equal? (car l) '())]\n    [else (or (equal?\
    \ (car l) (cadr l)) (equal? (car l) (caddr l)))]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]\n    [else (if (equal? (car l) (caddr l)) (and (equal? (caddr l) '())\
    \ (cadr l)) (and (equal? (caddr l) (cadr l)) (equal? (caddr l) (caddr l))))]))\n",
  "  (cond [(empty? l) #f]\n        [(member (car l) (cadr l)) #f]\n        [(< (cadr\
    \ (car l)) (+ (car l) (cadr (car l))))\n         (pairs_sum_to_zero (cdr l))]\n\
    \        [else #t]))\n", "  (= (count l) (length (filter null (remove 0 (map -\
    \ l))))))\n", "  (let* ((pairs (pairs l))\n         (pair (first pairs))\n   \
    \      (sum (second pair))\n         [a b]\n         (pairs (rest pairs)))\n \
    \   (if (null? pairs) #t\n        (and (not (= a sum)) (not (= b sum)))\n    \
    \    (and (= a sum) (= b sum))\n        (and (not (= a sum)) (= b sum))\n    \
    \    (pairs_sum_to_zero (cdr pairs))))))\n", "  (cond ((null? l)\n         #f)\n\
    \        ((null? (cdr l))\n         (= (car l) 0))\n        (else (= (+ (car l)\
    \ (car (cdr l)))\n                  (pairs_sum_to_zero (cdr l)))))\n  )\n", " \
    \ (define (iter l acc)\n    (if (null? l)\n        (if (= acc 0)\n           \
    \ (if (not (= (first l) acc))\n                (cons acc (iter (rest l) acc))\n\
    \                nil)\n            acc)\n        (iter (rest l) (+ (first l) acc)))))\n\
    \  (iter l (if (null? l) 0 0)))\n", "  (cond ((null? l) false)\n        ((equal?\
    \ (first l) (first l)) true)\n        (else (pairs_sum_to_zero (rest l)))))\n",
  "  (cond [(null? l) #f]\n        [(equal? (add1 car) (add1 cdr)) #t]\n        [else\
    \ (pairs_sum_to_zero (cdr l))]\n))\n</cell>\n<cell>", "  (let ([sum (first l)]\n\
    \        [l (rest l)])\n    (cond [(or (empty? l) \n               (< sum 0))\n\
    \           #f]\n          [else\n           (pair? l)\n           (pairs_sum_to_zero\
    \ (cdr l))]))) ;#lang racket\n", "  (cond [(null? l) false]\n        [else (equal?\
    \ (first l) (second l)) (pairs_sum_to_zero (rest l))]\n        [else (equal? (first\
    \ l) 0)\n             (equal? (second l) (first l))\n             (pairs_sum_to_zero\
    \ (rest l))]\n        [else (equal? (first l) 0)\n             (equal? (second\
    \ l) (first l))\n             (equal? (third l) (first l))\n             (pairs_sum_to_zero\
    \ (rest l))]\n        [else (equal? (first l) 0)\n             (equal? (second\
    \ l) (first l))\n             (equal? (third l) (first l))\n             (equal?\
    \ (fourth l) (first l))\n             (pairs_sum_to_zero (rest l))]\n        [else\
    \ (equal? (first l) 0)\n             (equal? (second l) (first l))\n         \
    \    (equal? (third l) (first l))\n             (equal? (fourth l) (first l))\n\
    \             (equal? (fifth l) (first l))\n             (pairs_sum_to_zero (rest\
    \ l))]\n        [else (equal? (first l) 0)\n             (equal? (second l) (first\
    \ l))\n             (equal? (third l) (first l))\n             (equal? (fourth\
    \ l) (first l))\n             (equal? (fifth l) (first l))\n             (equal?\
    \ (sixth l) (first l))\n             (pairs_sum_to_zero (rest l))]))\n", "  (or\
    \ (null? l)\n      (null? (cdr l)\n               ;; two distinct elements that\
    \ sum to zero\n               (and (or (= (car l) (cdr l))\n                 \
    \        (= (car l) 0)))))\n  )\n", "  (cond [(empty? l) #false]\n        [(member\
    \ (first l) (second l) #f) #t]\n        [else (pairs_sum_to_zero (rest l))]\n\
    \        ))\n", "  (cond\n    [(empty? l) empty]\n    [(equal? (first l) (last\
    \ l)) (empty)]\n    [(equal? (first l) (last l)) empty]\n    [else (if (equal?\
    \ (+ (first l) (first l)) 0)\n              (pairs_sum_to_zero (rest l))\n   \
    \           (pairs_sum_to_zero (rest l)))]))\n", "  (cond ((null? l) '())\n  \
    \      ((equal? (first l) 0) (= (first l) (second l)) (pairs_sum_to_zero (rest\
    \ l)))\n        (else (cons (first l) (pairs_sum_to_zero (rest l))))))\n", " \
    \ (cond ((null? l) #f)\n        ((equal? (car l) 0)\n         (equal? (cdr l)\
    \ 0)\n         (pairs_sum_to_zero (cdr l)))\n        (else (equal? (pair? (car\
    \ l)) true)\n              (equal? (pair? (cdr l)) true)\n              (pairs_sum_to_zero\
    \ (cons (car l)\n                                       (cons (cdr l)\n      \
    \                                         '())))))))\n", "  (= (length l) 2)\n\
    \  (let ((c (car l))\n        (dst (car l)))\n    (if (= c dst)\n        #t\n\
    \        (let ((r (cdr l))\n              (s (+ c dst)))\n          (cond ((or\
    \ (= c r) (= dst r)) #f)\n                ((= s r) #f)\n                ((pair?\
    \ r) (pairs_sum_to_zero r))\n                (else #f)))))))\n", "  (cond\n  \
    \  [(empty? l) #t]\n    [(zero? (first l)) #t]\n    [else (let ([head-pair (first\
    \ l)\n                     tail-pairs (rest l)])\n            (cond\n        \
    \      [(zero? (first tail-pairs)) #t]\n              [else (or (pairs_sum_to_zero\
    \ (rest tail-pairs))\n                        (and (pair? head-pair)\n       \
    \                      (equal? (+ head-pair (first tail-pairs))\n            \
    \                        0)))]))]))\n", "  (cond [(empty? l) #false]\n       \
    \ [(= (first l) 0) #false]\n        [else (pair? l)\n             (cond (pairs?\
    \ l)\n                    (and (pair? (first l))\n                         (pairs_sum_to_zero\
    \ (rest l)))\n                    [else #f]))]))\n", "  (let* ((pair (lambda (l)\n\
    \                   (if (null? l)\n                       null\n             \
    \          (append (list (first l) (second l))\n                             \
    \ (pair (rest l))))))\n         (empty (lambda ()\n                   (eq? pair\
    \ (lambda () null)))))\n    (and (pair (pair? l))\n         (if (empty? l)\n \
    \            #f\n             (pair (first l)))))) \n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(pair? l) (equal? (car l) (pairs_sum_to_zero (cdr l)))]\n    [else\
    \ #f]))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThe accepted solution has\
    \ a problem. Consider pairs (1, 0), (2, 0), (3, 0), which will evaluate to true\
    \ in a boolean context, because 1+0=0. However, (2, 0) will evaluate to false\
    \ in a boolean context, because 2+0=0. \nIf you add another rule [else #f] to\
    \ the end of the cond statement, you will get the correct result:\n<code>", " \
    \ (cond\n    [(empty? l)\n     (equal? #f (first l))]\n    [(equal? (first l)\
    \ (second l))\n     (equal? (first l) (third l))\n     (equal? (first l) (fourth\
    \ l))\n     (equal? (first l) (fifth l))\n     (equal? (first l) (sixth l))\n\
    \     (equal? (first l) (seventh l))]\n    [else\n     (equal? (first l) (second\
    \ (first l)))\n     (equal? (second (first l)) (third (first l)))\n     (equal?\
    \ (third (first l)) (fourth (first l)))\n     (equal? (fourth (first l)) (fifth\
    \ (first l)))\n     (equal? (fifth (first l)) (sixth (first l)))\n     (equal?\
    \ (sixth (first l)) (seventh (first l)))]\n    )\n  )\n", "  (if (empty? l)\n\
    \      false\n      (let ((a (car l))\n            (b (cdr l)))\n        (and\
    \ (= (+ (* a a) b) (* 0 b)) (= (- a b) 0))\n        (pairs_sum_to_zero (cdr l)))))\
    \ ;; #lang racket\n", "  (cond ((null? l) false)\n        ((pair? l) (equal? (first\
    \ l) (second l)))\n        (else (and (equal? (first l) 0)\n                 \
    \ (pairs_sum_to_zero (rest l))))))\n</code>\n<|/ a tags=scheme |>\n<| a dscore=1\
    \ |>\nHere is an Scheme solution which I think I like very much.\n<code>", " \
    \ (cond ((null? l) #t)\n        ((equal? (first l) (second l)) #t)\n        (else\
    \ (and (pair? (first l))\n                  (pairs_sum_to_zero (rest l)))))) ;\
    \ this one isn't very elegant\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\n\
    I like this answer.  I should note that I did not test this code, but it looks\
    \ correct and it does look nicer than my answer. :)\n<|/ c |>\n<| a |>\n<code>",
  "  (let ((pair (append (list-ref l 0) (list-ref l 1))))\n    (and (not (null? pair))\n\
    \         (equal? (rest pair) 0)\n         (equal? (first pair) (first l)))))\n",
  "  (cond [(null? l)  #f]\n        [(member (car l) (cadr l))\n         (or (pairs_sum_to_zero\
    \ (cdr l))\n             (pairs_sum_to_zero (cdr l)))]\n        [else      (if\
    \ (= (car l) 0)\n                     (= (cadr l) 0)\n                     (false)))]))\n",
  "  (let loop ((p l) (s 0))\n    (cond ((null? p) (values false s))\n          ((equal?\
    \ (car p) (cadr p)) (loop (cdr p) (+ s (car p))))\n          (else (loop (cdr\
    \ p) s)))))\n", "  (let loop ((l (car l))\n             (acc (car l))\n      \
    \       (sum (car (cdr l))))\n    (cond\n      [(empty? l) (equal? (car l) 0)]\n\
    \      [else\n       (cond\n         [(= sum (- acc (* 2 acc)))\n          (cond\n\
    \            [(= acc (* 1 acc))\n             (loop (cdr l) (+ acc (* 2 sum))\
    \ sum)]\n            [else\n             (loop (cdr l) acc sum)]\n         )]\n\
    \         [else\n          (loop (cdr l) acc sum)]\n       )]\n    )))\n</code>\n\
    The solution is recursive, which is much easier to read than a procedural one,\
    \ and this also has the benefit that you can test each element in the list against\
    \ the sum and see if it works.\n<|/ a dscore=2 tags=scheme,racket |>\n<| a dscore=2\
    \ |>\nAs a functional approach:\n<code>", "  (if (null? l)\n      #f\n      ;\
    \ here we assume that l is sorted\n      (let loop ((l (sort l))\n           \
    \      (ls (cdr l)))\n        (cond\n          ((= (+ first l) (+ rest ls))\n\
    \           (loop (rest l) ls))\n          ((null? ls)\n           (= (+ first\
    \ ls) 0))\n          (else\n           (loop (rest l) (cons (first l) (first ls)))))))\n",
  "  (cond [(null? l) false]\n        [(equal? (first l) (last (rest l))) true]\n\
    \        [else false]))\n", "  (cond [(empty? l) #t]\n        [(pair? (cdr l))\
    \ (or (pair? (cdr (car l)))\n                           (or (pair? (cddr l))\n\
    \                               (pairs_sum_to_zero (cdr l)))))]\n        [else\
    \ #f]))\n", "  (and (equal? length (sort l)) (= (+ (car l) (cadr l)) 0)))\n",
  "  (cond\n    ((null? l)\n     (false))\n    ((equal? (car l) 0)\n     (equal? (cdr\
    \ l) 0)\n     (false))\n    ((equal? (car l) (cdr l))\n     (equal? (cdr l) 0)\n\
    \     (true))\n    ((equal? (car l) (cdr l))\n     (true))\n    (else\n     (pairs_sum_to_zero\
    \ (cdr l))))) ;; <-- line 6\n", "  (cond [(null? l)\n         (empty? l)\n   \
    \      #f]\n        [(equal? (first l) (first (rest l)))\n         (pairs_sum_to_zero\
    \ (rest l))]\n        [else\n         (pair? (first l))\n         (equal? (first\
    \ (first l)) (pair? (first (rest l))))\n         (equal? (first (pair? (first\
    \ l))) (pairs_sum_to_zero (rest l)))]\n        [else #f]))\n", "  (cond\n    ((null?\
    \ l) #t)\n    ((= (first l) 0) #f)\n    ((= (second l) 0) #t)\n    ((= (+ (first\
    \ l) (second l)) 0)\n     (pairs_sum_to_zero (rest l)))\n    (else (#t (pairs_sum_to_zero\
    \ (rest l))))))\n", "  (cond\n    [(empty? l) true]\n    [(equal? (rest l) 0))\
    \ true]\n    [else (equal? (rest l)\n                    (reduce +\n         \
    \                  l\n                           (map (lambda (x)\n          \
    \                       x (+ x 1))\n                                 (rest l))\n\
    \                         (pairs_sum_to_zero (rest l))))]))\n", "  (let ((p (gensym\
    \ \"pairs_sum_to_zero\")))\n    (let loop ((c 0) (pair ()))\n      (if (null?\
    \ l)\n          (if (or (zero? c) (zero? (cdr pair)))\n              (display\
    \ pair)\n              (display \"false\")\n              (display \"\\n\")\n\
    \              (set! pair '())\n              (set! c 0)\n              (return\
    \ false)\n              )\n          (if (= c 0)\n              (display \"false\"\
    )\n              (display \"\\n\")\n              (set! pair '())\n          \
    \    (set! c 0)\n              (return false)\n              )\n          (set!\
    \ c (+ c 1))\n          (set! pair (cons (car l) pair))\n          (loop (cdr\
    \ pair) pair)\n          )\n      (display \"true\")\n      (display \"\\n\")\n\
    \      (set! pair '())\n      (set! c 0)\n      (return true)\n      )\n    )\n\
    \  )\n  ", "  (cond ((null? l) '())\n        ((eq? (car l) (car (cdr l))) t)\n\
    \        (else (and (pairs-sum-to-zero (cdr l))\n                  (eq? (car l)\
    \ (car (cdr l)))))))\n", "  (define (helper l seen pair-sum)\n    (cond\n    \
    \  [(null? l)\n       #t]\n      [(pair-sum (car l) pair-sum)\n       (helper\
    \ (cdr l) (cons (car l) seen) (pair-sum (car l) pair-sum))]\n      [else\n   \
    \    (helper (cdr l) seen (pair-sum (car l) pair-sum))]))\n  (let ([found (helper\
    \ (reverse l) #f 0)])\n    (and (not found)\n         (not (pair-sum (car l) 0)))))\n",
  "  (cond [(empty? l) empty]\n        [(equal? (rest l) 0) false]\n        [else\
    \ (equal? (rest (first l)) 0) false]\n        [else (equal? (rest (first (rest\
    \ l))) 0) (pairs_sum_to_zero (rest l))]\n        ))\n", "  (= (length l) (length\
    \ \n                  (filter (lambda (pair) (pair '0 '(1)))\n               \
    \           (map (lambda (pair) (cons pair '((0 1)))) l))))\n  )\n", "  (cond\n\
    \    [(empty? l) false]\n    [(pair? (car l)) (pairs_sum_to_zero (cdr l))]\n \
    \   [else (+ (car l) (cadr l))]\n    ))\n  \n", "  (for/or ((e (car l))\n    \
    \        (c (cdr l)))\n    (cond ((= 0 (+ e c)) #t)\n          ((not (null? (cdr\
    \ l))) (cond ((null? (cdr l)) #f) (else #f) (else (pairs_sum_to_zero (cdr l)))))))\n",
  "  (cond\n    [(empty? l) #f]\n    [else (= (first l) 0)\n           (= (second\
    \ l) 0)\n           (= (third l) 0)\n           (= (fourth l) 0)\n           (=\
    \ (fifth l) 0)]\n   )\n )\n", "  (define (helper l r)\n    (cond ((null? l) r)\n\
    \          ((eq? (car l) (car (cdr l))) (helper (cdr l) (add1 r)))\n         \
    \ (else (helper (cdr l) (add1 r))))\n  (helper l 0))\n</cell>\n<text>\nWe see\
    \ that the predicate pairs_sum_to_zero is exactly the same as the predicate zero?,\
    \ which we already saw earlier. Both of them have the special property that if\
    \ any two elements in a list sum to zero, they will both appear in the list with\
    \ the same index.\n\nWhat about pairs? The function pairs creates an infinite\
    \ list of all possible pairs of elements from l. For instance, if l is [1 2 3\
    \ 4], the function will produce an infinite list of all possible pairs of elements\
    \ from l: [(1) (2) (3) (4) (1)...].\n\nThe function pairs_sum_to_zero can be rewritten\
    \ to use pairs instead of an explicit for loop:\n\n\n</text>\n<cell>\n#lang racket\n",
  "  (cond\n    [(empty? l) #f]\n    [(not (pair? l)) #f]\n    [(not (pair? (rest\
    \ l)))\n     (< (expt (first (rest l)) 2)\n         (expt (first (first l)) 2))]\n\
    \    [else (and (pair? (first l))\n              (pair? (second l))\n        \
    \      (= (expt (first (first l)) 2)\n                  (expt (first (second l))\
    \ 2))\n              (not (pairs_sum_to_zero (rest l))))]))\n", "  (= (length\
    \ l) 2)\n  (= (first l)\n     (second l)))", "  (and (< (length l) 2)\n      \
    \ (not (null? (remove-duplicates l))))))\n</code>\n<|/ a tags=functional-programming,racket,scheme\
    \ |>\n<| c |>\nI appreciate your help so much. Thanks :)\n<|/ c |>\n<| c |>\n\
    `remove-duplicates` is `O(n^2)`, this solution will run in O(n^3). Not too bad\
    \ for a first attempt.\n<|/ c |>\n<| c |>\nI didn't realise that, I just wrote\
    \ the code in the SO editor, so I guess I didn't test it. Thanks for the reminder.\n\
    <|/ c |>\n<| c |>\nYou might want to think about what happens if there are zero\
    \ numbers in the list, should it return `#t` or `#f`? Should it return `#f` if\
    \ the list contains exactly one number that sums to zero, `#t` if the list contains\
    \ two or more numbers that sum to zero, and `#t` if the list contains any number\
    \ of numbers that sum to zero? All three possibilities are possible, all three\
    \ are possible when the list contains at least one number that sums to zero.\n\
    <|/ c |>\n<| c |>\nThat is why I pointed out my code is not going to work right\
    \ if `#t` is returned if there are any two distinct numbers that sum to zero.\n\
    <|/ c |>\n<| a |>\nA possible solution in Racket:\n<code>", "  (or (= (length\
    \ l) 2)\n      (= (reduce + l) 0)))\n", "  (let loop ((s 0) (r 0) (c (cdr l)))\n\
    \    (cond\n      [(null? c) r]\n      [(eq? (car c) s)\n       (loop (+ s r)\
    \ 0 (cdr c))]\n      [else\n       (loop (+ s r) (car c) (cons (car c) (cdr c)))]))\n",
  "  (cond [(empty? l) #f]\n        [(member (first l) l) #t]\n        [(= (+ (first\
    \ l) (first l)) 0) #t]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  (let\
    \ ((a (car l))\n        (b (cdr l)))\n    (and (< b 0)\n         (= a 0)\n   \
    \      (= (+ (car l) b) 0)\n         (pairs_sum_to_zero (cdr l)))))\n", "  (equal?\
    \ ((filter even? (map - l)) l)\n         (filter even? (map - l))))\n", "  (cond\
    \ [(empty? l) #f]\n        [(pair? (car l)) (pairs_sum_to_zero (cdr l))]\n   \
    \     [else #f]))\n", "  (let loop ((l l)\n              (i 1))\n    (cond\n \
    \     [(= i l)\n       (= 0 (reduce +\n                 (map (lambda (x)\n   \
    \                      (if (>= x 0)\n                             (- x 1)\n  \
    \                           x))\n                     l)))]\n      [(= 0 (car\
    \ l))\n       (= i (car l))]\n      [(= i (cdr l))\n       (loop (cdr l)\n   \
    \          (+ i (car l)))]\n      [else\n       (loop (cdr l)\n             (+\
    \ i (car l)))]\n      ))))\n", "  (cond [(null? l) true]\n        [(pair? (car\
    \ l)) (and (pair? (car l)) (eq (cadr l) 0))]\n        [else (or (pairs_sum_to_zero\
    \ (car l)) (pairs_sum_to_zero (cdr l)))]\n        )) \n", "  (define (helper l\
    \ acc)\n    (cond\n      [(empty? l) acc]\n      [else (helper (rest l)\n    \
    \              (cond [(eqv? (car l) 0) (equal? acc (car l)) acc]\n           \
    \             [(pair? l)\n                         (helper (cdr l)\n         \
    \                        (cond [(equal? acc (car l)) acc]\n                  \
    \                     [else (cons acc acc)]))]\n                    [else (cons\
    \ (car l) (cons acc acc))]))]))\n  (helper l #f))\n", "  (cond\n    [(empty? l)\
    \ empty]\n    [(= (head l) 0) empty]\n    [else (or (equal? (pairs_sum_to_zero\
    \ (rest l)) empty)\n               (equal? (head l) (sum (rest l))))]))\n", " \
    \ (cond\n    [(empty? l) false]\n    [(pair? (car l)) (let ([el1 (car l)]\n  \
    \                       [el2 (cdr l)])\n                       (cond\n       \
    \                  [(= (+ (car l) (cdr l)) 0) (= el1 el2)] \n                \
    \         [else (pair? (car l)) (pairs_sum_to_zero el2)]))]\n    [else (let ([el1\
    \ (car l)]\n               [el2 (car l)])\n           (cond\n             [(=\
    \ (+ (car l) (cdr l)) 0) (= el1 el2)] \n             [else (pairs_sum_to_zero\
    \ el2)])]\n    [else false]\n  ))\n", "  (cond [(empty? l) false]\n        [(equal?\
    \ (rest l) 0)\n         (equal? (rest l) (rest (rest l)))]\n        [else\n  \
    \       (equal? (first l) (first l))\n         (equal? (first l) (rest (first\
    \ l)))\n         (pairs_sum_to_zero (rest l))]\n        ))\n", "  (let loop ((sum\
    \ 0) (l l))\n    (cond [(null? l) false]\n          [(< sum (car l)) (loop (+\
    \ sum (car l)) (cdr l))]\n          [else (loop (+ sum 0) (cdr l))]))))\n", " \
    \ (cond ((null? l) #t)\n        ((equal? (car l) (cadr l)) #f)\n        (else\
    \ (and (pair? (car l))\n                   (equal? (cdr l) (pair-sum (car l) (cadr\
    \ l)))\n                   (pairs_sum_to_zero (cdr l)))))) \n", "  (let loop ((pairs\
    \ l) (sum 0) (found false))\n    (cond ((null? pairs) found)\n          ((= 0\
    \ (- (car pairs) sum)) found)\n          (else (loop (cdr pairs) sum (or (equal?\
    \ (car pairs) sum) found))))))\n", "  (define (pairs_sum_to_zero l)\n    (if (empty?\
    \ l)\n        #f\n        (if (pair? (car l))\n            (if (equal? (cadr l)\
    \ 0)\n                #t\n                #f)\n            (if (equal? (car l)\
    \ (cadr l))\n                #t\n                (if (equal? (car (rest l)) 0)\n\
    \                    #t\n                    (if (equal? (car (rest l)) (cadr\
    \ (rest l)))\n                        #t\n                        #f))))\n   \
    \   (if (equal? (car l) (cadr l))\n          #t\n          (if (equal? (car (rest\
    \ l)) 0)\n              #t\n              (if (equal? (car (rest l)) (cadr (rest\
    \ l)))\n                  #t\n                  #f))))))\n  (pairs_sum_to_zero\
    \ l))\n", "  (cond ((null? l) false)\n        ((= (first l) 0)\n         (= (second\
    \ l) 0)\n         (false))\n        (else\n         (let ((sum (+ (first l) (second\
    \ l)))\n               (next (pairs_sum_to_zero (rest l))))\n           (and (=\
    \ sum 0)\n                (not next)))\n        )))\n</code>\nAnd here are some\
    \ solutions, using both Racket and Racket/Scheme:\n<code>\n#lang racket\n", " \
    \ (let loop ((pairs null) (sum 0))\n    (cond\n      [(null? pairs) #t]\n    \
    \  [(> (car pairs) sum) #f]\n      [else (loop (cdr pairs) (+ sum (car pairs)))])))",
  "  (cond\n    [(empty? l) true]\n    [(= (head l) (last l)) false]\n    [else (=\
    \ (first l) (sum (tail l)))\n          (pairs_sum_to_zero (tail l))]\n    [else\
    \ (pairs_sum_to_zero (tail l))]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else false]\n    [else false]\n    [else false]\n    [else\
    \ false]\n    [else false]\n    [else false]\n    [else false]\n    [else false]\n\
    \    [else false]\n    [else ", '  (equal? (car (group-by (lambda (x) (= (+ x
    0) 0) l))) 0))', "  (cond [(null? l) empty]\n        [(member (- (car l) (cadr\
    \ l)) (filter (lambda (x) (not (= x 0)) (cdr l)))) empty]\n        [else (pairs-sum-to-zero\
    \ (cdr l))]))\n", "  (cond [(null? l) #false]\n        [(pair? (car l)) (pairs_sum_to_zero\
    \ (cdr l))]\n        [else (= (car l) 0)]\n        ))\n", "  (cond\n    [(empty?\
    \ l) true]\n    [else (= (sum l) 0)\n          (or (eq? (car l) (cadr l))\n  \
    \            (pairs_sum_to_zero (cdr l)))]))\n", "  (if (null? l)\n      (cond\
    \ ((equal? 0 (cdr l)) #t)\n            ((equal? (car l) (cadr l)) #t)\n      \
    \      (else #f))\n      (cond\n        ((equal? (car l) (cadr l))\n         (cond\
    \ ((equal? 0 (cadr l)) #t)\n               ((equal? (car l) (caddr l)) #t)\n \
    \              (else #f)))\n        ((equal? (cadr l) (caddr l))\n         (cond\
    \ ((equal? 0 (caddr l)) #t)\n               ((equal? (car l) (caddrr l)) #t)\n\
    \               (else #f)))\n        (else #f))))\n", "  (cond ((null? l) false)\n\
    \        ((= (first l) 0) true)\n        (else (pairs_sum_to_zero (rest l)))))\n",
  "  (< (apply + l) (apply - (map - l))))\n", "  (let ((pairs (assoc 0 (group-by (lambda\
    \ (e)\n                                       ((< e 0) (- e 1))\n            \
    \                           (< e 0) (- e 1)))\n                            l))))\n\
    \    (and (null? pairs)\n         (null? (rest pairs)))))\n", "  (for/sum (([i]\
    \ [(sub1 (length l)) l]) ([j] [(sub1 (length l)) l]))\n    (= (+ i j) 0))\n)\n",
  "  (cond\n    [(empty? l) empty]\n    [(null? (rest l)) (equal? (first l) 0)]\n\
    \    [else (equal? (first l) (second l))]\n))\n", "  (not (pair? l))\n  (and (equal?\
    \ (car l) 0) (equal? (cdr l) 0))\n  (or (pair? (cdr l))\n      (and (equal? (car\
    \ l) (cdr l))\n           (pairs_sum_to_zero (cdr l)))))", "  (cond\n    [(empty?\
    \ l) '()]\n    [(pair? (first l)) (let ((y (first l)) (m (second l))) (cond\n\
    \                            [(= m 0) (or (pairs_sum_to_zero '() (cons x y))\n\
    \                                        (pairs_sum_to_zero '() (cons y x)))]\n\
    \                            [else (cond\n                                   \
    \ [(= (+ m (- m (abs y)))\n                                        0) (pairs_sum_to_zero\
    \ '() (cons x y))]))]\n    [else (cond\n             [(= (+ l (- l (abs (first\
    \ l))))\n                 0) (pairs_sum_to_zero '() (cons (first l) (pair-sum-to-zero\
    \ l))]\n             [else (let ([m (second l)\n                          r (pair-sum-to-zero\
    \ l)]\n                      (cond\n                        [(empty? l) '()]\n\
    \                        [(pair? (first l)) (let ([y (first l)\n             \
    \                                  x (first r)])\n                           \
    \         (cond\n                                     [(= m 0) (or (pairs_sum_to_zero\
    \ '() (cons x y))\n                                                    (pairs_sum_to_zero\
    \ '() (cons y x)))]\n                                     [else (cond\n      \
    \                                      [(= (+ m (- m (abs y)))\n             \
    \                                   0) (pairs_sum_to_zero '() (cons x y))])])]\n\
    \                        [(= (+ m (- m (abs y)))\n                           \
    \  0) (pairs_sum_to_zero '() (cons y x))]\n                        [else (cond\n\
    \                                [(= (+ m (- m (abs y))) 0) (pairs_sum_to_zero\
    \ '() (cons y x))])]))]))]))]))\n", "  (let loop ((lst l) (sum 0))\n    (cond\n\
    \      [(null? lst) #false]\n      [(= 0 (+ lst sum)) #true]\n      [else (loop\
    \ (rest lst) (+ sum 1))])))\n</code>\n<|/ a |>\n<| c |>\nThis answer is actually\
    \ wrong: it returns `#t` for [1, 1, 0] and for `#t` the code returns #false. It\
    \ also doesn't return `#t` for [0, 0, 0] and for `#t` the code returns #false.\
    \ Also the code only works for lists of length 3 or larger. [This question](http://stackoverflow.com/questions/10782919/how-to-find-pairs-of-numbers-that-sum-to-zero-in-scheme)\
    \ has a better algorithm that works for lists of arbitrary length and doesn't\
    \ use mutation.\n<|/ c |>\n<| c |>\nthe question I linked to has a better algorithm\
    \ than the one I proposed.\n<|/ c |>\n<| c |>\nThis answer is wrong. Try it with\
    \ [1, 1, 0]. Your code returns #t. Try it with [0, 0, 0] and your code returns\
    \ #t. Try it with [1, 1, 0] and your code returns #f.\n<|/ c |>\n<| c |>\nI changed\
    \ it to return the right answer now.\n<|/ c |>\n<| a tags=racket,scheme dscore=1\
    \ |>\nHere's a Scheme implementation of Euclid's algorithm.\n<code>", "  (define\
    \ (helper lst acc)\n    (cond ((null? lst) acc)\n          ((= (+ acc (car lst))\
    \ 0)\n           (helper (cdr lst) (add1 acc)))\n          (else (helper (cdr\
    \ lst) (add1 acc))))\n    (helper l 0)))\n", "  (cond [(empty? l) false]\n   \
    \     [(equal? (first l) (first (rest l))) false]\n        [else (and (pairs_sum_to_zero\
    \ (rest l))\n                    (equal? (first l) (first (rest l))))]))\n", " \
    \ (cond\n    ((null? l)\n     #f)\n    ((pair? (car l))\n     (cond ((> (car l)\
    \ 0) #t)\n           (else (pairs_sum_to_zero (cdr l))))\n     (else (pairs_sum_to_zero\
    \ (cdr l)))))\n  (cond\n    ((null? (cdr l))\n     #f)\n    ((pair? (car l))\n\
    \     (cond ((> (car l) 0) #t)\n           (else (pairs_sum_to_zero (cdr l))))\n\
    \     (else (pairs_sum_to_zero (cdr l))))))\n", "  (cond\n    [(empty? l) false]\n\
    \    [(pair? (car l)) (equal? (car l) (cadr l))\n                  (equal? (car\
    \ l) (caddr l)) true]\n    [else (equal? (pair? (car l)) (pairs_sum_to_zero (cdr\
    \ l)))]))\n", "  (cond\n    ((empty? l) #t)\n    ((equal? (first l) (first '()))\n\
    \     (equal? (second l) (second '()))\n     (pairs_sum_to_zero (rest l)))\n \
    \   ((equal? (first l) 0)\n     (equal? (second l) 0)\n     (equal? (third (first\
    \ l)) (third (first '())))\n     (equal? (third (first '())) (third (second '())))\n\
    \     (equal? (third (first '())) (third (second (first '()))))\n    (else #f)\n\
    \    )\n  )\n)\n", "  (cond [(null? l) #f]\n        [(equal? (first l) 0) #f]\n\
    \        [else (equal? (rest l) 0)\n              (and (pairs_sum_to_zero (rest\
    \ l))\n                  (pairs_sum_to_zero (first l)))]\n  )\n)\n</cell>\n<code\
    \ language=dyalog-kernel>", "  (cond [(null? l) false]\n        [(= (sum l) 0)\
    \ false]\n        [else (set! seen (cons l (cdr seen))) (pairs_sum_to_zero (cdr\
    \ seen))]))\n", "  (cond\n    [(empty? l) #f]\n    [(not (member (first l) (second\
    \ l)))\n     (and (pairs_sum_to_zero (rest l)) (pairs_sum_to_zero (rest l)))]\n\
    \    [else #f]))\n", "  (and (>= (length l) 2)\n       (= (reduce + (filter pair-sum-to-zero\
    \ l)) 0)))\n", "  (cond [(null? l) false]\n        [(pair? l) (= (+ (car l) (cadr\
    \ l)) 0)\n          (else (pairs_sum_to_zero (cdr l)))]\n        [else true]))\n",
  "  (cond\n    [(empty? l) false]\n    [(member (first l) (second l)) false]\n  \
    \  [else (pairs_sum_to_zero (rest l))]\n  )\n)\n", "  (cond [(null? l) false]\n\
    \        [(equal? (first l) (rest l)) true]\n        [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) true]\n    [(pair? l) (cond\n\t\t\
    [(equal? (first l) (first (rest l))) (cond\n\t\t                             \
    \       [(equal? (second l) (second (rest l))) (pairs_sum_to_zero l)]\n\t\t  \
    \                                  [else false]]\n\t\t                       \
    \         [else false]\n\t\t                               )\n\t\t]\n\t\t[else\
    \ false]\n\t   )\n\t])\n  )\n", '  (< (count l) 2))', "  (cond\n    ((null? l)\
    \ '())\n    ((= (first l) (first '())) true)\n    (else (or (pairs_sum_to_zero\
    \ (rest l)) (pairs_sum_to_zero (rest '()))))))\n", "  (cond [(empty? l) #t]\n\
    \        [(equal? (first l) (first l))\n         (pairs_sum_to_zero (rest l))]\n\
    \        [else #f]))\n", "  (cond\n    [(empty? l) false]\n    [(member (first\
    \ l) (first l) (second l)) false]\n    [(equal? (first l) (second l)) false]\n\
    \    [else (let ([sum (+ (first l) (second l))])\n               (cond\n     \
    \            [(= sum (-0)) true]\n                 [(= sum (0)) false]\n     \
    \            [(= sum (- sum (first l)))\n                  (pairs_sum_to_zero\
    \ (rest l))])))]))\n", "  (cond ((null? l) #t)\n        ((equal? (car l) (car\
    \ (cdr l)))\n         (and (pairs-sum-to-zero (cdr l))\n               (pairs_sum_to_zero\
    \ (cdr l)))\n         (equal? (car l) (pairs-sum-to-zero (cdr l)))\n         (else\
    \ (pairs_sum_to_zero (cdr l))))))\n", "  (cond\n    [(empty? l) '()]\n    [(pair?\
    \ (first l)) (let ((c (first l))\n                          (t (pairs_sum_to_zero\
    \ (rest l))))]\n      [else (cond\n             [(= 0 (+ (first c) (first t)))\
    \ true]\n             [else false]])]))\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This is not correct if there are negative numbers in the list.\n<|/ c |>\n<| c\
    \ |>\nIt works for positive numbers and negative numbers. Try it yourself with\
    \ examples in my answer. Also, it's not clear what is the correct answer for input\
    \ `[5, -1]` - is it `[3, -1]` or `[5, -1]` ?\n<|/ c |>\n<| a |>\nUsing a helper\
    \ function:\n<code>", "  (let loop ((list l) (sum 0) (seen '()))\n    (cond\n\
    \      ((null? list)\n       (= sum 0))\n      ((null? (cdr list))\n       (not\
    \ (pair? (car list)))\n       (loop (cdr list) (+ sum (car list)) (cdr seen)))\n\
    \      (else (loop (cdr list) (+ sum (car list)) (cons sum (cdr seen))))))\n",
  "  (< (length l) 2)\n  (or (= (apply + l) 0)\n      (let ((acc (apply + l))\n  \
    \          (l (cons (car l) l)))\n        (if (< (apply + l) 0)\n            (>\
    \ (apply + l) (- acc))\n            (if (> (apply + l) 0)\n                (pairs_sum_to_zero\
    \ (cdr l))\n                (= (apply + l) acc))))))\n", "  (cond [(null? l) #t]\n\
    \        [(not (pair? l)) #f]\n        [(or (equal? (car l) (pair? (cadr l)))\n\
    \             (equal? (car l) (pair? (caddr l)))\n             (equal? (car l)\
    \ (pair? (cadddr l))))\n         (equal? (cadr l) (pair? (cadr l))\n         \
    \         (equal? (caddr l) (pair? (caddr l))\n                            (equal?\
    \ (cadddr l) (pair? (cadddr l))))]\n        [else #t]\n        )))\n", "  (let\
    \ loop ((lst lst)\n             (res #t))\n    (cond\n      [(null? lst)\n   \
    \    res]\n      [(= (cdr lst) 0)\n       (loop (cdr lst) (not res))]\n      [(<\
    \ (car lst) (cadr lst))\n       (loop (cdr lst) (or (not res) (not (loop (cdr\
    \ lst) res))))]\n      [else\n       (loop (cdr lst) (or (not res) (loop (cdr\
    \ lst) (or res #f))))])))\n", "  (let ((s1 0)\n        (s2 0)\n        (c 0))\n\
    \    (if (null? l)\n        (empty? l)\n        (let ((x (car l)))\n         \
    \ (cond\n            ( (< (+ x 1) 0) #t)\n            ( (= c 0)\n            \
    \  (= x s1)\n              (= (+ x s1) s2)\n              (= (+ x s2) 0)\n   \
    \           (= (+ x s2) s1)\n              (= s1 s2)\n              (= s2 0)\n\
    \              (= (+ x s2) s1))\n            ( (< (+ x 1) 0)\n              (=\
    \ s1 0)\n              (= s2 0)\n              (= (+ x s1) (+ s2 c))\n       \
    \       (= (+ x s2) (+ c x))\n              (= (+ x s2) (+ c x))\n           \
    \   (= s1 s2)\n              (= s2 0)\n              (= (+ x s2) s1))\n      \
    \      ( (> (+ x 1) 0)\n              (= s1 0)\n              (= s2 0)\n     \
    \         (= (+ x s1) (+ s2 c))\n              (= (+ x s2) (+ c x))\n        \
    \      (= (+ x s2) (+ c x))\n              (= s1 s2)\n              (= s2 0)\n\
    \              (= (+ x s2) s1))\n            ( (< (+ x 1) 0)\n              (=\
    \ s1 0)\n              (= s2 0)\n              (= (+ x s1) (+ s2 c))\n       \
    \       (= (+ x s2) (+ c x))\n              (= (+ x s2) (+ c x))\n           \
    \   (= s1 s2)\n              (= s2 0)\n              (= (+ x s2) s1))\n      \
    \      ( (> (+ x 1) 0)\n              (= s1 0)\n              (= s2 0)\n     \
    \         (= (+ x s1) (+ s2 c))\n              (= (+ x s2) (+ c x))\n        \
    \      (= (+ x s2) (+ c x))\n              (= s1 s2)\n              (= s2 0)\n\
    \              (= (+ x s2) s1))\n            ( (< (+ x 1) 0)\n              (=\
    \ s1 0)\n              (= s2 0)\n              (= (+ x s1) (+ s2 ", "  (= (length\
    \ l) 1)\n  (cond\n    ((null? l) #f)\n    ((= (first l) 0)\n     (= (second l)\
    \ 0)\n     (= (+ (first l) (second l))\n          0)\n     (false #f))\n    ((=\
    \ (first l) (second l))\n     (false #f))\n    ((> (first l) (second l))\n   \
    \  (false\n      (cond\n        ((> (first l) (second l))\n         (false\n \
    \         (cond\n            ((> (first l) (second l))\n             (false\n\
    \              (cond\n                ((< (first l) 0)\n                 (false\n\
    \                  (cond\n                    ((= (first l) 0)\n             \
    \        (false\n                      (cond\n                        ((< (second\
    \ l) 0)\n                         (false\n                          (cond\n  \
    \                          ((= (second l) 0)\n                             (false\n\
    \                              (cond\n                                ((= (+ (first\
    \ l) (second l)) 0)\n                                 (false\n               \
    \                   (cond\n                                    ((= (+ (first l)\
    \ (second l)) 0)\n                                     (false\n              \
    \                        (cond\n                                        ((< (+\
    \ (first l) (second l)) 0)\n                                         (false\n\
    \                                          (cond\n                           \
    \                 ((= (+ (first l) (second l)) 0)\n                          \
    \                   (false\n                                              (cond\n\
    \                                                (#t (and (= (+ (first l) (second\
    \ l)) 0)\n                                                       (pairs_sum_to_zero\
    \ (rest l)))\n                                                 (#f)))))))))\n\
    \                                (#t (and (= (+ (first l) (second l)) 0)\n   \
    \                                      (pairs_sum_to_zero (rest l)))\n       \
    \                         (#f (#f))))))\n                            (#t (and\
    \ (= (+ (first l) (second l)) 0)\n                                     (pairs_sum_to_zero\
    \ (rest l)))\n                            (#f (#f))))))))\n                  \
    \    (#t (and (= (+ (first l) (second l)) 0)\n                               (pairs_sum_to_zero\
    \ (rest l)))\n                      (#f (#f))))))))\n              (#t (and (=\
    \ (+ (first l) (second l)) 0)\n                       (pairs_sum_to_zero (rest\
    \ l)))\n                (#f (#f))))))))\n    (#t (and (= (+ (first l) (second\
    \ l)) 0)\n           (pairs_sum_to_zero (rest l)))\n    (#f (#f))))))\n", "  (cond\
    \ [(empty? l) (or (pair? (car l)) false)] \n        [else\n         (equal? (+\
    \ (car l) (pair? (cdr l)))\n                  (+ (car l) (cdr l)))\n         (pairs_sum_to_zero\
    \ (cdr l))]\n         [else true]))\n", "  (cond\n    [(empty? l) (boolean?)\n\
    \     (= (length l) 0)\n     (empty? (rest l))]\n    [(= (first l) (rest (first\
    \ l))) (= (rest (first l)) 0)\n     ((empty? (rest l)) false)\n     ((pairs_sum_to_zero\
    \ (rest l))\n      (boolean? (cons (first l) empty)))]\n    [else true]\n    ))",
  "  (if (empty? l)\n      (or (null? (first l))\n          (null? (rest l)))\n  \
    \    (and (pair? (first l))\n           (null? (rest (first l))))\n      (and\
    \ (pair? (first l))\n           (null? (rest (first l)))\n           (pairs_sum_to_zero\
    \ (rest l)))))", "  (define (loop-helper i acc)\n    (if (= i (length l))\n  \
    \      acc\n        (loop-helper (+ i 1) (and (= (- l (first acc)) (first acc))\
    \ acc))))\n  (loop-helper 1 #f))\n", "  (cond [(= 0 (sum (list car l) (cdr l)))\n\
    \         #t]\n        [else\n         (not (pairs_sum_to_zero (cdr l)))]))\n",
  "  (define (helper l sum count)\n    (cond ((null? l) false)\n          ((= count\
    \ 0) (= sum 0))\n          (else (helper l (+ sum (car l)) (add1 count))))))\n\
    \  (helper l 0 0))\n", "  (cond\n    [(empty? l) (empty)]\n    [(equal? (first\
    \ l) 0)\n     (equal? (second l) 0)\n     (equal true (equal? (first l) (second\
    \ l)))]\n    [(equal? (first l) 0)\n     (equal? (second l) 0)\n     (equal false\
    \ (equal? (first l) (second l)))]\n    [else (if (equal? (first l) (pairs_sum_to_zero\
    \ (rest l)))\n             true\n             false)]))\n", "  (cond ((null? l)\
    \ true)\n        ((< (car l) (cadr l)) false)\n        (else (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (cond\n    [(null? (cdr l)) (boolean (pair? l))]\n    [else\
    \ (and (boolean (pair? (car l))) (boolean (pair? (cdr l))))]\n  ))\n", "  (cond\
    \ [(null? l)\n         #t]\n        [(or (not (pair? l))\n             (pair?\
    \ (car l)))\n         #f]\n        [else\n         (equal? (sum (cons (car l)\
    \ (cons (car l) #f)) '#f)\n                   (sum (cdr l) '#f))\n         #t]\n\
    \        [else #f]))\n", "  (cond\n    [(empty? l) true]\n    [(equal? (first\
    \ l) (first l)) (pairs_sum_to_zero (rest l))]\n    [(equal? (first l) (second\
    \ l)) (pairs_sum_to_zero (rest l))]\n    [else false]\n    ))\n", "  (cond [(null?\
    \ l) #false]\n        [(= 2 (pair? (car l)))\n         (eq? (car l) (cadr l))\
    \ ; a tricky case\n         (eq? (cadr l) (cadr l)) ; a tricky case\n        \
    \ #f]\n        [else (cons (car l) (pairs_sum_to_zero (cdr l)))]\n      )\n  )\n",
  "  (cond\n    [(empty? l) #f]\n    [(zero? (first l)) #t]\n    [else (and (pair?\
    \ (first l))\n              (pairs_sum_to_zero (rest l)))]))\n", "  (let loop\
    \ ((lst '()) (n 0))\n    (if (null? lst)\n        #f\n        (let ((x (car lst)))\n\
    \          (if (= n 2)\n              #t\n              (loop (cdr lst) (+ 1 n))\n\
    \            (if (= (- x n) 0)\n              #t\n              (loop (cons x\
    \ lst) n))))))\n", "  (cond\n    [(empty? l) #t]\n    [(pair? (car l)) (eq? (car\
    \ l) (pair-sum (cdr l)))]\n    [else #f]))\n", "  (cond [(empty? l) (empty?)]\
    \ \n        [(pair? (car l)) (and (pairs_sum_to_zero (cdr l)) (not (equal? (car\
    \ l) 0)))]\n        [else false]))\n", "  (< (length l)\n      (reduce + (map\
    \ \n                  (lambda (n acc) \n                    (if (< acc 0)\n  \
    \                      acc\n                      (if (< n 0)\n              \
    \            acc\n                        (+ (car l)\n                       \
    \   (* n\n                            (if (= n (cadr l))\n                   \
    \             acc\n                                (cdr acc))))))\n          \
    \        (range 1 (- 1 (length l))))))\n  )\n", "  (if (null? l)\n      #f\n \
    \     (= (car l) 0) (= (cadr l) 0)\n      (and (and (= (car l) (cadr l)) (= (cadr\
    \ l) 0))\n           (pairs_sum_to_zero (cdr l)))))\n", "  (let ([f (lambda (x)\
    \ (- x 0))])\n    (define (helper lst acc)\n      (cond [(empty? lst) (= acc 0)]\n\
    \            [else (helper (cdr lst) (f (+ acc (first lst))))]))\n    (helper\
    \ l 0)))\n", "  (and (null? l)\n       (null? (cdr l))\n       (not (zero? (+\
    \ (car l) (cadr l))))))\n", "  (let loop ((pairs l) (result #f))\n    (if (null?\
    \ pairs)\n        result\n        (loop (cdr pairs)\n              (if (or (not\
    \ result) (= (+ (car pairs) (car result))\n                                 (minusp\
    \ (- (car pairs) (car result))))\n                   result\n                \
    \   #f))))))\n", "  (or (null? l)\n      (and (= (car l) (cadr l))\n         \
    \  (cadr (cdr l))\n           (cadr (cdr (cdr l))))))\n", "  (cond\n    [(empty?\
    \ l) false]\n    [else (and (= (+ (first l) (first l)) 0)\n               (pairs_sum_to_zero\
    \ (rest l)))]\n    [else true]))\n", "  (cond [(null? l) false]\n        [else\
    \ (let ([a1 (first l)]\n                    [a2 (first l)])\n               (cond\n\
    \                 [(= a1 a2) (pairs_sum_to_zero (rest l))]\n                 [else\
    \ (or (pairs_sum_to_zero (cons a l))\n                             (pairs_sum_to_zero\
    \ (cons a1 l)))]))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
