name: HumanEval_30_get_positive
language: rkt
prompt: "#lang racket\n\n;; Return only positive numbers in the list.\n;; >>> get_positive([-1,\
  \ 2, -4, 5, 6])\n;; [2, 5, 6]\n;; >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123,\
  \ 1, -10])\n;; [5, 3, 2, 3, 9, 123, 1]\n(define (get_positive l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n\
  \    (check-equal? (candidate (list -1 -2 4 5 6)) (list 4 5 6))\n    (check-equal?\
  \ (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1))\n    (check-equal?\
  \ (candidate (list -1 -2)) (list ))\n    (check-equal? (candidate (list )) (list\
  \ ))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) '()]\n    [(list? (first l)) (cons (first\
    \ l) (get_positive (rest l)))]\n    [else (cons (first (rest l)) (get_positive\
    \ (rest l)))]))\n", "  (map positive? (remove negative? (cdr l))))\n", "  (filter\
    \ (lambda (x) (>= x 0)) l))\n", "  (cond [(empty? l) nil]\n        [(zero? (car\
    \ l)) nil]\n        [(positive? (car l)) (cons (car l) (get_positive (cdr l)))]\n\
    \        [else (cons (car l) (get_positive (cdr l)))]))\n</code>\n<|/ a |>\n<|\
    \ c |>\nI'm surprised this isn't the accepted answer; it seems to me to be a lot\
    \ more intuitive than the other solutions, especially for newcomers.\n<|/ c |>\n\
    <| a tags=scheme,racket,lisp |>\nThe answer is to use filter and map (Racket docs\
    \ say, \"filter is the filter function and map is the map function):\n<code>",
  "  (cond\n    ((empty? l) l)\n    ((positive? (first l))\n     (cons (first l)\n\
    \           (get_positive (rest l))))\n    (else (cons (first l)\n           \
    \     (get_positive (rest l))))))\n", "  (cond [(null? l)\n         '()]\n   \
    \     [(number? (car l))\n         (cons (car l)\n               (get_positive(cdr\
    \ l)))]\n        [else\n         (get_positive (cdr l))]))\n", "  (cond\n    ((null?\
    \ l) '())\n    ((zero? (car l))\n     (cons (car l) (get_positive\n          \
    \         (cdr l))))\n    (else (cons (car l)\n              (get_positive\n \
    \              (cdr l)))))\n  )\n", "  (filter (lambda (n) (>= n 0)) l))\n", " \
    \ (filter (lambda (x) (>= x 0)) l))\n", "  (filter (lambda (n) (>= n 0))\n   \
    \       l))\n</code>\n<|/ a dscore=1 |>\n<| a tags=scheme,racket,lambda |>\nThis\
    \ answer demonstrates how to use the Racket built-in filter procedure to remove\
    \ any element from the list which is negative.\n<code>", "  (filter positive?\
    \ (map negate l)))\n", "  (filter (lambda (n) (> n 0)) l))\n", "  (filter (lambda\
    \ (n) (number? n) (> n 0))\n          l))\n", "  (filter (lambda (n) (>= n 0))\n\
    \          l))\n", "  (filter \n   (lambda (x) (not (< x 0)))\n   l))\n", "  (cond\n\
    \    [(null? l) (list null)]\n    [(list? (car l)) (get_positive (car l))]\n \
    \   [(< 0 (car l)) (get_positive (cdr l))]\n    [else (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  ;; If l is empty, return empty list.\n  (cond [(empty? l)\
    \ '()]\n        ;; Return only positive numbers in the list.\n        [(number?\
    \ (first l)) (cons (first l) (get_positive(rest l)))]\n        ;; Return positive\
    \ numbers plus numbers after the first.\n        [else (cons (first l) (get_positive(rest\
    \ l)))]))\n", "  (filter (lambda (n) (< n 0)) l))\n", "  (filter (lambda (x) (number?\
    \ x)) l))\n", "  (cond\n    [(empty? l) l]\n    [(< (first l) 0) (append (get-positive\
    \ (rest l)) (list first (first l)))]\n    [else (first l)]))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (define (f l acc)\n    (cond\n      [(null? l) acc]\n\
    \      [else (f (rest l) (cons (car l) acc))]\n      ))\n  (f l '()))\n", "  (filter\
    \ (\u03BB (x) (> x 0)) l))\n", "  (cond\n    ((null? l) '())\n    ((<= (car l)\
    \ 0) (car l))\n    (else (get_positive (cdr l)))))\n", "  (if (null? l)\n    \
    \  '()\n      (append (map (\u03BB(x) (if (<= x 0) x 0)) l)\n               (get_positive\
    \ (rest l)))))\n", "  (filter positive? l))\n", "  (let loop ((l l) (acc '()))\n\
    \    (if (null? l)\n        acc\n        (loop (cdr l) (cons (car l) acc)))))\n",
  "  (filter (lambda (x) (< x 0)) l))\n", "  (filter (\u03BB (n) (>= n 0)) l))\n</code>\n\
    If you have trouble with the lambdas, here are some alternatives:\n<code>", " \
    \ (filter (lambda (x)\n            (and\n              (number? x) (> x 0))\n\
    \            (lambda (x) (< x 0))\n            l))\n)\n", "  (cond\n    [(empty?\
    \ l) l]\n    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (cons (first l) (get_positive (rest l)))]))\n", "  (filter (\u03BB\
    \ (x) (> x 0)) l))\n", "  (filter (lambda (x) (> x 0)) (concat l)))\n", "  (filter\
    \ (lambda (x) (not (zero? x))) l))\n", "  (filter positive? l))\n</code>\n<|/\
    \ a tags=functional-programming,racket dscore=2 |>\n<| a tags=functional-programming,racket\
    \ |>\nThis can also be done without using \"map\" as such:\n<code>", "  (cond\
    \ [(empty? l) empty]\n        [(> (first l) (first l))\n         (cons (first\
    \ l) (get_positive (rest l)))]\n        [else (cons (first l) (get_positive (rest\
    \ l)))]))\n", "  (filter positive? (reverse l)))\n", "  (filter (lambda (x) (>\
    \ x 0)) l))\n", "  (filter (lambda (num)\n            (if (< num 0)\n        \
    \        (return-from get_positive num)\n                (return)))\n        \
    \  l))\n", "  (filter (lambda (n) (> n 0)) l))\n", "  (if (empty? l)\n      '()\n\
    \      (append (if (>= (car l) 0)\n                  (cons (car l) (get_positive\
    \ (cdr l)))\n                  (get_positive (cdr l)))\n               (get_positive\
    \ (cdr l))))\n", "  (cond ((null? l) l)\n        ((< (car l) 0) l)\n        (else\n\
    \         (cons (car l)\n               (get_positive (cdr l)))))\n)\n", "  (filter\
    \ (lambda (x) (< x 0)) l))\n", "  (cond [(< l 0) nil]\n        [else (cons (car\
    \ l) (get_positive (cdr l)))]))", "  (cond [(empty? l) empty]\n        [else (cons\
    \ (car l) (get_positive (cdr l)))]))\n", "  (filter (lambda (n m) (positive? (-\
    \ n m)))\n         l))\n", "  (cond\n    [(empty? l) (empty)]\n    [(= (first\
    \ l) (-)) (empty)]\n    [else (cons (first l) (get_positive (rest l)))]))\n",
  "  (cond [(empty? l) empty]\n        [(and (number? (first l)) (> 1 (first l)))\n\
    \         (cons (first l) (get_positive (rest l)))]\n        [else (get_positive\
    \ (rest l))]))\n", "  (filter (lambda (n) (number? n)) l))\n", "  (cond [(null?\
    \ l) '()]\n        [(positive? (car l)) (cons (car l) (get_positive (cdr l)))]\n\
    \        [else (get_positive (cdr l))]))\n", "  (map car (filter positive? (reverse\
    \ l))))\n", "  (filter (lambda (x) (not (< x 0)))\n          l))\n", "  (remove-if(compose(<\
    \ 0) f) l))\n</code>\n<|/ a dscore=0 tags=scheme,lisp,racket,functional-programming\
    \ |>\n<| a |>\n<code>", "  (reverse\n   (remove\n    ; Remove negatives first\n\
    \    ; >>> get_positive([-10, 1, 2, 3, -3, 5, -5, 6, -9])\n    ; [-1, 2, -3, 5,\
    \ -5, 6]\n    (remove\n      ; Keep positives\n      ; >>> get_positive([-1, 2,\
    \ -3, 5, -5, 6, -9])\n      ; [2, 3, 5, -5, 6]\n      (remove\n        ; Remove\
    \ zero elements\n        ; >>> get_positive([-1, 2, -3, 5, 0, -5, 6, -9])\n  \
    \      ; [2, 3, 5, 6]\n        (filter\n          ; Keep positive numbers\n  \
    \        ; >>> get_positive([-1, 2, -3, 5, 0, -5, 6, -9])\n          ; [2, 3,\
    \ 5, 6]\n          (lambda (x) (not (= x 0)))))))))\n", "  (cond [(null? l) l]\n\
    \        [(>= (car l) 0) (cons (car l) (get_positive (cdr l)))]\n        [else\
    \ (get_positive (cdr l))]))\n", "  (filter (lambda (x) (>= x 0)) l))\n", "  (filter\
    \ (lambda (n)\n            (and\n             (< n 0)\n             (not (negative?\
    \ n)))\n          l))\n)\n", "  (cond [(null? l) '()]\n        [(number? (car\
    \ l)) (cons (car l) (get_positive (cdr l)))]\n        [(number? (car l)) (get_positive\
    \ (cdr l))]\n        [else (cons (car l) (get_positive (cdr l)))]))\n", "  (filter\
    \ (lambda (n) (< n 0)) l))\n", '  (filter number? l))', "  (filter (lambda (x)\
    \ (and (> x 0) (< x 0))) (map list l)))\n", "  (filter (lambda (x) (< x 0)) l))\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nHm, that's an interesting idea, but I get\
    \ the error \"Wrong type argument: stringp, #<procedure:get_positive>\".  I guess\
    \ my real question would be how to get the function get_positive to work with\
    \ a list of strings (which I assume are just lists of characters).\n<|/ c |>\n\
    <| c |>\nThanks John.  Unfortunately, this didn't work for me.  I got the same\
    \ error as before.  I even tried changing the code to include a procedure that\
    \ takes a string, instead of an atom (just for debugging purposes).  I also tried\
    \ changing the type of x to string, but that didn't help either.  Any other ideas?\n\
    <|/ c |>\n<| a tags=racket,filter,scheme |>\nOk, so I figured out how to get the\
    \ function I was looking for to work with the list of strings.  I needed to convert\
    \ the strings into a list of integers (I assume that is what \"filter\" would\
    \ do automatically), then I needed to change the type of x to integer.  Here is\
    \ the working code:\n<code>\n#lang racket\n", "  (filter (lambda (x) (not (negative?\
    \ x))) l))\n", "  (cond [(null? l) nil]\n        [(number? (car l)) (car l)]\n\
    \        [(negative? l) get_positive (cdr l)]\n        [else (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  (cond\n    ((empty? l) '())\n    ((> (car l) 0) (cons (car\
    \ l) (get_positive (cdr l))))\n    (else (cons (car l) (get_positive (cdr l))))))\n\
    </code>\n<|/ a |>\n<| c |>\nI think this code is very difficult to read. Is there\
    \ any way to make it more clear?\n<|/ c |>\n<| c |>\nI suggest you use some kind\
    \ of IDE that provides good code completion.\n<|/ c |>\n<| a dscore=1 |>\nJust\
    \ one last variation:\n<code>", "  (cond [(null? l) l]\n        [(number? l) (if\
    \ (> l 0) l nil)]\n        [(cons? l) (append (get_positive (car l)) (get_positive\
    \ (cdr l)))]\n        [else (error \"not a list\")]))\n", "  (let loop ([ll l]\
    \ \n             [x '()])\n    (if (null? ll)\n        x\n        (loop (cdr ll)\
    \ (cons (car ll) x)))))\n", "  (filter (lambda (n) (> n 0)) l))\n", "  (cond [(null?\
    \ l) (list l)]\n        [(positive? l) (cons (car l) (get_positive (cdr l)))]\n\
    \        [else (get-positive (cdr l))]))\n", "  (cond [(empty? l) empty]\n   \
    \     [(negative? (first l)) (append (first l) (get_positive (rest l)))]\n   \
    \     [else (cons (first l) (get_positive (rest l)))]))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (cond [(null? l)\n         '()]\n        [(positive?\
    \ head) (cons (head l) (get_positive (rest l)))]\n        [else (cons (head l)\
    \ (get_positive (rest l)))]))\n", "  (if (null? l)\n      '()\n      (let ([head\
    \ (car l)])\n        (if (number? head)\n            (if (= head 0)\n        \
    \        (cons head l)\n                (cons head (get_positive (cdr l))))\n\
    \            (cons head (get_positive (cdr l)))))) ; recurse\n", "  (filter positive?\
    \ (list l)))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (n)\n\
    \            (and (number? n)\n                 (not (zero? n)))\n           \
    \ l))\n)\n#lang racket\n", "  (filter pos? (list l)))\n", "  (filter (lambda (n)\
    \ (>= n 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n</code>\n<|/ a tags=scheme,racket\
    \ dscore=1 |>\n<| a dscore=0 tags=scheme,racket |>\nHere is another variation\
    \ of the function that returns only positive numbers, using map and filter:\n\
    <code>", "  (filter (lambda (n)\n            (and (positive? n) (< n 0)))\n  \
    \        l))\n", "  (cond ((null? l) '())\n        ((negative? (car l)) l)\n \
    \       (else\n         (cons (car l)\n              (get_positive (cdr l)))))\n\
    \  )\n", "  (cond\n    [(empty? l) empty]\n    [(= (first l) 0) (cons 0 (get_positive\
    \ (rest l)))]\n    [else (cons (first l) (get_positive (rest l)))]))\n", "  (filter\
    \ (lambda (n)\n            (and (> n 0) (< n 0))\n            ))\n  l)\n", " \
    \ (cond [(null? l) l]\n        [(positive? (car l)) (get_positive (cdr l))]))\n\
    </code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| c |>\n+1 for the most efficient\
    \ solution, but don't forget to also give the non-recursive solution.\n<|/ c |>\n\
    <| c |>\nI prefer this answer, as it is easy to understand.\n<|/ c |>\n<| a dscore=1\
    \ tags=racket,scheme |>\nIt can be done using foldl and filter\n<code>", "  (cond\n\
    \    [(empty? l) empty]\n    [(cons? l) (cons (car l) (get_positive (cdr l)))]\n\
    \    [else (append (get_positive (car l)) (get_positive (cdr l)))]))\n", "  (filter\
    \ (lambda (n) (>= n 0)) l))\n</code>\n<|/ a tags=scheme |>\n<| c |>\nThis is an\
    \ answer to the wrong question.\n<|/ c |>\n<| c |>\nYou're right. The question\
    \ was edited and I have now edited my answer. Thank you!\n<|/ c |>\n<| c |>\n\
    `'()` is not a list but a symbol. The quote should be removed.\n<|/ c |>\n<| c\
    \ |>\nThank you. I fixed it.\n<|/ c |>\n<| a dscore=2 |>\nI find that it is easier\
    \ to define procedures that take lists as arguments.  A procedure, given an argument,\
    \ should produce an output with the same argument.  So (f [1 2 3 4 5]) should\
    \ produce [1 2 3 4 5] and so on.  \nThen you can use those procedures for other\
    \ problems.  For instance, to get the length of the list you can do something\
    \ like (list-length [1 2 3 4 5])\n<code>", "  (let ([head (first l)]\n       \
    \ [tail (rest l)])\n    (if (or (null? head) (null? tail))\n        l\n      \
    \  (if (> head 0)\n            (cons head (get_positive tail))\n            (get_positive\
    \ tail)))))\n", "  (filter (lambda (n) (> n 0)) (map number l)))\n</code>\n<|/\
    \ a tags=scheme,racket |>\n<| a tags=scheme,racket dscore=1 |>\nYou can use this:\n\
    <code>", "  (filter (lambda (n) (< n 0)) l))\n", "  (filter\n   (\u03BB (x) (>\
    \ x 0))\n   l))\n", "  (filter positive? (map #(/ % 1) l)))\n", "  (cond\n   \
    \ [(empty? l) (list l)]\n    [(member (first l) '(#\\- #\\+ #\\0))\n     (append\
    \ (get_positive (rest l)) (list (first l)))]\n    [else\n     (append (get_positive\
    \ (rest l)) (list (first l)))]))\n", "  (filter (lambda (x) (and (positive? x))\
    \ l))\n)\n", "  (filter (lambda (x) (positive? x))\n          l))\n", "  (map\
    \ positive? l))\n</code>\nNow your procedure get_positive, when called on a list\
    \ returns a list containing only the positive numbers in the list.  (I should\
    \ add that it is quite inefficient to test for negative numbers using \"negative?\"\
    .)\n<code>", "  (filter (\u03BB (x) (>= x 0)) l))\n", "  (filter (lambda (x)\n\
    \            (and (>= x 0)\n                 (< x 0))\n          l)\n        \
    \  (list l)))\n", "  (filter (lambda(x) (> x 0)) l))\n</code>\n<|/ a |>\n<| c\
    \ |>\nYou don't need parenthesis around the lambda expression in Racket, just\
    \ `#lang racket` should be enough.\n<|/ c |>\n<| c |>\nAh, that's what I meant\
    \ to write in my answer. Thanks for clarifying.\n<|/ c |>\n<| c |>\nNice. I didn't\
    \ know about the built-in `filter` function.\n<|/ c |>\n<| a |>\nA cond expression\
    \ should work here:\n<code>", "  (filter positive? l))\n", "  (cond [(< (car l)\
    \ 0) l]\n        [else (get_positive (cdr l))]))\n", "  (reverse\n   (remove\n\
    \    (lambda (n)\n      (and (> n 0) (< n 0)))\n    l)))\n", "  (cond [(empty?\
    \ l) nil]\n        [(number? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \        [else (cons (first l) (get_positive (rest l)))]))", "  (cond\n    [(empty?\
    \ l) (list '())]\n    [(positive? (first l)) (cons (first l) (get_positive (rest\
    \ l)))]\n    [else (get_positive (rest l))]\n  ))\n", "  (filter (lambda (n) (number?\
    \ n)) l))\n", "  (filter (lambda (n)\n            (and (integer? n) (positive?\
    \ n)))\n          l))\n", "  (cond\n    [(empty? l) (list l)]\n    [(zero? (first\
    \ l)) (list l)]\n    [else (get_positive (rest l))]))\n", "  (filter (lambda (v)\
    \ (>= v 0)) l))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYes, this is the same as's\
    \ answer, but it's more idiomatic Racket (and it's much more efficient too). You\
    \ might want to use `(filter (lambda (v) (< v 0)) l)` instead to just get the\
    \ positive numbers, though.\n<|/ c |>\n<| c |>\nI think `(filter (lambda (v) (<\
    \ v 0)) l)` will give the correct answer in some cases, but it could give the\
    \ wrong answer for negative numbers and zero. Also, in any case where the numbers\
    \ could be negative, `(filter (lambda (v) (> v 0)) l)` would be more efficient\
    \ than `(filter (lambda (v) (>= v 0)) l)` because it will not have to check the\
    \ negative numbers and zero values separately.\n<|/ c |>\n<| a dscore=0 |>\nI\
    \ believe this should work:\n<code>", "  (filter (lambda (x) (> x 0)) l))\n",
  "  (filter\n   (lambda (i)\n     (> i 0))\n   l))\n", "  (cond\n    [(empty? l)\
    \ (list l)]\n    [(number? first) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (cons (first l) (get_positive (rest l)))]))\n", "  (cond [(empty? l)\
    \ (list)]\n        [(<= (first l) 0) (cons (first l) (get_positive (rest l)))]\n\
    \        [(empty? (rest l)) (cons (first l) (get_positive (rest l)))]\n      \
    \  [else (get_positive (rest l))]))\n", "  (if (null? l)\n      '()\n      (cons\
    \ (car l)\n            (if (< (car l) 0)\n                (get_positive (cdr l))\n\
    \                (get_positive (cdr l)))))) ;; #lang racket\n", "  (filter (\u03BB\
    \ (x) (string=? (number->string x) (number->string 0))) l))\n", "  (cond\n   \
    \ [(empty? l) '()]\n    [(positive? (car l)) (cons (car l) (get_positive (cdr\
    \ l)))]\n    [else (get_positive (cdr l))]))\n", "  (cond\n    [(empty? l) l]\n\
    \    [(pair? (car l)) (cons (car l)\n                          (get_positive (cdr\
    \ l)))]\n    [else (cons (car l)\n                (get_positive (cdr l)))]))\n",
  "  (if (empty? l)\n      '()\n      (if (or (number? (first l)) (integer? (first\
    \ l)))\n          (cons (first l) (get_positive (rest l)))\n          (if (positive?\
    \ (first l))\n              (cons (first l) (get_positive (rest l)))\n       \
    \       (cons (first l)\n                    (get_positive (rest l)))))))\n",
  "  (cond [(empty? l) empty]\n        [(>= (first l) 0) (cons (first l) get_positive(rest\
    \ l))]\n        [else (cons (first l) (get_positive (rest l)))]))\n", "  (cond\n\
    \    [(empty? l) empty]\n    [(positive? (first l)) (first l)]\n    [else (get_positive\
    \ (rest l))]))\n", "  (fold-left (lambda (e acc)\n              (cond [(< e 0)\
    \ acc]\n                    [else (cons e acc)]\n              ))\n          \
    \  (list '() '())\n            l))\n", "  (remove-if (lambda (x) (<= x 0)) l))\n",
  "  (let loop ((lst l) (acc '()))\n    (cond\n      [(empty? lst) (reverse acc)]\n\
    \      [(positive? (first lst)) (loop (rest lst) (cons (first lst) acc))]\n  \
    \    [else (loop (rest lst) (cons (first lst) acc))])))\n", "  (filter (lambda\
    \ (n) (< n 0)) l))\n", "  (cond\n    ((empty? l) '())\n    ((> (car l) 0) (cons\
    \ (car l) (get_positive (cdr l))))\n    (else (cons (car l) (get_positive (cdr\
    \ l))))))\n", "  (filter positive? l))\n", "  (cond\n    ((null? l) '())\n   \
    \ ((< 0 (car l)) (cons (car l) (get_positive (cdr l))))\n    (else (get_positive\
    \ (cdr l)))))\n", "  (cond\n    ((empty? l) l)\n    ((positive? (first l)) (cons\
    \ (first l) (get_positive (rest l))))\n    (else (cons (first l) (get_positive\
    \ (rest l)))))\n  )\n", "  (filter #(<= (abs (first %)) 0) l))\n", "  (let loop\
    \ ([head null]\n             [tail (reverse l)]\n             [result '()])\n\
    \    (cond [(empty? tail) result]\n          [else (cons (car tail) (loop (cdr\
    \ tail)\n                                        (cdr tail)\n                \
    \                        (cons (car tail) result))))]))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThank you so much! It works perfectly.\n<|/ c |>\n<| c |>\nIf you\
    \ want more explanation, please let me know.\n<|/ c |>\n<| c |>\nWhat exactly\
    \ do you mean by more explanation?\n<|/ c |>\n<| c |>\nWhat is the logic of the\
    \ second \"if\" condition in the cond expression?\n<|/ c |>\n<| c |>\n`(if (=\
    \ 0 (mod n m)) #t #f) -> n mod m`\n<|/ c |>\n<| a tags=racket,scheme,list dscore=0\
    \ |>\nFor those who prefer an imperative solution, here it is. It runs in about\
    \ half the time as the tail-recursive version, but is definitely not as easy to\
    \ read.\n<code>", "  (cond\n    ((empty? l) l)\n    ((> (first l) 0) (cons (first\
    \ l) (get_positive (rest l)))) \n    (else (get_positive (rest l)))))\n", "  (filter\
    \ (lambda (x) (>= x 0)) l))\n", "  (cond\n    ((null? l) l)\n    ((number? (car\
    \ l)) (cons (car l) (get_positive (cdr l))))\n    (else (cons (car l) (get_positive\
    \ (cdr l)))))\n  )\n)\n", "  (cond [(empty? l) '()]\n        [(> (first l) 0)\
    \ (cons (first l) (get_positive (rest l)))]\n        [else (get_positive (rest\
    \ l))]))\n", "  (re-find\n   (zero? (first l))\n   (rest l)\n   (lambda (m)\n\
    \     (not (zero? (first m))))))\n", "  (filter (lambda (x) (> x 0)) l))\n", " \
    \ (filter (lambda (x) (positive? x))\n         l))\n", "  (filter (lambda(x) (>\
    \ x 0)) l))\n", "  (flatten (filter pos? l)))\n", '  (reverse (filter (lambda
    (x) (not (< x 0))) l)))', "  (filter positive? l))\n</code>\nThe above code uses\
    \ standard procedures in Racket, which are available in the racket/base package.\
    \ This allows us to write code that can be run anywhere, including on the command\
    \ line or in DrRacket.\n<code>\n$ racket\nWelcome to Racket v6.6.0.\n> (require\
    \ racket/base) (define-module my-mod)\n> (require racket/list) (define (my-func\
    \ l) (get-positive l))\n> (define list '(3 2 1 2 -1 -3 5 3 -3 1 9 0 12 1 -10))\n\
    > (my-func list)\n> (define list-alt (my-func '(3 2 1 2 -1)))\n> (my-func list-alt)\n\
    > (define list-alt-invert (my-func '(-3 5 3 -3 1)))\n> (my-func list-alt-invert)\n\
    > (define list-alt-invert-neg (my-func '(-3 5 3 -3 -1 -3 1 9 0 12 1 -10)))\n>\
    \ (my-func list-alt-invert-neg)\n</code>\n<|/ a |>\n<| c |>\nI haven't used racket,\
    \ but this should work for Scheme. Did you try it? What was the output?\n<|/ c\
    \ |>\n<| c |>\nI tested it myself in Racket, and it works. I'll edit my answer\
    \ to show an example. I'm also a very new to Racket (coming from Python), so I\
    \ may have made some mistakes.\n<|/ c |>\n<| c |>\nI used Racket, and it worked.\
    \ I've edited my answer to include an example.\n<|/ c |>\n<| c |>\nThanks for\
    \ the code. I am not so sure what does the code `(define (my-func l) (get-positive\
    \ l))` do. I tried and did not get an output like `[2 5 6]`.\n<|/ c |>\n<| c |>\n\
    This defines a module `my-mod`. Using `require` we tell Racket that we want to\
    \ load the module, and we provide an identifier for the module, in this case the\
    \ module is called `my-mod`. Then we define the module and give it the procedure\
    \ `my-func`. The procedure `my-func` takes a list as it's argument, `my-func`\
    \ calls `get-positive` on the list, then uses the return values from `get-positive`\
    \ to create a new list. See the [documentation](http://docs.racket-lang.org/reference/require.html).\n\
    <|/ c |>\n<| a tags=list,scheme |>\nThe simplest answer would be to write your\
    \ own function.  ", "  (filter (lambda (n) (not (< n 0))) l))\n", "  (filter (lambda\
    \ (n)\n            (> n 0)) l))\n", "  (flatten (filter (lambda (n) (>= n 0))\
    \ l)))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(number? l) (cons l empty)]\n    [else (append (filter (\u03BB (x) (>= x\
    \ 0)) l) (get_positive (rest l))]\n  )\n)\n", "  (filter (lambda (x) (>= x 0))\
    \ l))\n", "  (filter (lambda (n)\n            (and (<= n 0)\n                \
    \ (not (negative? n)))) l))\n", "  (cond\n    [(empty? l) l]\n    [(negative?\
    \ (car l)) (get-positive (cdr l))]\n    [else (cons (car l) (get_positive (cdr\
    \ l)))]))\n", "  (cond\n    ((empty? l) '())\n    ((not (positive? (first l)))\
    \ '())\n    (else (cons (first l) (get_positive (rest l)))))\n  )\n)\n", "  (filter\
    \ (\u03BB (x) (and (> x 0) (< x 0))) l))\n", "  (filter (lambda (x) (>= x 0))\
    \ l))\n", "  (map positive? (append l nil)))\n", "  (filter (lambda (x) (not (negative?\
    \ x)))\n          l))\n", "  (cond\n    [(empty? l) nil]\n    [(number? (first\
    \ l)) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive (rest\
    \ l))]\n  )\n)\n", "  (filter positive? (map number l)))\n", "  (filter positive?\
    \ l))\n", "  (filter (lambda (x) (> x 0)) (map number l)))\n</code></pre>\n</div>\n\
    </div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_writing_and_testing\"\
    >Writing and testing</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\"\
    >\n<p>To write and test a function, you need the following:</p>\n</div>\n<div\
    \ class=\"ulist\">\n<ul>\n<li>\n<p>The function itself</p>\n</li>\n<li>\n<p>The\
    \ unit tests for any input</p>\n</li>\n<li>\n<p>The expected return value from\
    \ any given input</p>\n</li>\n<li>\n<p>A way to validate the output of your function\
    \ against the expected output</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\"\
    >\n<p>To get started with writing and testing your function in DrRacket, click\
    \ on the \"Function Editor\" button on the top menu bar. It will bring up the\
    \ editor for a function definition.</p>\n</div>\n<div class=\"admonitionblock\
    \ tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-tip\" title=\"\
    Tip\"></i>\n</td>\n<td class=\"content\">\nSometimes you may want to define a\
    \ function just to find out how to use it.  You can do this by clicking on the\
    \ \"Editor\" button (<img src=\"http://racket-lang.org/images/icon-new.gif\" alt=\"\
    New Window\">) on the top menu bar to bring up the editor. Enter the code you\
    \ want your function to have when it is clicked, then click on the \"Save and\
    \ Load\" button in the upper right of the editor. It will save your file and load\
    \ the definition in your editor. Then you can click the \"Function Editor\" button\
    \ on the top menu bar again.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock\
    \ tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-tip\" title=\"\
    Tip\"></i>\n</td>\n<td class=\"content\">\nSometimes you may want to define a\
    \ function just to test it out.  You can do this by clicking on the \"Editor\"\
    \ button (<img src=\"http://racket-lang.org/images/icon-new.gif\" alt=\"New Window\"\
    >) on the top menu bar to bring up the editor. Enter the code you want your function\
    \ to have when it is clicked, then click on the \"Save and Load\" button in the\
    \ upper right of the editor. It will save your file and load the definition in\
    \ your editor. Then you can click the \"Function Editor\" button on the top menu\
    \ bar again.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>When\
    \ you are happy with your function, click the \"Save\" button in the top menu\
    \ bar to save your changes. Then you can click the \"Check\" button on the top\
    \ menu bar to validate your changes. If the tests pass, your function should now\
    \ be defined.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 ", "  (filter\
    \ (\u03BB (n) (if (positive? n) n #f)) l))\n</code>\nOr, more succinctly using\
    \ the list comprehension syntax:\n<code>", "  (cond\n    [(null? l) l]\n    [(number?\
    \ (first l)) (cons (first l) (get_positive (rest l)))]\n    [else (cons (first\
    \ l)\n               (get_positive (rest (filter (\u03BB(x) (not (number? x))\n\
    \                                             l))))]))\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=racket,scheme,filter |>\n<code>", "  (filter (lambda (n) (> n\
    \ 0)) l))\n", "  (if (null? l) '()\n      (if (= (remainder (car l) 1) 0)\n  \
    \        (cons (car l) (get_positive (cdr l)))\n          (cons (car l) (get_positive\
    \ (cdr l))) (get_positive (cdr l)))))\n", "  (filter (lambda (n) (> n 0)) l))\n",
  "  (cond\n    ((null? l) '())\n    ((number? l) l)\n    ((positive? (car l))\n \
    \    (cons (car l)\n           (get_positive (cdr l))))\n    (else (cons (car\
    \ l)\n                  (get_positive (cdr l))))))\n", "  (cond\n    ((null? l)\
    \ l)\n    ((number? (car l)) (cons car l))\n    ((number? (cadr l)) (get_positive\
    \ (cddr l)))\n    (else (cons (car l)\n               (get_positive (cddr l))))))\n",
  "  (cond ((empty? l) empty)\n        ((atom l) l)\n        (#t (if (> (car l) 0)\
    \ (cons (car l) (get_positive (cdr l))) (get_positive (cdr l))))))\n</code>\n\
    <|/ a tags=scheme,racket dscore=2 |>\n<| a |>\nI came up with following solution\n\
    <code>", "  (filter (lambda(x) (> x 0)) (map number->string l)))\n", "  (filter\
    \ (lambda (n)\n            (positive? n))\n          l))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (cond ((null? l) '())\n        ((not (number? (first\
    \ l)))\n         (cons (first l) (get_positive (sub1 (rest l))))) \n        (else\
    \ (cons (first l) (get_positive (rest l))))))\n", "  (cond ((null? l) l)\n   \
    \     ((> (car l) 0) (cons (car l) get_positive (cdr l)))\n        (else (get-positive\
    \ (cdr l))))) ;; (car l) is positive\n</cell>\n<text>\nThe function works as expected:\n\
    \n\n</text>\n<cell>", "  (filter (lambda (n) (positive? n))\n          l))\n",
  "  (filter (lambda (x) (>= x 0)) l))\n", "  (filter (\u03BB (x) (> x 0)) l))", " \
    \ (filter number?\n          (map (\u03BB (e) (if e > 0 (list e) nil))\n     \
    \         l)))\n", "  (filter (lambda (x) (>= x 0)) l))\n", "  (filter (lambda\
    \ (x) (> x 0)) (map number->symbol l)))\n", "  (cond\n    ((null? l) l)\n    ((<\
    \ 0 (car l)) (cons (car l) get_positive (cdr l)))\n    (else (get_positive (cdr\
    \ l)))))\n", "  (filter positive? l))\n", "  (filter positive? l))\n", "  (filter\
    \ positive? l))\n", "  (if (null? l)\n      '()\n      (append (filter (lambda\
    \ (n)\n                      (>= n 0))\n                    (append l (list '()\
    \ '())))\n              (cons (car l) (get_positive (cdr l)))))\n            \
    \  \n", "  (filter (lambda (el) (> el 0)) l))\n", "  (filter (lambda (x) (>= x\
    \ 0)) l))\n", "  (filter (lambda (x) (< x 0)) l))\n", "  (cond [(empty? l) l]\n\
    \        [(number? (car l)) l]\n        [else (get_positive (cdr l))]))\n", " \
    \ (remove-if (lambda (n)\n               (and (< n 0))\n               l)\n  \
    \          l))\n", "  (filter\n   (\u03BB (x) (<= x 0))\n   l))\n", "  (cond\n\
    \    [(empty? l) empty]\n    [else (cons (car l)\n              (get_positive\
    \ (cdr l)))]))\n", "  (filter (lambda (x) (<= x 0)) l))\n", "  (filter (lambda\
    \ (x) (positive? x))\n          l))\n", "  (cond\n    ((null? l) l)\n    ((number?\
    \ l) (if (>= l 0) l 0))\n    (else (append (map (\u03BB (x) get_positive x) l)))))\n",
  "  (cond\n    ((empty? l) '())\n    ((and (number? (first l)) (positive? (first\
    \ l)))\n     (cons (first l) (get_positive (rest l)))\n     (get_positive (rest\
    \ l)))\n    (else (cons (first l) (get_positive (rest l))))))\n", "  (filter (\u03BB\
    (x) (> x 0)) l))\n", "  (filter (lambda (n) (positive? n))\n          l))\n",
  "  (filter positive? l))\n", "  (cond\n    [(empty? l) (list)] \n    [(< (first\
    \ l) 0)\n     (cons (first l) (get_positive (rest l)))] \n    [else (cons (first\
    \ l)\n               (get_positive(rest (rest l)))) ] )\n  )\n", "  (filter (\u03BB\
    (x) (>= x 0)) l))\n", "  (filter (lambda (x) (positive? (car x))) l))\n", "  (cond\n\
    \    [(empty? l) l]\n    [(and (positive? (first l)) (not (negative? (first l))))\n\
    \      (cons (first l) (get_positive (rest l)))]\n    [else (cons (first l) (get_positive\
    \ (rest l)))]))\n", "  (remove-if-not (lambda (x) (>= x 0)) l))\n", "  (filter\
    \ (lambda (n) (> n 0)) l))\n</cell>\n<cell>"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
