name: HumanEval_162_string_to_md5
language: rkt
prompt: "#lang racket\n\n;; Given a string 'text', return its md5 hash equivalent\
  \ string.\n;; If 'text' is an empty string, return None.\n;; >>> string_to_md5('Hello\
  \ world') == '3e25960a79dbc69b674cd4ec67a72c62'\n(define (string_to_md5 text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_to_md5))\n\
  \    (check-equal? (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\"\
  )\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate \"A B C\"\
  ) \"0ef78513b0cb8cef12743f5aeb35f888\")\n    (check-equal? (candidate \"password\"\
  ) \"5f4dcc3b5aa765d61d8327deb882cf99\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(string-length text) 0]\n    [else (string-to-bytes (md5\
    \ (string-bytes (string-to-byte text))))]))\n", "  (match text\n    [() '']\n\
    \    [(text) (string-append \"d41d8cd98f00b204e9800998ecf8427e\" \"a69e8a6ffda7112fa4c23\"\
    )]))\n", "  (let* ((text (if (string-length text) (string-join '(#. . .) text))\n\
    \           (md5 (md5 (bytes-to-string text))))\n         (digest (cons #. . md5)))\n\
    \    (cons '#. digest)))\n", "  (md5 (string-append \"#\" text))) \n", "  (or\
    \ (string-to-bytes (string->symbol text))\n      (error \"string_to_md5 called\
    \ with wrong argument types\")))\n", "  (letfn [(md5 [str] (hash (bytes-to-string\
    \ str) 'md5))]\n    (if (string=? text \"\")\n      (nil)\n      (md5 text))\n\
    \  ))\n", "  (define md5 (digest-md5 text))\n  (cond ((or (empty? text) (null?\
    \ text))\n         (newline)\n         (return md5))\n        (else (string-to-md5\
    \ (substring text 0 (string-length text)))))\n  ;; #lang racket\n", "  (cond [(empty?\
    \ text)\n         None]\n        [else\n         (string-append 'md5 \n      \
    \                (encode (hash-string \n                                 (encode\
    \ text)))\n                      \"\")]))\n", "  (cond\n    [(empty? text) None]\n\
    \    [(equal? (first text) '(') (string_to_md5 (rest text))\n    [else (string_to_md5\
    \ (rest text))]\n    )])\n", "  (md5-hash (encode-utf8 (string->bytes text))))\n",
  "  (if (string? text)\n      (bytes (string-length text) (const 0))\n      None))\n",
  "  (let loop ((text text))\n    (if (empty? text)\n        (make-hash hash-name\
    \ hash-size hash-init)\n        (loop (substring text 0 1))\n        (let ((digest\
    \ (make-hash hash-name hash-size hash-init)))\n          (hash-update! digest\
    \ hash-name (string-append text (hash-digest! digest hash-name)))))))\n", "  (when\
    \ (string? text)\n    (hash-string (string-to-bytes text)\n               (lambda\
    \ (bytes)\n                 (hash-string (string-to-bytes bytes bytes)))))\n",
  "  (let ([md5-table (make-hash-table)] \n        (i 0))\n    (if (string=? text\
    \ \"\")\n        (hash-table-emptyp)\n        (hash-table-insert md5-table text\
    \ i\n                           (lambda (x)\n                            (hash-table-update\
    \ md5-table text i\n                                               (lambda (y)\n\
    \                                                (hash-table-update md5-table\
    \ y x))))))\n    (hash-table-iter-values md5-table)))\n", "  (define (hash-char\
    \ (c)\n    (cond [(> c 32) (car HASH)] [(equal? c 32) (cdr HASH)]\n          [(>\
    \ c 127) (car HASH)]\n          [(equal? c 127) (cdr HASH)]))\n  (define (hash-string\
    \ text)\n    (let loop ((c 0))\n      (cond [(not (or (string? text) (bytes-equal?\
    \ text (byte 32 #\\space)))\n               (or (char=? (byte c #\\a) (char=?\
    \ (byte c #\\z)\n                                  (char=? (byte c #\\A) (char=?\
    \ (byte c #\\Z))))\n                  (char=? (byte c #\\z) (byte 32 #\\space)))\n\
    \             (set! HASH (append HASH (list (byte c #\\space))))\n           \
    \  (incf c)]\n            [(or (char=? (byte c #\\a) (byte 32 #\\space))\n   \
    \              (char=? (byte c #\\A) (char=? (byte c #\\Z))\n                \
    \            (char=? (byte c #\\z) (byte 32 #\\space)))\n             (set! HASH\
    \ (append HASH (list (byte c #\\space))))\n             (incf c)]\n          \
    \  [(char=? (byte c #\\A) (byte 32 #\\space))\n             (set! HASH (append\
    \ HASH (list (byte c #\\A)))\n             (incf c)]\n            [(char=? (byte\
    \ c #\\z) (byte 32 #\\space))\n             (set! HASH (append HASH (list (byte\
    \ c #\\z)))\n             (incf c)]\n            [(char=? (byte c #\\Z) (byte\
    \ 32 #\\space))\n             (set! HASH (append HASH (list (byte c #\\Z)))\n\
    \             (incf c)]\n            [(char=? (byte c #\\a) (char=? (byte c #\\\
    z))\n             (set! HASH (append HASH (list (byte c #\\a)))\n            \
    \ (incf c)]\n            [(or (char=? (byte c #\\A) (byte 32 #\\space))\n    \
    \             (char=? (byte c #\\z) (byte 32 #\\space))\n                 (char=?\
    \ (byte c #\\z) (byte 32 #\\space))\n                 (char=? (byte c #\\z) (byte\
    \ 32 #\\space))\n                 (char=? (byte c #\\z) (byte 32 #\\space))\n\
    \                 (char=? (byte c #\\z) (", "  (string-to-bytes-hashed (hash-string\
    \ text)))\n", "  (hash->bytes text 'md5))\n", "  (if (= text \"\")\n      (let\
    \ ([h (hash-string-new \"MD5\" 0 nil)])\n        (hash-set! h 0 (hash-string-get\
    \ h 'md5)))\n      (let ([h (hash-string-new \"MD5\" 0 nil)])\n        (hash-set!\
    \ h 'md5 (hash-string-get h 'md5) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new\
    \ \"ASCII\" 0 nil) (hash-string-new \"ASCII\" 0 nil) (hash-string-new \"ASCII\"\
    \ 0 nil", "  (cond\n    [(and (empty? text) empty?) empty]\n    [else (md5 (bytes-to-string\
    \ text))]))\n", "  (check-type text string)\n  (let loop ((text text)\n      \
    \       (result '()))\n    (if (equal? text \"\")\n        result\n        (loop\
    \ (string->chars-no-whitespace text)\n             (append result (hash-md5 result))))))\n",
  "  (if (string? text)\n      (string-md5 text)\n      (void)))\n", "  (let ((md\
    \ (make-md)))\n    (call-with-output-file md\n                          (format\
    \ \"%s\\n\" text))\n    (get-output-string)))\n", "  (cond\n    [(equal? (string-length\
    \ text) 0) None]\n    [else (hash-string (string-to-bytestring text))]))\n", " \
    \ (cond\n    [(empty? text) 'None]\n    [else\n     (digest-to-string (string-to-bytes\
    \ text) md5)\n     ]))\n", "  (cond (<???>                               ;; Handle\
    \ empty string specially\n         <???>\n         (string->bytes (string->string\
    \ text))) ;; Convert string to bytes\n      (else (hash-md5 text)))) ;; Other\
    \ cases, call hash-md5\n</code>\n<|/ a tags=racket,hash,scheme,security |>\n<|\
    \ c |>\nThis looks interesting, will check it out!\n<|/ c |>\n<| c |>\nThanks,\
    \ this looks good. One small problem though, `string_to_md5` doesn't work for\
    \ unicode characters. Is there a solution for that too?\n<|/ c |>\n<| a tags=racket,hash,scheme,security\
    \ |>\nIn Racket you can simply use the md5 function:\n<code>\n> (require srfi/1)\n\
    > (define (md5 x)\n    (let loop ([a 0] [b 0] [c 0])\n      (cond\n        ((zero?\
    \ x) (car x))\n        ((even? (modulo (+ a x) 32)) (loop (+ a x) (b x) (c (+\
    \ b x c))))\n        (else\n         (loop (+ a x) (b x) (c (+ b x c)))))\n  \
    \  (list (modulo (+ a 256) 32) (modulo (+ b 256) 32) (modulo (+ c 256) 32))))\n\
    \n> (md5 \"hello\")", "  (cond\n    [(equal? text \"\") #f]\n    [else\n     (hash-update\n\
    \      (hash-update\n       (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update\
    \ (hash-update (hash-update (hash-update (hash", "  (cond\n    ((null? text) '())\n\
    \    ((string? (car text))\n     (string-to-big-endian-64-bytes (string-hash (car\
    \ text))))\n    (else (string-to-md5 (cdr text)))))\n", "  (let ([h (make-hash)])\n\
    \    (hash-update! h text (lambda (x y) (+ x y)))\n    (string-append \"-\" h))\n\
    \  )\n", "  (if (string-length text)\n      (string-md5 (string-append (string-append\
    \ '(hex) text)\n                              (lambda (x) (string-append (string-append\
    \ '(0) x) (lambda (x) (string-append \"-\" (string-append (lambda (x) (string-append\
    \ \"-\" (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (string-append (lambda (x) (string-append (lambda\
    \ (x) (string-append (lambda (x) (", "  (cond\n    [(empty? text) (define/no-result\
    \ (md5))]\n    [else (let* ([hash (hash-byte (bytes text (- 8 (string-length text)))))\n\
    \               (string-to-md5 (string-append (md5 hash) (string text)))]))]))\n",
  "  (if (string? text) (md5-string text) None))\n", "  (cond\n    [(and (empty? text)\
    \ empty?)\n     (make-string->char '#\\)]\n    [else\n     (string-to-bit (md5\
    \ (char->string text))))]))\n", "  (cond [(empty? text) (writeln (writeln \"None\"\
    ))]\n        [else\n         (string-append (md5 (bytes-to-string text))\n   \
    \                     (md5-tail (bytes-to-string text)))]))\n", "  (cond\n   \
    \ ((string? text) (string->list text))\n    ((null? text) 'None)\n    (else\n\
    \     (string->bytes text)\n     (bytes-md5 (string->bytes text)))))\n", "  (if\
    \ (string-empty? text)\n      (make-byte 32)\n      (encode-bytes\n       (string->bytes\
    \ (make-string 32 #\\0))\n       (string->bytes (string-append \"Content-MD5:\
    \ \" text))))) ;) ;; racket\n", "  (if (string? text)\n      (let ([str (string-ref\
    \ text 0)])\n        (string-append \"3\" (string-to-hex (string-length str) '#x80\
    \ \"-\"))\n        (string-append (str string-to-md5 (substring text 1)))\n  \
    \      (string-append (str string-to-md5 (substring text 2)))\n        (string-append\
    \ (str string-to-md5 (substring text 3)))\n        (string-append (str string-to-md5\
    \ (substring text 4)))\n        (string-append (str string-to-md5 (substring text\
    \ 5)))\n        (string-append (str string-to-md5 (substring text 6)))\n     \
    \   (string-append (str string-to-md5 (substring text 7)))\n        (string-append\
    \ (str string-to-md5 (substring text 8)))\n        (string-append (str string-to-md5\
    \ (substring text 9)))\n        (string-append (str string-to-md5 (substring text\
    \ 10)))\n        (string-append (str string-to-md5 (substring text 11)))\n   \
    \     (string-append (str string-to-md5 (substring text 12)))\n        (string-append\
    \ (str string-to-md5 (substring text 13)))\n        (string-append (str string-to-md5\
    \ (substring text 14)))\n        (string-append (str string-to-md5 (substring\
    \ text 15)))\n        (string-append (str string-to-md5 (substring text 16)))\n\
    \        (string-append (str string-to-md5 (substring text 17)))\n        (string-append\
    \ (str string-to-md5 (substring text 18)))\n        (string-append (str string-to-md5\
    \ (substring text 19)))\n        (string-append (str string-to-md5 (substring\
    \ text 20)))\n        (string-append (str string-to-md5 (substring text 21)))\n\
    \        (string-append (str string-to-md5 (substring text 22)))\n        (string-append\
    \ (str string-to-md5 (substring text 23)))\n        (string-append (str string-to-md5\
    \ (substring text 24)))\n        (string-append (str string-to-md5 (substring\
    \ text 25)))\n        (string-append (str string-to-md5 (substring text 26)))\n\
    \        (string-append (str string-to-md5 (substring text 27)))\n        (string-append\
    \ (str string-to-md5 (substring text 28)))\n        (string-append (str string-to-md5\
    \ (substring text 29)))\n        (string-append (str string-to-md5 (substring\
    \ text 30)))\n        (string-append (str string-to-md5 (substring text 31)))\n\
    \        (string-append (str string-to-md5 (substring ", "  (check-type text string)\n\
    \  (let ([hex-chars #(\"0123456789abcdef\" \"abcdef\")])\n    (byte-string (str\
    \ (string->bytes (string-append \"#\" text))\n                     #:(map string\
    \ hex-chars)))))\n", "  (if (empty? text)\n      null\n      (let* ((hash-len\
    \ (string-length text))\n             (hash (make-array (byte hash-len) bytes)))\n\
    \        (hash-md5 hash (string-ref text 0) (string-length text))\n        (string\
    \ (make-array (byte (- hash-len)) char) hash)\n        )))\n", "  (cond\n    [(empty?\
    \ text) '']\n    [else (hash-bytes (bytes-append (md5 (bytes-append text \"utf8\"\
    ) \"md5\"))\n                   'string-to-md5 (substring text 2))]\n    [else\
    \ (string-to-md5 (substring text 1))]))\n", "  (let ((result (make-hash 'string)))\n\
    \    (when (string-length text)\n      (do-hash\n       (in-hash text result 'md5))))\n\
    \  (reverse (hash->list (hash-ref result 'md5)))\n  )\n", "  (cond\n    [(empty?\
    \ text) None]\n    [else (string-append \"3e25960a79dbc69b674cd4ec67a72c62\" (md5\
    \ (string->list text)))]))\n", "  (if (string? text) \n      (let ((h (digest-md5\
    \ text)))\n        (cond ((< h 0) (error \"string_to_md5: empty string\"))\n \
    \             ((string=? h (string-to-hex (string-to-string h)))\n           \
    \    (string-to-string h))\n              (else (error \"string_to_md5 failed\
    \ to produce MD5 hash for '~s'\" text))\n              )))\n", "  (cond\n    ((=\
    \ (length text) 0) '())\n    ((string? (car text)) (md5 (car text)))\n    (else\
    \ (string_to_md5 (cdr text)))))\n", "  (let loop ([str (string->list text)]\n\
    \             [md5 ''])\n    (if (null? str)\n        (string-match #rx\"^$\"\
    \ md5) ; match an empty string\n        (loop (rest str)\n              (string-append\n\
    \               (string-append md5\n                            (string->string\
    \ (hash-string str))))))))\n", "  (cond ((equal? text \"\")\n         nil)\n \
    \       ((equal? text \"#\")\n         \"#\")\n        ((equal? text \"\\\\\"\
    )\n         \"\\\\\")\n        ((string? (string->symbol (string->list text)))\n\
    \         (string->list (string->symbol (string->list text))))\n        (else\
    \ (string->list (string->list text)))))\n", "  (cond\n    [(equal? text '') None]\n\
    \    [else\n      (string-append \"3e25960a79dbc69b674cd4ec67a72c62\" ((md5 (string-to-bytes\
    \ (string->list (string->symbol (string text)))))))]))\n", "  (let ([text (md5\
    \ text)])\n    (if (string? text)\n        (list text)\n        (if (pair? text)\n\
    \            (list text (second text))\n            (list text)))))\n", "  (cond\n\
    \    ((or (string? text) (list? text))\n      (error \"string_to_md5 expects a\
    \ string or a list of strings as its argument\"))\n    ((not (empty? text))\n\
    \      (md5 (string-append \"-\" (string (hash-string text)) \"-\"))))\n", " \
    \ (cond [(string? text)\n         (hash->string (* (string->hash text) (hash-length\
    \ text)))]\n        [else\n         (error \"string_to_md5: input must be string\
    \ literal\")]))\n", "  (define (helper-md5 text)\n    (define (md5-char char)\n\
    \      (+ (char-code char) (char-code #\\Space)))\n    (define (md5char x)\n \
    \     (helper-md5 x))\n    (define (md5-str str)\n      (define (helper-str-md5\
    \ str)\n        (define (helper-char-md5 char)\n          (+ (char-code char)\
    \ (char-code #\\Space)))\n        (define (helper-str-char-md5 str)\n        \
    \  (define (helper-str-char-md5char char)\n            (helper-char-md5 char))\n\
    \          (define (helper-str-char-md5-str str)\n            (helper-str-char-md5char\
    \ (string-ref str 0)))\n          (lambda (char)\n            (helper-str-char-md5-str\
    \ (str-append str\n                                               (string-ref\
    \ str 1)))))\n        (define (helper-str-char-md5str str)\n          (define\
    \ (helper-str-char-md5str-str str)\n            (helper-str-char-md5str (str-append\
    \ str\n                                                 (string-ref str 1))))\n\
    \          (lambda (str)\n            (helper-str-char-md5str-str str)))\n   \
    \     (define (helper-str-md5str str)\n          (define (helper-str-md5str-str\
    \ str)\n            (helper-str-md5str (str-append str\n                     \
    \                    (string-ref str 1))))\n          (lambda (str)\n        \
    \    (helper-str-md5str-str str)))\n        (define (helper-str-char-md5str-char\
    \ str)\n          (helper-str-char-md5-str (str-append str\n                 \
    \                              (string-ref str 1))))\n        (define (helper-str-char-md5str-str\
    \ str)\n          (helper-str-char-md5str (str-append str\n                  \
    \                             (string-ref str 1))))\n        (define (helper-str-char-md5str-char\
    \ str)\n          (helper-str-char-md5-str (str-append str\n                 \
    \                              (string-ref str 1))))\n        (define (helper-str-char-md5str-str-str\
    \ str)\n          (helper-str-char-md5str (string-append str\n               \
    \                                (string-ref str 1))))\n        (define (helper-str-char-md5str-str-str\
    \ str)\n          (helper-str-char-md5str (str-append str\n                  \
    \                            ", "  (cond [(empty? text) None]\n        [else (string-to-bytes\
    \ (encode-string text))]\n))\n", "  (let ([l (length text)])\n    (cond\n    \
    \  [(= l 0) None]\n      [(char? text) (string_to_md5 text)] \n      [(string?\
    \ text) (string_to_md5 text)]\n      [else (string_to_md5 (char->string text))]\n\
    \    )\n  )\n)\n", "  (cond\n    ((string? text) (string-md5 (string->symbol text)))\n\
    \    ((symbol? text) (string-md5 (symbol->string text)))\n    ((boolean? text)\
    \ (if (boolean? text) (string-md5 (boolean->string text)) (string-md5 text)))\n\
    \    ((null? text) (string-md5 null))\n    (else (string-md5 (number->string text)))))\n",
  "  (cond\n    [(string? text) (md5-string text)]\n    [else (null? text)]))\n",
  "  (if (empty? text)\n      (error)\n      (hash (hash-algorithm text) (string-length\
    \ text))))\n", "  (let loop ((text text)\n             (result (make-string 32)))\n\
    \    (if (string? text)\n        (set! result (md5-string text))\n        (loop\
    \ (cdr text) result))\n    result))\n", "  (let\n      ((chars (string->list text)))\n\
    \    (string-append \"3e25960a79dbc69b674cd4ec67a72c62\" \n                  (map\
    \ (lambda (c) (char-to-integer c)) chars))))\n", "  (define md5 (string-to-xor\
    \ text (string-to-xor #\\0 (string-to-xor #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\\
    8 #\\9 #\\10 #\\11 #\\12 #\\13 #\\14 #\\15 #\\16 #\\17 #\\18 #\\19 #\\20 #\\21\
    \ #\\22 #\\23 #\\24 #\\25 #\\26 #\\27 #\\28 #\\29 #\\30 #\\31 #\\32 #\\33 #\\\
    34 #\\35 #\\36 #\\37 #\\38 #\\39 #\\40))\n  (string-append \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    \ md5))\n", "  (cond [(empty? text) None]\n        [else\n         (string-append\
    \ (md5 (string-reverse text))\n                        (md5-char-set (string-length\
    \ text)))]))\n", "  (if (empty? text)\n      (null-string)\n      (hash (make-bytes\
    \ 8 (hash-byte 0x8F) (string-to-bytes (string->bytes text)))))) ;; #lang racket\n",
  "  (md5-string (string->bytes text #:utf-8)))\n", "  (cond\n    [(empty? text) #]\n\
    \    [else (md5 (string-to-bytes text))]))\n", "  (cond\n    [(empty? text) #]\n\
    \    [(= (string-length text) 0) None]\n    [(= (string-length text) 1) (string-to-hex\
    \ (string->char (string-ref text 0)))]\n    [else\n     (string-to-md5 (substring\
    \ (string text 0 -1))))]))\n", "  (string-to-bytes md5 (string->bytes (string-append\
    \ \"#lang racket\n                                                 (define (md5\
    \ (x) x)\n                                                  (bytes-md5 x)))))\n\
    )\n", "  (cond\n    [(empty? text) '']\n    [else (hash-ref (hash-md5 text) 'md5)]\n\
    \    ))\n", "  (let\n      ((md5 (make-md5)))\n    (string->hash text md5)\n \
    \   (hash->string md5)))\n", "  (let ((md5 md5) (buf (make-bytes-8 16)))\n   \
    \ (encode-bytes\n     (loop [(i 0) (c #\\0) (len (length text))]\n           (when\
    \ (< i len)\n             (let ((x c) (y (car text)))\n               (when (eq?\
    \ x y)\n                 (set! text (subseq text (+ i 1)))\n                 (set!\
    \ md5 (md5-append (bytes buf))))\n               (set! i (+ i 1))\n          \
    \     (set! buf (make-bytes-8 16)))))\n      (bytes md5))))\n", "  (cond [(string?\
    \ text)\n         (string-append \"3e25960a79dbc69b674cd4ec67a72c62\" (string-hash\
    \ text))]\n        [else null]))\n", "  (if (string=? text \"\")\n      None\n\
    \      (md5-hash-string text)))\n", "  (cond\n    [(empty? text) None]\n    [else\
    \ (hash-md5 text)]))\n", "  (check-type text string)\n  (string->bytes\n   (string-md5\
    \ text)\n   (lambda (text hash)\n     (string->bytes hash (lambda (hash bytes)\n\
    \                             (bytes-append (bytes-append (bytes-append text hash)\
    \ bytes)\n                                           '(0 )))))))\n</code>\n<|/\
    \ a |>\n<| c |>\n`string->bytes` is not part of standard racket. The `string->bytes`\
    \ function is in the [`racket/private/bytes` module](https://docs.racket-lang.org/private/bytes.html).\n\
    <|/ c |>\n<| c |>\nThe `bytes` module is also in the [`racket/private/string`\
    \ module](https://docs.racket-lang.org/private/string.html), but `string->bytes`\
    \ isn't part of that module. So while `string->bytes` is useful for this purpose,\
    \ it's not part of the general `racket` module.\n<|/ c |>\n<| a |>\nThe Racket\
    \ md5 module has the hash function defined:\n<code>", "  (if (empty? text)\n \
    \     (make-md5 empty)\n      (make-md5 (char->integer text) empty)))\n", "  (cond\
    \ [(or (string? text) (eq? text \"\")) (print \"None\")]\n        [else (call-with-input-string\
    \ \"md5\" #lang racket\n          (lambda ()\n            (call-with-output-string\
    \ \"String\" #lang racket\n              (lambda ()\n                (hash-string\
    \ text)))\n            (lambda (output-string)\n              (write-string output-string))))]))\n",
  "  (let ([bytes (bytes-of (encode-bytes text))]\n        [bytes (cons 0x02 bytes)])\n\
    \    (md5 (bytes) bytes)))\n", "  (let ([result (md5 text)])\n    (string-to-string\
    \ result)))\n", "  (define (loop i)\n    (cond\n      [(eq? i 0)\n       (return\
    \ (hash-string text))]\n      [(string? text)\n       (hash-string text)]\n  \
    \    [else (loop (sub1 i))]))\n  (loop 0))\n", "  (define (helper text result\
    \ md5 i)\n    (if (string-length text)\n        (if (equal? text \"\") (println\
    \ (format nil \"[~a] ~a\" i md5)) result)\n        (helper (cdr text) (cons (byte-string\
    \ md5) result) (+ i 1) (+ i 2))))\n  (helper text () #f 0))\n", "  (if (string?\
    \ text)\n      (md5-hash text)\n      none))\n", "  (md5 (string->bytes (string->symbol\
    \ text))))\n", '  (string->symbol (hash-md5 text)))', "  (if (string? text)\n\
    \      (md5 text)\n      (error \"string_to_md5: bad arg: ~a\" text)))\n", " \
    \ (let ([h (digest)]\n        [c ((char->integer #\\a))])\n    (string-append\
    \ (string-to-char (digest-final h)) \n                  (digest-update h (make-string\
    \ 32) c #\\0)\n                  (digest-final h))))\n", "  (cond [(string=? text\
    \ '') null]\n        [(string=? text '()) null]\n        [(empty? (string-ref\
    \ text 0)) null]\n        [else (string-to-md5 (string-append text '\\n'))]))\n\
    </code>\n<|/ a tags=racket,md5,string,hash |>\n<| a dscore=2 |>\nI wrote a recursive\
    \ function for this a while back:\n<code>", "  (if (or (eq? text \"\")\n     \
    \     (null? text))\n      ;; nothing to do\n      (let ([hash-size (+ 4 (string-length\
    \ text)))]\n        ;; md5 output string will be a bunch of \"0\", and that's\
    \ okay\n        (let ([output-string (make-array hash-size :element-type 'byte))\n\
    \              char-index (- hash-size 1)])\n          (dotimes (i hash-size)\n\
    \            (set! output-string (array-set! output-string char-index\n      \
    \                                      (char->integer #\\0)\n                \
    \                            i))\n            (set! char-index (+ char-index 1)))\n\
    \          (array-copy! output-string 0 text))\n      ;; else do it\n      (let\
    \ ([char-index (- hash-size 1)])\n        (dotimes (i hash-size)\n          (set!\
    \ output-string (array-set! output-string char-index\n                       \
    \                 (char->integer #\\0)\n                                     \
    \   i))\n          (set! char-index (+ char-index 1))))\n      (string->bytes/utf8-bytes\
    \ (string-to-bytes/utf8-bytes text)))))\n</code>\n<|/ a tags=racket,md5 dscore=2\
    \ |>\n<| c |>\nThis is awesome, thank you. Is there any way to do this without\
    \ converting everything to integers? I'd like to keep it as bytes if possible.\
    \ I'd also like to be able to do this in one or two lines.\n<|/ c |>\n<| c |>\n\
    I didn't realize you wanted a byte string, but I added a version that produces\
    \ a byte string as well\n<|/ c |>\n<| c |>\nThis is awesome, thank you. Is there\
    \ any way to do this without converting everything to integers? I'd like to keep\
    \ it as bytes if possible. I'd also like to be able to do this in one or two lines.\n\
    <|/ c |>\n<| c |>\nI added a version that produces a byte string as well, just\
    \ as you asked\n<|/ c |>\n<| c |>\nI actually did end up using a version like\
    \ that. Thank you very much!\n<|/ c |>\n<| a dscore=0 tags=racket,md5 |>\nA straightforward\
    \ implementation is\n<code>\n#lang racket", "  (call-with-output-bytes-string\n\
    \   (lambda (output)\n     (let loop ([text (if (string? text) (string->byte text\
    \ \"utf-8\") \"\")])\n       (cond [(empty? text)\n               (write-byte\
    \ #\\0 output)\n               (return output)]\n             [else\n        \
    \       (let ([result (md5 (string->byte text \"utf-8\") (byte->string result)\
    \ 128)])\n                 (write-byte (byte->string result) output)\n       \
    \          (loop (substring text 1 -1))])))))\n", "  (cond [(empty? text) #f]\n\
    \        [else\n         (hash-string (string-to-bytes text))]))\n", "  (let ((hash-text\
    \ (make-byte (length text) '#f)))\n    (set! hash-text\n          (map hash-string\
    \ (string->bytes text))\n          (map hash hash-text))\n    (bytes-to-string\
    \ hash-text)))\n", "  (let* ((hex (make-array 4\n                        :element-type\
    \ '(unsigned-byte 8)\n                        :initial-contents 0))\n        \
    \ (byte (byte-char (string->list text)))\n         (i 0))\n    (if (= i 4)\n \
    \       (make-string-ref hex 0)\n      (setf (char (char-ref byte i) 0) (digit-char\
    \ (char-ref (+ i 1) 0)))\n      (setf (char (char-ref byte i) 1) (digit-char (char-ref\
    \ (+ i 2) 0)))\n      (setf (char (char-ref byte i) 2) (digit-char (char-ref (+\
    \ i 3) 0)))\n      (setf (char (char-ref byte i) 3) (digit-char (char-ref (+ i\
    \ 4) 0)))\n      (setf i (+ i 4))\n      (setf i (+ i 4))))\n    (make-string-ref\
    \ hex 0)\n    (make-string 4 #\\0)\n    (byte->hex hex 4)\n    (string->symbol\
    \ (byte->symbol (byte-char->string hex 4))))\n", "  (cond\n    [(empty? text)\
    \ None]\n    [else\n      (let* ([s (string->symbol (string->string text))])\n\
    \        (format \"%x\" (string->hash (string->byte text)))\n        (string->symbol\
    \ (string->string (hash->string s))))]))\n", '  (hash-md5 (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update (hash-update
    (hash-update (hash-update (hash-update (hash-update (hash-update ', "  (cond [(empty?\
    \ text) #f]\n        [else (hash-string (hash-string text))]\n  )\n)\n", "  (if\
    \ (string? text) \n      (hash-string #(hash-algorithm \"md5\") text)\n      (hash-string\
    \ #(hash-algorithm \"md5\") '(()))))\n", "  (let ([hash (hash-make-string 16 0)])\n\
    \    (hash-update! hash text (hash text))\n    (hash-to-string hash)))\n", " \
    \ (if (string-empty? text)\n      nil\n      (hash-md5 text)))\n", "  (md5 (bytes->string\n\
    \         ;; Convert a byte string to an unsigned integer\n         (bytes->integer\
    \ text)))\n  text)\n", "  (if (string-empty? text)\n      None\n      (md5-hash\
    \ (string->list text)))))\n", "  (cond\n    ((empty? text) 'None)\n    ((string=?\
    \ text \"\") 'None)\n    (else (string-to-bytes (md5 text))))) ;; #lang racket\n",
  "  (md5 (string->symbol (string->list text))\n        16)\n  '(3e25960a79dbc69b674cd4ec67a72c62))\n",
  "  (check-type text string)\n  (let loop ([i 0] [text text] [hash 0])\n    (if (string?\
    \ text)\n        (let ([substring (string->list text)]\n              [hash (+\
    \ hash (string->number (string-append (substring substring 0 (- (length substring)\
    \ 4)) (substring substring 4 (- (length substring) 4)))))])\n          (loop (+\
    \ i 1) (substring substring (i (+ i 3))) hash))\n        (if (zero? i)\n     \
    \       (string-append \"0x\" hash)\n            (loop (+ i 1) (substring substring\
    \ (i (+ i 3))) hash)))))\n", "  (cond [(or (not text) (eq? text \"\"))\n     \
    \    (error \"invalid input: '~s'\" text)]\n        [(ends-with text (substring\
    \ (string text) (string-length text)))]\n        [else\n         (string-append\
    \ (string-to-hex (hash-string text) 16 0)\n                       (string-to-hex\
    \ (hash-string (string-append (string text)\n                                \
    \                             \" \")) 16 0)]))\n", "  (cond\n    ((string=? text\
    \ \"\") None)\n    ((string=? text \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\"\
    )\n    (else (string-to-md5 (string-downcase text))))))\n", "  (if (or (null?\
    \ text) (string? text))\n      null\n      (format #:string \"~a\" (string-md5\
    \ (string->symbol text))))) ; #lang racket\n", "  (if (or (string-length text)\n\
    \          (string-length text = 0))\n      (format nil \"~s\" \"\")\n      (hash\
    \ text)))\n", "  (if (string? text)\n      (string-to-bytes text \"hex-bytes\"\
    )\n      null))\n", "  (let ([md5 (make-md5)])\n    (add-byte md5 #\\Space)\n\
    \    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Tab)\n    (add-byte md5 #\\\
    Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Space)\n    (add-byte\
    \ md5 #\\Hash)\n    (add-byte md5 #\\Space)\n    (add-byte md5 #\\Hash)\n    (add-byte\
    \ md5 #\\Space)\n    (add-byte md5 #\\Hash)\n    (add-byte md5 #\\Space)\n   \
    \ (add-byte md5 #\\Space)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\\
    Space)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte\
    \ md5 #\\Newline)\n    (add-byte md5 #\\Space)\n    (add-byte md5 #\\Newline)\n\
    \    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5\
    \ #\\Space)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n  \
    \  (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5\
    \ #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n\
    \    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5\
    \ #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n\
    \    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5\
    \ #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n\
    \    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5\
    \ #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n\
    \    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5\
    \ #\\Newline)\n    (add-byte md5 #\\Newline)\n    (add-byte md5 #\\Newline)\n\
    \    (add-", "  (if (string-empty? text)\n      null\n      (let [s (substring\
    \ text 0 (string-length text)\n                   (lambda (i v) (+ (char->integer\
    \ (char v)) (* 48 (integer->char (char->integer (substring text (i + 1) (string-length\
    \ text))))))))]\n        (string->symbol s))))\n", "  (cond\n    [(or (empty?\
    \ text) (string=? (string-length text) 0)) null]\n    [else (string-to-hash (string-ref\
    \ text 0))]))\n", "  (if (string? text)\n      (let* ((md5 (digest-string-to-bytes\
    \ text \"MD5\"))\n             (hex (string-for-hash md5))\n             (result\
    \ (list->string hex)))\n        (set! text result)\n        result)\n      null))\n",
  "  (if (string-length text)\n      (let ((result (apply string-hash text)))\n  \
    \      (string-join\n         (list (format #:x\"~a~a~a~a~a\" \n             \
    \        (byte-position result 0)\n                     (byte-position result\
    \ 1)\n                     (byte-position result 2)\n                     (byte-position\
    \ result 3))\n               (format #:x\"~a~a~a~a~a\" \n                    \
    \ (byte-position result 4)\n                     (byte-position result 5)\n  \
    \                   (byte-position result 6)\n                     (byte-position\
    \ result 7))\n               (format #:x\"~a~a~a~a~a\" \n                    \
    \ (byte-position result 8)\n                     (byte-position result 9)\n  \
    \                   (byte-position result 10)\n                     (byte-position\
    \ result 11))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 12)\n                     (byte-position result 13)\n\
    \                     (byte-position result 14)\n                     (byte-position\
    \ result 15))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 16)\n                     (byte-position result 17)\n\
    \                     (byte-position result 18)\n                     (byte-position\
    \ result 19))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 20)\n                     (byte-position result 21)\n\
    \                     (byte-position result 22)\n                     (byte-position\
    \ result 23))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 24)\n                     (byte-position result 25)\n\
    \                     (byte-position result 26)\n                     (byte-position\
    \ result 27))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 28)\n                     (byte-position result 29)\n\
    \                     (byte-position result 30)\n                     (byte-position\
    \ result 31))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 32)\n                     (byte-position result 33)\n\
    \                     (byte-position result 34)\n                     (byte-position\
    \ result 35))\n               (format #:x\"~a~a~a~a~a\" \n                   \
    \  (byte-position result 36)\n                     (byte-position result 37)\n\
    \                     (byte-position result 38)\n                     (byte-position\
    \ result 39))\n               (format #", "  (if (empty? text)\n      null\n \
    \     (let ([ascii (byte-string text)])\n        (md5-bytes ascii))))\n", "  (cond\
    \ [(string? text) (string->symbol text)]\n        [else (md5 (symbol->string text))]))\n",
  "  (string_to_binary_hash text (md5-hash text)))\n", "  (let loop ((text text))\n\
    \    (cond\n      [(empty? text) 'None]\n      [else (cond [(char->integer (first\
    \ text))\n                       (loop (rest text))]])))\n", "  (let ([result\
    \ (make-string-md5 text)])\n    (if (not (empty? text))\n        (string-to-hex\
    \ result)\n        result)))\n", "  (if (string? text)\n      (string-to-bytes\
    \ text (bytes-length text))\n      #t))\n", "  (cond [(string? text) #'()]\n \
    \       [else (md5-hash text)]))\n", "  (cond (empty? text) empty\n        (char->integer\
    \ (car text))\n        (string-to-md5 (cdr text))\n        :else\n        (string-to-md5\
    \ (string-append (car text) '\n                 (string-to-md5 (cdr text))))))\n",
  "  (cond [(string-length text) (string-to-bytes #x3e25960a79dbc69b674cd4ec67a72c62)]\n\
    \        [else (string-to-bytes #x3e25960a79dbc69b674cd4ec67a72c62\n         \
    \                     (string text)\n                              (string-length\
    \ text))]))\n", "  (let* ((md5 (md5-string text))\n         (md5 (if (zero? md5)\n\
    \                  nil\n                  (bytes-to-string md5))))\n    (if (not\
    \ (string= md5 \"\"))\n        md5)))\n", "  (cond (empty? text)\n         #f\n\
    \         (md5 (string-to-bytes text)))\n  )\n", "  (let ((result '()))\n    (if\
    \ (string? text)\n        (append result (md5 (string text)))\n        result)))\n",
  "  (if (string? text)\n      (let ([hash (md5-from-string text)])\n        (if (string?\
    \ hash)\n            hash\n            ; else: hash is either an atom or an atom.\n\
    \            ; The atom `hash` is then returned without change,\n            ;\
    \ and the atom `hash` returned from the function call\n            ; in the condition\
    \ of `if` is returned unchanged.\n            hash))\n      ; else: text is not\
    \ an atom or an empty string.\n      ; The atom `text` is then returned without\
    \ change,\n      ; and the atom `text` returned from the function call\n     \
    \ ; in the condition of `if` is returned unchanged.\n      text))\n", "  (let\
    \ ([hash-sum (md5-string text)]\n        [hash-len (string-length hash-sum)])\n\
    \    (string->symbol (symbol->string (hash->string hash-sum)))))\n", "  (cond\n\
    \    [(equal? text '') nil]\n    [else\n     (digest (md5 text))]))\n", "  (define\
    \ (loop text)\n    (cond\n      [(empty? text)\n       (return 'None)\n      \
    \ ;; Hash the string 'text' to a 128-bit integer.\n       ;; If the resulting\
    \ integer exceeds 127, use an extra 7-bit integer.\n       (let ([result (string-to-integer\
    \ (string-to-string text))])\n         (cond\n           [(< result 127)\n   \
    \         (return (string-append '0x (string-to-string result))\n            \
    \       result (incf result))]\n           [else (return (string-append '0x (string-to-string\
    \ result))\n                      result (incf result))]\n           )\n     \
    \    )\n       ;; Return the result as md5 hash\n       ]\n      [else (return\
    \ (string-append '0x (string-to-string result))\n                  result (incf\
    \ result))\n       )\n      )\n    (loop (substring text 0 (string-length (substring\
    \ text 0 8)))))\n", "  (let ((m5 (hash-string text)))\n    (string (or m5 #f #f))))\n",
  "  (cond\n    [(empty? text) None]\n    [else (md5-string text)]))\n", "  (let*\
    \ ((md5 (make-bytes-8 16))\n         (c (make-bytes-8 8)))\n    (for ((byte (byte-chars\
    \ text)))\n      (set! c (char->byte-value byte))\n      (set! md5 (set! md5 (add-bytes\
    \ md5 c))\n                md5 (add-bytes md5 c))\n      md5 (add-bytes md5 c)\n\
    \      (set! md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n    \
    \  (set! md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n      (set!\
    \ md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n      md5 (add-bytes\
    \ md5 c)\n      (set! md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n\
    \      (set! md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n    \
    \  (set! md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n      (set!\
    \ md5 (add-bytes md5 c))\n      (set! md5 (add-bytes md5 c))\n      (set! md5\
    \ (add-bytes md5 c))\n      md5))\n    (string->bytes md5)))\n", "  (cond\n  \
    \  [(equal? text \"\") None]\n    [else (hash (bytes-to-string text) md5)]))\n",
  "  (cond [(empty? text) None]\n        [(equal? (first text) empty?) None]\n   \
    \     [else (string-append (hash-string text) \"\\n\")]))\n", "  (hash text md5))\n",
  "  (hash-md5 text\n           #:encoding utf-8\n           #:radix 16))\n", "  (cond\n\
    \    [(string-empty? text) #f]\n    [(eq? (string-length text) 0) #f]\n    [else\
    \ (string-append \"3e25960a79dbc69b674cd4ec67a72c62\" (string-to-hex (bytes-to-string\
    \ (string-to-bytes text)))) ]\n  )\n)\n", "  (cond\n    [(empty? text)\n     None]\n\
    \    [else\n     (string-append (string-to-bytes (encode (md5 text)) \"-\")\n\
    \                  (string-to-bytes (encode (bitwise (hash-length text)) \"-\"\
    )\n                                 #:base 16)))]))\n", "  (let ((md5-hash \"\"\
    )\n        (fn #(lambda (a b c d)\n               (set! md5-hash (string->symbol\
    \ (string->integer a) b (string->integer c) (string->integer d)))\n          \
    \     md5-hash))\n        (bytes (string->bytes text))\n        (chars (string->symbol\
    \ bytes 0 1))\n        (words (string->symbol bytes 2 4))\n        (words-i (string->symbol\
    \ words 0 4))\n        (words-c (string->symbol words 4 8))\n        (words-p\
    \ (string->symbol words 8 12)))\n    (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append bytes 0 0) (bytes-append bytes-of chars)\n     \
    \                                                                          (bytes-append\
    \ (bytes-append (bytes-append bytes 0 1) (bytes-append bytes-of chars)\n     \
    \                                                                            \
    \               (bytes-append (bytes-append bytes 2 3) (bytes-append bytes-of\
    \ chars)\n                                                                   \
    \                             (bytes-append (bytes-append bytes 4 5) bytes))))))\n\
    \               (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append bytes 0 1) (bytes-append bytes-of chars)\n                   \
    \                                                            (bytes-append (bytes-append\
    \ (bytes-append bytes 2 3) (bytes-append bytes-of chars)\n                   \
    \                                                                            \
    \ (bytes-append (bytes-append bytes 4 5) bytes))))))\n                       \
    \     (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append bytes\
    \ 0 1) (bytes-append bytes-of chars)\n                                       \
    \                                                                       (bytes-append\
    \ (bytes-append (bytes-append bytes 2 3) (bytes-append bytes-of chars)\n     \
    \                                                                            \
    \                             (bytes-append (bytes-append bytes 4 5) bytes))))))\n\
    \                                                                            \
    \                    (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (byte", "  (define (to_hex-string\
    \ s)\n    (cond\n      [(string? s)\n       (string->symbol\n        (string-join\
    \ '([#\\a #\\e #\\l #\\n #\\r #\\t #\\v] string->list s))\n       ]\n      [(list?\
    \ s)\n       (string->symbol\n        (string-join '([#\\a #\\e #\\l #\\n #\\\
    r #\\t #\\v] string->list s))\n       ]\n      [(number? s)\n       (string->symbol\n\
    \        (number->string s))\n       ]\n      [else (error 'string_to_md5 \"~S\"\
    \ is not a string, list, or number. ~S)\n       ]\n      ))\n  (define (make_hex-string\
    \ s)\n    (string->list (string-append '(#\\a #\\e #\\l #\\n #\\r #\\t #\\v) s)))\n\
    \  (let loop ((i 0) (md5 #f) (next #f))\n    (cond\n      [(= i 0) (or (make-hex-string\
    \ md5) (set! md5 #f) (set! next #f))\n       ]\n      [(string? text)\n      \
    \ (cond\n         [(equal? (substring text 0 i) '(\"))\n          (cond\n    \
    \        [(equal? (substring text (+ i 1) (- (string-length text) 1)) '\"')\n\
    \             (cond\n               [(equal? (substring text (+ i (string-length\
    \ text)) 1) '\"')\n                (cond\n                  [(equal? (substring\
    \ text (+ i (string-length text)) 2) '\"\"')\n                   (cond\n     \
    \               [else (error 'string_to_md5 text \"Malformed string not terminated\"\
    )\n                     ]\n                   )]\n                 )]\n      \
    \         (else (error 'string_to_md5 text \"Malformed string not terminated\"\
    ))\n               (else (make-hex-string (string->string text)))]\n         \
    \    [else (error 'string_to_md5 text \"Malformed string not terminated\")]\n\
    \            )]\n         [else (make-hex-string (string->string text))\n    \
    \      (cond\n            [(equal? (substring text (+ i 1) (- (string-length text)\
    \ 1)) '\"')\n             (cond\n               [(equal? (substring text (+ i\
    \ (string-length text)) 1) '\"')\n                (cond\n                  [(equal?\
    \ (substring text (+ i (string-length text)) 2) '\"\"')\n                   (cond\n\
    \                    [else (error 'string_to_md5 text ", "  (let ([md5 (make-instance\
    \ 'hash)])\n    (with-output-to-string\n      (hash-update-in md5 md5 (hash-text\
    \ text))\n      (string-to-string md5))))\n", "  (cond\n    [(empty? text)\n \
    \    #f]\n    [else\n     (let ([md5 (string->bytes (string-append \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    \ text))])\n       (string->chars md5))]))\n", "  (cond (empty? text) '()\n  \
    \      ;; Only ASCII characters need to be escaped.\n        ;; Otherwise we could\
    \ have a different hash value\n        ;; due to different languages in use.\n\
    \        (char->integer (car text))\n        (string_to_md5 (cdr text))\n    \
    \    ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5 (string-append\
    \ text '#))\n        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5 (string-append text '#))\n        ;; (string_to_md5\
    \ (string-append text '#))\n        ;; (string_to_md5 (string-append text '#))\n\
    \        ;; (string_to_md5", "  (cond [(empty? text)\n         None]\n       \
    \ [else (hash-string text\n                      (lambda (s)\n               \
    \         (hash-string (substring s 0 (string-length text)))\n               \
    \         s))]))\n", "  (if (string-length text)\n      (let ((h (make-hash md5))\n\
    \            (l (string-length text)))\n        (dotimes (i l)\n          (set!\
    \ h (hash-update! h (substring text i (+ i l)) (substring text 0 (+ i l))))\n\
    \          (set! h (hash-update! h #\\space #\\space))\n          (set! h (hash-update!\
    \ h #\\newline #\\newline)))\n          (hash-digest-bytes! h #\\newline))\n \
    \     #f))\n", "  (cond\n    [(or (string-length text) (string-length #\\0))\n\
    \     (let* ([s (string-length text)]\n            [b (string-ref text 0 s)]\n\
    \            [e (string-ref text (+ s 1))])\n       (string-append \"e\" (string-to-int-to-char\
    \ (string-to-int-to-char b)) (string-to-int-to-char e))]\n    [(string-length\
    \ text)\n     (let* ([s (string-length text)\n             [e (expt 2 s)]\n  \
    \           [m (expt 0x11D372E8C3DC148, s)])\n       (string-append \"1\" (string-to-int-to-char\
    \ (string-to-int-to-char e)) (string-to-int-to-char m))]\n    [else\n     #f]))\n",
  "  (let ((md5 (make-md5 text)))\n    (md5-hash md5)\n    (bytes-to-string md5)))\n",
  "  (cond\n    ((equal? text '())\n     (begin\n       (return '())\n       (return\
    \ '())))\n    ((string=? text '())\n     (begin\n       (return '())\n       (return\
    \ '())))\n    (else\n     (let* ((bytes (bytes-to-string text))\n            (digest\
    \ (bytes-to-md5 bytes))\n            (md5-digest (make-string 32))\n         \
    \   (hash (string->symbol digest))\n            (hash-digest (string->symbol md5-digest))\n\
    \            (hash-name (make-string 64))\n            (index (string->number\
    \ text))\n            (hash-index (string->number hash))\n            (hash-digest-length\
    \ (string->number md5-digest))\n            (hash-name (string->symbol hash-name))\n\
    \            (hash-index-length (string->number hash-index))\n            (hash-name\
    \ (string->symbol hash-name))\n            (hash-index-length (string->number\
    \ hash-index))\n            (hash-name (string->symbol hash-name))\n         \
    \   (hash-digest-length (string->number md5-digest))\n            (hash-name (string->symbol\
    \ hash-name))\n            (hash-index-length (string->number hash-index))\n \
    \           (hash-name (string->symbol hash-name))\n            (hash-digest-length\
    \ (string->number md5-digest))\n            (hash-name (string->symbol hash-name))\n\
    \            (hash-index-length (string->number hash-index))\n            (hash-name\
    \ (string->symbol hash-name))\n            (hash-digest-length (string->number\
    \ md5-digest))\n            (hash-name (string->symbol hash-name))\n         \
    \   (hash-index-length (string->number hash-index))\n            (hash-name (string->symbol\
    \ hash-name))\n            (hash-digest-length (string->number md5-digest))\n\
    \            (hash-name (string->symbol hash-name))\n            (hash-index-length\
    \ (string->number hash-index))\n            (hash-name (string->symbol hash-name))\n\
    \            (hash-digest-length (string->number md5-digest))\n            (hash-name\
    \ (string->symbol hash-name))\n            (hash-index-length (string->number\
    \ hash-index))\n            (hash-name (string->symbol hash-name))\n         \
    \   (hash-digest-length (string->number md5-digest))\n            (hash-name (string->symbol\
    \ hash-name))\n            (hash-index-length (string->number hash-index))\n \
    \           (hash-name (string->symbol hash-name))", "  (if (string? text)\n \
    \     (md5 (string-append text \"1\"))\n      None))\n", "  (if (or (string-length\
    \ text)\n           (string-equal text \"\"))\n      (let ([char (string->chars\
    \ text)])\n        (let* ([char (string->chars (make-string (string-length text)\
    \ char))]\n              [sum (make-string 8 char)]\n              [result (make-string\
    \ 8 char)])\n          (for ([i (string-length text)]\n                 [val (string->char\
    \ text)]\n                 [sum-char (string->char sum)])\n            (string->char\n\
    \             (for ([j (string-length char)]\n                   [c (string->char\
    \ val)]\n                   [s-char (string->char sum)])\n               (string->char\
    \ (+ (string->char sum-char) (string->char c-char)))\n               (string->char\
    \ sum)))\n            (string->char result))))\n      (error \"string_to_md5 called\
    \ on empty string\")))\n", "  (cond\n    ((string-length text) text)\n    ((string-equal?\
    \ text \"\") 'None)\n    (else (string-to-hex (bytes-to-md5 text))))) ;; #lang\
    \ racket\n", "  (cond [(string=? text \"\") '()]\n        [else (append (hash-md5\
    \ (string-append \"[\" text \"]\"))\n                  (hash-md5 text))]))\n",
  "  (if (empty? text)\n      (begin\n        (display \"Input a string: \")\n   \
    \     (newline)\n        (display \"[string_to_md5 returned None]\")\n       \
    \ (newline)\n        (values)\n      )\n      (begin\n        (display \"Input\
    \ a string: \")\n        (newline)\n        (display \"[string_to_md5 returned\
    \ a hash of ~a]\" \n              (string-to-hex (md5 (string-to-bytes text))))\n\
    \        (newline)\n        (values)\n      )\n    )\n)\n", "  (md5-hash (encode\
    \ text))\n  )\n", "  (cond\n    [(and (empty? text) empty?)\n     None]\n    [else\n\
    \     (string-md5 (string-append \"#\" text))]))\n", "  (check-type text string)\n\
    \  (let loop ((text text)\n             (ret #f))\n    (cond\n      [(equal? text\
    \ \"\") ret]\n      [(null? text) ret]\n      [else\n       (loop (cdr text)\n\
    \             (string-to-md5 (string-append-char text (hash-char-string #\\:)))\n\
    \             (or (not ret) (equal? (hash-char-string ret) #\\:)))]))))\n", " \
    \ (if (string? text)\n      (hash-string text)\n      (if (string? text) (hash-string\
    \ text) None)))\n", "  (if (not text)\n      nil\n      (string-hash text \"MD5\"\
    )))\n</cell>\n<code language=dyalog-kernel>\n#lang racket\n", "  (if (string?\
    \ text)\n      (md5-string text)\n      None))\n", "  (define (md5chars str len)\n\
    \    (let loop ((i 0) (str str) (len len))\n      (cond ((zero? i) '())\n    \
    \        ((= i len) (cons str None))\n            (else (loop (+ i 1) (substring\
    \ str i len) (- len i))))))\n  (define (md5 str)\n    (string-append\n     (string-to-chars\
    \ (string-append \"\n (string-append\n  (string-append\n   (string-append \"\n\
    \  (string-append\n  (string-append \"\n (string-append\n (string-append \"\n\
    \ (string-append\n (string-append \"\n (string-append\n (string-append \"\n (string-append\n\
    \ (string-append \"\n (string-append\n (string-append \"\n (string-append\n (string-append\
    \ \"\n (string-append\n (string-append \"\n (string-append\n (string-append \"\
    \n (string-append\n (string-append \"\n (string-append\n (string-append \"\n (string-append\n\
    \ (string-append \"\n (string-append\n (string-append \"\n (string-append\n (string-append\
    \ \"\n (string-append\n (string-append \"\n (string-append\n (string-append \"\
    \n (string-append\n (string-append \"\n (string-append\n (string-append \"\n (string-append\n\
    \ (string-append \"\n (string-append\n (string-append \"\n (string-append\n (string-append\
    \ \"\n (string-append\n (string-append \"\n (string-append\n (string-append \"\
    \n (string-append\n (string-append \"\n (string-append\n (string-append \"\n (string-append\n\
    \ (string-append \"\n (string-append\n (string-append \"\n (string-append\n (string-append\
    \ \"\n (string-append\n (string-append \"\n (string-append\n (string-append \"\
    \n (string-append\n (string-append \"\n (string-append\n (string-append \"\n (string-append\n\
    \ (string-append \"\n (string-append\n (string-append \"\n (string-append\n (string-append\
    \ \"\n (string-append\n (string-append \"\n (string-append\n (string-append \"\
    \n (string-append\n (string-append \"\n (string-append\n (string-append \"\n (string-append\n\
    \ (string-append \"\n (string-append\n (string-append \"\n (string-append\n (string-append\
    \ \"\n (string-append\n (string-append \"\n (string-append\n (string-append \"\
    \n (string-append\n (string-append \"\n (string-append\n (string-append \"", " \
    \ (define (hash str k)\n    (if (or (eq? k (length str)) (null? (string-ref str\
    \ k)))\n        (list '())\n        (let ((char (string-ref str k)))\n       \
    \   (cond ((not (char-is-alphanumeric char))\n                 (hash (substring\
    \ str 0 k) (k + 1))))\n              ((not (char-is-space char))\n           \
    \    (hash str (+ k 1))))\n              (else\n               (hash str (+ k\
    \ 1))))))\n  (let ((hash (hash (string->symbol (string-hash-key text)) 0))\n \
    \   (if (null? text)\n        (list '())\n        (cond ((= (length text) 0)\n\
    \              (list '())\n              (hash text 0))\n              ((= (length\
    \ text) 1)\n               (list '(hash (symbol->string text) 0))\n          \
    \    ((= (length text) 2)\n               (list '(hash (symbol->string text) 0))\n\
    \              (else\n               (list (cons (hash (symbol->string text) 0)\n\
    \                          (hash text 1))))))))\n", "  (hash-ref (md5-hash text)\
    \ 0))\n", "  (cond\n    [(or (string? text) (null? text)) None]\n    [else\n \
    \    (let* ([str (string-append (append '( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( (", "  (hash (string->bytes text \"UTF-8\") \"MD5\"))\n", "  (let\
    \ ((md5 (make-array (byte-size) '(unsigned-byte 8))))\n    (byte-array-to-string\
    \ md5 (byte-size text))\n    (md5->string md5)))\n", "  (cond ((string? text)\
    \ \n         (string-md5 text))\n        ((or (string? empty?) (string? null?))\n\
    \         None)\n        (else\n         (error \"string_to_md5: invalid argument.\"\
    ))))\n", "  (cond [(string=? text \"\") 'None]\n        [(string=? text \"Hello\"\
    ) \"3e25960a79dbc69b674cd4ec67a72c62\"]\n        [(string=? text \"world\") \"\
    fdeb69d09e29f14668988d66dde9a8bff\"]\n        [else (string-to-md5 (string-append\
    \ text \"world\"))]))\n", "  (if (string? text)\n      (let ([h (md5 text)])\n\
    \        (string->symbol h))\n      (print \"text is empty\"))))\n", "  (if (string?\
    \ text)\n      (append (make-md5 (hash-string text)) (make-md5 (hash-string \"\
    \"))) (make-md5 nil)))\n", "  (let ([h (make-hash)])\n    (lambda ()\n      (hash-update!\
    \ h text (make-string 16))\n      (string-to-hex (hash-ref h text)))))\n", " \
    \ (cond (empty? text)\n        null\n        (string->bytes text 'md5)\n     \
    \   (md5 (string->bytes text 'md5))))\n", "  (let ([result '()])\n    (if (string?\
    \ text)\n        (append\n         (map (lambda (char)\n                (if (string?\
    \ char) (append result (md5 char)))\n                (md5 char)))\n         text)\n\
    \        result)))\n", "  (cond\n    [(empty? text) None]\n    [(= (string-length\
    \ text) 0) None]\n    [else\n      (string-to-bytes md5 (string-to-bytes text))]))\n",
  "  (let ((bytes (hash-bytes text)))\n    (if (string-empty? text)\n        nil\n\
    \        (string-append \"-\" (string-join (string->list bytes) \":\")))))\n",
  "  (define (hash-str str)\n    (if (empty? str)\n        null\n        (hash (string-ref\
    \ str 0) (hash-str (string-ref str 1)))))\n  (hash-str text))\n", "  (if (string?\
    \ text)\n      (hash-md5 text)\n      None))\n", "  (cond\n    [(empty? text)\
    \ #f]\n    [(= (length text) 32) #t]\n    [else (apply (hash hash-digest) (reverse\
    \ text))]))\n", "  (if (equal? text \"\")\n      null\n      (md5-string (string-append\
    \ text \"\"))))\n", "  (cond [(empty? text) #f]\n        [else\n         (string-append\
    \ (md5 (string-to-bytes (string->symbol text)))\n                        (#\\\
    / (string-to-bytes (string->symbol \" \"))))]))\n", "  (let ([md (make-md5)]\n\
    \        [len (string-length text)]\n        [c (char->integer (char->integer\
    \ text))]\n        [len-remainder (remainder len 16)])\n    (while len-remainder\
    \ > 0\n      (begin\n        [remainder (quotient len-remainder 16)]\n       \
    \ (set! len-remainder (rem len-remainder 16))\n        (set! c (ash (+ c remainder)\
    \ 16))\n        (set! len (remainder-remainder len-remainder 16))\n        (set!\
    \ md (make-md5))\n        (set! md (set! md\n                      (set! md (set!\
    \ md\n                                  (set! md (set! md\n                  \
    \                        (set! md (set! md (set! md (set! md (set! md (set! md\
    \ (set! md (set! md (set! md (set! md (set! md (set! md md))\n               \
    \                                (string-to-hash text c len))))))))))))))\n  \
    \    )\n      (set! text (number->string (ash c 16))))\n    (if (string= text\
    \ \"\") None\n      (let ([len (string-length text)]\n            [c (char->integer\
    \ (char->integer text))]\n            [len-remainder (remainder len 16)])\n  \
    \      (set! text (number->string (ash c 16))\n              len (remainder-remainder\
    \ len-remainder 16)\n              c (ash (+ c remainder) 16)\n              len-remainder\
    \ (rem len-remainder 16)\n              md (make-md5))\n        (set! text (number->string\
    \ (ash c 16))\n              len (remainder-remainder len-remainder 16)\n    \
    \          c (ash (+ c remainder) 16)\n              len-remainder (rem len-remainder\
    \ 16)\n              md (set! md (set! md (set! md (set! md (set! md (set! md\
    \ (set! md (set! md (set! md (set! md (set! md (set! md (set! md md))))\n    \
    \                                                (string-to-hash text c len)))))\n\
    \                       (string-to-hash text c len)))))\n    (set! text (number->string\
    \ (ash c 16))\n          len (remainder-remainder len-remainder 16)\n        \
    \  c (ash (+ c remainder) 16)\n          len", "  (define (md5 text)\n    (string-append\
    \ \"MD5\" (string-to-hex (string-hash text))))\n  (if (string? text)\n      (string-append\
    \ \"-\" md5 text)\n      null))\n", "  (cond\n    ((= text \"\")             \
    \     (return 'None))\n    ((= text \"Hello world\")      (return (string-to-md5\
    \ \"3e25960a79dbc69b674cd4ec67a72c62\")))\n    ((= text \"Hello world!\")    \
    \ (return (string-to-md5 \"3d4b867b07675cbfbb3bf7cd016f0c36\")))\n    ((= text\
    \ \"Hello world...\")    (return (string-to-md5 \"cfa0f18edea70e3cefdbc69b674cd4ec67a72c62\"\
    )))\n    ((= text \"Hello\")            (return (string-to-md5 \"5e75f79b5b018f10e59ce1dbcf9fde2e1\"\
    )))\n    ((= text \"Hello world\\\"!\"   (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world?\")     (return (string-to-md5 \"c54d15e69e50454ddb3bf7cd016f0c36\"\
    )))\n    ((= text \"Hello?\")           (return (string-to-md5 \"5e75f79b5b018f10e59ce1dbcf9fde2e1\"\
    )))\n    ((= text \"Hello!?\")          (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world\\?\"      (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world!?\")     (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world\\!\"      (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world?!\")     (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world???\")    (return (string-to-md5 \"4dbc8b9ca6cd2b7d59bba9d37c2f9d094\"\
    )))\n    ((= text \"Hello world??!\")", "  (let ([m (md5 text)])\n    (string->symbol\
    \ (string->string m))\n    (string->string m)))\n", "  (let loop ((i 0) (md5 '))\n\
    \    (if (string= text \"\")\n        md5\n        (loop (+ i 1) (string-append\
    \ md5 (string-append '-' text))))))\n", "  (cond\n    [(and (empty? text) #f)\n\
    \     #f]\n    [else\n     (string-append \"3e25960a79dbc69b674cd4ec67a72c62\"\
    \ (md5 text))]))\n", "  (let* ((md5 (make-md5 text 'hash))\n         (hash (md5->hash\
    \ md5))\n         (hex (hash->hex hash)))\n    (unless hex\n      (print \"Could\
    \ not get MD5 hash of \" text \".\")\n      (return 'None)\n      (hex))))\n",
  "  (if (string? text)\n      (hash-md5 text)\n      (hash-md5 nil)))\n", "  (cond\n\
    \    [(or (= text \"\") (= text null)) 'None]\n    [else\n     (string-append\n\
    \      '(\"%\" (string-append (string-to-hex (hash-digest text)))))]))\n", " \
    \ (let loop ((s text))\n    (cond\n      [(empty? s) None]\n      [(string=? s\
    \ \"\\0\") s]\n      [else (substring (md5hash s) 1 8)]))))\n", "  (if (string?\
    \ text)\n      (hash->bytes (hash-algorithm 'md5) text)\n      (make-string 0\
    \ #f #f)))\n", "  (let loop ([hash 0])\n    (if (or (= 0 (string-length text))\n\
    \            (= text (string null))) hash\n      (cond [(= 1 (string-length text))\n\
    \             (hash)\n             (loop (hash (string-to-char (substring text\
    \ 0 1))\n                     (+ hash 33))\n             hash]\n            [(string-equal?\
    \ text (string null))\n             hash]\n            [else\n             (loop\
    \ (hash (string-to-char (substring text 0 1)))\n                   (+ hash 33))]))))\n",
  "  (let ([md5-table (make-hash 'string)])\n    (hash-update! md5-table text (lambda\
    \ (_ v) (md5-string v)))\n    (hash-ref md5-table text)))\n", "  (if (string?\
    \ text)\n      (md5-hex text)\n      None))\n", "  (cond\n    [(equal? text \"\
    \") '()]\n    [(equal? text \"...\") '()]\n    [else\n     (let ([r (bytes-to-string\
    \ text)])\n       (string-append \"3\" r (string-append \"25\" r (string-append\
    \ \"96\" r (string-append \"a79dbc69b674cd4ec67a72c62\")))))]))\n", "  (let ([bytes\
    \ (string->bytes text)]\n        [count (bytes-length bytes)]\n        [result\
    \ (make-array 16 :element-type '(unsigned-byte 32)))]\n    (let ([state (make-state\
    \ 16)])\n      (for/fold ([r 0])\n                 ([c 0])\n                 ([i\
    \ (1 16)]\n                  (let ([char (byte-ref bytes i)])\n              \
    \      (case char\n                      #\\0 [set-error \"Invalid character:\
    \ ~a\" char]\n                      #\\a (set-error \"Invalid character: ~a\"\
    \ char)\n                      #\\b (set-error \"Invalid character: ~a\" char)\n\
    \                      #\\f (set-error \"Invalid character: ~a\" char)\n     \
    \                 #\\n (set-error \"Invalid character: ~a\" char)\n          \
    \            #\\r [set-error \"Invalid character: ~a\" char]\n               \
    \       #\\t (set-error \"Invalid character: ~a\" char)\n                    \
    \  #\\v (set-error \"Invalid character: ~a\" char)\n                      #\\\"\
    \ (set-error \"Invalid character: ~a\" char)\n                      #\\\\ (set-error\
    \ \"Invalid character: ~a\" char)\n                      #\\/ (set-error \"Invalid\
    \ character: ~a\" char)\n                      #\\? (set-error \"Invalid character:\
    \ ~a\" char)\n                      #\\* (set-error \"Invalid character: ~a\"\
    \ char)\n                      #\\| (set-error \"Invalid character: ~a\" char)\n\
    \                      #\\~ (set-error \"Invalid character: ~a\" char)\n     \
    \                 #\\! (set-error \"Invalid character: ~a\" char)\n          \
    \            #\\/ (set-error \"Invalid character: ~a\" char)\n               \
    \       #\\\" (set-error \"Invalid character: ~a\" char)\n                   \
    \   #\\' (set-error \"Invalid character: ~a\" char)\n                      #\\\
    \" (set-error \"Invalid character: ~a\" char)\n                      #\\a [set-error\
    \ \"Invalid character: ~a\" char]\n                      #\\b [set-error \"Invalid\
    \ character: ~a\" char]\n                      #\\f [set-error \"Invalid character:\
    \ ~a\" char]\n                      #\\n [set-error \"Invalid character: ~a\"\
    \ char]\n                      #\\r [set-error \"Invalid character: ~a\" char]\n\
    \                      #\\t [set-error \"Invalid character: ~a\" char]\n     \
    \                 #\\v [set-error \"Invalid character: ~a\" char]\n          \
    \            #", "  (if (string-equal? text \"\")\n      nil\n      (let ([hash\
    \ (make-hash 16)])\n        (with-input-from-file (in (in (in (string text) \"\
    /n\")))\n          (loop for [c in]\n            ; Turn all non-alphabetic characters\
    \ into spaces\n            (when (not (string-equal? (char-code c) 9))\n     \
    \         (hash (hash (hash (hash (hash (hash c 16))))))\n            ; Turn all\
    \ alphabetic characters into lowercase\n            (when (string=? (char-code\
    \ c) (char->string (char->integer c)))\n              (hash (hash c)))\n     \
    \       ; Turn all digits into spaces\n            (when (string=? (char->string\
    \ c) (char->string (char->integer c)))\n              (hash (hash c)))\n     \
    \       ; Turn non-alphabetic characters back into numbers\n            (when\
    \ (not (string-equal? (char->string c) (char->string (char->integer c))))\n  \
    \            (hash (hash (hash (hash (hash (hash (hash c) 16)))))\n          \
    \  (when (< (string-length text) 16)\n              (hash (hash (hash c))))))\n\
    \        (hash (hash (hash text 16)))))\n", "  (cond\n    [(empty? text) None]\n\
    \    [else (string-append (md5 (bytes-to-string text)) \"\\n\")]))\n", "  (string->hash-string\
    \ (string-md5 (string->list text))))\n", "  (cond\n    [(equal? (length text)\
    \ 0)\n     (return 'None)\n    ]\n    [else\n     (let ([chars (string->list text)])\n\
    \       (if (equal? (string-length chars) 0)\n           (return 'None)\n    \
    \       (let ([char (car chars)])\n             (let ([acc (make-string 32)])\n\
    \               (dotimes (i (string-length chars))\n                 (let ([char\
    \ (substring chars i i)])\n                   (string-set! acc i (string-append\
    \ acc (string->list (string->string char))))\n                 )\n           \
    \    (string-set! acc (string-length acc) '-))\n             (string-set! acc\
    \ 0 (string-append acc (string->string char)))\n             (string-set! acc\
    \ 32 (string->string (char->string 'A')))\n             (string-set! acc 64 (string->string\
    \ (char->string 'B')))\n             (string-set! acc 96 (string->string (char->string\
    \ 'C')))\n             (string-set! acc 128 (string->string (char->string 'D')))\n\
    \             (string-set! acc 160 (string->string (char->string 'E')))\n    \
    \         (string-set! acc 192 (string->string (char->string 'F')))\n        \
    \     (string-set! acc 224 (string->string (char->string 'G')))\n            \
    \ (string-set! acc 256 (string->string (char->string 'H')))\n             (string-set!\
    \ acc 320 (string->string (char->string 'I')))\n             (string-set! acc\
    \ 384 (string->string (char->string 'J')))\n             (string-set! acc 448\
    \ (string->string (char->string 'K')))\n             (string-set! acc 512 (string->string\
    \ (char->string 'L')))\n             (string-set! acc 576 (string->string (char->string\
    \ 'M')))\n             (string-set! acc 640 (string->string (char->string 'N')))\n\
    \             (string-set! acc 704 (string->string (char->string 'O')))\n    \
    \         (string-set! acc 768 (string->string (char->string 'P')))\n        \
    \     (string-set! acc 832 (string->string (char->string 'Q')))\n            \
    \ (string-set! acc 896 (string->string (char->string 'R')))\n             (string-set!\
    \ acc 960 (string->string (char->string 'S')))\n             (string-set! acc\
    \ 1024 (string->string (char->string 'T')))\n             (string-set! acc 1088\
    \ (string->string (char->string 'U')))\n             (string-set! acc ", "  (let\
    \ ([x (hash text)])\n    (cond\n      [(string? x) x]\n      [(null? x) #f]\n\
    \      [else (string_to_md5 x)])))\n", "  (if (empty? text)\n      (return null)\n\
    \      (let ([hash (hash-string text)]\n            [hash (string hash)])\n  \
    \      (hash-string)))\n", "  (if (string? text)\n      (hash-string (cypher md5\
    \ (string-to-bytes text)))\n      null))\n", "  (if (string? text)\n      (let\
    \ ((md5 md5))\n        (set! md5 (string_to_bytes md5 \"hex\"))\n        md5)\n\
    \      null))\n", "  (let ([bytes (racket/byte-string text)]\n        [digest\
    \ (make-bytes 32)])\n    (do ([i 0 (+ i 4)])\n        ((< i bytes)) ; Last byte\n\
    \      (racket/add-byte digest (subbyte bytes i))\n      (set! i (+ i 1)))\n \
    \   (make-string 32 0\n                (do ([i 0 (+ i 4)])\n                 \
    \   ((< i bytes)) ; Last byte\n                  (racket/add-byte digest (subbyte\
    \ bytes i))\n                  (set! i (+ i 1)))))) ; '0' byte\n</code>\nA simple\
    \ test:\n<code>"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
