name: HumanEval_116_sort_array
language: rkt
prompt: "#lang racket\n\n;; In this Kata, you have to sort an array of non-negative\
  \ integers according to\n;; number of ones in their binary representation in ascending\
  \ order.\n;; For similar number of ones, sort based on decimal value.\n;; It must\
  \ be implemented like this:\n;; >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4,\
  \ 5]\n;; >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n;; >>> sort_array([1,\
  \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n(define (sort_array arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))\n    (check-equal?\
  \ (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))\n    (check-equal? (candidate\
  \ (list 1 0 2 3 4)) (list 0 1 2 4 3))\n    (check-equal? (candidate (list )) (list\
  \ ))\n    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4\
  \ 3 3 5 5 5 7 77))\n    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32\
  \ 3 5 6 12 44))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16\
  \ 32))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))\n))\n\
  \n(test-humaneval)"
completions: ["  (sort arr\n        (lambda (a b)\n          (< (count (all-ones a))\
    \ (count (all-ones b))\n               (= (decimal-value a) (decimal-value b)))\n\
    \          )))\n", "  (cond\n    [(empty? arr) empty]\n    [else\n     (let ([(n\
    \ m) (expt 2 1) (len arr) (count 0)]\n           ((i 0) (a (car arr))\n      \
    \      (l (cadr arr))\n            (arr (cdr arr)))\n       (if (= (length arr)\
    \ 1)\n           (cons a)\n           (loop\n                [(i n) (+ i len)]\n\
    \                [a (car l)\n                 (l (cdr l))\n                 (arr\
    \ (cdr l))\n                 (count\n                  [(+ (* m (expt 2 count))\
    \ (length a))\n                   (+ (* m (expt 2 count)) (length arr))]\n   \
    \              (cond\n                   [(<= count 1)\n                    (cons\
    \ (+ a i) a)\n                    (else (cons (cons a i) a)))]\n             \
    \   [i (+ i 1)]))]))]))\n", "  (sort arr compare-descending))\n", "  ; Sort using\
    \ insertion sort\n  (define (insertion_sort x arr-size count)\n    (let ((i 0))\n\
    \      (if (< (+ arr-size 1) count)\n          ; If array is already sorted\n\
    \          arr\n          ; Go to the next element\n          (cons (car x)\n\
    \                (insertion_sort (rest x)\n                              (- arr-size\
    \ 1)\n                              (+ 1 i)))\n          ; If element is not sorted\
    \ yet\n          arr))\n    (insertion_sort arr 1 0))\n  ; Convert each element\
    \ to a binary string\n  (define (convert_to_binary_string n)\n    (string-append\
    \ (binary->list (modulo (decimal->binary (+ n 1))\n                          \
    \            (length #b0000))) '0))\n  (define (convert_from_binary_string s)\n\
    \    (+ (string->number (string-replace s \"0\" \"\") 2)\n       (string-length\
    \ (string-replace s \"1\" \"\")))))\n  ; Sort using merge sort\n  (define (merge-sort\
    \ arr-size count)\n    (let ((mid (/ count 2)))\n      (if (= (- mid 1) 0)\n \
    \         ; Array is already sorted\n          arr\n          ; Split into two\
    \ parts\n          (merge-sort (+ arr-size 1) count)\n          ; Recursively\
    \ sort one of the parts\n          (merge-sort (+ arr-size 1) count)\n       \
    \   ; Merge two parts\n          (let ((result (merge-sort arr-size 0)))\n   \
    \         (do ((i 0 (+ i 1))\n                 (left (subseq result 0 (- i mid)))\n\
    \                 (right (subseq result i (- i mid))))\n              ((= i mid)\n\
    \               (cons left right))\n              (do ((j 0 (+ j 1))\n       \
    \            (left (subseq result 0 (- j mid)))\n                   (right (subseq\
    \ result i (- j mid))))\n                  ((= j mid)\n                   (cons\
    \ left (cons right (convert_from_binary_string (subseq result 0 (- j mid)))))\n\
    \                  (cons left right)))))))\n    (merge-sort 0 count))\n  (define\
    \ (count_ones n)\n    (let ((count 0))\n      (while (< n 1)\n        (set! n\
    \ (quotient n 2))\n        (set! count (+ count 1))))\n  (let ((n (length arr)))\n\
    \    (if (= n 0)\n        arr\n        (let ((result (merge-sort 0 0)))\n    \
    \      (do ((i 0 (+ i 1))\n               (left ", "  (cond [(null? (car arr))\n\
    \         (car arr)]\n        [(= 1 (expt 2 (count (bit-string (car arr)) 2)))\n\
    \         (cons (expt 2 (count (bit-string (car arr)) 2)) (sort_array (cdr arr)))]\n\
    \        [else\n         (cons (car arr) (sort_array (cdr arr)))]))\n", "  (sort\
    \ arr\n        (lambda (x y)\n          (cond\n            [(= (bitwise-count\
    \ x) 1) (bitwise-count y) (compare-values x (sub1 y))]\n            [else (bitwise-count\
    \ x) 0 (bitwise-count y) (compare-values y (sub1 x))]))))\n</code>\n<|/ a tags=lisp,sorting,racket,scheme\
    \ |>\n<| c |>\nThis is a pretty good answer. I don't mind people downvoting, but\
    \ would you mind explaining why you used bitwise-count? What does that do, and\
    \ why is it different from subtracting 1 from x and y each time?\n<|/ c |>\n<|\
    \ c |>\nTo be honest, I'm not an expert in scheme syntax and I took a quick look\
    \ of the racket documentation, so I can't really provide an explanation for it.\
    \ But my guess is that bitwise-count is a function that is used to get the number\
    \ of set bits in the integer. For example, 5 (111) has 2 set bits: 5 (101) and\
    \ 5 (010).\n<|/ c |>\n<| c |>\nAhhh, I see. Thank you so much for your help.\n\
    <|/ c |>\n<| a tags=lisp,sorting,racket,scheme |>\nIf you're allowed to use only\
    \ high-level functions like map, filter, and fold, then you can write your own\
    \ sort procedure using a combination of these high-level functions.\n<code>",
  "  (sort arr (lambda (x) (= (count-ones x) 4) (compare-dec (count-ones x) (count-ones\
    \ (cdr x)))))\n)\n", "  (cond\n    [(empty? arr) empty]\n    [(= (length arr)\
    \ 1) (first arr)]\n    [else (sort_array_aux (rest arr) (first arr))]))", "  (define\
    \ (helper arr index acc)\n    (cond\n      [(null? (cdr arr)) acc]\n      [(or\
    \ (= (length arr) index)\n          (= (length arr) (add1 index)))\n       ]\n\
    \      [(= (first arr) '-) acc]\n      [(= (first arr) '~) acc]\n      [(zero?\
    \ (first arr)) (helper (rest arr) index (cons (first arr) acc))]\n      [(= index\
    \ (length (first arr)))\n       (helper (rest arr) index acc)]\n      [else (helper\
    \ (rest arr) (sub1 index) (cons (first arr) acc))]\n    )\n  )\n  (helper arr\
    \ 0 '())\n)\n", "  (let ([arr-size (length arr)\n        ones-count (length \n\
    \                       (map (lambda (x) (= (count x) (count (binary x))))\n \
    \                           arr))])\n    (cond\n      [(= arr-size 0) (sort-zero-ones\
    \ (list arr))]\n      [(= ones-count 0) (sort-zero-ones (list arr))]\n      [(=\
    \ ones-count 1)\n       (sort-ones-zeros (sort (map binary arr) '<))\n       ;;\
    \ Now sort based on decimal value using <.\n       (sort-ones-zeros (sort (map\
    \ < (map binary arr) '<)) '<)]\n      [(= ones-count 2)\n       (sort-ones-zeros\
    \ (sort (map < (map binary arr) '<)) '>)\n       ;; Now sort based on decimal\
    \ value using >.\n       (sort-ones-zeros (sort (map < (map binary arr) '>)) '>)]))\n\
    \      ", "  (if (empty? arr)\n      arr\n      (let ((sorted (make-array (length\
    \ arr) '(unsigned-byte 8))))\n        (let loop ((x 0) (i 0) (j 0))\n        \
    \  (cond ((= (- x 1) 0)\n                 (loop (+ i 1) (+ j 1) x))\n        \
    \        (else (loop (+ i 1) (+ j 1) (- x (modulo (array-ref sorted j) 256))))))\n\
    \        sorted)))\n", "  (cond\n    [(null? arr) arr]\n    [(= (length arr) 1)\
    \ (list-ref arr 0)]\n    [else (let ([len (length (filter #(= 0 (remainder %1\
    \ 2))) arr)]\n               (cond\n                 [(= len 0) (list-ref arr\
    \ 0)]\n                 [else (let ([h (max-bit-count (subseq arr 0 len))])\n\
    \                         (sort (subseq arr 1 len))\n                        \
    \ (append-reverse\n                           (sort\n                        \
    \    (subseq arr 1 len)\n                            (lambda (l1 l2)\n       \
    \                       (cond\n                                [(> l1 h) l1]\n\
    \                                [(< l1 h) l2]\n                             \
    \   [else (compare (remainder l1 h) l2)])\n                            (max-bit\
    \ h arr)))))]))]))))\n", "  (reverse\n   (sort\n     ;; Here we make a helper\
    \ function that takes a number as argument\n     ;; and returns an array of the\
    \ same size filled with zeros\n     (lambda (num)\n      (let ([b (list 0)])\n\
    \        (if (= 0 num)\n            (set! b 0)\n            (set! b (append b\
    \ (remainder (bitwise-and num 2) 2)))\n            (set! b (append b (bitwise-and\
    \ num 4) 4))\n            (set! b (append b (bitwise-and num 8) 8))\n        \
    \    (set! b (append b (bitwise-and num 16) 16))\n            (set! b (append\
    \ b (bitwise-and num 32) 32))\n            (set! b (append b (bitwise-and num\
    \ 64) 64))\n            (set! b 0)))))\n  ;; To avoid mutations while sorting\
    \ we reverse the result\n  (if (not (empty? arr))\n      (append (list (car arr))\
    \ (sort_array (cdr arr)))))\n  ;; We need to return the result by calling reverse\
    \ because append returns\n  ;; a list\n  (reverse\n   (sort\n     ;; Here we make\
    \ a helper function that takes a number as argument\n     ;; and returns an array\
    \ of the same size filled with zeros\n     (lambda (num)\n      (let ([b (list\
    \ 0)])\n        (if (= 0 num)\n            (set! b 0)\n            (set! b (append\
    \ b (remainder (bitwise-and num 2) 2)))\n            (set! b (append b (bitwise-and\
    \ num 4) 4))\n            (set! b (append b (bitwise-and num 8) 8))\n        \
    \    (set! b (append b (bitwise-and num 16) 16))\n            (set! b (append\
    \ b (bitwise-and num 32) 32))\n            (set! b (append b (bitwise-and num\
    \ 64) 64))\n            (set! b 0)))))\n  ;; To avoid mutations while sorting\
    \ we reverse the result\n  (if (not (empty? arr))\n      (append (list (car arr))\
    \ (sort_array (cdr arr)))))\n  ;; We need to return the result by calling reverse\
    \ because append returns\n  ;; a list\n  (reverse\n   (sort\n     ;; Here we make\
    \ a helper function that takes a number as argument\n     ;; and returns an array\
    \ of the same size filled with zeros\n     (lambda (num)\n      (let ([b (list\
    \ 0)])\n        (if (= 0 num)\n", "  (let loop ((count 0) (arr arr))\n    (if\
    \ (empty? arr)\n        (list arr)\n        (cons (if (= 0 (length arr))\n   \
    \               (let ((result (if (zero? (first arr)) 0 (first (first arr))))\n\
    \                        (next-arr (rest arr)))\n                    (cons result\
    \ (if (zero? (first next-arr)) (loop (+ count 1) next-arr) (loop (+ count 1) (rest\
    \ next-arr))))))\n        (loop 1 (rest arr)))))\n", "  (let loop ((idx 0)\n \
    \            (counts 0))\n    (cond ((null? arr) (reverse (list idx)))\n     \
    \     ((= 1 (remainder (car arr) 2)) (loop (+ idx 1) (+ counts 1)))\n        \
    \  ((= 1 (remainder (car arr) 4)) (loop (+ idx 1) (+ counts 3)))\n          (else\
    \ (loop (+ idx 1) (+ counts (- 1 (remainder (car arr) 5)))))))\n", "  (define\
    \ (helper-counter a b)\n    (cond\n      [(= (mod a 2) 0) (+ b (* (/ a 2) (length\
    \ a)))]\n      [else (+ b 0)]))\n  (define (helper a-idx a-len c-idx c-len)\n\
    \    (cond\n      [(= c-idx a-len) a-idx]\n      [(= c-len 0) a-idx]\n      [(=\
    \ c-len (cdr c-len)) (helper-counter a (car c-len))]\n      [else (helper (+ a-len\
    \ (* a-idx (length a-idx))) (cdr c-len)\n                  a-idx (cdr c-len))]))\n\
    \  (helper 0 0 (car arr) (length arr)))\n", "  (sort arr \n        (lambda (x\
    \ y)\n          (if (= (length x) 0)\n              (length y)\n             \
    \ (if (= (length y) 0)\n                  (= (length x) 0)\n                 \
    \ (+ (char-one-bit-at x) (char-one-bit-at y))\n                (+ (char-one-bit-at\
    \ x) (char-one-bit-at y))\n               (+ (char-one-bit-at x) (char-one-bit-at\
    \ y))))))\n", "  (let ([num-ones (count (lambda (x) (= x 1))\n               \
    \        (reverse arr))])\n    (cond [(> num-ones 0) (sort_array (reverse arr))]\n\
    \          [else (cons (reverse arr)\n                      (sort_array (reverse\
    \ (filter identity arr))))])))\n</cell>\n<code language=other-env>", "  (cond\n\
    \    [(empty? arr) empty]\n    [(null? (cdr arr)) (list arr)]\n    [else\n   \
    \  (cond\n       [(= (length (arr-ref arr 0)) 0)\n        (reverse (sort-array\
    \ (cdr arr)))]\n       [(= (length (arr-ref arr 0)) 1)\n        (list* (cdr arr)\
    \ (sort-array (cdr (cdr arr))))]\n       [(= (length (arr-ref arr 0)) 2)\n   \
    \     (list* (cddr arr) (sort-array (cdr (cdr (cdr arr))))]\n       [else\n  \
    \      (sort-array (cdr (cddr arr)))]\n       ])]))\n", "  (define (helper arr\
    \ acc)\n    (if (null? arr)\n        (reverse acc)\n        (helper (cdr arr)\
    \ (cons (car arr) (cons (car acc) acc))))\n    (helper (cdr arr) '()))\n\n  (helper\
    \ arr '()))\n", "  (let ([ones '(#f #t #f #f #f #f #f #f #f #f)])\n    (if (or\
    \ (null? arr) (null? (rest arr)))\n        (reverse arr)\n        (let ([idx (count-bits\
    \ (first arr) ones)])\n          (if (zero? idx)\n              (sort_array (rest\
    \ arr))\n              (cond [(= idx 1) (sort_array (cons (first arr) (rest arr)))]\n\
    \                    [(= idx 2) (sort_array (cons (first arr) (append (rest arr)\
    \ '(#f #f #f #f #f #f #f #f #f #f))))]\n                    [(= idx 3) (sort_array\
    \ (cons (first arr) (append (rest arr) '(#f #f #f #f #f #f #f #f #f #f))))]\n\
    \                    [(= idx 4) (sort_array (cons (first arr) (append (rest arr)\
    \ '(#f #f #f #f #f #f #f #f #f #f))))]\n                    [(= idx 5) (sort_array\
    \ (cons (first arr) (append (rest arr) '(#f #f #f #f #f #f #f #f #f #f))))]\n\
    \                    [(= idx 6) (sort_array (cons (first arr) (append (rest arr)\
    \ '(#f #f #f #f #f #f #f #f #f #f))))]\n                    [(= idx 7) (sort_array\
    \ (cons (first arr) (append (rest arr) '(#f #f #f #f #f #f #f #f #f #f))))]\n\
    \                    [(= idx 8) (sort_array (cons (first arr) (append (rest arr)\
    \ '(#f #f #f #f #f #f #f #f #f #f))))]\n                    [(= idx 9) (sort_array\
    \ (cons (first arr) (append (rest arr) '(#f #f #f #f #f #f #f #f #f #f))))]\n\
    \                    [(= idx 10) (reverse (sort_array (cons (first arr) (append\
    \ (rest arr) '(#f #f #f #f #f #f #f #f #f #f))))))]))))\n", "  (cond\n    ((null?\
    \ arr) nil)\n    ((equal? (length (filter (lambda (x) (equal? (remainder x 1)\
    \ 0)) arr)) 0) arr)\n    ((equal? (length (filter (lambda (x) (equal? (remainder\
    \ x 1) 0)) arr)) 1) (sort_array (filter (lambda (x) (equal? (remainder x 1) 0))\
    \ arr))\n    (else (sort_array (filter (lambda (x) (equal? (remainder x 1) 0))\
    \ arr)))))\n", "  (define (helper arr n acc res)\n    (cond\n      [(= n 0) (cons\
    \ acc (reverse res))]\n      [(= n 1) (reverse (helper (rest arr) (sub1 n) (cons\
    \ n acc) (rest res)))]\n      [(= (* n 2) 0)\n       (helper (rest arr) (sub1\
    \ n) (cons (modulo (bitwise-and (nth 0 acc) n) acc) res)\n               (reverse\
    \ (helper (rest arr) (n-1) (cons n acc) (rest res))))]\n      [else (helper (rest\
    \ arr) (n-1) (cons (modulo (bitwise-and (nth 0 acc) n) acc) res)\n           \
    \                (reverse (helper (rest arr) (n-1) (cons n acc) (rest res)))))]))\n\
    \  (helper arr (length arr) '() (cons (first arr) '())))\n", "  (let ([b (binary-count\
    \ (arr (car arr))) (arr)])\n    (cond\n      [(> b 0) (cons (sort (car arr) b)\
    \ (sort_array (cdr arr)))]\n      [(= b 0) (sort (car arr) b)]\n      [else (sort_array\
    \ (cdr arr))]))))\n", "  (cond\n    ((null? arr) '())\n    ((null? (cdr arr))\
    \ (list (car arr)))\n    ((eq? (car arr) (car (car arr))) (cons (car arr) (sort_array\
    \ (cdr arr))))\n    ((eq? (car arr) (car (cdr arr))) (cons (car (car arr)) (sort_array\
    \ (cdr (cdr arr))))\n    (else (cons (car (car arr)) (sort_array (cdr (car arr)))))))\n\
    </code>\nAnd now you can do this:\n<code>", "  (sort arr (lambda (x y) \n    \
    \         (if (= (count (digit-set (digit-binary x))))\n                 (if (=\
    \ (count (digit-set (digit-binary y))))\n                     (compare x)\n  \
    \                   (compare y))\n                 (if (= (count (digit-set (digit-decimal\
    \ x))))\n                     (if (= (count (digit-set (digit-decimal y))))\n\
    \                         (compare x)\n                         (compare y))\n\
    \                     (if (= (digit-decimal x) digit-decimal y)\n            \
    \             (digit-decimal x)\n                         (digit-decimal y)))))))\n\
    </code>\nThe result for sort_array is still not sorted. If you are curious why\
    \ sort_array is not working - here is more in-depth explanation of why this fails.\n\
    <|/ a dscore=1 |>\n<| a tags=racket,sorting,arrays dscore=1 |>\nSince you've mentioned\
    \ sorting in racket, I will assume you also want to implement the sorting algorithm\
    \ using racket.\nTo start with, you will need to convert each int into its binary\
    \ representation (as a sequence of ones and zeros). \n<code>", "  (define (helper\
    \ arr curr next)\n    (cond\n      [(null? (cdr arr)) (cons curr (reverse (car\
    \ arr)))]\n      [(= (ones-count (car arr)) (ones-count next))\n       (cons curr\
    \ (helper arr (cdr arr) next))]\n      [else\n       (cons curr (helper (cdr arr)\
    \ (cons (ones-count (car arr)) next) (car arr)))]))\n  (helper arr '() '()))\n",
  "  (sort (lambda (x y)\n           (if (>= (length x) 0)\n             (if (>= (length\
    \ y) 0)\n                 (if (equal? (string-append (str \"0\" x) (string-append\
    \ (str \"0\" y))))\n                     (- (string-length x) (- (string-length\
    \ y)))\n                   (equal? (string-append (str \"1\" x) (string-append\
    \ (str \"1\" y))))\n                     (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"10\" x) (string-append\
    \ (str \"10\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"11\" x) (string-append\
    \ (str \"11\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"100\" x) (string-append\
    \ (str \"100\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"101\" x) (string-append\
    \ (str \"101\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"110\" x) (string-append\
    \ (str \"110\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"111\" x) (string-append\
    \ (str \"111\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1000\" x) (string-append\
    \ (str \"1000\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1001\" x) (string-append\
    \ (str \"1001\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1010\" x) (string-append\
    \ (str \"1010\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1011\" x) (string-append\
    \ (str \"1011\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1100\" x) (string-append\
    \ (str \"1100\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1101\" x) (string-append\
    \ (str \"1101\" y))))\n                   (- (string-length x) (+ (string-length\
    \ y)))\n                 (equal? (string-append (str \"1110\" x) (string-append\
    \ (str \"1110\" y))))\n                   (- (string-length x) (+ (", "  (let\
    \ ([num-ones (count-ones (array-get arr 0))]\n        [decimal-part (expt (- (array-get\
    \ arr 0) (array-get arr 1)) 2)])\n    (cond\n      [(= num-ones 1)\n       (array-get\
    \ arr 0)]\n      [(= num-ones 2)\n       (array-get arr 0)\n       (expt (array-get\
    \ arr 1) (array-get arr 0))]\n      [(= num-ones 3)\n       (array-get arr 0)\n\
    \       (expt (array-get arr 1) (array-get arr 0))\n       (expt (array-get arr\
    \ 1) (array-get arr 0))]\n      [(= num-ones 4)\n       (array-get arr 0)\n  \
    \     (expt (array-get arr 1) (array-get arr 0))\n       (expt (array-get arr\
    \ 1) (array-get arr 0))\n       (expt (array-get arr 1) (array-get arr 0))]\n\
    \      [(= num-ones 5)\n       (array-get arr 0)\n       (expt (array-get arr\
    \ 1) (array-get arr 0))\n       (expt (array-get arr 1) (array-get arr 0))\n \
    \      (expt (array-get arr 1) (array-get arr 0))\n       (expt (array-get arr\
    \ 1) (array-get arr 0))]\n      [(= num-ones 6)\n       (array-get arr 0)\n  \
    \     (expt (array-get arr 1) (array-get arr 0))\n       (expt (array-get arr\
    \ 1) (array-get arr 0))\n       (expt (array-get arr 1) (array-get arr 0))\n \
    \      (expt (array-get arr 1) (array-get arr 0))\n       (expt (array-get arr\
    \ 1) (array-get arr 0))]\n      [else\n       (let ([sorted-arr (array-copy arr)])\n\
    \         (define (sort-subarray subarray)\n           (cond\n             [(=\
    \ (array-get subarray 0) 0)\n               (sort (subarray) (- num-ones 1))]\n\
    \             [(= (array-get subarray 0) 1)\n               (sort-subarray (subarray))]\n\
    \             [(= (array-get subarray 0) 2)\n               (sort", "  (let loop\
    \ ((arr-head (first arr))\n             (arr-tail (rest arr)))\n    (if (or (null?\
    \ arr-tail)\n            (null? (first arr-tail)))\n        arr-head\n       \
    \ (let ((ones (length (bitwise-and arr-head arr-tail))))\n          (if (> ones\
    \ 0)\n              (loop (first arr-tail)\n                    (append (sort\
    \ (second arr-tail) <) arr-tail))\n              (loop (first arr-tail) arr-tail))))))\n",
  "  (sort (lambda (x y)\n          (< (count-ones (binary-string x)) (count-ones\
    \ (binary-string y)))\n          (< (count x) (count y)))\n         arr\n    \
    \     <))", "  (cond [(= (length arr) 0)\n         (reverse arr)]\n        [else\n\
    \         (let ([big (first arr)])\n           (if (> (* big 2) 1)\n         \
    \      (cons (first arr)\n                     (sort_array (cons (rest arr) big)))\n\
    \               (cons (first arr)\n                     (sort_array (cons (rest\
    \ arr) (- big 2))))))]))\n", "  (if (null? arr)\n      '()\n      (let ([i (first\
    \ arr)])\n        (let ([j (rest arr)])\n          (if (< i j)\n             \
    \ (let ([left (subseq arr 0 i)])\n                (let ([right (subseq arr (+\
    \ i 1) (+ j 1))])\n                  (cond [(= (length left) 0) (cons left '())]\n\
    \                        (else (cons (reverse left) (sort_array right))))))\n\
    \              (cons i '())))))))\n", "  (if (empty? arr)\n      '()\n      (append\
    \ (sort (first arr) 'descending-comparator)\n              (sort_array (rest arr)))))\n",
  "  (let* ((base (list 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1\
    \ 0 1 0 1 0))\n         (len (length arr))\n         (cnt (lambda (i)\n      \
    \          (cond\n                  [(= i 0) 0]\n                  [(= i 1) 1]\n\
    \                  [else (+ (cnt (- i 1)) (base (floor (/ i 2)))]))]))\n     \
    \    (rev (lambda (i)\n                (if (= i 0)\n                    0\n  \
    \                  (let ((c (cnt i)))\n                      (+ (* c rev i) (rev\
    \ (- c i)))))))\n    (if (= len 0)\n        arr\n        (sort-helper\n      \
    \   arr\n         len cnt (rev 0))))\n", "  (if (null? arr)\n      null\n    \
    \  (cond\n        ((= (length arr) 2)\n         (cond\n           ((= (first arr)\
    \ 1)\n            (cond\n              ((= (second arr) 1)\n               (reverse\
    \ (sort arr)))\n              ((= (second arr) 0)\n               (sort arr)))))\n\
    \        ((= (length arr) 4)\n         (cond\n           ((= (first arr) 0)\n\
    \            (cond\n              ((= (second arr) 0)\n               (reverse\
    \ (sort arr)))\n              ((= (second arr) 1)\n               (cond\n    \
    \             ((= (third arr) 1)\n                  (cond\n                  \
    \  ((= (fourth arr) 1)\n                     (reverse (sort arr)))\n         \
    \           ((= (fourth arr) 0)\n                     (sort arr)))\n         \
    \         ((= (fourth arr) 2)\n                   (cond\n                    \
    \ ((= (fifth arr) 1)\n                      (cond\n                        ((=\
    \ (sixth arr) 1)\n                         (reverse (sort arr)))\n           \
    \             ((= (sixth arr) 0)\n                         (sort arr)))\n    \
    \                 ((= (sixth arr) 2)\n                       (cond\n         \
    \               ((= (seventh arr) 1)\n                         (cond\n       \
    \                   ((= (eigth arr) 1)\n                           (reverse (sort\
    \ arr)))\n                          ((= (eigth arr) 0)\n                     \
    \      (sort arr)))\n                        ((= (eigth arr) 2)\n            \
    \             (cond\n                          ((= (ninth arr) 1)\n          \
    \                 (cond\n                            ((= (tenth arr) 1)\n    \
    \                         (reverse (sort arr)))\n                            ((=\
    \ (tenth arr) 0)\n                             (sort arr)))\n                \
    \          ((= (tenth arr) 2)\n                           (cond\n            \
    \                ((= (eleventh arr) 1)\n                             (cond\n \
    \                              ((= (twelfth arr) 1)\n                        \
    \        (cond\n                                  ((= (thirteenth arr) 1)\n  \
    \                                 (reverse (sort arr)))\n                    \
    \              ((= (thirteenth arr) 0)\n                                   (sort\
    \ arr)))\n                               ((= (thirteenth arr) 2)\n           \
    \                     (cond\n                                  ((= (fourteenth\
    \ arr) 1)\n                                   (cond\n                        \
    \            ((= (fifteenth arr) 1)\n                                     (reverse\
    \ (sort arr)))\n                                    ((= (fifteenth arr) 0)\n \
    \                                    (sort arr)))\n                          \
    \        ((= (fifteenth arr", "  (let loop ((i 0) (acc '()))\n    (cond ((< i\
    \ arr) (sort (loop (+ i 1) (cons (car arr) (append acc (length acc))))))\n   \
    \       ((= 0 (length acc)) (cons (car arr) (sort (loop (+ i 1) '()))))\n    \
    \      (else (cons (car acc) (loop (+ i 1) (cdr acc)))))\n    ))\n", "  (if (null?\
    \ arr) null\n    (let ([arr (cdr arr)])\n      (if (zero? arr) arr\n        (let\
    \ ([counts (count-ones arr)]\n              [dec (- 0 1)]\n              [decs\
    \ (list (car arr)])\n              [decs (cons (car arr) decs)]\n            \
    \  [decs (append decs (cons (- (car decs)) counts)])])\n          (if (null? decs)\n\
    \              (sort_array arr)\n              (if (< (car decs) (car counts))\n\
    \                  (sort_array decs)\n                  (append decs (sort_array\
    \ decs))))))))\n", "  (let ([count (length arr)]\n        [counts (make-array\
    \ (+ (* count 2) 1) 2)]\n        [binary (make-array (+ (* count 2) 1) 'unsigned-byte)]\n\
    \        [decimal (make-array (* count 1) 'unsigned-byte)])\n    (assert (<= 0\
    \ count 10))\n    (for ([i (in-range count)]\n          [value (in-range (* count\
    \ 2))])\n      (setf (elt binary value) (bitwise-and (elt arr i) 1))\n      (setf\
    \ (elt decimal value) (elt arr i))\n      (setf (elt counts value) (incf (elt\
    \ counts value))))))\n", "  (let ([arr (sort-array-helper arr)])\n    (sort-array-helper-result\
    \ arr)))\n", "  (cond\n    [(empty? arr) (empty? (list arr))]\n    [else (cons\
    \ (first arr) (sort_array (rest arr)))]))\n", "  (sort (\u03BB (x y)\n       \
    \   (if (eq? x y)\n              x\n              (if (= (one? x) y)\n       \
    \           (/ x 10)\n                  (/ y 10)))\n          arr)))\n", "  (cond\n\
    \    [(null? arr) (list)]\n    [(<= 0 1 (car arr)) (sort (sort_array (cdr arr)))]\n\
    \    [else (cons (car arr)\n              (sort_array (cdr arr)))]))\n", "  (sort\
    \ arr (lambda (x) (length x))))\n", "  (if (< (length arr) 2)\n      (let ([ones\
    \ (subseq arr 0 2)])\n        (sort_array (append ones (sort (list 1) <))))\n\
    \      (let ([dec (quotient (car arr) 10)])\n        (sort_array (append (list\
    \ (- dec 10)) (sort (list dec) <))))\n      (sort arr <)))\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=scheme |>\nHere's one more solution in Racket, just for the fun\
    \ of it. This solution assumes that the input array has already been sorted in\
    \ ascending order. Also, the code will crash if you give it an empty array.\n\
    <code>", "  (let ([m (count-ones arr)])\n    (if m\n        (let ([i (floor m)]\n\
    \              [count (- m i)])\n          (cons (cons i (car arr) count) (cdr\
    \ arr)))\n      arr)))\n", "  (sort (lambda (x y) (> (count-ones (binary-ones-rev\
    \ x) (rev (binary-ones-rev y)))\n                      (> (count-ones (binary-ones-rev\
    \ y) (rev (binary-ones-rev x)))\n                      (> (number-value x) \n\
    \                          (number-value y))\n                      (> (number-value\
    \ y) \n                          (number-value x)))\n         arr))\n)\n", " \
    \ (sort arr (lambda (x y)\n             (cond\n              [(= (length x) (length\
    \ y)) (list x)]\n              [(= x y) (list y)]\n              [(= (count y\
    \ \"1\") (count x \"0\")) (list (reverse x))]\n              [else (cond\n   \
    \                   [(< y (* x y)) (list (reverse x))]\n                     \
    \ [(> y (* x y)) (list (reverse y))]\n                      [else (cons (list\
    \ x) (list (reverse y)))]\n                      )]\n              )))\n  (filter\
    \ even? arr))\n", "  (define (count-ones! x)\n    (if (= x 0)\n        0\n   \
    \     (+ 1 count-ones! (logand (bitwise-and x 1)(bitwise-and x (- 1 x))))))\n\
    \  (define (count-zeros! x)\n    (if (= x 0)\n        0\n        (+ 1 count-zeros!\
    \ (logand (bitwise-and x (- 1 x))(bitwise-and x 1)))))\n  (define (count-twos!\
    \ x)\n    (if (= x 0)\n        0\n        (+ 1 count-twos! (logand (bitwise-and\
    \ x (- 1 x))(bitwise-and x 2)))))\n  (define (count-threes! x)\n    (if (= x 0)\n\
    \        0\n        (+ 1 count-threes! (logand (bitwise-and x (- 1 x))(bitwise-and\
    \ x 3)))))\n  (define (count-fours! x)\n    (if (= x 0)\n        0\n        (+\
    \ 1 count-fours! (logand (bitwise-and x (- 1 x))(bitwise-and x 4)))))\n  (define\
    \ (count-fives! x)\n    (if (= x 0)\n        0\n        (+ 1 count-fives! (logand\
    \ (bitwise-and x (- 1 x))(bitwise-and x 5)))))\n  (define (count-sixes! x)\n \
    \   (if (= x 0)\n        0\n        (+ 1 count-sixes! (logand (bitwise-and x (-\
    \ 1 x))(bitwise-and x 6)))))\n  (define (count-sevens! x)\n    (if (= x 0)\n \
    \       0\n        (+ 1 count-sevens! (logand (bitwise-and x (- 1 x))(bitwise-and\
    \ x 7)))))\n  (define (count-eights! x)\n    (if (= x 0)\n        0\n        (+\
    \ 1 count-eights! (logand (bitwise-and x (- 1 x))(bitwise-and x 8)))))\n  (define\
    \ (count-tens! x)\n    (if (= x 0)\n        0\n        (+ 1 count-tens! (logand\
    \ (bitwise-and x (- 1 x))(bitwise-and x 10)))))\n  (define (count-elevens! x)\n\
    \    (if (= x 0)\n        0\n        (+ 1 count-elevens! (logand (bitwise-and\
    \ x (", "  (cond\n    [(empty? arr) '()]\n    [(= (length arr) 1) (list arr)]\n\
    \    [else\n     (append (cons (first arr) '())\n             (sort_array (rest\
    \ arr)))]))\n", "  (cond [(empty? arr) empty]\n        [(= (length arr) 1) arr]\n\
    \        [else (sort_array (sub (arr 0) 1))\n               (cons (min (count\
    \ 1 (bitvector arr 0))\n                      (count 1 (bitvector arr (- 1 ))))\n\
    \                     (sort_array (sub (arr (- 1 )) 1))]))\n</code>\nYou can compare\
    \ your implementation with mine here: https://racket-lang.org/snippets/view.html?id=LnqNKc\n\
    <|/ a dscore=0 |>\n<| c |>\nPlease explain what your code does and why you think\
    \ it's superior to others.\n<|/ c |>\n<| a dscore=0 tags=scheme |>\n<code>\n#lang\
    \ racket", "  (cond\n    [(empty? arr) (list arr)]\n    [(= 1 (length (filter\
    \ (complement even?) arr)))\n     (sort (filter (complement even?) arr) <)]\n\
    \    [else (sort arr (lambda (a b) (< (length (filter (complement even?) a)) (length\
    \ (filter (complement even?) b))))))))\n</code>\n<|/ a dscore=0 tags=racket,sorting,scheme\
    \ |>\n<| a |>\nMy solution: \n<code>", "  (sort (lambda (x) (count_ones x))\n\
    \        arr))\n", "  (if (null? arr)\n      '()\n      (if (number? (car arr))\n\
    \          (cons (car arr)\n                (sort_array (cdr arr)))\n        \
    \  (if (> (count-ones (car arr)) 0)\n              (cons (car arr)\n         \
    \           (sort_array (cdr arr)))\n              (sort_array (cdr arr))))))\n",
  "  (let loop ((acc '()) (arr '()))\n    (cond\n      [(null? arr) acc]\n      [(not\
    \ (pair? arr)) (sort-ints-ascending acc arr)]\n      [(number? arr) (sort acc\
    \ arr)]\n      [else (loop (cons acc arr) (rest arr))])))\n", "  (let loop ((start\
    \ (length arr))\n             (end (length arr))\n             (count (- end start))\n\
    \             (arr (in-range (- end start) end))\n             (acc '()))\n  \
    \  (if (<= count 0)\n        acc\n        (loop (+ start 1) (+ end 1) (- count\
    \ 1) (cons arr (loop (+ start 1) (+ end 1) (- count 1) acc))\n               (if\
    \ (= end start) acc))))))\n", "  (let loop ((start (min arr))\n             (end\
    \ (min (apply + (map (lambda (x) (1- x)) arr))))\n             (acc '()))\n  \
    \  (if (<= end start)\n        acc\n        (loop (+ start 1) end (cons start\
    \ acc)))))\n", "  (define (helper arr index acc cur)\n    (cond\n      [(empty?\
    \ arr) acc]\n      [(eq? cur 0) (helper arr (sub1 index) (rest acc) (rest cur))]\n\
    \      [(> cur 0) (helper (rest arr) (sub1 index) (rest acc) (append cur (rest\
    \ cur)))]\n      [(< cur 0) (helper (rest arr) (add1 index) (rest acc) (append\
    \ cur (rest cur)))]\n      [(= cur 0) (helper (rest arr) (add1 index) (rest acc)\
    \ (rest cur))]\n      [(> cur 1) (helper (rest arr) (add1 index) (rest acc) (append\
    \ cur (rest cur)))]\n      [(< cur 1) (helper (rest arr) (sub1 index) (rest acc)\
    \ (append cur (rest cur)))]\n      [(= cur 1) (helper (rest arr) (sub1 index)\
    \ (rest acc) (rest cur))]\n      [else (helper (rest arr) (add1 index) (rest acc)\
    \ (append cur (rest cur)))]))\n  (helper arr 0 '() (first arr)))\n", "  (if (null?\
    \ arr) arr\n      (let ([zeros 0] (car arr))\n        (let ([ones 1])\n      \
    \    (if (> (length arr) ones) (sort_array (drop-array arr ones))\n          \
    \    (sort_array (drop-array arr (- ones ones)))\n              (list (cond ((=\
    \ zeros (length arr)) arr)\n                         ((= (length arr) (+ ones\
    \ zeros)) (reverse (cons zeros arr))\n                         ((= (length arr)\
    \ ones) (reverse (cons zeros (reverse arr))))\n                         (else\
    \ (cons zeros (sort_array (drop-array arr ones)))))))))))\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=algorithm,arrays,scheme,binary-search |>\nI didn't do Scheme,\
    \ so my code might not be 100% correct.  But it gives the idea of how to approach\
    \ this problem from a general algorithm perspective.  \nYou have a set of sorted\
    \ numbers, each number has two possible representations, 0 and 1.  You want to\
    \ know whether there's a set S of numbers that has at least twice the number of\
    \ 1s than S is compared to the largest number in S.  \nThe idea would be to sort\
    \ S, count the number of 1s in each position, compare it to the number of ones\
    \ in the largest number, and keep searching until you found the smallest one larger\
    \ than it.\nIt should go as follows:\n\nTake the first number in S, and compare\
    \ it to the largest number in S.  \nIf it's larger than the largest number, skip\
    \ to the next number.  \nIf it's smaller than the largest number, repeat step\
    \ 2.\nOtherwise, if the number of 1s is the same as the number of ones in the\
    \ largest number, move on to step 3.\nOtherwise, if the number of 1s is more than\
    \ the number of ones in the largest number, move on to step 4.\nOtherwise, the\
    \ number of 1s is not equal to the number of ones in the largest number, so you\
    \ can safely compare the number in S to the number that's equal to the number\
    \ of 1s in the largest number.  \n\nThat last step should be easy, since the number\
    \ of 1s in the largest number is the number of ones in the largest number.  \n\
    The rest should be fairly easy, too.  If the number of 1s is more than the number\
    \ of ones in the largest number, you know that S has no two numbers with twice\
    \ the number of ones.  If it's equal to the number of ones in the largest number,\
    \ you know that S has at least twice the number of 1s than S is compared to the\
    \ largest number in S.  \nIf that's all you need, you should be able to write\
    \ this in any language.  Good luck!\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis\
    \ can be solved by binary search tree (", "  (let loop ((len (length arr))\n \
    \            (arr '()))\n    (if (< len 0)\n        arr\n        (loop (sub1 len)\n\
    \              (cons (if (zero? (bitwise-and (first arr) 1)) (rest arr) (cons\
    \ (first arr) (loop (rest len) (cons (rest arr) (first arr)))))\n            \
    \      (loop (sub1 len) (cons (second arr) (loop (rest len) (cons (third arr)\
    \ (second arr))))\n                  (loop (sub1 len) (cons (third arr) (loop\
    \ (rest len) (cons (fourth arr) (third arr))))\n                  (loop (sub1\
    \ len) (cons (fourth arr) (loop (rest len) (cons (fifth arr) (fourth arr))))\n\
    \                  (loop (sub1 len) (cons (fifth arr) (loop (rest len) (cons (sixth\
    \ arr) (fifth arr))))\n                  (loop (sub1 len) (cons (sixth arr) (loop\
    \ (rest len) (cons (seventh arr) (sixth arr))))\n                  (loop (sub1\
    \ len) (cons (seventh arr) (loop (rest len) (cons (eighth arr) (seventh arr))))\n\
    \                  (loop (sub1 len) (cons (eighth arr) (loop (rest len) (cons\
    \ (ninth arr) (eighth arr))))\n                  (loop (sub1 len) (cons (ninth\
    \ arr) (loop (rest len) (cons (tenth arr) (ninth arr))))\n                  (loop\
    \ (sub1 len) (cons (tenth arr) (loop (rest len) (cons (eleven arr) (tenth arr))))\n\
    \                  (loop (sub1 len) (cons (eleven arr) (loop (rest len) (cons\
    \ (twelve arr) (eleven arr))))\n                  (loop (sub1 len) (cons (twelve\
    \ arr) (loop (rest len) (cons (thirteen arr) (twelve arr))))\n               \
    \   (loop (sub1 len) (cons (thirteen arr) (loop (rest len) (cons (fourteen arr)\
    \ (thirteen arr))))\n                  (loop (sub1 len) (cons (fourteen arr) (loop\
    \ (rest len) (cons (fifteen arr) (fourteen arr))))\n                  (loop (sub1\
    \ len) (cons (fifteen arr) (loop (rest len) (cons (sixteen arr) (fifteen arr))))\n\
    \                  (loop (", "  (if (null? arr)\n      (list)\n      (cons (sort\
    \ (map (lambda (x) (count (list-ref x 0)) arr))\n               (lambda (x) (-\
    \ x 1)))\n            (sort_array (remove (lambda (x) (count (list-ref x 0)) arr)\n\
    \                            arr))))\n", "  (define (helper-function arr i j k)\n\
    \    (cond [(< i j) (helper-function arr (+ i 1) (+ k 1) k)]\n          [(or (=\
    \ (modulo i 2) (modulo k 2)) (= (modulo j 2) (modulo k 2))) (cond [(> i j) (helper-function\
    \ arr (+ i 1) (+ j 1) k)]\n                                                  \
    \                                            [(and (= (modulo i 2) (modulo j 2))\
    \ (= (modulo k 2) (modulo j 2))) (cond [(> i j) (helper-function arr (+ i 1) (+\
    \ k 1) j)]\n                                                                 \
    \                                                   [(< i j) (helper-function\
    \ arr (+ i 1) (+ j 1) k)]\n                                                  \
    \                                                                            \
    \                    [(and (= (modulo i 2) (modulo k 2)) (= (modulo j 2) (modulo\
    \ k 2))) (helper-function arr (+ i 1) (+ j 1) k)]\n                          \
    \                                                                            \
    \                                                                            \
    \                                [else (helper-function arr (+ i 1) (+ j 1) k)]))]\n\
    \          [else (cond [(> i j) (helper-function arr (+ i 1) (+ k 1) j)]\n   \
    \                      [(< i j) (helper-function arr (+ i 1) (+ j 1) k)]\n   \
    \                      [else (helper-function arr (+ i 1) (+ j 1) k)]]))\n  (helper\
    \ arr (length arr) 0 0))\n", "  (let loop ()\n    (if (empty? arr)\n        (reverse\
    \ (list nil))\n        (let ([elt (first arr)])\n          (let ([count (count\
    \ elt)])\n            (if (zero? count)\n                (loop (cons elt (reverse\
    \ (reverse (list elt)))) (rest arr))\n                (loop (cons elt (reverse\
    \ (list (- count 1)))) (rest arr)))))))\n</code>\n<|/ a |>\n<| c |>\nThis was\
    \ a nice challenge. Thanks for the solution, though. I'll definitely take another\
    \ look at this when I get more time to play around with it.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (define (sort-helper arr i count)\n    (if (= count 0)\n   \
    \     arr\n        (sort-helper\n         (sub1 arr)\n         (add1 i)\n    \
    \     (sub1 count))\n      )\n    )\n  (sort (sort-helper arr 0 0) <)\n  )", " \
    \ (sort (lambda (x y)\n          (< (expt x 2) (expt y 2))\n          (< (dec\
    \ (binary->decimal x)) (dec (binary->decimal y)))\n          (< x y)\n       \
    \   )\n          (range (length arr))\n          :key '<\n          :reverse #f\n\
    \          ))\n", "  (cond\n    [(empty? arr) empty]\n    [(equal? (car arr) empty)\
    \ arr]\n    [else (sort_array_aux (cdr arr) (append (car arr) empty))]\n  )\n)",
  "  (let loop ((len (length arr))\n             (i 0))\n    (cond ((= len 1)\n  \
    \         (if (> 0 i)\n               (list i)\n               arr))\n       \
    \   ((= 0 (rem len 2)) ; odd length\n           (loop (sub1 len)\n           \
    \       (+ i 1)))\n          ((= 0 (rem len 3)) ; even length\n           (loop\
    \ (sub1 len)\n                  (+ i (* 2 len))))\n          (else ; odd length\n\
    \           (loop (sub1 len)\n                  (+ i (* 3 len)))))))\n</code>\n\
    <|/ a tags=racket,scheme |>\n<| c |>\nThanks for the solution but I already have\
    \ one :)\n<|/ c |>\n<| a tags=racket,scheme dscore=0 |>\nHere's the solution:\n\
    <code>\n#lang racket\n", "  (define (helper n i)\n    (cond ((null? arr) '())\n\
    \          ((= (modulo n 2) 0) (cons n (helper n i)))\n          (else (helper\
    \ (sub1 n) i))))\n  (helper 0 0))", "  (cond\n    [(null? arr) arr]\n    [(> (length\
    \ arr) 1) (list arr)]\n    [(= 1 (count (first arr)) 0) (list arr)]\n    [else\
    \ (cons (sort (first arr)) (sort_array (rest arr))) ]))\n", "  (sort (\u03BB (x)\
    \ (bitwise-count x (array arr)))\n        >))\n", "  (cond [(null? arr) (list\
    \ null)]\n        [(= (remainder arr 2) 0) (cons arr (sort_array (remainder arr\
    \ 2)))]\n        [else (cons\n                 (quotient arr 2)\n            \
    \     (sort_array (remainder arr 2)))]))", "  (define (compare-int-binary a\n\
    \                        b\n                        cmp-bool)\n    (cond [(< a\
    \ 0) (< b 0)]\n          [(< (expt a 2) b) (< 0 1)]\n          [(< b 0)\n    \
    \       (or (< a 0) (< b (- a 1)))]\n          [(> a 0)\n           (or (< a (-\
    \ b 1)) \n               (< b (- a 1)))]\n          [else\n           (or (< a\
    \ (- b 1))\n               (< b (- a 1))) cmp-bool]))\n\n  (define (compare-int-decimal\
    \ a\n                           b\n                           cmp-bool)\n    (cond\
    \ [(< a 0) (< b 0)]\n          [(< b 0)\n           (or (< a 0) (< b (- a 1)))]\n\
    \          [(< a 0)\n           (or (< b (- a 1)) \n                (< a (- b\
    \ 1)))]\n          [else\n           (or (< a (- b 1))\n               (< b (-\
    \ a 1))) cmp-bool]))\n\n  (define (sort-bool-ascending a\n                   \
    \     b\n                        cmp-bool)\n    (cond [(< a 0) (< b 0)]\n    \
    \      [(< b 0)\n           (or (< a 0) (< b (- a 1)))]\n          [else\n   \
    \        (< (compare-int-binary a (expt b 2) cmp-bool)\n               (compare-int-binary\
    \ a b cmp-bool)) cmp-bool]))\n\n  (define (sort-bool-descending a\n          \
    \              b\n                        cmp-bool)\n    (cond [(< a 0) (< b 0)]\n\
    \          [(< b 0)\n           (or (< a 0) (< b (- a 1)))]\n          [else\n\
    \           (< (compare-int-binary a (- (expt b 2)) cmp-bool)\n              \
    \ (compare-int-binary a b cmp-bool)) cmp-bool]))\n\n  (cond [(< arr 0)\n     \
    \    arr]\n        [else\n         (append \n             (sort-bool-ascending\
    \ arr (expt arr 2) cmp-bool)\n             (sort-bool-descending arr (- arr 2)\
    \ cmp-bool))]))\n", "  (sort (\u03BB (a b) (cond\n                    (equal?\
    \ (remainder a 2) 1) (cond\n                                                 \
    \   (equal? (remainder b 1) 0)\n                                             \
    \       (equal? (remainder b 0) 1)\n                                         \
    \           (equal? (remainder b 1) 0)\n                                     \
    \               (equal? (remainder b 0) 1)\n                                 \
    \                   (equal? (remainder b 1) 0)\n                             \
    \                       (equal? (remainder b 0) 1)\n                         \
    \                           (equal? (remainder b 1) 0)\n                     \
    \                               (equal? (remainder b 0) 1)\n                 \
    \                                   (equal? (remainder b 1) 0)\n             \
    \                                       (equal? (remainder b 0) 1)\n         \
    \                                           (equal? (remainder b 1) 0)\n     \
    \                                               (equal? (remainder b 0) 1)\n \
    \                                                   (equal? (remainder b 1) 0)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n\
    \                                                    (equal? (remainder b 0) 1)\n",
  "  (sort_array-impl arr ()))\n", "  (if (null? arr)\n      '()\n      (append (sort\
    \ (count (count-ones arr))))\n      ;; If you are not familiar with append and\
    \ sort functions,\n      ;; here is the explanation:\n      ;; append will append\
    \ the second list to the first list.\n      ;; Then it will sort it.\n      ;;\
    \ Thus, the result will be an array where each element is the\n      ;; sorted\
    \ list from the input list.\n      (append (sort (count-ones arr))\n         \
    \      (sort (sort (count-ones arr))))))\n", "  (cond [(= (length arr) 0)\n  \
    \       '()]\n        [(number? (car arr))\n         (list arr)]\n        [(=\
    \ (car arr) 0)\n         (reverse (sort_array (cdr arr)))]\n        [else\n  \
    \       (cons (car arr) (sort_array (cdr arr)))]))\n", "  (if (null? arr) (list\
    \ null) (cons (sort (number-to-binary (car arr))) (sort_array (rest arr)))))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(cons? arr) (sort_array (car arr))]\n \
    \   [else (cons (if (= (remainder (car arr) 2) 1)\n                   (+ (remainder\
    \ (car arr) 2)\n                      (list (- (remainder (car arr) 2) 1)))\n\
    \                   (+ (car arr)\n                      (list (- (car arr) 2)\
    \ 1)))\n            (sort_array (rest arr))]))\n", "  (sort (lambda (x y) (or\
    \ (> 0 x) (< 0 y)) (dec (bcdr x))\n                     (bcdr y)) arr))\n", " \
    \ (define (helper lst index)\n    (cond [(null? lst)\n           (reverse lst)]\n\
    \          [(= (modulo index 2) 0)\n           (helper (cdr lst) index)]\n   \
    \       [(= (modulo index 2) 1)\n           (helper (append (append (cons index\
    \ (car lst)) (list index)) (cdr lst)) (+ index 1))]\n          [else\n       \
    \    (helper (append (list index) (cons index (car lst))) (cdr lst))]))\n  (helper\
    \ arr 0))\n", "  (cond [(= (length arr) 0)\n         arr]\n        [(= (first\
    \ arr) 0)\n         (sort_array (subseq arr (quotient (length arr) 2)))]\n   \
    \     [else\n         (let ((i 0)\n                (m 0))\n           (loop\n\
    \                (when (= i n)\n                  (let ((b (first arr)))\n   \
    \                 (set! m (quotient (length arr) 2))\n                    (let\
    \ ((n (- b (first arr))))\n                      (set! i (+ i (+ i m)))))\n  \
    \                (cond [(> i (length arr))\n                         arr]\n  \
    \                      [else\n                         (set! i (+ i (+ i (quotient\
    \ (length arr) 2))))\n                         (let ((n (- (first arr) b)))\n\
    \                           (set! m (quotient (length arr) 2))\n             \
    \              (set! i (+ i (+ i (+ i m)))))))]\n           (set! i (+ i (+ i\
    \ (quotient (length arr) 2))))\n           (loop\n                (when (= i n)\n\
    \                  (let ((b (first arr)))\n                    (set! m (quotient\
    \ (length arr) 2))\n                    (let ((n (- b (first arr))))\n       \
    \               (set! i (+ i (+ i (+ i m))))))\n                  (cond [(> i\
    \ (length arr))\n                         arr]\n                        [else\n\
    \                         (set! i (+ i (+ i (+ i (quotient (length arr) 2))))\n\
    \                         (let ((n (- (first arr) b)))\n                     \
    \      (set! m (quotient (length arr) 2))\n                           (set! i\
    \ (+ i (+ i (+ i m))))))]))]))\n", "  (sort (lambda (x) (dec->bin x)) arr))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme |>\nHere is how\
    \ I implemented it :\n<code>", "  (let ([zeros 0])\n    (let loop ((arr (sort\
    \ arr))\n              (len (length arr))\n              (current 0))\n      (if\
    \ (>= len 0)\n          (cons (first arr)\n                (loop (rest arr)\n\
    \                       (sub1 (+ current len))\n                       (+ current\
    \ len)))\n          zeros))))\n", "  (let loop ((x 0) (y 0) (arr arr) (arr-length\
    \ 0))\n    (cond ((null? arr) (cons arr (reverse (cons (car arr) '())))\n    \
    \       (else (cons (car arr) (loop (+ x 1) (+ y 1) (cdr arr) (+ arr-length 1)))))\n\
    \          ((= y 0) (cons (car arr) '()))\n          (else (loop (+ x 1) (- x\
    \ 1) (cdr arr) arr-length)))))\n", "  (sort arr comp\n        ;; If n1 is 0 and\
    \ n2 is 1, compare them by decimal,\n        ;; Otherwise, compare them by their\
    \ binary representation.\n        (lambda (n1 n2)\n          (if (= (length n1)\
    \ 0)\n              (= (length n2) 0)\n              (let ([n11 (reverse n1)]\n\
    \                    [n21 (reverse n2)])\n                (cond\n            \
    \      [(= (reverse (sub1 (string-append \"1\" n11))) (reverse (sub1 (string-append\
    \ \"1\" n21)))]\n                  [(= (sub1 (string-append \"0\" n11)) (sub1\
    \ (string-append \"0\" n21))]\n                  [(> (sub1 (string-append \"0\"\
    \ n11)) (sub1 (string-append \"0\" n21))) 0]\n                  [(< (sub1 (string-append\
    \ \"1\" n11)) (sub1 (string-append \"1\" n21))) 0]\n                  [else (sub1\
    \ (string-append \"0\" n11)) (sub1 (string-append \"0\" n21))])))))\n        ;;\
    \ Sort in descending order.\n        #'descend))\n", "  (sort (lambda (x) (count-ones\
    \ (binary-representation of x)) x) (arr arr)))\n</code>\n<code>", "  (let* ((count\
    \ (apply + (map #(if (= 1 (cadr %)) 1 (cdr %)) arr)))\n         (dec (sort (cons\
    \ 0 count) <)))\n    (map (lambda (x) (cond ((< x dec) (dec (cdr dec)))\n    \
    \                         ((= x dec) (cons (car dec) dec))\n                 \
    \            (else (cons x (car dec)))) dec))))\n", "  (sort (lambda (x y)\n \
    \         (if (= (rem1 x 2) 1)\n              (dec1 y)\n              (if (= (rem1\
    \ x 2) 0)\n                  (dec1 x)\n                  (if (= (rem1 x 1) 0)\n\
    \                      (dec1 y)\n                      (dec1 x))))\n         \
    \ (map (lambda (x) (rem x 2)) (arr))\n          (map (lambda (x) (/ x 2)) (arr))))\n\
    </code>\nYou can use this as a starting point for your own and improve on it.\n\
    <|/ a tags=functional-programming,scheme,racket,sicp |>\n<| a |>\nHere's a solution\
    \ that uses higher-order functions to do the work:\n<code>", "  (let ((count (length\
    \ arr)))\n    (define (helper lst count acc)\n      (cond\n        ((= count 0)\n\
    \         acc)\n        ((null? (rest lst))\n         (helper lst (- count 1)\
    \ acc))\n        (else\n         (helper (rest lst) (add1 count) (if (> 1 (car\
    \ lst))\n                                       acc\n                        \
    \               (cons (car lst) acc))))))\n    (helper arr count (list)))\n",
  "  (sort arr (lambda (a b)\n             (cond\n              [(= (regexp-match\
    \ \"1?\" a) (regexp-match \"1?\" b)) (- a b)]\n              [(= (regexp-match\
    \ \"0?\" a) (regexp-match \"0?\" b)) (+ a b)]\n              [(= (regexp-match\
    \ \"1\" a) (regexp-match \"1\" b)) (+ a b)]\n              [else (- a b)]))))\n",
  "  (if (null? arr)\n      nil\n      (let ((count (zero? (bitwise-and arr 65536))))\n\
    \        (cond ((> count 0) (cons arr (sort_array (sub1 arr) (- count 1))))\n\
    \              ((> count 1) (cons 0 (sort_array (sub1 arr))))\n              (else\
    \ (cons arr nil)))))\n</code>\n<|/ a dscore=2 tags=algorithm,sorting,racket |>\n\
    <| c |>\nIf it helps, here's a [C version of this solution](http://codegolf.stackexchange.com/a/73531/5900).\n\
    <|/ c |>\n<| a dscore=2 tags=algorithm,sorting,racket |>\nHere is a racket implementation\
    \ that uses recursion:\n<code>\n#lang racket\n", "  (sort (lambda (x y)\n    \
    \       (if (= (length y) 0)\n               0\n               (+ 1 (* (sub1 (string-length\
    \ x))\n                       (char-bin (sub1 x 1)))\n                     (*\
    \ (sub1 (string-length y))\n                         (char-bin (sub1 y 1)))\n\
    \                       (char-bin (sub1 y 2))))))\n        arr))\n", "  (cond\n\
    \    [(null? arr) arr]\n    [(number? arr) (sort_array (map number? arr))]\n \
    \   [else (cons\n            (cond\n              [(= 1 (count (filter #(= (mod\
    \ % 2) 0) arr)) (sort_array (map number? arr))]\n              [(= 2 (count (filter\
    \ #(= (mod % 2) 0) arr)) (sort_array (map number? (reverse arr))))]\n        \
    \      [(= 3 (count (filter #(= (mod % 2) 0) arr)) (sort_array (reverse (map number?\
    \ (reverse arr))))]\n              [else (sort_array (map number? (reverse arr)))]))]\n\
    \  ))\n", "  (sort arr \n        (lambda (x) (cond\n                      [(=\
    \ (length x) 1)\n                       (sort (binary_count x))\n            \
    \           ]\n                      [(= (length x) 2)\n                     \
    \  (sort (count_digits x))\n                       ]\n                      [(=\
    \ (length x) 3)\n                       (sort (count_tens x))\n              \
    \         ]\n                      [(= (length x) 4)\n                       (sort\
    \ (count_ones x))\n                       ]\n                      [else (sort\
    \ (count_tens x))\n                       ])))\n)\n", "  (fold (lambda (x y)\n\
    \          (cond [(< x y) x]\n                [else y]))\n         0\n       \
    \  arr))", "  (sort arr \n\t[(lambda (x y)\n\t    (cond\n\t    [(= (length x)\
    \ 1)\n\t     x])\n\t    [(= (length x) 0)\n\t     y])\n\t (lambda (x) (* 2 (remainder\
    \ x 2))))]\n\t[> #:key (lambda (x) (/ (length x) 2))]))", "  (let loop ((arr (car\
    \ arr))\n             (acc (car arr)))\n    (if (null? arr)\n        acc\n   \
    \     (loop (cdr arr) (if (zero? (cdr arr)) (car arr) (cdr arr))))))\n", "  (define\
    \ (check index)\n    (define (helper arr index helper check)\n      (cond\n  \
    \      [(null? (rest arr)) (reverse helper)]\n        [else (let ([number (car\
    \ arr)]\n                  [sum (+ (car helper) (cdr helper))]\n             \
    \     [index (+ index 1)]\n                  [helper (append (helper (cdr arr)\
    \ index) [(list number)])]\n                  [check (if (< number 1) (cons (car\
    \ helper) (check)) (check))]\n                  [check-helper (check (cdr helper))])]\n\
    \        [else (helper arr (+ index 1) (append (helper (cdr arr) index) [(list\
    \ number)])\n                  (check-helper (check (cdr helper)))]))\n    ([(null?\
    \ (rest arr)) (list [])])\n    (helper (reverse arr) 1 '() check))\n  (apply sort\
    \ (check 0)))\n", "  (define (helper arr i j acc)\n    (cond\n      [(> i j) acc]\n\
    \      [(equal? (mem-ref arr i) 1) (helper (mem-set arr i (mem-ref arr 0))\n \
    \                                        (add1 i) (add1 j) acc)]\n      [else\
    \ (helper (mem-set arr i (mem-ref arr 0))\n                       (add1 i) j (append\
    \ acc (list i)))]))\n  (helper arr 0 0 (reverse (append arr '())))\n  )", "  (define\
    \ (helper index count result)\n    (cond\n      [(= count 0) result]\n      [(<=\
    \ (sub1 index) count) result]\n      [else (helper (sub1 index) (sub1 count) (conj\
    \ result (sub1 index)))]))\n  (helper 0 0\n          (if (= (length arr) 0)\n\
    \              (list 0)\n              (append (helper (sub1 arr) 0 (conj 0 0))\n\
    \                       (helper (sub1 arr) 1 (conj 0 0)))))\n  (helper (length\
    \ arr) 0\n          (if (= (length arr) 0)\n              (list 0)\n         \
    \     (append (helper (sub1 arr) 0 (conj 0 0))\n                       (helper\
    \ (sub1 arr) 1 (conj 0 0)))))\n  (helper (length arr) (length arr)\n         \
    \ (if (= (length arr) 0)\n              (list 0)\n              (append (helper\
    \ (sub1 arr) 0 (conj 0 0))\n                       (helper (sub1 arr) 1 (conj\
    \ 0 0)))))\n)\n</code>\n<|/ a tags=scheme |>\n<| a tags=scheme dscore=0 |>\nA\
    \ simple recursive function, which works on each element and appends it to the\
    \ return list :\n<code>", "  (cond\n    ((= (length arr) 0)\n     (sort arr '<))\n\
    \    ((= (length arr) 1)\n     (cons (first arr) (sort (rest arr) '<)))\n    ((=\
    \ (length arr) 2)\n     (cons (first arr) (sort (rest arr) '<))\n     (cons (second\
    \ arr) (sort (rest arr) '<)))\n    ((= (length arr) 3)\n     (cons (first arr)\
    \ (sort (rest arr) '<))\n     (cons (second arr) (sort (rest arr) '<))\n     (cons\
    \ (third arr) (sort (rest arr) '<)))))\n", "  (let helper ((arr (vector '() 0))\
    \ (res nil))\n    (cond\n      [(null? arr) (return-from helper (vector '() 0))]\n\
    \      [(= (rem-int (caar arr)) 1) (cons rem-int (helper (cdr arr) (rem* (+ (caar\
    \ arr) 1) (caar arr)))))]\n      [else (cons (+ (rem* (* (car arr) (+ 1 (* (rem\
    \ (caar arr) 1) (length arr))) 2))) \n                (helper (cdr arr) (cons\
    \ (+ (rem* (* (car arr) (+ 1 (* (rem (caar arr) 1) (length arr))) 2)) res)))])))\n\
    </code>\n<|/ a dscore=2 tags=scheme,racket,sorting |>\n<| a tags=scheme,racket,sorting\
    \ |>\nFor anyone who likes recursion and want to solve this with recursion:\n\
    <code>", "  (sort (\u03BB (x) (= (length x) (log (length x))))\n         #:key\
    \ (\u03BB (x) (dec (bin-to-dec x)))\n         #:order (\u03BB (x y) (dec (dec\
    \ (bin-to-dec x))) (dec (dec (bin-to-dec y))))\n         arr))\n", "  (let loop\
    \ ((arr (reverse arr)) (prev 0) (acc '()))\n    (if (null? arr)\n        acc\n\
    \        (loop (rest arr) (rest prev) (cons (first arr) acc)))))\n", "  (sort\
    \ (\u03BB (x y)\n           (if (= (regex-match-all (string-append \"1{\" x \"\
    }\") \"^1\" 0) 0)\n               y\n               (if (= (regex-match-all (string-append\
    \ \"1{\" x \"}\") \"^1\" 0) 0)\n                   (string-append x y)\n     \
    \              (string-append y x))))\n         arr))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(zero? n) arr]\n    [(equal? (first arr) 0) (sort_array (rest\
    \ arr))]\n    [else (cons (first arr) (sort_array (rest arr)))]))\n", "  (sort\
    \ (lambda (i) (let ([count (count-ones (bit-field i))])\n                    \
    \   (if (< count 0)\n                           (- count)\n                  \
    \         0))\n         arr))\n", "  (sort (lambda (x) (length x)) arr)\n  (sort\
    \ (lambda (x) (mem1 (reverse x) '1))\n         arr))\n", "  (define (helper arr\
    \ len)\n    (cond [(or (= len 0)\n              (null? (cdr arr)))\n         \
    \  (reverse (car arr))]\n          [else (helper (cdr arr)\n                 \
    \       (sub1 (car arr))\n                        (reverse (rest arr)))]))\n \
    \ (helper arr length (reverse arr)))\n", "  (define (count-ones num)\n    (define\
    \ (count-ones subNum)\n      (cond\n        ((= (mod num 2) 0)\n         (+ 1\
    \ (count-ones (quotient num 2)))\n         0))\n    (if (= num 0)\n        (1+\
    \ count-ones (quotient num 2))\n        (count-ones (quotient num 2))))\n    (+\
    \ (count-ones 1) (count-ones 2)))\n  (cond ((null? arr) (null? arr))\n       \
    \ ((equal? (first arr) (- (first arr) (first arr))) arr)\n        ((equal? (first\
    \ arr) 0) (reverse arr))\n        (else (let ([low (first arr)])\n           (sort-array\
    \ (remove-if (lambda (x) (> (count-ones x) (first arr)) 0)\n                 \
    \              (rest arr))))))\n</code>\nThis gives the following result:\n<code>\n\
    Welcome to Racket v6.\n> (sort-array [1 2 5 3 4])\n'(1 2 3 4 5)\n> (sort-array\
    \ [2 -3 4 -5 6])\n'(-2 -3 -4 -5 6)\n> (sort-array [1 0 3 4 5])\n'(0 1 2 3 4)\n\
    </code>\n<|/ a dscore=2 tags=lisp,racket,scheme,functional-programming |>\n<|\
    \ c |>\nIt might be better if you rephrased the conditional expressions in the\
    \ last `cond` expressions so that we could see what they do.\n<|/ c |>\n<| c |>\n\
    Thank you! I agree with you. I've updated the answer.\n<|/ c |>\n<| a |>\nHere's\
    \ my attempt at this problem in Racket (which I'm somewhat comfortable with):\n\
    <code>", "  (sort arr\n         (\u03BB (x y)\n           (let ((b1 (make-bitmap\
    \ x (+ 1 (bit-count x))))\n                 (b2 (make-bitmap y (+ 1 (bit-count\
    \ y))))\n                 (b2 (bit-set b2 0))\n                 (b2 (bit-not b1\
    \ 0))\n                 (r (bit-ref b1 0))\n                 (r (bit-ref b2 0))\n\
    \                 (count-1 (+ r 1))\n                 (count-2 (+ r 2))\n    \
    \             (count-3 (+ r 3))\n                 (count-4 (+ r 4))\n        \
    \         (count-5 (+ r 5))\n                 (count-6 (+ r 6))\n            \
    \     (count-7 (+ r 7)))\n             (cond ((> count-1 0) (< count-1 y)) ((>\
    \ count-2 0) (< count-2 y)) ((> count-3 0) (< count-3 y)) ((> count-4 0) (< count-4\
    \ y)) ((> count-5 0) (< count-5 y)) ((> count-6 0) (< count-6 y)) ((> count-7\
    \ 0) (< count-7 y)))\n                 ((> count-1 0) (< count-1 x))\n       \
    \          ((> count-2 0) (< count-2 x))\n                 ((> count-3 0) (< count-3\
    \ x))\n                 ((> count-4 0) (< count-4 x))\n                 ((> count-5\
    \ 0) (< count-5 x))\n                 ((> count-6 0) (< count-6 x))\n        \
    \         ((> count-7 0) (< count-7 x))\n                 ((< count-1 0) (< count-1\
    \ y))\n                 ((< count-2 0) (< count-2 y))\n                 ((< count-3\
    \ 0) (< count-3 y))\n                 ((< count-4 0) (< count-4 y))\n        \
    \         ((< count-5 0) (< count-5 y))\n                 ((< count-6 0) (< count-6\
    \ y))\n                 ((< count-7 0) (< count-7 y)))))))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [else (let ([first x (next x (cdr x))])\n              (cond\n\
    \                [(= (count x) 1) (cons x first)]\n                [(= (count\
    \ x) 0)\n                 (cons first x)]\n                [else (cons x (sort_array\
    \ x))]))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(zero? first) (cons first\
    \ arr)]\n    [else (sort_helper (first arr) (sub1 first) (sort_helper (rest arr)\
    \ rest second) (rest second))]))\n", "  (sort (lambda (x) (number-of-ones x))\
    \ arr))\n", "  (let loop ([idx 0] [arr arr] [count-ones 0] [temp 0])\n    (cond\n\
    \      ((null? arr)\n       (reverse arr))\n      ((= count-ones 0)\n       (loop\
    \ (+ idx 1) (add1 arr) 0 temp))\n      ((= count-ones (length arr))\n       (loop\
    \ (+ idx 1) arr (+ 1 count-ones) temp))\n      (else\n       (loop (+ idx 1) (add1\
    \ arr) (+ 1 count-ones) temp)\n       (loop (+ idx 1) arr (+ 1 count-ones) (+\
    \ temp arr)))\n      )))\n</code>\nNow that we have sorting in place, let's look\
    \ at some of its interesting aspects\n\nThe function loop is designed to be tail-recursive\
    \ (aka loop is a function that returns some value and does something with its\
    \ argument continuously), which means it calls itself (which is in turn called\
    \ by loop) indefinitely.\nThe looping condition is done with some mutual recursion\
    \ which means that loop is called from within itself.\nThe mutual recursion is\
    \ only done when loop is called for the first time.\n\nLet's go over the function\
    \ once again for a moment and see what's going on under the hood.\nThe first thing\
    \ we see is that loop will take 3 arguments, a counter which is initially 0, the\
    \ array to sort, and the current sort temp (which stores the current number that\
    \ is being sorted).\nThe condition in the last clause checks whether count-ones\
    \ has reached the length of the array to sort. If it has, the function will stop\
    \ and the result will be returned.\nIf not, then we'll go into the (else) clause\
    \ of the (cond) expression. The first thing that happens is that the (add1 arr)\
    \ is evaluated which will increment the counter by one for each element that is\
    \ added to the array. Since we are sorting integers, this means that this element\
    \ will be moved to the end of the list if it is the last element that is to be\
    \ sorted. Because of the mutual recursion, we'll go back to loop right after that.\n\
    We now know that loop will call itself again when the count is equal to or greater\
    \ than the length of the array. Since we're sorting integers, we'll just have\
    \ to make sure that count is never less than the length of the array. After all,\
    \ the function will have to go into the (else) clause to sort everything after\
    \ the current element in the array. The current element is the value of the element\
    \ at the current index (which is initially 0).\nThe loop will continue until we\
    \ reach the end of the array or when we break out due to a condition. At that\
    \ point, we'll start incrementing the counter and we'll go back into the (cond)\
    \ expression. The (add1 arr) is still evaluated. This will add one to the counter,\
    \ but since arr is now an ", "  (define (helper i arr)\n    (if (< i 0)\n    \
    \    arr\n        (helper (- i 1) (sort_array (if (equal? (sub1 i) 0) (sub1 i)\
    \ i))))\n  (if (< (length arr) 2)\n      (sort (helper 1 (sub1 arr)) <)\n    \
    \  (helper 1 (sort_array (sub1 arr)))))\n</cell>\n<cell>\n#lang racket\n", " \
    \ (define (compare-elements comp x1 x2)\n    (let ([c (comp x1 x2)])\n      (if\
    \ (< c 0)\n          1\n          c)))\n  (cond ((null? arr) (list nil))\n   \
    \     ((null? (cdr arr)) arr)\n        (else (append (sort (sort (map cons arr\
    \ arr)) compare-elements)\n                        (map cons (car arr) arr)))))\n",
  "  (cond\n    [(null? arr) '()]\n    [(< 0 (modulo (+ (first arr) 1) 2)) (rest (rest\
    \ arr))]\n    [else (cons (first arr) (rest (rest arr)))]))\n</code>\n<|/ a dscore=0\
    \ tags=recursion,scheme,racket,lisp |>\n<| c |>\nThank you for your answer! But\
    \ can you explain me why you made it this way?\n<|/ c |>\n<| c |>\nI made it this\
    \ way because I started with Racket. Since I do not know Racket's internals, I\
    \ started with the simplest solution using only R5RS primitives. The solution\
    \ is pretty straightforward, so I did not feel the need to rewrite it. I also\
    \ did not want to rewrite the sorting algorithm from scratch. The `modulo` function\
    \ was just left as an exercise.\n<|/ c |>\n<| c |>\nOkay, thank you very much!\
    \ But I don't get why you made it this way. Can you explain it to me? I'm just\
    \ curious.\n<|/ c |>\n<| c |>\nThe `modulo` function was just left as an exercise.\
    \ Also, I added a link to an explanation of how `modulo` works. In the comment,\
    \ I also added the link to the standard `modulo` function in R5RS. The code above\
    \ should work fine, but it is not efficient. It traverses the list twice. The\
    \ code above is also hard to read. The `modulo` function could be replaced with\
    \ a single line.\n<|/ c |>\n<| c |>\nI tried to rewrite it without using the `modulo`\
    \ function.\n<|/ c |>\n<| a |>\n<code>\n#lang racket\n", "  (sort (lambda (x)\
    \ (if (zero? (logand x 1)) (dec (logand x 1)) (logand x 1))) arr))\n", "  (cond\n\
    \    [(empty? arr) '()]\n    [(= (size arr) 1) arr]\n    [(= (size arr) 2) (cons\
    \ 0 arr)]\n    [else\n     (define (helper a b)\n       (cond\n         [(< a\
    \ (+ a b)) (cons a (helper (+ a b) (- a b)))]\n         [(< b (+ a b)) (helper\
    \ a (+ b a))\n          (helper a b)]\n         [else (helper a b)]))\n     (helper\
    \ 1 2)]))\n", "  (define (compare-arr arr pivot)\n    (if (null? pivot)\n    \
    \    0\n        (let ((pivot-left (sub1 pivot)))\n          (if (null? (rest arr))\n\
    \              (if (< pivot pivot-left)\n                  1\n               \
    \   0))\n            (let ((pivot-right (sub1 pivot)))\n              (if (< pivot\
    \ pivot-left)\n                  (if (< pivot pivot-right)\n                 \
    \     1\n                      0)\n                  (if (< pivot pivot-right)\n\
    \                      -1\n                      0)))))))\n  (if (null? (rest\
    \ arr))\n      arr\n      (let ((pivot (sub1 (rest arr))))\n        (if (< pivot\
    \ (sub1 (rest arr)))\n            (sort_array (append (reverse arr) (list (car\
    \ arr)))\n            (sort_array (append (list (car arr)) (reverse arr)))\n \
    \           (sort_array (append (list (car arr)) (list (car arr)))))\n       \
    \ (let ((pivot-left (sub1 pivot)))\n          (if (null? (rest arr))\n       \
    \       (if (< pivot pivot-left)\n                  (sort_array (append (reverse\
    \ arr) (list (car arr)))\n                  (sort_array (append (list (car arr))\
    \ (reverse arr)))\n                  (sort_array (append (list (car arr)) (list\
    \ (car arr))))))\n            (let ((pivot-right (sub1 pivot)))\n            \
    \  (if (< pivot pivot-left)\n                  (if (< pivot pivot-right)\n   \
    \                   (sort_array (append (reverse arr) (list (car arr)))\n    \
    \                  (sort_array (append (list (car arr)) (reverse arr)))\n    \
    \                  (sort_array (append (list (car arr)) (list (car arr))))\n \
    \                     (sort_array (append (reverse arr) (list (car arr))))\n \
    \                     (sort_array (append (list (car arr)) (reverse arr)))))\n\
    \                  (compare-arr arr pivot-right))\n            (let ((pivot-right\
    \ (sub1 pivot)))\n              (if (< pivot pivot-left)\n                  (if\
    \ (< pivot pivot-right)\n                      (compare-arr arr pivot-right)\n\
    \                      (compare-arr arr pivot-left)\n                      (compare-arr\
    \ arr pivot)\n                      (compare-arr arr pivot-left))\n          \
    \        (compare-arr arr pivot-right)\n                  (compare-arr arr", " \
    \ (define (helper arr index compare)\n    (cond [(null? arr) '()]\n          [(null?\
    \ (rest arr)) (cons index (sort compare '()\n                                \
    \          (cons 0 (first arr))))]\n          [(compare (first arr) (first arr))\
    \ (cons index (sort compare '()\n                                            \
    \            (cons 0 (first arr))))]\n          [(= (first arr) (first arr)) (sort\
    \ compare '()\n                                          (cons 0 (first arr))))]\n\
    \          [else (helper (rest arr) (+ index 1)\n                     (lambda\
    \ (x y) (cdr compare (* (car compare (* (cdr x) y))\n                        \
    \                         (car compare (* (cdr y) x)))))]))\n  (helper arr (length\
    \ arr) '()))\n", "  (sort arr compare-ones))\n", "  (if (null? arr)\n      '()\n\
    \      (cond\n        ((= (remainder (car arr) 2) 0) (sort_array (cdr arr)))\n\
    \        ((= (remainder (car arr) 1) 0)\n         (if (< (car arr) 0)\n      \
    \       (sort_array (cdr arr))\n             (cons (car arr) (sort_array (cdr\
    \ arr))))))\n      (if (< (car arr) 0)\n          (cons (car arr) (sort_array\
    \ (cdr arr)))\n          (sort_array (cdr arr)))))\n", "  (cond\n    [(= (length\
    \ arr) 1) arr]\n    [(= (first arr) 1) (sort_array (subseq arr (range (1+ length\
    \ (first arr))))]\n    [else\n     (let ([count (add1 (first arr)))\n        \
    \   (sorted (sort_array (subseq arr count (+ count (length arr)))\n          \
    \                   [0 1]\n                             [0 1]))]\n       (if (<\
    \ count (length arr))\n           (concat sorted\n                   (list (first\
    \ arr)\n                         (add1 (second arr)))\n           (concat sorted\
    \ sorted))]))]))\n", "  (define (helper arr acc)\n    (cond\n      [(null? arr)\
    \ acc]\n      [(zero? (car arr)) (helper arr (cons 0 (car acc))) (helper (cdr\
    \ arr) (cons (car arr) acc))]\n      [else (helper (cdr arr) (cons (car arr) acc))]\n\
    \    )\n  )\n  (helper arr nil))\n", "  (let loop ((arr arr) (acc '()))\n    (cond\
    \ ((null? arr) acc)\n          ((= (length arr) 0) acc)\n          ((even? (length\
    \ arr)) (loop (rest arr) (cons (car arr) acc)))\n          ((odd? (length arr))\
    \ (loop (rest arr) (cons (car arr) (append acc (list (- 1 (length arr))) ))))\n\
    \          (else (loop (rest arr) (append acc (list (- (length arr) (* 2 (car\
    \ arr))))))))))\n", "  (let ([count (count-ones (string->list arr))]\n       \
    \ [dec (decimal-sort count)]\n        [max (max count)]\n        [min (min count)]\n\
    \        [sum (sum count)]\n        [i (min (max-array-length arr))]\n       \
    \ [result (make-array (max-array-length arr) '(integer 0))])\n    (dotimes (i\
    \ arr)\n      (set! result (assoc-at result i (+ i 1)))\n      (cond\n       \
    \ ((< min count) (minuends result (- min count)))\n        (#t (< sum (+ count\
    \ (dec (assoc-at result (- i 1)))))))\n    (set! result (assoc-at result (+ i\
    \ 1) max))\n    result))\n", "  (define (helper arr acc k)\n    (cond [(< k (length\
    \ arr)) (cons acc (helper arr (add1 acc) (+ k 1)))]\n          [(= k (length arr))\
    \ (sort arr (reverse acc))]\n          [else (helper arr (cons arr (add1 acc))\
    \ (+ k 1))]))\n  (helper arr null 0))\n", "  (cond [(null? arr) arr]\n       \
    \ [(<= (list-length (list-ref arr 0)) (list-length (list-ref arr (- 0 (list-length\
    \ (list-ref arr 0))))))\n         (sort_array (list-tail arr (list-length (list-ref\
    \ arr 0))))]\n        [else (cons (list-ref arr (list-length (list-ref arr 0))\
    \ (+ 0 (list-length (list-ref arr 0))))\n                  (sort_array (list-tail\
    \ arr (list-length (list-ref arr 0)))))]))\n", "  (sort\n   (lambda (x y)\n  \
    \   (< (memcpy (memset (memcpy 0 0 8) 1 8)\n                (+ x 8 y) 8)\n   \
    \     (memcpy (memcpy 0 8 8) 1 8)))\n   (cdr arr)))\n", "  (sort arr\n       \
    \ ;; Binary comparison is implemented using a custom predicate.\n        (lambda\
    \ (x y)\n          (< (count x #b1) (count y #b1))\n          ;; Decimal comparison\
    \ is implemented using a custom predicate.\n          (< (count x) (count y)))\n\
    \        ;; Binary search is implemented using a custom predicate.\n        (lambda\
    \ (x y)\n          (< (binary-search #b1 x (count x)) (binary-search #b1 y (count\
    \ y))))))\n", "  (define (helper arr counter)\n    (cond\n      [(empty? arr)\n\
    \       (cons counter counter)]\n      [(= (first arr) 1)\n       (helper (rest\
    \ arr)\n               (cons (first arr) (first arr)))]\n      [(< (first arr)\
    \ (first counter))\n       (helper (rest arr)\n               (cons (first arr)\
    \ (first counter)))]\n      [else\n       (helper (rest arr)\n               (cons\
    \ (first counter) (first arr)))]))\n  (helper arr counter))\n", "  (sort arr\n\
    \        (lambda (a b)\n          (cond [(= (length a) (length b)) (< (length\
    \ a) 1)]\n                [(= (length b) (length a)) (< (length b) 1)]\n     \
    \           [(= (length a) 1) (= (length b) 1)]\n                [else (< (length\
    \ b) (length a))]\n              )\n        )\n  )\n)", "  (let ((result (make-array\
    \ (array-length arr) '(list))))\n    (do ((i 0 (+ i 1)))\n        ((< i array-length\
    \ result))\n      (set! result (map (lambda (arr-el)\n                       \
    \  (cond (= (array-ref arr-el i) 1)\n                               (cond ((<\
    \ j i) (set! result (cons (array-ref arr-el j) result))\n                    \
    \                  ((> j i) (set! result (append (list) (subseq result j)))\n\
    \                                      (else\n                               \
    \        (append (subseq result j) (subseq result i (+ j 1))))))\n           \
    \                    (else\n                               (cond ((< j i) (set!\
    \ result (cons (array-ref arr-el j) result))\n                               \
    \       ((> j i) (set! result (append (subseq result j) (subseq result i (+ j\
    \ 1))))))\n                               (else\n                            \
    \   (set! result (append (subseq result j) (list) (subseq result i (+ j 1))))))))))\n\
    \    result))\n", "  (sort\n   (lambda (x y)\n     (cond ((= (length x) (length\
    \ y)) (compare_decimals x y))\n           ((= (length x) 1) (compare_decimals\
    \ x (sub1 y)))\n           ((= (length y) 1) (compare_decimals (sub1 x) y))\n\
    \           ((= (length x) (length y)) (compare_decimals (sub1 x) (sub1 y)))\n\
    \           (else (compare_decimals x (sub1 y)))))\n   arr))\n", "  (if (null?\
    \ arr) '()\n      (append (sort (map count_ones (map bit_extract arr))\n     \
    \               (lambda (x y) (< (x y) 0))\n                    (lambda (x y)\
    \ (< (x y) 0))\n                    '() '()))))\n", "  (sort arr strings-ascending))\n",
  "  (cond\n    [(null? (rest arr)) (list arr)]\n    [(not (= (first arr) 0)) (cons\
    \ (first arr) (sort_array (rest arr)))]\n    [else (cons (first arr) (sort_array\
    \ (rest arr)))]\n))\n</code>\n<|/ a |>\n<| c |>\nThis doesn't sort in numerical\
    \ order as per OP's example, but instead compares the first element to the last\
    \ element and uses the first element as the comparison key.\n<|/ c |>\n<| c |>\n\
    thank you for the comment. I've edited my answer. I hope that now the answer fits\
    \ OP's needs\n<|/ c |>\n<| c |>\nIt doesn't work with:", "  (define (helper arr\
    \ idx)\n    (if (= idx 0)\n        arr\n        (helper (cdr arr) (- idx 1))))\n\
    \  (helper (reverse arr) 0))", "  (define (compare x y)\n    (cond\n      [(=\
    \ 0 (mod x 2)) (< (+ 0 (mod x 2) 1) (+ y 1))]\n      [(= 0 (mod y 2)) (> (+ 0\
    \ (mod y 2) 1) (+ x 1))]\n      [else (< (+ x y) x)]\n    ))\n\n  (cond\n    [(empty?\
    \ arr) (empty? arr)]\n    [else (cons (first arr) (sort (subseq arr 1)\n     \
    \                            (lambda (x) (compare (first arr) x)))\n         \
    \    (sort_array (rest arr)))]))\n</code>\n<|/ a dscore=0 tags=scheme,lisp,racket,racket-student-languages\
    \ |>\n<| a dscore=0 |>\nAs it has been already pointed out, it seems like a homework\
    \ question (which is not a bad thing, as it is a nice puzzle to play with). Thus\
    \ I'm providing you the answer without giving you the solution. (Note: I'm only\
    \ answering the question here, and not giving you the complete solution, which\
    \ is more interesting).\nI'll try to explain as I can, how I did it, and what\
    \ I've done differently from your solution (which I believe is a bit more complex\
    \ and more easily understandable)\nThe solution\nThe main idea is to separate\
    \ algorithmic part from data structure.\nFirst of all, let's get data structures\
    \ right:\n<code>\n#lang racket\n", "  (define (helper i)\n    (if (zero? i)\n\
    \        arr\n        (helper (sub1 i) (+ 1 i))))\n  (helper (length arr) (length\
    \ arr)))", "  (sort (lambda (x y)\n         (if (= (bitwise-and (bitwise-not x)\
    \ (bitwise-and y 0))\n                  (bitwise-and x y))\n             (< y\n\
    \                  (bitwise-and x (bitwise-and y 1)))\n             (< x\n   \
    \               (bitwise-and y (bitwise-and x 1)))))\n         arr))\n</code>\n\
    <|/ a dscore=1 tags=sorting,arrays,racket,scheme |>\n<| a dscore=0 tags=sorting,arrays,racket,scheme\
    \ |>\nYou can use a simple merge sort to solve this problem. Here, I use a procedure\
    \ that will merge two sorted lists, called merge:\n<code>", "  (sort arr\n   \
    \      (lambda (x y) (length (dectobin-string x)) (length (dectobin-string y))\n\
    \                      (dectobin-string x) <  (dectobin-string y)))\n        \
    \ '()))\n", "  ; TODO: Implement your sorting algorithm\n)\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\nHere is a more general solution (for arrays of different lengths).\
    \ \nI assumed a bit-array (so it's sorted for arrays of length 1 and arrays of\
    \ length n where n is a power of two). \n<code>", "  (define (count-ones x)\n\
    \    (let loop ((x x) (i 0))\n      (if (= x 1)\n          (loop (quotient x 2)\
    \ (+ i 1))\n          (loop (quotient x 2) (+ i 1)))\n      i))\n  (sort arr (lambda\
    \ (x) (if (<= (count-ones x) 0) (- count-ones x) (count-ones x))))\n  ;; If you\
    \ don't care about the original order, you can do it like this:\n  (sort arr (lambda\
    \ (x) (count-ones x)))\n  ;; But it might be more efficient to return it sorted\
    \ as is. To do that,\n  ;; just add `(set! arr (sort arr ...))` to the return\
    \ line.\n  (set! arr (sort arr (lambda (x) (count-ones x))))\n  ;; If you need\
    \ the original order, you can do it like this:\n  ;(set! arr (sort arr (lambda\
    \ (x) (count-ones x)) '(< (count-ones x) (count-ones))))\n  (set! arr (sort arr\
    \ (lambda (x) (count-ones x)) '(< (count-ones x) (count-ones))))\n  arr\n)\n",
  "  (cond [(null? arr) '()]\n        [(= 0 (length arr)) (reverse arr)]\n       \
    \ [(= 1 (length arr)) (sort arr (lambda (x y)\n                              \
    \           (- (length x) (length y)))\n                                     (lambda\
    \ (x y)\n                                         (< (char x) (char y))))]\n \
    \       [else (sort arr (lambda (x y)\n                          (cond\n     \
    \                       [(char (mod x 2)) < (char (mod y 2)) (< x y)]\n      \
    \                      [(char (mod x 2)) (< x y) (< y x)]\n                  \
    \          [(char (mod x 2)) > (char (mod y 2)) (> x y)]\n                   \
    \         [(char (mod x 2)) (> x y) (> y x)]\n                            [(char\
    \ (mod x 2)) (= x y) true]\n                            [else false]))]))\n",
  "  (if (null? arr) arr\n      (cons (min (count-ones (car arr)) (count-ones (cdr\
    \ arr)))\n            (sort_array (cdr arr)))))\n", "  (sort arr >\n   (lambda\
    \ (a b)\n     (declare (ignore a b))\n     (if (zero? (logand a (logand 1 b)))\n\
    \         (- (- a 1)\n            (if (negative? b)\n                (+ b 1)\n\
    \                0))\n         (if (negative? a)\n             (+ a 1)\n     \
    \        0)))\n   :key (lambda (x) (logand x 1))))\n</code>\n<|/ a tags=racket,binary,sorting\
    \ dscore=2 |>\n<| c |>\n`sort_array` is not defined correctly.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nThis code works perfectly fine:\n<code>", "  (define (helper arr\
    \ prev-ones)\n    (cond\n      [(empty? arr) '()]\n      [(equal? prev-ones 1)\
    \ (cons (car arr) '())]\n      [(equal? prev-ones 0) (cons (car arr) (helper (cdr\
    \ arr) (sub1 prev-ones)))]\n      [(equal? (car arr) 1) (helper (cdr arr) (sub1\
    \ prev-ones))]\n      [(equal? (car arr) 0) (helper (cdr arr) (add1 prev-ones))]\n\
    \      [else (helper (cdr arr) (add1 prev-ones))]))\n  (helper arr 0))\n", " \
    \ (cond\n    [(null? arr) arr]\n    [else (append (sort_array (filter (lambda\
    \ (x) (equal? (remainder x 2) 1) arr)) \n                      (filter (lambda\
    \ (x) (equal? (remainder x 2) 0) arr)))]))\n</code>\n<|/ a tags=scheme,racket,sorting\
    \ |>\n<| c |>\nThanks very much for sharing your solution!\n<|/ c |>\n<| c |>\n\
    Thanks for sharing. I really like how you solved it using filter and remainder.\
    \ Learned something new. :)\n<|/ c |>\n<| a tags=scheme,racket,sorting |>\nMy\
    \ own solution: \n<code>", "  (if (null? arr) '()\n      (cons (sort (\u03BB (x)\
    \ (count (bit-and x 1)) (assoc x (reverse arr))) (\u03BB (a b) (if (> a b) (a\
    \ b) (+ a b))) (reverse arr)))))\n</cell>\n<cell>\n%run ../sort/sort-array-racket-solutions.rkt ",
  "  (define (helper arr index current-index acc)\n    (if (= index (length arr))\n\
    \        acc\n        (helper (cdr arr) (+ index 1) (+ current-index 1) (cons\
    \ (car arr) (helper arr index (+ current-index 1) acc))))))\n  (helper arr 0 1\
    \ ()))\n", "  (let loop ((len len)\n             (arr (in-list arr)))\n    (cond\n\
    \      [(= len 0)\n       arr]\n      [(even? len) (loop (sub1 len) (cons (first\
    \ arr) (loop (rest len) (cdr arr))))]\n      [(odd? len) (loop (sub1 len) (cons\
    \ (first arr) (loop (rest len) (rest arr))))]\n      [else\n       (loop (sub1\
    \ len) (cons (first arr) (loop (rest len) (cons (first arr) (loop (rest len) (rest\
    \ arr))))))])))\n</code>\n<|/ a dscore=1 |>\n<| a tags=scheme,racket |>\nFor those\
    \ that want to see how it would be done in Racket (sorry, this question was answered\
    \ before)\n<code>", "  (cond [(null? arr) (null? arr)]\n        [(zero? (car arr))\
    \ (car arr)]\n        [else (cons (car arr)\n                    (sort_array (filter\
    \ pos?\n                                         (map remainder\n            \
    \                                       (map (lambda (i)\n                   \
    \                                        (bitwise-and i 1))\n                \
    \                                         arr))))]))\n", "  (define (helper i\
    \ j r)\n    (cond ((null? r) (cons i r))\n          ((eq? (car r) (car j)) (helper\
    \ (cdr j) i (append r (list (car j)))))\n          ((>= (bit-count (car r)) (bit-count\
    \ (car j))) (helper (car r) (cdr j) (append r (list (car r)))))))\n  (helper null\
    \ null null))\n", "  (cond\n    ((null? arr) '())\n    ((= (length arr) 0) '())\n\
    \    ((equal? (car arr) 0) '())\n    ((= (car arr) -1) (cons (car arr) (sort_array\
    \ (cdr arr))))\n    (else (if (equal? (car arr) 0) (sort_array (cdr arr))\n  \
    \            (if (< (length (binary-ones (cadr arr)))\n                      \
    \ (length (binary-ones (car arr))))\n                  (cons (cadr arr) (sort_array\
    \ (cdr arr)))\n                  (sort_array (cdr arr)))\n              (sort_array\
    \ (cdr arr)))))\n  )\n)\n", "  (sort (lambda (x y)\n          (let ([x0 (expt\
    \ x 2)\n                  y0 (expt y 2)]\n                [x0l (expt x0 2)\n \
    \                y0l (expt y0 2)]\n                [x0l0 (expt x0l 2)\n      \
    \            y0l0 (expt y0l 2)])\n            (< (< (expt x0 1) x0l)\n       \
    \       (< (< (expt y0 1) y0l)\n                (< x0 y0l)\n                (<\
    \ y0 x0l))))\n          arr)\n        (lambda (x0 y0)\n          (+ (expt x0 2)\n\
    \             (expt y0 2)))))", "  (cond\n    [(empty? arr) empty]\n    [(= (remainder\
    \ arr (floor (/ (* 2 (length arr)))) 2) 0) (cond\n        [(empty? arr) arr]\n\
    \        [else (cons (quotient arr (floor (/ (* 2 (length arr)))) 2) (sort_array\
    \ (remainder arr (floor (/ (* 2 (length arr)))) 2)))]\n        )]\n    [else (cons\
    \ (quotient arr (floor (/ (* 2 (length arr)))) 2) (sort_array (remainder arr (floor\
    \ (/ (* 2 (length arr)))) 2)))]\n    ))\n", "  (let loop ((prev-count 0))\n  \
    \  (cond\n      ((null? (rest arr)) arr)\n      ((= prev-count (length (filter\
    \ (lambda (x) (= x 1)) (rest arr))))\n       (reverse (sort (lambda (x) (dec (array-copy\
    \ x)))\n                    (lambda (x) (dec (array-copy x)))))\n      (else (loop\
    \ (+ (dec (array-copy arr)) (dec (array-copy prev-count))) (rest arr)))))\n</code>\n\
    <|/ a tags=racket,sorting dscore=2 |>\n<| c |>\nThe `(sort (lambda (x) (dec (array-copy\
    \ x)))` isn't doing anything useful - you could just as easily have `(sort (dec\
    \ (array-copy arr)))`. But the `(dec (array-copy x))` is also wrong - you're copying\
    \ the array to another array, then converting that. The `array-copy` function\
    \ doesn't do what you think it does. It makes a shallow copy, not a deep copy.\
    \ See my answer below.\n<|/ c |>\n<| c |>\nThanks. I see you changed the implementation\
    \ to copy and sort the array directly. The problem was that `array-copy` was returning\
    \ `#t` every time, which caused the sort to break. I thought it was a bug because\
    \ I used that function before, but my array wasn't empty and I thought I used\
    \ it before, but I was wrong. Thanks for the correction!\n<|/ c |>\n<| c |>\n\
    No problem, I wasn't even referring to the bug you pointed out in your own answer\
    \ - I just found it confusing. :-)\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution\
    \ I came up with by combining several of the answers so far. I've tested it with\
    \ input that includes negative numbers and it seems to work with that input as\
    \ well. My solution passes all test cases I've tried.\n<code>", "  (sort (lambda\
    \ (a b)\n          (cond\n            ((= (- b 1) a) (- b 1))\n            ((<\
    \ a b) (- b 1))\n            (else a) )))\n  (reverse arr))\n", "  (if (null?\
    \ arr)\n      null\n      (let ([n (length arr)])\n        (let ([bits (string-bits\
    \ (string->list arr))]\n              [zeros (subseq bits 0 (- n bits))])\n  \
    \        (let ([ones (subseq bits n (+ n bits))])\n            (cond [(< 0 n)\
    \ (list-of n (list-of n))]\n                  [(= 0 n) (list-of n (list-of n))]\n\
    \                  [(= n zeros) (cons n (list-of (length ones) (list-of (length\
    \ ones))))]\n                  [(= n ones) (cons (subseq n 0 (+ n ones)) (list-of\
    \ (length ones) (list-of (length ones))))]\n                  [else (cons zeros\
    \ (sort (append (sort (append ones ones)) (subseq n zeros))))]))))))\n", "  (sort\
    \ (map car (map (lambda (a) (bin->dec a)) arr))))\n", "  (sort arr\n        (lambda\
    \ (x) (< (count x) 3))\n        (lambda (x) (< 0 (expt 2 x))))\n  (sort arr\n\
    \        (lambda (x) (< (count x) 3))\n        (lambda (x) (= (expt 2 x) 0))))\n\
    </code>\n<|/ a tags=scheme,racket |>\n<| a tags=scheme,racket |>\nAnother solution\
    \ in Scheme is this:\n<code>", "  (define (helper index arr-length arr)\n    (if\
    \ (< index arr-length)\n        (if (equal? (count-one (subseq arr (+ index 1)\
    \ arr-length)) 0)\n            (helper (+ index 1) arr-length arr)\n         \
    \   (helper (+ index 1) arr-length arr)))\n      (sub arr (+ index 1) arr-length)))\n\
    \  (helper 0 (length arr) arr))\n</cell>\n<code language=russian>", "  (let ([bins\
    \ \n           (for/fold ([i 0]\n                      ([acc '()])\n         \
    \             ([arr (copy arr)])\n                      ([cnt 0])\n          \
    \            ([acc '()])\n                      ([len (length arr)])\n       \
    \               ([k (+ i 1)])\n                      ([c (modulo (* (+ 1 k) 2)\
    \ len)])\n                      ([s (* 2 c)])\n                      ([t (modulo\
    \ (* c 3) len)])\n                      ([u (* c 6)])\n                      ([v\
    \ (* c 9)])\n                      ([x (* c 12)])\n                      ([y (*\
    \ c 15)])\n                      ([z (* c 18)])\n                      ([o (*\
    \ c 21)])])\n             (cond\n               ((= k len) (append acc arr))\n\
    \               ((= k 0) (cons arr (reverse acc)))\n               ((and (< k\
    \ 4) \n                    (< x len))\n                 (cond\n              \
    \     ((= cnt 1) (cons (- x i) acc))\n                   ((< cnt 0) (cond\n  \
    \                               ((= (length acc) 1) (reverse acc))\n         \
    \                        ((= (length acc) 0) (cons (- x i) acc)))\n          \
    \                       ((= cnt (length acc)) acc)\n                         \
    \        (else (sort acc 0 (+ cnt 1))))))\n               ((and (< k 4) \n   \
    \                 (< y len))\n                 (cond\n                   ((= cnt\
    \ 1) (cons (- y i) acc))\n                   ((< cnt 0) (cond\n              \
    \                   ((= (length acc) 1) (reverse acc))\n                     \
    \            ((= (length acc) 0) (cons (- y i) acc)))\n                      \
    \           ((= cnt (length acc)) acc)\n                                 (else\
    \ (sort acc 0 (+ cnt 1))))))\n               ((and (< k 4) \n                \
    \    (< z len))\n                 (cond\n                   ((= cnt 1) (cons (-\
    \ z i) acc))\n                   ((< cnt 0) (cond\n                          \
    \       ((= (length acc) 1) (reverse acc))\n                                 ((=\
    \ (length acc) 0) (cons (- z i) acc)))\n                                 ((= cnt\
    \ (length acc)) acc)\n                                 (else (sort acc 0 (+ cnt\
    \ 1))))))\n               ((and (< k 4) \n                    (< o len))\n   \
    \              (cond\n                   ((= cnt 1) (cons (- o i) acc))\n    \
    \               ((< cnt 0) (cond\n                                 ((= ", "  (let\
    \ loop ((arr (make-array (length arr) '(unsigned-byte 8))))\n    (cond ((= (length\
    \ arr) 0) arr)\n          ((< 0 (length arr)) (sort arr (lambda (x y)\n      \
    \                                (if (= (sub1 x) 0)\n                        \
    \                  (- y)\n                                          (- x y))))))\n\
    \          (else (loop (cdr arr)))))\n", "  (if (null? arr)\n      '()\n     \
    \ (let* ((head (car arr))\n             (tail (cdr arr)))\n        (cond\n   \
    \      ((and (number? head) (number? tail))\n          (cons (cons head tail)\n\
    \                (sort_array (cons (- head 1) tail))))\n         ((and (number?\
    \ head) (not (number? tail)))\n          (cons (cons head tail)\n            \
    \    (sort_array (cons tail (- head 1)))))\n         ((not (number? head)) (cons\
    \ head (sort_array tail)))\n         (else (cons (sort_array head) (sort_array\
    \ tail)))))))\n", "  (define (helper arr counter index compare)\n    (cond\n \
    \     [(= counter 0) (compare arr index)]\n      [else (helper (cdr arr) (add1\
    \ counter) (add1 (car arr)) (compare index counter))]\n    ))\n  (helper (cdr\
    \ arr) 0 0 > ))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, I learned a lot\
    \ about recursion today.\n<|/ c |>\n<| a tags=arrays,recursion,scheme,sorting,racket\
    \ |>\nHere's an answer that I wrote a while ago, that works with SICP. It's a\
    \ modified version of this one from The Little Schemer. It's not very efficient\
    \ though, but I think it's fairly readable. I'm sure there's a way to do this\
    \ more efficiently (using tail recursion, for example), but I don't know the details\
    \ for that yet.\n<code>\n#lang racket\n", "  (sort (lambda (x y)\n          (cond\n\
    \          [(= (bitwise-and x 1) y) (dec (+ x y))]\n          [(= (bitwise-and\
    \ x 1) 0) (+ x y)]\n          [(> x y) (+ x y)]))\n        arr))\n", "  (cond\
    \ ((null? arr)\n         #f)\n        ((zero? (car arr))\n         (sort_array\
    \ (cdr arr)))\n        ((<= (car arr) (count '1 (cdr arr)))\n         (cons (car\
    \ arr)\n               (sort_array (cdr arr))))\n        (else\n         (sort_array\
    \ (cdr arr)))))\n", "  (cond\n    [(null? arr) (list arr)]\n    [(zero? (car arr))\
    \ (cons (car arr) (sort_array (cdr arr)))]\n    [(> (dec (car arr)) (dec (dec\
    \ (car arr)))) (sort_array (cdr arr))]\n    [else (cons (car arr) (sort_array\
    \ (cdr arr)))]\n  )\n)\n", "  (sort arr (lambda (x y)\n            (cond\n   \
    \           [(= (expt x 2) y) (expt x 2)]\n              [(= (expt y 2) x) (expt\
    \ y 2)]\n              [(= x y) (expt x 3)]\n              [(= y x) (expt y 3)]\n\
    \              [else 0]))))", "  (sort (lambda (x y)\n          (= (remainder\
    \ x 2) (remainder y 2))\n          (> (expt x 2) (expt y 2))\n          (expt\
    \ x 3) <\n          (expt y 3))\n        (reverse arr)))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [else (cons\n           (sort (lambda (x y) (if (number? x)\
    \ (dec (number-to-binary (number-of-bits x))) -1)\n                     (lambda\
    \ (x y) (if (number? y) (dec (number-to-binary (number-of-bits y))) -1)))\n  \
    \         arr)]))\n", "  (sort arr (lambda (x y)\n              (cond\n      \
    \          [(= (bitwise-count x) #b1) (cond\n                                \
    \               [(= (bitwise-count y) #b1) (cond\n                           \
    \                                             [(> (+ x y) y) x]\n            \
    \                                                            [(< (+ x y) y) y]\n\
    \                                                                        [else\
    \ (+ x y)])]\n                                               [else (+ y x)]\n\
    \                                               [(< (+ x y) y) y]\n          \
    \                                     [else (+ x y)])]\n                [(= (bitwise-count\
    \ x) #b0) (cond\n                                               [(= (bitwise-count\
    \ y) #b0) (cond\n                                                            \
    \            [(> (+ x y) y) x]\n                                             \
    \                           [(< (+ x y) y) y]\n                              \
    \                                          [else (+ x y)])]\n                \
    \                               [else (+ y x)]\n                             \
    \                  [(< (+ x y) y) y]\n                                       \
    \        [else (+ x y)])]\n                [else (+ x y)]\n                [else\
    \ (+ x y)]))))\n", "  (define (helper arr n)\n    (cond [(zero? n) (sort arr arr)]\n\
    \          [else (helper (append arr (list (nth arr (quotient n 2))))\n      \
    \                  (sub1 (quotient n 2)))))])\n  (helper arr 0))\n", "  (sort\
    \ (lambda (x) (if (even? (car x))\n                       (+ 1 (count_ones (binary-value\
    \ (bit-array (car x))))\n                        (decimal-value (bit-array (car\
    \ x))))\n                       (decimal-value (bit-array (car x))))\n       \
    \       (bit-array arr)))\n</code>\n<|/ a tags=scheme,racket,algorithm,sorting\
    \ dscore=0 |>\n<| c |>\nThe first solution would fail with (sort_array [2 0 1\
    \ 3 4 5]), which returns [0 1 2 3 4 5].\n<|/ c |>\n<| c |>\nYou are right. I've\
    \ modified my solution and added the line `(sort (lambda (x) (if (even? (car x))\
    \ (decimal-value (bit-array (car x))) (decimal-value (bit-array (car x))) ) `.\
    \ Thanks for the comment.\n<|/ c |>\n<| a tags=scheme,racket,algorithm,sorting\
    \ |>\n<code>\n#lang racket\n", "  (sort arr \n\t(lambda (x y)\n\t  (cond\n\t \
    \   [(equal? (ones-count-of x) y) 0]\n\t    [(equal? (ones-count-of y) x) 1]\n\
    \t    [else (compare-counts x y)])))\n", "  (let loop ((arr (car arr))\n     \
    \        (result (car arr))\n             (count (car arr))\n             (res\
    \ (cdr arr)))\n    (cond\n      [(zero? count)\n       (reverse res)]\n      [(or\
    \ (null? res) (zero? count))\n       (reverse result)]\n      [(null? arr) (reverse\
    \ result)]\n      [else\n       (loop (cdr arr)\n             (cons (car arr)\
    \ (loop (cdr arr) (cons (car res) result)))\n             (- count (expt 2 (car\
    \ arr)))\n             (cons (car res) res))]]))\n", "  (cond [(empty? arr) empty]\n\
    \        [(positive? (first arr)) (cons (first arr) (sort_array (rest arr)))]\n\
    \        [else (if (empty? (rest arr)) (cons (first arr) (sort_array (rest arr)))\n\
    \                  (cons (sort_array (rest arr)) (first arr)))]))\n", "  (if (empty?\
    \ arr) '() (rest (sort (count-ones (first arr)) (lambda (x y)\n              \
    \                                    (compare-ones (first arr) (first y)))\n \
    \                                                 (reverse (second arr)))))) \n",
  "  (if (null? arr)\n      (list)\n      (let ([bins (binary-to-bin arr)])\n    \
    \    (let ([counts (map (lambda (b) (count (bin-at b 0)) bins)])\n           \
    \    (mins (for [c counts] (list c))\n                   (maxes (for [c counts]\
    \ (cons (- c 1) (list c))))\n                   (lens (for [x mins] (- x (length\
    \ maxes)))\n                   (sorted-bins (for [i lens] (let ([m1 (car mins)\n\
    \                                                            m2 (car maxes)\n\
    \                                                            x (- i 1)])\n   \
    \                                             (cond\n                        \
    \                          ((= i 0)\n                                        \
    \           (cons m1 m2))\n                                                  ((=\
    \ i 1)\n                                                   (cons (+ m1 (* x 2))\
    \ (cons m2 (+ m1 (* x 2)))))\n                                               \
    \   (else\n                                                   (cond\n        \
    \                                            ((= i 2)\n                      \
    \                               (cons m1 m2))\n                              \
    \                      (else\n                                               \
    \      (cond\n                                                      ((= i 3)\n\
    \                                                       (cons m1 (+ m1 (* x 3)))\n\
    \                                                      (else\n               \
    \                                        (cons m1 (+ m1 (* x 4)))\n          \
    \                                           ))\n                             \
    \                     ))\n                                                ))\n\
    \                   (sorted-decimals (for [i lens] (let ([m1 (car sorted-bins))\n\
    \                                                       m2 (cons (car sorted-bins)\
    \ (cadr sorted-bins))\n                                                      \
    \ x (- i 1)])\n                                                (cond\n       \
    \                                           ((= i 0)\n                       \
    \                            (cons m1 m2))\n                                 \
    \                 ((= i 1)\n                                                 \
    \  (cons (+ m1 (* x 2)) (cons m2 (+ m1 (* x 2)))))\n                         \
    \                         (else\n                                            \
    \       (cond\n                                                    ((= i 2)\n\
    \                                                     (cons m1 m2))\n        \
    \                                            (else\n                         \
    \                            (cond\n                                         \
    \             ((= i 3)\n                                                     \
    \  (cons m1 (+ m1 (* x 3)))\n                                                \
    \      (else\n                                                       (cons m1\
    \ (+ m1 (* x 4)))\n                                                     ))\n \
    \                                                 ))\n                       \
    \                         ))\n                   (unsorted-bins (for [i lens]\
    \ (let ([m1 (car sorted-decimals))\n                                         \
    \             m2 (cons (car sorted-decimals) (cadr sorted-decimals))\n       \
    \                                               x (- i 1)])\n                \
    \                                (cond\n                                     \
    \             ((= i 0)\n                                                   (cons\
    \ m1 m2))\n                                                  ((= i 1)\n      \
    \                                             (cons (", "  (define (helper arr\
    \ start)\n    (cond\n      [(empty? arr) empty]\n      [(positive? (first arr))\
    \ (append (helper (rest arr)\n                                               (cons\
    \ (first arr) start))\n                               (helper (rest arr) (list\
    \ (first arr))))]\n      [(negative? (first arr)) (append (helper (rest arr)\n\
    \                                               (cons (first arr) start))\n  \
    \                             (helper (rest arr) (list (- first arr))))]))\n \
    \ (helper (reverse arr) '()))\n", "  (sort arr (lambda (a) (count (binary->dec\
    \ (binary->bit a))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, I did not\
    \ think of using binary.\n<|/ c |>\n<| c |>\nThis doesn't give me the correct\
    \ answer for the first test case I gave in the question though, which is `sort_array([1,\
    \ 5, 2, 3, 4])` should return `[1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nAh, I see.\
    \ I updated the answer to sort on decimal value. Let me know if that works\n<|/\
    \ c |>\n<| c |>\nI still get `sort_array([-6, -5, -4, -3, -2])` as the output.\
    \ I'm thinking this is because you are using string comparison, instead of the\
    \ integer comparison you were supposed to use.\n<|/ c |>\n<| c |>\nAre you sure\
    \ you copied the code correctly? It works correctly for me. Are you sure you're\
    \ not using the old version?\n<|/ c |>\n<| a |>\nHere's another possible approach:\n\
    <code>", "  (let ([length (length arr)])\n    (if (= length 0)\n      '()\n  \
    \    (let ([cur (car arr)])\n        (if (= cur (- 1 (logand arr (cdr arr)))))\n\
    \          (cons cur (sort_array (cdr arr)))\n          (if (< cur (+ 1 length))\n\
    \            (cons cur (sort_array (cdr arr)))))))))\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=1 |>\n<code>", "  (sort (lambda (x) (zero? (binary->decimal\
    \ x)))\n\t (reverse (sort (lambda (x) (decimal->binary x))\n\t\t\t (reverse arr)))))\n",
  "  (sort (\u03BB (a b) (< (expt a 2) (expt b 2)))\n\t ;; Convert to binary representation\n\
    \t  (map (\u03BB (x) (bin->dec x))\n\t       (map expt arr arr))\n\t ;; Sort according\
    \ to number of 1s in binary representation\n\t  (map add1 arr)))\n  ;; Convert\
    \ back to decimal representation\n  (map dec->bin arr))\n", "  (if (null? arr)\n\
    \      '()\n      (cons (min (sort (map (fn [x] \n                           \
    \    (if (= 0 (remainder x 2)) 1 0))\n                                   (append\
    \ arr (list x))))\n             (sort (map (fn [x] \n                        \
    \  (if (= 0 (remainder x 2)) 2 0))\n                           (append arr (list\
    \ x))))\n             (sort (map (fn [x] \n                          (if (= 0\
    \ (remainder x 2)) 3 0))\n                           (append arr (list x))))\n\
    \             (sort (map (fn [x] \n                          (if (= 0 (remainder\
    \ x 2)) 4 0))\n                           (append arr (list x))))\n          \
    \   (sort (map (fn [x] \n                          (if (= 0 (remainder x 2)) 5\
    \ 0))\n                           (append arr (list x)))))))", "  (if (null? arr)\n\
    \      arr\n      (let ([cnt (count-ones arr)])\n        (if (>= cnt 1)\n    \
    \        (let ([dec (/ (+ (* cnt dec) dec) 2)])\n              (cons dec \n  \
    \                  (sort_array (filter-out (complement cnt) arr))))\n        \
    \    (let ([dec (/ (+ (* cnt dec) dec) 2)])\n              (cons dec \n      \
    \              (sort_array (filter-out cnt arr)))))))\n", "  (cond\n    [(or (empty?\
    \ arr) (= (remainder 0 1) 0)) empty-arr]\n    [(<= (remainder 0 1) 0) (cons (min\
    \ (first arr) (rest arr)) (sort_array (rest arr)))]\n    [else (cons (first arr)\
    \ (sort_array (rest arr)))]\n  )\n)\n", "  (reverse\n   (sort (lambda (x y) (<\
    \ y (count_ones x)))\n          (lambda (x y) (< (count_ones x) y))\n        \
    \  arr)))\n", "  (define (helper arr result)\n    (if (null? arr)\n        result\n\
    \        (helper (cdr arr) \n                 (if (= 1 (car arr))\n          \
    \           (cons (car arr) (cons (car result) result))\n                    \
    \ (cons (car arr) (cons (car result) (helper result (car arr))))))))\n  (helper\
    \ arr '()))\n", "  (sort\n   (lambda (x y)\n     (if (= (count x) 1)\n       \
    \  (if (= (count y) 1)\n             (= (+ x y) 0)\n             (< (+ x y) y))))\n\
    \   arr))\n", "  (if (null? arr)\n      '()\n      (append (sort (map (lambda\
    \ (el) (count el \"1\")) arr) <)\n              (sort (map (lambda (el) (count\
    \ el dec)) arr) >))))\n", "  (let ([i 0] [max #f])\n    (if (< i 4)\n        (cond\n\
    \          [(= max #t) (sort arr (lambda (a b) (b a)))]\n          [else (cons\
    \ (min (length arr) (+ i 4) (+ i 4)) (sort arr (lambda (a b) (b a b)))])]\n  \
    \      [(= i 4) (sort arr (lambda (a b) (b a)))]\n        [else (cons (min (length\
    \ arr) (+ i 4)) (sort arr (lambda (a b) (b a b)))])])\n    (list arr)))\n", " \
    \ (define (sort-helper\n           arr\n           cur-pos\n           arr-pos)\n\
    \    (cond\n      ((or (= cur-pos arr-pos)\n           (null? arr))\n       (reverse\
    \ arr))\n      ((= (bitwise and cur-pos arr-pos)\n          0)\n       (sort-helper\n\
    \        arr\n        cur-pos\n        (+ cur-pos 1)))\n      (else\n       (cond\n\
    \         ((not (= (bitwise and cur-pos arr-pos)\n                   0))\n   \
    \       (sort-helper\n           (bitwise xor cur-pos arr-pos)\n           (+\
    \ cur-pos 1)\n           (+ arr-pos 1)))\n         (else\n          (let ((dec\
    \ (dec->int cur-pos)))\n            (cond\n             ((not (= dec 0))\n   \
    \           (sort-helper\n               (bitwise xor cur-pos arr-pos)\n     \
    \          (+ cur-pos 1)\n               (+ arr-pos 1)))\n             (else\n\
    \               (sort-helper\n               (bitwise xor cur-pos arr-pos)\n \
    \              (+ cur-pos 1)\n               (+ arr-pos 1))))))))\n  (sort-helper\n\
    \   arr\n   0\n   0))\n", "  (if (null? arr)\n      '()\n      (let ((current\
    \ (assoc (car arr) '(0 1 2 3 4 5 6 7 8 9))\n                         (length arr))\n\
    \            (result (cons current '())))\n        (if (= length 1)\n        \
    \    (cons (car arr) result)\n            (if (= length (- current 1))\n     \
    \           (cons current result)\n                (sort_array (append (reverse\
    \ result) (subseq arr (car arr) (+ current 1))))))));;#lang racket\n", "  (let\
    \ ([cnt (length (bin-to-decimal arr))])\n    (cond\n      [(= cnt 0) arr]\n  \
    \    [(= cnt 1) (sort (sort arr) <))]\n      [(= cnt 2) (sort (sort (sort arr))\n\
    \                         (lambda (x y)\n                          (< (length\
    \ (bin-to-decimal arr)) 2)\n                          (< (length y) 2)\n     \
    \                     (< (length (bin-to-decimal x)) 2)\n                    \
    \      (< (length (bin-to-decimal y)) 2))))]\n      [(= cnt 3) (sort (sort (sort\
    \ (sort arr))\n                             (lambda (x y)\n                  \
    \             (< (length (bin-to-decimal arr)) 3)\n                          \
    \     (< (length y) 3)\n                               (< (length (bin-to-decimal\
    \ x)) 3)\n                               (< (length (bin-to-decimal y)) 3))))]\n\
    \      [(= cnt 4) (sort (sort (sort (sort (sort arr)))\n                     \
    \          (lambda (x y)\n                                (< (length (bin-to-decimal\
    \ arr)) 4)\n                                (< (length y) 4)\n               \
    \                 (< (length (bin-to-decimal x)) 4)\n                        \
    \        (< (length (bin-to-decimal y)) 4)))]\n      [(= cnt 5) (sort (sort (sort\
    \ (sort (sort (sort arr)))\n                               (lambda (x y)\n   \
    \                             (< (length (bin-to-decimal arr)) 5)\n          \
    \                      (< (length y) 5)\n                                (< (length\
    \ (bin-to-decimal x)) 5)\n                                (< (length (bin-to-decimal\
    \ y)) 5)))]\n      [(= cnt 6) (sort (sort (sort (sort (sort (sort (sort arr)))\n\
    \                               (lambda (x y)\n                              \
    \  (< (length (bin-to-decimal arr)) 6)\n                                (< (length\
    \ y) 6)\n                                (< (length (bin-to-decimal x)) 6)\n \
    \                               (< (length (bin-to-decimal y)) 6)))))]\n     \
    \ [(= cnt 7) (sort (sort (sort (sort (sort (sort (sort (sort arr)))\n        \
    \                       (lambda (x y)\n                                (< (length\
    \ (bin-to-decimal arr)) 7)\n                                (< (length y) 7)\n\
    \                                (< (length (bin-to-decimal x)) 7)\n         \
    \                       (< (length (bin-to-decimal y)) 7))))))]\n      [(= cnt\
    \ 8) (sort (sort (sort (sort (sort (sort (sort (sort (sort arr)))\n          \
    \                     (lambda (x y)\n                                (< (length\
    \ (bin-to-decimal arr)) 8)\n                                (< (", "  (sort (lambda\
    \ (a b)\n          (cond [(= (length a) 0) 1]\n                [else (cond [(=\
    \ (length b) 0) 1]\n                            [(= (mod (basic-to-lut-idx a)\
    \ 0) 0) 1]\n                            [(= (mod (basic-to-lut-idx b) 0) 0) 1]\n\
    \                            [else (= (mod (basic-to-lut-idx a) 0) (mod (basic-to-lut-idx\
    \ b) 0))]\n                    [(= (mod (basic-to-lut-idx a) 1) 0) 0]\n      \
    \              [(= (mod (basic-to-lut-idx b) 1) 0) 0]\n                    [else\
    \ (= (mod (basic-to-lut-idx a) 1) (mod (basic-to-lut-idx b) 1))]\n           \
    \         [else (= (/ a b) 0) (/ b a)]\n                    [else (= (mod b a)\
    \ 0) (/ a b)]\n                    [else 0]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
