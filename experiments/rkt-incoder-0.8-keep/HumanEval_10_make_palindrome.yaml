name: HumanEval_10_make_palindrome
language: rkt
prompt: "#lang racket\n\n;; Find the shortest palindrome that begins with a supplied\
  \ string.\n;; Algorithm idea is simple:\n;; - Find the longest postfix of supplied\
  \ string that is a palindrome.\n;; - Append to the end of the string reverse of\
  \ a string prefix that comes before the palindromic suffix.\n;; >>> make_palindrome('')\n\
  ;; ''\n;; >>> make_palindrome('cat')\n;; 'catac'\n;; >>> make_palindrome('cata')\n\
  ;; 'catac'\n(define (make_palindrome string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"x\") \"\
  x\")\n    (check-equal? (candidate \"xyz\") \"xyzyx\")\n    (check-equal? (candidate\
  \ \"xyx\") \"xyx\")\n    (check-equal? (candidate \"jerry\") \"jerryrrej\")\n))\n\
  \n(test-humaneval)"
completions: ["  (let loop ((s string)\n             (start 0)\n             (end\
    \ (length s))\n             (palindrome #f)\n             (palindrome-length #f)\n\
    \             (palindrome-string #f)\n             (palindrome-chars #f)\n   \
    \          (chars '(#\\Space #\\Newline #\\Tab))\n             (result #f)\n \
    \            (start 0))\n    (if (zero? end)\n        (reverse result)\n     \
    \   (loop (substring s start end)\n              (+ start 1)\n              (+\
    \ end 1)\n              (= (length palindrome)\n                 (palindrome-length))\n\
    \              (palindrome)\n              (palindrome-string)\n             \
    \ (palindrome-chars)\n              (chars\n                (reverse (palindrome-chars))\n\
    \                (append s (reverse (palindrome-string s))))\n              (set!\
    \ result (append result (palindrome)))\n              start))\n    result))\n",
  "  (let* (\n        (l (string-length string))\n        (len (string-length string))\n\
    \        len1 (sub1 (string-length string)))\n    (let loop ((i 0) (j 0))\n  \
    \    (cond\n        ((< i l) (make-string len1 #\\space))\n        ((< j l) (make-string\
    \ len #\\space))\n        ((eq (sub1 (string+ i 1))\n              (string+ j\
    \ 1))\n          (string+ i (string+ j 1)))\n        (else (loop (+ i 1) (+ j\
    \ 1))))))))\n</code>\n<|/ a |>\n<| a tags=recursion,racket,scheme |>\nHere's a\
    \ solution without using string concatenation or recursion:\n<code>", "  (let\
    \ ((len (string-length string))\n        (found (substring string 0 (string-length\
    \ string)-1))\n        (palindrome (string-reverse string)))\n    (cond\n    \
    \  [(string= found palindrome) string]\n      [(null? found) found]\n      [(>\
    \ len 1) palindrome]\n      [else (append (make_palindrome (substring string 0\
    \ (string-length string)-1))\n                       (substring palindrome 0 (string-length\
    \ palindrome)-1))]))) ; The two strings should be\n                          \
    \                                                      ; equal and the function\
    \ should return \n                                                           \
    \                     ; a palindrome in reversed order. \n", "  (define (helper\
    \ string result)\n    (if (null? string) result\n        (helper (cdr string)\
    \ (append result (substring string 0 (string-length string))))))\n  (helper string\
    \ '()))\n", "  (cond ((null? string)\n         empty)\n        (else (cons (car\
    \ string)\n                    (make_palindrome (append (string (cdr string))\
    \ (string string)))))) ))\n", "  (define (helper str result)\n    (if (empty?\
    \ str)\n        result\n        (helper (cdr str) (cons (reverse str) result))))\n\
    \  (helper string ''))\n", "  (let ((postfix. (string-length string)))\n    (define\
    \ (prefix postfix string)\n      (string-append (reverse (reverse (substring string\
    \ 0 postfix))) (string-reverse (string-ref string (- postfix postfix))))\n   \
    \   (cond ((< postfix postfix) (prefix postfix string))\n            ((> postfix\
    \ postfix) (string-append string prefix)\n            (prefix postfix string))))\n\
    \    (cond ((< postfix 0)\n           (reverse (substring string 0 (- postfix\
    \ 1))))\n          ((> postfix 0)\n           (string-append (prefix postfix string)\
    \ (reverse (substring string 1 (- (string-length string) postfix)))))))\n</code>\n\
    <|/ a tags=racket,lisp,scheme |>\n<| c |>\nThis is not correct: it doesn't find\
    \ the largest palindrome that starts with some given string. It just finds the\
    \ longest postfix that can be a palindrome.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out, I've corrected the answer. :-)\n<|/ c |>\n<| c |>\nThanks, I like\
    \ this answer more than mine.\n<|/ c |>\n<| a dscore=1 |>\nThis can be done in\
    \ O(n) time with a simple recursive algorithm:\n\nIf your string is empty, return\
    \ an empty string.\nIf your string is equal to your last character, return an\
    \ empty string.\nIf your string is less than your last character, return the same\
    \ string plus the last character removed.\n\nIf your string is larger than your\
    \ last character, go through the steps of the previous step until you get to the\
    \ last character:\n\nIf your string is equal to the last character, return it.\n\
    If your string is less than the last character, return the same string plus the\
    \ last character removed.\n\nIt should be clear that this algorithm runs O(n)\
    \ time, and it only uses constant space. Here's the code in Racket:\n<code>",
  "  (define (find-longest-palindromic-suffix string suffix start end)\n    (cond\
    \ [(null? end) (if (char=? (car string) (string-ref string start)) (+ 1 (- start\
    \ (length string)))\n                             (if (> (length string) (length\
    \ string)) (length string))\n                             (length string))\n \
    \                    end]\n          [(char=? (car string) (string-ref string\
    \ start)) (find-longest-palindromic-suffix string (substring string end (+ start\
    \ end)) start (+ start (length string)))]\n          [else (find-longest-palindromic-suffix\
    \ string (substring string end end) start (+ start (length string)))]))\n  (define\
    \ (find-longest-palindrome-postfix string start end prefix)\n    (cond [(null?\
    \ end) (cons (substring string start start) prefix)\n                        end]\n\
    \          [(char=? (car string) (string-ref string start)) (find-longest-palindrome-postfix\
    \ (substring string end (+ start end)) start (+ start (length string)) (cons (substring\
    \ string end (+ start end)) prefix))]\n          [else (find-longest-palindrome-postfix\
    \ (substring string end end) start (+ start (length string)) (cons (substring\
    \ string end end) prefix))]))\n  (define (make-palindrome-suffix suffix start\
    \ end)\n    (let loop ((start (+ start (length suffix)))\n               (end\
    \ (+ end (length suffix)))\n               (suffix-length (- start end)))\n  \
    \    (cond [(null? (cdr suffix)) (substring string start end)]\n            [(char=?\
    \ (car suffix) (string-ref string start)) (loop (+ start (length suffix)) end\
    \ (+ start (length suffix)) (cons (substring string end end) suffix-length))]\n\
    \            [else (loop (+ start (length suffix)) end end (+ start (length suffix))\
    \ suffix-length)]))\n  (define (find-longest-palindrome-suffix string)\n    (find-longest-palindromic-suffix\
    \ string string 0 (length string)))\n  (define (make-palindrome string)\n    (let\
    \ loop ((i 0))\n      (cond [(null? string) (list '())]\n            [(char=?\
    \ (car string) (string-ref string i)) (loop (+ ", "  (let loop ((length length)\n\
    \             (length length))\n    (if (= length 0)\n        string\n       \
    \ (loop (sub1 length) (sub1 length) (string+ (reverse string) (sub1 (sub1 string)))))))\n",
  "  (let ([len (length string)])\n    (cond\n      [(< len 1)\n       (error \"Invalid\
    \ input: input must be at least one character.\" string)]\n      [(equal? (string-ref\
    \ string 0) (string-ref string len))\n       (string-append string (string-reverse\
    \ string))\n       string]\n      [(string=? (string-ref string 0) (string-ref\
    \ string len))\n       (make_palindrome (string-append string (string-reverse\
    \ string)))]\n      [else\n       (let ([pref (string-reverse (string-ref string\
    \ 0)))\n              p (reverse (string-append string pref))\n              l\
    \ (string-length (string-ref string len))\n              tail (string-ref string\
    \ (+ len 1))]\n         (cond\n           [(equal? (string-length pref) l)\n \
    \           (make_palindrome string)]\n           [else\n            (let ([res\
    \ (make_palindrome tail)])\n              (cond\n                [(null? res)\n\
    \                 (string-append string tail)]\n                [else\n      \
    \           (string-append string res)]\n                )\n            ]\n  \
    \        )))))\n</code>\n<|/ a dscore=4 tags=racket,string-processing,string,racket-student-languages\
    \ |>\n<| c |>\nThanks. I like your solution.\n<|/ c |>\n<| a dscore=2 |>\nI wrote\
    \ some code for the same problem in Java and it seems to work for every test I\
    \ tried\n<code>\npublic static String shortestPalindrome(String s) {\n       \
    \ int len = s.length();\n        StringBuilder sb = new StringBuilder();\n   \
    \     char[] a = s.toCharArray();\n        boolean isPalindrome = true;\n    \
    \    StringBuilder rev = new StringBuilder();\n\n        for( int i = 0; i < (len/2);\
    \ i++) {\n            if( a[i] != a[len-(i+1)]) {\n                isPalindrome\
    \ = false;\n                break;\n            }\n        }\n\n        if(isPalindrome)\
    \ {\n            for(int i = 0; i < (len/2); i++) {\n                sb.append(a[i]);\n\
    \            }\n        } else {\n            for(int i = 0; i < (len/2); i++)\
    \ {\n                rev.insert(0, a[i]);\n            }\n            sb.append(rev.toString());\n\
    \        }\n\n        return sb.toString();\n    }\n</code>\n<|/ a tags=racket,string-processing,string,racket-student-languages\
    \ |>\n<| c |>\nThis will not work as expected for \"abba\", it will return \"\
    abb\" instead of \"abba\".\n<|/ c |>\n<| c |>\nThanks, I didn't ", "  (let ((reverse\
    \ (make-reverse-string string)))\n    (let ((post (longest-postfix string reverse)))\n\
    \      (cond ((equal? string post)\n             string)\n            ((equal?\
    \ string (reverse post))\n             post)\n            (else\n            \
    \ (append string reverse (make-string-palindrome-prefix string post))\n      \
    \       post))))))\n", "  (let ((palindromic (reverse (string-pred string))) \n\
    \        (suffix (string-tail string)))\n    (if (string= suffix \"\")\n     \
    \   \"\"\n        (string-append\n         (string-append palindromic (reverse\
    \ suffix))\n         palindromic))))\n", "  (let loop ((longest (string-length\
    \ string))\n             (current (substring string 0 (min longest string-length\
    \ current))))\n    (if (< longest string-length current)\n        (let ((suffix\
    \ (reverse (substring current longest string-length current))))\n          (string-append\
    \ current suffix suffix))\n        \"\")))\n", "  (cond [(empty? string) string]\n\
    \        [(ends? string reverse) string]\n        [else\n         (append (make_palindrome\
    \ (reverse (subseq string 0 (- (length string) 1))))\n                 (subseq\
    \ string 0 (- (length string) (length reverse))))]))\n", "  (define (longest string)\n\
    \    (cond ((null? string) '')\n          ((eq? (length string) 0) string)\n \
    \         (else (longest (cdr string)))))\n  (define (postfix string longest)\n\
    \    (cond ((null? string) longest)\n          ((eq? (length string) 0) longest)\n\
    \          (else (postfix (cdr string) (cons (reverse string) (longest))))))\n\
    \  (postfix string longest))\n", "  (let ((pos-suffix (position string \"\")))\n\
    \    (if (> pos-suffix 0)\n        (let ((suffix (substring string 0 pos-suffix)))\n\
    \          (cond ((equal? (reverse suffix) (string suffix))\n                (substring\
    \ string 0 pos-suffix))\n                (else (string-append (string suffix)\
    \ (reverse (substring string pos-suffix 0)))))))))\n", "  (define (length s)\n\
    \    (if (empty? s)\n        0\n        (+ 1 (length (rest s)))))\n\n  (define\
    \ (substring s i)\n    (if (empty? s)\n        '()\n        (substring (rest s)\
    \ i)))\n\n  (define (reverse s)\n    (if (empty? s)\n        '()\n        (reverse\
    \ (rest s) (length s))))\n\n  (define (append a b)\n    (if (empty? b)\n     \
    \   a\n        (append b (first b))))\n\n  (define (append a b)\n    (append (first\
    \ b) (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n    (append\
    \ b (first a)))\n\n  (define (append a b)\n    (append b (first a)))\n\n  (define\
    \ (append a b)\n    (append b (first a)))\n\n  (define (append a b)\n", "  (cond\
    \ [(empty? string) string]\n        [(equal? (first string) (last string)) (string)]\n\
    \        [else\n         (append (reverse (string-append (make-substring string\
    \ 0 (- (length string) 1)))\n                    (make-substring (string-append\
    \ (reverse string) (string-append (make-substring string 1 (- (length string)\
    \ 1))))\n                                (- (length string) 1))))]))\n", "  (let\
    \ ((prefix (reverse string)))\n    (append (string-append string prefix)\n   \
    \         (make-palindrome (string-substring string 0 (string-length string)))))\n\
    </code>\n<|/ a |>\n<| c |>\nPlease don't use the word \"palindrome\", since that's\
    \ a word already in use in the Racket language. It's not a palindrome in Scheme\
    \ or Lisp, so I wouldn't consider it one.\n<|/ c |>\n<| a |>\nI know this is an\
    \ old question, but if you're looking for an elegant solution that uses regular\
    \ expressions, try this one:\n<code>", "  (define (suffix i s)\n    (cond\n  \
    \    [(null? s)\n       (reverse s)]\n      [else (cons (car s) (suffix (+ i 1)\
    \ (cdr s)))]))\n  (define (postfix i s)\n    (cond\n      [(null? s)\n       s]\n\
    \      [(not (null? s))\n       (cond\n         [(equal? (car s) (string-reverse\
    \ (string i)))\n          (postfix (+ i 1) (cdr s))]\n         [else\n       \
    \   (cons (car s) (postfix (+ i 1) (cdr s)))])]\n      [else\n       (cons (car\
    \ s) (postfix (+ i 1) (cdr s)))]))\n  (define (reverse-length string)\n    (define\
    \ (find-last-palindrome i s)\n      (cond\n        [(null? s)\n         0]\n \
    \       [(equal? (car s) (string-reverse (string i)))\n         1]\n        [else\
    \ (find-last-palindrome i (cdr s))]))\n    (define (reverse s i)\n      (cond\n\
    \        [(null? s)\n         (reverse s (+ i 1))]\n        [else\n         (cons\
    \ (car s) (cons (car s) (reverse (cons (cdr s) (+ i 1)) (length s))))]))\n   \
    \ (define (prefix s i)\n      (cond\n        [(null? s)\n         s]\n       \
    \ [(equal? (car s) (string-reverse (string i)))\n         (prefix s (+ i 1))]\n\
    \        [else\n         (cons (car s) (prefix (cdr s) (+ i 1)))]))\n  (define\
    \ (prefix s)\n    (define (length s)\n      (cond\n        [(null? s)\n      \
    \   0]\n        [(equal? (car s) (string-reverse (string s)))\n         (length\
    \ (cdr s))]\n        [else\n         (+ 1 (length s))]))\n  (define (suffixes\
    \ i)\n    (cond\n      [(null? i)\n       (reverse (list string))]\n      [else\
    \ (cons (reverse (list (string-reverse (string i))) (length (string i)))\n   \
    \               (suffixes (+ i 1))]))\n  (define (postfix s)\n    (define (length\
    \ s)\n      (cond\n        [(null? s)\n         0]\n        [(equal? (car s) (string-reverse\
    \ (string s)))\n         (length (cdr s))]\n        [else\n         (+ 1 (length\
    \ s))]))\n  (define (palindrome s)\n    (define (length s)\n", "  (let ((longest-prefix\
    \ (reverse string)))\n    (append string (reverse (substring string 0 (- (string-length\
    \ string) (string-length longest-prefix)))))))\n", "  (let ((len (length string)))\n\
    \    (define (longest-palindromic-prefix prefix longest-prefix longest-suffix\
    \ longest-suffix longest-prefix)\n      (cond\n        [(or (< 0 len) (>= len\
    \ 1)) (prefix longest-prefix longest-suffix longest-suffix longest-prefix)]\n\
    \        [else\n         (cond\n            [(string-equal? (substring string\
    \ 0 len) prefix) (cons (reverse prefix) longest-prefix)]\n            [else (longest-palindromic-prefix\
    \ (substring string 0 (+ len 1)) prefix (reverse (substring string (+ len 1))\
    \ longest-suffix (reverse (substring string (- len 1)) longest-prefix))]))]))\n\
    \    (longest-palindromic-prefix string '() '() '() '()))\n", "  (let* ((postfix-len\
    \ (string->list string))\n         (longest 0\n                   (longest 0))\n\
    \         (suffix-start (sub1 (string-length string)))\n         (suffix-end (sub1\
    \ (string->list string))\n         (suffix-palindrome? (reverse (string->list\
    \ string))))\n        (if (eqv? longest 0)\n            (append string \n    \
    \              (string->list string #:reverse (list #:empty))))\n        (cond\
    \ ((< longest postfix-len)\n               (let* ((palindrome-start (sub1 postfix-len)\n\
    \                        (suffix (sub1 suffix longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest longest longest longest\
    \ longest longest longest longest longest longest longest ", "  (let loop ((longest-postfix\
    \ string)\n             (longest-postfix \"\"))\n    (if (string? longest-postfix)\n\
    \        (if (eq? (reverse (make-string 0 (string-length string) (append longest-postfix\
    \ (reverse (string longest-postfix))))) string)\n            (loop (string-append\
    \ longest-postfix (reverse (string longest-postfix)))\n                  (string-append\
    \ longest-postfix string))\n        (loop (string-append longest-postfix string)\n\
    \              (string-append longest-postfix string))))))\n</code>\nEDIT: I updated\
    \ the code to be more efficient (it now runs about 150 times faster), but I still\
    \ have a long way to go in Racket without using lists. If you need more efficiency,\
    \ then you can improve the code by using vectors. A vector can store several values\
    \ at once instead of several lists. Vectors are easier to manipulate, but they\
    \ also tend to use more memory than lists.\n<|/ a dscore=1 |>\n<| a |>\nI suggest\
    \ you try using lists instead of vectors. Vectors store all of the information\
    \ at once, whereas lists store all of the information at once, one element at\
    \ a time. This means that the data you stored in them is stored as a linked list,\
    \ whereas list just stores the data. It's possible to have a list where each element\
    \ is a vector of numbers, and each vector is stored as a list. But vectors are\
    \ better than lists, which is why they're better than you might think.\nHere is\
    \ a function that uses lists to return the shortest palindrome of the supplied\
    \ string:\n<code>", "  (define (match-len start end)\n    (cond [(= end start)\
    \ (- start string)]\n          [(= 0 (string-length start))\n           (string-reverse\
    \ start)]\n          [else (match-len (substring start end)\n                \
    \          (substring end start))]))\n  (let ([l (match-len (substring string\
    \ 0)\n                       (string-length string))])\n    (cond [(= 0 (string-length\
    \ string))\n           (substring string 0)]\n          [else (substring string\
    \ l)]))))\n", "  (let ((l (length string))\n        (palindrome))\n    (if (=\
    \ l 0)\n        string\n        (let ((post (reverse (subseq string 0 (- l 2))))\n\
    \              (pre (subseq string 1 l)))\n          (cond\n            ((equal\
    \ post pre) (make-string l #\\space))\n            (else (cons pre post)))))\n\
    \    (cons palindrome (string-append palindrome (make_palindrome (subseq string\
    \ 1 (- (length palindrome) 1)))))))", "  (define (helper\n           (longest-postfix\
    \ string)\n           (palindromic prefix)\n           (result-string prefix))\n\
    \    (if (null? prefix)\n        result-string\n        (let ((prefix (substring\
    \ (string (reverse prefix)) 0 longest-postfix)))\n          (helper (+ longest-postfix\
    \ 1) (append (string) (list (reverse prefix))) (append result-string (list prefix))))))\n\
    \  (string-append string (helper 0 (string \"\") \"\")))\n</code>\nI did some\
    \ quick testing:\n<code>", "  (let ((reverse (substr string 0 (- (length string)\
    \ 1)))\n        (prefix (substr string 0 (- (length string) 2)))\n        (postfix\
    \ (substr string (- (length string) 1)))\n        (longest (subseq post 0)))\n\
    \    (cond\n      [(equal? reverse prefix) (cons postfix string)]\n      [(equal?\
    \ reverse prefix) (cons (reverse postfix) string)]\n      [(equal? reverse prefix)\
    \ (cons (reverse prefix) (cons postfix string))]\n      [(equal? reverse prefix)\
    \ (cons (reverse prefix) (cons (reverse postfix) string))]\n      [else (cons\
    \ (reverse prefix) (cons postfix string))]))\n", "  (let ((length (string-length\
    \ string)))\n    (define (longest prefix)\n      (cond\n        ((= 0 (string-length\
    \ prefix)) length)\n        (else (longest (substring prefix 0 (string-length\
    \ prefix))))))\n    (define (append prefix suffix) (append (substring suffix 0\
    \ (string-length suffix))\n                                         (substring\
    \ prefix 0 (string-length prefix))))\n    (define (append prefix suffix suffix)\
    \ (string-append (append prefix suffix) (append suffix prefix)))\n    (define\
    \ (longest palindrome)\n      (cond\n        ((= 0 (string-length palindrome))\
    \ length)\n        (else (longest (append (substring palindrome 0 (string-length\
    \ palindrome)) (substring string 0 (string-length string))))))\n    (longest string)))\n",
  "  (cond\n    [(empty? string) string]\n    [(equal? (substring (string 0 (string-length\
    \ string)) (string-length string)) (string-reverse (string-prefix string))) (string-append\
    \ string (string 0 (string-length string)))]\n    [else (make_palindrome (string-append\
    \ string (string 0 (string-length string))))]))\n", "  (let* (\n        (r (reverse\
    \ string))\n        (p (substring string 0 r))\n        (ps (rreverse p)))\n \
    \   (cons (+ p (string ps)) string)))\n", "  (cond [(null? string) string]\n \
    \       [(string-length string)\n         (append (string-append (string-reverse\
    \ (string-ref string 0)) (string-ref string 0))\n                 string)]\n \
    \       [else (make_palindrome (string-ref string 0))]))\n", "  (if (string? string)\n\
    \      (let ((reversed (substring string 0 (- (length string) 1)))\n         \
    \   (prefix (substring string 1)))\n        (set! string (reverse prefix (append\
    \ reversed (reverse string))))\n        (set! string (string->list string))\n\
    \        (string-append \"(\" (reverse (string->list string)) \")\")))\n  '())\n",
  "  (cond ((= (length string) 1)\n         string)\n        ((equal? (reverse (string-ref\
    \ string 0))\n                  (string-ref string 1))\n         string)\n   \
    \     (else\n         (append\n          (make_palindrome (string-ref string 0\
    \ (- (length string) 1))))\n         (string-append (reverse (string-ref string\
    \ 0 (- (length string) 1))) (string-ref string 1))))))\n</code>\n<|/ a dscore=2\
    \ tags=racket,scheme |>\n<| a tags=racket,scheme |>\nHere's a way that's probably\
    \ faster than the others -- it's O(n log n) instead of O(n) for the other answers:\n\
    <code>", "  (let ((result (make-string (string-length string))))\n    (set! result\
    \ (append result (substring string 0 (string-length string)))))\n    (set! result\
    \ (append (substring result 1 (string-length string))\n                      \
    \  (reverse (substring result 0 (string-length string))))))\n    (set! result\
    \ (cons result \"\")))", "  (cond\n    [(empty? string) string]\n    [else (append\n\
    \           (make_palindrome\n             (string-reverse (string-ref string\
    \ 0))\n             (string-append string (string-reverse (string-ref string 0)))\n\
    \           (make_palindrome\n             (string-reverse (string-ref string\
    \ 1))\n             (string-append (string-reverse (string-ref string 1)) string))))]))\n",
  "  (let ((longest-palindrome (longest-palindrome-of string))\n        (prefix (reverse\
    \ (string longest-palindrome))))\n    (list string\n          (string-append string\
    \ prefix)))))\n", "  (let ((longest (string-reverse (string-prefix-predecessor\
    \ string))))\n    (append string longest longest)))\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nIn scheme you can do something like the following:\n<code>", "  (let ((length\
    \ (string-length string)))\n    (let loop ((longest length) (i (- longest 1)))\n\
    \      (if (< i (- longest 1))\n          string\n          (let ((prefix (substring\
    \ string i longest)))\n            (let ((suffix (substring string longest 1)))\n\
    \              (cons (reverse prefix) (append suffix longest loop)))))\n     \
    \ string)))\n", "  (let loop ((string string) (palindrome (string reverse string)))\n\
    \    (cond\n      [(empty? string) palindrome]\n      [(equal? string (reverse\
    \ palindrome)) string]\n      [else (loop (rest string) (cons (first string) palindrome))])))\n",
  "  (let loop ((string string) (result '')) (i 0))\n    (cond ((char= (char string\
    \ i) (string-length string))\n           (loop string (append result (list-ref\
    \ (substring string 0 i) string))))\n          ((char= (char string i) (list-ref\
    \ string i))\n           (loop string (append result (list-ref (substring string\
    \ (i-1) i) string))))\n          ((char= (char string i) (string-length string))\n\
    \           (loop string (append result (substring string 0 i))))\n          ((char=\
    \ (char string i) (list-ref string i))\n           (loop string (append result\
    \ (substring string (i-1) i))))\n          ((char= (char string i) (list-ref (substring\
    \ string 0 i) string))\n           (loop string (append result (substring string\
    \ (i-1) string))))\n          ((char= (char string i) (list-ref (substring string\
    \ 0 i) string))\n           (loop string (append result (substring string (i-1)\
    \ string))))\n          ((char= (char string i) (string-length string))\n    \
    \       (loop string (append result (substring string 0 i))))\n          ((char=\
    \ (char string i) (list-ref string i))\n           (loop string (append result\
    \ (substring string (i-1) i))))\n          ((char= (char string i) (list-ref (substring\
    \ string 0 i) string))\n           (loop string (append result (substring string\
    \ (i-1) string))))\n          ((char= (char string i) (list-ref (substring string\
    \ 0 i) string))\n           (loop string (append result (substring string (i-1)\
    \ string))))\n          ((char= (char string i) (string-length string))\n    \
    \       (loop string (append result (substring string 0 i))))\n          ((char=\
    \ (char string i) (list-ref string i))\n           (loop string (append result\
    \ (substring string (i-1) i))))\n          ((char= (char string i) (list-ref (substring\
    \ string 0 i) string))\n           (loop string (append result (substring string\
    \ (i-1) string))))\n          (else\n           (loop string (append result (substring\
    \ string 0 i)))))))\n", "  (if (equal? string \"\")\n      \"\"\n      (let ((start\
    \ (string-length string))\n            (end start))\n        (let ((suffix (reverse\
    \ (substring string start end))))\n          (if (equal? (make-prefix-reverse\
    \ string suffix) (string-append string suffix))\n              (string-append\
    \ string (string-append (make-prefix-reverse string suffix) \"\")))\n        \
    \    (make-prefix-reverse string (string-append (substring string start end) \"\
    \"))))))\n", "  (let ([pos-length (string-length string)])\n    (let ([length\
    \ (- pos-length 1)])\n      (let ([length (min length pos-length)]\n         \
    \   [half-string (make-string length #\\0))])\n        (cond [(> pos-length 0)\n\
    \                (append half-string\n                        (string-reverse\
    \ (string-copy string 0 pos-length)))]\n              [else string])))\n</code>\n\
    <|/ a tags=scheme,racket,string,reverse |>\n<| a tags=scheme,racket,string,reverse\
    \ dscore=0 |>\nThis solution works with any size string:\n<code>", "  (let ([prefix\
    \ (reverse string)])\n    (append prefix (reverse (substring string 0 (- (string-length\
    \ string) 1))))))", "  (let* ((prefix (reverse (string-append string \"\")))\n\
    \         (postfix string))\n    (if (string-equal? postfix prefix)\n        postfix\n\
    \        (make-prefix-palindrome prefix postfix))))\n", "  (let ((longest (longest_palindrome\
    \ string)))\n    (if (null? longest)\n        string\n        (append-to-end string\
    \ longest))))\n", "  (define (p string)\n    (lambda (prefix)\n      (cond (empty?\
    \ prefix) string\n            ((equal? (car prefix) (string->char (reverse (cdr\
    \ prefix)))) (string->char (reverse (car prefix)))))\n            (else (p prefix\
    \ (append (string->char (reverse (car prefix))) string))))))\n  (p string \"\"\
    ))\n", "  (let ((palindrome-suffix '())\n        (palindrome-prefix string))\n\
    \    (cond [(null? string)\n           '']\n          [else\n           (define\
    \ (longest_palindrome_suffix string)\n             (if (palindrome-suffix)\n \
    \                (reverse palindrome-suffix)\n                 (palindrome-suffix))\n\
    \           (cond [(= (length string) 0)\n                  (string-append palindrome-suffix\
    \ string)]\n                 [(string? (substring (string 0) 0 (- (length string)\
    \ 1)))\n                   (longest_palindrome_suffix string)]\n             \
    \    [(string? (substring (string 0) 0 (- (length string) 2)))\n             \
    \      (longest_palindrome_suffix string)]\n                 [else\n         \
    \          (append palindrome-suffix\n                          (longest_palindrome_suffix\
    \ (substring (string 0) 1 (- (length string) 1))))]))\n          (let ((suffix\
    \ (longest_palindrome_suffix string)))\n            (cond [(= (length suffix)\
    \ 0)\n                   string]\n                  [(string? (substring (suffix\
    \ 0) 0 (- (length suffix) 1)))\n                   (cons (string->char (substring\
    \ (suffix 0) 0 (- (length suffix) 1))) palindrome-suffix)]\n                 \
    \ [(string? (substring (suffix 0) 0 (- (length suffix) 2)))\n                \
    \   (cons (string->char (substring (suffix 0) 0 (- (length suffix) 2))) palindrome-suffix)]\n\
    \                  [else\n                   (append palindrome-prefix\n     \
    \                     (string->char (substring (suffix 0) 1 (- (length suffix)\
    \ 1))))]))]))\n", "  (let ((prefix (make-suffix string 0))\n        (suffix (make-suffix\
    \ string (string-length string) string)))\n    (append-to-end prefix suffix)\n\
    \    (longest-palindrome prefix)))\n", "  (define (reverse string)\n    (define\
    \ (helper string)\n      (if (empty? string) string\n          (helper (rest string))\n\
    \          (cons (car string) (helper (cdr string)))))\n    (helper (reverse string)))\n\
    \  (let loop ((current string) (result string))\n    (if (empty? current)\n  \
    \      result\n        (loop (cdr current)\n              (cons (reverse current)\
    \ (cons (car current) result)))))\n  (if string-equal? string (reverse result)\
    \ result))\n", "  (letrec\n    ((longest-post (lambda (str)\n                \
    \    (let loop ([str str] [len 0])\n                      (cond\n            \
    \          ((null? str) str)\n                      ((palindromic? str) str)\n\
    \                      (else\n                       (let ([suffix (reverse (subseq\
    \ str 0 len))])\n                         (loop\n                           (subseq\
    \ str len (length str))\n                           (+ len 1)))))))))\n    (if\
    \ (palindromic? string)\n        string\n        (let ([prefix (subseq string\
    \ 0 (longest-post string))])\n          (append prefix (subseq string (longest-post\
    \ string) string)))))\n", "  (cond\n    ((string-empty? string) string)\n    ((equal?\
    \ (char-at (string-ref string 0) 0) (string-ref string 1)) (string-cat string\
    \ 'catac'))\n    ((equal? (char-at (string-ref string 0) 0) (char-at (string-ref\
    \ string -1) 0))\n     (string-append string (string-reverse (string-ref string\
    \ 1)))\n     (make_palindrome (string-concat string 'cata')))\n    ((equal? (char-at\
    \ (string-ref string 0) 0) (char-at (string-ref string -1) 0))\n     (make_palindrome\
    \ (string-concat string 'cata'))\n     (make_palindrome (string-concat string\
    \ 'catac')))\n    (else (make_palindrome (string-concat string 'catac')))))\n",
  "  (let ((suffix (substring string 0 (string-length string)))\n        (pref (substring\
    \ string 1 (string-length string)))\n        (palp (substring string 1 (string-length\
    \ string)))\n        (rev (reverse palp)))\n    (if (equal? (reverse palp) (reverse\
    \ pref (reverse suffix)))\n        (reverse prep (reverse suffix))\n        (recur\
    \ string))))\n</code>\n<|/ a tags=racket,scheme,string |>\n<| a tags=racket,scheme,string\
    \ |>\n<code>", "  (let loop ((result string)\n             (reverse (list-reverse\
    \ (string-append result (string-reverse result))))\n             (prefix string))\n\
    \    (cond ((null? string) string)\n          ((equal? (string-ref string 0) (string-ref\
    \ prefix 0))\n           (loop (string-append result (reverse reverse) (substring\
    \ prefix 1))))\n          (else (loop (string-append result reverse) (substring\
    \ prefix 1))))))\n", "  (let ([len (string-length string)\n        max-len (-\
    \ len 1)\n        prefix (substring string 0 (- len 1))\n        suffix-end (substring\
    \ string (- (string-length string) 1))\n        suffix (substring string (- (string-length\
    \ string) -1))\n        palindrome-end (make-empty-string max-len)]\n    (cond\n\
    \      [(< len 0) palindrome-end]\n      [(equal? prefix suffix) (cons suffix\
    \ palindrome-end)]\n      [(equal? (substring palindrome-end (- len 1)) prefix)\n\
    \       (cons prefix (make_palindrome suffix))]\n      [(equal? (substring palindrome-end\
    \ (- len 1)) suffix-end)\n       (cons prefix palindrome-end)]\n      [(equal?\
    \ prefix suffix-end) (cons prefix palindrome-end)]\n      [(equal? (substring\
    \ palindrome-end (- len 1)) prefix)\n       (cons prefix palindrome-end)]\n  \
    \    [(equal? suffix suffix-end)\n       (cons suffix palindrome-end)]\n     \
    \ [(equal? suffix prefix) (cons suffix palindrome-end)]\n      [(equal? (substring\
    \ palindrome-end (- len 1)) prefix)\n       (cons prefix palindrome-end)]\n  \
    \    [(equal? (substring palindrome-end (- len 1)) suffix-end)\n       (cons suffix\
    \ palindrome-end)]\n      [else (cons suffix palindrome-end)])))\n", "  (define\
    \ (make_palindrome-helper input longest-postfix longest-prefix reversed-strings-suffix\
    \ reversed-strings-prefix)\n    (cond [(empty? input)\n           (list longest-postfix\
    \ longest-prefix reversed-strings-suffix reversed-strings-prefix)]\n         \
    \ [(string-equal? (reverse input) reversed-strings-suffix)\n           (make_palindrome-helper\
    \ (rest input) longest-postfix (first input) (reverse (reverse input)) (reverse\
    \ reversed-strings-prefix))]\n          [else\n           (make_palindrome-helper\
    \ (rest input) (append longest-postfix (reverse input)) (append longest-prefix\
    \ (reverse input)) (reverse reversed-strings-suffix) (reverse reversed-strings-prefix)])\n\
    \          ]))\n  (let ([longest-postfix (reverse (string-length string))])\n\
    \    (make_palindrome-helper string longest-postfix '() '()))\n  )\n", "  (let\
    \ loop ((max-prefix (string-length string)) (prefix (reverse (string-ref string\
    \ 0))))\n    (cond ((< (string-length string) max-prefix) prefix)\n          (else\
    \ (loop (- max-prefix 1)\n                      (string-append (substring string\
    \ 1)\n                                    (substring prefix 0)))))))\n", "  (cond\
    \ [(empty? string) string]\n        [else (append (make_palindrome (revstring\
    \ (last string))) (reverse string))]))\n", "  (let ((p (reverse (string string))))\n\
    \    (cond\n      [(string=? p string) string]\n      [(string=? (reverse p) string)\
    \ p]\n      [else (make_palindrome (string-append p (reverse (string-append string\
    \ p))))])))\n", "  (let loop ((longest '())\n             (string string))\n \
    \   (cond\n      [(empty? string) (string->symbol '())]\n      [(equal? (string->symbol\
    \ string) (string->symbol longest)) (string->symbol (string->symbol string))]\n\
    \      [(not (pair? (string->symbol string))) (loop longest (string->string string))]\n\
    \      [(not (pair? (string->symbol longest))) (loop longest string)]\n      [(string->symbol\
    \ (string->symbol string)) (loop (string->string string) (append (string->string\
    \ (string->symbol string) (string->string (string->symbol string))))]\n      [else\
    \ (loop longest string)])))\n</code>\n<|/ a |>\n<| a |>\nA simple palindrome function\
    \ would look like this:\n<code>", "  (cond\n    [(empty? string) (empty)]\n  \
    \  [else (append (append string (reverse (substring string 0 (string-length string))))\
    \ (make_palindrome (substring string 1 (string-length string))))]))\n", "  (let\
    \ ((str (reverse string)))\n    (string-append\n     (string str)\n     string)))\n",
  "  (define (helper s p)\n    (cond\n      [(string? p) (string-reverse p)]\n   \
    \   [else (cons s p)]))\n  (if (string=? string \"\")\n      string\n      (helper\
    \ (substring string 0 (string-length string)\n                       (reverse\
    \ (substring string 1 (string-length string)))) \n             (make-string (substring\
    \ string 0 (string-length string))))))\n", "  (let ([rpl (length (make-reverse\
    \ string))\n         prefix (substring string 0 (- (length string) 1))\n     \
    \    suffix (substring string 1 length(string))])\n    (cond\n      [(or (equal?\
    \ (make-reverse prefix) rpl)\n           (equal? (make-reverse suffix) rpl)\n\
    \           (equal? (make-reverse (make-reverse prefix)) rpl)\n           (equal?\
    \ (make-reverse (make-reverse suffix)) rpl)\n           (equal? (make-reverse\
    \ prefix) (make-reverse suffix)) '']\n      [else (cons prefix suffix)])))\n",
  "  (let ([string1 (string-append string (string-reverse string))])\n    (if (equal?\
    \ string (string-reverse string1))\n      string1\n      (make_palindrome string1))))\n",
  "  (if (palindrome string)\n      (string-append string \"~\" (reverse (string-prefix-reverse\
    \ string)))\n      '()))\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is great!\
    \ I've made some improvements to your version [here](https://gist.github.com/fmaf/aed2db8ca0d18b60c44b).\
    \ Please feel free to edit your answer to reflect improvements.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nHere's a solution using tail-recursion. Recursion can be difficult\
    \ to grasp, but a tail recursive function is one where the recursive call is the\
    \ last thing in the function so there is no need to save any data outside the\
    \ function.\n<code>", "  (let ((l (string-length string))\n        (palindrome\
    \ (substring (string 0 l) 0 (- l 1)))\n        (palindrome-suffix (reverse (substring\
    \ string 0 l)))\n        (palindrome-prefix (substring string 0 l)))\n    (cond\
    \ [(equal? (string-length palindrome) 0)\n           string]\n          [else\n\
    \           (concat string palindrome palindrome-suffix palindrome-prefix)])))\n",
  "  (let ((longest_postfix string)\n        (longest_postfix_length (length longest_postfix)))\n\
    \    (let ((prefix (substring string 0 longest_postfix_length)))\n      (set!\
    \ longest_postfix (append (append (append (substring string 0 longest_postfix_length)\
    \ (reverse prefix))) longest_postfix)\n            (longest_postfix_length (length\
    \ longest_postfix)))\n      (set! prefix (substring string longest_postfix_length))\n\
    \      (set! prefix (reverse prefix))\n      (string-append prefix longest_postfix))))\n",
  "  (let ((max-postfix\n          (longest-palindrome string)))\n    (prepend-to-end\
    \ string\n                   (reverse (longest-palindrome string)))))\n", "  (cond\
    \ [(null? string) string]\n        [(string-char-at (string-upcase string) 0)\n\
    \         (make-reverse (string-reverse (string-char-at (string-upcase string)\
    \ 0)))]\n        [else (cond [(string-char-at (string-upcase string) 0)\n    \
    \                 (string-append (make-reverse (string-reverse (string-char-at\
    \ (string-upcase string) 0))) (string-char-at (string-upcase string) 0))]\n  \
    \                 [else (make-reverse (string-reverse (string-char-at (string-upcase\
    \ string) 0)) (string-append (make-reverse (string-reverse (string-char-at (string-upcase\
    \ string) 0)) (string-char-at (string-upcase string) 0)))]))]))\n", "  (let ((longest\
    \ 0)\n        (longest_palindrome (make-string)))\n    (if (equal? string \"\"\
    )\n        longest_palindrome\n        (make_palindrome_helper\n         longest_palindrome\n\
    \         (string-to-list string)\n         longest))\n    longest_palindrome))\n",
  "  (let ((longest string))\n    (cond\n      [(empty? string) string]\n      [(char=?\
    \ (car string) longest) (cdr longest)]\n      [(not (char=? (car string) longest))\
    \ (cons car longest)]\n      [(not (equal? (car string) (cdr string))) (make_palindrome\
    \ (cdr string))]\n      [(equal? (car string) (cdr string)) (make_palindrome (cdr\
    \ string))]\n      [(char=? (car string) (cdr string)) (cons car string)]\n  \
    \    (else (make_palindrome (cons (car string) (make_palindrome (cdr string)))))]\n\
    \    longest))\n", "  (if (empty? string)\n      string\n      (append (make_palindrome\n\
    \                (substring (string 0) (length string))\n              (reverse\
    \ (substring (string 1) (length string)))))))\n", "  (define (iter string)\n \
    \   (if (null? string)\n        '\n        (begin (let ([prefix (substring string\
    \ 0 (string-length string))]\n                    [suffix (substring string (string-length\
    \ string) (string-length string))])\n               (cons suffix (reverse prefix)))\n\
    \               (iter (substring string 1 (string-length string)))))\n    (iter\
    \ string)))\n  (iter string))\n", "  (let loop ([string string] [reverse \"\"\
    ] [length 0])\n    (cond [(empty? string) \"\"]\n          [(equal? (car string)\
    \ (reverse reverse)) (string)]\n          [else (loop (cdr string) (cons (reverse\
    \ (car string)) reverse) (inc length))])))\n", "  (let ([palindrome-length (length\
    \ (make_palindrome-preprocess string))])\n    (string->symbol (symbol->string\
    \ (string-cat palindrome-string \"cata\" string))))))\n", "  (define (make-palindrome-helper\
    \ string acc longest-postfix)\n    (cond ((null? string)\n           (reverse\
    \ acc))\n          ((string=? (car string) (cadr string))\n           (make-palindrome-helper\
    \ (cdr string) (cons (reverse acc) (car string)) longest-postfix))\n         \
    \ ((string=? (car string) (caddr string))\n           (make-palindrome-helper\
    \ (cdr string) (cons (reverse acc) (car string)) longest-postfix))\n         \
    \ ((string=? (car string) (caar string))\n           (make-palindrome-helper (cdr\
    \ string) (cons (reverse acc) (car string)) longest-postfix))\n          ((string=?\
    \ (car string) (car (reverse longest-postfix)))\n           (make-palindrome-helper\
    \ (cdr string) (cons (reverse acc) (car string)) (cdr longest-postfix)))\n   \
    \       ((string=? (car string) (cdr (reverse longest-postfix)))\n           (make-palindrome-helper\
    \ (cdr string) (cons (reverse acc) (car string)) (cdr longest-postfix)))\n   \
    \       ((string=? (car string) (reverse longest-postfix))\n           (make-palindrome-helper\
    \ (cdr string) (cons (reverse acc) (car string)) longest-postfix))\n         \
    \ (else\n           (make-palindrome-helper (cdr string) (cons (reverse acc) (car\
    \ string)) longest-postfix)))\n  (make-palindrome-helper string '() string))\n",
  "  (let ((palindrome-length (longest-postfix string)))\n    (if (zero? palindrome-length)\n\
    \        string\n        (append string\n                (list-ref (substring\
    \ (string 0 (- palindrome-length 1)) (palindrome-length 1))\n                \
    \           (reverse (list-ref (substring string (+ palindrome-length 1) (- palindrome-length\
    \ 1))))\n                 ))))\n", "  (let ((reverse (string reverse string)))\n\
    \    (cond ((= (string-length string) 0)\n           (string reverse \"\"))\n\
    \          (else (string-append string reverse))))\n", "  (let loop ((i 0) (longest\
    \ string)\n             (palindrome '()))\n    (cond ((char=? (string-ref string\
    \ i) '-) \"\")\n          ((char=? (string-ref string i) '(') \"\")\n        \
    \  ((char=? (string-ref string i) ')') \"\")\n          ((char=? (string-ref string\
    \ i) '-) longest)\n          ((char=? (string-ref string i) '-) palindrome)\n\
    \          ((char=? (string-ref string i) '(')\n           (loop (+ i 1) (string-append\
    \ palindrome (string-ref string i)))\n           (loop (+ i 1) palindrome))\n\
    \          ((char=? (string-ref string i) '-) loop)\n          ((char=? (string-ref\
    \ string i) '-) palindrome)\n          ((char=? (string-ref string i) '-) (string-append\
    \ palindrome (string-ref string i)))\n          (else\n           (loop (+ i 1)\
    \ longest (string->string (string-append palindrome (string-ref string i)))))\n\
    \          )))\n", "  (define (helper)\n    (define (helper string\n         \
    \        longest_postfix_index\n                 prefix-string)\n      (cond (string?\
    \ prefix)\n            (let ([prefix-index\n                  (position string\n\
    \                            (substring prefix 0 longest_postfix_index)\n    \
    \                        0)])\n              (cond ((eq? (substring prefix 0 longest_postfix_index)\n\
    \                          (substring prefix longest_postfix_index\n         \
    \                           longest_postfix_index\n                          \
    \          0))\n                     (list prefix-index\n                    \
    \      prefix-string))\n                    (else (helper (substring prefix longest_postfix_index)\
    \ longest_postfix_index\n                                  (substring prefix 0\
    \ prefix-index)))))\n      (let ([longest_postfix\n            (reverse (substring\
    \ string 0 (length string) 0))])\n        (cond ((string? longest_postfix)\n \
    \              (helper string\n                      (length longest_postfix)\n\
    \                      (append longest_postfix prefix-string)))\n            \
    \  (else (list prefix-string longest_postfix))))\n    (if (string? string)\n \
    \       (helper string\n                (length string)\n                (append\
    \ string (string-reverse (string-append (substring string 0 (length string) 0)\n\
    \                                 (substring string 0 (length string) 0)))\n \
    \                       string))\n        '()))\n\n  (helper string\n        \
    \  (length string)\n          '()))\n", "  (cond [(empty? string) empty]\n   \
    \     [(equal? (first string) (string-ref (reverse string) 0)) (string-append\
    \ (first string) (string-reverse (reverse (first string))))]\n        [else (make_palindrome\
    \ (reverse (string-append (first string) (first string)))]))\n", "  (let ((tail\
    \ (reverse (string-tail string)))\n        (head (string-head string)))\n    (if\
    \ (empty? tail)\n        head\n        (if (equal? (string-palindrome tail) (string-palindrome\
    \ head))\n            (append (cons head tail)\n                    (make_palindrome\
    \ (string-tail string))\n                    (make_palindrome (string-head string))\n\
    \                    string))))\n", "  (define (make-prefix-of-palindrome string)\n\
    \    (reverse (string-match-leftmost string string :count 1)))\n  (define (longest-palindrome-end\
    \ string end-position )\n    (string? (string-match-end string string end-position\
    \ :count 1)))\n  (let ((end-position (+ end-position (* 2 1))))\n    (let ((prefix\
    \ (make-prefix-of-palindrome string)))\n      (cond (longest-palindrome-end string\
    \ end-position)\n            (else (append string (make-prefix-of-palindrome string)))))))\n",
  "  (cond [(null? string)\n         empty]\n        [(equal? (car string) (string-reverse\
    \ (string-prefix (string-reverse (car string))))\n              (string-reverse\
    \ (string-suffix string)))\n         string]\n        [else\n         (make_palindrome\
    \ (string-suffix string))]))\n</code>\n<|/ a tags=scheme,recursion,racket,sicp,algorithm\
    \ |>\n<| c |>\nThanks for your answer, I upvoted but I think you haven't completely\
    \ read the question. Your solution returns `'cat'` for an empty string, `'cat'`\
    \ for `\"cat\"` and `\"cat\"` for `\"cat\"`, not `\"cata\"`.\n<|/ c |>\n<| c |>\n\
    I didn't notice that. Fixing now\n<|/ c |>\n<| a |>\nThis is another solution\
    \ that is easier to understand and works correctly for empty strings:\n<code>",
  "  (define (longest_palindrome_suffix s)\n    (define (find-tail-prefix s suffix)\n\
    \      (cond\n        ((null? suffix) '())\n        ((string=? (car suffix) (car\
    \ (cdr suffix))) (find-tail-prefix (cdr suffix) suffix))\n        (else (find-tail-prefix\
    \ (cdr suffix) (car suffix))))\n    (cond\n      ((null? s) (longest_palindrome_suffix\
    \ s))\n      ((string=? (car s) (string= (substring s 0 (string-length s))))\n\
    \       (longest-prefix (find-tail-prefix s (reverse (substring s 0 (string-length\
    \ s)))))))\n    (longest_palindrome_suffix (substring s 0 (string-length s)))))\n",
  "  (let ((longest-postfix (longest-postfix string)))\n    (if longest-postfix\n\
    \        (append string (reverse-string (longest-prefix string)))\n        string)))\n",
  "  (define (add-to-end pref prec)\n    (cond\n      [(not (list? prec)) (append\
    \ pref prec)]\n      [(string? (pref prec)) (add-to-end (append pref (append (list->string\
    \ prec) (list->string prec))) prec)]\n      [else (add-to-end pref (list->string\
    \ prec))]))\n  (add-to-end (list->string (string->list string)) (list->string\
    \ (string->list string))))\n", "  (define (longest string)\n    (if (null? string)\n\
    \        0\n        (+ 1 (longest (cdr string)))))\n  (define (make_palindrome-suffix\
    \ suffix string longest)\n    (if (> (length string) longest)\n        '()\n \
    \       (cons (substring string 0 (- longest longest)) (make_palindrome-suffix\
    \ suffix (substring string longest 0) (longest)))))\n  (define (make_palindrome-string\
    \ string longest)\n    (if (null? string)\n        '()\n        (make_palindrome-suffix\
    \ (reverse (substring string 0 longest)) string longest)))\n  (make_palindrome-string\
    \ string 0))\n", "  (let ((prefix (substring string 0 (string-length string))))\n\
    \    (let ((suffix (substring string (string-length string) (string-length string))))\n\
    \      (cond ((equal? (reverse prefix) (reverse suffix))\n             (string-append\
    \ string (substring string 0 (string-length string))))\n            (else\n  \
    \           (string-append string (make-prefix (reverse prefix) (substring string\
    \ (string-length string) (string-length string))))))))\n", "  (define (prefix\
    \ string start limit)\n    (string-slice string start limit))\n  (define (suffix\
    \ string start limit)\n    (string-slice string limit start))\n  (define (reverse\
    \ string start limit)\n    (string-reverse (string-slice string start limit)))\n\
    \  (define (start string limit)\n    (floor (/ (string-length string) 2)))\n \
    \ (define (end string limit)\n    (ceiling (/ (string-length string) 2)))\n  (let\
    \ loop ((i 0) (string-length string) (len limit) (shortest '()))\n    (cond\n\
    \      ((null? string) (string-append shortest string))\n      ((< i len) (loop\
    \ (+ i 1) string len shortest))\n      (else (cond \n              ((= (length\
    \ shortest) (length string))\n               (cons shortest (reverse string 0\
    \ (- i 2))))\n              ((= (start string) (i 2))\n               (cons shortest\
    \ (reverse string (- i (+ i 2)))))\n              (else (let ((prefix (prefix\
    \ string i (+ i 2))) (suffix (suffix string i (- i 2))) (tail (reverse string\
    \ (+ i (+ i 2))) (newstring (append prefix (suffix string))))\n              \
    \          (cond \n                          ((null? tail) (cons newstring shortest))\n\
    \                          (else (loop (+ i 2) tail len newstring)))))))))\n",
  "  (cond ((empty? string) string)\n        ((palindrome? string) (append string\
    \ (append (reverse (substring string 0 (string-length string))) (string-append\
    \ (reverse (substring string (string-length string) (string-length string))))\
    \ string)))\n        (else (make_palindrome (substring string 0 (string-length\
    \ string)) string))))\n", "  (let loop ((i 0 (+ i (string-length string)))\n \
    \            (start (substring string 0 (+ i 1)))\n             (end (substring\
    \ string i (string- (+ i 1))))\n             (reverse-string '()))\n    (cond\n\
    \      [(> i 0) (loop (- i 1) (append reverse-string (substring string 0 (string-length\
    \ start))) (append reverse-string (substring end 0 (string-length start))))]\n\
    \      [else (string-append reverse-string (substring string i (string-length\
    \ start)))]))))\n</code>\n<|/ a dscore=0 tags=string,palindrome,scheme |>\n<|\
    \ a |>\n<code>\n#lang racket\n", "  (let loop ((x string) (y string) (longest\
    \ 0))\n    (if (< x y)\n        (if (eqv? x (reverse y))\n            (cons x\
    \ longest)\n            (loop (reverse x) y longest))\n        (cons x (list longest)))))\n\
    </code>\n<|/ a tags=palindrome,racket,scheme |>\n<| a |>\nThe problem is in the\
    \ return function and in the append function when you try to return (append reverse\
    \ string) you are trying to apply append on reverse and string which is not possible.\n\
    Here is a simplified version of your code:\n<code>", "  (let loop ((string (make-string\
    \ (string-length string) ?A)))\n    (let ((found (equal? (string->list (string->string\
    \ string)) (string->list (string->string (reverse string)))))\n          (result\
    \ (make-string (string-length string) ?A)))\n      (when (not found)\n       \
    \ (string-append result (string->string string))\n        (loop (string->string\
    \ (reverse string)))))\n    result))\n", "  (if (null? string)\n      string\n\
    \      (let ((chars (list->string (list->chars (string->list string))))\n    \
    \        (start (sub1 (length string)))\n            (remaining (- start (length\
    \ chars)))\n            (post (reverse (chars start))\n            (posts (make-postfix-list\
    \ post))\n            (current posts)\n            (next (sub1 (length post))))\n\
    \        (set! current (cons (cons string post) current))\n        (if (zero?\
    \ remaining)\n            (make-postfix-palindrome-helper posts next)\n      \
    \      (make-postfix-palindrome-helper (cons (cons (car posts) post) next) next)))))\n",
  "  (let ([reverse (substring (string 0 -1) (string 0 0))])\n    (if (eq? string\
    \ reverse)\n        string\n        (cons (reverse string)\n              (make_palindrome\
    \ (string-append (substring (string 0 -1) string) string))))))\n", "  (let\n \
    \     ([p (longest-palindrome-prefix (reverse-string string) (longest-palindrome-suffix\
    \ string))])\n    (string-append string p)))\n", "  (cond\n    [(string-empty?\
    \ string) (string-append string 'catac')]\n    [else (cons (string->char (string->list\
    \ (string->postfix (string->prefix string)))) (string->char (string->list (string->postfix\
    \ (string->reversed (string->prefix string))))))]))\n", "  (let ((palindrome-length\
    \ (string-length (reverse-string (prefix-string string)))))\n    (let ((new-string\
    \ (append-string (prepend-string string (reverse-string (prefix-string string)))\
    \ palindrome-length))))\n    (if (equal? new-string string)\n        null\n  \
    \      (new-string))))\n", "  (let ([string-p (reverse string)])\n    (let ([palindrome-start\
    \ (string-length string-p)]\n          [len (string-length string)])\n      (cond\n\
    \        ((= len 0)\n         (string-append string-p))\n        ((string= string-p\
    \ string-p ) string-p\n         (string-p))\n        (else (cond (\n         \
    \  ((<= (string-length string-p) len)\n            (string-append string-p (string-append\
    \ string-p (string-append string-p (string-append string-p string-p))))\n    \
    \       (else (string-append string-p (string-append string-p (string-append string-p\
    \ (string-append string-p string-p)))))))))))\n</code>\n<|/ a tags=string,recursion,racket,scheme\
    \ dscore=0 |>\n<| a tags=string,recursion,racket,scheme |>\n<code>", "  (let loop\n\
    \    (longest-postfix string\n                      (let ((reverse-string (make-string\
    \ (string-length string)))\n                        (string-append reverse-string\
    \ (make-string (substring (string 1 string-length) 0 (string-length string)))))\n\
    \                        (let ((length-to-append (string-length string)))\n  \
    \                        (loop longest-postfix (substring reverse-string 0 (-\
    \ length-to-append length-to-append))\n                                      (string-append\
    \ reverse-string (make-string (substring (string 1 string-length) length-to-append\
    \ (+ length-to-append (string-length string)))))\n                           \
    \           length-to-append (+ length-to-append (string-length string))))))\n\
    \    (substring (longest-postfix string \"\") 0 (string-length string))))\n",
  "  (let ((prefix (reverse string))\n        (suffix (reverse (string-append prefix\
    \ string))))\n    (string-append (substring string 0 length)\n               \
    \    (substring suffix 0 (substring suffix 0 length)))))\n", "  (let loop ((len\
    \ (string-length string)) (result '()))\n    (if (< len (string-length string))\n\
    \        (let ((prefix (substring string 0 (- len 1))))\n          (if (string-equal?\
    \ (reverse prefix) prefix)\n              (loop (sub1 len) (string-append result\
    \ (string prefix))))\n          result)))))\n", "  (define (helper (start end\
    \ string result-string)\n             (cond\n               ;; base cases: we've\
    \ reached the end\n               ((eq? end (string-length string)) result-string)\n\
    \n               ;; recursive case: find the prefix that comes before the suffix\n\
    \               ((start = (string-index string start))\n                (helper\
    \ (+ start 1) end (substring string 0 start) (append result-string (substring\
    \ string start end))))\n\n               ;; base case: we've already found a palindrome,\
    \ just add on the reverse\n               (else (helper (+ start 1) end (string-reverse\
    \ result-string) result-string))))\n  (helper 0 1 (string-reverse string) \"\"\
    ))\n", "  (let loop ([string string] [result (string \"\")])\n    (cond\n    \
    \  [(null? string) result]\n      [(string? string) (reverse result)]\n      [(equal?\
    \ (substring string 0 (string- (length string)))\n                (substring string\
    \ (string- (length string)) (length string)))]\n      [else (loop (substring string\
    \ 0 (string- (length string))) (string-reverse (substring string (string- (length\
    \ string)) (length string))))]))\n", "  (define post (reverse (string-prefix string)))\n\
    \  (cons string post))\n", "  (let ((rev (reverse (string-ref string 0)))\n  \
    \      (cum (length string)))\n    (let loop ((i 0)\n               (len 0)\n\
    \               (str string)\n               (str string))\n      (if (< i cum)\n\
    \          str\n          (let ((prefix (subseq str (* i 2) (* i 2))))\n     \
    \       (set! str (append prefix rev))\n            (loop i (+ len 1)\n      \
    \            (subseq str 0 len)\n                  str)))))))\n", "  (if (string-reverse\
    \ (string-ref string 0))\n      string\n      (make_palindrome (string-append\
    \ string (string-reverse (string-ref string 0))))))\n", "  (let loop ((string\
    \ string)\n             (result '()))\n    (if (null? string)\n        result\n\
    \        (loop (substring string 0 (reverse (string-length string)) string)\n\
    \              (cons (reverse string)\n                    result)))))\n</code>\n\
    <|/ a |>\n<| c |>\nThe \"find longest palindrome ending with given string\" approach\
    \ fails for the cases where the first letter is `M` or `N`, e.g. \"Mississippi\"\
    .\n<|/ c |>\n<| c |>\nThat's a very good catch, and very well made. I've modified\
    \ my answer accordingly. Thanks.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (let\
    \ ((longest-postfix longest-postfix))\n    (cond\n      [(empty? string) string]\n\
    \      [(string=? (string-ref string 0)\n                 (string-ref (string-reverse\
    \ string) 0))\n       (cond\n         [(string=? (string-ref string 1)\n     \
    \              (string-ref (string-reverse (string-ref string 1))\n          \
    \                    longest-postfix)]\n         [else (append (string-reverse\
    \ (string-ref string 1)\n                                (make-postfix longest-postfix)))]\n\
    \       )]\n      [else (make-postfix longest-postfix)]))))\n", "  (let ((reverse-string\
    \ (reverse-string-infix string)))\n    (string-append string reverse-string)))\n",
  "  (let ((prefix (substring string 0 (- (length string) 1))))\n    (let ((suffix\
    \ (reverse (string-append prefix string))))\n      (cond ((null? string) \"\"\
    )\n            ((equal? prefix string) suffix)\n            (else (string-append\
    \ suffix suffix)))))\n", "  (define (make_palindrome_aux\n             (i j)\n\
    \             (len1 len2)\n             (reverse prefix)\n             (reverse\
    \ suffix)\n             (prefix suffix))\n    (cond ((and (char=? i #\\space)\
    \ (char=? j #\\space))\n           (make_palindrome_aux (+ i 1) len1 reverse prefix\
    \ suffix))\n          ((and (char=? i #\\newline) (char=? j #\\newline))\n   \
    \        (make_palindrome_aux (+ i 1) len1 reverse prefix suffix))\n         \
    \ ((and (char=? i #\\space) (char=? j #\\newline))\n           (make_palindrome_aux\
    \ (+ i 1) len1 reverse prefix suffix))\n          ((and (char=? i #\\newline)\
    \ (char=? j #\\space))\n           (make_palindrome_aux (+ i 1) len1 reverse prefix\
    \ suffix))\n          ((and (char=? i #\\newline) (char=? j #\\newline))\n   \
    \        (make_palindrome_aux (+ i 1) len1 (reverse prefix) (append suffix reverse)))\n\
    \          ((char=? i #\\space)\n           (make_palindrome_aux (+ i 1) len1\
    \ (reverse prefix) (append suffix reverse)))\n          ((char=? i #\\newline)\n\
    \           (make_palindrome_aux (+ i 1) len1 (reverse prefix) (append suffix\
    \ reverse)))\n          ((char=? i #\\newline) (char=? j #\\space) (char=? j #\\\
    newline))\n          ((char=? i #\\newline) (char=? j #\\newline) (char=? j #\\\
    space))\n          (else\n           (make_palindrome_aux (+ i 1) len2 (append\
    \ (reverse prefix) suffix) prefix suffix))))\n  (make_palindrome_aux 0 (string-length\
    \ string) \"\" \"\" string \"\"))", "  (let ((max (length (reverse string))) (len\
    \ (length string)))\n    (cond ((<= len max)\n           (append (cons string\
    \ (reverse string))\n                  string))\n          ((= len max)\n    \
    \       (string string))\n          (else\n           (make_palindrome (string-right-of\
    \ string len))))))\n", "  (let ((prefix (reverse string))\n        (suffix (reverse\
    \ (substring string 0 (string-length string))))\n        (postfix \n         \
    \ (append prefix (substring suffix 0 (string-length prefix))))))\n    (cond ((equal?\
    \ string \"\") \"\")\n          ((equal? (substring string 0 (string-length string))\
    \ \"\") string)\n          (else (cons string postfix))))\n", "  (let ((palindromic\
    \ string))\n    (define (work)\n      (if (string-empty? palindromic)\n      \
    \    palindromic\n          (let ((suffix (string->list palindromic)))\n     \
    \       (string-append suffix\n                          (substring string\n \
    \                                   (length\n                                \
    \     (string->list suffix))\n                                    0))\n      \
    \      (string-append palindromic\n                          (string->reverse\
    \ (substring string\n                                                     (length\n\
    \                                                     (string->list suffix))\n\
    \                                                     0))))))\n    (work)))\n",
  "  (let loop ((string-to-be-palindromic string) string-to-be-palindromic string)\n\
    \    (if (> string-to-be-palindromic string)\n        string\n        (if (= (string-to-be-palindromic\
    \ string) (reverse string-to-be-palindromic))\n            string\n          \
    \  (loop (string-to-be-palindromic (reverse string-to-be-palindromic)) (string-append\
    \ string-to-be-palindromic (reverse string-to-be-palindromic)))))\n  (string-to-be-palindromic\
    \ '))\n", "  (if (string-empty? string)\n      ''\n      (append (list-ref (subseq\
    \ (reverse-subseq string) (length (subseq string 0 (string-length string)))) 0)\n\
    \              (make_palindrome (reverse-subseq string (length (subseq string\
    \ 0 (string-length string))))))))\n</cell>\n<cell>\n#lang racket\n", "  (define\
    \ (longest string)\n    (cond\n      [(empty? string) (empty? string)]\n     \
    \ [else (append (longest substring 0 0 string) (longest substring 0 1 string))]))\n\
    \  (longest string))\n", "  (cond [(empty? string) string]\n        [(equal? (car\
    \ string) (reverse (cdr string))) (string-append string reverse-string)]\n   \
    \     [else (string-append (string-append (string-append (string-append (string-append\
    \ (string-append string\n                                                    \
    \                    '~)\n                                                   \
    \                    (string-append (reverse (car string))\n                 \
    \                                                                       '~)\n\
    \                                                                       \"~)~\"\
    )\n                                                                      (string-append\
    \ \"~(\" string \")\" \"))\"))\n                      (string-append (string-append\
    \ (string-append (string-append (string-append (string-append string\n       \
    \                                                                 '~)\n      \
    \                                                                 (string-append\
    \ (reverse (car string))\n                                                   \
    \                                     '~)\n                                  \
    \                                     \"~)~\")\n                             \
    \                                         (string-append \"~)~\" \"))\"))]))))\n",
  "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref (rest\
    \ string) 0)) (string-reverse (string-ref (rest string) 1) (make_palindrome (rest\
    \ string)))]\n    [else (make-string (string-length (first string)) (make_palindrome\
    \ (rest string)))]))\n", "  (let ((l (length string)))\n    (define (aux suffix\
    \ start end\n               max-end max-end found-end\n               min-end\
    \ min-end found-start)\n      (cond\n        [(< start l) (make-char 0 0)]\n \
    \       [(< end l) (make-char l 0)]\n        [(equal? (substring string start\
    \ (+ start 1))\n                  (substring string end (+ end 1)))\n        \
    \ (aux suffix (+ start 1) (+ end 1) (+ start end) min-end found-end)]\n      \
    \  [(equal? (substring string start (+ start 1))\n                  (substring\
    \ string end (+ end 1)))\n         (aux suffix (+ start 1) (+ end 1) max-end found-end)]\n\
    \        [(equal? (substring string start (+ start 1))\n                  (substring\
    \ string end (+ end 1)))\n         (aux suffix (+ start 1) (+ end 1) max-end max-end\
    \ found-end)]\n        [else\n         (aux suffix (+ start 1) end max-end max-end\
    \ found-end)]\n      )\n      (cond\n        [(or (< start (- l 1))\n        \
    \     (< end (- l 1))) (make-char l 0)]\n        [(or (< (length string) (- end\
    \ 1))\n             (< (length string) (- start 1))) (make-char l 0)]\n      \
    \  [else (make-char 0 (- l 1))]))\n    (aux string 0 l (length string) 0 0)))\n",
  "  (let ([start 0])\n    (cond\n      [(empty? string) (string)]\n      [else\n\
    \       (let* ([tail (reverse (cdr (reverse string)))\n               (prefix\
    \ (reverse (substring string start (reverse (string-length string)))))]\n    \
    \        [prefix-end (length (substring string start (+ start (string-length string))))])\n\
    \         (cond\n           [tail string]\n           [else (cons (make-string\
    \ (+ prefix-end 1) tail)\n                       (make-string (- start 1) (make-string\
    \ 1 tail)))])]))]))\n", "  (let ((rev-string (substring string 0 (string-length\
    \ string)))\n        (prefix-string (substring string 1 (string-length string)))\n\
    \        (longest 0))\n    (cond ((null? prefix-string) string)\n          ((string=?\
    \ string rev-string) string)\n          ((< longest string-length) string)\n \
    \         (else (begin (set! longest 0) (append rev-string (make_palindrome prefix-string))\n\
    \                       (set! string prefix-string)))))\n", "  (let ([length (string-length\
    \ string)])\n    (cond\n      [(string= string (reverse (string-append string\
    \ (reverse string))))\n       string]\n      [(odd? length)\n       (cond\n  \
    \       [(string= string (reverse (string-append string (reverse string))))\n\
    \          string]\n         [(string= string (string-append string string))\n\
    \          string]\n         [else (make_palindrome (string-append string (reverse\
    \ string)))])]\n      [else (make_palindrome (string-append string string))]))))\n",
  "  (define (rev_string str)\n    (let loop ((str (reverse str))\n              (len\
    \ 0))\n      (if (null? str) str\n          (loop (cdr str)\n                (incf\
    \ len)))))\n  (define (find_palindrome str)\n    (define (loop i len)\n      (cond\n\
    \        ((null? i) nil)\n        ((= len (/ str (- i len))) (cons (reverse str)\
    \ (i + len 1)))\n        (else (loop (+ i 1) (incf len))))\n    (loop (length\
    \ str) 0))\n  (define (find_longest_palindrome str)\n    (define (loop i len)\n\
    \      (cond\n        ((null? i) nil)\n        ((= len (/ str (- i len))) (loop\
    \ i (+ len 1)))\n        (else (loop (+ i 1) (incf len))))\n    (loop (length\
    \ str) 0))\n  (if (null? string) string\n      (if (equal? string (make_palindrome\
    \ string))\n          string\n          (let ((prefix (reverse (string-slice string\
    \ 0 (length string))))\n                (suffix (string->chars (string->list string))))\n\
    \            (if (equal? (find_palindrome string) (string->chars (make-string\
    \ (car (find_longest_palindrome string)) (apply + suffix))))\n               \
    \ (reverse (append (reverse (append (list string) (list string->chars (make-string\
    \ (car (find_longest_palindrome string)) (apply + prefix)))))\n              \
    \                (append (list (reverse (append (list string) (list string->chars\
    \ (make-string (car (find_longest_palindrome string)) (apply - prefix)))))\n \
    \                                       (list (reverse (append (list (reverse\
    \ (append (list (reverse (append (list (reverse (append (list (reverse (append\
    \ (list (reverse (append (list (reverse (append (list (reverse (append (list (reverse\
    \ (append (list (reverse (append (list (reverse (append (list (reverse (append\
    \ (list (reverse (append (list (reverse (append (list (reverse (append (list (reverse\
    \ (append (list (reverse (append (list (reverse (append (list (reverse (append\
    \ (list (reverse (append (list (reverse (append (list (reverse (append (list (reverse\
    \ (append (list (reverse (append (list (reverse (append (list (reverse (append\
    \ (list (reverse (append (list (reverse (append (list (reverse (append (list (reverse\
    \ (append (list (reverse (append (", "  (define p (reverse (string-append string\
    \ (string->list (reverse string))))) ; string ends in palindrome\n  (cond ((null?\
    \ p) string)\n        ((equal? p (string-append string (string->list (reverse\
    \ string))))) ; string ends in itself\n        (else (string-append p (make_palindrome\
    \ (string->list (reverse p))))) ; string ends in suffix\n  )\n)\n", "  (let loop\
    \ ((string string) (result (make-string (string-length string)))\n           \
    \  (len (string->length (string-reverse string))) (index (string->length (string-reverse\
    \ string)))\n             (result (string-append string result))\n           \
    \  (i (string->length (string-reverse string)))\n             (j (string->length\
    \ (string->symbol string)))\n             (len (string->length (string->symbol\
    \ string))))\n    (if (or (= i j)\n            (= i (string->length string)))\n\
    \        result\n        (recur (string-append (string->symbol string index) result)\n\
    \               (+ i len) (+ j len) (+ i j) (+ len j))))\n</code>\n<|/ a tags=racket,algorithm\
    \ |>\n<| a dscore=0 tags=racket,algorithm |>\nThis is in Racket code (using pattern\
    \ matching and list comprehension):\n<code>", "  (let ((len (string-length string)))\n\
    \    (if (zero? len)\n        '\n        (let ((l (- len 2)))\n          (cond\
    \ ((char=? string 0)\n                 (make-string 1 string)\n              \
    \   (append (make-string l string)\n                         (reverse (make-string\
    \ l string) string)))))))))\n</code>\n<|/ a tags=scheme,lisp |>\n<| c |>\nThe\
    \ above is not complete; you should probably include some error handling for the\
    \ case where strings of length 0 or 1 are provided.\n<|/ c |>\n<| c |>\nThanks,\
    \ added a comment to the OP.\n<|/ c |>\n<| c |>\nI did a quick test and I think\
    \ the `reverse` procedure is missing from the snippet. I added it by editing the\
    \ answer. It might also be better to test the reversal before appending it to\
    \ the string.\n<|/ c |>\n<| c |>\nIn a comment above the OP says he is trying\
    \ to understand how he could do this in Scheme. He also says that his current\
    \ Scheme implementation supports tail calls (which Scheme does not). I think this\
    \ is a valid problem statement as his teacher is trying to teach you how to write\
    \ code that works in his current Scheme implementation.\n<|/ c |>\n<| c |>\n:\
    \ This code is in Scheme and *it works*, if run under Racket. I think he is trying\
    \ to teach him how to write his own Scheme implementation that does not *work*.\n\
    <|/ c |>\n<| a tags=scheme,lisp |>\nHere is what I would do. First, define the\
    \ basic functions: reverse and palindrome-end. If I am dealing with strings, I\
    \ check if they are palindrome and if they are, I reverse them and append them.\
    \ Otherwise, if I end with a palindrome, I would reverse the string and append\
    \ the result. \n<code>", "  (define (append x y)\n    (if (string? x)\n      \
    \  x\n        (append x (string->symbol (string->string y)))))\n  (define (postfix\
    \ str)\n    (if (string? str)\n        str\n        (postfix (string->string (str\
    \ \"\")))))\n  (define (longest str prefix)\n    (if (string? str)\n        (if\
    \ (string? prefix)\n            (if (equal? (string->string prefix) (string->string\
    \ (str)))\n                str\n                (longest (string->string (str\
    \ \"\")) (str prefix \"\")))\n            (longest (string->string (str \"\"))\
    \ (str prefix \"\")))\n        prefix))\n  (define (longest_postfix str)\n   \
    \ (if (equal? str \"\")\n        (error \"No palindromic prefix\" str)\n     \
    \   (longest_postfix (string->string (str \"\"))))\n  (define (longest_postfix_reverse\
    \ str)\n    (if (equal? str \"\")\n        (error \"No palindromic suffix\" str)\n\
    \        (longest_postfix_reverse (string->string (str \"\"))))\n  (define (find_longest\
    \ str prefix suffix)\n    (if (string? str)\n        (if (string? prefix)\n  \
    \          (if (equal? (string->string prefix) (string->string (str)))\n     \
    \           (append str (longest_postfix_reverse (str suffix)))\n            \
    \    (find_longest str (prefix suffix) (longest str (longest_postfix str))))\n\
    \            (find_longest str (prefix suffix) (longest str (longest_postfix str))))\n\
    \        (append str (longest_postfix_reverse (str suffix)))))\n  (find_longest\
    \ string (postfix string) (longest_postfix string)))\n", "  (let ((longest-palindromic-postfix\
    \ '())\n        (palindromic-suffix (reverse (substring string 0 (- (string-length\
    \ string) 1)))))\n    (cond ((= 0 (string-length string)) palindromic-suffix)\n\
    \          ((equal? (substring string 0 (string-length string)) palindromic-suffix)\n\
    \           (cons string longest-palindromic-postfix))\n          ((equal? (reverse\
    \ palindromic-suffix) (substring string 0 (string-length string)))\n         \
    \  (cons (reverse palindromic-suffix) (longest-palindromic-postfix string)))\n\
    \          (else (make-palindrome (string-append longest-palindromic-postfix (reverse\
    \ palindromic-suffix)))))))\n", "  (let loop ((input string)\n             (output\
    \ '')\n             (end 0)\n             (count 0))\n    (cond\n      [(empty?\
    \ input) output]\n      [(equal? input (substring input 0 count)) (loop (substring\
    \ input (+ end (count end)) (- count end)) output end (+ count 1))]\n      [(equal?\
    \ input (substring input (+ end (- count end)) (- count end)))\n       (loop (substring\
    \ input end (+ count 1)) output end (+ count 1))]\n      [else\n       (loop (substring\
    \ input end (+ count 1)) output end (+ count 1))]))\n  (loop '() output 0 0))\n",
  "  (define (make_palindrome_helper lst start len)\n    (cond ((null? lst) (cons\
    \ start start))\n          ((eq? (substring lst start len) (string->list (reverse\
    \ (substring lst start len))))\n           (make_palindrome_helper (rest lst)\
    \ (+ start len) (+ len 1))\n          (else (make_palindrome_helper (rest lst)\
    \ start len))))\n  (make_palindrome_helper string 0 0))\n", "  (let ((start-pos\
    \ (string-length string))\n        (end-pos start-pos))\n    (cond ((null? string)\
    \ (list string))\n          ((equal? (string-ref string 0) (string-ref string\
    \ (string-length string))) (list string))\n          (else (loop\n           \
    \       (set! end-pos (string-length string))\n                  (cond ((equal?\
    \ (string-ref string end-2) (string-ref string end-1) (string-reverse (string-ref\
    \ string end-1)))\n                         (set! start-pos (+ end-2 1))\n   \
    \                      (append (string-ref string start-pos) (make_palindrome\
    \ (string-ref string start-pos)))\n                         (set! start-pos (+\
    \ end-2 1)))))))))\n</code>\n<|/ a tags=racket,recursion,string |>\n<| c |>\n\
    I should note that `string-length` and `string-ref` were introduced in Racket\
    \ 5.2 but are still in `racket/string` before that.  See [this page](http://docs.racket-lang.org/racket/string.html)\
    \ for a more detailed discussion of them.\n<|/ c |>\n<| a |>\nJust for fun, I\
    \ took the liberty of expanding the solution by to include a recursive solution\
    \ as well:\n<code>", "  (cond\n    [(empty? string) (string '())]\n    [(equal\
    \ string \"\") (string '())]\n    [else (let ([pre (reverse string)])\n      \
    \      (append\n             (make-string (string-length pre)\n              \
    \          (cond\n                         [(equal? (string 0) (string-ref pre\
    \ 0)) string]\n                         [else (string-cat pre pre)]))]))]))\n",
  "  (let loop\n    [(start 0)\n     (end (length string))\n     (result \"\")\n \
    \    (len 0)]\n    (cond\n      [(= len end) result]\n      [(char? (car string))\n\
    \       (loop (+ start 1) (- end 1) (append result (reverse (car string)) (make_palindrome\
    \ (reverse (string-slice string (+ end 1) (- end 1))))))]\n      [else (loop (+\
    \ start 1) end result (+ len 1))]))))\n", "  (define (find-longest-palindrome\
    \ prefix postfix palindromic-suffix)\n    (if (null? palindromic-suffix)\n   \
    \     postfix\n        (find-longest-palindrome\n         (append prefix palindromic-suffix)\n\
    \         (substring postfix 1)\n         (append palindromic-suffix (reverse\
    \ prefix)))))\n  (define (find-palindrome string palindromic-suffix)\n    (if\
    \ (equal? string palindromic-suffix)\n        \"\"\n        (cond [(equal? (substring\
    \ string 1) palindromic-suffix)\n               (find-palindrome (string) (append\
    \ palindromic-suffix (reverse (substring string 1)))\n               (find-palindrome\
    \ (string) (append palindromic-suffix (reverse (substring string 1))))]\n    \
    \          [else (string-append palindromic-suffix (substring string 1))])))\n\
    \  (find-longest-palindrome string \"\" (reverse string)))\n", "  (define (make_palindrome-helper\
    \ string string index output)\n    (cond [(char=? (substring string index index)\
    \ (substring string 0 index)) (cons string output)\n          (empty? string)\
    \ (output)\n          (else\n           (make_palindrome-helper\n            (substring\
    \ string index (add1 (length string)))\n            (substring string 0 (add1\
    \ (length string))) index (cons (reverse string) output))\n           (add1 (length\
    \ string)) (add1 (length string))])\n  (make_palindrome-helper string string 0\
    \ (list '')))\n", "  (define (prefix n str)\n    (if (zero? n)\n        '()\n\
    \        (if (char=? (substring str n 1) string)\n            (prefix (substring\
    \ str (+ n 1) (length str)) (substring str (+ n 1) (length str)))\n          \
    \  (append (substring str (- n 1) 1) (substring str n 1)))\n        ))\n  (define\
    \ (suffix n str)\n    (if (zero? n)\n        '()\n        (if (char=? (substring\
    \ str n (length str)) string)\n            (suffix (substring str (- n 1) (+ n\
    \ 1) (length str)) (substring str (- n 1) (+ n 1) (length str)))\n           \
    \ (append (substring str (- n 1) (+ n 1) (length str)) (substring str n (+ n 1)\
    \ (length str)))))\n  (append (substring string 1 1)\n          (reverse (substring\
    \ string 0 (length (string)))))\n  (cond ((equal? (length string) 0)\n       \
    \  string)\n        ((char=? (substring string 0 1) string)\n         (cons string\
    \ (substring string 1 1)))\n        (else\n         (append (substring string\
    \ 0 (- 1 (length string)))\n                 (substring string 1 (length (string))))\n\
    \         (cons (reverse (substring string 0 (- 1 (length string))))\n       \
    \        (substring string 1 (length (string))))))))\n", "  (let ([len (string-length\
    \ string)])\n    (let loop ([i 0]\n               [postfix string])\n      (if\
    \ (< i (- len 1))\n          (begin (set! postfix (string-append (reverse postfix)\
    \ (string i len)))\n                (loop (+ i 1) postfix))\n          postfix)))))\n",
  "  (define (find-palindrome-start string i)\n    (cond\n      [(empty? string) (or\
    \ (eq? string #\\space) (eq? string #\\newline))]\n      [else (or (find-palindrome-start\
    \ (rest string) (rem i 2))\n                 (eq? (substring string (rem i 1)\
    \ (rem i 2))\n                       (reverse (substring string 0 i)))\n     \
    \              (eq? (reverse string) (substring string 0 i)))]))\n  (define (find-palindrome-string\
    \ string i result)\n    (cond\n      [(empty? string) (if (eq? string #\\space)\
    \ (cons #\\space result) result)]\n      [else (if (eq? string #\\newline) (cons\
    \ #\\newline result) result)]))\n  (define (palindrome? string)\n    (cond\n \
    \     [(empty? string) false]\n      [else (eq? (reverse string) (substring string\
    \ 0 (length string)))]))\n  (define (find-palindrome string result)\n    (cond\n\
    \      [(empty? string) (if (palindrome? string) (cons string result) result)]\n\
    \      [else (find-palindrome-string string (rem (length string) 2)\n        \
    \                           (if (palindrome? (substring string (rem (length string)\
    \ 1) (rem (length string) 2)))\n                                      (cons string\
    \ result)\n                                      result))]))\n  (find-palindrome\
    \ string '())\n)\n", "  (let loop\n    [(prefix string) (list string)\n     (suffix\
    \ string) (list string)\n     (prefix suffix) (list suffix)]\n    (cond\n    \
    \  [(null? prefix) string]\n      [(string? prefix) (make_palindrome (reverse\
    \ prefix))]\n      [(string? suffix) (make_palindrome (append (make_palindrome\
    \ (reverse suffix)) string))]\n      [else (append (make_palindrome (reverse suffix))\
    \ (make_palindrome (reverse prefix))) ])))\n", "  (let ((len (string-length string))\n\
    \        (palindrome))\n    (cond\n      [(zero? len) (string palindrome)]\n \
    \     [(string=? string (reverse (string-slice string 0 (- len 1)))) (string palindrome)]\n\
    \      [else (make_palindrome (string-append string (reverse (string-slice string\
    \ (- len 1)))))]\n    )\n  )\n)\n", "  (let ((longest (longest-palindrome string)))\n\
    \    (string (substring string 0 (- (length string) (length longest))))\n    (append\
    \ string (reverse-string (substring string 0 (- (length string) (length longest)))))\n\
    ))\n", "  (let loop ((string string) (rev string) (i (string-length string)) (prev\
    \ string))\n    (if (< i 0)\n        (reverse prev)\n        (if (equal? (string-ref\
    \ string i) (string-ref prev (- i 1)))\n            (loop string (append (reverse\
    \ prev) (string-ref string i)) (- i 1) prev)\n            (loop string (append\
    \ prev (string-ref string i)) (- i 1) (string-ref string i))))))\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis algorithm is quite elegant, but is inefficient\
    \ for longer strings: for strings longer than 1,000,000 characters it will take\
    \ over 30 seconds on my computer to complete this algorithm.\n<|/ c |>\n<| c |>\n\
    : That sounds like it might be a limitation of Racket or its interpreter. Maybe\
    \ you should try it with a different compiler or interpreter.\n<|/ c |>\n<| c\
    \ |>\n: I tested the algorithm on a string of 10,000 characters and it took 10\
    \ milliseconds. Racket was 3.1.4, so I think it must be something in the implementation.\n\
    <|/ c |>\n<| c |>\n: You're right, it seems to be a limitation of Racket or its\
    \ interpreter. I'll report it to their bugzilla. Thanks.\n<|/ c |>\n<| c |>\n\
    : I tried it in Ruby 1.9.2 (via RubyInstaller) and it took 5 milliseconds! RubyInstaller's\
    \ Ruby 1.9.1 installer actually installs Racket 2.1, and the performance was actually\
    \ worse; it took 10 times longer.\n<|/ c |>\n<| a |>\nIn case anybody is interested,\
    \ here is the solution I arrived at:\n<code>", "  (let* ((len (length string))\n\
    \         (chars (string->list string))\n         (len0 (- len 1))\n         (chars0\
    \ (subseq chars 0 (- len 0)))\n         (chars (subseq chars 1 len))\n       \
    \  (chars0 (subseq chars0 1 len0)))\n    (cond\n      [(empty? string) (append\
    \ (subseq (list chars) 1) (subseq (list chars0) 1))]\n      [(equal? (first string)\
    \ (first (first chars))) (append (make_palindrome (rest string)) (make_palindrome\
    \ (subseq (list chars) 1))]\n      [else (append (make_palindrome (rest string))\
    \ (make_palindrome (subseq (list chars) 1))]\n      )\n    )\n  )\n", "  (define\
    \ (longest string)\n    (if (string-empty? string)\n        '\n        (let ((length\
    \ (string-length string)))\n          (string-append (substring (string 0 (length\
    \ length / 2))) (longest (substring (string length / 2) length))))))\n  (let ((longest\
    \ (longest string)))\n    (string-append (string-append (substring (string 0 (length\
    \ string)) longest) (substring reverse (string 0 longest))) string)))\n", "  (let\
    \ ((length (string-length string))\n        (start-index (string->list (substring\
    \ string 0 length))))\n    (let loop ((start-index start-index)\n            \
    \   (end-index (+ length 1)))\n      (if (>= end-index start-index)\n        \
    \  (if (substring string start-index end-index) (string-append string (string->string\
    \ (string->reverse (string-substring string start-index (- end-index start-index)))))\n\
    \              (string-append string (string->string (string->reverse (string-append\
    \ start-index (substring string end-index (+ start-index 1))))))))\n    (loop)))\n",
  "  (let ((longest-palindrome (make-palindrome-helper string)))\n    (append string\
    \ (reverse (subseq string 0 (- longest-palindrome (length string)))))\n    ))",
  "  (let ((long-post (longest-postfix string)))\n    (if (string-equal? long-post\
    \ string)\n        string\n        (append string (make-palindrome-suffix string\
    \ long-post)))))\n", "  (cond [(empty? string)\n         empty]\n        [else\
    \ (cons (reverse (substring string 0 (string-length string)))\n              \
    \       (make_palindrome (string-append string (substring string 1 (string-length\
    \ string))))])]))\n", "  (let* ((string-length (string-length string))\n     \
    \    (longest-palindromic-length (/ string-length 2))\n         (longest-palindromic-suffix\
    \ (subseq string 0 (* longest-palindromic-length (/ string-length 2))))\n    \
    \     (longest-palindromic-prefix (subseq string (* longest-palindromic-length\
    \ (/ string-length 2)) string-length))\n         (reverse (append longest-palindromic-suffix\
    \ longest-palindromic-prefix)))\n    (if (string=? string reverse)\n        string\n\
    \        (make_palindrome reverse))))\n", "  (if (null? string)\n      \"\"\n\
    \      (let ((reverse-string (reverse string)))\n        (if (equal? (make-postfix\
    \ string reverse-string) string)\n            string\n            (make-postfix\
    \ string (make-reverse-string string reverse-string)))))\n", "  (let ((palindrome\
    \ (make-string (string-length string) ?a)))\n    (let loop ()\n      (let ((reversed-string\
    \ (reverse (string-tail string)))\n            (start 0))\n        (cond\n   \
    \       [(> (string-length string) 0)\n           (loop (+ start (string-length\
    \ string)))]\n          [(reversed-string\n             (string-append reversed-string\
    \ (string-reverse palindrome)))\n           (set! palindrome (string-append palindrome\
    \ reversed-string))\n           (set! string (substring string 0 start))\n   \
    \        (loop (+ start 1))]\n          [else\n           (set! palindrome (string-append\
    \ palindrome reversed-string))])))))\n</code>\n<|/ a tags=functional-programming,scheme,racket,algorithm,haskell\
    \ |>\n<| c |>\nI like this answer the best because it is simple and elegant, but\
    \ I've decided to accept the other one because it is simpler.\n<|/ c |>\n<| a\
    \ dscore=1 tags=functional-programming,scheme,racket,algorithm,haskell |>\nIn\
    \ Haskell you can also do:\n<code>\nimport Data.List\nimport Data.Maybe\n", " \
    \ (let loop ((reverse (make-string-ref string 0))\n             (str (make-string-ref\
    \ string 0))\n             (palindrome (make-string-ref string 0))\n         \
    \    (len (string-length string))\n             (len2 (string->length string))\n\
    \             (len3 (string->length str))\n             (i 0))\n    (cond ((<\
    \ len 1) (reverse p))\n          ((eq? i len2) (reverse p))\n          ((eq? i\
    \ len3) (if (string=? p (make-string-ref str len3) i) (reverse p)))\n        \
    \  ((eq? i 0)\n           (append p (reverse (make-string-ref str len3))))\n \
    \         ((< (- len2 (- i len)) (reverse p))\n           (loop (reverse (make-string-ref\
    \ str len2) (str reverse p)\n                       (make-string-ref str len3)\
    \ p\n                       (- len2 (- i len)) (- i len) (+ i 1))))))\n", "  (let\
    \ loop ((start (string-length string))\n             (end (min start (string-length\
    \ string))))\n    (if (> start end)\n        \"\"\n        (let ((palindromic\
    \ (substring (string start end)\n                                  (substring\
    \ (string start (string-length string) end)\n                                \
    \  (string-length string))))\n              (postfix \"~a\" (string-reverse palindromic)))\n\
    \          (string-append postfix string))))\n</code>\n<|/ a tags=racket,algorithm,string-manipulation,string\
    \ dscore=0 |>\n<| c |>\nIt's a good idea to check whether `end` is already less\
    \ than `start`, to avoid unnecessary work after `loop` has finished.\n<|/ c |>\n\
    <| a tags=racket,algorithm,string-manipulation,string |>\nThis solution is not\
    \ tail recursive and will use a lot of memory\n<code>\n#lang racket\n", "  (let\
    \ ([longest longest (reverse longest \"\")])\n    (if (palindrome? string)\n \
    \       (begin (+ string longest) (+ string longest))\n        (begin (+ string\
    \ longest) (+ string longest)))))\n", "  (let loop ((i 0)\n             (palindrome\
    \ \"\"))\n    (if (> i (string-length string))\n        palindrome\n        (loop\
    \ (+ i 1)\n              (append (substring string i 1)\n                    \
    \  (substring (string-reverse (string-slice string 0 i)) (string-length string)))))))\n\
    </code>\n<|/ a tags=string,racket |>\n<| c |>\nI do not understand how this code\
    \ can produce a palindrome. Please clarify.\n<|/ c |>\n<| c |>\nI added some comments.\
    \ Maybe it's clearer now.\n<|/ c |>\n<| c |>\nThank you!  Now I understand how\
    \ this works. Your solution is nice and clear.\n<|/ c |>\n<| c |>\nNice, but still\
    \ not very efficient, because you are building the result string up in memory,\
    \ but building it in a second pass in reverse. Also, you forgot to check for a\
    \ palindrome at the end. :)\n<|/ c |>\n<| c |>\nI see now your solution is even\
    \ more efficient because it builds the palindrome in reverse order. Thank you.\n\
    <|/ c |>\n<| a tags=string,racket dscore=2 |>\nI think that the problem is in\
    \ the append line.\nI replaced it with\n<code>", "  (let ([palindromic string\n\
    \         prefix (reverse (string-append palindromic \"a\"))\n         suffix\
    \ (reverse (string-append prefix \"a\"))])\n    (assert (equal? (string-length\
    \ palindromic) (string-length suffix))\n            (error \"Palindromic length\
    \ does not match original length\" palindromic suffix))\n    (assert (equal? (string-length\
    \ (string-append suffix palindromic)) (string-length prefix))\n            (error\
    \ \"Postfix length does not match prefix length\" suffix prefix))\n    (string-append\
    \ prefix palindromic)))\n", "  (let loop\n    ( (longest-postfix longest-postfix-length\
    \ longest-postfix-index string empty-string empty-string-length) (index-count\
    \ 0)\n      (index-count 0)\n      (index 0)\n      (string string)\n      (longest-postfix\
    \ empty-string empty-string-length) (index-count 0) (index 0) (longest-postfix-length\
    \ empty-string-length) (index-count 0) (index 0))\n    (if (string= longest-postfix\
    \ empty-string)\n      longest-postfix empty-string-length)\n    (if (< index-count\
    \ 5)\n      longest-postfix empty-string-length)\n    (if (string= longest-postfix\
    \ empty-string)\n      longest-postfix empty-string-length)\n    (if (< index-count\
    \ 5)\n      longest-postfix empty-string-length)\n    (if (< index-count 5)\n\
    \      longest-postfix empty-string-length)\n    (if (< index-count 5)\n     \
    \ longest-postfix empty-string-length)\n    (if (< index-count 5)\n      longest-postfix\
    \ empty-string-length)\n    (if (< index-count 5)\n      longest-postfix empty-string-length)\n\
    \    (if (< index-count 5)\n      longest-postfix empty-string-length)\n    (if\
    \ (< index-count 5)\n      longest-postfix empty-string-length)\n    (if (< index-count\
    \ 5)\n      longest-postfix empty-string-length)\n    (if (< index-count 5)\n\
    \      longest-postfix empty-string-length)\n    (if (< index-count 5)\n     \
    \ longest-postfix empty-string-length)\n    (if (< index-count 5)\n      longest-postfix\
    \ empty-string-length)\n    (if (< index-count 5)\n      longest-postfix empty-string-length)\n\
    \    (if (< index-count 5)\n      longest-postfix empty-string-length)\n    (if\
    \ (< index-count 5)\n      longest-postfix empty-string-length)\n    (if (< index-count\
    \ 5)\n      longest-postfix empty-string-length)\n    (if (< index-count 5)\n\
    \      longest-postfix empty-string-length)\n    (if (< index-count 5)\n     \
    \ longest-postfix empty-string-length)\n    (if (< index-count 5)\n      longest-postfix\
    \ empty-string-length)\n    (if (< index-count 5)\n      longest-postfix empty-string-length)\n\
    \    (if (< index-count 5)\n      longest-postfix empty-string-length)\n    (if\
    \ (< ", "  (let loop ((string string)\n             (palindrome empty)\n     \
    \        (i 0))\n    (if (null? string)\n        palindrome\n        (loop (cdr\
    \ string)\n              (cons (car string) palindrome)\n              (+ i 1)))))\n",
  "  (let loop ([start 0] [end (string-length string)] [string string]\n         \
    \    [len 0] [palindrime \"\"] [result \"\"] [prefix \"\"])\n    (cond\n     \
    \ [(string= end (substring string start end)) (display result)\n       (display\
    \ end) (inc)\n       (loop (+ start 1) end (string-append string\n           \
    \                              (reverse (string-append prefix string)))))]\n \
    \     [(and (char= (string-ref string start) (string-ref string end))\n      \
    \     (string= (string-ref string end) (substring string start end)))\n      \
    \ (set! len (+ start len))\n       (set! palindrome (string-append palindrome\
    \ (string-append (string-ref string start) (string-ref string end))))\n      \
    \ (loop (+ start 1) end (string-append string prefix))\n       (set! start len)]\n\
    \      [(string= start (substring string start end)) (loop (+ start 1) end (string-append\
    \ prefix string \"\"))]\n      [(and (not (char= (string-ref string start) (string-ref\
    \ string end)))\n             (char= (string-ref string end) (string-ref string\
    \ start)))\n       (loop (+ start 1) end (string-append prefix string \"\"))]\n\
    \      [(string= start end) (loop (+ start 1) end (string-append prefix string\
    \ \"\"))]\n      [(string= start end) (display end) (display start) (inc)]))\n\
    \  result)\n</code>\n<|/ a tags=string,scheme |>\n<| a tags=string,scheme |>\n\
    <code>", "  (let ([palindrome-start (longest-palindrome-start string)])\n    (cond\
    \ [(empty? string)\n           (error \"Empty input\")]\n          [(>= palindrome-start\
    \ 0)\n           (concat string (reverse (substring string 0 palindrome-start)))]\n\
    \          [else\n           (make_palindrome (substring string palindrome-start))]))\n\
    </code>\n<|/ a tags=recursion,palindrome,racket,scheme |>\n<| c |>\nThis doesn't\
    \ work for strings of length <= 7 or so.\n<|/ c |>\n<| a tags=recursion,palindrome,racket,scheme\
    \ |>\n<code>", "  (let ((palindrome-length (string-length string))\n        (palindrome-tail\
    \ (substring string 0 palindrome-length))\n        (reversed-tail (substring string\
    \ palindrome-length)))\n    (let loop ((start (length palindrome-tail))\n    \
    \           (end 0))\n      (if (= start end)\n          string\n          (let\
    \ ((prefix (substring string 0 (+ start (- end start))))\n                (suffix\
    \ (substring string end (+ start end))))\n            (cond\n              [(palindrome-tail\
    \ = suffix (reverse prefix)]\n              [(empty? prefix) (concat prefix reversed-tail\
    \ palindrome-tail)]\n              [(empty? suffix) (concat reversed-tail prefix\
    \ palindrome-tail)]\n              [else (concat prefix loop (make-tail palindrome-tail\
    \ (reverse suffix))))])))))\n", "  (let ([last (substring string 0 (string-length\
    \ string))])\n    (append string\n            (substring (string-reverse last)\
    \ 0 (string-length last)))))\n", "  (let ((found (find-longest-palindrome string)))\n\
    \    (cond\n      ((null? found) string)\n      (else (append (reverse (substring\
    \ string 0 found)) (substring string found (length string)))))\n    )\n  )\n",
  "  (let ((longest-postfix null))\n    (loop for c (strreverse string)\n        \
    \  for i = 0 below string-length do\n            (when (palindrome? i c c c)\n\
    \              (set! longest-postfix (cons (substring string i (add1 i)) longest-postfix)))\n\
    \          while (null? longest-postfix)\n          reverse longest-postfix)))\n",
  "  (let ((prefix-length (string-length string))\n        (palindromic-length (string-length\
    \ string))\n        (suffix-length (string-length string))\n        (palindrome-suffix\
    \ (make-string\n                             (+ (- palindromic-length suffix-length)\
    \ 1)\n                             '#)))\n    (define (check suffix suffix-length)\n\
    \      (cond\n        ((null? suffix)\n         (make-string palindromic-length\
    \ #\\space))\n        ((= suffix-length palindromic-length)\n         (make-string\
    \ palindromic-length #\\space))\n        ((string-equal string (reverse suffix))\n\
    \         (make-string palindromic-length string))\n        (else\n         (make-string\
    \ palindromic-length\n                     string\n                     (reverse\
    \ suffix))))\n    (check-for-palindrome-suffix suffix\n                      \
    \        check\n                              suffix-length\n                \
    \              palindrome-suffix))", "  (let ([i (string-length string)\n    \
    \     j (string-length string)\n         l (string->list string)])\n    (cond\n\
    \      [(= i j) string]\n      [(= i 0) (string->list string)]\n      [(string->list\
    \ (substring string 0 i))\n       (append l (make_palindrome (substring string\
    \ i (- i 1))))]\n      [else\n       (append l (make_palindrome (substring string\
    \ i (- i 1))) (substring string 0 (+ i j)))])))\n", "  (let ((reverse-prefix (reverse\
    \ (append string 'cata'))))\n    (append reverse-prefix string)))\n</code>\nA\
    \ bit more efficient version of this algorithm, perhaps, but less readable:\n\
    <code>", "  (cond [(empty? string) \"\"]\n        [(equal? (first string) (string-reverse\
    \ (first string)))\n         (cons (first string) (string-reverse (first string)))]\n\
    \        [else (cons (make_palindrome (string-append (first string) (append (string-reverse\
    \ (first string)) (string-append (first string) (string-reverse (first string))))))]))\n",
  "  (let ((longest-palindrome (find-longest-palindrome string)))\n    (cond [(null?\
    \ longest-palindrome) (error \"No longest palindrome found for ~a\" string)]\n\
    \          [else (cons (string-append (string-reverse (string-prefix-before longest-palindrome))\n\
    \                                  longest-palindrome)\n                     \
    \   string)])))\n", "  (cond [(empty? string) \"\"]\n        [(string? (cdr string))\
    \ (cons (reverse (car string)) (make_palindrome (cdr string)))]\n        [else\
    \ (string) (make_palindrome (string)(cdr string))]))\n", "  (define (longest_palindromic_suffix\
    \ start end)\n    (cond\n      [(> start end) (substring string 0 end)]\n    \
    \  [(equal? (substring string start (+ start 1))\n                (longest_palindromic_suffix\
    \ (+ start 1) end))\n       (substring string start (+ start 1))]\n      [(equal?\
    \ (substring string end (- end 1))\n                (longest_palindromic_suffix\
    \ start (- end 1)))\n       (substring string end (- end 1))]))\n  (cond\n   \
    \ [(equal? string \"\") \"\"]\n    [(equal? string \"cat\") \"\"]\n    [(equal?\
    \ string \"cata\") \"\"]\n    [else (concat (reverse\n                    (longest_palindromic_suffix\
    \ 0 (string-length string))\n                    string)))]))\n", "  (let ((longest-palindromic-suffix\
    \ (longest-palindromic-suffix string)))\n    (let ((string-prefix (string-prefix\
    \ string)))\n      (if (or (< string-prefix longest-palindromic-suffix)\n    \
    \          (equal? (reverse string-prefix) longest-palindromic-suffix))\n    \
    \      string\n          (string-prefix (reverse (string-prefix longest-palindromic-suffix))))))))\n",
  "  (define (make_postfix start stop)\n    (let ((len (substring string start stop)))\n\
    \      (if (= len 0)\n          stop\n          (let ((len (substring string start\
    \ (add1 stop))))\n            (set! string (reverse (string-append string (reverse\
    \ (substring string start stop)))))))))\n  (define (make_prefix start stop)\n\
    \    (let ((len (substring string start stop)))\n      (if (= len 0)\n       \
    \   stop\n          (let ((len (substring string (add1 start) stop)))\n      \
    \      (set! string (string-append (substring string start stop) (reverse (substring\
    \ string start stop))))))))\n  (define (make_palindrome_suffix start stop)\n \
    \   (let ((len (substring string start stop)))\n      (if (= len 0)\n        \
    \  stop\n          (let ((len (substring string (add1 start) stop)))\n       \
    \     (set! string (string-append (substring string start (add1 stop)) (reverse\
    \ (substring string start stop)))))))))\n  (define (longest_palindromic suffix)\n\
    \    (if (> (string-length string) 0)\n        (let ((start (string-length string)))\n\
    \          (make-postfix start (add1 start))\n          (longest_palindromic suffix)))\n\
    \    suffix))\n  (define (longest_palindrome_suffix suffix)\n    (if (> (string-length\
    \ string) 0)\n        (let ((start (string-length string)))\n          (make-prefix\
    \ start (add1 start))\n          (longest_palindrome_suffix suffix)))\n    suffix))\n\
    \  (define (longest_palindrome suffix)\n    (let ((len (string-length string)))\n\
    \      (if (= len 0)\n          suffix\n          (let ((len (string-length string)))\n\
    \            (if (= len 0)\n                suffix\n                (let ((len\
    \ (string-length string)))\n                  (if (= len 0)\n                \
    \      suffix\n                      (let ((len (string-length string)))\n   \
    \                     (if (= len 0)\n                            suffix\n    \
    \                        (let ((len (string-length string)))\n               \
    \               (if (= len 0)\n                                  suffix\n    \
    \                              (let ((len (string-length string)))\n         \
    \                           (if (= len 0)\n                                  \
    \      suffix\n                                        (let ((len (string-length\
    \ string)))\n                                          (if (= len 0)\n       \
    \                                       suffix\n                             \
    \                 (let ((len (string-length string)))\n                      \
    \                          (if (= len 0)\n                                   \
    \                 (", "  (let loop ((max-length (string-length string))\n    \
    \         (longest string)\n             (palindrome (substring (append (substring\
    \ string 0 max-length) (append (substring string max-length) (reverse (substring\
    \ string 0 max-length)))) 0 (string-length string)))\n             (found '#t)\
    \ ; found\n\n             (i 0 (+ i 1)) ; index\n\n             (palindromes (list\
    \ palindrome))\n             (palindrome-length (string-length palindrome))\n\
    \             (next-length (+ palindrome-length (length palindrome)))\n\n    \
    \         (longest-length (string-length longest))\n             (longest-post\
    \ (substring longest 0 (- (+ i 1) longest-length)))\n             (longest-palindrome\
    \ (substring palindrome 0 (- (+ i 1) palindrome-length)))\n             (longest-suffix\
    \ longest))\n    (cond ((null? string) (string-append (string \"\") palindromes))\n\
    \          ((= i max-length) (string-append (string \"\") palindromes))\n    \
    \      (else (loop (+ i 1)\n                      (if (< i max-length)\n     \
    \                     (string-append (substring string 0 i) longest-post)\n  \
    \                        longest)\n                      palindromes\n       \
    \               palindrome-length\n                      (if (< i max-length)\n\
    \                          (string-append (substring string (i) max-length) (append\
    \ longest-palindrome (substring string (i) max-length) (substring string 0 (+\
    \ i 1))))\n                          longest)\n                      longest-length\n\
    \                      longest-post\n                      longest-palindrome\n\
    \                      longest-suffix)))\n          )\n  )\n", "  (let ((prefix\
    \ (substring string 0 (length string)))\n        (suffix (substring string 1 (length\
    \ string))))\n    (cond ((equal? string (make-palindrome-of prefix suffix))\n\
    \           (append prefix (reverse suffix)))\n          ((equal? (reverse string)\
    \ (make-palindrome-of (substring string 1 length) (substring string 0 (length\
    \ string)))))\n          ((equal? (substring string 0 (length string)) (make-palindrome-of\
    \ (substring string 1 length) (substring string 1 (length string))))\n       \
    \   ((equal? (substring string 0 (length string)) (make-palindrome-of prefix (reverse\
    \ suffix)))\n          (else\n           (make-palindrome-of prefix (reverse suffix)))))\n",
  "  (let ((l (length string))\n        (a (substring string 0 (l/2))))\n    (if (=\
    \ l 0)\n        string\n        (append-to-string string reverse\n           \
    \             (make_palindrome (substring string 1 (l-a)))\n                 \
    \       string))))\n", "  (cond [(empty? string) \"\"]\n        [(equal? (car\
    \ string) (string-reverse (cdr string)))\n         (cons string \"\")]\n     \
    \   [else (cons (car string) (string-reverse (make_palindrome (string-reverse\
    \ (car string))))))))\n", "  (let ((length (string-length string))\n        (reverse\
    \ (string->list (substring (string 0 length) 0 0)))\n        (prefix string))\n\
    \    (let loop ((i 0) (reverse reverse) (i-length 0))\n      (if (< (length i)\
    \ (i-length))\n          (begin\n            (set! reverse (append reverse string->list\
    \ (substring (string i i) 0 0))\n                          (string->list (substring\
    \ (string 0 i) 0 0)))\n          (begin\n            (set! prefix (substring string\
    \ 0 i)\n                       (cons i prefix))\n            (set! i (+ i 1))\n\
    \            (set! reverse\n                  (append reverse (string->list (substring\
    \ reverse 0 0))\n                          (string->list (substring reverse 0\
    \ 0))))\n            (set! i-length (+ i-length 1))\n            (if (< (length\
    \ i) (i-length))\n                (loop (+ i 1) reverse (i-length))\n        \
    \        (begin (set! reverse\n                          (append reverse (string->list\
    \ (substring reverse 0 0))\n                                  (string->list (substring\
    \ reverse 0 0))))\n                      (set! i (+ i 1))\n                  \
    \    (set! prefix (cons i prefix))))))))\n", "  (let loop ((string string) (palindromic\
    \ ''))\n    (if (empty? string)\n        palindromic\n        (loop (cdr string)\
    \ (append palindromic (reverse (car string)))))\n    (loop '() '')))\n", "  (let\
    \ loop ((i 0)\n             (longest string)\n             (prefix null?)\n  \
    \           (suffix null?))\n    (cond ((= i (string-length string)) longest)\n\
    \          ((string-eql? string (substring longest i (string-length string)))\n\
    \           (loop (+ i 1)\n                 longest prefix\n                 longest\
    \ suffix))\n          ((string-eql? (substring string i (string-length string))\n\
    \                        (substring longest 0 (string-length longest)))\n    \
    \       (loop (+ i 1)\n                 longest prefix\n                 longest\
    \ suffix\n                 (cons (string-reverse (substring longest i (string-length\
    \ longest))) prefix)))\n          (else\n           (loop (+ i 1)\n          \
    \       longest prefix\n                 longest suffix\n                 (cons\
    \ (substring string i (string-length string))\n                       prefix\n\
    \                       (cons (substring longest 0 (string-length longest))\n\
    \                              suffix)))))))\n", "  (if (null? string)\n     \
    \ string\n      (let ((max (reverse string))\n            (min (string-append\
    \ string max)))\n        (if (= (string-length max) (string-length min))\n   \
    \         max\n            (if (< min (string-length max))\n                min\n\
    \                (string-append (reverse max) (string-append min max)))))))\n",
  "  (let ((longest_postfix \n         (longest-palindrome-postfix string)))\n   \
    \ (if (null? longest_postfix)\n        string\n        (append string\n      \
    \          (append (string (string-reverse longest_postfix))\n               \
    \         (longest-palindrome-postfix longest_postfix))))))\n", "  (let ((r (reverse\
    \ string))\n        (p (substring string 0 (- (string-length string) 1)))\n  \
    \      (n (substring string 1 (string-length string))))\n    (set! p (reverse\
    \ p))\n    (set! string (append p string))\n    (set! n (reverse n))\n    (set!\
    \ string (string-append string n))))\n", "  (define (longest-palindrome s)\n \
    \   (let* ((len (string-length s))\n           (suffix (substring s 0 len))\n\
    \           (prefix (substring s len -1)))\n      (cond [(= len 0)\n         \
    \    '']\n            [(empty? prefix)\n             '']\n            [(equal?\
    \ (string prefix) (string-reverse prefix))\n             suffix]\n           \
    \ [(equal? (string prefix) (string suffix))\n             (longest-palindrome\
    \ (substring s 0 (+ len 1)))]\n            [else (longest-palindrome (substring\
    \ s 0 (- len 1)))])))\n  (longest-palindrome string))\n", "  (let ((result (cons\
    \ string '')))\n    (loop for i from 0 to (string-length string)\n          for\
    \ s = substring (string 0 i) (substring (string i string))\n          for p =\
    \ (reverse s)\n          for j = (string-length p)\n          for c = (p (+ j\
    \ j))\n          for x = c (- j j)\n          for r = result do\n            (cond\n\
    \              [(eq? (car p) (car r)) (cons (car r) result)]\n              [(eq?\
    \ (car x) (car r)) (cons (car r) result)]\n              [(eq? (car r) (car p))\
    \ (cons (car r) result)]\n              [else (cons (car r) (cons x (cons c r)))]))))",
  "  (if (string? string)\n      (append string (string-reverse (string-ref string\
    \ 0)))\n      string))\n", "  (let ([len (string-length string)]\n        [post\
    \ (reverse (substring string 0 (len - 1)))]\n        [left (substring string 1\
    \ (len - 1))])\n    (if string? (string-ref string 0)\n      (cons post (make_palindrome\
    \ left))\n      (cons string post))))\n", "  (define (append string reversed)\n\
    \    (if (empty? reversed)\n      string\n      (append (rest reversed) (cons\
    \ (car string) reversed))\n      )\n    )\n\n  (define (prefix_palindrome-suffixes\
    \ prefix)\n    (let loop ((length (string-length prefix))\n                (longest\
    \ 0))\n      (cond\n        ((empty? prefix) longest '())\n        ((eq? (string-ref\
    \ prefix length) (string-ref prefix length longest length)) longest longest longest\
    \ '())\n        ((< length longest length) (loop (+ longest 1) (+ length 1)))\n\
    \        ((eq? (string-ref prefix length) (string-ref prefix longest length))\
    \ (loop (+ longest 1) (+ length 1)))\n        ((< length longest length) (loop\
    \ (+ longest 1) (+ length 1)))\n        ((eq? (string-ref prefix length) (string-ref\
    \ prefix longest length)) (loop (+ longest 1) (+ length 1)))\n        ((eq? (string-ref\
    \ prefix length) (string-ref prefix longest length)) (loop (+ longest 1) (+ length\
    \ 1)))\n        (else (loop (+ longest 1) (+ length 1))))\n    )\n\n  (define\
    \ (longest_palindrome-suffix longest length)\n    (cond\n      ((empty? longest\
    \ length) '())\n      ((eq? (string-ref longest length) (string-ref longest length\
    \ longest length)) (longest_palindrome-suffixes longest length (+ length 1)))\n\
    \      (else (longest_palindrome-suffixes longest length (+ length 1))))\n\n \
    \ (define (longest_palindrome prefix)\n    (let loop ((longest '()))\n      (cond\n\
    \        ((empty? prefix) (longest longest longest))\n        ((eq? (string-ref\
    \ prefix length) (string-ref prefix length longest length)) (longest_palindrome-suffixes\
    \ longest length (+ length 1)))\n        ((< length longest length) (loop (cons\
    \ (car prefix) longest)))\n        ((eq? (string-ref prefix length) (string-ref\
    \ prefix longest length)) (longest_palindrome-suffixes longest length (+ length\
    \ 1)))\n        ((< length longest length) (loop (cons (car prefix) longest)))\n\
    \        ((eq? (string-ref prefix length) (string-ref prefix longest length))\
    \ (longest_palindrome-suffixes ", "  (let ((p (reverse string))\n        (ps (append\
    \ string p)))\n    (cond [(empty? ps) string]\n          [(equal? ps p) string]\n\
    \          [(equal? p (last ps)) string]\n          [else (make_palindrome ps)]))\n\
    </code>\nAnd here's an implementation using Racket (a Lisp dialect of Scheme)\
    \ which uses lists:\n<code>\n#lang racket\n", "  (define (append suffix prefix)\n\
    \    (cond ((equal? (string-length prefix) 0)\n           (string-append suffix\
    \ prefix))\n          ((equal? (string-length suffix) 0)\n           (string-append\
    \ prefix suffix))\n          (else\n           (string-append (substring suffix\
    \ 0 string-length (string-reverse prefix)) (substring prefix 0 string-length (string-reverse\
    \ suffix))))))\n\n  (define (search string prefix)\n    (cond ((equal? (string-length\
    \ string) 0)\n           prefix)\n          ((equal? (string-length prefix) 0)\n\
    \           (search string (substring string 0 (string-length string)))) ; No\
    \ more characters\n          (else\n           (search (substring string 0 (string-length\
    \ prefix))\n                   (append (substring string 0 (string-length string))\n\
    \                          (substring string 0 (string-length prefix))))))))\n\
    \n  (search string \"\"))\n", "  (let loop ((longest (max 0 (string-length string)))\n\
    \             (result (substring string 0 (min longest string-length)))\n    \
    \         (reverse (substring string 0 (min longest string-length)))\n       \
    \      (prefix string))\n    (if (< (string-length string) longest)\n        (loop\
    \ (+ longest string-length) (substring result 0 longest) (substring reverse 0\
    \ longest) (concat prefix result))\n        (concat prefix result))))\n", "  (let\
    \ ((longest-postfix (longest-postfix-of string string))\n        (start 0) (end\
    \ (length string)))\n    (if (or (not (> end start))\n            (equal? string\
    \ (reverse (reverse (substring string start end))))\n            ;; (equal string\
    \ (reverse (string-reverse string)))\n            ;; (string=? string (reverse\
    \ (string-reverse string)))\n            (equal? string (reverse (substring string\
    \ start longest-postfix)))\n            (equal? (substring string 0 longest-postfix)\
    \ (substring string longest-postfix end)))\n        string \"\")))\n", "  (define\
    \ (length string &optional (length 0))\n    (if (empty? string)\n        length\n\
    \        (length (subseq string 1 length) (+ length 1))))\n  (define (append l\
    \ r) (concat l r))\n  (define (prefix string &optional (start 0))\n    (if (empty?\
    \ string)\n        \"\"\n        (subseq string start)))\n  (define (suffix string\
    \ &optional (end (string-length string)))\n    (if (empty? string)\n        string\n\
    \        (subseq string (+ end 1))))\n  (define (postfix string)\n    (append\
    \ (suffix string) (append (suffix string) (append (prefix string) (append (prefix\
    \ string) (append string \"\"))))))\n  (define (longest string &optional (length\
    \ 0))\n    (if (< length 0)\n        0\n        (max (length string) (longest\
    \ string (subseq string 0 length))))\n  (define (postfix_suffix string &optional\
    \ (suffix \"\"))\n    (if (empty? string)\n        (append suffix \"\")\n    \
    \    (postfix_suffix (subseq string 1) (append suffix (reverse (subseq string\
    \ 0 longest)))))\n  (postfix_suffix (postfix string) (append (postfix string)\
    \ (append (postfix string) (append string \"\"))))\n  (postfix_suffix string \"\
    \"))\n", "  (let ((longest-post (longest-postfix string)))\n    (append string\
    \ (longest-post string)))))\n", "  (define (helper string reverse reverse-pos\
    \ longest-pos longest-length) \n    (if (null? string)\n        (if (= longest-length\
    \ 0)\n            (cons (reverse string) reverse)\n            (helper (rest string)\
    \ reverse (rest reverse) longest-pos longest-length))\n        (if (> (length\
    \ string) longest-pos)\n            (helper (rest string) (reverse (rest reverse))\
    \ (+ longest-pos 1) (length string))\n            (helper (rest string) (reverse\
    \ reverse) (+ longest-pos 1) (length string))))\n  (helper string '() 0 0 (length\
    \ string)))\n</cell>\n<cell>", "  (define prefix (reverse (substring string 0\
    \ (string-length string))))\n  (if (equal? (make-string (string-length string)\
    \ string)\n              (substring string 0 (string-length string)))\n      string\n\
    \      (append prefix (reverse (substring string 0 (string-length string))))))\n\
    </code>\n<|/ a |>\n<| c |>\nYes, you're correct, but this question is tagged [tag:racket],\
    \ so I wanted to share my solution in Racket as well.  It's just not that different\
    \ from what you wrote.\n<|/ c |>\n<| a |>\nMy version using substring and reverse\
    \ functions:\n<code>"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
