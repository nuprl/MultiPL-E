name: HumanEval_154_cycpattern_check
language: rkt
prompt: "#lang racket\n\n;; You are given 2 words. You need to return True if the\
  \ second word or any of its rotations is a substring in the first word\n;; cycpattern_check(\"\
  abcd\",\"abd\") => False\n;; cycpattern_check(\"hello\",\"ell\") => True\n;; cycpattern_check(\"\
  whassup\",\"psus\") => False\n;; cycpattern_check(\"abab\",\"baa\") => True\n;;\
  \ cycpattern_check(\"efef\",\"eeff\") => False\n;; cycpattern_check(\"himenss\"\
  ,\"simen\") => True\n(define (cycpattern_check a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n\
  \    (check-equal? (candidate \"xyzw\" \"xyw\") #f)\n    (check-equal? (candidate\
  \ \"yello\" \"ell\") #t)\n    (check-equal? (candidate \"whattup\" \"ptut\") #f)\n\
  \    (check-equal? (candidate \"efef\" \"fee\") #t)\n    (check-equal? (candidate\
  \ \"abab\" \"aabb\") #f)\n    (check-equal? (candidate \"winemtt\" \"tinem\") #t)\n\
  ))\n\n(test-humaneval)"
completions: ["  (cond\n    [(and (string=? (substr b 0 (string-length a)) a)\n  \
    \        (string-empty? b))\n     (string=? b a)]\n    [else\n     (false)]))\n",
  "  (cond\n    ((null? a) #f)\n    ((null? b) #f)\n    ((string-match? a b) #t)\n\
    \    ((string-match? (substring a 0 b) (substring b 0 a)) #t)\n    (else (cycpattern_check\
    \ (substring a b) (substring b a)))))\n", "  (define (match a-1 b-2)\n    (or\
    \ (char=? a-1 b-2) (char=? a-2 b-1)))\n  (define (match a-2 b-3)\n    (or (char=?\
    \ a-1 b-3) (char=? a-2 b-2) (char=? a-3 b-1)))\n  (define (match a-3 b-4)\n  \
    \  (or (char=? a-1 b-4) (char=? a-2 b-3) (char=? a-3 b-2) (char=? a-4 b-1)))\n\
    \  (define (match a-4 b-5)\n    (or (char=? a-1 b-5) (char=? a-2 b-4) (char=?\
    \ a-3 b-3) (char=? a-4 b-2) (char=? a-5 b-1)))\n  (define (match a-5 b-6)\n  \
    \  (or (char=? a-1 b-6) (char=? a-2 b-5) (char=? a-3 b-4) (char=? a-4 b-3) (char=?\
    \ a-5 b-2) (char=? a-6 b-1)))\n  (define (match a-6 b-7)\n    (or (char=? a-1\
    \ b-7) (char=? a-2 b-6) (char=? a-3 b-5) (char=? a-4 b-4) (char=? a-5 b-3) (char=?\
    \ a-6 b-2) (char=? a-7 b-1)))\n  (define (match a-7 b-8)\n    (or (char=? a-1\
    \ b-8) (char=? a-2 b-7) (char=? a-3 b-6) (char=? a-4 b-5) (char=? a-5 b-4) (char=?\
    \ a-6 b-3) (char=? a-7 b-2) (char=? a-8 b-1)))\n  (define (match a-8 b-9)\n  \
    \  (or (char=? a-1 b-9) (char=? a-2 b-8) (char=? a-3 b-7) (char=? a-4 b-6) (char=?\
    \ a-5 b-5) (char=? a-6 b-4) (char=? a-7 b-3) (char=? a-8 b-2) (char=? a-9 b-1)))\n\
    \  (define (match a-9 b-10)\n    (or (char=? a-1 b-10) (char=? a-2 b-9) (char=?\
    \ a-3 b-8) (char=? a-4 b-7) (char=? a-5 b-6) (char=? a-6 b-5) (char=? a-7 b-4",
  "  (cond ((or (empty? a) (empty? b)) #f)\n        ((= (length b) (length a)) #t)\n\
    \        ((contains-all (substring b 0 (- (length b) 1)) (substring a 0 (- (length\
    \ a) 1))) #t)\n        (else (cycpattern_check (substring a 0 (- (length a) 1))\
    \ b))))\n", "  (cond ((null? b) false)\n        ((equal? (substring (string a)\
    \  (substring (string b) 0 (length b)) (substring (string a)  0 (length a)) )\n\
    \                (substring (string a) 0 (length a)) )\n        (else (begin (cycpattern_check\
    \ (substring (string a)  (substring (string b) 0 (length b)) (substring (string\
    \ a)  0 (length a)) ) \n                (substring (string a) 0 (length a)) )))))\n",
  "  (if (or (empty? a) (empty? b))\n      true\n      (or\n         (string=? (substring\
    \ b 0) a)\n         (string=? (substring b 1) a)\n         (string=? (substring\
    \ b 1) (substring a 0))\n         (string=? (substring b 0) (substring a 0))\n\
    \         (string=? (substring b 1) (substring a 1))\n         (string=? (substring\
    \ b 0) (substring a 1))\n         (string=? (substring b 1) (substring a 2))\n\
    \         (string=? (substring b 0) (substring a 2))\n         (string=? (substring\
    \ b 1) (substring a 3))\n         (string=? (substring b 0) (substring a 3))\n\
    \         (string=? (substring b 1) (substring a 4))\n         (string=? (substring\
    \ b 0) (substring a 4))\n         (string=? (substring b 1) (substring a 5))\n\
    \         (string=? (substring b 0) (substring a 5))\n         (string=? (substring\
    \ b 1) (substring a 6))\n         (string=? (substring b 0) (substring a 6))\n\
    \         (string=? (substring b 1) (substring a 7))\n         (string=? (substring\
    \ b 0) (substring a 7))\n         (string=? (substring b 1) (substring a 8))\n\
    \         (string=? (substring b 0) (substring a 8))\n         (string=? (substring\
    \ b 1) (substring a 9))\n         (string=? (substring b 0) (substring a 9))\n\
    \         (string=? (substring b 1) (substring a 10))\n         (string=? (substring\
    \ b 0) (substring a 10))))\n", "  (or (member a b) (member b a) (member (string-append\
    \ a (b (string-append \"a\" (b \"\"))))\n                             (string-append\
    \ b (a \"\"))))\n", "  (cond ((or (equal? a b) (null? a)) #f)\n        (else (and\
    \ (equal? (string-length a) (string-length b)) (or (substring a 0 (string-length\
    \ a)) (substring b (string-length b)))))))", "  (cond [(string? a) (string? b)\
    \ (equal? a (string-reverse b))]\n        [else (cond\n                 [(or (char?\
    \ (car a)) (char? (car b)))\n                   (equal? (string-reverse a) (string-reverse\
    \ b))]\n                 [else (equal? a (string-reverse b))])]))\n", "  (or (string-includes?\
    \ a b)\n      (string-includes? b a)\n      (substring? a b 1) ; or use \"#\"\n\
    \      (substring? b a 1))\n)\n", "  (cond\n    [(empty? a) (empty? b) empty]\n\
    \    [(substring b 0 (length a)) (empty? a) empty]\n    [(substring a 0 (length\
    \ b)) (b empty) empty]\n    [(substring a 0 (length b) (cons (reverse b) (list\
    \ a)) empty) (b empty) empty]\n    [else (substring a 0 (length b) (cons (reverse\
    \ b) (list a)) empty) (b empty) (cycpattern_check a (cycpattern_rotate b b))]))\n",
  "  (or (= (length a) 0)\n      (= (length b) 0)\n      (and (member (car a) (car\
    \ b))\n           (member (car b) (car a))\n           (member (cadr a) (cadr\
    \ b))\n           (member (cadr b) (cadr a))))))\n", "  (cond\n    [(empty? a)\
    \ true]\n    [(empty? b) false]\n    [(equal a (substring b 0 1)) true]\n    [else\
    \ (cycpattern_check (substring b 0 1)\n                           (substring a\
    \ 0 1 +)))]))\n", "  (cond [(empty? b) #t]\n        [(cons? (subseq a (length\
    \ b)))\n         (and (subseq b (length a)) (subseq b (length a)))]\n        [(equal?\
    \ a (subseq a (length b)))\n         (equal? (subseq a (length b)) b)]\n     \
    \   [(equal? (subseq a (length b)) b)\n         (equal? a (subseq a (length b)))]\n\
    \        [else\n         (or (equal? (subseq a (length b)) b)\n             (equal?\
    \ (subseq a (length b)) (subseq b 0)))))\n", "  (cycpattern_check_c (reverse a)\
    \ b))\n", "  (cond ((equal? a b) true)\n        ((equal? a (cycpattern_rotate\
    \ (cycpattern_rotate (cycpattern_rotate a b)) (cycpattern_rotate a (cycpattern_rotate\
    \ a b)))))\n        (else false)))\n", "  (cond\n    [(empty? b) #t]\n    [(empty?\
    \ a) #f]\n    [(substring b 0 (string-length a)) #t]\n    [else (or (substring\
    \ a 0 (string-length b))\n               (substring b 0 (string-length a)))]\n\
    \  )\n)\n", "  (cond\n    [(empty? a) true]\n    [(empty? b) false]\n    [else\n\
    \     (let\n       ((c (length b))\n        (d (length a)))\n       (cond\n  \
    \       [(< c d)\n          (and (eq? (substring b 0) (substring a 0))\n     \
    \         (eq? (substring b (- c)) (substring a (- d)))\n              (eq? (substring\
    \ b c) (substring a d))\n              (eq? (substring b 0) (substring a d)))]\n\
    \         [(eq? c d)\n          (and (eq? (substring b 0) (substring a 0))\n \
    \             (eq? (substring b c) (substring a d))\n              (eq? (substring\
    \ a 0) (substring b c)))]\n         [else\n          (and (eq? (substring a 0)\
    \ (substring b 0))\n              (eq? (substring a (- c)) (substring b (- d)))\n\
    \              (eq? (substring a c) (substring b d))\n              (eq? (substring\
    \ a 0) (substring b d)))]))]))", "  (cond [(null? b) true]\n        [(equal? (substring\
    \ a 0 1) (substring b 0 1)) false]\n        [else (cycpattern_check (substring\
    \ a 1 ) (substring b 0 ))]))\n", "  (cond\n    ((empty? a) false)\n    ((empty?\
    \ b) false)\n    ((string-member? b (substring (last a) (first a))) true)\n  \
    \  ((string-member? (substring (first a) (last a)) b) true)\n    ((string-member?\
    \ (substring (first a) (first a)) b) true)\n    ((string-member? (substring (last\
    \ a) (first a)) b) true)\n    ((string-member? b a) true)\n    ((string-member?\
    \ (substring (first a) b) a) true)\n    ((string-member? (substring (last a) b)\
    \ a) true)\n    ((string-member? (substring (last a) (first a)) b) true)\n   \
    \ ((string-member? (substring (last a) (first a)) b) true)\n    ((string-member?\
    \ b a #t) false)\n    ((string-member? (substring (first a) (last a)) b #t) false)\n\
    \    ((string-member? (substring (first a) (first a)) b #t) false)\n    ((string-member?\
    \ (substring (last a) (first a)) b #t) false)\n    ((string-member? (substring\
    \ (last a) (last a)) b #t) false)\n    ((string-member? b a #t) false)\n    ((string-member?\
    \ (substring (first a) (last a)) b #t) false)\n    ((string-member? (substring\
    \ (last a) (first a)) b #t) false)\n    ((string-member? (substring (last a) (last\
    \ a)) b #t) false)\n    ((string-member? b a #t) false)\n    ((string-member?\
    \ (substring (first a) (first a)) b #t) false)\n    ((string-member? (substring\
    \ (last a) (first a)) b #t) false)\n    ((string-member? (substring (last a) (last\
    \ a)) b #t) false)\n    ((string-member? b a #t) false)\n    ((string-member?\
    \ (substring (first a) (first a)) b #t) false)\n    ((string-member? (substring\
    \ (last a) (first a)) b #t) false)\n    ((string-member? (substring (last a) (last\
    \ a)) b #t) false)\n    ((string-member? b a #t) false)\n    ((string-member?\
    \ (substring (first a) (first a)) b #t) false)\n    ((string-member? (substring\
    \ (last a) (first a)) b #t) false)\n    ((string-member? (substring (last a) (last\
    \ a)) b ", "  (cond\n    [(empty? b) true]\n    [(string-subset-p (first b) (first\
    \ a)) (cycpattern_check (rest a) (rest b))]\n    [else false]))\n", "  (cond\n\
    \    [(string=? (string-ref a 0) (string-ref b 0)) false]\n    [(string=? (string-ref\
    \ a 0) (string-ref b 1)) true]\n    [(string=? (string-ref a 1) (string-ref b\
    \ 0)) true]\n    [(string=? (string-ref a 1) (string-ref b 1)) false]\n    [else\
    \ false]))\n</code>\n<|/ a tags=string,racket,pattern-matching dscore=1 |>\n<|\
    \ c |>\nThank you for your help but this code doesn't do what I want. I need to\
    \ test if any permutation of the given word is in the first word. So `cycpattern_check(\"\
    abcd\",\"abd\")` should return false because `bcd` is not in `abcd` but `abcd`\
    \ contains `bcd`. `cycpattern_check(\"hello\",\"ell\")` should return true because\
    \ `ell` is in `hello` and `hello` contains `ell`. `cycpattern_check(\"whassup\"\
    ,\"psus\")` should return false because `psus` is not in `whassup` but `whassup`\
    \ contains `psus`. `cycpattern_check(\"abab\",\"baa\")` should return true because\
    \ `baa` is in `abab` and abab contains `baa`. `cycpattern_check(\"efef\",\"eeff\"\
    )` should return false because `eeff` is not in the first word and efef contains\
    \ eeff but it contains `eeff`. `cycpattern_check(\"himenss\",\"simen\")` should\
    \ return true because `simen` is in `himenss` and himenss contains simen.\n<|/\
    \ c |>\n<| c |>\nAh sorry I misread that. I\u2019ll look at it when I get back\
    \ later today, I\u2019m on a phone at the moment.\n<|/ c |>\n<| c |>\nI looked\
    \ at this problem again and realized I made a mistake. I'll post an answer shortly.\n\
    <|/ c |>\n<| c |>\nThank you for your help but this code doesn't do what I want.\
    \ I need to test if any permutation of the given word is in the first word. So\
    \ `cycpattern_check(\"abcd\",\"abd\")` should return false because `bcd` is not\
    \ in `abcd` but `abcd` contains `bcd`. `cycpattern_check(\"hello\",\"ell\")` should\
    \ return true because `ell` is in `hello` and `hello` contains `ell`. `cycpattern_check(\"\
    whassup\",\"psus\")` should return false because `psus` is not in `whassup` ",
  "  (cond ((or (eq? a \"\")\n               (eq? b \"\"))\n         true)\n     \
    \   ((equal? (substring a 0 (string-length a)) (substring b 0 (string-length b)))\n\
    \         true)\n        (else (or (equal? (substring a 0 (string-length a)) (substring\
    \ b (- (string-length a) 1)))\n                   (equal? (substring b (- (string-length\
    \ b) 1)) (cycpattern_check (substring a 0 (string-length a)) (substring b (- (string-length\
    \ b) 1))))\n                   (equal? (substring a 0 (string-length a)) (substring\
    \ b (- (string-length b) 1))))))\n", "  (or (equal? (string-match? b a) #t)\n\
    \      (equal? (string-match? b (make-string (string-length b) #\\z)) #t)))\n",
  "  (or (char-subset? b (string-ref a 0)) \n      (map (lambda (x) (rotate-to-left\
    \ x)) b)))\n", "  (cond\n    [(empty? a)\n     (empty? b)]\n    [(member (substring\
    \ b 0)\n              (substring a 0))\n     (cycpattern_check (substring a 0)\n\
    \                       (substring b 0))]\n    [(member (substring b 1)\n    \
    \          (substring a 0))\n     (cycpattern_check (substring a 0)\n        \
    \               (substring b (- 1 1)))]\n    [(member (substring b 2)\n      \
    \        (substring a 0))\n     (cycpattern_check (substring a 0)\n          \
    \             (substring b (- 2 1)))]\n    [else\n     (or\n      (equal? (substring\
    \ a 0)\n              (substring b 0))\n      (equal? (substring a 0)\n      \
    \        (substring b (- 1 0)))\n      (equal? (substring a 0)\n             \
    \ (substring b (- 2 0)))\n      (equal? (substring a 0)\n              (substring\
    \ b (- 3 0)))\n      (equal? (substring a 0)\n              (substring b (- 4\
    \ 0)))\n      (equal? (substring a 0)\n              (substring b (- 5 0)))\n\
    \      (equal? (substring a 0)\n              (substring b (- 6 0)))\n      (equal?\
    \ (substring a 0)\n              (substring b (- 7 0)))\n      (equal? (substring\
    \ a 0)\n              (substring b (- 8 0)))\n      (equal? (substring a 0)\n\
    \              (substring b (- 9 0)))\n      (equal? (substring a 0)\n       \
    \       (substring b (- 10 0)))\n      (equal? (substring a 0)\n             \
    \ (substring b (- 11 0)))\n      (equal? (substring a 0)\n              (substring\
    \ b (- 12 0)))\n      (equal? (substring a 0)\n              (substring b (- 13\
    \ 0)))\n      (equal? (substring a 0)\n              (substring b (- 14 0)))\n\
    \      (equal? (substring a 0)\n              (substring b (- 15 0)))\n      (equal?\
    \ (substring a 0)\n              (substring b (- 16 0)))\n      (equal? (substring\
    \ a 0)\n              (substring b (- 17 0)))\n      (equal? (substring a 0)\n\
    \              (substring b (- 18 0)))\n      (equal? (substring a 0)\n      \
    \        (substring b (- 19 0)))\n      (equal? (sub", "  (cond\n    [(empty?\
    \ a) (empty? b) false]\n    [(equal a b) (empty? a) true]\n    [(equal? (string-index\
    \ a (cycpattern_head b))\n              (string-index b cycpattern_head a))\n\
    \     (empty? a) false]\n    [else (cycpattern_check a (cycpattern_tail b))]))\n",
  "  (cond ((equal? (string-length a) (string-length b))\n         (equal? (string-match\
    \ (string-to-chars a) (string-to-chars b))\n                   (string-match (string-to-chars\
    \ (substring-from b\n                                                        \
    \   0 (string-length b))\n                                        (string-to-chars\
    \ (substring-from a\n                                                        \
    \              0 (string-length a)))))))\n        (else (equal? (string-match\
    \ (string-to-chars a) (string-to-chars b))\n                      (string-match\
    \ (string-to-chars (substring-from b\n                                       \
    \                          (string-length b)\n                               \
    \                                  (string-length a))\n                      \
    \                  (string-to-chars (substring-from a\n                      \
    \                                                0 (string-length a)))))))))\n\
    </code>\n<|/ a tags=algorithm,string,regex |>\n<| c |>\nThanks for your answer.\
    \ I guess I forgot to mention that I dont want to use string operations to do\
    \ this. I think it would be very inefficient.\n<|/ c |>\n<| a |>\nIn terms of\
    \ speed, I believe a regex is the best. I implemented an algorithm that iterates\
    \ over the patterns once. \nA naive algorithm that would take O(n^2) time would\
    \ look like this:\n<code>\nbool isSubstring(string, string) {\n  if(string.length\
    \ <= pattern.length) \n    return false;\n\n  for(int i = 0; i < pattern.length;\
    \ ++i) {\n    int count = 0;\n    bool found = false, lastFound = false;\n   \
    \ for(int j = 0; j < string.length; ++j) {\n      if(string[j] == pattern[i])\
    \ {\n        ++count;\n        if(count == pattern.length) found = true;\n   \
    \   } else if(found && count == pattern.length){\n        lastFound = true;\n\
    \        break;\n      }\n    }\n    if(found && lastFound) return true;\n  }\n\
    \n  return false;\n}\n</code>\nI implemented this in a recursive function, which\
    \ is quite fast for small strings, and can be optimized in terms of time using\
    \ divide and conquer (divide the string into substrings until the length of the\
    \ string divided by the length of each pattern is less than the number of patterns\
    \ and then check the last substring against every pattern). \n<code>\nbool isSubstringRecursive(string\
    \ s, string pattern) {\n  if(s.length <= pattern.length) {\n    if(s == pattern)\
    \ return true;\n  }\n\n  int n = pattern.length;\n\n  for(int i = 0; i < s.length;\
    \ ++i) {\n    bool found = false;\n    for(int j = 0; j < n; ++j) {\n      if(s[i]\
    \ != pattern[j]) {\n        found = false;\n        break;\n      }\n      if(j\
    \ == n - 1 && found) return true;\n    }\n\n    if(found) {\n      n = n / 2;\n\
    \      if(n <= pattern.length) continue;\n    }\n\n    return isSubstringRecursive(s.substr(0,\
    \ i), pattern)\n        && isSubstringRecursive(", "  (cond\n    [(empty? b) true]\n\
    \    [else (if (equal? a (cycpattern_check b (rest b))) true false)]\n  ))\n",
  "  (or (cycpattern_check_b b a)\n      (cycpattern_check_a b a)))\n", "  (if (or\
    \ (char=? a #\\A)\n          (char=? a #\\z)\n          (char=? a #\\0))\n   \
    \   (if (or (char=? b #\\A)\n              (char=? b #\\z)\n              (char=?\
    \ b #\\0))\n          (if (char=? b a) (char=? a b))\n          #f)\n      (if\
    \ (char=? b a) (char=? a b))\n      (cycpattern_check (substring a 1 -1) (substring\
    \ b 1 -1)))\n", "  (or (= 0 (string-length a (string-length b))\n         (string-length\
    \ b (string-length a))\n         (= (string-length a) (string-length b))\n   \
    \      (= (string-length a) (string->int (b (string-length a)))\n           (string->int\
    \ (a (string-length a)))\n           (string->int (a (string-length a))))))\n",
  "  (or (equal? (string-find a b) (string-find b a))\n      (or (string-find a\n\
    \                  (append (reverse (cycpattern_check (string-reverse a) b))\n\
    \                          (reverse (cycpattern_check (string-reverse b) a)))\n\
    \            (string-find b\n                         (append (reverse (cycpattern_check\
    \ (string-reverse a) b))\n                                (reverse (cycpattern_check\
    \ (string-reverse b) a))))))\n", "  (cond\n    [(equal? a b)      true]\n    [(equal?\
    \ (substring a 0) (substring b 0)) false]\n    [(equal? (substring a 1) (substring\
    \ b 1)) false]\n    [(equal? (substring a 2) (substring b 2)) false]\n    [else\
    \ (equal? (substring a 3) (substring b 3)) false]\n    [else (equal? (substring\
    \ a 4) (substring b 4)) false]\n    [else (equal? (substring a 5) (substring b\
    \ 5)) false]\n    [else (equal? (substring a 6) (substring b 6)) false]\n    [else\
    \ (equal? (substring a 7) (substring b 7)) false]\n    [else (equal? (substring\
    \ a 8) (substring b 8)) false]\n    [else (equal? (substring a 9) (substring b\
    \ 9)) false]\n    [else (equal? (substring a 10) (substring b 10)) false]\n  \
    \  [else (equal? (substring a 11) (substring b 11)) false]\n    [else (equal?\
    \ (substring a 12) (substring b 12)) false]\n    [else (equal? (substring a 13)\
    \ (substring b 13)) false]\n    [else (equal? (substring a 14) (substring b 14))\
    \ false]\n    [else (equal? (substring a 15) (substring b 15)) false]\n    [else\
    \ (equal? (substring a 16) (substring b 16)) false]\n    [else (equal? (substring\
    \ a 17) (substring b 17)) false]\n    [else (equal? (substring a 18) (substring\
    \ b 18)) false]\n    [else (equal? (substring a 19) (substring b 19)) false]\n\
    \    [else (equal? (substring a 20) (substring b 20)) false]\n    [else (equal?\
    \ (substring a 21) (substring b 21)) false]\n    [else (equal? (substring a 22)\
    \ (substring b 22)) false]\n    [else (equal? (substring a 23) (substring b 23))\
    \ false]\n    [else (equal? (substring a 24) (substring b 24)) false]\n    [else\
    \ (equal? (substring a 25) (substring b 25)) false]\n    [else (equal? (substring\
    \ a 26) (substring b 26)) false]\n    [else (equal? (substring a 27) (substring\
    \ b 27)) false]", "  (or (string=? b (substring a 0 #lang racket)) (list-contains\
    \ b (substring a 0 #lang racket))))\n", "  (cond ((or (null? a) (null? b)) #t)\n\
    \        ((equal? a b) #f)\n        (else (equal? (substring a 0 end) (substring\
    \ b 0 end)) (cycpattern_check (substring a end end) (substring b end end)))))\n",
  "  (or (string-substring a b)\n      (or (string-rotate a b)\n          (string-rotate\
    \ a (b string)))\n      (or (string-rot b (a string))\n          (string-rot b\
    \ (a (a string))))))\n", '  (or (string=? (string-append a (string-append (b "s")))
    a) (string=? (string-append a (string-append (b "es"))) a) (string=? (string-append
    a (string-append (b "d"))) a) (string=? (string-append a (string-append (b "ed")))
    a) (string=? (string-append a (string-append (b "ing"))) a) (string=? (string-append
    a (string-append (b "ed"))) a) (string=? (string-append a (string-append (b "ed")))
    a) (string=? (string-append a (string-append (b "ed"))) a) (string=? (string-append
    a (string-append (b "ing"))) a) (string=? (string-append a (string-append (b "s")))
    a) (string=? (string-append a (string-append (b "ed"))) a) (string=? (string-append
    a (string-append (b "ing"))) a) (string=? (string-append a (string-append (b "ing")))
    a) (string=? (string-append a (string-append (b "ing"))) a) (string=? (string-append
    a (string-append (b "ing"))) a) (string=? (string-append a (string-append (b "s")))
    a) (string=? (string-append a (string-append (b "e"))) a) (string=? (string-append
    a (string-append (b "e"))) a) (string=? (string-append a (string-append (b "e")))
    a) (string=? (string-append a (string-append (b "e"))) a) (string=? (string-append
    a (string-append (b "e"))) a) (string=? (string-append a (string-append (b "e")))
    a) (string=? (string-append a (string-append (b "e"))) a) (string=? (string-append
    a (string-append (b "s"))) a) (string=? (string-append a (string-append (b "ed")))
    a) (string=? (string-append a (string-append (b "ing"))) a) (string=? (string-append
    a (string-append (b "ing"))) a) (string=? (string-append a (string-append (b "e")))
    a) (string=? (string-append a (string-append (b "s"))) a) (string=? (string-append
    a (string-append (b "e"))) a) (string=? (string-append a (string-append (b "s")))
    a) (string=? (string-append a (string-append (b "s"))) a) (string=? (string-append
    a (string-append (b "s"))) a) (string=? (string-append a (string-append (b "s")))
    a) (', "  (cond\n    [(or (char-alphabetic? a) (char-alphabetic? b)) (and (char-alphabetic?\
    \ a) (char-alphabetic? b))] #t\n    [(char-numeric? a) (and (char-numeric? a)\
    \ (char-numeric? b))] #t\n    [else (and (char-alphabetic? a) (char-numeric? b))]\
    \ #t\n    [else (and (char-numeric? a) (char-alphabetic? b))] #t\n    [else (and\
    \ (char-alphabetic? a) (char-numeric? b))] #t\n    [else (and (char-numeric? a)\
    \ (char-alphabetic? b))] #t\n    [else (and (char-alphabetic? a) (char-alphabetic?\
    \ b))] (and (char-alphabetic? a) (char-alphabetic? b))] #t\n    [else (and (char-numeric?\
    \ a) (char-numeric? b))] #t\n    [else (and (char-alphabetic? a) (char-alphabetic?\
    \ b))] (and (char-alphabetic? a) (char-alphabetic? b))] #t\n    [else (and (char-numeric?\
    \ a) (char-numeric? b))] (and (char-numeric? a) (char-numeric? b))] #t\n    [else\
    \ (and (char-alphabetic? a) (char-alphabetic? b))] (and (char-alphabetic? a) (char-alphabetic?\
    \ b))] #t\n    [else (and (char-numeric? a) (char-numeric? b))] (and (char-numeric?\
    \ a) (char-numeric? b))] #t\n    [else (and (char-alphabetic? a) (char-alphabetic?\
    \ b))] (and (char-alphabetic? a) (char-alphabetic? b))] #t\n    [else (and (char-numeric?\
    \ a) (char-numeric? b))] (and (char-numeric? a) (char-numeric? b))] #t\n    [else\
    \ (and (char-alphabetic? a) (char-alphabetic? b))] (and (char-alphabetic? a) (char-alphabetic?\
    \ b))] #t\n    [else (and (char-numeric? a) (char-numeric? b))] (and (char-numeric?\
    \ a) (char-numeric? b))] #t\n    [else (and (char-", "  (or\n   (= (cycpattern_check_recursive\
    \ a b)\n      true)\n   (= (cycpattern_check_recursive (rotate_left\n        \
    \                         (rotate_left b a)\n                                \
    \ (rotate_left a (rotate_left b a))) b)\n      true)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_left b (rotate_left\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_right b (rotate_right a b))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_right a (rotate_left\
    \ b a))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_left a (rotate_right b a))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_right b (rotate_left\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_right a (rotate_right b a))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_left b (rotate_right\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_left a (rotate_left b b))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_right b (rotate_right\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_right a (rotate_left b b))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_right b (rotate_right\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_left a (rotate_right b a))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_right b (rotate_left\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_right a (rotate_left b b))) b)\n   (= (cycpattern_check_recursive\
    \ (rotate_left a b)\n                               (rotate_left b (rotate_right\
    \ a b))) b)\n   (= (cycpattern_check_recursive (rotate_right a b)\n          \
    \                     (rotate_right a (rotate_right b a))) b)\n   (", "  (or (string=?\
    \ a b)\n      (string-match a (substring (string b) 0 -1))\n      (substring (string\
    \ b) 0 (string-length b))))\n", "  (cond ((= (length a) (length b)) (equal? (substring\
    \ b 0 0) (substring a 0 0))) ; if the lengths are equal\n        (else (or (equal?\
    \ (substring b 0 0) (substring a 0 0)) (equal? (substring b 0 0) (substring a\
    \ 0 1))))) ; if the strings are the same", "  (cond\n    [(empty? a) true]\n \
    \   [(empty? b) false]\n    [else (cycpattern_check (rest a) (b a))]\n    [else\
    \ (cycpattern_check (b a) (rest a))]))\n", "  (cond\n    [(string=? b a) #t]\n\
    \    [(= 0 (string-length a) (string-length b)) #t]\n    [else (cycpattern_check\
    \ (string-append a b) (string-append (b (substring b 0 (string-length a))))) #t]\n\
    \  ))", "  (cycpattern_check_aux (car a) (car b) (cdr a) (cdr b)))\n", "  (cond\
    \ ((null? a) #t)\n        ((null? b) #f)\n        ((string-match a b 0)\n    \
    \     (string-match (substring b 0 (string-length b)) a (string-length a) 0))\n\
    \        (else (cycpattern_check (substring a 0 (string-length a)) (substring\
    \ b 0 (string-length b))))))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi there! Thanks\
    \ for helping me out. I tested it out and it works perfectly for me. Thank you!\n\
    <|/ c |>\n<| c |>\nIf an answer solved your problem, consider [accepting](https://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ it, so that your question is marked as resolved.\n<|/ c |>\n<| c |>\nI accepted\
    \ the answer already! Thanks again for helping out!\n<|/ c |>\n<| a tags=string,algorithm,pattern-matching,common-lisp\
    \ dscore=0 |>\nThis problem is more like a graph problem. If you can represent\
    \ it as a graph, then you can solve it using graph algorithms.\n<|/ a |>\n<| a\
    \ dscore=0 |>\nThis is what I have for you, I hope it helps you. Although it uses\
    \ Racket and probably is not the fastest algorithm but you get the idea. Also,\
    \ here is a link to my github where I test my solutions.\n<code>", "  (= (length\
    \ a) (length b))\n  (cond [(string=? (string-ref b 0) (a-string=? a 0))\n    \
    \     (string-eq? b (string-ref a 0))]\n        [(string=? (string-ref a 0) (a-string=?\
    \ b 0))\n         (string-eq? (string-ref a 1) (b-string=? b 1))]\n        [(string=?\
    \ (string-ref a 0) (a-string=? b 1))\n         (string-eq? (string-ref a 2) (b-string=?\
    \ b 2))]\n        [(string=? (string-ref a 1) (a-string=? b 2))\n         (string-eq?\
    \ (string-ref a 3) (b-string=? b 3))]\n        [else\n         (string-eq? (string-ref\
    \ a 0) (a-string=? b 3))]\n        [else\n         (string-eq? (string-ref a 1)\
    \ (a-string=? b 2))]\n        [else\n         (string-eq? (string-ref a 2) (a-string=?\
    \ b 1))]\n        [else\n         (string-eq? (string-ref a 3) (a-string=? b 0))]))\n",
  "  (cond\n    [(empty? a)                    false]\n    [(member (first a) b) \
    \           true]\n    [(member (second a) (rotate b)) (cycpattern_check (rotate\
    \ b) (rotate (first a)))]))\n", "  (cond ((or (string=? a b)\n             (string=?\
    \ (substring b 0 (- (length b) 1)) (substring a 0 (- (length a) 1)))) #f\n   \
    \     (else #t)))\n", "  (cond\n    [(empty? a) false]\n    [(empty? b) false]\n\
    \    [(eq? (car a) (substring (car b) 0)) (equal? (car b) (cadr a))]\n    [else\
    \ (or (equal? (car a) (substring (car b) 0)) (equal? (cadr a) (substring (car\
    \ b) (car (cdr b)))))]\n  ))\n</code>\n<|/ a |>\n<| c |>\nThis code has nothing\
    \ to do with my question and you did not answer my question!\n<|/ c |>\n<| c |>\n\
    You're right! I revised my answer. I didn't realize that your question was a homework\
    \ question and thought that my answer was helpful.\n<|/ c |>\n<| a dscore=2 |>",
  "  (cond\n    [(empty? a) true]\n    [(empty? b) false]\n    [(equal? (first a)\
    \ last) (cycpattern_check (rest a) (rest b))] \n    [else\n     (equal? (first\
    \ a) (substring (first b) 0 (- (first b) 1)))\n    (cycpattern_check (rest a)\
    \ (cons (second b) (cons (second a) (cycpattern_check (rest a) (rest b))))]\n\
    \    ))\n", "  (or (equal? (string->list b) (string->list a)) (equal? (string->list\
    \ a) (string->list b))))\n", "  (or (string=? b a)\n      (string=? (substring\
    \ b 0 (- (length a) 1)) a)))\n", "  (or (string-contains? b a)\n      (or (string-contains?\
    \ b (reverse a)) (substring a 0 1 b) (substring a (substring a 0 1) 1 b))))\n",
  "  (and (list? a) (list? b))\n  (let ((ac (set-difference (set-add-to-set (list-ref\
    \ a 0) (list-ref b 0)) (set-add-to-set (list-ref a 1) (list-ref b 1)))))\n   \
    \ (or (null? ac)\n        (string-matches-one-of (car ac)\n                  \
    \           (string->list b))))))\n", "  (or (string-contains-substring a b)\n\
    \      (string-contains-substring b (string-upcase a))))\n", "  (or (equal? (string-compare\
    \ a b) 0)\n      (string-contains-substring a b #t:)))\n", "  (or (string=? b\
    \ a)\n      (or (string=? a (substring (make-string (cycle-length a - 1)) (make-string\
    \ (cycle-length b 1))))\n          (or (string=? (substring (make-string (cycle-length\
    \ b)) (make-string (cycle-length a))) b)\n              (or (string=? (substring\
    \ (make-string (cycle-length a + 1)) (make-string (cycle-length b)) b) a)\n  \
    \            (or (string=? (substring (make-string (cycle-length a + 1)) (make-string\
    \ (cycle-length b +1)) a) b)\n                  (or (string=? (substring (make-string\
    \ (cycle-length b +1)) (make-string (cycle-length a +1)) a) b)\n             \
    \         (or (string=? (substring (make-string (cycle-length a +1)) (make-string\
    \ (cycle-length b +1)) a) b)\n                          (or (string=? (substring\
    \ (make-string (cycle-length b +1)) (make-string (cycle-length a +1)) a) b)\n\
    \                              (or (string=? (substring (make-string (cycle-length\
    \ a + 1)) (make-string (cycle-length b +1)) a) b)\n                          \
    \        (or (string=? (substring (make-string (cycle-length b +1)) (make-string\
    \ (cycle-length a +1)) a) b)\n                                      (or (string=?\
    \ (substring (make-string (cycle-length a + 1)) (make-string (cycle-length b +1))\
    \ a) b)\n                                          (or (string=? (substring (make-string\
    \ (cycle-length b +1)) (make-string (cycle-length a +1)) a) b)\n             \
    \                                 (or (string=? (substring (make-string (cycle-length\
    \ a + 1)) (make-string (cycle-length b +1)) a) b)\n                          \
    \                        (or (string=? (substring (make-string (cycle-length b\
    \ +1)) (make-string (cycle-length a +1)) a) b)\n                             \
    \                         (or (string=? (substring (make-string (cycle-length\
    \ a + 1)) (make-string (cycle-length b +1)) a) b)\n                          \
    \                                (cycpattern_check a (substring b 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n\
    </code>\n<|/ a tags=lisp,racket,string,pattern-matching,scheme |>\n<| a |>\n<code>",
  "  (cond\n    [(string-equal b \"\") false]\n    [(string-equal (string->list a)\
    \ (substring (string->list b) 0 0)) true]\n    [else (substring-substring a b\
    \ 0)]))\n", "  (cond\n    [(empty? a)  true]\n    [(empty? b) false]\n    [(equal?\
    \ (first a) (cycpattern_check (rest a) b))  true]\n    [else (or (equal? (first\
    \ b) (cycpattern_check (rest b) (cons (first a) (cycpattern_check (rest a) (b))))\n\
    \              (cycpattern_check (cons (first b) (cycpattern_check (rest a) b)))\n\
    \             )]))\n", "  (cond \n    [(equal? (string-length a 1) 0) #f]\n  \
    \  [(equal? (string-length b 1) 0) #f]\n    [(equal? (string-length b 0) 0) #f]\n\
    \    [(equal? (string-length b 1) 1) #f]\n    [(string-ref a (string-length b)\
    \ 1) (string-ref b (string-length a) 1)] \n    [else (equal? (substring b 0 string-length\
    \ (substring a 0 string-length b)) (substring a 0 string-length (substring b 0\
    \ string-length a)))]))\n", '  (< (string-length a) (string-length b)))', "  (or\
    \ (string=? a b)\n      (member (rotate a b 1) (string=? (substring a 0 (- (length\
    \ a) 1)) b))))\n", "  (cond\n    ((string=? a b) #t)\n    ((null? a) #f)\n   \
    \ ((null? b) #t)\n    ((string=? (string-ref a 0) (string-ref b 0))\n     (string=?\
    \ (string-ref a 1)(string-ref b 1))\n     (string=? (string-ref a 2)(string-ref\
    \ b 2))\n     (string=? (string-ref a 3)(string-ref b 3))\n     (string=? (string-ref\
    \ a 4)(string-ref b 4))\n     (string=? (string-ref a 5)(string-ref b 5))\n  \
    \   (string=? (string-ref a 6)(string-ref b 6))\n     (string=? (string-ref a\
    \ 7)(string-ref b 7))\n     (string=? (string-ref a 8)(string-ref b 8))\n    \
    \ (string=? (string-ref a 9)\n              (string-ref b (- 9 1)))\n     (string=?\
    \ (string-ref a 10)\n              (string-ref b (- 9 2))))\n    ((string=? (string-ref\
    \ a 0)(string-ref b 1))\n     (string=? (string-ref a 1)(string-ref b 0))\n  \
    \   (string=? (string-ref a 2)(string-ref b 2))\n     (string=? (string-ref a\
    \ 3)(string-ref b 3))\n     (string=? (string-ref a 4)(string-ref b 4))\n    \
    \ (string=? (string-ref a 5)(string-ref b 5))\n     (string=? (string-ref a 6)(string-ref\
    \ b 6))\n     (string=? (string-ref a 7)(string-ref b 7))\n     (string=? (string-ref\
    \ a 8)(string-ref b 8))\n     (string=? (string-ref a 9)\n              (string-ref\
    \ b (- 9 1)))\n     (string=? (string-ref a 10)\n              (string-ref b (-\
    \ 9 2))))\n    ((string=? (string-ref a 0)(string-ref b 2))\n     (string=? (string-ref\
    \ a 1)(string-ref b 1))\n     (string=? (string-ref a 2)(string-ref b 0))\n  \
    \   (string=? (string-ref a 3)(string-ref b 3))\n     (string=? (string-ref a\
    \ 4)(string-ref b 4))\n     (string=? (string-ref a 5)(string-ref b 5))\n    \
    \ (string=? (string-ref a 6)(string-ref b 6))\n     (string=? (string-ref a 7)(string-ref\
    \ b 7))\n     (string=? (string-ref a 8)(string-ref b 8))\n     (string=? (string-ref\
    \ a 9)\n              (string-ref b (- 9 1)))\n     (string=? (string-ref a 10)\n\
    \              (string", "  (or (string-equal a b)\n      (loop for i from 0 to\
    \ (string-length a)\n            when (string-substring b i (+ i (string-length\
    \ b))\n                           (substring (substring a i (+ i (string-length\
    \ a)) 1) 0)))))\n", "  (define (match_string str)\n    (define (match_substr str)\n\
    \      (cond\n        [(empty? str) true]\n        [(= (substring str 0) (substring\
    \ str 1)) true]\n        [else false]))\n    (cond\n      [match_string (substring\
    \ b 0 (length a))]\n      [match_string (substring b 0 (length a)-1)]\n      [match_string\
    \ b]\n      [match_string (substring b 1 (length a)-1)]\n      [match_string (substring\
    \ b 1 (length a))]))\n  (match_string b))\n</code>\nThe idea is to create a function\
    \ that checks if the second word is a substring in the first word or any of its\
    \ rotations.\n<|/ a dscore=1 |>\n<| c |>\nThank you, your solution is definitely\
    \ more elegant.\n<|/ c |>\n<| a dscore=0 tags=racket,pattern-matching,string,racket,scheme\
    \ |>\nI actually wrote my own algorithm that does not involve any looping or recursion.\
    \ The algorithm works by making each word of the original string into substrings\
    \ of the original string then checking each substring in the second string with\
    \ each substring in the first string until a match is found. This algorithm works\
    \ for my requirements.\n<code>", "  (cond ((null? a) false)\n        ((equal?\
    \ (car a) (car b)) (cycpattern_check (cdr a) (cdr b)))\n        (else (or (cycpattern_check\
    \ (cdr a) (car b)) (cycpattern_check (car a) (cdr b))))))\n", "  (define (rotate_a\
    \ a n)\n    (if (= n 0)\n        a\n        (rotate_a (substring a n n) (- n 1))))\n\
    \  (if (< (length a) (length b))\n      (equal? (substring b 0 (length a)) (substring\
    \ a 0 (length a)))\n      (equal? (substring a 0 (length a)) (substring b 0 (length\
    \ b))))\n  (equal? (equal? (rotate_a b 1) (substring a 0 (length b)))\n      \
    \    (equal? (rotate_a a 1) (substring b 0 (length a))))\n  (equal? (equal? (rotate_a\
    \ b 2)) (equal? (substring a 0 (length b)) (substring b 0 (length a))))\n  (equal?\
    \ (equal? (rotate_a a 2)) (equal? (substring b 0 (length a)) (substring a 0 (length\
    \ b))))\n  (equal? (equal? (rotate_a b 3)) (equal? (substring a 0 (length b))\
    \ (substring b 0 (length a))))\n  (equal? (equal? (rotate_a a 3)) (equal? (substring\
    \ b 0 (length a)) (substring a 0 (length b))))\n  (equal? (equal? (rotate_a b\
    \ 4)) (equal? (substring a 0 (length b)) (substring b 0 (length a))))\n  (equal?\
    \ (equal? (rotate_a a 4)) (equal? (substring b 0 (length a)) (substring a 0 (length\
    \ b))))\n  (equal? (equal? (rotate_a b 5)) (equal? (substring a 0 (length b))\
    \ (substring b 0 (length a))))\n  (equal? (equal? (rotate_a a 5)) (equal? (substring\
    \ b 0 (length a)) (substring a 0 (length b))))\n  (equal? (equal? (rotate_a b\
    \ 6)) (equal? (substring a 0 (length b)) (substring b 0 (length a))))\n  (equal?\
    \ (equal? (rotate_a a 6)) (equal? (substring b 0 (length a)) (substring a 0 (length\
    \ b))))\n  (equal? (equal? (rotate_a b 7)) (equal? (substring a 0 (length b))\
    \ (substring b 0 (length a))))\n  (equal? (equal? (rotate_a a 7)) (equal? (substring\
    \ b 0 (length a)) (substring a 0 (length b))))\n  (equal? (equal? (rotate_a b\
    \ 8)) (equal? (substring a 0 (length b)) (substring b 0 (length a))))\n  (equal?\
    \ (equal? (rotate_a a 8)) (equal? (substring b 0 (length a)) (substring a 0 (",
  "  (cond ((string=? a b) #t)\n        ((string=? (string-ref a 0) (string-ref b\
    \ 0)) #t)\n        ((string=? (string-ref a 0) (string-ref b 1)) #t)\n       \
    \ ((string=? (string-ref a 1) (string-ref b 0)) #t)\n        ((string=? (string-ref\
    \ a 1) (string-ref b 1)) #t)\n        ((string=? (string-ref a 2) (string-ref\
    \ b 0)) #t)\n        ((string=? (string-ref a 2) (string-ref b 1)) #t)\n     \
    \   ((string=? (string-ref a 3) (string-ref b 0)) #t)\n        ((string=? (string-ref\
    \ a 3) (string-ref b 1)) #t)\n        ((string=? (string-ref a 4) (string-ref\
    \ b 0)) #t)\n        ((string=? (string-ref a 4) (string-ref b 1)) #t)\n     \
    \   ((string=? (string-ref a 5) (string-ref b 0)) #t)\n        ((string=? (string-ref\
    \ a 5) (string-ref b 1)) #t)\n        ((string=? (string-ref a 6) (string-ref\
    \ b 0)) #t)\n        ((string=? (string-ref a 6) (string-ref b 1)) #t)\n     \
    \   (else #f)))", "  (cond ((null? a) true)\n        ((substring? (substring a\
    \ 0) (b (substring a 0)))) \n        ((substring? (substring a 0) (b (substring\
    \ a 0)))) \n        ((substring? (substring a 0) (b (substring a 0)))) \n    \
    \    (else (cycpattern_check (substring a 1) b))))\n", "  (cond [(empty? b) false]\n\
    \        [else (= (cycpattern_check (substring a 0 (string-length a))\n      \
    \                           (substring b 0 (string-length b)))\n             \
    \     (substring a (string-length a) (string-length a))\n                  )]\n\
    \        ))\n", "  (or (equal? (string-length a) (string-length b))\n      (equal?\
    \ (string-length b) (string-length a))\n      (equal? (string-ref a 0) (string-ref\
    \ b 0))\n      (equal? (string-ref b 0) (string-ref a 0))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref b 1) (string-ref a 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref b 1) (string-ref a 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ b 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))\n      (equal? (string-ref\
    \ a 0) (cycpattern_check (string-ref a 1) (string-ref b 1)))))\n", "  (or (string=?\
    \ a b)\n      (string=? (string-rotate a) b)\n      (string=? (string-rotate b)\
    \ a)))\n", "  (define (match pattern1 pattern2 rot1 rot2)\n    (cond\n      [(string=?\
    \ (string-ref pattern1 0)\n                   (string-ref pattern2 0))\n     \
    \  (match (string-downcase (string-ref pattern1 1))\n               (string-downcase\
    \ (string-ref pattern2 1))\n               (string-downcase rot1)\n          \
    \     (string-downcase rot2))]\n      [(string=? (string-ref pattern1 0)\n   \
    \                (string-ref pattern2 0))\n       (match (string-downcase (string-ref\
    \ pattern1 1))\n               (string-downcase rot1)\n               (string-downcase\
    \ (string-ref pattern2 1))\n               (string-downcase rot2))]\n      [(string=?\
    \ (string-ref pattern1 0)\n                   (string-ref pattern2 0))\n     \
    \  (match (string-downcase rot1)\n               (string-downcase (string-ref\
    \ pattern1 1))\n               (string-downcase (string-ref pattern2 1))\n   \
    \            (string-downcase rot2))]\n      [(string=? (string-ref pattern1 0)\n\
    \                   (string-ref pattern2 0))\n       (match (string-downcase rot1)\n\
    \               (string-downcase rot2)\n               (string-downcase (string-ref\
    \ pattern1 1))\n               (string-downcase (string-ref pattern2 1)))]\n \
    \     [(string=? (string-ref pattern1 0)\n                   (string-ref pattern2\
    \ 0))\n       (match (string-downcase rot1)\n               (string-downcase (string-ref\
    \ pattern1 1))\n               (string-downcase rot2)\n               (string-downcase\
    \ (string-ref pattern2 1)))]\n      [(string=? (string-ref pattern1 0)\n     \
    \              (string-ref pattern2 0))\n       (match (string-downcase rot1)\n\
    \               (string-downcase (string-ref pattern1 1))\n               (string-downcase\
    \ rot2)\n               (string-downcase rot2))]\n      [(string=? (string-ref\
    \ pattern1 0)\n                   (string-ref pattern2 0))\n       (match (string-downcase\
    \ (string-ref pattern1 1))\n               (string-downcase (string-ref pattern2\
    \ 1))\n               (string-downcase rot1)\n               (string-downcase\
    \ rot2))]\n      [(string=? (string-ref pattern1 0)\n                   (string-ref\
    \ pattern2 0))\n       (match (string-downcase rot1)\n               (string-downcase\
    \ rot2)\n               (string-downcase rot1)\n               (string-downcase\
    \ (string-ref pattern2 1)))]\n      [(string=? (string-ref pattern1 0)\n     \
    \              (string-ref pattern", "  (or\n   (string-contains-substring a b)\n\
    \   (string-contains-rotated-substring a b)\n  ))\n", "  (cond\n    [(empty? a)\
    \ (empty? b)]\n    [(equal? (first (first a)) (first (first b)))]\n    [(equal?\
    \ (first (first a)) (first (first b)))\n     (cond\n       [(equal? (rest (first\
    \ a)) (rest (first b)))]\n       [(equal? (rest (first a)) (rest (first b)))\n\
    \        (cond\n          [(equal? (first (rest (first a)) (rest (first b))) (first\
    \ (rest (first b)))) True]\n          [else False]])]\n    [(equal? (first (first\
    \ a)) (first (first b)))\n     (cond\n       [(equal? (rest (first a)) (rest (first\
    \ b)))\n        (cond\n          [(equal? (first (rest (first a)) (rest (first\
    \ b))) (first (rest (first b)))) True]\n          [else False]])]\n    [else\n\
    \     (cond\n       [(equal? (first (first a)) (first (first b)))\n        (cond\n\
    \          [(equal? (rest (first a)) (rest (first b)))\n           (cond\n   \
    \          [(equal? (first (rest (first a)) (rest (first b))) (first (rest (first\
    \ b)))) True]\n             [else False]])]\n       [(equal? (first (first a))\
    \ (first (first b)))\n        (cond\n          [(equal? (rest (first a)) (rest\
    \ (first b)))\n           (cond\n             [(equal? (first (rest (first a))\
    \ (rest (first b))) (first (rest (first b)))) True]\n             [else False]])]\n\
    \       [(equal? (first (first a)) (first (first b)))\n        (cond\n       \
    \   [(equal? (rest (first a)) (rest (first b)))\n           (cond\n          \
    \   [(equal? (first (rest (first a)) (rest (first b))) (first (rest (first b))))\
    \ True]\n             [else False]])]\n       [(equal? (first (first a)) (first\
    \ (first b)))\n        (cond\n          [(equal? (rest (first a)) (rest (first\
    \ b)))\n           (cond\n             [(equal? (first (rest (first a)) (rest\
    \ (first b))) (first (rest (first b)))) True]\n             [else False]])]\n\
    \       [(equal? (first (first a)) (first (first b)))\n        (cond\n       \
    \   ", "  (or (eq? (cstr_contains b (cstr_rot13 (cstr_sub a 2))) (cstr_contains\
    \ b (cstr_rot13 (cstr_sub b 2))))\n      (eq? (cstr_contains b (cstr_rot13 (cstr_sub\
    \ a 1))) (cstr_contains b (cstr_rot13 (cstr_sub b 1))))))\n", "  (cond ((string=?\
    \ b a) (equal a b))\n        ((rot13-check (string-to-list a) (string-to-list\
    \ b))\n         (rot13-check (string-to-list b) (string-to-list a)))\n       \
    \ (else false)))\n", "  (or (string=? b a)\n      (let ((s (string-rotate a b)))\n\
    \        (string=? a s))))\n", "  (if (or (string=? a b) (string-length a = (string-length\
    \ b)))\n      (bool->number true)\n      (cond\n        ((char-equal a b) (bool->number\
    \ true))\n        ((char-subset? a b) (bool->number false))\n        ((string=?\
    \ (string->char a) (string->char b)) (bool->number false))\n        ((char-subset\
    \ (string->char a) (string->char b)) (bool->number false))\n        ((string-contains-substring\
    \ a b) (bool->number false))\n        ((string-contains-substring b a) (bool->number\
    \ false))\n        (else (bool->number false))))\n  )", "  (cond (empty? b) true\n\
    \        (empty? a) false\n        ;; Check for string rotation\n        (equal?\
    \ (first a) (first (substring (b 1) 0 (- (length b) 2))))\n        (equal? (first\
    \ (substring b 1 (- (length b) 2))) (first (substring a 0 (- (length a) 2))))\n\
    \        (cycpattern_check (substring b 1 (- (length b) 2)) (substring a 0 (-\
    \ (length a) 2)))\n        ;; Check for substring\n        (equal? (first a) (first\
    \ (substring (b 1) 0 (- (length b) 2)))) (cycpattern_check (substring b 1 (- (length\
    \ b) 2)) a)\n        (equal? (first (substring b 1 (- (length b) 2)) (substring\
    \ a 0 (- (length a) 2))) (cycpattern_check a (b 1)))\n        ;; All other cases\n\
    \        (cycpattern_check (substring b 1 (- (length b) 2)) (substring a 0 (-\
    \ (length a) 2)))\n        (true\n         false)))\n", "  (cond [(empty? b) false]\n\
    \        [(equal? (first a) (first (rest b))) (or (cycpattern_check (rest b) a))\n\
    \         (and (equal? (first a) (cycpattern_check (rest b) a))\n            \
    \   (equal? (first (rest b)) (cycpattern_check a (rest b))))]\n        [else false]))\n",
  "  (cond\n    ((empty? a) b)\n    ((member? (car a) b) b)\n    (else (cycpattern_check\
    \ (cdr a) b))))\n", "  (or (string-match a b)\n      (or\n       (string-match\
    \ (string-reverse a) b)\n       (string-match (string-reverse b) a))))\n", " \
    \ (cond ((empty? b) (empty? a))\n        ((chars-match? (substring (caar b) 0\
    \ (cadar b)) (substring (caar a) 0 (cadar a))) (empty? b) (empty? a))\n      \
    \  (else (or (chars-match? (substring (caar b) 0 (cadar b)) (substring (caar a)\
    \ 0 (cadar a)))\n                  (cycpattern_check (substring (caar b) 1 (cadar\
    \ b)) (substring (caar a) 1 (cadar a)))))\n  )\n)\n", "  (or (string=? b (string-matching\
    \ a b) #:case (insensitive) #:partial-match #:anchored)\n      (string=? b (string-matching\
    \ a b) #:case (partial) #:partial-match #:anchored)\n      (string=? b (string-matching\
    \ a b) #:case (insensitive) #:partial-match #:none)\n      (string=? b (string-matching\
    \ a b) #:case (partial) #:partial-match #:none)))\n", "  (pattern-match (subseq\
    \ b 0 ) (subseq a (length a) ) ))\n", "  (or (string=? b a) (substring b string=?\
    \ a (cycpattern_check (rotate a 1) (cycpattern_check (rotate a 2) (cycpattern_check\
    \ (rotate a 3) (cycpattern_check (rotate a 4)) b))))))\n", "  (cond\n    [(equal?\
    \ a (string-append b))\n     (string-contains b a)]\n    [(string=? (string-length\
    \ a) (string-length b))\n     (string-contains b a)]\n    [(equal? a (string-append\
    \ (string-reverse b)))\n     (string-contains b (string-reverse a))]\n    [(string=?\
    \ (string-length (string-reverse a)) (string-length (string-reverse b)))\n   \
    \  (string-contains b (string-reverse a))]\n    [else false]))\n", "  (cond\n\
    \    [(empty? b) true]\n    [(substring? a (car b)) (cycpattern_check (cdr a)\
    \ b)]\n    [else false]))\n", "  (or (null? b) (null? (string-contains b (substring\
    \ a (cycle-car (subseq b 0)))))) )\n", "  (cond\n    [(string=? a b)\n     (string-contains\
    \ b a)]\n    [(string=? (string-reverse a) (string-reverse b))\n     (string-contains\
    \ b a)]\n    [(string=? (string-reverse a) (string-reverse (string-reverse b)))\n\
    \     (string-contains b a)]\n    [else false]))\n", "  (or\n    (equal? a b)\n\
    \    (equal? (substr_rotate a 1 0) b)\n    (equal? (substr_rotate b 0 1) a)\n\
    \    (equal? (substr_rotate b 1 0) a)\n    (equal? (substr_rotate b 0 1) (substr_rotate\
    \ a 0 1))\n    (equal? (substr_rotate b 0 1) (substr_rotate a 1 0)))\n  )\n",
  "  (cond\n    ((null? a) true)\n    ((string=? (string-ref a 0) (string-ref b 0))\
    \ true)\n    ((string=? (string-ref a 0) (string-ref b 2)) true)\n    ((string=?\
    \ (string-ref a 2) (string-ref b 0)) true)\n    ((string=? (string-ref a 2) (string-ref\
    \ b 2)) true)\n    ((string=? (string-ref a 2) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 0) (string-ref b 2)) true)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 0)) true)\n    ((string=? (string-ref a 2) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 2) (string-ref b 2)) true)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 0)) true)\n    ((string=? (string-ref a 1) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 1) (string-ref b 2)) true)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 1)) true)\n    ((string=? (string-ref a 1) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 1) (string-ref b 2)) true)\n    ((string=? (string-ref a 1) (string-ref\
    \ b 1)) true)\n    ((string=? (string-ref a 0) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 1) (string-ref b 0)) true)\n    ((string=? (string-ref a 1) (string-ref\
    \ b 2)) true)\n    ((string=? (string-ref a 0) (string-ref b 1)) true)\n    ((string=?\
    \ (string-ref a 1) (string-ref b 1)) true)\n    ((string=? (string-ref a 1) (string-ref\
    \ b 2)) true)\n    ((string=? (string-ref a 1) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 0) (string-ref b 0)) true)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 2)) true)\n    ((string=? (string-ref a 0) (string-ref b 1)) true)\n    ((string=?\
    \ (string-ref a 0) (string-ref b 1)) true)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 0)) true)\n    ((string=? (string-ref a 1) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 0) (string-ref b 1)) true)\n    ((string=? (string-ref a 1) (string-ref\
    \ b 1)) true)\n    ((string=? (string-ref a 1) (string-ref b 2)) true)\n    ((string=?\
    \ (string-ref a 1) (string-ref b ", "  (= (length a) (length b))\n  (let ((len1\
    \ (length a))\n        (len2 (length b))\n        (index1 (make-vector len1 #f\
    \ #f))\n        (index2 (make-vector len2 #f #f)))\n    (for ((i 0) (j 0))\n \
    \     (when (equal? j (+ i len1))\n        (set! index1[i] j))\n      (when (equal?\
    \ i (+ j len2))\n        (set! index2[j] i))))\n  (let* ((x (vector-ref a index1))\n\
    \         (y (vector-ref b index2)))\n    (and (equal? (substring x 0 len2)\n\
    \                (substring y 0 len1)))))\n", "  (if (or\n       (string=? (substring\
    \ b 0 (- (string-length a) 1)) a)\n       (string=? (substring b 0 (- (string-length\
    \ a) 2)) (substring a 0 (- (string-length b) 2))))\n      #t\n      #f))\n", " \
    \ (cond\n    [(empty? b) true]\n    [(string_match a (car b)) (cycpattern_check\
    \ (cdr a) (cdr b))]\n    [else false]))\n", "  (define (substr_or_rotated w r)\n\
    \    (cond\n      [(empty? w) #false]\n      [(equal? (string-length r) 0)\n \
    \      (equal? (string-length w) 0)\n       (equal? #true (equal? #false (string-equal?\
    \ w r)))]\n      [(equal? (string-length r) (string-length w))\n       (equal?\
    \ (string-equal? w r))\n       (equal? #true (equal? #false (string-equal? r (substring\
    \ w 0 (string-length r))))))\n      [(equal? r (substring w 0 (string-length r)))\n\
    \       (equal? #true (equal? #false (string-equal? w r)))]\n      [else #false]))\n\
    \  (let ((w (string-split a #\\)))\n    (cond (empty? w) #f\n          [else (or\
    \ (substr_or_rotated w (string-reverse w))\n                    (substr_or_rotated\
    \ w (string-reverse (string-reverse w))))])))\n</code>\n<|/ a tags=string,racket,scheme\
    \ dscore=0 |>\n<| a dscore=0 tags=string,racket,scheme |>\nThis question doesn't\
    \ have an accepted answer but I think it would be great to share the solution,\
    \ which is based on the excellent answer by John Martinson.\n<code>\n#lang racket",
  "  (let loop ([a a] [b b] [p 0] [r 0])\n    (cond ((null? a) (reverse p))\n    \
    \      ((null? b) (reverse r))\n          ((string=? (substring b p (+ (string->list\
    \ (string->string a) 0)) r)\n                    (string->list (string->string\
    \ a)))\n          ((string=? (substring a p (+ (string->list (string->string a)\
    \ 0)) r)\n                    (string->list (string->string b)))\n          (else\n\
    \           (loop (substring a p (+ (string->list (string->string a) 0)) r)\n\
    \                  (substring b p (+ (string->list (string->string b) 0)) r)\n\
    \                  (+ p 1) r)))))\n</code>\n<|/ a tags=algorithm,pattern-matching,racket,string\
    \ |>\n<| c |>\nThank you very much for your help! As I said above, I am not very\
    \ familiar with Racket, but I'll definitely look into this and try to understand\
    \ it better. In the meantime, can you please tell me how you are able to see the\
    \ output of your program? Is it a variable somewhere? If so, how do I make it\
    \ visible in my Racket?\n<|/ c |>\n<| c |>\nWhen you're running the program you\
    \ just have to type in the code you're looking for (the part under `(define (substring\
    \ ... ))`) and you'll see it output.  `(string->list \"abcd\")` gives you `(list\
    \ 'a 'b 'c 'd)` which is then `(string->list \"abcd\")` again.  It doesn't have\
    \ to be in a function, it can be anywhere where you type your code.\n<|/ c |>\n\
    <| c |>\nThank you! That was really helpful. Also, I noticed that you answered\
    \ a similar question in the comments (by Jonathan) about this program. Would you\
    \ please let me know what would be the best way to ask this question? It might\
    \ help my future readers better, as I am new to Stack Overflow and am not familiar\
    \ with its way of asking questions.\n<|/ c |>\n<| c |>\nI posted it as a new question:\
    \ [link](http://stackoverflow.com/questions/13874791/check-if-substring-of-a-string-is-a-substring-of-another-string)\n\
    <|/ c |>\n<| c |>\nPlease don't be discouraged by the downvotes, they're not necessarily\
    \ wrong, but they might have been more constructive than they could have been.\
    \ People who have read this answer or are reading this question in the future ",
  "  (= (length a) (length b)) (substring b (cdr (substring a (length a))) (substring\
    \ a (cdr (substring b (length b))))))\n</code>\nThe solution is obviously not\
    \ easy to read, but it works.\n<|/ a |>\n<| a dscore=0 |>\nThis works well for\
    \ me\n<code>", "  (or (string=? a b) (string=? (string-rotate a 0) b)))\n", " \
    \ (cond [(string=? b a) true]\n        [(string=? (string-reverse b) (string-reverse\
    \ a)) true]\n        [else false]))\n", "  (or (string=? b a)\n      (find-substring\
    \ a b)))\n", "  (cond [(empty? a)\n         (empty? b)]\n        [(equal? (first\
    \ a) (first b))\n         (equal? (second a) (second b))\n         (equal? (third\
    \ (first a)) (third (first b)))\n         (equal? (fourth (first a)) (fourth (first\
    \ b)))]\n        [else\n         (equal? (first (first a)) (first (first b)))\n\
    \         (equal? (first (second a)) (first (second b)))\n         (equal? (first\
    \ (third (first a)) (third (first b)))\n         (equal? (first (fourth (first\
    \ a)) (fourth (first b)))\n         (equal? (second (first a)) (second (first\
    \ b)))\n         (equal? (second (second a)) (second (second b)))\n         (equal?\
    \ (second (third (first a)) (third (first b)))\n         (equal? (second (fourth\
    \ (first a)) (fourth (first b)))\n         (equal? (third (first a)) (third (first\
    \ b)))\n         (equal? (third (second a)) (third (second b)))\n         (equal?\
    \ (third (third (first a)) (third (first b)))\n         (equal? (third (fourth\
    \ (first a)) (fourth (first b)))\n         (equal? (fourth (first a)) (fourth\
    \ (first b)))\n         (equal? (fourth (second a)) (fourth (second b)))\n   \
    \      (equal? (fourth (third (first a)) (fourth (first b)))\n         (equal?\
    \ (fourth (fourth (first a)) (fourth (first b)))\n         (equal? (fifth (first\
    \ a)) (fifth (first b)))\n         (equal? (fifth (second a)) (fifth (second b)))\n\
    \         (equal? (fifth (third (first a)) (fifth (first b)))\n         (equal?\
    \ (fifth (fourth (first a)) (fifth (first b)))\n         (equal? (fifth (fifth\
    \ (first a)) (fifth (first b)))\n         (equal? (fifth (sixth (first a)) (fifth\
    \ (first b)))\n         (equal? (sixth (first a)) (sixth (first b)))\n       \
    \  (equal? (sixth (second a)) (sixth (second b)))\n         (equal? (sixth (third\
    \ (first a)) (sixth (first b)))\n         (equal? (sixth (", "  (cond (equal?\
    \ (length a) 1) (equal? (length b) 1) (equal? (string b (sub1 a)) (string a (sub1\
    \ b))) (equal? (sub1 a 1) (sub1 b 1))\n  (else (cond ((equal? (sub1 b 1) (sub1\
    \ a 1))\n               (equal? (string b (sub1 a)) (string a (sub1 b)))\n   \
    \            (else (cond ((equal? (sub1 a 1) (sub1 b 1))\n                   \
    \        (equal? (string a (sub1 b)) (string b (sub1 a)))\n                  \
    \         (else (equal? (sub1 a 1) (sub1 b 1))\n                             \
    \    (equal? (string a (sub1 b)) (string b (sub1 a)))))))\n          (else (equal?\
    \ (sub1 a 1) (sub1 b 1))\n               (equal? (string b (sub1 a)) (string a\
    \ (sub1 b)))\n               (else (cond ((equal? (sub1 a 1) (sub1 b 1))\n   \
    \                        (equal? (string a (sub1 b)) (string b (sub1 a)))\n  \
    \                         (else (equal? (sub1 a 1) (sub1 b 1))\n             \
    \                    (equal? (string a (sub1 b)) (string b (sub1 a)))))))))\n",
  "  (or (string=? a b)\n      (or (string=? (reverse b) (substring a 0 b (+ 1 b (string-length\
    \ a)))\n                 (string=? (reverse a) (substring a (b + 1) (- 1 b (string-length\
    \ a)))))\n      (cond ((string=? a (reverse b)) #f)\n            (else #t))))\n",
  "  (cond [(equal? (string-length a) (string-length b)) true]\n        [else (string-match\
    \ a b)]))\n", "  (if (null? a)\n      (not (null? b))\n      (or (string=? (substring\
    \ b 0) (substring a 0))\n          (string=? (substring b 0) (substring a 1))\n\
    \          (string=? (substring b 1) (substring a 0))\n          (string=? (substring\
    \ b 1) (substring a 1))\n          (string=? (substring b 2) (substring a 0))\n\
    \          (string=? (substring b 2) (substring a 1))\n          (string=? (substring\
    \ b 3) (substring a 0))\n          (string=? (substring b 3) (substring a 1)))))\n",
  "  (cond [(empty? b) #t]\n        [(substring a (b (- (length a) (length b))))\n\
    \         (substring a (b (- (length a) (b (length a) 1))))] #t\n        [else\n\
    \         (cycpattern_check (tail a (b (- (length a) (length b))))\n         \
    \                  (tail b (b (- (length a) (b (length a) 1))))) #t]))\n", '  (=
    (length a) (length b)))', "  (cond\n    [(string=? (string-length a) (string-length\
    \ b)) true]\n    [(string=? b a) true]\n    [else false]))\n", "  (cond\n    ((=\
    \ (length a) (length b)) (equal? a b))\n    ((string? a) (string? b))\n    (else\
    \ (begin (and (equal? (string-ref b 0 (length b)) (cycpattern_check (string-ref\
    \ a 0 (length a))) (equal? (string-ref a 0 (length a)) (cycpattern_check (string-ref\
    \ b 0 (length b))))) (cycpattern_check (string-ref a 0 (length a)) (string-ref\
    \ b 0 (length b))) ))\n    )\n  )\n)\n", "  (cond\n    [(empty? a) true]\n   \
    \ [(string-match a b) true]\n    [(member (first (split-string b)) a) true]\n\
    \    [else false]))\n", "  (or (string=? (take b a) (take a (- b 1)))\n      (string=?\
    \ (take a (- b 1)) (take b (- a 1)))\n      (list? a) (list? b) (substring a b)))\n",
  "  (cond\n    [(empty? a) (empty? b)]\n    [(equal? a (first b)) (equal? (first\
    \ a) (first b))]\n    [else (cond\n            [(equal? (first (rest b)) (first\
    \ (rest a))) (equal? (first (rest a)) (first (rest b)))]\n            [else (cond\n\
    \                    [(cycpattern_check (rest a) (rest b))]\n                \
    \    [else (cond\n                            [(equal? (first (rest a)) (first\
    \ (first b)))]\n                            [else (cond\n                    \
    \                [(equal? (first (first a)) (first (first b)))]\n            \
    \                        [else (cond\n                                       \
    \     [(cycpattern_check (rest a) (rest b))]\n                               \
    \             [else False])])])])])])\n", "  (cond\n    [(empty? b) true]\n  \
    \  [(string-char-alphabetic? a) (substring b 0 a)]\n    [(empty? a) false]\n \
    \   [else (and (substring b 0 a) (substring a 0 b))]))\n", "  (cond\n    [(empty?\
    \ a) false]\n    [(empty? b) true]\n    [else (or (equal? a b)\n             \
    \  (substring a 0 (- (length a) (length b))))]\n  ))\n", "  (cond [(empty? a)\
    \ #f]\n        [(equal? (first a) (first b)) #t]\n        [else (or (cycpattern_check\
    \ (rest a) b) (or (cycpattern_check (rest b) a) (cycpattern_check (first a) (first\
    \ b))))]))", "  (cond\n    [(empty? a) false]\n    [(empty? b) false]\n    [(equal?\
    \ (first a) (first (rest b)))\n     (or (cycpattern_check (rest a) (rest b)))]\n\
    \    [else (or (cycpattern_check (first a) (first (rest b))) \n              \
    \ (cycpattern_check (rest (first a)) (rest (first b))))]))\n", "  (define (rotated\
    \ word)\n    (append (list word) (apply list (reverse (cdr word)))) ) ;; reverse\
    \ to keep order\n  (define (substr word pattern)\n    (string=? (subseq word 0\
    \ (string-length pattern))\n              pattern)) ;; subseq returns a seq of\
    \ chars\n  (or (= (car a) b)\n      (substr b a)\n      (or (= (string-length\
    \ b) (string-length a))\n          (string-match a b)\n          (string-match\
    \ a rotated b)\n          (string-match b rotated a)\n          (string-match\
    \ rotated a b)\n          (string-match rotated b a)\n          (string-match\
    \ rotated rotated (subseq b 0 (string-length a))))))\n", "  (or (string=? (substring\
    \ b 0 (string-length a))\n                 (substring a 0 (string-length b)))\
    \ \n      (or (string=? (substring b 0 (string-length a) 2)\n                \
    \  (substring a 0 (string-length b) 2))) \n      (or (string=? (substring a 0\
    \ (string-length b))\n                  (substring b 0 (string-length a) 2)) \n\
    \        (or (string=? (substring a 0 (string-length b) 2)\n                 \
    \ (substring b 0 (string-length a) 2)))))\n", "  (define (check x y)\n    (if\
    \ (string-match x (string-append y \"*\")) #t (if (string-match y x) #t #f)))\n\
    \  (check-pattern a b check))\n", "  (if (equal? a b)\n      (begin\n        (set!\
    \ b a)\n        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n\
    \        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n      \
    \  (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set!\
    \ b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13\
    \ b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n\
    \        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n      \
    \  (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set!\
    \ b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13\
    \ b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n\
    \        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n      \
    \  (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set!\
    \ b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13\
    \ b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n\
    \        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n      \
    \  (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set!\
    \ b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13\
    \ b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n\
    \        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n      \
    \  (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set!\
    \ b (string-rot13 b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13\
    \ b))\n        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n\
    \        (set! b (string-rot13 b))\n        (set! b (string-rot13 b))\n      \
    \  (set! b (string-", "  (cond\n    ((string=? a b) #t)\n    ((string-match? b\
    \ (string-upcase a)) #t)\n    ((string-match? (string-downcase a) (string-downcase\
    \ b)) #t)\n    ((string-match? (string-downcase a) (string-downcase b)) #t)\n\
    \    ((string-match? (string-downcase a) (string-downcase b)) #t)\n    ((string-match?\
    \ (string-downcase a) (string-downcase b)) #t)\n    ((string-match? (string-downcase\
    \ a) (string-downcase b)) #t)\n    ((string-match? (string-downcase a) (string-downcase\
    \ b)) #t)\n    ((string-match? (string-downcase a) (string-downcase b)) #t)\n\
    \    ((string-match? (string-downcase a) (string-downcase b)) #t)\n    ((string-match?\
    \ (string-downcase a) (string-downcase b)) #t)\n    ((string-match? (string-downcase\
    \ a) (string-downcase b)) #t)\n    ((string-match? (string-downcase a) (string-downcase\
    \ b)) #t)\n    ((string-match? (string-downcase a) (string-downcase b)) #t)\n\
    \    ((string-match? (string-downcase a) (string-downcase b)) #t)\n    ((string-match?\
    \ (string-downcase a) (string-downcase b)) #t)\n    ((string-match? (string-downcase\
    \ a) (string-downcase b)) #t)\n    ((string-match? (string-downcase a) (string-downcase\
    \ b)) #t)\n    ((string-match? (string-downcase a) (string-downcase b)) #t)\n\
    \    ((string-match? (string-downcase a) (string-downcase b)) #t)\n    ((string-match?\
    \ (string-downcase a) (string-downcase b)) #t)\n    ((string-match? (string-downcase\
    \ a) (string-downcase b)) #t)\n    ((string-match? (string-downcase a) (string-downcase\
    \ b)) #t)\n    ((string-match? (string-downcase a) (string-downcase b)) #t)\n\
    \    ((string-match? (string-downcase a) (string-downcase b)) #t)\n    ((string-match?\
    \ (string-downcase a) (string-downcase b)) #t)\n    ((string-match? (string-downcase\
    \ a) (string-downcase b)) #t)\n    ((string-match? (string-downcase a) (string-downcase\
    \ b)) #t)\n    ((string-match? (string-downcase a) (string-downcase b)) #t)\n\
    \    ((string-match? (string-downcase a) (string-downcase b)) #t)\n    ((string-match?\
    \ (string-downcase a) (string", "  (cond ((or (string-match? a b) (string-match\
    \ a b)) (equal? a b))\n        ((string-match? b a) (equal? a b))\n        ((string-match\
    \ b a) (equal? a b))\n        (else (or (string-match? a b) (string-match a b))))\n\
    )\n", "  (cond\n    [(empty? a) (empty? b) false]\n    [(eq? (car a) (car b))\
    \ (cycpattern_check (cdr a) (cdr b))]\n    [else (cycpattern_check (cdr a) (cdr\
    \ b) (cdr a))]\n  ))", "  (cond\n    [(empty? b) #t]\n    [(empty? a) false]\n\
    \    [(string-subset? (tail a (cycpattern_find b a)) b)\n     (cycpattern_check\
    \ b (tail a (cycpattern_find b a)))]\n    [else false]\n    )\n  )", "  (cond\
    \ [(empty? a) #f]\n        [(equal? (string-downcase (car a)) (string-downcase\
    \ (car b))) (if (string-downcase (car b)) #t #f)]\n        [(equal? (string-downcase\
    \ (car a)) (string-downcase (car b))) (if (string-downcase (b)) #t #f)]\n    \
    \    [else (cycpattern_check (cdr a) (cons (cons (string-append (string-downcase\
    \ (car b)) (string-downcase (car a))) (list)) ))]))\n", "  (cond\n    [(null?\
    \ a) true]\n    [(null? b) false]\n    [(or (eq? (string-ref a 0) (string-ref\
    \ b 0))\n          (cycpattern_check (string-tail a 0)\n                     \
    \       (string-tail b 0)))\n     (or (eq? a (string-tail b 0))\n         (cycpattern_check\
    \ (string-tail a 0)\n                            (string-tail b 0))]\n    [else\
    \ (equal? (string-car a) (string-car b))\n          (cycpattern_check (string-tail\
    \ a 1)\n                            (string-tail b 1))]))\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nHi , could you please explain how you are checking the equality\
    \ of characters ?\n<|/ c |>\n<| c |>\nHi , please see the above comment.\n<|/\
    \ c |>\n<| a |>\nYou can't use string matching for this. Even if you could, it\
    \ would be much too slow for large strings.\nYou can do the same thing with linear\
    \ search through the string using characters, but then you have to make a new\
    \ copy of the string every time, which is O(n).\nA better approach is to make\
    \ a HashSet from the first string, and then check whether the second string is\
    \ in the set. Since sets are implemented with hashtables, this will be much faster\
    \ than O(n) time complexity.\nHere's some code to illustrate this:\n<code>", " \
    \ (cond ((eq? b \"\") True)\n        ((eq? a b) True)\n        ((eq? (string-find\
    \ (substring a 0 b) (substring b 0 a)) 0) True)\n        (else (cycpattern_check\
    \ (substring a (b-length b)) b))))\n", "  (or (string=? (rotate b) a) (string=?\
    \ (rotate (rotate a)) b)))\n", "  (cond [(null? b) #f]\n        [(equal? b (substring\
    \ a 0 (string-length b)))\n         (string-contains b a)] \n        [else (substring\
    \ a 0 (string-length b))\n              (substring b (string-length a) (string-length\
    \ b))]\n        [else (cycpattern_check (substring a 0 (string-length b)) b)]))\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  (cond [(null? a) (null? b) true]\n\
    \        [(eq? a b)  (true)]\n        [(empty? (rest a)) (true)]\n        [(empty?\
    \ (rest b)) (true)]\n        [else (or (eq? (fst a) (bnd (dec a)))\n         \
    \         (eq? (fst b) (bnd (dec b)))\n                  (true)))]))\n", "  (or\
    \ (string=? (string=! a b) b)\n      (string=? (string=! b a) a)))\n", "  (cond\n\
    \    [(empty? a) #t]\n    [(empty? b) #f]\n    [(sub? b a) #t]\n    [(sub? (substring\
    \ (b 0) (length a)) a) #t]\n    [else (sub? (substring (b 0 ) (length a)) a)]))\n",
  "  (cond\n    [(string=? (string-ref a 0) (string-ref b 0))\n     (string-ref a\
    \ 0)]\n    [(symbol=? (string-upcase (car a)) (string-upcase (car b)))\n     (string-ref\
    \ a 0)]\n    [else\n     (string=? (string-ref a 0) (string-ref b 0))]))\n", " \
    \ (or (equal? (string-length a string-length b)\n              (string-length\
    \ (string-repeat b string-length a))\n              0)\n      (equal? (string-rotate\
    \ b (string-length a string-length b) 0)\n              (string-rotate a\n   \
    \                          (string-length (string-repeat b string-length a) 0)\n\
    \                             0))))\n", "  (cond\n    ((not (member (substring\
    \ a 0 (string-length a)) b)) #t)\n    ((member (substring a 0 (string-length a))\
    \ b) (substring b (string-length a) (string-length b)))\n    ((equal? (substring\
    \ a 0 (string-length a)) b) (substring b (string-length b) (string-length a)))\n\
    \    ((equal? (substring a 0 (string-length a)) (substring b (string-length a)\
    \ (string-length b)))\n    (#t (cycpattern_check (substring a 0 (string-length\
    \ a)) (substring b (string-length b) (string-length a))))\n    ((equal? (substring\
    \ a 0 (string-length a)) (substring b (string-length b) (string-length a))) #t)\n\
    \    ((equal? (substring a 0 (string-length a)) (substring b (string-length a)\
    \ (string-length b)))\n    (#t (cycpattern_check (substring a 0 (string-length\
    \ a)) (substring b (string-length a) (string-length b))))\n    ((equal? (substring\
    \ a 0 (string-length a)) (substring b (string-length a) (string-length b)))\n\
    \    (#t (cycpattern_check (substring a 0 (string-length a)) (substring b (string-length\
    \ b) (string-length b))))\n    ((equal? (substring a 0 (string-length a)) (substring\
    \ b (string-length b) (string-length b))) #t)\n    ((equal? (substring a 0 (string-length\
    \ a)) (substring b (string-length a) (string-length b)))\n    (#t (cycpattern_check\
    \ (substring a 0 (string-length a)) (substring b (string-length a) (string-length\
    \ b))))\n    ((equal? (substring a 0 (string-length a)) (substring b (string-length\
    \ a) (string-length b)))\n    (#t (cycpattern_check (substring a 0 (string-length\
    \ a)) (substring b (string-length b) (string-length a))))\n    ((equal? (substring\
    \ a 0 (string-length a)) (substring b (string-length a) (string-length b))) #t)\n\
    \    ((equal? (substring a 0 (string-length a)) (substring b (string-length b)\
    \ (string-length b)))\n    (#t (cycpattern_check (substring a 0 (string-length\
    \ a)) (substring b (string-length b) (string-length b))))\n    ((equal? (substring\
    \ a 0 (string-length a)) (substring b (string-length a) (string-length b)))\n",
  "  (if (or (= (cycpattern_length a) 0)\n          (= (cycpattern_length b) 0))\n\
    \      #t\n      (let loop ((a (string-to-list a))\n                 (b (string-to-list\
    \ b)))\n        (if (or (= (cycpattern_length a) 0)\n                (= (cycpattern_length\
    \ b) 0))\n            #f\n            (let ((c (+ (car b) (car a)))\n        \
    \          (dst (string-to-list a)))\n              (if (equal? (car b) (car a))\n\
    \                  #t\n                  (if (substring dst 0 c true)\n      \
    \                (if (substring dst 1 c true)\n                          (if (substring\
    \ dst 2 c true)\n                              (if (substring dst 3 c true)\n\
    \                                  (if (substring dst 4 c true)\n            \
    \                          (if (substring dst 5 c true)\n                    \
    \                      (if (substring dst 6 c true)\n                        \
    \                      (if (substring dst 7 c true)\n                        \
    \                          (if (substring dst 8 c true)\n                    \
    \                                  (if (substring dst 9 c true)\n            \
    \                                              (if (substring dst 10 c true)\n\
    \                                                              (if (substring\
    \ dst 11 c true)\n                                                           \
    \       (if (substring dst 12 c true)\n                                      \
    \                                (if (substring dst 13 c true)\n             \
    \                                                             (if (substring dst\
    \ 14 c true)\n                                                               \
    \               (if (substring dst 15 c true)\n                              \
    \                                                    (if (substring dst 16 c true)\n\
    \                                                                            \
    \          (if (substring dst 17 c true)\n                                   \
    \                                                       (if (substring dst 18\
    \ c true)\n                                                                  \
    \                            (if (substring dst 19 c true)\n                 \
    \                                                                            \
    \     (if (substring dst 20 c true)\n                                        \
    \                                                              (if (substring\
    \ dst 21 c true)\n                                                           \
    \                                               (if (substring dst 22 c true)\n\
    \                                                                            \
    \                                  (if (substring dst 23 c true)\n           \
    \                                                                            \
    \                           (if (substring dst 24 c true)\n                  \
    \                                                                            \
    \                        (if (substring dst 25 c true)\n                     \
    \                                                                            \
    \                         (if (substring dst 26 c true)\n                    \
    \                                                                            \
    \                              (if (substring dst 27 c true)\n               \
    \                                                                            \
    \                                       (if (substring dst 28 c true)\n      \
    \                                                                            \
    \                                                    (if (substring dst 29 c true)\n\
    \                                                                            \
    \                                                              (if (substring\
    \ dst 30 c true)\n                                                           \
    \                                                                            \
    \       (if (substring dst 31 c true)\n                                      \
    \                                                                            \
    \                                (if (substring dst 32 c true)\n             \
    \                                                                            \
    \                                                             (if (substring dst\
    \ 33", "  (or (string=? a b)\n      (= (string-length a) (string-length b))\n\
    \      (= (string-ref a 0 (string-length a)) (string-ref b (0 (string-length b))))\
    \ ; substring at beginning\n      (= (string-ref a 0 (string-length a)) (string-ref\
    \ b 0 (string-length b)))) ; substring at end\n  )\n", "  (cond ((null? a) #f)\n\
    \        (else (or (eq? (subseq (string-split (string-reverse a)) b)\n       \
    \               (subseq (string-split (string-reverse b)) a)))))\n</code>\n<|/\
    \ a tags=string,string-matching,racket,pattern-matching dscore=0 |>\n<| c |>\n\
    This is not racket code, this is a general programming problem with two strings\
    \ and a pattern string. You should mention that as a comment on your own question,\
    \ not as an answer to your own question.\n<|/ c |>\n<| c |>\nI believe your solution\
    \ will require 2 passes through the string. I'm hoping someone can come up with\
    \ a solution that will require only 1 pass through the string. If not, I'd like\
    \ to hear your reasoning.\n<|/ c |>\n<| c |>\n: No, it only requires one pass\
    \ through the string. See my answer.\n<|/ c |>\n<| a dscore=0 |>\nI believe this\
    \ can be done in O(n) by using a binary search. Here's my implementation in Racket\
    \ (it might not be the most efficient implementation):\n<code>", "  (define (cycpattern_check\
    \ word pattern)\n    (cond\n      [(equal? (length word) 1) (equal? (string-ref\
    \ word 0) pattern)]\n      [(equal? (string-ref word 0) pattern) (equal? (string-ref\
    \ word 1) pattern)]\n      [(equal? (string-ref word 0) pattern) (equal? (string-ref\
    \ word 1) pattern)]\n      [else (or (equal? (string-ref word 0) pattern) (cycpattern_check\
    \ (string-ref word 1) pattern))]))\n  (cycpattern_check a b))\n", "  (cond ((empty?\
    \ b) empty?) ; if a is empty, check if b matches empty string\n        ((substring-exists?\
    \ (cdr a) (car b)) (substring-exists? (cdr a) (car b)) #t)\n        (else (substring-exists?\
    \ (cdr a) (car b)))\n        ))\n", "  (or\n   (and (char-substring b a) (char-substring\
    \ a b))\n   (and (char-substring a b) (char-substring b a))\n   (and (char-substring\
    \ a b) (char-substring a b))\n   (and (char-substring b a) (char-substring b a))\n\
    \   (and (char-substring b a) (char-substring a b))))\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks for the solution, but unfortunately, it doesn't work with some test\
    \ cases.\n<|/ c |>\n<| c |>\n, try \"efef\" and \"eeff\" and see what happens\n\
    <|/ c |>\n<| c |>\n`efef` and `eeff` return `True` in your solution.\n<|/ c |>\n\
    <| c |>\n, sorry, my bad. Corrected my answer.\n<|/ c |>\n<| c |>\nYour solution\
    \ looks great! But it doesn't work for all test cases. I have added some test\
    \ cases into the question.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme |>\nA more\
    \ efficient solution would use a trie. A trie is like a dictionary where each\
    \ node contains information about one character in the string. You can make one\
    \ using a simple table with hash functions (aka hash table). It's also possible\
    \ to make one using a binary search tree to optimize lookup time. As usual, a\
    \ trie is more efficient than a linear search.\nYou only need one data structure\
    \ to implement your trie. A hash table would probably be best. If you want to\
    \ implement one using a binary search tree, then you can just use a hash table\
    \ that stores pairs of characters. A pair would contain the character and the\
    \ index into the string where it appears. A hash table would allow you to look\
    \ up a character by searching through the hash table until you found an entry\
    \ that has the correct character. It would also allow you to look up a character\
    \ by searching through the tree until you found the correct character.\nHere is\
    \ a version that uses hash table and binary search trees. It has some tricks to\
    \ make it shorter. I had to make a few changes (mainly to change the hash function\
    \ to not use the character itself). There are a number of optimizations that can\
    \ be made, but the code should be easy to understand.\n<code>", "  (or (member\
    \ (substring a 0 (string-length a))\n               (substring b (string-length\
    \ b)\n                            (string-length a)))\n      (member (substring\
    \ a 0 (string-length a))\n               (substring b (string-length b)\n    \
    \                        (string-length a)))))\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you for the help and explanation.\n<|/ c |>\n<| a |>\nThe string \"ab\" is a\
    \ substring of \"abcde\", so any permutation of \"ab\" is a substring of \"abcde\"\
    .\nThe string \"ba\" is not a substring of \"abcde\", so any permutation of \"\
    ba\" is not a substring of \"abcde\".\nThe string \"abc\" is also not a substring\
    \ of \"abcde\", so any permutation of \"abc\" is not a substring of \"abcde\"\
    .\nSo your function will return true for all of these:\n<code>", "  (cond\n  \
    \  [(string-match b a)\n      (eqv? a b)]\n    [else\n      (cond [(string=? (substring\
    \ b 0 (- (length a) 2)) a)\n            (eqv? a b)]\n            [(substring b\
    \ 0 (- (length a) 2)) (eqv? a b)]\n            [else\n            (string=? (substring\
    \ b 0 (- (length a) 1)) a)\n            (eqv? a b)])]))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like the use of substring here and the use of eqv?. Thanks\n\
    <|/ c |>\n<| a tags=racket,substring,string dscore=2 |>\nHere is another solution,\
    \ using sets and pattern matching:\n<code>", "  (let ((count 0))\n    (do ((a\
    \ (aref a count))\n         (b (aref b count)))\n        ((< count (length a))\
    \ #f)\n      (set! count (1+ count))\n      (and (equal? (substring b 0 count)\n\
    \                    (substring a 0 count))\n           (equal? (substring b 0\
    \ count)\n                    (cycpattern_check a (substring b count 1)))))\n\
    \  (equal? (length b) (length a)))\n", "  (cond\n    ((empty? b) #t)\n    ((equal?\
    \ (string-first b) (string-first a)) #t)\n    ((equal? (string-last b) (string-first\
    \ a)) #t)\n    ((equal? (string-first b) (substring a (string-first b) (string-last\
    \ b)))) #t)\n    ((equal? (string-last b) (substring a (string-first b) (string-last\
    \ b)))) #t)\n    ((equal? (substring a (string-first b) (string-last b)) (string-first\
    \ a)) #t)\n    ((equal? (substring a (string-first b) (string-last b)) (string-last\
    \ a)) #t)\n    (else (equal? (substring a (string-first b) (string-last b)) (cycpattern_check\
    \ a (substring a (string-first b) (string-last b)))))))\n", "  (cond ((null? a)\
    \ b)\n        ((string=? (substring b 0 a) (substring a 0 b)) #t)\n        (else\
    \ (cycpattern_check (substring a 1 b) (substring b 1 a)))))\n", "  (cond ((string=?\
    \ (substring a 0 1) (substring b 0 1)) (or (string=? (substring b 0 1) (substring\
    \ a 0 1)) (cycpattern_check (substring a 0 1) (substring b 0 1))))\n        ((string=?\
    \ (substring b 0 1) (substring a 0 1)) (or (string=? (substring a 0 1) (substring\
    \ b 0 1)) (cycpattern_check (substring a 0 1) (substring b 0 1))))\n        ((string=?\
    \ (substring a 0 1) (substring b 0 1)) (or (string=? (substring b 0 1) (substring\
    \ a 0 1)) (cycpattern_check (substring a 0 1) (substring b 0 1))))\n        (else\
    \ (or (string=? (substring a 0 1) (substring b 0 1)) (cycpattern_check (substring\
    \ a 0 1) (substring b 0 1))))))\n", "  (define (check_rotations w)\n    (define\
    \ (check_rotations w)\n      (cond\n        ((eq? (string-ref w 0) (cycpattern_check\
    \ a (substring w 1 -1))) true)\n        (else (check_rotations (substring w 1\
    \ -1))))\n    (check_rotations (reverse w)))\n  (define (is_substring w s)\n \
    \   (define (is_substring w s)\n      (cond\n        ((eq? (string-ref w 0) (substring\
    \ s 0 -1)) true)\n        (else (is_substring (substring s 0 -1) (substring w\
    \ 1 -1)))))\n    (is_substring  (reverse s) (reverse b)))\n  (let ((substring\
    \ (cycpattern_check a b)))\n    (cond\n      ((or (not (eq? (string-ref substring\
    \ 0 0) (string-ref substring 1 0))) (not (eq? (string-ref substring 1 0) (string-ref\
    \ substring 0 0)))) (is_substring substring b))\n      (else (eq? substring (b\
    \ 0 -1)))))\n", "  (cond\n    [(empty? b) false]\n    [else (or (equal? (string-match\
    \ a (car b)) true) (equal? (string-match (string-append (car b) (cdr b)) a) true))]))\n",
  "  (let loop ((i 0)\n             (a (a))\n             (b (b))\n             (pattern\
    \ (cdr (reverse b)))\n             (result '()))\n    (cond\n      [(empty? b)\
    \ (cdr result)]\n      [(equal? (car b) (car pattern)) (cons (car b) result)]\n\
    \      [else (loop (+ i 1) (cdr a) (cdr b) (cdr pattern) (cons (car a) result))]))\n",
  "  (define (helper-check a b)\n    (cond (string=? a b)\n          #t\n        \
    \  (string-char-at-pos (string->list a) (string->list b) (string->list a)\n  \
    \                               (string->list b) (string->list a) 0)\n       \
    \   (string-char-at-pos (string->list b) (string->list a) (string->list a)\n \
    \                                (string->list b) (string->list a) 0)\n      \
    \    (string-char-at-pos (string->list b) (string->list a) (string->list b)\n\
    \                                 (string->list a) (string->list b) 0)\n     \
    \     (string-char-at-pos (string->list b) (string->list a) (string->list b)\n\
    \                                 (string->list a) (string->list a) 0)\n     \
    \     (string-char-at-pos (string->list a) (string->list b) (string->list a)\n\
    \                                 (string->list a) (string->list a) 0)\n     \
    \     (string-char-at-pos (string->list a) (string->list a) (string->list b)\n\
    \                                 (string->list a) (string->list a) 0)\n     \
    \     (else #f)))\n  (helper-check a b))\n", "  (ormap (\u03BB (w)\n         \
    \  (or (string-match b w)\n               (string-substring-match b w))) a))\n\
    </code>\n<|/ a |>\n<| a |>\nThe following code will do the job :\n<code>", " \
    \ (cond\n    [(empty? a) #t]\n    [(empty? b) #f]\n    [(equal? a (substring (first\
    \ a) (second a)))\n     (match_cycpattern_b (substring (first b) (second b)) a)\n\
    \     ]\n    [else #f]))\n", "  (cond [(empty? a)        false]\n        [(empty?\
    \ b)        false]\n        [(= 0 (string-length b)) false]\n        [(or (= (string-length\
    \ a) (string-length b)) (<= (string-length a) (string-length b)))\n         false]\n\
    \        [else\n         (chars-in-string? b (substring a 0 string-length a))\n\
    \         ]\n        ))\n", "  (define (b-str-check a b)\n    (cond\n      [(empty?\
    \ b) true]\n      [(member? (first b) a) (cond [(empty? a) true]\n           \
    \                        [(equal? (first a) (reverse (rest a))) true])]\n    \
    \  [else false]))\n\n  (cond\n    [(empty? a) true]\n    [(equal? (first a) (reverse\
    \ (rest a))) (cond\n                                           [(empty? b) true]\n\
    \                                           [(b-str-check (rest a) b) true])]\n\
    \    [else false]))\n", "  (cond\n    [(empty? b) false]\n    [(member (substring\
    \ a 0 end) (substring b 0 end)) true]\n    [else false]))\n", "  (or (string=?\
    \ a b) (string=? (string-reverse a) (string-reverse b))))\n", "  (cond (string-match\
    \ a b)\n    (string-match a (b . \".\"))\n    (string-match a (b . \"..\"))\n\
    \    (string-match a (b . \"...\"))\n    (string-match a (b . \"??\"))\n    (string-match\
    \ a (b . \"???\"))\n    (string-match a (b . \"????\"))\n    (string-match a (b\
    \ . \"?????\"))\n    (string-match a (b . \"??????\"))\n    (string-match a (b\
    \ . \"???????\"))\n    (string-match a (b . \"????????\"))\n    (string-match\
    \ a (b . \"?????????\"))\n    (string-match a (b . \"??????????\"))\n    (string-match\
    \ a (b . \"???????????\"))\n    (string-match a (b . \"????????????\"))\n    (string-match\
    \ a (b . \"?????????????\"))\n    (string-match a (b . \"??????????????\"))\n\
    \    (string-match a (b . \"???????????????\"))\n    (string-match a (b . \"????????????????\"\
    ))\n    (string-match a (b . \"?????????????????\"))\n    (string-match a (b .\
    \ \"??????????????????\"))\n    (string-match a (b . \"???????????????????\"))\n\
    \    (string-match a (b . \"??????????????????????\"))\n    (string-match a (b\
    \ . \"???????????????????????\"))\n    (string-match a (b . \"????????????????????????\"\
    ))\n    (string-match a (b . \"?????????????????????????\"))\n    (string-match\
    \ a (b . \"????????????????????????????\"))\n    (string-match a (b . \"??????????????????????????????????\"\
    ))\n    (string-match a (b . \"????????????????????????????????????????????\"\
    ))\n    (string-match a (b . \"??????????????????????????????????????????????????\"\
    ))\n    (string-match a (b . \"????????????????", "  (cond [(empty? a) false]\n\
    \        [(empty? b) true]\n        [(string-substring b (car a) (car (cdr a)))\n\
    \         (or (cycpattern_check (cdr a) b)\n             (cycpattern_check a (cdr\
    \ b)))]\n        [else false]))\n", "  (match b\n    [(empty-string? a) #t]\n\
    \    [(exactly?(empty? b) #f]\n    [else\n      (or (equal? (string-match (first\
    \ a) (reverse b)) #t)\n          (equal? (string-match (first b) (reverse a))\
    \ #t)))]))\n", "  (cond ((and (empty? a) (empty? b)) #t)\n        ((equal? a (string-join\
    \ (reverse (string->list b)))) #t)\n        ((equal? (string-last a) (string-first\
    \ b)) #t)\n        ((equal? (string-first a) (string-last b)) #t)\n        ((member\
    \ (string-last a) (string-first b)) #t)\n        ((equal? (string-last b) (string-first\
    \ a)) #t)\n        (else false)))\n", "  (or (equal? b (string-append a b))\n\
    \      (equal? (string-append a (cycshift b)) b)\n      (equal? (string-append\
    \ (cycshift b) a) a)))\n", "  (cond\n    [(null? a) false]\n    [(member (substring\
    \ b 0) a) false]\n    [else (and (substring b 0 1) (member (substring b 1) a))]\n\
    \  )\n)\n</code>\n<|/ a dscore=3 tags=lisp,racket,scheme |>\n<| c |>\nThank you.\
    \ I did it with your help and I made a mistake for my final code. Thanks.\n<|/\
    \ c |>\n<| c |>\nNice solution.  I thought about posting another solution, but\
    \ then I thought \"why not do it this way?\"  It seems cleaner, too.\n<|/ c |>\n\
    <| c |>\nI like that! I didn't know you could use \"and\" like that\n<|/ c |>\n\
    <| c |>\nI actually think your approach is nice, particularly if you use a `let`\
    \ to avoid redundant calculations.\n<|/ c |>\n<| c |>\nAh, I see. I think the\
    \ let is really nice too, especially since we're not really doing that much calculations\
    \ :)\n<|/ c |>\n<| a |>\nThis is what I came up with, using just cond and and\
    \ and member:\n<code>", "  (cond ((eq? b '()) true)\n        ((or (eq? b (substring\
    \ a 0)) (cycpattern_check (substring a 1) b))) \n        (else false)))\n", " \
    \ (let loop ((a (string->list (string->string a)) (string->list (string->string\
    \ b)))\n             (w (first a))\n             (c (rest a)))\n    (if (null?\
    \ c)\n        (or (= w '()) (eq? (first c) (butlast c)))\n        (or (loop (rest\
    \ c) (first w) (append (butlast w) (list (first c))))))))\n", "  (cond [(and (eq?\
    \ a (substring b 0 0)) \n              (eq? b (substring a 0 0))) \n         true]\n\
    \        [(or (eq? a b) \n             (not (member b (string->list a) '())))\
    \ false]\n        [else (and (member (substring b 0 0) a)\n                  \
    \ (cycpattern_check (substring a 0 0) (substring b 0 0)))]))", "  (match b\n \
    \   [(_ :: tail) ; base case\n     (match a [(_ :: tail2) ; recursive case\n \
    \              ]\n       [(_ :: tail2) ; recursive case\n       ])]\n    [(_ ::\
    \ tail) ; base case\n     (match a [(_ :: tail2) ; recursive case\n          \
    \     ]\n       [(_ :: tail2) ; recursive case\n       ])]))\n", "  (or (string=?\
    \ (string-ref a 0)\n                   (string-ref b 0)))\n      (for ([i 0])\n\
    \        (string=? (string-ref b i)\n                    (string-ref a i))\n \
    \       (set! i (+ i 1))\n        (string=? (string-ref b i)\n               \
    \     (string-ref a i))))\n", "  (cond ((equal? (string-length a) (string-length\
    \ b))\n         (equal? (string-ref a 0)\n                  (string-ref b 0)))\n\
    \        (else\n         (string=? a\n                     (concat (substring\
    \ b (- (string-length b) 1))\n                             (substring a 1)))))\n",
  "  (cond\n    [(string-equal a b)\n     (string-equal? (rotate-string a -1) b)\n\
    \     (string-equal? (rotate-string b 1) a)\n     (string-equal? (rotate-string\
    \ b -1) (rotate-string a 1))]\n    [(or (string->list (string->symbol a) (cons\
    \ (first a) a) b)\n          (string->list (string->symbol b) (cons (first b)\
    \ b)))\n     (string-equal? (rotate-string a -1) (rotate-string b 1))\n     (string-equal?\
    \ (rotate-string a -1) (rotate-string b -1))\n     (string-equal? (rotate-string\
    \ b 1) (rotate-string a 1))\n     (string-equal? (rotate-string b -1) (rotate-string\
    \ a -1))]\n    [else false]))\n", "  (and (equal? (length a) (length b))\n   \
    \    (or (equal? (string-ref b 0 (length a))\n                   (string-ref a\
    \ 0 (length a)))\n           (equal? (string-ref a 0 (length b))\n           \
    \        (string-ref b 0 (length b))))))\n", "  (cycpattern_check_aux (string-length\
    \ a) (string-length b) a b))\n", "  (match b ((\"e\"(e \"e\"))\n             (\"\
    t\"(t \"t\"))\n             (\"a\"(a \"a\"))\n             (\"aa\"(a \"aa\"))\n\
    \             (\"m\"(m \"m\"))\n             (\"aaa\"(a \"aaa\"))\n          \
    \   (\"bca\"(a \"bca\"))\n             (\"aba\"(a \"aba\"))\n             (\"\
    baa\"(a \"baa\"))\n             (\"bb\"(a \"b\"))\n             (\"bbb\"(a \"\
    bbb\"))\n             (\"c\"(c \"c\"))\n             (\"cc\"(c \"cc\"))\n    \
    \         (\"ccc\"(c \"ccc\"))\n             (\"ccca\"(c \"ccca\"))\n        \
    \     (\"dddd\"(d \"dddd\"))\n             (\"ddddccc\"(d \"ddddccc\"))\n    \
    \         (\"ddddccca\"(d \"ddddccca\"))\n             (\"e\"(e \"e\"))\n    \
    \         (\"t\"(t \"t\"))\n             (\"a\"(a \"a\"))\n             (\"aa\"\
    (a \"aa\"))\n             (\"m\"(m \"m\"))\n             (\"aaa\"(a \"aaa\"))\n\
    \             (\"bca\"(a \"bca\"))\n             (\"aba\"(a \"aba\"))\n      \
    \       (\"baa\"(a \"baa\"))\n             (\"bb\"(a \"b\"))\n             (\"\
    bbb\"(a \"bbb\"))\n             (\"c\"(c \"c\"))\n             (\"cc\"(c \"cc\"\
    ))\n             (\"ccc\"(c \"ccc\"))\n             (\"ccca\"(c \"ccca\"))\n \
    \            (\"dddd\"(d \"dddd\"))\n             (\"ddddccc\"(d \"ddddccc\"))\n\
    \             (\"ddddccca\"(d \"ddddccca\"))\n             (\"e\"(e \"e\"))\n\
    \             (\"t\"(t \"t\"))\n             (\"a\"(a \"a\"))\n             (\"\
    aa\"(a \"aa\"))\n             (\"m\"(m \"m\"))\n             (\"aaa\"(a \"aaa\"\
    ))\n             (\"bca\"(a \"bca\"))\n             (\"aba\"(a \"aba\"))\n   \
    \          (\"baa\"(a \"baa\"))\n             (\"bb\"(a \"b\"))\n            \
    \ (\"bbb\"(a \"bbb\"))\n             (\"c\"(c \"c\"))\n             (\"cc\"(c\
    \ \"cc\"))\n             (\"ccc\"(c ", "  (or\n   (or (equal? (string-length a)\
    \ (string-length b))\n       (string=? (string-append a b)\n                 (string-append\
    \ (reverse a) (reverse b))))\n   (apply #'equal? (subseq a 0 (string-length a))\n\
    \               (subseq b 0 string-right-pos (string-length b)))))\n", "  (or\
    \ (boolean? (string-prefix? a b))\n      (boolean? (string-prefix? (string-reverse\
    \ a) b))))\n", "  (cycpattern_check_rec a b 0 0))\n", "  (let ((p (csubstring\
    \ b a)))\n    (or (not (cstringpat p a 0))\n        (or (cycpattern_check (csubstring\
    \ a (+ p 1)) p)\n            (cycpattern_check (csubstring a 0) (csubstring p\
    \ (- (length a) 1)))\n            (or (cycpattern_check (csubstring p (- (length\
    \ a) 1) 1) a)\n                (cycpattern_check (csubstring a (- p 1)) p))))))\n",
  "  (cond ((null? a) false)\n        ((char? a) (chars-substring b a))\n        ((string-char?\
    \ a) (string-chars-substring b a))\n        (else (equal? (string-chars-substring\
    \ b a) a))\n  )\n)\n", "  (cond [(string? a) (string? b) (string? (substring a\
    \ b 0))]\n        [(= 0 (string-length a)) (= 0 (string-length b))]\n        [(string-contains?\
    \ (reverse a) (reverse b))]))\n", "  (cond [(string=? b a) true]\n        [(string=?\
    \ (take b a) (take a b)) true]\n        [else false]))\n", "  (or\n   (string-subset?\
    \ a b)\n   (string-subset? (substring b 0)\n                    (substring a 0))))\n",
  "  (cond\n    [(empty? b) #f]\n    [(= (length a) (length b)) #t]\n    [else (or\
    \ (equal a b) (equal (substring a 1 ) (substring b 1 )) (cycpattern_check (substring\
    \ a (+ 1 )) (substring b (+ 1 )) ))]))\n", "  (or\n   (string-contains? a b) \n\
    \   (string-contains? b a) \n   (string-contains-any a b)\n   (string-contains-any\
    \ b a) \n   (string-contains-all-of b a)\n   (string-contains-all-of a b)))\n",
  "  (or (string=? b a)\n      (string=? (substring a 0 (- (length a)) b) (substring\
    \ a 0 (- (length a)) b))))\n</code>\n<|/ a |>\n<| c |>\nThis is my first time\
    \ trying out Racket, so I'm trying to figure out how to write this myself. Could\
    \ you possibly explain what each line does, and how it works?\n<|/ c |>\n<| c\
    \ |>\nThis works, except I made a mistake copying my code in. This one should\
    \ work as intended. Thanks!\n<|/ c |>\n<| a |>\nMy solution only works for uppercase\
    \ and lowercase. I know this is an old question but I figure maybe someone will\
    \ find it useful. \n<code>", "  (cond [(empty? b) #f]\n        [(equal? (string-ref\
    \ b 0) a) #t]\n        [else (or (cycpattern_check (tail b) (substring b 0 (string-length\
    \ b)))\n                   (cycpattern_check (substring b 0 (string-length b))\
    \ a)))]))", "  (let ((len (length a)))\n    (define (is-in b a)\n      (define\
    \ (subseq n k)\n        (if (<= n k)\n            a\n            (subseq (+ n\
    \ 1) k)))\n      (and (subseq b a) (subseq b (- n 1))))\n    (define (is i j)\n\
    \      (define (subseq n k)\n        (if (<= n k)\n            (is (+ n 1) j)\n\
    \            (is (+ n 1) (- n 1))))\n      (and (subseq a i) subseq (- i 1) j))\n\
    \    (is len (- len 1))))\n", "  (cond\n    [(or (string=? (substring b 0 a) (substring\
    \ b 0 0)) (string=? (substring b 0 a) (substring b 0 1))) (equal? a b)]\n    [else\
    \ (equal? a (cycpattern_check (substring b 0 a) b))]))\n", "  (cond (\n      (empty?\
    \ b) \n      (= (cycpattern_count a) 0)\n      (= (cycpattern_count b) 0)\n  \
    \    (= (cycpattern_count (first b)) 0)\n      (= (cycpattern_count (last a))\
    \ 0)\n      (empty? (rest b))\n      (= (first b) (last a))\n      (= (first a)\
    \ (last b))\n      (= (first b) (rest a))\n      (= (last a) (rest b))\n     \
    \ (= (first b) (rest b))\n      (= (last b) (rest a))\n      (= (cycpattern_count\
    \ (first b)) 0)\n      (= (cycpattern_count (last a)) 0)\n      (= (cycpattern_count\
    \ (rest b)) 0)\n      (= (cycpattern_count (rest a)) 0)\n      (= (cycpattern_count\
    \ (first a)) 0)\n      (= (cycpattern_count (first b)) 0)\n      (= (cycpattern_count\
    \ (last b)) 0)\n      (= (cycpattern_count (rest a)) 0)\n      (= (cycpattern_count\
    \ (rest b)) 0)\n      (= (cycpattern_count (last b)) 0)\n      (= (cycpattern_count\
    \ (rest a)) 0)\n      (= (cycpattern_count (rest b)) 0)\n      (= (cycpattern_count\
    \ (first a)) 0)\n      (= (cycpattern_count (first b)) 0)\n      (= (cycpattern_count\
    \ (last a)) 0)\n      (= (cycpattern_count (last b)) 0)\n      (= (cycpattern_count\
    \ (rest a)) 0)\n      (= (cycpattern_count (rest b)) 0)\n      (= (cycpattern_count\
    \ (last a)) 0)\n      (= (cycpattern_count (last b)) 0)\n      (= (cycpattern_count\
    \ (rest a)) 0)\n      (= (cycpattern_count (rest b)) 0)\n      (= (cycpattern_count\
    \ (first b)) 0)\n      (= (cycpattern_count (last a)) 0)\n      (= (cycpattern_count\
    \ (last b)) 0)\n      (= (cycpattern_count (rest a)) 0)\n      (= (cycpattern_count\
    \ (rest b)) 0)\n      (= (cycpattern_count (first a)) 0)\n      (= (cycpattern_count\
    \ (first b)) 0)\n      (= (cycpattern_count (last a)) 0)\n", "  ;; ((null? a)\
    \ (b-member? (first b) a)) \n  (cond [(empty? a) true]\n        [(equal? (first\
    \ a) (first b)) true]\n        [else (member (first b) (first a)) (cycpattern_check\
    \ (rest a) (rest b))]\n      )\n)\n", "  (or (string-match a b)\n      (string-match\
    \ (string-reverse a) (string-reverse b))))\n</code>\n<|/ a tags=substring,racket,string\
    \ |>\n<| a tags=substring,racket,string |>\nA straight forward way to solve this\
    \ would be to simply use string-match to check if your pattern exists. Something\
    \ like:\n<code>", "  (cond ((null? a) false)\n        ((string-contains? b a)\n\
    \         (equal? b a))\n        (else\n         (string-contains? b b a 0)\n\
    \         (string-contains? b b a 1)))\n  )\n", "  (define (substr w s)\n    (define\
    \ (loop i acc)\n      (if (equal? i s) acc\n          (loop (sub1 (+ i 1)) (cons\
    \ (first w) (cons i acc))))\n      (if (equal? i (length w)) acc\n          (loop\
    \ (+ i (length w)) acc)))\n    (if (equal? (length a) (length b)) #t\n       \
    \ (loop (length a) '())))\n  (substr b a))\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ works for me and my professor has explained this to me as well. Thank you for\
    \ the help\n<|/ c |>\n<| c |>\nI did my own implementation, but your answer got\
    \ me thinking of how to do it recursively, and I'm sure I'll get some good ideas\
    \ out of it.\n<|/ c |>\n<| a dscore=0 |>\nFor any word that is contained in another\
    \ word, no matter how many other letters are rotated inside it, this recursive\
    \ solution will work:\n<code>", "  (or\n   (string-prefix? (string-ref a 0 ) (string-ref\
    \ b 0 ))\n   (string-prefix? (string-ref b 0 ) (string-ref a 0 )) ))\n", "  (cond\n\
    \    [(equal? a b) true]\n    [(equal? (string-ref a 0) (string-ref b 0)) false]\n\
    \    [(or (eq? (string-ref b 0) \"\") (eq? (string-ref b 0) (string-ref a 0)))\n\
    \     (equal? b a)] ))\n", "  (cond [(null? b) false]\n        [(or (string=?\
    \ (substring a 0 (string-length a)) b)\n             (string=? (substring a (string-length\
    \ a) (string-length a)) b)) true]\n        [else (cycpattern_check (substring\
    \ a 0 (string-length a)) b)]))\n", "  (cond\n    [(equal? a b) true]\n    [else\
    \ (or (equal? (string-match a b) 0)\n               (or (equal? (string-match\
    \ \"^\" a 2) (equal? (string-match \"^\" b 2)))\n                   (equal? (string-match\
    \ \"^\" (substring a 1 3) (substring b 1 3)))))]))\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThank you for taking time to answer my question!\n<|/ c |>\n<| c |>\n\
    I thought about this more and I realized my approach is fundamentally wrong. I've\
    \ updated the answer to include a solution that is correct but more complicated\
    \ than the one I first proposed.\n<|/ c |>\n<| c |>\nThank you for explaining\
    \ your approach! I did some reading on string-match and that helped me understand\
    \ your solution.\n<|/ c |>\n<| c |>\nYou're welcome! If this has answered your\
    \ question, please [accept it](http://stackoverflow.com/help/someone-answers).\n\
    <|/ c |>\n<| a dscore=0 tags=racket,scheme,string |>\nAnother solution using regexp:\n\
    <code>", "  (match b\n      [(string \"\") (= 0 (string-length a))]\n      [(string\
    \ x) (string-length a)]\n      [(string x y) (string-length a)\n           (or\
    \ (string=? x y) (member (substring x 0 (string-length a)) a))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
