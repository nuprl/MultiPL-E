name: HumanEval_153_Strongest_Extension
language: rkt
prompt: "#lang racket\n\n;; You will be given the name of a class (a string) and a\
  \ list of extensions.\n;; The extensions are to be used to load additional classes\
  \ to the class. The\n;; strength of the extension is as follows: Let CAP be the\
  \ number of the uppercase\n;; letters in the extension's name, and let SM be the\
  \ number of lowercase letters \n;; in the extension's name, the strength is given\
  \ by the fraction CAP - SM. \n;; You should find the strongest extension and return\
  \ a string in this \n;; format: ClassName.StrongestExtensionName.\n;; If there are\
  \ two or more extensions with the same strength, you should\n;; choose the one that\
  \ comes first in the list.\n;; For example, if you are given \"Slices\" as the class\
  \ and a list of the\n;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then\
  \ you should\n;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest\
  \ extension \n;; (its strength is -1).\n;; Example:\n;; for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\n(define (Strongest_Extension class_name\
  \ extensions)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n\
  \    (check-equal? (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\"))\
  \ \"Watashi.eIGHt8OKe\")\n    (check-equal? (candidate \"Boku123\" (list \"nani\"\
  \ \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\")\n    (check-equal?\
  \ (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\"\
  \ \"123NoooneB321\")) \"__YESIMHERE.NuLl__\")\n    (check-equal? (candidate \"K\"\
  \ (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\")\n    (check-equal? (candidate\
  \ \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\")\n    (check-equal?\
  \ (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"\
  -_-\")) \"YameRore.okIWILL123\")\n    (check-equal? (candidate \"finNNalLLly\" (list\
  \ \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\")\n    (check-equal? (candidate\
  \ \"_\" (list \"Bb\" \"91245\")) \"_.Bb\")\n    (check-equal? (candidate \"Sp\"\
  \ (list \"671235\" \"Bb\")) \"Sp.671235\")\n))\n\n(test-humaneval)"
completions: ["  (define (sort a b)\n    (if (< (length a) (length b))\n        (let\
    \ ((num-uppers (count (caar a)) (num-lowers (count (car a))))\n              (num-lowers\
    \ (- (length a) (length b)))\n              (num-uppers (- num-uppers num-lowers)))\n\
    \          (if (and (>= num-uppers 0)\n                   (>= num-lowers 0))\n\
    \              (cons (cons (caar a) (sort b (cdr a)))\n                    (sort\
    \ b (cdr b)))\n              (cons (caar a) (sort b (cdr a))))))\n  (sort extensions\
    \ (sort extensions extensions)))\n", "  (define (strength name)\n    (let ((cap\
    \ (string-length name)))\n      (let ((sm (string-length name (- cap sm))))\n\
    \        (/ (- cap sm)\n           (length extensions)\n           (min cap (-\
    \ sm cap))))))\n\n  (define (extension name)\n    (let ((cap (string-length name)))\n\
    \      (let ((sm (string-length name (- cap sm))))\n        (cond\n         ((=\
    \ cap sm) name)\n         ((< cap sm) (list-ref extensions (- sm cap)))\n    \
    \     (else (error \"No such extension!\"))))))\n\n  (define (compare-extension\
    \ x y)\n    (let ((cmp (strength x) (strength y)))\n      (cond\n       ((= cmp\
    \ 0) (< cmp 0))\n       ((= cmp -1) (< cmp 0))\n       ((= cmp 1) (< cmp 0))\n\
    \       (else (< cmp 0)))))\n\n  (define (compare-extensions xs ys)\n    (let\
    \ ((cmp (compare-extension xs ys)))\n      (cond\n       ((= cmp 0) '())\n   \
    \    ((= cmp -1) (cons xs ys))\n       ((= cmp 1) (cons (extensions xs) ys))\n\
    \       (else (cons (extensions xs) (compare-extensions ys))))))\n\n  (let ((extension\
    \ (extensions class_name)))\n    (if (null? extension) (error \"No such extension!\"\
    ))\n    (let ((extensions (compare-extensions extension extensions)))\n      (format\
    \ #t \"~a.~a~%\" class_name extension)))\n", "  (define CAP 0)\n  (define SM 0)\n\
    \  (for extension in extensions \n    (cond\n      [(char-upper-case? extension)\
    \ (set! CAP (add1 (char-upper-case? (string->list extension))))]\n      [(char-lower-case?\
    \ extension) (set! SM (add1 (char-lower-case? (string->list extension))))]\n \
    \     [(else (error \"Invalid extensions input\"))]))\n  (/ (- (- CAP SM) 1) 2))\n",
  "  (let\n    (\n      (\n        cap (count (map first (map first extensions))))\n\
    \      \n      (\n        sm  (count (map first (map rest extensions))))\n   \
    \   \n      (\n        strength (- (min cap sm) 1))\n      \n      (\n       \
    \ extensions (filter second extensions))\n      \n      (\n        extensions\
    \ (sort extensions \n                        (lambda (x) (> (second x) strength)))\n\
    \      )\n    )\n  \n    (cond\n      [(> (min cap sm) 0) (string class_name \"\
    .\" first extensions)]\n      \n      [else (string class_name \".\" first (reverse\
    \ extensions))]\n    ))\n", "  (cond\n    [(null? extensions) '()]\n    [(= 0\
    \ (string-length class_name)) (set! class_name '())]\n    [else (cond\n      \
    \      [(< (length (string-match (substring (first extensions) 0) class_name)\n\
    \                            (string-match (substring (first extensions) 1) class_name))\n\
    \             (/ (length (string-match (substring (first extensions) 0) class_name)\n\
    \                      (string-match (substring (first extensions) 1) class_name))\n\
    \            (- (string-length (substring (first extensions) 0) class_name)\n\
    \             (string-length (substring (first extensions) 1) class_name)))]\n\
    \            [else (cond\n                    [else (cond\n                  \
    \        [(< (length (string-match (substring (first extensions) 0) class_name)\n\
    \                                          (string-match (substring (first extensions)\
    \ 1) class_name))\n                           (/ (length (string-match (substring\
    \ (first extensions) 0) class_name)\n                                  (string-match\
    \ (substring (first extensions) 1) class_name))\n                           (-\
    \ (string-length (substring (first extensions) 0) class_name)\n              \
    \                (string-length (substring (first extensions) 1) class_name)))]\n\
    \                          [(< (length (string-match (substring (first extensions)\
    \ 0) class_name)\n                                          (string-match (substring\
    \ (first extensions) 1) class_name))\n                           (/ (length (string-match\
    \ (substring (first extensions) 0) class_name)\n                             \
    \     (string-match (substring (first extensions) 1) class_name))\n          \
    \                 (+ (string-length (substring (first extensions) 0) class_name)\n\
    \                              (string-length (substring (first extensions) 1)\
    \ class_name)))]\n                          [(< (length (string-match (substring\
    \ (first extensions) 0) class_name)\n                                        \
    \  (string-match (substring (first extensions) 1) class_name))\n             \
    \              (/ (length (string-match (substring (first extensions) 0) class_name)\n\
    \                                  (string-match (substring (first extensions)\
    \ 1) class_name))\n                           (- (+ (string-length (substring\
    \ (first extensions) 0) class_name)\n                              (string-length\
    \ (substring (first extensions) 1) class_name))\n                            (length\
    \ (string-match (substring (first extensions) 0) class_name))))]))]))]))]))\n",
  "  (let ([CAP (string-length class_name)])\n    (let ([SM (string-length extensions)])\n\
    \      (let ([strength (/ (- CAP SM) (CAP SM))])\n        (cond\n          [(=\
    \ strength 0) (list-ref extensions 0)]\n          [(< strength 0) (list-ref extensions\
    \ (- strength))]\n          [else (list-ref extensions (quotient strength 2))])))))\n",
  "  (cond\n    [(empty? extensions) (list class_name)]\n    [else\n      (cond\n\
    \        [(string-contains? class_name (car extensions)) (list class_name)]\n\
    \        [else (list class_name)]\n        )]\n    )\n  )\n)\n", "  (define (compare-extension\
    \ ex1 ex2)\n    (< (string-downcase ex1) (string-downcase ex2)))\n  (define (first-extension\
    \ exs)\n    (first exs))\n  (define (second-extension exs)\n    (second exs))\n\
    \  (define (count-letter letter)\n    (length (string->list letter)))\n  (define\
    \ (count-letters string count)\n    (if (null? string)\n        ;; If string is\
    \ a zero-length string, then all letters are\n        ;; counted.\n        count\n\
    \        ;; Otherwise count the letters.\n        (count-letters (string->list\
    \ string) (+ count count))))\n  (define (count-letters-extensions extensions count)\n\
    \    (define (count-letters-extension (exs count) (letter count))\n      (cond\n\
    \        ((null? exs)\n         count)\n        ((null? (car exs))\n         (count-letters-extension\
    \ (cdr exs) count\n                                       (add1 count)))\n   \
    \     (else\n         (count-letters-extension (car exs) count\n             \
    \                          (add1 count)))))\n    (count-letters-extensions extensions\
    \ count))\n  (define (count-letters-extensions-by-strength extensions count)\n\
    \    (define (count-letters-extensions-by-strength (exs count))\n      (cond\n\
    \        ((null? exs)\n         count)\n        ((null? (car exs))\n         (count-letters-extensions-by-strength\
    \ (cdr exs)\n                                              (add1 count)))\n  \
    \      (else\n         (count-letters-extensions-by-strength (car exs)\n     \
    \                                         (add1 count)))))\n    (count-letters-extensions-by-strength\
    \ extensions count))\n  (define (strong-extension exs count)\n    (cond (null?\
    \ exs)\n          (empty-extension? count)\n          (string-append (format \"\
    \" count) (format \"\" class_name))\n          (true\n           (format \"%s.\"\
    \ (string-downcase class_name))\n           (format \"\" (string-downcase (format\
    \ \"\" count (car exs)))))\n          ((compare-extension (second-extension (exs))\
    \ (second-extension (cdr exs))))\n          ((compare-extension (second-extension\
    \ (cdr exs)) (first-extension (cdr exs))))\n          ((compare-extension (first-extension\
    \ (cdr exs)) (first-extension (car exs))))\n          ((compare-extension (first-extension\
    \ (car exs)) (second-extension (", "  (cond\n    [(empty? extensions) '']\n  \
    \  [(equal? (string-length class_name) (string-length extensions)) (concat class_name\
    \ extensions)]\n    [else (cons (substring (class_name 0 (string-length class_name))\
    \ (length (first extensions)) (substring (class_name 0 (string-length class_name))\
    \ 0 0))\n             (concat class_name \n                    (map \n       \
    \              #(substring extensions (string-length extensions) (* 2 (string-length\
    \ extensions)) (+ 0 (string-length extensions))) \n                     (reverse\
    \ extensions))\n                     (map \n                     #(substring extensions\
    \ (string-length extensions) (* 1 (string-length extensions)) (+ 0 (string-length\
    \ extensions))) \n                     (reverse extensions))\n               \
    \      (map \n                     #(substring extensions (string-length extensions)\
    \ (* 0 (string-length extensions)) (+ 0 (string-length extensions))) \n      \
    \               (reverse extensions)))]))\n", "  (cond\n    ((null? extensions)\
    \ (format nil \"~S.\" class_name))\n    ((= (length extensions) 1) (format nil\
    \ \"~S.\" class_name))\n    (else\n     (let ((extension (caar extensions))))\n\
    \       (cond\n        (\n         ((> extension (length extensions))\n      \
    \    (format nil \"~S.\" class_name))\n         (else\n          (format nil \"\
    ~S.\" class_name extension))))))\n", "  (if (null? extensions)\n      '#error\n\
    \      (let ((cap (length class_name)))\n        (let ((sm  (length extensions)))\n\
    \          (cond\n            ((< cap sm)\n             (cond \n             \
    \  ((< cap sm) (make-string-append class_name \".\" (take-first (reverse extensions))))\n\
    \               (else (make-string-append class_name \".\" (take-first (reverse\
    \ extensions))))))\n            ((= cap sm)\n             (cond \n           \
    \    ((< cap sm) (make-string-append class_name \".\" (take-first (reverse extensions))))\n\
    \               (else (make-string-append class_name \".\" (take-first (reverse\
    \ extensions))))))\n            (else\n             (cond \n               ((<\
    \ cap sm) (make-string-append class_name \".\" (take-first (reverse extensions))))\n\
    \               (else (make-string-append class_name \".\" (take-first (reverse\
    \ extensions))))))))))))\n", "  (cond [(empty? extensions) '()]\n        [(= (length\
    \ class_name) 1)\n         (format nil \"~a.\" (substring class_name 0 1))]\n\
    \        [else \n         (max (List-Max (map str (group-by (lambda (s) (count\
    \ s) extensions)) extensions))\n              (list class_name))]))\n", "  (cond\
    \ (null? extensions)\n      (Error \"No extensions given\"))\n  (cond [(string-length\
    \ (car extensions)) < (string-length (car class_name))]\n        ((string=? (car\
    \ extensions) (car class_name))\n         (reverse (cdr extensions) (reverse class_name))))\n\
    \  (else\n      (if (< 0 (/ (string-length (car class_name))\n               \
    \    (string-length (car extensions)))\n             (- 0 (- (string-length (car\
    \ class_name))\n                       (string-length (car extensions)))))\n \
    \         (cond [(string=? (car extensions) (car class_name))\n              \
    \     (reverse (cdr extensions) (reverse class_name))]\n                [else\
    \ (Error \"Extensions list too small\")])))\n  ", "  (define (Extension_Strongest-Extension\
    \ ext)\n    (let ((ca (string-length ext)))\n      (cond ((< ca sm)\n        \
    \     (string=? ext (substring class_name 0 ca))))\n            (else\n      \
    \       (string=? ext (substring class_name 0 ca))))))\n  (cond\n    ((null? extensions)\n\
    \     (string-append (substring class_name 0 sm) (substring class_name sm sm)))\n\
    \    ((Extension_Strongest-Extension extensions) (first (sort extensions)))))\n\
    </code>\n<|/ q |>\n<| c |>\nWhat is the problem you are having?\n<|/ c |>\n<|\
    \ c |>\nPlease describe the exact problem you are having with your code.  I see\
    \ a lot of code but no specific problem.  Please describe the problem and we can\
    \ help you with it.\n<|/ c |>\n<| c |>\nSo what is the problem? I see some code\
    \ but no problem statement.\n<|/ c |>\n<| c |>\nPlease describe the problem you\
    \ are having with the above code.  \"I can't get the right answer\" is not a problem\
    \ statement.  Please explain what the code is supposed to do.  Do you get an error\
    \ message?  Unexpected results?\n<|/ c |>\n<| c |>\nYou say \"it doesn't work\"\
    , and you show no error messages.\n<|/ c |>\n<| a |>\nThis solution is a little\
    \ bit more complicated than it needs to be and relies on some really interesting\
    \ Racket trickery to make it work. You will need it to understand the Racket code\
    \ in the next section.\nThe solution is a two-part one: first we find all the\
    \ extensions we care about by finding the extensions that have a length of at\
    \ least the number of letters in the class name. Then we find the extensions whose\
    \ number of letters in the class name is the highest in all the extensions we\
    \ found. That is what we call Strongest Extension.\nThe Racket code to do this\
    \ is as follows:\n<code>\n#lang racket\n", "  (let* ((strongest_extension (find-extension\
    \ class_name extensions))\n         (extension_name (caar strongest_extension))\n\
    \         (extension_strength (cdr strongest_extension))\n         (strength (-\
    \ extension_strength extension_name)))\n    (cond\n      [(zero? strength) (string-append\
    \ class_name extension_name)])\n    (else (Strongest_Extension (string-append\
    \ class_name extension_name) (cons (car strongest_extension) extensions))))))\n",
  "  (if (null? extensions) \n      (format nil \"~a\" (string-append class_name \"\
    .\"))\n      (let ((extension (caar (sort extensions (lambda (x) (+ (length x)\
    \ 2)))))\n            (strongest (caar (sort extensions (lambda (x) (if (> (length\
    \ x) 0) (- x (length extension)) 0)))))\n        (if (> (- strongest (length extension))\
    \ 0)\n            (format nil \"~a.\" (string-append class_name \".\"))\n    \
    \        (if (< strongest (length extension))\n                (format nil \"\
    ~a.\" (string-append class_name \".\" (substring extension 0 (- strongest (length\
    \ extension)))))))))\n</code>\n<|/ q |>\n<| c |>\nWhat specifically is confusing?\n\
    <|/ c |>\n<| c |>\nWhen i run it in DrRacket i get this error: \"Error: no function\
    \ clause matching (define (Strongest_Extension class_name extensions) (if (null?\
    \ extensions) (format nil \"~a\" (string-append class_name \".\"))\n         \
    \              (let ((extension (caar (sort extensions (lambda (x) (+ (length\
    \ x) 2)))))\n                            (strongest (caar (sort extensions (lambda\
    \ (x) (if (> (length x) 0) (- x (length extension)) 0)))))\n                 \
    \      (if (> (- strongest (length extension)) 0)\n                          \
    \ (format nil \"~a.\" (string-append class_name \".\"))\n                    \
    \       (if (< strongest (length extension))\n                               (format\
    \ nil \"~a.\" (string-append class_name \".\" (substring extension 0 (- strongest\
    \ (length extension)))))))))\n<|/ c |>\n<| c |>\nThat's because you forgot to\
    \ end the function definition with `'`.\n<|/ c |>\n<| a tags=racket,scheme |>\n\
    A couple of issues, as already pointed out in the comments, you need a terminating\
    \ quote (at least) at the end of the definition of Strongest_Extension. Also,\
    \ sort returns a list, so you need to call car to get the first element from that\
    \ list.\nThere are also some logic errors in the code that are easier to see if\
    \ you indent your code and comment it.\nA couple of other notes:\n\nUse begin,\
    \ it's much clearer than using lambda. \nYou have a missing parenthesis at the\
    \ end (in the definition of Strongest_Extension) where you put the closing parenthesis\
    \ for.\nYou do not need to call string-append twice. Just concatenate the two\
    \ strings.\nYou do not need to wrap the list in a call to substring.\n<|/ a ",
  "  (match extensions \n  [(empty) '.']\n  [(cons  @(first-list extensions)\n   \
    \    (if (> (length @(first-list extensions)) 1) \n           (first @(first-list\
    \ extensions))\n           (first extensions))\n       \n       (concat (first\
    \ extensions) (Strongest_Extension class_name (rest extensions))))]))\n", "  (let\
    \ ((cap (length (string-map class_name '(#\\A #\\B #\\C)))))\n    (let ((sm (length\
    \ (string-map class_name '(#\\a #\\b #\\c)))))\n      (if (< cap sm)\n       \
    \   (list-ref extensions (- (min cap sm) (min sm cap)))\n          (list-ref extensions\
    \ 0)))))\n", "  (if (empty? extensions) \n      (list class_name)\n      (let\
    \ ((cap (count (first extensions)) (sm  (count (first extensions) (second extensions))\
    \ (cap-sm))))\n        (if (> cap sm)\n            (list class_name)\n       \
    \     (append (Strongest_Extension (substring class_name 0 cap) (sublist extensions\
    \ 0 cap) (sublist extensions sm sm)))\n        )\n      )\n  )\n)\n", "  (define\
    \ (Strongest_Extension_aux (extensions strength max_length)\n    (cond\n     \
    \ [(empty? extensions) (append class_name \"\")]\n      [(>= strength (/ (length\
    \ extensions) 2)) (Strongest_Extension_aux extensions (+ strength (/ (length extensions)\
    \ 2)) max_length)]\n      [else (if (>= strength (/ (length extensions) 1)) \n\
    \                (append (substring class_name 0 max_length) \".\" \n        \
    \                 (substring class_name 0 max_length)\n                      \
    \   extensions)\n                (Strongest_Extension_aux extensions (+ strength\
    \ (/ (length extensions) 1)) max_length)])]))\n  (Strongest_Extension_aux extensions\
    \ 0 0))\n", "  (let ((cap (length class_name)) (sm  (length class_name))\n   \
    \      (strongest-extension (first extensions)) \n         (strength (if (> (-\
    \ cap sm) 0) (- cap sm) (- sm))))\n    (if (null? extensions)\n        strongest-extension\n\
    \        (if (< (first extensions) strongest-extension)\n            (begin (set!\
    \ strongest-extension (first extensions))\n                  (set! strength (if\
    \ (> (- cap sm) 0) (- cap sm) (- sm)))\n                  (set! extensions (rest\
    \ extensions))\n                  (strongest_Extension class_name extensions))\n\
    \            (begin (set! extensions (rest extensions))\n                  (set!\
    \ strength (if (> (- cap sm) 0) (- cap sm) (- sm)))\n                  (strongest_Extension\
    \ class_name extensions))))))\n", "  (cond\n    [(empty? extensions) \"\"]\n \
    \   [else (cons \n            (sub1 (string-length class_name))\n            (sub1\
    \ (str-length extensions))\n            (sort-by (lambda (str) (string->number\n\
    \                (string->list str (string->string class_name))))\n          \
    \          extensions)]))) \n</code>\n<|/ q tags=racket,lisp,scheme |>\n<| c |>\n\
    You say you get an error message, but don't tell us what the error message is.\
    \ Do you get an error message? A runtime error? Please update your question to\
    \ give this information.\n<|/ c |>\n<| c |>\nI get the error message \"Error:\
    \ unbound identifier in: a\" and the program will exit with an error code. Sorry\
    \ for the confusion.\n<|/ c |>\n<| c |>\nI added the error message in the main\
    \ post.\n<|/ c |>\n<| c |>\nThe code you pasted here does not seem to be the code\
    \ you're using. The error message you quoted is about a variable `a` that you\
    \ did not define. I don't know what your code is doing, but you probably defined\
    \ a variable `a` in the function `my_extension_sort`, or maybe you defined a function\
    \ `a` in the environment in which `my_extension_sort` is called.\n<|/ c |>\n<|\
    \ a |>\nIt seems that the error you are getting is caused by the following two\
    \ lines of code in Strongest_Extension:\n<code>", "  (cond\n    [(empty? extensions)\
    \ '']\n    [(= (length class_name) 1) \n     (string-append class_name extensions)]\n\
    \    [else\n     (string-append (substring class_name 0 (string-length class_name-1)))\n\
    \     (string-append (substring class_name 1 \n                          (string-length\
    \ class_name-2))\n                   (string-append extensions \".\"))]\n    )\n\
    \  )\n", "  (define CAP (length class_name))\n  (define SM (length extensions))\n\
    \  (define CAP-SM (float CAP SM))\n  (define SM-extensions (sort extensions #<\n\
    \                         (lambda (x)\n                           (cond\n    \
    \                        [(< (float CAP (length x)) CAP-SM) x]\n             \
    \               [(< (float SM (length x)) CAP-SM) x]\n                       \
    \     [else x]\n                           )\n                         >)\n  )\n\
    \  (cond\n    [(empty? extensions) \"\"]\n    [else \n        (define (ext-index\
    \ x)\n          (cond\n            [(< (float CAP (length x)) CAP-SM) x]\n   \
    \         [(< (float SM (length x)) CAP-SM) x]\n            [else x]\n       \
    \   )\n        )\n        (cond (empty? extensions) \"\"\n               (> (length\
    \ extensions) SM) \n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)\n               (ext-index extensions)\n               (ext-index\
    \ extensions)", "  (cond\n    [(empty? extensions) \"\"]\n    [(equal? (substring\
    \ (symbol->string class_name) 0 1)\n                (first extensions)) \n   \
    \  (string-append (symbol->string class_name) \".\" (first extensions))]\n   \
    \ [else (Strongest_Extension (last extensions) extensions)]))\n", "  (define (best_extension\
    \ extensions)\n    (cond\n      [(empty? extensions) extensions]\n      [(eq?\
    \ (car extensions) extensions)\n       (append class_name \n               (reverse\
    \ extensions))]\n      [else\n       (cond\n         [(member (car extensions)\
    \ extensions)\n          (append class_name \n                  (best_extension\
    \ (cdr extensions)))]\n         [else\n          (append class_name \n       \
    \           (best_extension (reverse extensions))))]]))\n  (best_extension (reverse\
    \ extensions)))\n</cell>\n<cell>\n%load 'solutions/strongest-extension-problem.rkt'\n\
    </cell>\n<cell>", "  (let ((strongest (max_element (map strength extensions) (comparing\
    \ negative))))\n    (concat class_name \".\" (substring strongest)))))\n", " \
    \ (cond [(null? extensions) (list class_name)]\n        [(extension-strength extensions)\
    \ \n         (string-append class_name (extension-name extensions))]))\n", " \
    \ (define strengths \n      (map (\u03BB (x)\n             (if (> (count x) 1)\n\
    \                 (- \n                  (length (string->symbol (symbol->string\
    \ (substring x 0 (count x))))) \n                  (length (string->symbol (symbol->string\
    \ (substring x 1 (count x))))))\n               0))\n         extensions))\n \
    \ (sort (\u03BB (x y)\n          (if (<= (strengths x) strengths y)\n        \
    \      (< x (cons y x))\n              (< y (cons x y)))) extensions)\n  (second\
    \ extensions))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCan you give an example of\
    \ what this would look like in a piece of code?  I'm new to Racket and don't have\
    \ a clue what you're referring to.\n<|/ c |>\n<| c |>\nI'm very impressed with\
    \ your ability to teach a language that way!\n<|/ c |>\n<| c |>\nI'm glad to help\
    \ you understand Racket better. I'd like to give you some examples for you but\
    \ StackOverflow doesn't have enough space to do so. I'm glad you find my experience\
    \ useful.\n<|/ c |>\n<| c |>\nI've edited my answer to include some examples of\
    \ what this might look like. Hopefully it helps you.\n<|/ c |>\n<| c |>\nWow,\
    \ thanks!  I understand it more now.  You're a gentleman and a scholar!\n<|/ c\
    \ |>\n<| a |>\nHere's how I would do this:\n<code>", "  (let loop ((classes '())\n\
    \             (extensions '())\n             (extension '()))\n    (if (or (empty?\
    \ classes)\n            (empty? extensions))\n        '()\n        (let ((name\
    \ (first classes))\n              (index (length classes)))\n          (set! extension\
    \ (first extensions))\n          (set! extensions (rest extensions))\n       \
    \   (loop (rest classes)\n                (cons extension extensions)\n      \
    \          (cons name extension)))))\n  (define (sort list key)\n    (sort list\
    \ (lambda (x)\n                  (if (> key x) 0 1))))\n  (define (sort-by-strongest-extension\
    \ l strongest-extension)\n    (sort l (lambda (x)\n              (/ (- (length\
    \ x) (strongest-extension x)) (length x))))\n    (sort l (lambda (x)\n       \
    \       (if (= x strongest-extension) \n                  0\n                \
    \  1))))\n  (sort-by-strongest-extension extensions extension))", "  (define (CAP_SM\
    \ extension_name)\n    (/ (length extension_name) 2))\n  (define (EXTENSION_SM\
    \ extension_name)\n    (length extension_name))\n  (define (EXTENSION_STRENGTH\
    \ extension_name)\n    (let ((CAP (CAP_SM extension_name)))\n      (let ((SM (EXTENSION_SM\
    \ extension_name)))\n        (if (> CAP SM)\n            (- CAP SM)\n        \
    \    (- SM CAP))))\n  (define (STRONGER_EXTENSION extension_name extension_strength)\n\
    \    (cond (extension_strength < (EXTENSION_STRENGTH extension_name))\n      \
    \    extension_name \n          extension_name))\n  (define (STRONGEST_EXTENSION\
    \ extension_name extensions)\n    (let ((extension_strength (EXTENSION_STRENGTH\
    \ extension_name)))\n      (cond\n       ((= extension_strength 0)\n        '())\n\
    \       ((= extension_strength 1)\n        (EXTENSION_LIST extensions))\n    \
    \   ((< extension_strength 1)\n        (EXTENSION_LIST (sort extensions #< ;;\
    \ This sorts the extensions in ascending order of strength\n                 \
    \           ;; then it takes the strongest one.\n                            (lambda\
    \ (extension1 extension2)\n                              (if (extension_strength\
    \ > extension1)\n                                  (extension_strength extension1)\n\
    \                                  (extension_strength extension2)))))))\n   \
    \ (if (null? extensions)\n        extension_name\n        (STRONGER_EXTENSION\
    \ extension_name extension_strength)))) ; This is probably a bug.\n", "  (let\
    \ ([extension_strongest (max extensions)]\n        [extension_count (length extensions)]\n\
    \        [strongest_extension_str (string-append class_name \".\" \"\")])\n  \
    \  (if (= extension_count 1)\n        (string-append strongest_extension_str (string-append\
    \ extension_strongest \".\" \"\"))\n        (loop for extension in extensions\
    \ \n              for [count (1- count)] \n              when (> (string-length\
    \ extension_strongest (string-length extension))\n                      (- extension_count\
    \ 1))\n              collect (cons (substring extension 0 (string-length extension))\
    \ \n                            (substring extension (string-length extension)\
    \ 1))\n              into extension_strongest)\n        strongest_extension_str)))\n",
  "  (cond [(empty? extensions)\n         \"\"]\n        [(>= (length class_name)\
    \ (length extensions))\n         \"\"]\n        [(= (length class_name) (length\
    \ extensions))\n         (append class_name (first extensions))]\n        [else\n\
    \         (append class_name (Strongest_Extension (first extensions)\n       \
    \                                     (rest extensions)))]))\n", "  (define strongest-ext\
    \ (first extensions))\n  (cond [(empty? extensions) (error 'Strongest_Extension\
    \ '(class_name strongest-ext))]\n        [(> (length strongest-ext) (length class_name))\
    \ (error 'Strongest_Extension '(class_name strongest-ext))]\n        [else (Strongest_Extension\
    \ class_name (rest extensions))]))\n</code>\nMy Solution:\n<code>", "  (cond [(null?\
    \ extensions) (format nil \"~A\" class_name)]\n        [(> (length (string-match\
    \ (symbol->string class_name)\n                                    (map symbol->string\
    \ extensions))) 0)\n         (format nil \"~A~A\" class_name (reduce (lambda (x\
    \ y) (cons y x)) extensions))]\n        [else \n         (format nil \"~A~A~A\"\
    \ class_name \n                 (reduce (lambda (x y) (cons (symbol->string (substring\
    \ x 0 (string-length x)-1) y) x))\n                       extensions\n       \
    \                :key (lambda (x)\n                              (sort \n    \
    \                          (map string->symbol (symbol->string x))\n         \
    \                     (lambda (x y)\n                                (+ (char->integer\
    \ (symbol->string x) 36) \n                                    (char->integer\
    \ (symbol->string y) 36))))))]))\n", "  (cond ((null? extensions)\n         (list\
    \ class_name))\n        ((null? (cdr extensions))\n         (list (car extensions)\
    \ class_name))\n        (else\n         (let ((ext (car extensions)))\n      \
    \     (if (or (char-upper? (car ext))\n                  (char-lower? (car ext)))\n\
    \               (append (list class_name) (Strongest_Extension ext (cdr extensions)))\n\
    \               (append (list (car ext) class_name)))))\n        ))\n", "  (define\
    \ extensions-by-strength \n    (assoc -1 (sort extensions \n                 \
    \  (lambda (ext)\n                     (let ((cap (string->number (substring ext\
    \ 0 1)))\n                           (sm  (string->number (substring ext 1 1))))\n\
    \                       (/ (- cap sm)\n                        (cap - sm)\n  \
    \                      (- cap sm)))))))\n  (let ((extension (assoc (extensions-by-strength\
    \ (extensions-by-strength extensions)) -1 extensions))))\n  (if (and (not extension)\n\
    \t   (null (assoc -1 extensions)))\n      class_name\n      (concat (string class_name)\n\
    \              (substring extension (string->number (substring extension 0 1))\
    \ - \n                         (string->number (substring extension 1 1)) + 1))))\n",
  "  (define (Strongest_Extension_ extension all_extensions)\n    (cond\n      [(empty?\
    \ all_extensions)\n       (format nil \"~a has no extensions\" class_name)]\n\
    \      [(equal? (string-length extension) 1)\n       (format nil \"~a has only\
    \ one extension\" class_name)]\n      [else\n       (define (strongest-strength\
    \ extension)\n         (Math/- (string-length extension)\n                   (Math/-\
    \ (Math/- \n                              (string-length extension)\n        \
    \                      (Math/- \n                               (Math/- \n   \
    \                             (Math/- \n                                 (string-length\
    \ extension)\n                                 (Math/- \n                    \
    \             (Math/- \n                                  (Math/- \n         \
    \                          (Math/- \n                                    (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math/-\
    \ \n                                     (Math/- \n                          \
    \           (Math/- \n                                     (Math/- \n        \
    \                             (Math/- \n                                     (Math",
  "  (let ([capacity (count_chars class_name ?A)]\n        [smith (count_chars class_name\
    \ ?A)]\n        [extension (find_strongest extensions capacity smith)])\n    (format\
    \ nil \"~a ~a\" class_name extension)))\n", "  (cond\n    [(empty? extensions)\
    \ (error)\n     (list (cons class_name empty))\n     ]\n    [(equal? (first extensions)\
    \ (first extensions))\n     (cons (first extensions) (Strongest_Extension (rest\
    \ extensions) empty))\n     ]\n    [(equal? (first extensions) (first extensions))\n\
    \     (error (format \"There is more than one extension with same strength. Choices\
    \ are ~a, ~a, ~a\" \n                    (first extensions) (first extensions)\
    \ (rest extensions)))\n     ]\n    [else\n     (append (Strongest_Extension (first\
    \ extensions) extensions)\n            (list (cons (first extensions) empty)))\n\
    \     ]\n    )\n  )\n", "  (let ([extension_count (length extensions)])\n    (cond\n\
    \      [(= extension_count 0) (throw 'Bad extensions list size)]\n      [(= extension_count\
    \ 1) (throw 'Bad extensions list size)]\n      [else\n       (let ([extension_name\
    \ (reverse (sort extensions reverse <))])\n         (cond\n           [(char-upper-case?\
    \ extension-name (rest extension_name (length extension_name)))\n            (throw\
    \ 'Bad extensions list size)]\n           [else (set! extension_name (append extension-name\
    \ (list (rest extension_name))))])\n       \n       (let ([extension_strength\
    \ (map (lambda (s) (- (char-lower-case? s) (length extension_name)))\n       \
    \                               extension_name)])\n        (cond\n          [(>\
    \ extension_strength 0) (throw 'Bad extensions list size)]\n          [else (set!\
    \ extension_strength (min extension_strength (length extension_strength)))])\n\
    \n       (let ([extension_name (concat (reverse extension_name) \".\")])\n   \
    \     (cond\n          [(char-upper-case? extension-name (rest extension_name\
    \ (length extension_name)))\n            (throw 'Bad extensions list size)]\n\
    \           [else (set! extension_name (append extension-name (list (rest extension_name))))])\n\
    \n       (concat (reverse class_name) \".\" extension_name))]))\n", "  (let ((cap\
    \ (length class_name))\n        (sm  (length class_name))\n        (strongest))\n\
    \    (map (lambda (ext)\n           (let ((cap (length ext))\n               \
    \  (sm  (length ext)))\n             (if (> cap sm)\n                 (cons ext\
    \ strongest)\n                 (cons ext strongest)))))\n  (define (compare-str\
    \ str1 str2)\n    (< str2 str1))\n\n  (define (compare-extensions ext1 ext2)\n\
    \    (if (> (length ext1) (length ext2))\n        #t\n        (= ext1 (take ext1\
    \ #(compare-str %1 ext2)))\n        (= ext2 (take ext2 #(compare-str ext1 %1))))\n\
    \    (= (take ext1 (reverse (sort (reverse ext2))))\n      (take ext2 (reverse\
    \ (sort (reverse ext1))))))\n\n  (if (null? extensions)\n      '()\n      (let\
    \ ((ext (first (filter compare-extensions extensions))))\n        (cond ((null?\
    \ (rest extensions))\n               (reverse (sort (take class_name extensions)\
    \ compare-str))\n               (cons ext (Strongest_Extension (drop class_name\
    \ 1) extensions)))))))\n", "  (cond\n    [(null? (rest extensions)) class_name]\n\
    \    [(= (length class_name) (length extensions)) (Strongest_Extension (substring\
    \ class_name 0 1)\n                                                          \
    \  (rest extensions))]\n    [else (let ([CAP (length class_name)]\n          \
    \      [SM (length class_name)])\n            (cond\n              [(= CAP (length\
    \ extensions)) (Strongest_Extension (substring class_name 0 CAP)\n           \
    \                                             (rest extensions))]\n          \
    \    [(< CAP (length extensions)) (Strongest_Extension (substring class_name 0\
    \ SM)\n                                                        (rest extensions))]\n\
    \              [(= SM (length extensions)) (Strongest_Extension (substring class_name\
    \ CAP 0)\n                                                        (rest extensions))]\n\
    \              [(< SM (length extensions)) (Strongest_Extension (substring class_name\
    \ SM\n                                                        CAP)\n         \
    \                                               (rest extensions))]\n        \
    \      [else (error 'error \"Not a valid extension.\"))]))]))\n", "  ;; TODO\n\
    \  ;; (define (extension name) ...)\n  (define (extension name)\n    ;; TODO\n\
    \    ;; (define (strength name) ...)\n    (define (strength name)\n      (match\
    \ name\n        ((substring #f 0 (length name)) (- #f 0))\n        ((substring\
    \ #f 1 (length name)) (- #f (length name)))\n        (else (error \"Invalid extension's\
    \ name: ~S\" name))\n      )\n    )\n    \n    (define (extension name)\n    \
    \  ;; TODO\n      ;; (define (strength name) ...)\n      (define (strength name)\n\
    \        (match name\n          ((substring #f 0 (length name)) (- #f 0))\n  \
    \        ((substring #f 1 (length name)) (- #f (length name)))\n          (else\
    \ (error \"Invalid extension's name: ~S\" name))\n        )\n      )\n    )\n\
    \    \n    (define (extension name)\n      ;; TODO\n      ;; (define (strength\
    \ name) ...)\n      (define (strength name)\n        (match name\n          ((substring\
    \ #f 0 (length name)) (- #f 0))\n          ((substring #f 1 (length name)) (-\
    \ #f (length name)))\n          (else (error \"Invalid extension's name: ~S\"\
    \ name))\n        )\n      )\n    )\n    \n    (define (extension name)\n    \
    \  ;; TODO\n      ;; (define (strength name) ...)\n      (define (strength name)\n\
    \        (match name\n          ((substring #f 0 (length name)) (- #f 0))\n  \
    \        ((substring #f 1 (length name)) (- #f (length name)))\n          (else\
    \ (error \"Invalid extension's name: ~S\" name))\n        )\n      )\n    )\n\
    \    \n    (define (extension name)\n      ;; TODO\n      ;; (define (strength\
    \ name) ...)\n      (define (strength name)\n        (match name\n          ((substring\
    \ #f 0 (length name)) (- #f 0))\n          ((substring #f 1 (length name)) (-\
    \ #f (length name)))\n          (else (error \"Invalid extension's name: ~S\"\
    \ name))\n        )\n      )\n    )\n    \n    (define (extension name)\n    \
    \  ;; TODO\n      ;; (define (strength name) ...)\n      (define (strength name)\n\
    \        (match name\n          ((substring #f 0 (length name)) (- #f 0))\n  \
    \        ((sub", "  (cond\n    [(empty? extensions) '']\n    [(> (length extensions)\
    \ 1) (throw 'WrongFormat '\"Extensions list has only one element\" class_name)]\n\
    \    [(equal? (first extensions) (first extensions)) (cons (first extensions)\
    \ class_name)]\n    [else (Strongest_Extension (cons (first extensions) class_name)\
    \ (rest extensions))]))\n", "  (let ([cap (length class_name)])\n    (cond\n \
    \     [(< cap (length extensions)) (first extensions)]\n      [(< cap (length\
    \ extensions)) (last extensions)]\n      [(> cap (length extensions)) (first extensions)]\n\
    \      [(> cap (length extensions)) (last extensions)] \n      [(= cap (length\
    \ extensions)) extensions]\n      [(> (/ (- cap (length extensions)) (length extensions)))\
    \ extensions]\n      [(< (/ (- cap (length extensions)) (length extensions)))\
    \ extensions]\n      [else (error 'Strongest_Extension \"~A\" has too many extensions'\n\
    \                   (cons class_name extensions))])))\n", "  (let\n      ([cap\
    \ (length class_name)]\n       [sm  (length extensions)])\n      (cond [(= cap\
    \ sm)\n             class_name]\n            [(= cap sm) (cons class_name extensions)]\n\
    \            [else\n             (let\n                  ([sorted_extensions (sort\
    \ extensions)])\n               (string-join (cons class_name sorted_extensions))]))]))\n",
  "  (define cap (length class_name))\n  (define sm  (length extensions))\n\n  (define\
    \ (CAP-SM)\n    (* cap (- sm)))\n\n  (define (SM-CAP)\n    (- sm (* cap (- cap))))\n\
    \n  (define (strength ext)\n    (if (<= (CAP-SM) (SM-CAP))\n        (if (eqv?\
    \ (char-upper-case (first ext)) (char-upper-case (first class_name)))\n      \
    \      (/ (+ (char-upper-case (first ext)) (char-upper-case (first class_name)))\
    \ (SM-CAP))\n            (/ (+ (char-lower-case (first ext)) (char-lower-case\
    \ (first class_name))) (SM-CAP)))))\n\n  (let ((max (list (strength ext) (first\
    \ ext) (second ext))))\n    (cond\n      [(empty? extensions)\n       (string-append\
    \ class_name max)]\n      [(eqv? (first extensions) (first max))\n       (string-append\
    \ (first class_name) (second max))] \n      [else\n       (string-append (first\
    \ class_name) (first max) (second max))]))\n", "  (cond ((null? extensions) (list\
    \ class_name))\n        ((null? (cdr extensions)) (list class_name))\n       \
    \ (else (let ([class_name (car extensions)])\n              (let ([strongest (string-equal?\
    \ (string-length class_name)\n                                        (string-length\
    \ extensions))])\n                (if (null? strongest)\n                    (cons\
    \ class_name extensions)\n                    (let ([extension (car (assoc strongest\n\
    \                                          (list-ref extensions strongest)))])\n\
    \                      (cons (string-append class_name extension) extensions))))))))\n",
  "  (define (compare_extensions ext ext)\n    (let ((cmp (- (length ext) (length\
    \ ext))))\n      (cond ((< cmp 0) 0)\n            ((= cmp 0) (< ext ext))\n  \
    \          (else (= ext ext))))))\n  (define (extension-list ext ext exts)\n \
    \   (cond ((< ext 0) exts)\n          ((> ext 0) (extension-list ext (sub1 ext)\
    \ exts))\n          (else (append (list ext) exts))))\n  (define (find_extensions\
    \ class_name extensions)\n    (let ((extensions-found (list '')))\n      (map\
    \ (lambda (e) (if (> (length e) 0) (append extension-list e extensions-found)\
    \ '()))\n           (filter (lambda (ext) (equal? (sub1 class_name) ext)) extensions))))\n\
    \  (let ((extensions-found (list '')))\n    (map (lambda (e) (if (> (length e)\
    \ 0) (append extension-list e extensions-found) '()))\n           (filter (lambda\
    \ (ext) (equal? (sub1 class_name) ext)) extensions))))\n  (sort extensions-found\
    \ (lambda (e) (< (length e) (length (Strongest_Extension class_name (map sub1\
    \ extensions)))))))\n)\n", "  (let* ((strength-count (list-length extensions))\n\
    \         (strengths (make-list strength-count (\u03BB () (list-ref extensions\
    \ 0)))))\n    (for/fold ((strength 0) (i 0) (extension extensions))\n      ((\u03BB\
    \ (i extension) (set! strength (* i strength)))\n       (set! strengths (\u03BB\
    \ (strengths i) (cons strength (sub1 strengths))))\n       (incf i))\n      (set!\
    \ strengths strengths))\n    (let ((max (max strengths)))\n      (if max\n   \
    \       (sub1 class_name max)\n          (sub1 class_name 0)))\n    (map sub1\
    \ extensions))\n", "  (let* ((extension-letters (string->list extensions))\n \
    \        ((extension-letters-count (length extension-letters))\n          (extensions-count\
    \ 0))\n         (extension-strongest (list \"\"))\n         ((extension-strongest-capacity\
    \ (- extension-letters-count 1))\n          (extension-strongest-strength (- extension-letters-count\
    \ 1)))\n         (extension (first extension-letters))\n         (extensions (rest\
    \ extension-letters))\n         (letter-count 0)\n         (strongest (list class_name)))\n\
    \    (while extensions\n      (set! (first strongest) (cons (first extension)\
    \ (first strongest)))\n      (set! (first extension) (first extensions))\n   \
    \   (set! (first extensions) (first extensions))\n      (set! letter-count (+\
    \ letter-count 1))\n      (when (> letter-count extension-letters-count)\n   \
    \     (set! extension-strongest-strength (- extension-strongest-strength 1))\n\
    \        (set! extension-strongest-capacity (- extension-strongest-capacity 1)))\n\
    \      (when (< extension-strongest-strength (/ extension-strongest-capacity 2))\n\
    \        (set! extension-strongest-strength (/ extension-strongest-capacity 2)))\n\
    \      (set! extension-strongest-capacity (+ extension-strongest-capacity 1)))\n\
    \    (when (> extension-strongest-strength 0)\n      (set! extension-strongest-strength\
    \ (- extension-strongest-strength 1))\n      (set! extension-strongest (string-append\
    \ (first strongest) \".\" (first extension))))\n    (first strongest)))\n", " \
    \ (if (null? extensions)\n      class_name\n      (let ([cap (length class_name)]\n\
    \            [sm  (length extensions)])\n        (let ([strength (- cap sm)])\n\
    \          (cond ((< strength 0) (cons class_name extensions))\n             \
    \   (else (cons (first extensions)\n                            (Strongest_Extension\n\
    \                             #(substring class_name 0 cap)\n                \
    \             extensions)))))))\n", "  (let ((caps (count (substring class_name\
    \ 0 (string-length class_name)))))\n    (let ((sms (count (substring class_name\
    \ (string-length class_name) (string-length class_name)))) \n          (strongest_extension\
    \ (list class_name '())))\n      (for ((i 0) (< i (- caps (- sm 0))))\n      \
    \  (cond\n          ((equal? (substring extensions i (+ i (string-length extensions)))\
    \ \n                  (substring extensions i (+ i (string-length extensions))))\n\
    \            (set! strongest_extension (append strongest_extension\n         \
    \                                  (list (substring class_name \n            \
    \                                    (+ i (string-length extensions))))))\n  \
    \        ((equal? (substring extensions i (+ i (string-length extensions))) \n\
    \                  (substring extensions (- i (+ i (string-length extensions)))\
    \ \n                              (string-length class_name)))\n            (set!\
    \ strongest_extension (append strongest_extension\n                          \
    \                 (list (substring class_name \n                             \
    \                   (+ i (string-length extensions))))))\n          ((equal? (substring\
    \ extensions i (+ i (string-length extensions))) \n                  (substring\
    \ extensions (+ i (+ i (string-length extensions))) \n                       \
    \       (string-length class_name)))\n            (set! strongest_extension (append\
    \ strongest_extension\n                                           (list (substring\
    \ class_name \n                                                (+ i (string-length\
    \ extensions))))))\n          ((equal? (substring extensions i (+ i (string-length\
    \ extensions))) \n                  (substring extensions (+ i (+ i (string-length\
    \ extensions))) \n                              (string-length class_name)))\n\
    \            (set! strongest_extension (append strongest_extension\n         \
    \                                  (list (substring class_name \n            \
    \                                    (+ i (string-length extensions))))))\n  \
    \        ((equal? (substring extensions i (+ i (string-length extensions))) \n\
    \                  (substring extensions (+ i (+ i (string-length extensions)))\
    \ \n                              (string-length class_name)))\n            (set!\
    \ strongest_extension (append strongest_extension\n                          \
    \                 (list (substring class_name \n                             \
    \                   (+ i (string-length extensions)))))))\n      (strongest_extension))))\n",
  "  (define (Strongest_Extension-helper name extension)\n    (cond ((null? extension)\
    \ (cons name (list '-1 '-1)))\n          ((char-upper-case (caar extension))\n\
    \           (cond ((null? (cdar extension)) \n                  (cons name extension))\n\
    \                 ((> (car extension) \n                      (char-lower-case\
    \ (caar extension)))\n                  (cons (car extension) (list name (cdr\
    \ extension))))\n                 (else (cons (car extension) (list name extension))))\n\
    \          ((char-lower-case (caar extension))\n           (cond ((null? (cdar\
    \ extension)) \n                  (cons name extension))\n                 ((>\
    \ (car extension) \n                      (char-upper-case (caar extension)))\n\
    \                  (cons (car extension) (list name (cdr extension))))\n     \
    \            (else (cons (car extension) (list name extension))))\n          ((>\
    \ \n               (char-upper-case (caar extension)) \n               (char-upper-case\
    \ (caar extension)))\n          ((char-lower-case (caar extension)) \n       \
    \    (cons name (list '-1 (char-lower-case (caar extension)))))))\n  (let ((strongest-extension\
    \ (list (list '-1 '-1))))\n    (for-each (lambda (extension) (Strongest_Extension-helper\
    \ class_name extension))\n               extensions)))", "  (cond\n    [(empty?\
    \ extensions) '']\n    [(member class_name extensions) (Concat class_name '.'\
    \ \n            (first extensions))]\n    [else\n      (max extensions\n     \
    \     (lambda (extension)\n            (cond\n              [(member class_name\
    \ extension) (Concat class_name '.' \n                    (first extension))]\n\
    \              [else (Concat class_name '.' \n                    (first extensions))])))]))\n",
  "  (define (compare ext1 ext2)\n    (cond\n      [(string=? (string-length(ext1)\
    \ ext2) 0)\n       (string-compare ext1 ext2)]\n      [(string=? (string-length(ext1)\
    \ ext2) 1)\n       (string-compare ext1 ext2 false)]\n      [else (string-compare\
    \ (string-append class_name ext1) (string-append class_name ext2) false)]))\n\n\
    \  (define (extension-strength ext)\n    (let ([strength 0]\n           (ext ext)\n\
    \           (count 0)\n           (index 0)\n           (char '?)\n          \
    \ (first false)\n           (last false)\n           (count 0))\n      (cond [(string=?\
    \ (string-length ext) 0)\n             0]\n            [(char=? (car ext) ??)\n\
    \             (* count (+ (string-length ext) (+ 1 strength)))]\n            [(string=?\
    \ (string-length ext) 1)\n             (* count (+ (string-length ext) (+ 1 strength)))]\n\
    \            [else (for \n                    (char ??)\n                    (ext\
    \ ext)\n                    ([index 0]))\n             (for \n               \
    \     (char ??)\n                    (ext ext)\n                    ([count 0]))\n\
    \             (for \n                    (char ??)\n                    (ext ext)\n\
    \                    ([index 0])\n                    ([first false])\n      \
    \              ([last false])\n                    ([count 0]))\n            \
    \ (for \n                    (char ??)\n                    (ext ext)\n      \
    \              ([index 0])\n                    ([first false])\n            \
    \        ([last true])\n                    ([count 0]))\n             (for \n\
    \                    (char ??)\n                    (ext ext)\n              \
    \      ([index 0])\n                    ([first true])\n                    ([last\
    \ false])\n                    ([count 0]))\n             (for \n            \
    \        (char ??)\n                    (ext ext)\n                    ([index\
    \ 0])\n                    ([first true])\n                    ([last true])\n\
    \                    ([count 0]))\n             (for \n                    (char\
    \ ??)\n                    (ext ext)\n                    ([index 0])\n      \
    \              ([first false])\n                    ([last false])\n         \
    \           ([count 1])])\n            (else (for \n                    (char\
    \ ??)\n                    (ext ext)\n                    ([index 0])\n      \
    \              (for \n                        (char ??)\n                    \
    \    (ext ext)\n                        ([count 1])\n                        ([count\
    \ 0]))\n            (else (for \n                    (char ??)\n             \
    \       (ext ext)\n                    ([index 0])\n                    (for \n\
    \                        (char ??)\n                        (ext ext)\n      \
    \                  ([count 0])\n                        ([count 1])\n        \
    \                ([count 0]))\n            (else (for ", "  (cond\n    [(empty?\
    \ extensions)\n     (string-append class_name \".\" empty)]\n    [(equal? (first\
    \ extensions) (string-uppercase-char (first extensions))\n             (string-lowercase-char\
    \ (first extensions)))\n     (string-append class_name \".\" (first extensions))]\n\
    \    [else\n     (let ([new_extensions (map \n                           extensions\
    \ \n                           (lambda (x)\n                             (cond\n\
    \                              [(equal? (first x) (string-uppercase-char (first\
    \ x))\n                                    (string-lowercase-char (first x)))\n\
    \                                (cons (first x) new_extensions)] \n         \
    \                     [(equal? (first x) (string-lowercase-char (first x))\n \
    \                                   (string-uppercase-char (first x)))\n     \
    \                           (cons (first x) new_extensions)]\n               \
    \               [else\n                                (cons x new_extensions)])\n\
    \                           )\n                       (length (remove-if (lambda\
    \ (x)\n                                                (equal? (first x) \n  \
    \                                                  (string-uppercase-char (first\
    \ x)) \n                                                    (string-lowercase-char\
    \ (first x)))\n                                               extensions)))\n\
    \                       (sort new_extensions \n                             (lambda\
    \ (x y)\n                               (< (length (remove-if (lambda (x)\n  \
    \                                                      (equal? (first x) \n  \
    \                                                          (string-uppercase-char\
    \ (first x)) \n                                                            (string-lowercase-char\
    \ (first x)))\n                                                       extensions))\
    \ \n                                          (length (remove-if (lambda (x)\n\
    \                                                                (equal? (first\
    \ x) \n                                                                    (string-lowercase-char\
    \ (first x)) \n                                                              \
    \      (string-uppercase-char (first x)))\n                                  \
    \                           extensions)))))))]\n      (let ([extension_name (first\
    \ extensions)])\n        (cond\n          [(empty? new_extensions)\n         \
    \  (string-append class_name \".\" extension_name)]\n          [(equal? (first\
    \ new_extensions) extension_name)\n           (string-append class_name \".\"\
    \ extension_name)]\n          [else\n           (let ([extension_name (first new_extensions)])\n\
    \             (cond\n               [(empty? new_extensions)\n               \
    \ (string-append class_name \".\" extension_name)]\n               [(equal? (first\
    \ new_extensions) extension_name)\n                (string-append class_name \"\
    .\" extension_name)]\n               [else\n                (let ([extension_name\
    \ (first new_extensions)])\n                  (string-append class_name \".\"\
    \ extension_name)]\n                 (cond\n                   [(empty? new_extensions)\n\
    \                    (string-append class_name \".\" extension_name)] \n     \
    \              [(equal? (first new_extensions) extension_name)\n             \
    \       (string-append class_name \".\" extension_name)] \n                  \
    \ [else\n                    (string-", "  (cond\n    [(null? extensions) (error\
    \ 'my-errors '\"No extensions given.\" 'extensions)]\n    [(null? (cdr extensions))\
    \ (error 'my-errors '\"The last extension in the list must be the strongest extension.\"\
    \ extensions)]\n    [(= (length class_name) (car extensions))\n     (error 'my-errors\
    \ '\"The class name given should only have one extension.\" extensions)]\n   \
    \ [else\n     (cond [(= (length extensions) (length class_name)) (error 'my-errors\
    \ '\"The class name given cannot have more extensions than extensions.\" extensions)]\n\
    \           [else (let ([extension_name (list-ref extensions 0)])\n          \
    \           (cond\n                       [(string? (string-reverse extension_name))\n\
    \                        (error 'my-errors '\"Extension names must be in lower\
    \ case.\" extension_name)]\n                       [else \n                  \
    \      (cond\n                         [(string-length extension_name) (string-length\
    \ extension_name)\n                           (error 'my-errors '\"The extension's\
    \ name must have one lower case letter.\" extension_name)]\n                 \
    \        [else \n                          (cond\n                           [(string->number\
    \ (string-to-chars (string->list extension_name)))\n                         \
    \   (error 'my-errors '\"The extension's name must only have letters.\" extension_name)]\n\
    \                           [else \n                            (cond\n      \
    \                       [(> extension_name (string-length extension_name))\n \
    \                             (error 'my-errors '\"The extension's name must be\
    \ the length of the class name.\" extension_name)]\n                         \
    \    [else (cons extension_name extensions)])]))])))])))]))\n", "  (let ([cap\
    \ 0]\n        [sm 0])\n    (for ext in extensions\n      (if (string-match #rx\"\
    ^[A-Z][a-z]\" ext)\n          (incf cap (string->number (string-ref ext 0) #rx\"\
    [A-Z]\")\n                (incf sm (string->number (string-ref ext 0) #rx\"[a-z]\"\
    )\n                        (cap sm))\n          (incf cap (string->number (string-ref\
    \ ext 0) #rx\"[A-Z]\")\n                (incf sm (string->number (string-ref ext\
    \ 0) #rx\"[a-z]\")\n                        (cap sm)))))\n    (string->string\
    \ class_name #rx\".\"\n                  (string->string class_name #rx\".\")\n\
    \                  (cap sm)))", "  (define (my_strongest_extension extension_name\
    \ class_name)\n    (cond\n      [(null? extensions) (printf \"%s.\" class_name)]\n\
    \      [(equal? (length extension_name) (length extensions)) \n       (printf\
    \ \"%s.\" (substring (class_name 0 (length extension_name)))]\n      [(< (length\
    \ extension_name) (length extensions))\n       (printf \"%s.\" (substring (class_name\
    \ 0 (length extensions)) 0 1))]\n      [(< extension_name (length extensions))\n\
    \       (printf \"%s.\" (substring (class_name 0 (length extension_name)) 0 1))]\n\
    \      [else (printf \"%s.\" (substring (class_name 0 (length extensions))))]\n\
    \      ))\n  (my_strongest_extension extensions class_name))\n</code>\n<|/ q dscore=0\
    \ |>\n<| a tags=racket,scheme,recursion dscore=2 |>\nThis isn't really a good\
    \ fit for Stack Overflow. Let's try this instead:\n<code>\n#lang racket\n", " \
    \ (define (StrongestExtensionName extension)\n    (string-join\n     `(,(substring\
    \ class_name 0 (string-length extension))\n       .,(substring extension 1 (string-length\
    \ extension)))\n     \".\"))\n  (define (FindStrongestExtension extensions strength)\n\
    \    (let ((strongest-extension (first extensions)))\n      (if (equal strength\
    \ 0)\n          strongest-extension\n          (find-if (lambda (extension) (>=\
    \ strength (- strength (string->int extension))))\n                   extensions))))\n\
    \  (let ((extension-strength (string->int (first extensions))))\n    (let ((strength\
    \ (- extension-strength (string->int (first extensions)))))\n      (find-if (lambda\
    \ (extension) (= strength extension-strength)) \n               extensions)))\n\
    \  (let ((extension (FindStrongestExtension extensions strength)))\n    (cond\
    \ ((null? extension)\n           \"\")\n          ((null? (rest extensions))\n\
    \           extension)\n          (else\n           (StrongestExtensionName extension))))))\n",
  "  (let ((number_of_uppercase (length class_name))\n        (number_of_lowercase\
    \ (length class_name))\n        (number_of_capital (length class_name))\n    \
    \    (number_of_other_letters (length class_name))\n        (number_of_strongest\
    \ number_of_uppercase)\n        (number_of_others number_of_lowercase)\n     \
    \   (number_of_capitals number_of_capital))\n    (if (<= number_of_uppercase number_of_lowercase)\n\
    \        (set! number_of_strongest number_of_uppercase)\n        (set! number_of_others\
    \ number_of_lowercase))\n    (if (<= number_of_capitals number_of_other_letters)\n\
    \        (set! number_of_strongest number_of_capitals)\n        (set! number_of_others\
    \ number_of_other_letters))\n    (if (<= number_of_strongest number_of_others)\n\
    \        (set! number_of_strongest number_of_others)\n        (set! number_of_others\
    \ number_of_strongest))\n    (if (<= number_of_others number_of_capitals)\n  \
    \      (set! number_of_strongest number_of_others)\n        (set! number_of_others\
    \ number_of_capitals))\n    (printf \"%s.%s\" class_name (substring (extensions\
    \ (* number_of_strongest number_of_others) number_of_others)))\n    (if (< (*\
    \ number_of_strongest number_of_others) number_of_capitals)\n        (substring\
    \ (extensions (* number_of_strongest number_of_others) number_of_capitals)\n \
    \                 (* number_of_strongest number_of_others))\n        (substring\
    \ (extensions (* number_of_strongest number_of_others) number_of_others)))\n \
    \   (if (< (* number_of_strongest number_of_others) number_of_other_letters)\n\
    \        (substring (extensions (* number_of_strongest number_of_others) number_of_other_letters)\n\
    \                  (* number_of_strongest number_of_others))\n        (substring\
    \ (extensions (* number_of_strongest number_of_others) number_of_other_letters)))\n\
    \    (if (< (* number_of_strongest number_of_others) number_of_capitals)\n   \
    \     (substring (extensions (* number_of_strongest number_of_capitals) number_of_capitals)\n\
    \                  (* number_of_strongest number_of_capitals))\n        (substring\
    \ (extensions (* number_of_strongest number_of_capitals) number_of_capitals)))\n\
    \    (if (< (* number_of_strongest number_of_capitals) number_of_other_letters)\n\
    \        (substring (extensions (* number_of_strongest number_of_other_letters)\
    \ number_of_other_letters)\n                  (* number_of_strongest number_of_other_letters))\n\
    \        (substring (extensions (* number_of_strongest number_of_other_letters)\
    \ number_of_other_letters)))\n    (printf \".%s\" (substring (extensions (* number_of_strongest\
    \ number_of_capitals) number_of_other_letters)))\n    (if (< (* number_of_stron",
  "  (let ((C (count (first extensions))))\n    (cond\n      [(= C 0) '']\n      [(=\
    \ C 1) (first extensions)]\n      [(even? (mod C 2))\n       (let* ((M (length\
    \ (first extensions)))\n               (S (- (count (first extensions)) M)))\n\
    \         (cond\n           [(= S 0) '']\n           [(= S 1) (first extensions)]\n\
    \           [(even? (mod S 2))\n            (let* ((M (length (first extensions)))\n\
    \                   (S (- (count (first extensions)) M)))\n              (cond\n\
    \                 [(= S 0) '']\n                 [(= S 1) (first extensions)]\n\
    \                 [(even? (mod S 2))\n                  (let* ((M (length (first\
    \ extensions)))\n                         (S (- (count (first extensions)) M)))\n\
    \                    (cond\n                      [(= S 0) '']\n             \
    \         [(= S 1) (first extensions)]\n                      [(even? (mod S 2))\n\
    \                       (let* ((M (length (first extensions)))\n             \
    \                  (S (- (count (first extensions)) M)))\n                   \
    \      (cond\n                           [(= S 0) '']\n                      \
    \     [(= S 1) (first extensions)]\n                           [(even? (mod S\
    \ 2))\n                            (let* ((M (length (first extensions)))\n  \
    \                                   (S (- (count (first extensions)) M)))\n  \
    \                            (cond\n                                [(= S 0) '']\n\
    \                                [(= S 1) (first extensions)]\n              \
    \                  [(even? (mod S 2))\n                                 (let*\
    \ ((M (length (first extensions)))\n                                         (S\
    \ (- (count (first extensions)) M)))\n                              (cond\n  \
    \                              [(= S 0) '']\n                                [(=\
    \ S 1) (first extensions)]\n                                [(even? (mod S 2))\n\
    \                                 (let* ((M (length (first extensions)))\n   \
    \                                      (S (- (count (first extensions)) M)))\n\
    \                              (cond\n                                [(= S 0)\
    \ '']\n                                [(= S 1) (first extensions)]\n        \
    \                        [(even? (mod S 2))\n                                \
    \ (let* ((M (length (first extensions)))\n                                   \
    \      (S (- (count (first extensions)) M)))\n                              (cond\n\
    \                                [(= S 0) '']\n                              \
    \  [(= S 1) (first extensions)]\n                                [(even? (mod\
    \ S 2))\n                                 (let* ((M (length (first extensions)))\n\
    \                                         (S (- (count ", "  (if (null? extensions)\
    \ \n      (list class_name)\n      (let ((extension (assoc class_name (sort extensions))))\n\
    \        (if extension\n            (append class_name (list (second extension)\
    \ \".\" (first extension))) \n            (error \"No extensions found\")))))\n",
  "  (if (null? extensions)\n      class_name\n      (if (< (length (string-prefix\
    \ (string-trim class_name \"[]\")) (string-length (string-trim (first extensions)\
    \ \"[]\"))) (length (string-prefix (string-trim (first extensions) \"[]\"))))\n\
    \          (let ((strength (- (length (string-prefix (string-trim class_name \"\
    []\")) (string-length (string-trim (first extensions) \"[]\"))) \n           \
    \              (length (string-prefix (string-trim (first extensions) \"[]\")))))\n\
    \            (cond\n              ((= strength 0 (car extensions))\n         \
    \      (cons class_name (cdr extensions)))\n              ((> strength 0 (car\
    \ extensions))\n               (Strongest_Extension (cons (car extensions) class_name)\
    \ (cdr extensions)))\n              ((< strength 0 (car extensions))\n       \
    \        (Strongest_Extension (cons (car extensions) (cons (car extensions) class_name))\n\
    \                                 (cdr extensions))))\n              ((= strength\
    \ 1(car extensions))\n               (cons (cdr extensions) class_name))\n   \
    \           ((> strength 1(car extensions))\n               (Strongest_Extension\
    \ (cons (car extensions) (cons (car extensions) (cdr extensions)))\n         \
    \                        (cdr extensions))\n              ((< strength 1(car extensions))\n\
    \               (Strongest_Extension (cons (car extensions) (cons (car extensions)\
    \ (cons (car extensions) class_name))))\n                                 (cdr\
    \ extensions))))))))\n", "  (define (extension_strength extension)\n    (let*\
    \ ((extension_name extension)\n           (extension_name_uppercase (str_upper\
    \ (first extension)))\n           (extension_name_lowercase(str_lower (first extension)))\n\
    \           (extension_name_length_of_name (length (str_lower (first extension))))\n\
    \           (extension_name_length_of_extension (length (str_lower (first extension))))\n\
    \           (extension_length (- (str_upper (first extension)) (str_lower (first\
    \ extension))))\n           (extension_strength (/ extension_length extension_name_length_of_extension)))\n\
    \      (cond\n        ((= extension_strength 0)\n         (str_upper (first extension)))\n\
    \        (else\n         (cond\n           ((< extension_strength 1)\n       \
    \     (str_lower (first extension)))\n           ((= extension_strength 2)\n \
    \           (str_upper (first extension)))\n           ((= extension_strength\
    \ 3)\n            (str_upper (first extension))))))\n    (if (> extension_strength\
    \ 0 (length extensions))\n        (error 'extension_strength\n               (list\
    \ '(extension_strength (length extensions)))))))\n", "  (define CAP (string-length\
    \ class_name))\n  (define SM (string-length extensions))\n  (define CAP_SM CAP\
    \ - SM)\n  (define (strongest)\n    (define (ext ext ext-index)\n      (if (<\
    \ CAP-SM CAP ext-index)\n          (cond \n            ( (>= CAP ext-index 0)\n\
    \              (cons ext (+ ext-index (* CAP CAP-SM)))\n            )\n      \
    \      (true\n              (cons ext ext-index))\n          ))\n      true)\n\
    \    (define (ext-sort exts ext-index)\n      (cond \n        ( (null? exts) \n\
    \          (cons 0 (- CAP-SM CAP ext-index)))\n        ( (> CAP-SM CAP ext-index)\n\
    \          (ext-sort (rest exts) (+ ext-index (* CAP-SM CAP)))\n        )\n  \
    \      (else (ext-sort (first exts) (+ ext-index (* CAP-SM CAP))))\n      )\n\
    \      (ext-sort extensions 0))\n    (define (strongest-ext ext-index)\n     \
    \ (cond \n        ( (> (- CAP-SM CAP ext-index) 0)\n          (cons ext-index\
    \ (+ CAP-SM CAP ext-index))\n        )\n        (else \n          (cons ext-index\
    \ (+ CAP-SM CAP (* CAP-SM CAP))))\n      )\n      (ext-sort (strongest exts 0)\
    \ ext-index))\n    (cond\n      (\n        (null? (strongest-ext 0))\n       \
    \ (cons (substring class_name 0 CAP) (strongest-ext 1))\n      )\n      (else\n\
    \        (cons (substring class_name 0 CAP) (strongest-ext (strongest exts 0)))\n\
    \      )\n    )\n  )\n  (cond\n    (\n      (null? (strongest))\n      (cons class_name\
    \ (strongest))\n    )\n    (else\n      (cons (substring class_name 0 CAP) (strongest))\n\
    \    )\n  )\n)\n", "  (let loop ([class_name class_name]\n             [extensions\
    \ extensions]\n             [strongest_extension null])\n    (cond [(empty? extensions)\
    \ strongest_extension]\n          [(equal? (caar extensions) (caar class_name))\
    \ (loop (cdr extensions)\n                                                   \
    \           (cdr extensions)\n                                               \
    \               (cons (car extensions) strongest_extension))]\n          [else\n\
    \          (loop (cdr class_name) \n                (cdr extensions)\n       \
    \         (cons (car extensions) strongest_extension)\n                (cons (car\
    \ class_name) strongest_extension))])))\n", "  (define (strongest-ext-name (extensions\
    \ strength))\n    (sort extensions #<\n          (lambda (ext strength)\n    \
    \        (< (string-car ext) (string-car strength))\n            (+ (string-car\
    \ ext) (string-car strength)))\n          >))\n  (let ((best-ext (first strongest-ext-name\
    \ (extensions -1)))\n        (other-exts (rest strongest-ext-name (extensions\
    \ 0))))\n    (cond\n      [(empty? extensions) (string class_name)]\n      [(string=?\
    \ best-ext class_name)\n       (string class_name \".\" best-ext)]\n      [else\
    \ (string class_name \".\" best-ext \".\" \n                 (append (Strongest_Extension\
    \ best-ext other-exts) \".\" \n                          (string-car other-exts))))]))\n",
  "  (cond\n    [(null? (rest extensions)) '()]\n    [else (cons (caar extensions)\n\
    \               (Strongest_Extension (caar extensions)\n                     \
    \            cdr extensions)))]))\n", "  (cond\n    [(empty? extensions) (error\
    \ 'Strongest_Extension \"\" extensions)] \n    [else\n     (let ([strongest (assoc\
    \ 0 (sort extensions \n                                  (lambda (ext) \n    \
    \                                (cond [(string=? (string-length ext) 0) \"ZZ\"\
    ]\n                                          [(string=? (string-length ext) 1)\
    \ \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 2) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 3) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 4) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 5) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 6) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 7) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 8) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 9) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 10) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 11) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 12) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 13) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 14) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 15) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 16) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 17) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 18) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 19) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 20) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 21) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 22) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 23) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 24) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 25) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 26) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 27) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 28) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 29) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 30) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 31) \"ZZ\"]\n                                          [(string=? (string-length\
    \ ext) 32) \"ZZ\"]\n", "  (define (compare-extension extension strength)\n   \
    \ (let ([letters (string->list extension)]\n          [smrty (sub1 (length (string->list\
    \ extension)))])\n      (cond\n        ((= strength 0)\n         (cons extension\
    \ \"\"))\n        ((= strength 1)\n         (cons extension \"\"))\n        ((=\
    \ (- SM (length (string->list extension))) (length letters))\n         (cons extension\
    \ (sub1 letters)))\n        (else\n         (cond\n           ((< (- SM (length\
    \ (string->list extension))) (length letters))\n            (cons extension (sub1\
    \ (letters smrty)))\n            (else\n             (cons extension \"\"))))))\n\
    \  (define (compare-strength extension-name)\n    (let ([extension-letters (string->list\
    \ extension-name)]\n          [extension-smrty (sub1 (length (string->list extension-name)))])\n\
    \      (cond\n        ((= extension-name \"\")\n         (cons extension-name\
    \ \"\"))\n        ((= extension-name \"\")\n         (cons extension-name \"\"\
    ))\n        ((= (- SM (length (string->list extension-name))) (length extension-letters))\n\
    \         (cons extension-name (sub1 extension-letters)))\n        (else\n   \
    \      (cond\n           ((< (- SM (length (string->list extension-name))) (length\
    \ extension-letters))\n            (cons extension-name (sub1 (extension-letters\
    \ extension-smrty)))\n            (else\n             (cons extension-name \"\"\
    ))))))\n  (define (extension extension-list extension-strength)\n    (cond (extension-list\n\
    \           (apply (lambda (e) (compare-extension e extension-strength))\n   \
    \                (sort extension-list #'> :key #'car))\n           (extension-list\
    \ \"\"))\n          ((extension-list \"\") (extension-list \"\"))\n          (extension-list\
    \ extension-strength))\n  (define (strength extension-name)\n    (cond (extension-name\n\
    \           (apply (lambda (e) (compare-strength e))\n                   (sort\
    \ extension-name #'> :key #'car))\n           (strength \"\"))\n          ((strength\
    \ \"\") (strength \"\"))\n          (strength extension-name)))\n  (define (strengths\
    \ extension-list)\n    (cond\n      ((null? extension-list) '())\n      (else\
    \ (append (extensions (car extension-list)) (strengths (cdr extension-list)))))\n\
    \  (define (strength strength-name)\n    (", "  (define (strongest-extension extension\
    \ strength)\n    (cond\n      [(empty? extensions) '']\n      [(equal? (first\
    \ (reverse extensions)) extension) (cons strength extensions)]\n      [else (cons\
    \ (reverse extensions) (strongest-extension extension (- strength 1)))]))\n  (let\
    \ ([strength (count (filter string->boolean (map (string->lower-case class_name))\
    \ extensions))]\n        [extension (filter string->boolean (map (string->lower-case\
    \ class_name) extensions))]\n        [extension (sort extensions (lambda (x y)\
    \ (compare (string->upper-case x) (string->upper-case y))) '<)])\n    (cond\n\
    \      [(equal? strength 0) (cons class_name strongest-extension 0)]\n      [else\
    \ (cons class_name (strongest-extension extension strength))]))) ; yapf: disable\n",
  "  (let ([num (length extensions)])\n    (let ([strength (/ (length class_name)\
    \ (length extensions))])\n      (cond (< (+ strength (* (char-code (char-code\
    \ 'A') \n                                        (char-code extensions)) \n  \
    \                            (char-code (char-code 'a'))) \n                 \
    \ 0) \n            (let ([index (* strength (- char-code (char-code 'A') \n  \
    \                                        (char-code extensions))\n           \
    \             (+ strength (* (char-code (char-code 'a') \n                   \
    \                     (char-code extensions)) \n                             \
    \      (char-code (char-code 'A')))\n                        (* num (- strength\
    \ (+ strength (* (char-code \n                                            (char-code\
    \ 'A') \n                                        (char-code extensions)) \n  \
    \                                      (char-code (char-code 'a'))) \n       \
    \                          (char-code (char-code 'A') \n                     \
    \                   (char-code extensions)) \n                               \
    \  (char-code (char-code 'a') \n                                        (char-code\
    \ extensions)))))\n                      extension (if (<= index 0)\n        \
    \                            extension\n                                    (substring\
    \ extensions (- index 1)))])\n            (cond [(< strength 0) extension]\n \
    \                 [(char-code extension) extension]\n                  [else (substring\
    \ extensions index)])))\n    ))\n  ", "  (cond\n    [(empty? extensions) (printf\
    \ \"~s\" class_name)]\n    [(equal? (first extensions) (string->symbol (first\
    \ extensions))) (printf \"~s.~s\" class_name (first extensions))]\n    [else (if\
    \ (equal? (first extensions) (string->symbol (first extensions))) (printf \"~s.~s\"\
    \ class_name (first extensions)) \n            (if (> (first extensions) (first\
    \ extensions)) (printf \"~s.~s\" class_name (first extensions))))]))\n", "  (cond\
    \ [(or (not (list? extensions)) (null? extensions)) #f]\n        [(= 0 (string-length\
    \ extensions)) #f]\n        [else (let ((CAP (string-length class_name)) (SM (string-length\
    \ extensions)))\n               (cond [(= CAP SM) class_name]\n              \
    \       [(> (- (string->number class_name) SM) CAP) #f]\n                    \
    \ [(< (- CAP (string->number class_name)) SM) #f]))]\n        (else #f)))\n",
  "  (cond\n    ((null? extensions) class_name)\n    ((and (substring (first extensions)\
    \ 0 1) (substring (first extensions) 1 1))\n     (string-append class_name \"\
    .\" (first extensions))) \n    ((and (substring (first extensions) 0 1) (substring\
    \ (first extensions) 1 0))\n     (string-append class_name \".\" (first extensions)))\
    \ \n    ((and (substring (first extensions) 0 1) (substring (first extensions)\
    \ 1 1))\n     (string-append class_name \".\" (first extensions))) \n    ((and\
    \ (substring (first extensions) 0 1) (substring (first extensions) 1 0))\n   \
    \  (string-append class_name \".\" (first extensions)))\n    ((and (substring\
    \ (first extensions) 0 1) (substring (first extensions) 1 1))\n     (string-append\
    \ class_name \".\" (first extensions)))\n    ((and (substring (first extensions)\
    \ 0 1) (substring (first extensions) 1 0))\n     (string-append class_name \"\
    .\" (first extensions)))\n    ((and (substring (first extensions) 0 1) (substring\
    \ (first extensions) 1 1))\n     (string-append class_name \".\" (first extensions)))\n\
    \    ((and (substring (first extensions) 0 1) (substring (first extensions) 1\
    \ 0))\n     (string-append class_name \".\" (first extensions)))\n    ((and (substring\
    \ (first extensions) 0 1) (substring (first extensions) 1 1))\n     (string-append\
    \ class_name \".\" (first extensions)))\n    ((and (substring (first extensions)\
    \ 0 1) (substring (first extensions) 1 0))\n     (string-append class_name \"\
    .\" (first extensions)))\n    ((and (substring (first extensions) 0 1) (substring\
    \ (first extensions) 1 1))\n     (string-append class_name \".\" (first extensions)))\n\
    \    ((and (substring (first extensions) 0 1) (substring (first extensions) 1\
    \ 0))\n     (string-append class_name \".\" (first extensions)))\n    ((and (substring\
    \ (first extensions) 0 1) (substring (first extensions) 1 1))\n     (string-append\
    \ class_name \".\" (first extensions)))\n    ((and (substring (first extensions)\
    \ 0 1) (substring (first extensions) 1 0))\n     (string-append class_name \"\
    .\" (first extensions)))\n    ((and (substring (first extensions) 0 1) (substring\
    \ (first extensions) 1 1))\n     (string-append class_name \".\" (first extensions)))\n\
    \    ((and (substring (first extensions) 0 1) (substring (first extensions) 1\
    \ 0))\n     (string-append class_name \".\" (first extensions)))\n    ((and (substring\
    \ (first extensions) 0 1) (substring (first extensions) 1 1))\n     (string-append\
    \ class_name \".\" (first extensions)))\n    ((and (substring (first ", "  (let\
    \ ((strongest (max 0 0)))\n    (for ext in extensions\n      (set! strongest (min\
    \ (strongest 0) (/ (count (list-ref ext 0)) (count ext))))))\n  (concat class_name\
    \ (strconcat \".\" (list-ref extensions strongest)))))\n</code>\n<|/ q tags=racket,scheme\
    \ dscore=0 |>\n<| c |>\nPlease don't use `set!` unless you _really_ know what\
    \ it does. It's really rarely needed in Scheme.\n<|/ c |>\n<| c |>\nThank you,\
    \ that solved it. I'm new to scheme, I'm sorry for not being able to wrap my head\
    \ around it.\n<|/ c |>\n<| a dscore=0 |>\nThe reason why your solution fails to\
    \ work is that you are trying to access unbound variable strongest from within\
    \ your loop. \nThis is not allowed in Scheme: it won't allow you to access unbound\
    \ variables within loops.\nThere are two ways you can solve this problem:\n\n\
    Declare strongest outside of the loop, and assign to it inside of the loop.\n\
    Pass strongest as an additional parameter to Strongest_Extension.\n\nThe second\
    \ solution is cleaner, though harder to understand. Here is the second solution:\n\
    <code>", "  (define (compare-extension x1 x2)\n    (if (<= (length x1) (length\
    \ x2)) (substring x1 0 (length x1))\n        (substring x1 0 (length x2))\n  \
    \    0))\n  (define (get-extension-name x)\n    (match (length (substring x 0\
    \ 1))\n      0\n      ([A] (substring x 0 1))\n      ([B] (substring x 0 (- (length\
    \ x) 1)))\n      ([C] (substring x (- (length x) 1)))\n      ([D] (substring x\
    \ 0 (- (length x) 1)))))\n  (define (strength-of-extension extension)\n    (let\
    \ ((cap (char->integer (first extension))\n          (sm (char->integer (second\
    \ extension))\n          (strength (- (/ (+ cap sm) 2) (length extension))))\n\
    \          (extension (rest extensions))))\n      (cond\n        ((= cap (length\
    \ extension)) strength)\n        ((= sm (length extension)) strength)\n      \
    \  ((< strength (* cap (length extension)))\n         (let ((best-extension (assoc\
    \ extension (extensions extensions))))\n           (if (and (list? best-extension)\
    \ (= (length best-extension) 1))\n               (list extension)\n          \
    \     (list extension)))\n         (else (list extension)))\n        ((= (length\
    \ extension) (sub (length extension) (length extension))))\n        (else\n  \
    \       (let ((best-extension (assoc extension (extensions extensions))))\n  \
    \         (cond\n             ((list? best-extension) (min (length best-extension)\
    \ 1))\n             (else (list extension)))\n           (strength-of-extension\
    \ (first best-extension))))))\n  (let ((extensions (sort extensions (lambda (x)\
    \ (compare-extension x class_name)))))\n    (if (< extensions (length extensions))\n\
    \      (let ((extension (first extensions)))\n        (cond\n          ((string=?\
    \ (get-extension-name extension) class_name)\n           (if (null extension)\n\
    \               (list class_name)\n               (list class_name extension)))\n\
    \          ((list=? extension (map (lambda (x) (string=? (get-extension-name x)\
    \ class_name))\n                                 extensions))\n           (cons\
    \ (reverse (sort extension (lambda (x) (compare-extension x class_name))))\n \
    \                extensions))\n          (else (list class_name extension)))\n\
    \      (list class_name extensions))))\n", "  (define (strength name)\n    (cond\n\
    \      [(empty? name) 0]\n      [(substring (substring name 0 1) (length name))\
    \ (substring (substring name 1 length) (length name))]\n      [(substring (substring\
    \ name 0 2) (length name)) (substring (substring name 1 length) (length name))]\n\
    \      [(substring (substring name 0 3) (length name)) (substring (substring name\
    \ 1 length) (length name))]\n      [(substring (substring name 0 4) (length name))\
    \ (substring (substring name 1 length) (length name))]\n      [(substring (substring\
    \ name 0 5) (length name)) (substring (substring name 1 length) (length name))]\n\
    \      [(substring (substring name 0 6) (length name)) (substring (substring name\
    \ 1 length) (length name))]\n      [(substring (substring name 0 7) (length name))\
    \ (substring (substring name 1 length) (length name))]\n      [(substring (substring\
    \ name 0 8) (length name)) (substring (substring name 1 length) (length name))]\n\
    \      [(substring (substring name 0 9) (length name)) (substring (substring name\
    \ 1 length) (length name))]\n      [(substring (substring name 0 10) (length name))\
    \ (substring (substring name 1 length) (length name))]\n      [else (substring\
    \ (substring name 0 11) (length name))]))\n  (define (max_extension extension\
    \ strength classes)\n    (cond\n      [(empty? classes) extension]\n      [(member(strength\
    \ extension) (map strength classes)) extension]\n      [(max_extension (max_extension\
    \ (max_extension extension strength (rest classes)) strength classes)) extension]\n\
    \      [else (max_extension (max_extension (max_extension extension strength (rest\
    \ classes)) (max (strength extension) (strength (first extension)))) strength\
    \ classes)]))\n  (define (sort extensions)\n    (sort extensions strength))\n\
    \  (max_extension (sort extensions) (strength class_name) extensions))\n", " \
    \ (define (count_upper_case string) \n    (define (count_uppercase substr str)\n\
    \      (define (count_upper substr)\n        (if (empty? substr) 1\n         \
    \ (if (char? substr) 1 \n            (+ (count_uppercase (substr substr (- 1 substr)))\
    \ (count_upper (substring substr 1 substr)))\n            (count_upper (substring\
    \ substr 1 substr))))\n      (count_upper (substring str 0 substr)))\n    (count_uppercase\
    \ string 0))\n  (define (count_lowercase string) \n    (define (count_lowercase\
    \ substr str)\n      (define (count_lower substr)\n        (if (empty? substr)\
    \ 1\n          (if (char? substr) 1 \n            (+ (count_lowercase (substr\
    \ substr (- 1 substr))) (count_lower (substring substr 1 substr)))\n         \
    \   (count_lower (substring substr 1 substr))))\n      (count_lower (substring\
    \ str 0 substr)))\n    (count_lowercase string 0))\n  (define (count_char char)\
    \ \n    (define (count_char substr)\n      (define (count_char substr)\n     \
    \   (if (empty? substr) 1\n          (if (char? substr) 1 \n            (count_char\
    \ (substring substr 1 substr))\n            (count_char (substring substr 1 substr))))\n\
    \      (count_char substr)))\n  (define (count_char string) \n    (count_char\
    \ (substring string 0 1)))\n  (define (count_char str) \n    (count_char (substring\
    \ str 0 1)))\n  (define (count_char string) \n    (count_char (substring string\
    \ 0 1)))\n  (define (count_char string) \n    (count_char (substring string 0\
    \ 1)))\n  (define (count_char str) \n    (count_char (substring str 0 1)))\n \
    \ (define (count_char string) \n    (count_char (substring string 0 1)))\n  (define\
    \ (count_char str) \n    (count_char (substring str 0 1)))\n  (define (count_char\
    \ string) \n    (count_char (substring string 0 1)))\n  (define (count_char str)\
    \ \n    (count_char (substring str 0 1)))\n  (define (count_char str) \n    (count_char\
    \ (substring str 0 1)))\n  (define (count_char str) \n    (count_char (substring\
    \ str 0 1)))\n  (define (count_char str) \n    (count_char (substring str 0 1)))\n\
    \  (define (count_char str) \n    (count_char (substring str 0 1)))\n  (define\
    \ (count_char str) ", "  (if (null? extensions)\n      'Error\n      (let ((max_strength\
    \ (car extensions))\n            (extension (cdr extensions))\n            (idx\
    \ (car extensions))\n            (ext (cdr extensions)))\n        (cond\n    \
    \      ((= (length class_name) (length extension)) (list class_name))\n      \
    \    ((= max_strength 0) (list class_name))\n          ((>= max_strength (- SM\
    \ (length class_name)) (/ CAP (length class_name)))\n          (begin\n      \
    \       (cond \n               ((empty? (cdr extensions)) (list class_name))\n\
    \               ((empty? (cdr extensions)) (list class_name))\n              \
    \ ((empty? (cdr extensions)) (list class_name))\n               ((empty? (cdr\
    \ extensions)) (list class_name))\n               ((empty? (cdr extensions)) (list\
    \ class_name))\n               ((empty? (cdr extensions)) (list class_name))\n\
    \               ((empty? (cdr extensions)) (list class_name))\n              \
    \ ((empty? (cdr extensions)) (list class_name))\n               ((empty? (cdr\
    \ extensions)) (list class_name))\n               ((empty? (cdr extensions)) (list\
    \ class_name))\n               ((empty? (cdr extensions)) (list class_name))\n\
    \               ((empty? (cdr extensions)) (list class_name))\n              \
    \ ((empty? (cdr extensions)) (list class_name))\n               ((empty? (cdr\
    \ extensions)) (list class_name))\n               ((empty? (cdr extensions)) (list\
    \ class_name))\n               ((empty? (cdr extensions)) (list class_name))\n\
    \               ((empty? (cdr extensions)) (list class_name))\n              \
    \ ((empty? (cdr extensions)) (list class_name))\n               ((empty? (cdr\
    \ extensions)) (list class_name))\n               ((empty? (cdr extensions)) (list\
    \ class_name))\n               ((empty? (cdr extensions)) (list class_name))\n\
    \               ((empty? (cdr extensions)) (list class_name))\n              \
    \ ((empty? (cdr extensions)) (list class_name))\n               ((empty? (cdr\
    \ extensions)) (list class_name))\n               ((empty? (cdr extensions)) (list\
    \ class_name))\n               ((empty? (cdr extensions)) (list class_name))\n\
    \               ((empty? (cdr extensions)) (list class_name))\n              \
    \ ((empty? (cdr extensions)) (list class_name))\n               ((empty? (cdr\
    \ extensions)) (list class_name))\n               ((", "  (cond\n    [(empty?\
    \ extensions) (list class_name)]\n    [(member (first extensions) '(a e i o u\
    \ y) extensions)\n     (cons class_name extensions)]\n    [(member (first extensions)\
    \ '(A E I O U Y)) \n     (cons class_name extensions)] \n    [else \n     (let\
    \ ([CAP (length (first extensions))\n           SM (length (substring (first extensions)\
    \ CAP (+ CAP (length extensions))))]\n           (/ (CAP - SM) (length (first\
    \ extensions)))) \n       (append class_name (list '. '. \n                  \
    \       (first extensions) \n                         (substring extensions (+\
    \ CAP (length extensions)) \n                                       SM (+ CAP\
    \ (length extensions))))\n              extensions)]))\n", "  (let ([CAP (count\
    \ (substring (upper-case class_name) 0 -1))\n        SM  (count (substring (lower-case\
    \ class_name) 0 -1))\n        SM0 (/ (SM + CAP) 2)])\n    (cond\n      [(< SM0\
    \ 0) (list class_name)]\n      [else (append (list class_name) \n            \
    \        (Strongest_Extension (substring class_name 1 SM) extensions))])))", " \
    \ (cond\n    [(empty? extensions)\n      class_name]\n    [(member? (first extensions)\
    \ (map car (filter string->symbol (string->list class_name)))) \n      (append\
    \ class_name (rest (filter string->symbol (string->list class_name)))) \n    ]\n\
    \    [else\n      (let ([extension (Strongest_Extension (first extensions) (rest\
    \ extensions))])\n        (if (>= (length (second (first extension))) \n     \
    \            (length (second extension)))\n            (append class_name extension)\n\
    \            (append extension class_name))\n        )\n    ]\n  )\n)\n", "  (define\
    \ SM (length class_name))\n  (define CAP (length #\\A))\n  (define strength (/\
    \ (- (length extensions) SM) CAP))\n  (define sorted (sort extensions \n     \
    \                (lambda (a b) (< (length a) (length b)))\n                  \
    \   (lambda (a b) (- (length a) (length b))))) \n  (define best_strongest (first\
    \ sorted))\n  (format \"~a~a.~a\" class_name best_strongest))\n", "  ;; Write\
    \ your code here\n)\n", "  (if (or (null? extensions) (empty? extensions))\n \
    \     \"\"\n      (let ((strength (map '- (length (string-ref class_name 0)) \n\
    \                           #(/ (string-ref (first extensions) %)\n          \
    \                     (length (string-ref class_name 0)))))\n            (extension\
    \ (min (sort strength reverse <)\n                            (length extensions))))\n\
    \        (string-append class_name \".\" (string-append (first extensions) \"\
    .\")) \n        (Strongest_Extension (rest extensions) extension))))\n", "  (let\
    \ ((extension-list-length 0))\n    (for extension in extensions\n      (if (equal?\
    \ extension (substring (string extension) 0 1))\n          (set! extension-list-length\
    \ (add1 extension-list-length))\n          (set! extension-list-length 0))\n \
    \     (if (> extension-list-length 0)\n          (set! extension-list-length 0)\n\
    \          (cond\n            [(equal? extension (substring (string extension)\
    \ 0 1)) (append class_name extension)]\n            [else extension])))\n    (if\
    \ (> extension-list-length 0)\n        (substring (string class_name) 0 extension-list-length)\
    \ (substring class_name 1 extension-list-length))))\n", "  (define (extension_strength\
    \ extension)\n    (define (letter_count s)\n      (if (char= (first s) 'A)\n \
    \         (+ 1 (letter_count (rest s)))\n          (+ 1 (letter_count (rest s)))))\n\
    \    (/ (letter_count extension) 2))\n  (let ((max_strength (first extensions))\n\
    \        (max_extension (first extensions))\n        (strength (extension_strength\
    \ max_extension)))\n    (if (> (strength max_strength) strength)\n        (let\
    \ ((strength (extension_strength max_extension)))\n          (cond ((> strength\
    \ strength) (list class_name max_extension strength max_strength))\n         \
    \       ((< strength strength) (list class_name max_extension strength max_strength))\n\
    \                (else\n                 (list class_name max_extension strength\
    \ max_strength)))))\n    (error \"There are no extensions with the same strength\"\
    )))\n</code>\nThis is where I got stuck. \n<code>", "  (cond\n    [(empty? extensions)\
    \ '']\n    [(member (first extensions) (map string \n                        \
    \         (map char-uppercase (first extensions))))\n      (str class_name \"\
    .\" (first extensions) \".\")]\n    [else (error \"Can't find strongest extension\"\
    \ \n               class_name extensions)]))\n", "  ;; Compute the extension strengths\
    \ by comparing the lengths of the extensions. \n  (define (compute_extension extension)\n\
    \    (if (string=? extension \"\")\n      \"\"\n      (let ((cap (length extension))\n\
    \            (sm  (length extension (string=? extension \"\"))))\n        (/ (-\
    \ cap sm) (- cap sm)))) \n  (define (compute_extensions extensions)\n    (map\
    \ compute_extension extensions))\n  ;; Compute the extension strengths and return\
    \ the strongest extension\n  (define (strongest_extension extensions)\n    (define\
    \ (max_extension extensions strength)\n      (if (null? extensions)\n        \
    \  \"\"\n          (if (= strength 0)\n              (if (string=? extensions\
    \ (cdr extensions))\n                  (car extensions)\n                  (max_extension\
    \ (cdr extensions) (- strength 1))))))\n    (max_extension extensions (- 0 (length\
    \ extensions))))\n  (define (sort_extensions extensions)\n    (define (compare-extensions\
    \ a b)\n      (if (= (compute_extension a) 0) \n          (if (= (compute_extension\
    \ b) 0)\n              (if (string=? a (substring class_name 0 (string-length\
    \ a)))\n                  (if (string=? b (substring class_name 0 (string-length\
    \ b)))\n                      0\n                      (if (string=? (substring\
    \ class_name 0 (string-length a)) (substring class_name 0 (string-length b)))\n\
    \                          1\n                          (if (string=? (substring\
    \ class_name 0 (string-length a)) (substring class_name 0 (string-length b)))\n\
    \                              1\n                              (if (string=?\
    \ (substring class_name 0 (string-length a)) (substring class_name 0 (string-length\
    \ b)))\n                                  0\n                                \
    \  (if (string=? (substring class_name 0 (string-length a)) (substring class_name\
    \ 0 (string-length b)))\n                                      (+ 1 (compare-extensions\
    \ (substring class_name 0 (string-length a)) (substring class_name 0 (string-length\
    \ b))) (- 0 (length extensions)))\n                                      (+ 1\
    \ (compare-extensions (substring class_name 0 (string-length a)) (substring class_name\
    \ 0 (string-length b))) (- 0 (length extensions)))\n                         \
    \             (+ 1 (compare-extensions (substring class_name 0 (string-length\
    \ a)) (substring class_name 0 (string-length b))) (- 0 (length extensions)))\n\
    \                                      (+ 1 (compare-extensions (substring class_name\
    \ 0 (string-length a)) (substring class_name 0 (string-length b))) (- 0 (length\
    \ extensions)))))))\n                  (if (string=? (", "  (cond\n    ((null?\
    \ extensions) 'my_class.my_class.')\n    ((equal? (first extensions) (first extensions))\
    \ (Strongest_Extension (second extensions))\n     (Strongest_Extension (rest extensions)))))\n",
  "  ;; Use a hash-table to store the extensions that have been \n  ;; encountered.\
    \ The key is the extension name and the value is the strength.\n  ;; Hash table\
    \ initialization has two arguments: initial capacity, and\n  ;; equality comparison\
    \ function; hash-table uses default equality comparison\n  ;; function that compares\
    \ two objects by their address which is not\n  ;; suitable for our case.\n  (define\
    \ (hash-table-initialize capacity)\n    (define (equality-fn x y)\n      (equal?\
    \ x y))\n    (make-hash-table :test-eq equality-fn :test-key string->symbol :test-value\
    \ boolean->boolean\n                     :initial-contents (vector '() capacity\
    \ '()))\n  )\n  (hash-table-initialize 256)\n  ;; Add the extensions to the hash\
    \ table and find the strongest\n  ;; extension.\n  (define (hash-table-add extension\
    \ strength)\n    (hash-table-update\n      (lambda (key)\n        (string->symbol\
    \ key)\n        strength)\n      (lambda (key old-strength)\n        (equal? (string->symbol\
    \ key) extension)\n        old-strength)))\n  (define (hash-table-update hash\
    \ key function)\n    (hash-table-get-or-add key hash function))\n  (define (hash-table-get-or-add\
    \ key hash function)\n    (if (hash-table-contains? hash key)\n        (hash-table-get-value\
    \ hash key)\n        (hash-table-add key (function key))))\n  ;; Add all extensions\
    \ to hashtable\n  (define (hash-table-add extensions)\n    (for extension (reverse\
    \ extensions)\n      (hash-table-add extension (- (string-length extension)\n\
    \                                   (string-length key))))\n  ;; Find the strongest\
    \ extension using the hash table\n  (define (hash-table-find extension)\n    (hash-table-get-or-add\
    \ extension (hash-table-initialize 256)\n                              string->symbol))\n\
    \  (define (hash-table-contains? hash key)\n    (hash-table-contains-key? hash\
    \ key (hash-table-get-key hash key))\n  )\n  ;; Remove extension from the hashtable\n\
    \  (define (hash-table-remove hash key)\n    (hash-table-update\n      (lambda\
    \ (key)\n        (string->symbol key)\n        false)\n      (lambda (key old-strength)\n\
    \        (equal? (string->symbol key) key)\n        old-strength)\n    )\n  )\n\
    \  ;; Remove all extensions from the hashtable\n  (define (hash-table-clear-all\
    \ hash", "  (let ((strongest-extension (first extensions)))\n    (cond ((null?\
    \ extensions)\n           strongest-extension)\n          ((string-equal class_name\
    \ (string-ref class_name 0))\n           (let ((index (substring (length (string-ref\
    \ class_name 0)) 1)))\n             (if (< index (length extensions))\n      \
    \           (let ((extension (subseq extensions index)))\n                   (if\
    \ (> (string-car extension) (string-car strongest-extension))\n              \
    \         (string-car extension)\n                       (string-car strongest-extension)))\n\
    \                 (error \"The extension class must begin with the class name\"\
    \n                         class_name)))\n          (else \n           (let ((extensions\
    \ (remove-if (lambda (x) (equal? (string-ref x 0) class_name)) extensions)))\n\
    \             (if (null? extensions)\n               strongest-extension\n   \
    \            (let ((strongest-extension (first extensions))\n                \
    \     (index (substring (length (string-ref class_name 0)) 1)))\n            \
    \     (if (< index (length extensions))\n                     (let ((extension\
    \ (subseq extensions index)))\n                       (if (> (string-car extension)\
    \ (string-car strongest-extension))\n                           (string-car extension)\n\
    \                           (string-car strongest-extension)))\n             \
    \      (error \"The extension class must begin with the class name\"\n       \
    \                  class_name)))\n           (error \"There are no extensions\
    \ with the same class\")))))\n", "  (define sm\n    (string-length \n     (string-map\
    \ \n      (lambda (s) (member s (string-map toUpperCase extensions))))\n     (string-map\
    \ toLowerCase extensions)))\n  (define cap\n    (string-length \n     (string-map\
    \ \n      (lambda (s) (member s (string-map toUpperCase extensions))))\n     class_name))\n\
    \  (/ (- cap sm)\n     (+ cap (- sm cap)))\n)\n", "  \n  (define (strength_of_extension\
    \ extension)\n    (string->int->float \n     (string-length extension) \n    \
    \ (string-length class_name))) \n\n  (define (sort extensions)\n    (sort extensions\
    \ \n     (lambda (e1) \n       (strength_of_extension e1) \n       (lambda (e2)\
    \ \n        (strength_of_extension e2)) \n      -1)))\n\n  (sort extensions))\n",
  "  (if (null? extensions)\n      class_name\n      (let ((cap (length class_name))\n\
    \            (sm (length extensions)))\n        (if (zero? cap)\n            class_name\
    \ \n            (let ((score (- (minus (ash (car extensions) sm) cap) sm)))\n\
    \              (cond\n                [(< score 0)\n                 ']' class_name\n\
    \                [(< score 1)\n                 '.' class_name\n             \
    \   [(>= score 0)\n                 (cons (cons (car extensions) class_name)\n\
    \                      '[' + class_name (str (- score 1))))])))))\n</code>\nI\
    \ didn't find any more problems that you might have, but I made a couple of assumptions:\n\
    \nThe extensions aren't case sensitive.\nYou shouldn't have any classes named\
    \ Slices\nThe extensions are case sensitive.\n<|/ a tags=scheme,racket |>\n<|\
    \ c |>\nthanks for your answer. i think this will definitely be helpful to my\
    \ current situation as I already have made a similar function called \"Strongest_Extension\"\
    \ which compares the extensions by their strength but I am struggling to figure\
    \ out how to go about making another function which would compare them and return\
    \ the class with the strongest extension.\n<|/ c |>\n<| c |>\nOkay that makes\
    \ it more difficult, I'll keep trying to think of something\n<|/ c |>\n<| c |>\n\
    : I added something to the answer that should help you out a bit. I couldn't find\
    \ a solution to the case sensitive issue though\n<|/ c |>\n<| a |>\nThis was my\
    \ first Stack Overflow answer, so bear with me if it's not quite what you're looking\
    \ for.\n<code>", "  (let ([strength (/ (count (filter (lambda (e) (equal? (first\
    \ e) class_name))\n                                extensions)\n             \
    \                #(length %)) 2)])\n    (if (> strength 0 (first extensions))\n\
    \        (list class_name (first extensions))\n        ;; The same strength extension\
    \ may be in multiple lists, so we\n        ;; take the one with the lower index\n\
    \        (let ([extension (sort extensions #[<])])\n          (list (first extension)\
    \ class_name)\n        )))))\n", "  (cond [(empty? extensions) '.' ]\n       \
    \ [(= (length extensions) 1)\n         (string->symbol (string->symbol class_name))]\n\
    \        [(or (char->upper-case? extensions[(length extensions)-1])\n        \
    \     (char->lower-case? extensions[(length extensions)-1]))\n         (if (>\
    \ \n              (/ (length extensions) 2)\n              (char->upper-case?\
    \ extensions[(length extensions)-2])\n              (char->lower-case? extensions[(length\
    \ extensions)-2]))\n              (set! extensions (rest extensions))\n      \
    \        (set! extensions (append (list extensions) (list '')))\n            \
    \  (set! extensions (subseq extensions 0 (length (rest extensions)+2)))\n    \
    \          (set! extensions (subseq extensions (length (rest extensions)+2)))\n\
    \              (set! extensions (subseq extensions 0 (length (rest extensions)+3)))\n\
    \              (set! extensions (subseq extensions (length (rest extensions)+3))))\n\
    \         (cond [(char->upper-case? extensions[(length extensions)-1])\n     \
    \           (char->lower-case? extensions[(length extensions)-1])]\n         \
    \      [(> (length extensions) 2)\n                (cond (eq (char->upper-case?\
    \ extensions[(length extensions)-1])\n                          (char->lower-case?\
    \ extensions[(length extensions)-2])) \n                       (cond (eq (char->upper-case?\
    \ extensions[(length extensions)-2])\n                                (char->lower-case?\
    \ extensions[(length extensions)-3])) \n                               (set! extensions\
    \ (subseq extensions 0 (length (rest extensions)+2)))\n                      \
    \         (set! extensions (subseq extensions (length (rest extensions)+2)))\n\
    \                               (set! extensions (subseq extensions 0 (length\
    \ (rest extensions)+3)))\n                               (set! extensions (subseq\
    \ extensions (length (rest extensions)+3))))\n                       (set! extensions\
    \ (subseq extensions 0 (length (rest extensions)+2)))\n                      \
    \ (set! extensions (subseq extensions (length (rest extensions)+2)))\n       \
    \                (set! extensions (subseq extensions 0 (length (rest extensions)+3)))\n\
    \                       (set! extensions (subseq extensions (length (rest extensions)+3)))\n\
    \                       (cond (eq (char->upper-case? extensions[(length extensions)-1])\n\
    \                               (char->lower-case? extensions[(length extensions)-2]))",
  "  (cond\n    [(empty? extensions) (list class_name)]\n    [(equal? (first extensions)\
    \ class_name)\n      (append (Strongest_Extension (second extensions) extensions)\n\
    \              (list (first extensions))]\n    [(equal? (first extensions) (substring\
    \ (second extensions) 0 1))\n      (append (Strongest_Extension (second extensions)\
    \ extensions)\n              (list (substring (second extensions) 1 )))]\n   \
    \ [else (append (Strongest_Extension (first extensions) extensions)\n        \
    \          (list (first extensions)))]))\n", "  (let ((CAP (string-length class_name))\n\
    \        (SM (string-length extensions))\n        (strongest (make-string CAP\
    \ CAP))\n        (strongest-index (make-list 1 CAP CAP)))\n    (for ((i 0 (+ CAP\
    \ SM))) (set! strongest \n                                  (substring class_name\
    \ i CAP))\n      (for ((j 0 (+ SM (list-length extensions)))) (set! strongest-index\n\
    \                                                    (subseq strongest-index \n\
    \                                                        0 \n                \
    \                                        (+ j 1))))\n    (cond ((and (= CAP SM)\
    \ (list-length extensions) \n                   (= 0 (string-compare (substring\
    \ class_name 0 CAP) \n                                       (substring strongest\
    \ 0 CAP)))) (substring strongest 0))\n          ((= SM (list-length extensions))\
    \ (substring class_name CAP))\n          (else (substring strongest 0 (min CAP\
    \ SM)))))\n", "  (define C\n    (let ([len (string-length class_name)])\n    \
    \  (cond\n        ((equal? (string-length extensions) 0) \"\")\n        ((= len\
    \ 0)(list class_name))\n        ((= (- len 1) 0)(list \"S\"))\n        (else (cons\
    \ (string->symbol class_name)\n                  (cons (string-append \"S\" (string->symbol\
    \ \n                                         (string-substring extensions 0 (-\
    \ len 1)))\n                               \".\")\n                        (string->symbol\
    \ \n                         (string-substring extensions (- len 1)))))))))\n\
    \  (define SM (string-length class_name))\n  (define CAP (string-length class_name))\n\
    \  (define SM-LETTERS (quotient SM CAP))\n  (define CAP-LETTERS (quotient CAP\
    \ SM))\n  (define CAP-LETTER-COUNT (modulo CAP-LETTERS SM-LETTERS))\n  (define\
    \ SM-LETTER-COUNT (modulo SM CAP-LETTERS))\n  (cond\n    ((= SM-LETTER-COUNT 0)\
    \ (list class_name))\n    ((= CAP-LETTER-COUNT 0) (list (string-append class_name\
    \ \".\" \"\")))\n    ((> CAP-LETTER-COUNT 0) (list (string-append class_name \"\
    .\" \n                                       (string->symbol (string-append class_name\
    \ \n                                                                    (symbol->string\
    \ (first extensions))))))))\n  (let ([c (C)]\n        [sm (SM)]\n        [cap\
    \ (CAP)]\n        [sm-letters (SM-LETTERS)]\n        [cap-letters (CAP-LETTERS)]\n\
    \        [cap-letter-count (CAP-LETTER-COUNT)]\n        [sm-letter-count (SM-LETTER-COUNT)]\n\
    \        [extensions (extensions)])\n    (if (= cap-letter-count sm-letter-count)\n\
    \        (cond\n          ((<= cap-letter-count 0) (cons (symbol->string (c))\
    \ (list (symbol->string (c)))))\n          ((< sm-letter-count 0) (cons (symbol->string\
    \ (c)) (list \"\")))\n          (else (cons (symbol->string (c)) (list \"\")))))\n\
    \    (if (= sm-letter-count 0)\n        (cons (symbol->string (c)) (list (symbol->string\
    \ (c)))))\n    (if (>= sm-letter-count 0)\n        (cond\n          ((<= sm-letter-count\
    \ 0) (cons (symbol->string (c)) (list \"\")))\n          ((< cap-letter-count\
    \ 0) (cons (symbol->string (c)) (list \"\")))\n          (else ", "  (define (match_strength\
    \ ext extensions)\n    (cond\n      [(empty? extensions) 0]\n      [(equal? (first\
    \ extensions) ext) (+ 1 (match_strength ext (rest extensions)))]\n      [else\
    \ (+ 1 (match_strength (first extensions) (rest extensions)))]))\n  (if (empty?\
    \ extensions)\n      (list class_name)\n      (list class_name \n            (apply\
    \ str (map (lambda (e) (match_strength e extensions)) extensions))))) ; #lang\
    \ racket\n", "  ;; Write your code below (\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\
    \u2261\u2261\u2261\u2261\u2261\u2261\uFFFD", "  (define cap (length (string->list\
    \ (string-map \n                                     (lambda (c) (if (string=?\
    \ c \"A\") (- 26) (- 32)) c))\n                                  class_name)))\n\
    \  (define sm  (length (string->list (string-map \n                          \
    \          (lambda (c) (if (string=? c \"a\") (- 26) (- 32)) c))\n           \
    \                       class_name)))\n  (define (strength ext) (/ (- (string-length\
    \ ext) cap) (- sm ext)))\n  (define (index ext) (sort extensions #'<))\n  (if\
    \ (null? extensions) \n      (cons class_name '())\n      (let ((strength (strength\
    \ extensions))\n            (index   (index extensions)))\n        (if (null?\
    \ index)\n            (cons class_name '())\n            (let ((ext (list-ref\
    \ index 0))\n                   (newext (list-ref index 1)))\n              (cons\
    \ (string-append ext (if (< (strength ext) strength) \n                      \
    \                   '.' \n                                         '_')) \n  \
    \                  (Strongest_Extension newext extensions))))))))\n", "  ;; Implement\
    \ here\n)\n", "  (cond\n    [(null? extensions) \"\"]\n    [(list? (first extensions))\
    \ \n     (let ([extension (first extensions)])\n       (cond\n         [(string=?\
    \ extension class_name) \n          (Strongest_Extension class_name (remove extensions\
    \ extension))]\n         [(string=? (first extension) class_name) \n         \
    \ (Strongest_Extension class_name (remove (first extensions) extension))]\n  \
    \       [else \n          (Strongest_Extension class_name (remove (first extensions)\
    \ extension))]))]\n    [else \n     (cond\n       [(string=? (first extensions)\
    \ class_name) \n        (Strongest_Extension class_name (remove extensions extensions))]\n\
    \       [else (Strongest_Extension class_name (remove extensions extensions))]\n\
    \       )]))\n</code>\n<|/ a dscore=0 |>\n<| a |>\nMy solution uses two functions:\n\
    \nmake-class-definition\nmake-class-instance\n\nI use a hash map to store the\
    \ instance data.\nmake-class-definition creates a definition from the user input\
    \ (name-string and extension-list). The definition includes the name of the class\
    \ and the class extensions (strings). The extensions are sorted in alphabetical\
    \ order.\n<code>", "  (match extensions \n    ((null? extensions) (error 'Strongest_Extension\
    \ \"List is empty\"))\n    ((null? (cdr extensions))\n     (error 'Strongest_Extension\
    \ \"Extensions are empty\"))\n    ((string-length extensions)\n     (error 'Strongest_Extension\
    \ \"Extensions name has too many characters\"))\n    ((= (string-length class_name)\
    \ (string-length extensions))\n     (error 'Strongest_Extension \"Class name is\
    \ too long\"))\n    ((string-match #rx[a-z] (cadr extensions))\n     (error 'Strongest_Extension\
    \ \"Extension name cannot have lowercase letters\"))\n    ((string-match #rx[A-Z]\
    \ (cadr extensions))\n     (error 'Strongest_Extension \"Extension name cannot\
    \ have uppercase letters\"))\n    ((string-match #rx[0-9] (cadr extensions))\n\
    \     (error 'Strongest_Extension \"Extension name cannot have numbers\"))\n \
    \   ((= (string-length class_name) (string-length extensions))\n     (error 'Strongest_Extension\
    \ \"Class name is too long\"))\n    ((< (- (string-length class_name) (string-length\
    \ extensions))\n       (string-length extensions))\n     (error 'Strongest_Extension\
    \ \"Class name must be less than extensions\"))\n    ((< (- (string-length class_name)\
    \ (string-length extensions))\n       (string-length class_name))\n     (error\
    \ 'Strongest_Extension \"Class name must be less than extensions\"))\n    ((<\
    \ (- (string-length class_name) (string-length extensions))\n       (string-length\
    \ class_name))\n     (error 'Strongest_Extension \"Class name must be less than\
    \ extensions\"))\n    ((< (- (string-length class_name) (string-length extensions))\n\
    \       (string-length class_name))\n     (error 'Strongest_Extension \"Class\
    \ name must be less than extensions\"))\n    ((> (- (string-length class_name)\
    \ (string-length extensions))\n       (string-length class_name))\n     (error\
    \ 'Strongest_Extension \"Class name must be greater than extensions\"))\n    ((>\
    \ (- (string-length class_name) (string-length extensions))\n       (string-length\
    \ class_name))\n     (error 'Strongest_Extension \"Class name must be greater\
    \ than extensions\"))\n    ((> (- (string-length class_name) (string-length extensions))\n\
    \       (string-length class_name))\n     (error 'Strongest_Extension \"Class\
    \ name must be greater than extensions\"))\n    ((< (- (string-length class_name)\
    \ (string-length extensions))\n       (string-length class_name))\n     (error\
    \ 'Strongest_Extension \"Class name must be less than extensions\"))\n    ((<\
    \ (- (string-length class_name) (string-length extensions))\n       (string-length\
    \ class_name))\n     (error 'Strongest_Extension \"Class name must be less than\
    \ extensions", "  (cond\n    [(null? extensions) '()]\n    [(> (Math#max (Math#count\
    \ (car extensions))\n                   (Math#count (Math#count (cdr extensions))))\n\
    \       (Math#count (Math#count (car extensions))))\n      (let ([sm (Math#count\
    \ (Math#count (cdr extensions)))]\n            ([cap (Math#count (Math#count (car\
    \ extensions)))])\n            [strength (Math#/ (Math#- sm cap) cap)])\n    \
    \    (list class_name (car extensions) (Math#- strength sm))))]\n    [(> (Math#max\
    \ (Math#count (car extensions))\n                  (Math#count (Math#count (cdr\
    \ extensions))))\n       (Math#count (Math#count (car extensions))))\n      (let\
    \ ([sm (Math#count (Math#count (cdr extensions)))]\n            ([cap (Math#count\
    \ (Math#count (car extensions)))])\n            [strength (Math#/ (Math#- sm cap)\
    \ cap)])\n        (list class_name (car extensions) (Math#- strength sm)))]\n\
    \    [else\n      (list class_name (car extensions) (Math#count (car extensions)))]))\n",
  "  (cond\n    [(empty? extensions) \"\"]\n    [(member ((first extensions) (caar\
    \ (string->list (string->symbol (first extensions))))) (string->list (string->symbol\
    \ class_name)))\n     (string-append class_name \".\" ((first extensions) (caar\
    \ (string->list (string->symbol (first extensions))))))]\n    [else (Strongest_Extension\
    \ (first extensions) (rest extensions))]))\n", "  (cond\n    ((empty? extensions)\
    \ '())\n    ((> (count (apply map #(char-uppercase? %) extensions)\n         \
    \          (count (apply map #(char-lowercase? %) extensions))) 0)\n     (first\
    \ extensions))\n    (else (first extensions))))\n", "  (define (strength ext)\n\
    \    (string-length (substring (ext 0) (+ 4 (string-length ext)))) / 4)\n  (let\
    \ ((strongest (first extensions))\n        (strongest-str (strength strongest)))\n\
    \    (cond\n      [(null? extensions) (list class_name)]\n      [else (cons ((append\
    \ class_name strongest) strongest-str)\n                   (Strongest_Extension\
    \ class_name (subseq extensions 1)))])))\n  ", "  (define (strong_extension extension)\n\
    \    (if (<= 0 (string-length extension)\n            (string-length extension))\n\
    \        extension\n        (let ((len (string-length extension)))\n         \
    \ (let ((len1 (string-length extension)))\n            (if (>= len len1)\n   \
    \             extension\n                (strong_extension (substring extension\
    \ 0 (+ len len1))))))))\n  (strong_extension (first extensions))\n  (lambda (extension)\
    \ (string-append class_name \".\" (strong_extension extension))))\n", "  (if (null?\
    \ extensions)\n      '#error\n      (let ((extension (assoc (sort extensions)\
    \ #:key \n                                 (lambda (x) \n                    \
    \               (/ (apply str (map string x)) \n                             \
    \        string-length x)))) \n        (if (eq? (car extensions) '-) \n      \
    \      (if (> (string-length extension) (string-length class_name))\n        \
    \        class_name \n                (concat class_name extension))\n       \
    \     (if (> (string-length extension) (string-length class_name))\n         \
    \       '#error\n                (concat class_name extension))))))\n", "  (cond\n\
    \    [(empty? extensions)\n     (string-append class_name \".\" class_name)]\n\
    \    [else\n     (string-append (substring class_name 0 (string-length class_name-1))\n\
    \                     (first-extension-name extensions)\n                    \
    \ (substring (second extensions) 0 (string-length extensions)-1))]))\n", "  (if\
    \ (null? extensions)\n      '()\n      (let ([extension (first extensions)])\n\
    \        (cond\n          [(< extension (length (string-match #regex \"[A-Z]\"\
    \ extension))) (string-append class_name '.' extension)]\n          [(< extension\
    \ (length (string-match #regex \"[a-z]\" extension))) (string-append class_name\
    \ '-' extension)]\n          [else extension]\n          ])))\n", "  (define (compare\
    \ x y)\n    (cond\n      [(string=? x y)  0]\n      [(string=? y x)  1]\n    \
    \  [else          (compare (string=? (string-ref x 0) (string-ref y 0)) 0)]))\n\
    \  (let ((class-name (string-downcase (substring-at class_name 0 1))))\n    (define\
    \ (find-extension x extensions)\n      (cond\n        [(null? extensions) x]\n\
    \        [else\n         (let ((extension-name (string-downcase (substring-at\
    \ x 0 1))))\n           (if (string=? extension-name class-name)\n           \
    \    (find-extension extension (cdr extensions))\n               (cond\n     \
    \            [(> extension-name class-name) (cons extension-name extensions)]\n\
    \                 [else\n                   (cons (car extensions) extension-name)]))]))\n\
    \    (find-extension extensions (reverse-list extensions))))\n", "  (cond\n  \
    \  [(empty? extensions) \"\"]\n    [(null? (string-length class_name)) \"\"]\n\
    \    [else\n     (cond\n       [(member (first extensions) (map car (split-string\
    \ class_name #\\)))\n        (string-append class_name (rest extensions))]\n \
    \      [else\n        (let* ([cap (count (substring (first extensions) 0 1))\n\
    \              sm  (count (substring (first extensions) 1 1)))\n           (cond\n\
    \             [(< (+ cap sm) (- cap (length extensions)))\n              (cond\n\
    \                [(string-length extensions)\n                 (let* ([exs (sort\
    \ extensions reverse)])\n                   (cond\n                     [(empty?\
    \ exs) \"\"]\n                     [(null? (string-length exs)) \"\"]\n      \
    \               [else (cons (first exs) (Strongest_Extension (rest exs) extensions))])])]\n\
    \               [else\n                (let* ([exs (sort extensions reverse)])\n\
    \                   (cond\n                     [(empty? exs) \"\"]\n        \
    \             [(null? (string-length exs)) \"\"]\n                     [else (cons\
    \ (first exs) (Strongest_Extension (rest exs) extensions))])])])]\n          \
    \ [else \"\"]))]))]))\n</code>\nTests:\n<code>", "  (cond\n    ((null? extensions)\
    \ '())\n    ((equal? (car extensions) class_name)\n     (cons (car extensions)\
    \ (Strongest_Extension class_name (cdr extensions))))\n    (else (Strongest_Extension\
    \ class_name (cdr extensions)))))\n", "  (cond\n    [(empty? extensions) \"\"\
    ]\n    [(not (member (first extensions) (sort extensions)))\n     (string-append\
    \ class_name \".\" (reverse (sort extensions)))]\n    [(member (first extensions)\
    \ (sort extensions))\n     (string-append class_name \".\" (reverse (sort extensions)))]\n\
    \    [else (error \"Error: extensions' length is greater than 1\" extensions)]))\n",
  "  (define (Strongest_Extension_helper name extensions strength)\n    (let ((ext\
    \ (first extensions)))\n      (if (equal? name (name (substring ext 0 (string-length\
    \ ext))))\n          (let ((strength_exts (filter \n                         \
    \   (lambda (ext)\n                              (equal? (string (first ext))\
    \ (name (substring ext 0 (string-length ext))))\n                            \
    \  extensions)))\n            (if (null? strength_exts) (cons name (extensions\
    \ strength)))\n            (if (> (first strength_exts) strength)\n          \
    \      (Strongest_Extension_helper name (first strength_exts) (first strength)))\n\
    \            (Strongest_Extension_helper name (first strength_exts) strength)))))\n\
    \    (Strongest_Extension_helper class_name extensions -1)))\n", "  (cond\n  \
    \  [(empty? extensions) '']\n    [(equal? 0 (count (car extensions))) (car (extensions))]\n\
    \    [else (cond\n             [(= (count (car extensions)) (count (reverse extensions)))\n\
    \               (Strongest_Extension (cdr (reverse extensions))\n            \
    \                   extensions)]\n             [else (append (Strongest_Extension\
    \ (cdr (reverse extensions))\n                                          extensions)\n\
    \                           (list (capitalize class_name) (car (reverse extensions))))]))))\n",
  "  (cond\n    ((= (length extensions) 0) (printf \"~a\" class_name))\n    ((eqv\
    \ (string-length class_name) (string-length extensions)) \n     (printf \"~a\"\
    \ (string-append class_name \".\" (string-join extensions \".\"))))\n    ((= (string-length\
    \ class_name) (string-length extensions))\n     (let ((ext (get-extension-name\
    \ extensions)))\n       (cond\n         ((> (+ ext (str-lower-case (substring\
    \ (sub-string  class_name 0 1) 0) (str-lower-case (substring (sub-string  class_name\
    \ 0 1) (+ string-length (substring (sub-string  class_name 0 1) (+ 1 ext)) + string-length\
    \ (substring (sub-string  class_name 0 1) (+ 1 ext)) + 1))))) 0)\n         ((=\
    \ ext (str-lower-case (substring (sub-string  class_name 0 1) (+ 1 ext))))\n \
    \        (printf \"~a\" (string-append class_name \".\" (string-append ext \"\
    .\")))\n         (else \n           (cond\n             ((> (+ ext (str-lower-case\
    \ (substring (sub-string  class_name 0 1) (+ 1 ext)))))) \n             ((= ext\
    \ (str-lower-case (substring (sub-string  class_name 0 1) (+ 1 ext)))))\n    \
    \         ((= ext (str-lower-case (substring (sub-string  class_name 0 1) (+ 1\
    \ ext)))))\n             ((= ext (str-lower-case (substring (sub-string  class_name\
    \ 0 1) (+ 1 ext)))))\n             ((= ext (str-lower-case (substring (sub-string\
    \  class_name 0 1) (+ 1 ext)))))\n             ((= ext (str-lower-case (substring\
    \ (sub-string  class_name 0 1) (+ 1 ext)))))\n             ((= ext (str-lower-case\
    \ (substring (sub-string  class_name 0 1) (+ 1 ext))))\n             ((= ext (str-lower-case\
    \ (substring (sub-string  class_name 0 1) (+ 1 ext)))))\n             ((= ext\
    \ (str-lower-case (substring (sub-string  class_name 0 1) (+ 1 ext)))))\n    \
    \         ((= ext (str-lower-case (substring (sub-string  class_name 0 1) (+ 1\
    \ ext))))\n             ((= ext (str-lower-case (substring (sub-string  class_name\
    \ 0 1) (+ 1 ext)))))\n             ((= ext (str-lower-case (substring (sub-string\
    \  class_name ", "  (let ((cap (count (string-upper-case class_name)))\n     \
    \   (sm  (count (string-lower-case class_name))))\n    (cond\n      [(> cap sm)\
    \ (find-extensions-with-same-strength extensions cap - sm)]\n      [else (find-extensions-with-same-strength\
    \ extensions cap)]))) ;; (define (find-extensions-with-same-strength extensions\
    \ cap sm)", "  (sort (filter (lambda (extension) (extension-name extension) extensions)\n\
    \               (map extension-name extensions))\n        (lambda (a b) (strength-name\
    \ a b))))", "  (cond\n    [(null? extensions) '']\n    [else\n     (string-append\
    \ (substring (class-name class_name) 0 (length (class-name class_name)))\n   \
    \                  (first extensions))]\n    [else\n     (list class_name extensions)]))\n",
  "  (let ((cap (length class_name))\n        (sm  (length extensions))\n        (cb\
    \ (make-vector cap sm))\n        (len (mem-length extensions)))\n    (mem-set\
    \ cb 0 (* cap sm) (* len (length extensions)))\n    (let ((len (mem-length extensions))\n\
    \          (sm  0\n              cap 0\n              cur (mem-ref cb cap sm)\n\
    \              prev (mem-ref cb 0 cap)\n              ext (mem-ref extensions\
    \ 0))\n          (cur-ext (mem-ref extensions 0))\n          (ext-cnt 0))\n  \
    \    (mem-set prev 0 (* cap sm) (* len (length extensions)))\n      (mem-set cur-ext\
    \ 0 (* cap sm) (* len (length extensions)))\n      (mem-set ext-cnt 0 0 (* len\
    \ (length extensions)))\n      (while ((> len 0)) \n        (let ((cur-ext (mem-ref\
    \ extensions 0))\n              (ext-cnt 0))\n          (mem-set cur (mem-ref\
    \ cb cap sm) (* cap sm))\n          (mem-set prev (mem-ref cb 0 cap) (* cap sm))\n\
    \          (mem-set cur-ext (mem-ref extensions 0) (* cap sm))\n          (mem-set\
    \ ext-cnt 0 0 (* cap sm))\n          (mem-set cap 0 0)\n          (mem-set sm\
    \ 0 0)\n          (mem-set len 0)\n          (mem-set cb 0 (* cap sm) (* len (length\
    \ extensions))))\n      (set! len (- len 1))\n      (cond ((< ext-cnt 1)\n   \
    \         (mem-set (mem-ref extensions 0) (+ cur-ext cur) (* len ext-cnt))\n \
    \           (set! cur-ext (mem-ref extensions 0))\n            (set! ext-cnt 0))\n\
    \            (else\n            (mem-set (mem-ref extensions 0) (+ cur-ext cur)\
    \ (* len ext-cnt))\n            (set! cur-ext 0))\n      (else (mem-set (mem-ref\
    \ extensions 0) (+ cur-ext cur) (* len ext-cnt))))\n    (set! len (- len 1))\n\
    \    (cond ((< ext-cnt 1)\n            (mem-set (mem-ref extensions 0) (+ cur-ext\
    \ cur) (* len ext", "  (let ([cap (string-length class_name)])\n    (let ([sm\
    \ (string-length \"\")]\n          [strongest (substring class_name 0 (cap - sm)))]\n\
    \          [extension-count 0])\n      (for ([i extensions])\n        (let ([extension-name\
    \ (string-ref extensions i)])\n          (cond\n            (string-empty? extension-name)\n\
    \            (set! extension-name \"\")\n            (set! extension-count (+\
    \ extension-count 1))\n            (set! strongest (substring class_name 0 (cap\
    \ - sm)))\n            (set! cap (+ cap (string-length extension-name))))\n  \
    \        (if (> extension-count 1)\n            (set! extension-name (substring\
    \ extension-name 0 (string-length extension-name)))\n            (set! extension-name\
    \ \"\"))))\n      (cond\n        (>= extension-count 1)\n        (set! extensions\
    \ (substring extensions 0 extension-count))\n        (set! extension-count 0))\n\
    \      (set! extensions \"\"))))\n", "  (let ([sorted_extensions (sort extensions\
    \ (lambda (e) (< (length e) (length class_name))))])\n    (cond\n      [(empty?\
    \ sorted_extensions)\n       (string-append class_name \"-\"])\n      [(> (length\
    \ sorted_extensions) 1)\n       (string-append class_name \".\" (car sorted_extensions)])\n\
    \      [(= 0 (length sorted_extensions))\n       (string-append class_name \"\
    .\" class_name)]\n      [else\n       (let\n          [extension_name (String->String\
    \ (car sorted_extensions))]\n          [extension_class (String->String class_name)]\n\
    \          [extension_strength (- extension_name (length extension_name))]\n \
    \         [extension_strongest (first sorted_extensions)]\n          [extension_strength-strongest\
    \ (- (length (string-append extension_class extension_name)) (length (string-append\
    \ extension_class extension_strongest)))])\n         (cond\n           [(< extension_strength\
    \ extension_strength-strongest)\n            (string-append (String->String extension_class)\
    \ \".\" extension_name)\n            (string-append (String->String extension_class)\
    \ \".\" extension_strongest)]\n           [else \n            (string-append (String->String\
    \ extension_class) \".\" extension_strongest)]]))]))\n", "  ;; Complete this function\n\
    \  (define strongest-extensions (sort extensions <))\n  (define strongest-extension-name\
    \ (first strongest-extensions))\n  (define strongest-extension-strength (StrongestExtensionStrength\
    \ extension-name))\n  (cond [(equal? strongest-extension-strength -1) (substring\
    \ class_name 0 (length (length class_name) - 1))]\n        [else (substring class_name\
    \ 0 (length (strongest-extension-strength class_name)))]))\n", "  (define (strength\
    \ x)\n    (match x\n      [(char-uppercase y) (sub (string->list (string->char\
    \ y)) 1)] \n      [(char-lowercase y) (sub (string->list (string->char y)) 1)]))\n\
    \  (let ([candidates (map strength extensions)])\n    (if (null? candidates)\n\
    \        (list class_name)\n        (sort candidates (<) (string->list (string->char\
    \ class_name))))\n    (append (list class_name) (strongest candidates (length\
    \ extensions)))))\n", "  (cond ((= 0 (string-length class_name))\n         (string-append\
    \ class_name (reverse extensions)))\n        (else \n         (string-append (substring\
    \ (class_name 0 (string-length class_name)) 1 -1)\n                         (Strongest_Extension\
    \ (substring (class_name 1 \n                                                \
    \           (string-length class_name))\n                                    \
    \               extensions)))))\n      ", "  (let ((classes (hash-map class_name\
    \ '()))\n        (strength (hash-map class_name 0))\n        (current (hash-map\
    \ class_name '')))\n    (do ((i 0 (+ i 1)))\n        ((>= i extensions)\n    \
    \     (hash-map class_name ''))\n      (let ((extension (assoc-in extensions i)))\n\
    \        (cond\n          ((null? extension)\n           (hash-map class_name\
    \ ''))\n          ((null? (assoc-in classes extension))\n           (hash-map\
    \ class_name '()))\n          ((< (hash-map class_name extension) (hash-map class_name\
    \ current))\n           (hash-map class_name '()))\n          (else (cond ((member\
    \ (assoc-in classes extension) (hash-map class_name current))\n              \
    \           (hash-map class_name '()))\n                       (else (hash-map\
    \ class_name \n                                   `(~(subseq class_name 0 (length\
    \ extension)) \n                                     (cons extension current))))))))))\n",
  "  (cond [(empty? extensions) class_name]\n        [(equal? (first extensions) class_name)\
    \ \n         (first extensions)]\n        [else (Strongest_Extension (cdr extensions)\
    \ extensions)]))\n", "  ;; Write your code here.\n  (define SM (string-length\
    \ class_name))\n  (define CAP (string-length extensions))\n  (define SM_CAP (/\
    \ SM (- CAP)))\n  (define SM_CAP (/ SM_CAP (/ CAP SM_CAP)))\n  (define SM_CAP\
    \ (- SM_CAP))\n  (define CAP (- SM_CAP))\n  (define CAP (- CAP))\n  (cond\n  \
    \  ((equal? SM_CAP 0) (substring (substring class_name 0 SM_CAP) 1))\n    ((equal?\
    \ (- CAP) (- SM)) (substring (substring class_name 0 SM_CAP) 1))\n    (else (substring\
    \ (substring class_name 0 SM_CAP) 0 (+ (* CAP (- SM_CAP)) 1)))\n  )\n)\n", " \
    \ (define num_upper_case (count (filter is_upper extensions)))\n  (define num_lower_case\
    \ (count (filter is_lower extensions)))\n  (define strength\n    (/ (- num_upper_case\
    \ num_lower_case) \n       (- num_lower_case num_upper_case)))\n  (if (> strength\
    \ (car extensions))\n    (Strongest_Extension class_name (cdr extensions))\n \
    \   (cons (car extensions) (Strongest_Extension class_name extensions))))\n",
  "  ;; TODO\n  \n  )\n", "  (cond\n    ((empty? extensions) 'error)\n    ((equal?\
    \ (first extensions) (first extensions)) (first extensions))\n    ((equal? (first\
    \ extensions) (first (reverse extensions))) (first (reverse extensions)))\n  \
    \  (else (Strongest_Extension (second extensions) (rest extensions)))))\n", " \
    \ (cond\n    [(empty? extensions) class_name]\n    [\n      (equal? (first extensions)\
    \ (first class_name)) (append class_name (rest extensions))\n      (equal? (first\
    \ extensions) (first class_name)) (Strongest_Extension class_name (rest extensions))\n\
    \      (equal? (first extensions) (first class_name)) (Strongest_Extension class_name\
    \ (rest extensions))\n      (equal? (first extensions) (first class_name)) (Strongest_Extension\
    \ class_name (rest extensions))\n      (equal? (first extensions) (first class_name))\
    \ (Strongest_Extension class_name (rest extensions))\n      (equal? (first extensions)\
    \ (first class_name)) (Strongest_Extension class_name (rest extensions))\n   \
    \   (equal? (first extensions) (first class_name)) (Strongest_Extension class_name\
    \ (rest extensions))\n      (equal? (first extensions) (first class_name)) (Strongest_Extension\
    \ class_name (rest extensions))\n      (equal? (first extensions) (first class_name))\
    \ (Strongest_Extension class_name (rest extensions))\n      (equal? (first extensions)\
    \ (first class_name)) (Strongest_Extension class_name (rest extensions))\n   \
    \   (equal? (first extensions) (first class_name)) (Strongest_Extension class_name\
    \ (rest extensions))\n      (equal? (first extensions) (first class_name)) (Strongest_Extension\
    \ class_name (rest extensions))\n      (equal? (first extensions) (first class_name))\
    \ (Strongest_Extension class_name (rest extensions))\n      (equal? (first extensions)\
    \ (first class_name)) (Strongest_Extension class_name (rest extensions))\n   \
    \   (equal? (first extensions) (first class_name)) (Strongest_Extension class_name\
    \ (rest extensions))\n      (equal? (first extensions) (first class_name)) (Strongest_Extension\
    \ class_name (rest extensions))\n      (equal? (first extensions) (first class_name))\
    \ (Strongest_Extension class_name (rest extensions))\n      (equal? (first extensions)\
    \ (first class_name)) (Strongest_Extension class_name (rest extensions))\n   \
    \   (equal? (first extensions) (first class_name)) (Strongest_Extension class_name\
    \ (rest extensions))\n      (equal? (first extensions) (first class_name)) (Strongest_Extension\
    \ class_name (rest extensions))\n      (equal? (first extensions) (first class_name))\
    \ (Strongest_Extension class_name (rest extensions))\n      (equal? (first extensions)\
    \ (first class_name)) (Strongest_Extension class_name (re", "  (let ((strongest_extension\
    \ (List)))\n    (List-for-each (lambda (extension) (if (<= (length (string-length\
    \ extension)) (length (string-length class_name))) (set! strongest_extension (cons\
    \ extension (car strongest_extension))) (null! strongest_extension))\n       \
    \           extensions)\n    (sort strongest_extension (lambda (x) (- car (length\
    \ x))))))\n", "  (cond\n    ((null? extensions) \n     (error 'Strongest_Extension\
    \ \"The extensions are not given.\"))\n    ((null? (car extensions)) \n     (error\
    \ 'Strongest_Extension \"The extensions are not given.\"))\n    ((=\n      (length\
    \ (string->list \n          (make-string-of\n           (string-match\n      \
    \      (string-match \n              (get-string-match \n                (string-match\
    \ class_name \"[A-Z]\") \n                \"[a-z]\")) \n              \"[A-Z]\"\
    )) \n        (length (string->list \n          (make-string-of\n           (string-match\n\
    \            (string-match \n              (get-string-match \n              \
    \  (string-match class_name \"[A-Z]\") \n                \"[a-z]\")) \n      \
    \        \"[a-z]\")) \n         (car (cdr extensions)))) \n      0)\n     (error\
    \ 'Strongest_Extension \"The extensions are not given.\"))\n    ((not (member\
    \ (car extensions) \n                  (string->list (make-string-of (get-string-match\
    \ (string-match class_name \"[A-Z]\") \"[a-z]\"))))\n     (error 'Strongest_Extension\
    \ \"The extensions are not given.\"))\n    ((< (- (length (string->list (make-string-of\
    \ (get-string-match (string-match class_name \"[A-Z]\") \"[a-z]\"))) \n      \
    \      (length (string->list (make-string-of (get-string-match (string-match class_name\
    \ \"[A-Z]\") \"[a-z]\"))))) \n       (car (cdr extensions))))\n    ((> (- (length\
    \ (string->list (make-string-of (get-string-match (string-match class_name \"\
    [A-Z]\") \"[a-z]\"))) \n            (length (string->list (make-string-of (get-string-match\
    \ (string-match class_name \"[A-Z]\") \"[a-z]\"))))) \n       (car (cdr extensions))))\n\
    \    ((> (- (length (string->list (make-string-of (get-string-match (string-match\
    \ class_name \"[A-Z]\") \"[a-z]\"))) \n            (length (string->list (make-string-of\
    \ (get-string-match (string-match class_name \"[A-Z]\") \"[a-z]\"))))) \n    \
    \   (car (cdr extensions))))\n    ((> (- (length (string->list (make-string-of\
    \ (get-string-match (string-match class_name \"[A-Z]\") \"[a-z]\"))) \n      \
    \      (length (string->list (make-string-of (get-string-match (string-match class_name\
    \ \"[A-Z]\") \"[a-z]\"))))) \n       (car (cdr extensions))))\n    ((> (- (length\
    \ (string->list (make-string-of (get-string-match (string-", "  (cond\n    [(empty?\
    \ extensions) (error \"No extensions given\")]\n    [(equal? (first extensions)\
    \ '-) (error \"Extension name cannot start with a hyphen\")]\n    [(equal? (first\
    \ extensions) '.) (error \"Extension name cannot start with a period\")]\n   \
    \ [else \n     (cond\n       [(> (count (filter #(or (char-upper? (first %)) (char-lower?\
    \ (first %))) #extensions)) 0)\n        (error \"No extensions start with lowercase\
    \ letters\")]\n       [(> (count (filter #(char-upper? (first %)) #extensions))\
    \ 0)\n        (error \"No extensions start with uppercase letters\")]\n      \
    \ [(> (count (filter #(char-lower? (first %)) #extensions)) 0)\n        (error\
    \ \"No extensions start with lowercase letters\")]\n       [(> (count (filter\
    \ #(char-upper? (first %)) #extensions)) 0)\n        (error \"No extensions start\
    \ with uppercase letters\")]\n       [(equal? (max extensions)\n             \
    \  (substring class_name (length (second extensions)) -1))]\n       [(equal? (min\
    \ extensions)\n               (substring class_name (length (first extensions))\
    \ -1))]\n       [(equal? (max extensions)\n               (substring class_name\
    \ (length (second extensions)) -1))]\n       [(equal? (min extensions)\n     \
    \          (substring class_name (length (first extensions)) -1))]\n       [(equal?\
    \ (max extensions)\n               (substring class_name (length (second extensions))\
    \ -1))]\n       [(equal? (min extensions)\n               (substring class_name\
    \ (length (first extensions)) -1))]\n       [else (error \"No extensions has the\
    \ maximum strength\")]\n       [(equal? (min extensions)\n               (substring\
    \ class_name (length (first extensions)) -1))]\n       [else (error \"No extensions\
    \ has the minimum strength\")]\n       [else (error \"Multiple extensions have\
    \ the same strength.\")]))]))\n", "  (define (Strength name)\n    (if (char->integer\
    \ name) < 0)\n      (- (char->integer name))\n      (if (char->integer name) 0)\n\
    \        (char->integer name)\n        'error))\n  (define (Strength_name name)\n\
    \    (if (char->integer name) < 0)\n      (- (char->integer name))\n      (if\
    \ (char->integer name) 0)\n        (char->string name))\n    (if (null? name)\n\
    \      (error 'error \"No extension name.\")\n      (let ((strength (Strength\
    \ name)))\n        (if (> (Strength name) 0)\n          (if (eqv? (Strength name)\
    \ 0)\n            'error\n            (cond ((< strength 1) name)\n          \
    \        ((< strength 2) (concat (car extensions) \".\" name))\n             \
    \     ((< strength 3) (concat (car extensions) \".\" (Strength_name (substring\
    \ name 2 1) \".\"))\n                   ((< strength 4) \n                   \
    \ (concat (car extensions) \".\" (Strength_name (substring name 2 1) \".\") \n\
    \                           (Strength_name (substring name 3 1) \".\"))\n    \
    \               ((< strength 5) \n                    (concat (car extensions)\
    \ \".\" (Strength_name (substring name 2 1) \".\") \n                        \
    \   (Strength_name (substring name 3 1) \".\") \n                           (Strength_name\
    \ (substring name 4 1) \".\"))\n                   ((< strength 6) \n        \
    \            (concat (car extensions) \".\" (Strength_name (substring name 2 1)\
    \ \".\") \n                           (Strength_name (substring name 3 1) \".\"\
    ) \n                           (Strength_name (substring name 4 1) \".\") \n \
    \                          (Strength_name (substring name 5 1) \".\"))\n     \
    \              ((< strength 7) \n                    (concat (car extensions)\
    \ \".\" (Strength_name (substring name 2 1) \".\") \n                        \
    \   (Strength_name (substring name 3 1) \".\") \n                           (Strength_name\
    \ (substring name 4 1) \".\") \n                           (Strength_name (substring\
    \ name 5 1) \".\") \n                           (Strength_name (substring name\
    \ 6 1) \".\"))\n                   ((< strength 8) \n                    (concat\
    \ (car extensions) \".\" (Strength_name (substring name 2 1) \".\") \n       \
    \                    (Strength_name (substring name 3 1) \".\") \n           \
    \                (Strength_name (substring name 4 1) \".\") \n               \
    \            (Strength_name (substring name 5 1) ", "  (match extensions (\n \
    \   [(Extension)\n     (Extension (Extension))]\n    [(Extension _)\n     (Extension\
    \ _)]\n    [(Extension _)\n     (Extension (Extension (Extension _)))]\n    [(_\
    \ _)\n     (Extension (Extension (Extension _)))]\n    [(_ _)\n     (Extension\
    \ (Extension (Extension (Extension _)))]\n    [(_ _)\n     (Extension (Extension\
    \ (Extension (Extension (Extension _))))]\n    [(_ _)\n     (Extension (Extension\
    \ (Extension (Extension (Extension (Extension _))))])\n    [(_ _)\n     (Extension\
    \ (Extension (Extension (Extension (Extension (Extension (Extension _))))]))]\n\
    \    [(_ _)\n     (Extension (Extension (Extension (Extension (Extension (Extension\
    \ (Extension (Extension _)))))]))]\n    [(_ _)\n     (Extension (Extension (Extension\
    \ (Extension (Extension (Extension (Extension (Extension (Extension (Extension\
    \ _))))))))])\n    [(_ _)\n     (Extension (Extension (Extension (Extension (Extension\
    \ (Extension (Extension (Extension (Extension (Extension (Extension _))))))))]))]\n\
    \    [(_ _)\n     (Extension (Extension (Extension (Extension (Extension (Extension\
    \ (Extension (Extension (Extension (Extension (Extension (Extension _))))))))]))]))\n\
    \  (define (StrongestExtensionName extension)\n    (match (Extension extension)\n\
    \      [(Extension (Extension (Extension _)))\n       (Extension _)]\n      [(Extension\
    \ (Extension _))\n       (Extension _)]\n      [(Extension (Extension _))\n  \
    \     (Extension (Extension (Extension _)))]\n      [(Extension (Extension _))\n\
    \       (Extension (Extension (Extension (Extension _)))]\n      [(Extension (Extension\
    \ _))\n       (Extension (Extension (Extension (Extension _)))]\n      [(Extension\
    \ (Extension _))\n       (Extension (Extension (Extension (Extension _)))]\n \
    \     [(Extension (Extension _))\n       (Extension (Extension (Extension (Extension\
    \ _)))]\n      [(Extension (Extension _))\n       (Extension (Extension (Extension\
    \ (Extension (Extension _))))]\n      [(Extension (Extension _))\n       (Extension\
    \ (Extension (Extension (Extension (Extension _))))])\n      [(Extension (Extension\
    \ _))\n       (Extension (Extension (Extension (Extension (Extension", "  (define\
    \ (strength extension)\n    (cond ((null? extension) (-1))\n          ((string=?\
    \ (string->char extension) 'A) (-1 (string->char extension)))\n          ((string=?\
    \ (string->char extension) 'B) (-1 (string->char extension)))\n          ((string=?\
    \ (string->char extension) 'C) (-1 (string->char extension)))\n          (else\
    \ (-1 (string->char extension)))))\n  (define (find extensions strength)\n   \
    \ (cond ((null? extensions) '())\n          ((<= strength (strength (first extensions)))\
    \ (string-append (string class_name)\n                                       \
    \                          (string (reverse (rest extensions)))))\n          (else\
    \ (string-append (string class_name)\n                                       \
    \     (string (reverse extensions)))))))\n  (define (filter extensions strength)\n\
    \    (filter extensions strength '()))\n  (define (max extensions strength)\n\
    \    (if (null? extensions)\n        '()\n        (let ([strengths (map strength\
    \ extensions)])\n          (define (compare s strength)\n            (if (< s\
    \ strength) \n                (list s strength)\n                (list strength\
    \ s)))\n          (map compare strengths strength)))\n  (define (min extensions\
    \ strength)\n    (if (null? extensions)\n        '()\n        (let ([strengths\
    \ (map strength extensions)])\n          (define (compare s strength)\n      \
    \      (if (< s strength) \n                (list s strength)\n              \
    \  (list strength s)))\n          (map compare strengths strength)))\n  (define\
    \ (sort extensions strength)\n    (sort extensions strength '()))\n  (define (count\
    \ extensions strength)\n    (if (null? extensions)\n        0\n        (+ 1 (count\
    \ extensions (rest extensions) strength))))\n  (define (choose extensions strength)\n\
    \    (if (null? extensions)\n        extensions\n        (let ([strengths (map\
    \ strength extensions)])\n          (define (compare s strength)\n           \
    \ (if (< s strength) \n                (list s strength)\n                (list\
    \ strength s)))\n          (define (find s strength)\n            (cond ((null?\
    \ s) '())\n                   ((<= strength (sort strengths (first s)) ) \n  \
    \                  (list s (first s))\n                    (find (rest s) strength)\n\
    \                    (choose (rest s) strength)))\n          (choose (find strengths\
    \ strength)\n                 (sort extensions (first s)))))\n  (define (extention\
    \ extensions strength)\n    (cond ((null? extension", "  (let ((CAP (length class_name))\n\
    \        (SM (length (substring class_name 0 CAP))) (strength -1))\n    (for X\
    \ (range CAP SM)\n      (let ((letter (substring class_name X X))\n          \
    \  (extension (substring extensions X X)))\n        (if (equal? letter letter)\n\
    \            (let ((strength (string->number (string->letter (first extension))))\n\
    \                  (next extension))\n              (if (< (- strength strength)\
    \ 0)\n                  (set! strength (- strength strength))\n              \
    \    (set! extension (first extension))\n                  (set! extensions (rest\
    \ extensions))))\n            (let ((strongest (string-append (substring class_name\
    \ X X) extension)))\n              (if (equal? (string-length strongest) CAP)\n\
    \                  (set! strength strength)\n                  (set! extension\
    \ (strongest)))))\n        (let ((next (substring extensions X (+ X SM))))\n \
    \         (if (equal? next next)\n              (set! extensions (rest extensions))\n\
    \              (set! extension (first extension))\n              (set! extensions\
    \ (rest extensions)))))))\n", "  (cond\n    [(empty? extensions) '']\n    [else\n\
    \      (let* ((extension (max-extension-strength extensions))\n             (strongest\
    \ (sort-extension-strength extension)))\n        (string-append class_name (string-append\
    \ \".\" strongest))]))])\n", "  (if (empty? extensions)\n      (cons (string-append\
    \ (string class_name) \".\") '())\n      (let ((extension-name (first extensions))\n\
    \            (extension-strength (string-distance (string class_name)\n      \
    \                           (substring (string extension-name)\n             \
    \                           0 (string-length extension-name))))\n            (extension-extensions\
    \ (rest extensions)))\n        (if (< extension-strength (- extension-name (count\
    \ extension-extensions))) \n            (cons extension-name (Strongest_Extension\
    \ class_name extension-extensions))\n            (Strongest_Extension class_name\
    \ extension-extensions)))))\n", "  (let ((class-name (caar class_name)))\n   \
    \ (let loop ((extensions extensions)\n             (strongest-extension null))\n\
    \      (if (null? extensions)\n          strongest-extension\n          (let ((ext\
    \ (first extensions))\n                (strength (substring (class-name length)\
    \ (cdr ext))))\n            (if (or (not (= strength -1))\n                  \
    \  (or (= strength (/ 1 extension-strength)))\n                    (loop (cdr\
    \ extensions)\n                          (cons (first extensions)\n          \
    \                      strongest-extension))))))))\n", "  (let ((strongest (car\
    \ extensions))\n        (cap (string-length strongest))\n        (sm (string-length\
    \ (car extensions))))\n    (if (= cap sm)\n        (list-ref extensions (sub1\
    \ cap))\n        (list-ref extensions 0))))\n", "  (cond\n    [(empty? extensions)\
    \ (error \"Not enough extensions\")]\n    [(member class_name (map car (sort extensions)))\
    \ (car extensions)]\n    [else (error \"Could not find strongest extension\")]))\n",
  "  (cond\n    [(empty? extensions) \"\"]\n    [(member (car-case class_name) '(A\
    \ B C)) (cdr extensions)]\n    [else (max (map #(if (eq? (car-case %) (car-case\
    \ class_name))\n                           (- %)\n                           %)\n\
    \                     extensions)) ]))\n", "  (cond\n    ((null? extensions) (list\
    \ class_name))\n    ((string=? (car extensions) (caar extensions)) (Strongest_Extension\
    \ (cadr extensions) extensions))\n    (else (Strongest_Extension (caddr extensions)\
    \ extensions))))\n", "  (define (ext ext exts)\n    (cond\n      [(empty? exts)\
    \ '']\n      [(equal? (ext (first exts)) class_name)\n       (cons (first exts)\
    \ (ext class_name (rest exts)))]\n      [else (ext (first exts) (cons (first exts)\
    \ (ext class_name (rest exts))))]\n      ))\n  (ext class_name extensions))\n\
    </code>\n<|/ q tags=racket,scheme |>\n<| c |>\nCan you show us a sample test case\
    \ in Racket? It would help to see how you call the function and what happens.\n\
    <|/ c |>\n<| c |>\nI added an example at the bottom of my original post.\n<|/\
    \ c |>\n<| c |>\nAnd what is the expected outcome of your test case?\n<|/ c |>\n\
    <| c |>\nIt should be 'my_class.AA', since 'AA' comes before 'Be' in 'my_class.Be'\n\
    <|/ c |>\n<| c |>\nYes, I see that now. `extension-sort` should sort lexicographically.\
    \ I've edited my answer. Sorry for the misunderstanding.\n<|/ c |>\n<| a |>\n\
    When you call extension-sort with an argument 'my_class' you are sorting lexicographically\
    \ according to your definition (sort is stable). But you are calling it with a\
    \ list, not an atom. So 'my_class' gets sorted according to your definition, which\
    \ sorts everything by the first letter.\nYour function extension-sort should sort\
    \ lexicographically according to your definition:\n<code>", "  (cond\n    [(empty?\
    \ extensions) (list class_name)]\n    [(=\n          (rest (first extensions))\
    \ \n          (length class_name))\n      (cons (first extensions)\n         \
    \   (list (append (Strongest_Extension \n                              (rest class_name)\n\
    \                              (rest extensions))\n                        (reverse\
    \ extensions)))]\n    [else (append (Strongest_Extension \n                  \
    \  (rest class_name)\n                    (append (first extensions) (rest extensions)))])))\
    \ \n  ", "  (let ([strongest-extension (List-Max (Extension-Strength extensions))]\n\
    \        [strongest-extension-name (Extension-Name strongest-extension)])\n  \
    \  (format #t \"~a. ~a~%\" class_name strongest-extension-name))) ;;#lang racket\n",
  "  (let loop ((strength-counts #(\n                       (list (list) (hash-ref\
    \ (hash class_name '()) '()))\n                       (list (list) (hash-ref (hash\
    \ class_name '()) '()))))\n            (extension (car extensions))\n        \
    \    (rest (cdr extensions)))\n    (cond\n      [(null? extensions) (error 'Strongest_Extension\
    \ `(~class_name ,@(map car (reverse strength-counts))))\n       (loop (hash-ref\
    \ (hash class_name '()) extension) (rest extensions))]\n      [(hash-ref (hash\
    \ class_name '()) extension) (loop (hash-ref (hash class_name '()) extension)\
    \ (rest extensions))]\n      [else (error 'Strongest_Extension '(~class_name ,@(map\
    \ car (reverse strength-counts))))]))\n", "  (define (strength ext)\n    (string-length\
    \ (string-replace ext #\\A #\\Z) 0))\n  (define (choose ext choices)\n    (if\
    \ (empty? choices)\n        (string-append class_name '.' ext)\n        (if (>\
    \ (strength ext) (strength (first choices)))\n            (choose (first choices)\
    \ (rest choices))\n            (choose (first choices) choices))))\n  (choose\
    \ (first extensions) extensions))\n", "  (let ([cap (length class_name)\n    \
    \    sm  (length class_name)]\n        (min-exts min-exts min-strongest))\n  \
    \  (for [extension extensions]\n      (when (> extension min-exts)\n        (set!\
    \ min-exts extension))\n      (when (> extension min-strongest)\n        (set!\
    \ min-strongest extension))\n      (when (< cap (substract extension min-exts))\n\
    \        (set! cap (substract extension min-exts))\n        (set! sm (substract\
    \ extension min-strongest)))\n      (format t \"~a ~a.~a\" class_name (substract\
    \ extension (substract min_exts min_strongest)))\n    (substract extension (substract\
    \ cap sm))))\n", "  (cond [(empty? extensions) (print \"No extensions\")]\n  \
    \      [(equal? (string-length extensions)\n                  (string-length class_name))\n\
    \         (print \"There is only one extension\")]\n        [(= (string-length\
    \ extensions)\n             (string-length class_name))\n         (print \"There\
    \ is only one extension\")]\n        [else\n         (define cap (count-upper-case\
    \ class_name))\n         (define sm (count-lower-case class_name))\n         (if\
    \ (< (- cap sm) 0)\n             (cond [(= sm 0) (print \"No extensions\")]\n\
    \                   [(= cap 0) (print \"No extensions\")]\n                  \
    \ [(< cap sm) (print \"No extensions\")]\n                   [else\n         \
    \           (define strength (- (count (set extensions))\n                   \
    \                     (count (set (sort extensions)))))\n                    (cond\
    \ [(< strength 0) (print \"No extensions\")]\n                          [(= strength\
    \ 0) (print \"No extensions\")]\n                          [(> strength 0) (let\
    \ ([extension\n                                                    (sort\n   \
    \                                                  (sort extensions)\n       \
    \                                              down)]\n                      \
    \                          (cond [(equal? extension\n                        \
    \                                  extension) extension]\n                   \
    \                                   [(< extension\n                          \
    \                                extension)\n                                \
    \                       (print \"No extensions\")]\n                         \
    \                             [else extension]))]\n                          [else\
    \ (print \"No extensions\")])])])]))\n", "  (let ([num_cap (length (string-upcase\
    \ (substring class_name 0 1)))]\n        [num_sm (length (string-upcase (substring\
    \ class_name 1 1)))]\n        [strength (- num_cap - num_sm)]\n        [extension\
    \ (min (list (string-downcase (substring class_name 0 0)))\n                 \
    \        (sort extensions \n                               (lambda (a b) \n  \
    \                               (cond\n                                  [(= strength\
    \ (- string-downcase (substring a 0 0))) b]\n                                \
    \  [(= strength (- string-downcase (substring b 0 0))) a]\n                  \
    \                [else (list* a b)]))])\n        [last_extension (last extension)]\n\
    \        [strongest_extension (list* last_extension (reverse extension))]\n  \
    \      [strongest_extension_name (append (substring class_name 1 0)\n        \
    \                                (str (string-downcase last_extension)))]\n  \
    \      [extensions_length (length extensions)])\n\n    (cond\n      [(= num_cap\
    \ 0) (set* strongest_extension_name class_name)]\n      [(= num_sm 0) (set* strongest_extension_name\
    \ (append (substring class_name 0 1)\n                                       \
    \                 (str (string-downcase extension)))]\n      [else (set* strongest_extension_name\
    \ (append (str (string-downcase extension))\n                                \
    \                        (str (string-downcase strongest_extension_name))))]))\n",
  "  (cond\n    [(empty? extensions)\n     (cons class_name '())]\n    [(equal? (caar\
    \ extensions) (caar (car extensions)))\n     (cadr extensions)]\n    [else\n \
    \    (append (list class_name)\n             (Strongest_Extension (caar extensions)\n\
    \                                 (cdr extensions)))]))\n", "  (cond\n    [(empty?\
    \ extensions) '']\n    [else\n     (let ([first_ext (first extensions)])\n   \
    \    (cond\n        [(string-equal? class_name first_ext) first_ext]\n       \
    \ [else (cond\n          [(empty? (rest extensions)) first_ext]\n          [(string-equal?\
    \ class_name (rest extensions)) (first extensions)]\n          [(string-equal?\
    \ (first extensions) (rest extensions)) (Strongest_Extension class_name (rest\
    \ extensions))])])])])) ;; (display (Strongest_Extension class_name extensions))\
    \ ;; (display (string class_name \".\" first_ext \".\" (rest extensions))))\n",
  "  (let ((max_extension \n          (max-extension-strength (map extension->class-name\
    \ extensions))))\n    (if (eq? max_extension '?) \n        (string-append class_name\
    \ \".\" '?) \n        (string-append class_name \".\" (extension->class-name max_extension))))))\n",
  "  (cond\n    [(empty? extensions) \"\"]\n    [(member (first extensions) (map (lambda\
    \ (e) (char->string) (string->list e)) (sort extensions))) \n      (append class_name\
    \ (cons (first extensions) \".\"))]\n    [else (Strongest_Extension (append class_name\
    \ \".\") (rest extensions))]))\n", "  (cond\n    [(empty? extensions) class_name]\n\
    \    [(member class_name extensions)\n     (format \"%s.%s\" \n             (append\
    \ (substring class_name 0 length) \n                     (substring extensions\
    \ 0 ((length (first extensions)) -1) \n                             length))\n\
    \             (Strongest_Extension (substring class_name 1 length) \n        \
    \                           (rest extensions)))]\n    [else\n     (Strongest_Extension\
    \ (substring class_name 0 length) \n                           (rest extensions))]))\n\
    \n", "  (let ((classes (reverse (append (list class_name)\n                  \
    \                  (map (lambda (x) (char-length x)) extensions))))\n        (extensions\
    \ (reverse extensions))\n        (extensions-by-stren (assoc -1 extensions))\n\
    \        (extensions-by-length (assoc -1 extensions extensions-by-stren))\n  \
    \      (extensions-sorted-by-length (sort extensions-by-length \n            \
    \                           (lambda (a b) (char-length a) \n                 \
    \                        (char-length b))))\n    (cond\n      [(empty? classes)\
    \ \"\"]\n      [(empty? extensions) \"\"]\n      [(empty? (cdr extensions)) \"\
    \"]\n      [else \n       (let* ((stren (char-at (car extensions-sorted-by-length)\n\
    \                               (char-at (car extensions-sorted-by-length)\n \
    \                                      (char-length (car extensions-sorted-by-length))))))\n\
    \         (cond\n           [(and (>= stren (char-length (car extensions))) \n\
    \                (< stren (char-length (car extensions))))\n            (concat\
    \ (car classes)\n                    \".\"\n                    (intercalate \"\
    ..\" extensions))]\n           [else \n            (concat (intercalate \".\"\
    \ classes)\n                    \".\"\n                    (intercalate \"..\"\
    \ extensions))]\n           [else (cond\n                     [(and (>= stren\
    \ (char-length (car extensions))) \n                          (< stren (char-length\
    \ (car extensions))))\n                      (concat (car classes)\n         \
    \                     \".\"\n                              (intercalate \"..\"\
    \ extensions))]\n                     [(and (>= stren (char-length (car extensions)))\
    \ \n                          (>= stren (char-length (cdr extensions))))\n   \
    \                   (concat (car classes)\n                              \".\"\
    \n                              (intercalate \"..\" extensions))]\n          \
    \           [else \n                      (concat (intercalate \".\" classes)\n\
    \                              \".\"\n                              (intercalate\
    \ \"..\" extensions))])]))]))]))\n", "  (sort extensions (lambda (ext)\n     \
    \             (/ (string-length ext) (length class_name)))\n          'ascending))\n",
  "  ;; Base case\n  (cond\n    [(empty? extensions) (error 'Strongest_Extension '(class_name))]\n\
    \    [else (let ([CAP (length extensions)])\n           (cond\n             [(=\
    \ CAP 0) (error 'Strongest_Extension '(class_name))]\n             [(= CAP 1)\
    \ (error 'Strongest_Extension '(class_name))]\n             [(= CAP 2) (error\
    \ 'Strongest_Extension '(class_name))]\n             [(< CAP 3) (error 'Strongest_Extension\
    \ '(class_name))]\n             [else (let ([SM (length extensions)])\n      \
    \               (cond\n                       [(= SM (length extensions)) (error\
    \ 'Strongest_Extension '(class_name))]\n                       [(= SM (length\
    \ extensions)) (error 'Strongest_Extension '(class_name))]\n                 \
    \      [(= SM (length extensions)) (error 'Strongest_Extension '(class_name))]\n\
    \                       [(= SM (length extensions)) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [(< SM (length extensions)) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [(< (/ CAP (+ 2 SM))) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [(< (/ CAP (+ 2 SM))) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [(< (/ CAP (+ 2 SM))) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [(< (/ CAP (+ 2 SM))) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [(< (/ CAP (+ 2 SM))) (error 'Strongest_Extension\
    \ '(class_name))]\n                       [else (let ([strongest_extension (first\
    \ extensions)])\n                               (cond\n                      \
    \           [(= CAP SM) (strongest_extension)]\n                             \
    \    [(< CAP SM) (error 'Strongest_Extension '(class_name))]\n               \
    \                  [(< SM (- CAP 1)) (strongest_extension)]\n                \
    \                 [else (error 'Strongest_Extension '(class_name))]))]))]))]))]))\n\
    \n", "  (cond\n    [(empty? extensions) \"\"]\n    [(eq? (first extensions) class_name)\
    \ \n     (reverse extensions)\n    ]\n    [(> (length extensions) 2)\n     (error\
    \ \"Two or more extensions have the same strength.\")\n    ]\n    [else \n   \
    \  (error \"Not enough extensions are given.\")\n    ]\n  )\n)\n", "  (define\
    \ (helper extension i)\n    (cond [(> i 0)\n           (if (< (string-length extension)\
    \ (string-length class_name)) ;; too long\n               extension\n        \
    \       (helper (string-downcase (substring extension 0 (- i 1))) (i-1))] ;; too\
    \ short\n          [(< (string-length extension) (string-length class_name)) \
    \   ;; too short\n           (list class_name extension)]\n          [else\n \
    \          (list class_name extension (substring extension 0 (- (string-length\
    \ extension) (string-length class_name))))]))\n  (helper (string-length class_name)\
    \ 0))\n", "  (let loop ((class_name class_name)\n             (extensions extensions))\n\
    \    (if (null? extensions)\n        '\n        (let ((extension (car extensions))\n\
    \               (strength (Math-Strongest-Extension-Strong-Extension\n       \
    \                      (string-match '([A-Z]) (car extensions)\n             \
    \                                 (string-match '([a-z]) (cdr extensions)))))\n\
    \               (extensions (cdr extensions)))\n          (if (< strength 0)\n\
    \              (loop (cons (substring class_name 0 strength)\n               \
    \           extensions)\n                    extensions)\n              (if (eq?\
    \ class_name extension)\n                  (loop (substring class_name strength)\n\
    \                        extensions)\n                  (if (<= (length (append\
    \ class_name (list extension)))\n                           (length (append extension\
    \ (list class_name))))\n                      extension)))))))\n", "  (cond\n\
    \    [(empty? extensions) class_name]\n    [(> (length extensions) 1) class_name]\n\
    \    [else (cond \n           [; Extensions have the same strength.\n        \
    \    (< (length extensions) 2)\n            (let\n              [extension_name\
    \ (first extensions)]\n              (set! extension_name (reverse extension_name))\n\
    \              (cond\n                [(empty? extension_name) class_name]\n \
    \               [else (cond (empty? (substring class_name 0 (- (length extension_name))\
    \ (length extension_name))) class_name)\n                           (else (cond\
    \ [(substring extension_name 0 (- (length extension_name)) (length extension_name))\
    \ \n                                         `(~(substring class_name 0 (- (length\
    \ extension_name)) (length extension_name)))\n                               \
    \          (cons extension_name (drop extension_name (- extension_name extensions)))])]))\n\
    \           ]\n           [; Extensions have different strength.\n           \
    \ (< (length extensions) 3)\n            (let\n              [extension_name (first\
    \ extensions)]\n              (set! extension_name (reverse extension_name))\n\
    \              (cond\n                [(empty? extension_name) class_name]\n \
    \               [else (cond (empty? (substring class_name 0 (- (length extension_name))\
    \ (length extension_name))) class_name)\n                           (else (cond\
    \ [(substring extension_name 0 (- (length extension_name)) (length extension_name))\
    \ \n                                         `(~(substring class_name 0 (- (length\
    \ extension_name)) (length extension_name)))\n                               \
    \          (cons extension_name (drop extension_name (- extension_name extensions)))])])\n\
    \           ]\n           [else (cond \n                   [(empty? (substring\
    \ class_name 0 (- (length extensions) (length extensions))))\n               \
    \     class_name]\n                   [(empty? (substring class_name 0 (- (length\
    \ extensions) (length extensions))))\n                    class_name]\n      \
    \             [(empty? (substring class_name 0 (- (length extensions) (length\
    \ extensions))))\n                    class_name]\n                   [(empty?\
    \ (substring class_name 0 (- (length extensions) (length extensions))))\n    \
    \                class_name]\n                   [(empty? (substring class_name\
    \ 0 (- (length extensions) (length extensions))))\n                    class_name]\n\
    \                   [(empty? (substring class_name 0 (- (length extensions) (length\
    \ extensions))))\n                    class_name]\n                   [(empty?\
    \ (substring class_name 0 (- (length extensions) (length extensions))))\n    \
    \                class_name]\n                   [else (cond [(empty? (substring\
    \ class_name 0 (- (length extensions) (length extensions))))\n               \
    \                    class_name]", "  (let* ((extension-length (length extensions))\n\
    \         (cap (length class_name)))\n    (cond ((< extension-length cap) (Strongest_Extension\
    \ class_name (reverse extensions)))\n          ((> extension-length cap) (Strongest_Extension\
    \ class_name (extensions reverse)))\n          ((eq? cap (- extension-length SM))\n\
    \           (cons class_name (reverse extensions))))\n      (else (cons class_name\
    \ extensions))))\n", "  (cond\n    [(empty? extensions) '.']\n    [(equal? (caar\
    \ extensions) 'AA') (cons (caddr extensions) '.')]\n    [(equal? (caar extensions)\
    \ 'Be') (cons (caddr extensions) '.')]\n    [(equal? (caar extensions) 'CC') (cons\
    \ (caddr extensions) '.')]\n    [else (cons (caddr extensions) '.')])\n)\n", " \
    \ (let ((extensions-len (length extensions))\n        (best-extension #f)\n  \
    \      (strongest-extension-name #f))\n    (if (= extensions-len 0)\n        strongest-extension-name\n\
    \        (loop for extension from 1 to extensions-len\n              for strongest-extension\
    \ = (substring class_name (length extension) extension)\n              for strongest-extension-name\
    \ = (substring strongest-extension 0 (- strongest-extension 1))\n            \
    \  when (>= (- strongest-extension 1) (- strongest-extension-name 1))\n      \
    \        when (< strongest-extension-name strongest-extension\n              \
    \       break\n                     )\n              when (> strongest-extension-name\
    \ strongest-extension\n                     best-extension\n                 \
    \    )\n              when (< best-extension extension\n                     best-extension\n\
    \                     )\n              when (> best-extension extension\n    \
    \                 strongest-extension-name\n                     )\n         \
    \     collect strongest-extension-name\n              )\n    )\n    )\n)\n</code>\n\
    I hope this helps somebody else. \nI only now have to figure out how to make things\
    \ work in Racket.\n<|/ a dscore=1 |>\n<| c |>\nI edited my post to include my\
    \ solution to this. It is very similar to what you wrote, so I'm going to mark\
    \ your post as the answer.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme |>\nI was\
    \ working on something similar recently and figured I would share my solution.\
    \ \n<code>", "  (cond\n    [(empty? extensions) '()]\n    [else (cond\n      \
    \    [(equal? (extension-name (car extensions)) class_name)\n           (car extensions)]]\n\
    \          [(equal? (extension-name (car extensions)) (lower-case class_name))\n\
    \           (cdr extensions)]]\n        [(equal? (extension-name (car extensions))\
    \ (lower-case (lower-case class_name)))\n         (cdr extensions)]))\n", "  (let\
    \ ([strongest_extension (Max (length extensions))]\n        [strongest_extension_name\
    \ \"\"])\n    (for ([i extensions]) \n      (cond [(zero? (- i strongest_extension))\
    \ (set! strongest_extension_name (list-ref extensions i))]\n            [else\
    \ (set! strongest_extension_name (strongest_extension_name ? (substring class_name\
    \ 0 i))))])\n    (string-append class_name \".\" (string strongest_extension_name))\n\
    \  )\n)\n", "  (cond\n    [(empty? extensions) \"\"]\n    [(equal? (first extensions)\
    \ (first extensions)) (second extensions)]\n    [else (Strongest_Extension (first\
    \ extensions) (rest extensions))]))\n", "  (let ([cap (length class_name)\n  \
    \      sm  (length class_name (minusp cap))])\n    (let ([strength (- sm (length\
    \ extensions))])\n      (sort extensions (lambda (e) (/ (count e cap) strength)))))\n\
    \  ;; You will need to write this function\n  (define (Strongest_Extension class_name\
    \ extensions)\n    (let ([cap (length class_name)\n          sm  (length class_name\
    \ (minusp cap))])\n      (let ([strength (- sm (length extensions))])\n      \
    \  (sort extensions (lambda (e) (/ (count e cap) strength)))))\n  ;; You will\
    \ need to write this function\n  ;; (define (Strongest_Extension class_name extensions)\n\
    \    (let ([cap (length class_name)\n          sm  (length class_name (minusp\
    \ cap))])\n      (let ([strength (- sm (length extensions))])\n        (sort extensions\
    \ (lambda (e) (/ (count e cap) strength)))))\n  ;; You will need to write this\
    \ function\n  ;; (define (Strongest_Extension class_name extensions)\n    (let\
    \ ([cap (length class_name)\n          sm  (length class_name (minusp cap))])\n\
    \      (let ([strength (- sm (length extensions))])\n        (sort extensions\
    \ (lambda (e) (/ (count e cap) strength)))))\n  ;; You will need to write this\
    \ function\n  ;; (define (Strongest_Extension class_name extensions)\n    (let\
    \ ([cap (length class_name)\n          sm  (length class_name (minusp cap))])\n\
    \      (let ([strength (- sm (length extensions))])\n        (sort extensions\
    \ (lambda (e) (/ (count e cap) strength)))))\n  ;; You will need to write this\
    \ function\n  ;; (define (Strongest_Extension class_name extensions)\n    (let\
    \ ([cap (length class_name)\n          sm  (length class_name (minusp cap))])\n\
    \      (let ([strength (- sm (length extensions))])\n        (sort extensions\
    \ (lambda (e) (/ (count e cap) strength)))))\n  ;; You will need to write this\
    \ function\n  ;; (define (Strongest_Extension class_name extensions)\n    (let\
    \ ([cap (length class_name)\n          sm  (length class_name (minusp cap))])\n\
    \      (let ([strength (- sm (length extensions))])\n        (sort extensions\
    \ (lambda (e) (/ (count e cap) strength)))))\n  ;; You will need to write ", " \
    \ (if (null? extensions)\n      class_name\n      (let ([extension \n        (lambda\
    \ ()\n          (let ([ext (list-ref extensions 0)])\n            (set! extensions\
    \ \n                  (subseq extensions 1 \n                         (length\
    \ (remove-if (lambda (x) (char=? (char-code x) 65)) extensions)))))\n        \
    \  ext)])\n        (extension))))\n</code>\n<code>\n#lang racket\n", "  (cond\n\
    \    ((empty? extensions) (error \"No extensions given\"))\n    ((equal? (string-length\
    \ class_name) (string-length extensions)) (error \"Class name is the same length\
    \ as the number of extensions\"))\n    ((equal? (string-length class_name) 1)(error\
    \ \"Class name is a single letter\"))\n    ((equal? (string-length class_name)\
    \ 2)(error \"Class name is a two-letters extension\"))\n    ((equal? (string-length\
    \ class_name) 3)(error \"Class name is a three-letters extension\"))\n    ((equal?\
    \ (string-length class_name) 4)(error \"Class name is a four-letters extension\"\
    ))\n    ((equal? (string-length class_name) 5)(error \"Class name is a five-letters\
    \ extension\"))\n    ((equal? (string-length class_name) 6)(error \"Class name\
    \ is a six-letters extension\"))\n    ((equal? (string-length class_name) 7)(error\
    \ \"Class name is a seven-letters extension\"))\n    ((equal? (string-length class_name)\
    \ 8)(error \"Class name is a eight-letters extension\"))\n    ((equal? (string-length\
    \ class_name) 9)(error \"Class name is a nine-letters extension\"))\n    ((equal?\
    \ (string-length class_name) 10)(error \"Class name is a ten-letters extension\"\
    ))\n    ((equal? (string-length class_name) 11)(error \"Class name is a eleven-letters\
    \ extension\"))\n    ((equal? (string-length class_name) 12)(error \"Class name\
    \ is a twelve-letters extension\"))\n    ((equal? (string-length class_name) 13)(error\
    \ \"Class name is a thirteen-letters extension\"))\n    ((equal? (string-length\
    \ class_name) 14)(error \"Class name is a fourteen-letters extension\"))\n   \
    \ ((equal? (string-length class_name) 15)(error \"Class name is a fifteen-letters\
    \ extension\"))\n    ((equal? (string-length class_name) 16)(error \"Class name\
    \ is a sixteen-letters extension\"))\n    ((equal? (string-length class_name)\
    \ 17)(error \"Class name is a seventeen-letters extension\"))\n    ((equal? (string-length\
    \ class_name) 18)(error \"Class name is a eighteen-letters extension\"))\n   \
    \ ((equal? (string-length class_name) 19)(error \"Class name is a nineteen-letters\
    \ extension\"))\n    ((equal? (string-length class_name) 20)(error \"Class name\
    \ is a twenty-letters extension\"))\n    ((equal? (string-length class_name) 21)(error\
    \ \"Class name is a twenty-letters extension\"))\n    ((equal? (string-length\
    \ class_name) 22)(error \"Class name is a tw", "  (define (fraction cap sm)\n\
    \    (if (= sm 0)\n        (/ (- cap cap) 2)\n        (/ (- cap cap) (- sm sm))))\n\
    \n  (define (streng name abbr cap sm)\n    (if (member abbr abbr-list)\n     \
    \   (if name name-list abbr)\n        (if (or (member name (name-list abbr)) (member\
    \ abbr (abbr-list name)))\n            abbr (if (= (fraction cap sm) 0)\n    \
    \            (cons name (name-list abbr))\n                (cons abbr (abbr-list\
    \ name)))))))\n\n  (define (match name abbr cap sm)\n    (let ((strengs (streng\
    \ name abbr cap sm)))\n      (if (empty? strengs)\n          (error \"No matches.\"\
    ))\n      (streng strengs 0 0))))\n", "  (if (null? extensions) (Cons 'Error Error-Message))\n\
    \  (let ((best_extension (car extensions))\n        (best_extension_strength (Cons\
    \ 'Error (* -1 -1 -1))))\n    (if (< (length extensions) 2)\n        (begin\n\
    \          (let ((extension (car extensions)))\n            (if (equal? (string-case\
    \ (second extension)) (string-case class_name))\n                (begin\n    \
    \              (let ((strength (string-length extension)))\n                 \
    \   (if (< (- strength best_extension_strength) best_extension_strength)\n   \
    \                     (begin\n                          (set! best_extension_strength\
    \ (cons strength best_extension_strength))\n                          best_extension\n\
    \                          strength)\n                        (begin\n       \
    \                   (set! best_extension_strength (cons strength (cons (- strength\
    \ best_extension_strength) (cons best_extension extension))))\n              \
    \            best_extension_strength)))\n                (begin\n            \
    \      (set! best_extension_strength (cons (- strength best_extension_strength)\
    \ best_extension_strength))\n                  best_extension\n              \
    \    strength)))\n          (begin\n            (set! best_extension_strength\
    \ (cons (- strength best_extension_strength) best_extension_strength))\n     \
    \       best_extension\n            strength)))\n    (begin\n      (set! best_extension_strength\
    \ (cons (- strength best_extension_strength) best_extension_strength))\n     \
    \ best_extension\n      strength))))\n", "  ;; (define CS [(Strongest_Extension\
    \ \"my_class\" '(\"AA\" \"Be\" \"CC\")) ", "  (define (strength-str extension)\n\
    \    (/ (string-length extension) (string-length class_name))) \n  (define (sort-extensions\
    \ extensions strength)\n    (sort extensions \n          (lambda (x y) (if (<\
    \ (strength x) (strength y)) -1 1))))\n  (sort-extensions extensions strength-str))\
    \ \n", "  (define (compare-strength ex ext)\n    (cond (\n          (member (substring\
    \ ex 0 1) '(A B C)) -1\n          (member (substring ex 0 1) '(a b c)) 1\n   \
    \       (member (substring ex 0 1) '(1 2 3)) 0\n          :else 0))\n  (define\
    \ (strength ext)\n    (cond ((= (length ext) 0)\n           0)\n          ((member\
    \ (first ext) '(A B C))\n           (- 0 (length (substring (first ext) 1 ))))\n\
    \          ((member (first ext) '(a b c))\n           (- 0 (length (substring\
    \ (first ext) 1 ))))\n          ((member (first ext) '(1 2 3))\n           (-\
    \ 0 (length (substring (first ext) 1 ))))\n          :else 0))\n  (define (strength-list\
    \ ext)\n    (cond ((null? ext) '())\n          ((member (first ext) '(A B C))\n\
    \           (cons (cons ext (first ext)) (strength-list (rest ext))))\n      \
    \    ((member (first ext) '(a b c))\n           (cons (cons ext (first ext)) (strength-list\
    \ (rest ext))))\n          ((member (first ext) '(1 2 3))\n           (cons (cons\
    \ ext (first ext)) (strength-list (rest ext))))\n          :else (cons (cons ext\
    \ (first ext)) (strength-list (rest ext))))))\n", "  (cond\n    [(empty? extensions)\
    \ (list class_name)]\n    [(< (count (filter (lambda (x) (starts-with-? (first\
    \ x) class_name)) extensions)) 2)\n     (list class_name)]\n    [else (first (sort\
    \ (map (lambda (x) (length (filter (lambda (y) (starts-with-? (first y) x)) extensions)))\
    \ extensions))]))", "  (cond\n    [(null? extensions) (list class_name)]\n   \
    \ [(null? (cdr extensions)) (list class_name)]\n    [(equal? (string-length extensions)\
    \ 1)\n     (if (equal? (string-char-car extensions) (string-char-car extensions))\n\
    \         (list class_name\n               (string-append (substring class_name\
    \ 0 (string-length extensions))\n                              \".\" (substring\
    \ class_name (string-length extensions) 1)))\n         (list class_name (substring\
    \ class_name 0 (string-length extensions))))]\n    [(equal? (string-length extensions)\
    \ 2)\n     (if (equal? (string-char-car extensions) (string-char-car extensions)\n\
    \               (string-char-lower (string-char-upper (string-char-cdr extensions)\
    \ 1))\n               (string-append (substring class_name 0 (string-length extensions))\n\
    \                              \".\" (substring class_name (string-length extensions)\
    \ 1))))\n     (list class_name (substring class_name 0 (string-length extensions))\n\
    \            (reverse\n             (string-append (substring class_name 0 (string-length\
    \ extensions))\n                              \".\" (substring class_name (string-length\
    \ extensions) 1))\n             (reverse extensions)))]\n    [else\n     (cond\n\
    \       [(equal? (string-char-car extensions) (string-char-car extensions))\n\
    \        (cond\n         [(equal? (string-char-lower (string-char-upper (string-char-cdr\
    \ extensions) 1))\n              (string-append (substring class_name 0 (string-length\
    \ extensions))\n                              \".\" (substring class_name (string-length\
    \ extensions) 1)))\n          (cond\n           [(equal? (string-char-lower (string-char-upper\
    \ (string-char-cdr extensions) 2))\n              (string-append (substring class_name\
    \ 0 (string-length extensions))\n                              \".\" (substring\
    \ class_name (string-length extensions) 2)))]\n           [else\n            (list\
    \ class_name (substring class_name 0 (string-length extensions))\n           \
    \       (reverse\n                   (string-append (substring class_name 0 (string-length\
    \ extensions))\n                                   \".\" (substring class_name\
    \ (string-length extensions) 1))\n                   (reverse extensions))))]\n\
    \         [else\n          (list class_name (substring class_name 0 (string-length\
    \ extensions))\n                (reverse\n                 (string-append (substring\
    \ class_name 0 (string-length extensions))\n                                 \"\
    .\" (substring class_name (string-length extensions) 1))\n                 (reverse\
    \ extensions))))]]\n       [else\n        (cond\n         [(equal? (string-char-lower\
    \ (string-char-upper (", "  (let ([letters (length extensions)])\n    (cond\n\
    \      [(= letters 0) (format nil \"~a\" class_name)]\n      [(equal? (char-lower-case\
    \ (first extensions))\n              (char-lower-case (first extensions))) \n\
    \       (format nil \"~a.~a\" class_name (first extensions))]\n      [(equal?\
    \ (char-upper-case (first extensions))\n              (char-upper-case (first\
    \ extensions))) \n       (format nil \"~a.~a\" class_name (first extensions))]\n\
    \      [else\n       (format nil \"~a.~a\" class_name \n               ((/ (+\
    \ (- letters 1) (min letters 2))\n                    2) (min letters 2)))]))\n\
    \  ", "  (define C (length class_name))\n  (define SM (length extensions))\n \
    \ (define CAP (length class_name #\\a))\n  (define SM_CAP (- (CAP SM) CAP))\n\
    \  (define SM_SM (- (SM_CAP) SM_CAP))\n  (define SM_SM_SM (- (SM_SM_SM) SM_SM_SM))\n\
    \  (define STRONG (if (< (+ (* CAP SM) (* CAP SM_SM))\n                      \
    \ (+ (* SM_SM SM_SM_SM) SM_SM_SM_SM))\n                  (first extensions)\n\
    \                  '()))\n\n  (let ([x (first extensions)])\n    (if (> SM (length\
    \ x))\n        (Strongest_Extension class_name extensions)\n        (if (< (+\
    \ (* CAP SM) (* CAP SM_SM))\n               (+ (* SM_SM SM_SM_SM) SM_SM_SM_SM))\n\
    \            (Strongest_Extension class_name (rest extensions))\n            (Strongest_Extension\
    \ class_name (cons x extensions)))))\n", "  (cond\n    [(empty? extensions) (error\
    \ 'Strongest_Extension (string-append class_name \".\" \"\"))]\n    [(not (string-equal?\
    \ class-name (car extensions))) (error 'Strongest_Extension \"The extensions must\
    \ include only classes from this class\")]\n    [else (cons (car extensions) (Strongest_Extension\
    \ (cdr extensions) (filter (lambda (x) (string-equal? class-name x) extensions))))]\n\
    \  ))\n", "  (let ([sorted_extensions (sort extensions (foldr (lambda (a b) \n\
    \                                           (- (length a) (length b))\n      \
    \                                     (string-compare a b)))])\n        (strongest_extension\
    \ (first sorted_extensions))])\n    (if (equal? class_name strongest_extension)\n\
    \        (second sorted_extensions)\n        (Strongest_Extension (string (strongest_extension\
    \ . class_name) \n                               (string class_name \".\" \n \
    \                                      (first sorted_extensions))\n          \
    \                     sorted_extensions)))))\n", "  (if (empty? extensions)\n\
    \      class_name\n      (let ((best_extension (first extensions)))\n        (if\
    \ (= (length (string->list (string-ref class_name 0))) (length (string->list (string-ref\
    \ best_extension 0))))\n            (append class_name \n                    \
    \ (cons (string-cat class_name '.') \n                           (string-cat best_extension\
    \ '.')))\n            (append best_extension (cons (string-cat class_name '.')\
    \ best_extension)))))) \n", "  (let* ((extension-count\n         (count extensions))\n\
    \         (extension-chars\n          (map car\n               (reverse (take-while\
    \ symbol=? (reverse extensions)))))\n         (extension-upper\n          (map\
    \ string=?\n              (map string->char\n                   (map string->symbol\n\
    \                       (map string->string\n                          (filter\
    \ string=? (string-split class_name \"#\"))))))\n         (extension-lower\n \
    \         (map string=?\n              (map string->char\n                   (map\
    \ string->symbol\n                       (map string->string\n               \
    \           (filter string=? (string-split class_name \"#\")))))))\n         (extension-strength\n\
    \          (lambda (x)\n            (if (empty? x)\n                0\n      \
    \          (let ((x x))\n                  (+ (map (lambda (y)\n             \
    \               (/ (length y) 2))\n                        x)\n              \
    \            (map (lambda (y)\n                                (/ (length y) 1))\n\
    \                                x))\n                  -1))))\n         (extension-strengths\
    \ (reduce (lambda (x y)\n                                     (cons (list (car\
    \ x) (car y))\n                                          (map extension-strength\
    \ y)))\n                                   extension-upper\n                 \
    \                  extension-lower))\n         (extension-strengths-sorted \n\
    \          (sort extension-strengths >)))\n    (cond\n      ((empty? extensions)\
    \ (format nil \"~a.~a\" class_name \"\"))\n      ((member (extension-strengths-sorted\
    \ extension-chars) extensions)\n       (format nil \"~a.~a\" (string-split class_name\
    \ \"#\") (first extension-chars)))\n      (else \n       (format nil \"~a.~a\"\
    \ (first extension-chars) (Strongest_Extension (second extension-chars) extensions))))))\n",
  "  (let\n    ([counts (group-by (lambda (x) (char-type x)) extensions)]\n     [max\
    \ (reduce (lambda (x y) (if (> (second x) \n                                 \
    \           (second y)) \n                                          x (y)) '()\
    \ extensions))]\n     [strength (lambda (x) (/ (char-count x) count))])\n    (if\
    \ (empty? extensions)\n        class_name\n        (let ([name (name (first extensions))])\n\
    \          (if (null? name)\n              (let ([strength (strength (first extensions))])\n\
    \                (format #f \"~A.~A\" class_name (symbol->string name))\n    \
    \            (if (> (strength max) -0)\n                    (format #f \"~A.~A\"\
    \ class_name name)\n                    (format #f \"~A.~A\" (symbol->string name)\
    \ \n                              (symbol->string (Strongest_Extension \n    \
    \                                              name extensions)))))))))\n", " \
    \ (define (my_strength x y)\n    (let ((x x))\n      (if (char-case? x y)\n  \
    \        0\n          (+ (char-case? x 'A) (char-case? y 'A)))))\n  (let ((extension-list\
    \ '()))\n    (for extension in extensions\n      (let* ((extension-name (substring\
    \ extension 0 (string-length extension)))\n             (extension-chars (string-length\
    \ extension)))\n        (when (char-case? extension-name 'A)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'B)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'C)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'D)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'E)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'F)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'G)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'H)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'I)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'J)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'K)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (when (char-case? extension-name 'L)\n          (push\
    \ (string extension-name \n                       (string-length extension-chars))\
    \ extension-list))\n        (", "  (cond\n    [(empty? extensions) '.']\n    [(=\
    \ (length extensions) 1)\n     cons (string-append (substring class_name 0 (length\
    \ class_name) 1)\n                        (substring extensions 0 (length extensions)\
    \ 1))]\n    [else\n     (let ([(extension-name extension) (list-ref extensions\
    \ (length extensions))])\n       (cond\n         [(<= (length extensions) 2)\n\
    \          (cons extension-name extension)]\n         [(<= (length extensions)\
    \ 3)\n          (cons (string-append extension-name 'AA') extension)]\n      \
    \   [(<= (length extensions) 4)\n          (cons (string-append extension-name\
    \ 'AB') extension)]\n         [(<= (length extensions) 5)\n          (cons (string-append\
    \ extension-name 'BA') extension)]\n         [(<= (length extensions) 6)\n   \
    \       (cons (string-append extension-name 'BB') extension)]\n         [(<= (length\
    \ extensions) 7)\n          (cons (string-append extension-name 'CA') extension)]\n\
    \         [(<= (length extensions) 8)\n          (cons (string-append extension-name\
    \ 'CB') extension)]\n         [(<= (length extensions) 9)\n          (cons (string-append\
    \ extension-name 'CC') extension)]\n         [(<= (length extensions) 10)\n  \
    \        (cons (string-append extension-name 'Da') extension)]\n         [(<=\
    \ (length extensions) 11)\n          (cons (string-append extension-name 'Db')\
    \ extension)]\n         [(<= (length extensions) 12)\n          (cons (string-append\
    \ extension-name 'De') extension)]\n         [(<= (length extensions) 13)\n  \
    \        (cons (string-append extension-name 'E') extension)]\n         [(<= (length\
    \ extensions) 14)\n          (cons (string-append extension-name 'F') extension)]\n\
    \         [(<= (length extensions) 15)\n          (cons (string-append extension-name\
    \ 'G') extension)]\n         [(<= (length extensions) 16)\n          (cons (string-append\
    \ extension-name 'H') extension)]\n         [(<= (length extensions) 17)\n   \
    \       (cons (string-append extension-name 'I') extension)]\n         [(<= (length\
    \ extensions) 18)\n          (cons (string-append extension-name 'J') extension)]\n\
    \         [(<= (length extensions) 19)\n          (cons (string-append extension-name\
    \ 'K') extension)]\n         [(<= (length extensions) 20)\n          ("]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
