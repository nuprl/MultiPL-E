name: HumanEval_66_digitSum
language: rkt
prompt: "#lang racket\n\n;; Task\n;; Write a function that takes a string as input\
  \ and returns the sum of the upper characters only'\n;; ASCII codes.\n;; Examples:\n\
  ;; digitSum(\"\") => 0\n;; digitSum(\"abAB\") => 131\n;; digitSum(\"abcCd\") =>\
  \ 67\n;; digitSum(\"helloE\") => 69\n;; digitSum(\"woArBld\") => 131\n;; digitSum(\"\
  aAaaaXa\") => 153\n(define (digitSum s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n\
  \    (check-equal? (candidate \"\") 0)\n    (check-equal? (candidate \"abAB\") 131)\n\
  \    (check-equal? (candidate \"abcCd\") 67)\n    (check-equal? (candidate \"helloE\"\
  ) 69)\n    (check-equal? (candidate \"woArBld\") 131)\n    (check-equal? (candidate\
  \ \"aAaaaXa\") 153)\n    (check-equal? (candidate \" How are yOu?\") 151)\n    (check-equal?\
  \ (candidate \"You arE Very Smart\") 327)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    ((empty? s) 0)\n    ((char? (car s))\n      (+ (char->integer\
    \ car s)\n         (digitSum (cdr s))))\n    ((and (number? (car s)) (char? (cdr\
    \ s))\n          (char? (car s))\n          (and\n           (char->integer car\
    \ s)\n           (number? (cdr s))))\n      (+ (char->integer car s)\n       \
    \  (digitSum (cdr s))))\n    (else\n      (digitSum (cdr s)))))\n</code>\n<|/\
    \ a |>\n<| c |>\nNice answer, thanks for the extra detail. I've already learned\
    \ some from this.\n<|/ c |>\n<| c |>\n`(char->integer 'a)` results in an error:\
    \ `char->integer: not all arguments have types;\n expected all arguments provide\
    \ an explicit type` because there is no `integer` function defined for `char`s.\
    \ You could replace it with `(char->integer #\\a)`, but then you don't need to\
    \ define `char->integer`.\n<|/ c |>\n<| a dscore=2 tags=racket,scheme |>\nHere's\
    \ a recursive solution:\n<code>", "  (cond\n    ((empty? s) 0)\n    ((char= (first\
    \ (rest s)) (char 'A)) (+ 0 (digitSum (rest s))))\n    ((char= (first (rest s))\
    \ (char 'a)) (+ 0 (digitSum (rest s))))\n    (else (digitSum (rest s)))))\n",
  "  (cond\n    [(empty? s) 0]\n    [else (+ (number->char (digit-char (char->number\
    \ (first (string->list (string-ref s 0))))) 1)\n           (number->char (digit-char\
    \ (char->number (rest (string->list (string-ref s 0))))))]))\n", "  (sum (map\
    \ digit s))\n  )\n", "  (define (digit-sum s)\n    (if (string? s)\n        (digit-sum\
    \ (string->list s))\n        (if (empty? s)\n            0\n            (+ (first\
    \ s) (digit-sum (rest s)))))))\n  (digit-sum s))\n", "  (cond [(empty? s) 0]\n\
    \        [(> (number->char-code (car s))\n            (number->char-code (cadr\
    \ s))) (* (cadr s) (digitSum s))]\n        [else (+ (number->char-code (car s))\n\
    \                (digitSum (cdr s)))]))\n", "  (cond [(empty? s) 0]\n        [(>=\
    \ (first s) #\\A) (+ (first s)(digitSum (rest s)))]\n        [else (digitSum (rest\
    \ s))]))\n</code>\n<|/ a dscore=2 |>\n<| a |>\nFor those who might like some practical\
    \ exercises, I wrote a small piece of code. The code is not very sophisticated\
    \ and probably not very elegant, but it does show some of functional programming\
    \ concepts. \nThe code below is implemented in Racket.\n<code>", "  (cond\n  \
    \  [(empty? s) 0]\n    [else (+ (get-char-value (char->integer #\\A) s) (get-char-value\
    \ (char->integer #\\Z) s))]))\n", "  (if (or (empty? s) (= 0 (char-code (car s))))\
    \ 0\n      (+ (+ (char-code (car s)) 10) (- (digitSum (cdr s)) 10))))\n", "  (apply\
    \ + \n        (map #(let [ (n (char-code %))\n                        (char-code\
    \ (substring s 0 n))]\n                 (* 10 n) )) ))\n", "  (define (helper\
    \ s)\n    (if (string? s)\n        (helper (string-tail s))\n        (+ (ord (first\
    \ s)) (* (digitSum (rest s)) 26))))\n  (helper s))\n", "  (sum\n    (map (lambda\
    \ (c) (if (char->int (code-char c)) c #\\space)) s)\n    (lambda (x)\n      (+\
    \ x (if (char->int (code-char x)) x 0)))))\n", "  (cond [(empty? s) 0]\n     \
    \   [(or (char-upper? (first s)) (char-upper? (second s))) (+ 0 (digitSum (rest\
    \ s)))]\n        [else (+ 0 (digitSum (rest s))) ]))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a |>\nThe recursive solution using Racket is as follows:\n<code>", " \
    \ (sum (map char->int s))) ;; char->int is a function that takes a character and\
    \ returns the ASCII code\n", "  (let* ((sum (loop [acc 0] [s s])\n           \
    \      (if (char=? (first s) 'A) (+ acc char-code (first s)) acc))\n         (next-s\
    \ (rest s)))\n    (if (null? next-s)\n        sum\n        (digitSum (append s\
    \ next-s)))))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=racket,scheme |>\n\
    <code>", "  (if (empty? s)\n      (error \"Expected non-empty string\")\n    \
    \  (+ 1 (digitSum (substring s 0 1)))))\n", '  (if (empty? s) 0 (+ (char->digit
    (car s)) (* (digitSum (cdr s)) 10))))', "  (if (null? s)\n      0\n      (+ (char->integer\
    \ #\\0)\n         (map (fn [c] (char->integer c)) (substring s 0 (string-length\
    \ s))))\n  )\n)", "  (cond\n    [(empty? s) '0]\n    [(> (count s) 1) '0]\n  \
    \  [(< 1 2 (length (substring s 0 (- (length s) 1)))) '0]\n    [else (+ (digitSum\
    \ (substring s 0 (- (length s) 1))) \n           (digitSum (substring s (- (length\
    \ s) 1)))]))) \n", "  (define (helper s sum result)\n    (cond\n      [(null?\
    \ s) (println \"Result: \" result)]\n      [(char? s) (helper (cdr s) (+ (char->int\
    \ c) (sum)) (+ sum (char->int (car s))))]))\n  (helper s 0 0))\n</code>\n<|/ q\
    \ dscore=0 |>\n<| c |>\nHi Gareth, I didn't realize you had the homework tag.\
    \ Please disregard.\n<|/ c |>\n<| c |>\nHi Henrik, I added the homework tag. I\
    \ didn't want to add it to the question because it wasn't related to the problem\
    \ being solved. I just added it so the problem could be answered and people who\
    \ are looking for homework answers can find it.\n<|/ c |>\n<| a |>\n<code>", " \
    \ (cond [(empty? s) '()]\n        [(equal? (first (rest s))) #f]\n        [(digitSum\
    \ (first s)) +  (digitSum (rest s))]\n        [else (digitSum (first s))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(cons? s) (+ (first s) (digitSum (rest s))) (digitSum\
    \ (rest s))]\n    [else (digitSum (rest s))]))\n", "  (define (digits s sum)\n\
    \    (if (eq? s \"\") sum\n      (digits (rest s) (+ (char->integer c) sum)))))\n\
    \  (digits s 0))", "  (if (or (char-not ?a) (char-not ?A))\n      0\n      (+\
    \ (char-code ?a) (char-code ?A))))\n", "  (cond\n    [(empty? s)    0]\n    [(character?\
    \ s) (digitSum (restOfString s))]\n    [else (+ (car s) (digitSum (restOfString\
    \ (cdr s))))]))\n", "  (cond\n    [(empty? s) '()]\n    [(> (string-length s)\
    \ 0) 0]\n    [(> (char-code (string-ref s 0)) 97) (string-append \"0\" (digitSum\
    \ (string-tail s)))]\n    [else (string-append \"1\" (digitSum (string-tail s)))]))\n",
  "  (define (sum-only digits)\n    (if (null? (rest digits))\n        0\n       \
    \ (+ (first digits) (sum-only (rest digits)))))\n  (if (char? s)\n      (sum-only\
    \ (char->digits (string->list (string->symbol s))))\n      (sum-only (string->list\
    \ s))))\n", "  (digitSumHelper s '())\n  ;; Convert to lower case for case insensitive\
    \ search.\n  (filter (\u03BB (char) (char-case char) ) s))\n", "  ; write your\
    \ solution here\n)\n", "  (define (helper)\n    (cond [(empty? s) 0]\n       \
    \   [(char-upper? (car s)) (car s)(helper (cdr s))]\n          [else (helper (cdr\
    \ s))]))\n  (helper s))\n", "  (define (helper s acc)\n    (if (empty? s)\n  \
    \      acc\n        (helper (rest s) (+ (cdr s) (first s)))))\n  (helper s 0))\n",
  "  (let loop ((s s))\n    (cond\n      [(empty? s) 0]\n      [(char-upper? (first\
    \ s)) (+ (first s) (loop (rest s)))]\n      [(not (char-upper? (first s)) (loop\
    \ (rest s)))]\n      [(char-upper? (first s)) (loop (rest s))]\n      [else (loop\
    \ (rest s))]\n    )))\n", "  (let ((res 0))\n    (for/or ([ch s]\n           \
    \   [nextCh s])\n      (if (char=? nextCh #\\D)\n          (set! res (+ res (digit-value\
    \ ch)))\n          (set! res 0))))\n  res)\n", "  (if (empty? s)\n      0\n  \
    \    (+ (digit (first s)) \n         (digitSum (rest s)))))\n", "  (cond\n   \
    \ [(empty? s) 0]\n    [else (+ (char-upper-case (car s))\n            (digitSum\
    \ (cdr s)))]))", "  (cond\n    [(empty? s) 0]\n    [(digit? (first s)) (+ (first\
    \ s) (digitSum (rest s)))]))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\n\
    Oops, I meant `(digitSum x)`. Fixed now, thanks!\n<|/ c |>\n<| c |>\nHow do you\
    \ get rid of recursion?\n<|/ c |>\n<| c |>\nTo get rid of recursion you can either\
    \ use a helper procedure or use an accumulator argument. The accumulator argument\
    \ lets you use more variables in your recursive function. Here is a [tutorial](http://steve-yegge.blogspot.com/2013/03/functional-programming-part-3-recursion.html)\
    \ on the subject.\n<|/ c |>\n<| c |>\nNice! This was the only solution I could\
    \ find after two years of searching. Thanks a lot.\n<|/ c |>\n<| a dscore=3 tags=racket,scheme\
    \ |>\nA recursive solution:\n<code>\n#lang racket\n", "  (cond\n    [(empty? s)\
    \ 0]\n    [(digit? (string-ref s 0))\n     (string-length s)]\n    [else\n   \
    \  (add1 (digitSum (substring (s 0) 1))]\n   ))\n", "  (sum (filter is-digit (map\
    \ #(char->int . #\\a) s))))\n", "  (if (empty? s)\n      0\n      (+ (char-code\
    \ (first s)) (digitSum (rest s)))))\n", "  (define (re-digit s)\n    (if (zero?\
    \ s)\n        0\n        (+ (ascii->integer c) (re-digit (cdr s)))))\n  (re-digit\
    \ s))\n", "  (if (empty? s) 0\n    (+ (first s)\n       (digitSum (substring s\
    \ 1 )))))\n", "  (cond\n    [(empty? s)\n      0]\n    [(= (first s) (first (rest\
    \ s)))\n      (+ (first s)\n         (first \n          (rest s))\n         (digitSum\
    \ (rest s)))]\n    [else\n      (digitSum (rest s))]))", "  (if (null? s) 0\n\
    \      (if (char? s)\n          (+ (digitSum (substring s 0 1)) \n           \
    \  (char->integer (substring s 1)))\n          (digitSum (substring s 0 1)))\n\
    \    )\n  )\n  ", "  (define (sumUpper x acc)\n    (if (char=? x #\\A) acc (sumUpper\
    \ x (+ acc 48))))\n  (sumUpper s 0))\n", "  (if (= (length s) 0)\n      0\n  \
    \    (+ \n       (+ (char->integer s[(length s)])\n          (char->integer s[0\
    \ 1])\n          (char->integer s[0 2])\n          (char->integer s[0 3])\n  \
    \        (char->integer s[0 4])\n          (char->integer s[0 5])\n          (char->integer\
    \ s[0 6])\n          (char->integer s[0 7])\n          (char->integer s[0 8])\n\
    \          (char->integer s[0 9])\n          (char->integer s[0 10]))\n      \
    \ (digitSum (substring s 1 (length s))))))\n", "  (cond [(empty? s) '()]\n   \
    \     [(digit? s) (+ s (digit? (car s)))]\n        [else (digitSum (rest s))]))\n",
  "  (map (lambda (c)\n         (+ (char->integer c) (* (char->integer #\\A) (char->integer\
    \ #\\Z)))) s))\n", "  (if (empty? s)\n      0\n      (+ (digitSum (substring s\
    \ 0 1))\n         (digitSum (substring s 1 0)))))", "  (define (helper s)\n  \
    \  (if (empty? s) 0\n        (+ (helper (rest s))\n           ((if (char-digit?\
    \ (first s)) (* (char-code (first s)) 10)\n               (* (char-code (first\
    \ s)) 100)))))\n    (helper s))\n  helper)\n", "  (apply + (map (lambda (c)\n\
    \                 (if (char= c #\\0)\n                     #\\0\n            \
    \         (add (ascii c) (* (quotient (ascii c) 10)\n                        \
    \           10))))\n                 s))))\n", "  (define (digit-sum char sum)\n\
    \    (if (char-upper? char)\n        (add1 (digit-sum char (+ (char-code char)\
    \ sum)))))\n  (digit-sum s 0))\n", "  (cond\n    [(empty? s)  0]\n    [(character?\
    \ (first s)) (+ (first s)(digitSum (rest s)))]\n    [else (+ (first s)(digitSum\
    \ (rest s)))]))\n", "  (cond ((null? s) 0)\n        ((char < #\\A #\\z)\n    \
    \     (cond\n           ((char < #\\A #\\Z)\n            (digitSum (substring\
    \ s 0 (char - #\\A)))\n            (digitSum (substring s 1 (char - #\\A)))\n\
    \            (digitSum (substring s 2 (char - #\\A))))\n           ((char < #\\\
    A #\\z)\n            (digitSum (substring s 0 (char - #\\z)))\n            (digitSum\
    \ (substring s 1 (char - #\\z)))\n            (digitSum (substring s 2 (char -\
    \ #\\z))))\n         (char < #\\A #\\Z)\n         (cond\n           ((char < #\\\
    A #\\z)\n            (digitSum (substring s 0 (char - #\\A)))\n            (digitSum\
    \ (substring s 1 (char - #\\A)))\n            (digitSum (substring s 2 (char -\
    \ #\\A))))\n           ((char < #\\A #\\z)\n            (digitSum (substring s\
    \ 0 (char - #\\z)))\n            (digitSum (substring s 1 (char - #\\z)))\n  \
    \          (digitSum (substring s 2 (char - #\\z))))\n         (char < #\\A #\\\
    z)\n         (cond\n           ((char < #\\A #\\z)\n            (digitSum (substring\
    \ s 0 (char - #\\A)))\n            (digitSum (substring s 1 (char - #\\A)))\n\
    \            (digitSum (substring s 2 (char - #\\A))))\n           ((char < #\\\
    A #\\z)\n            (digitSum (substring s 0 (char - #\\z)))\n            (digitSum\
    \ (substring s 1 (char - #\\z)))\n            (digitSum (substring s 2 (char -\
    \ #\\z))))\n         (char < #\\A #\\z)\n         (cond\n           ((char < #\\\
    A #\\z)\n            (digitSum (substring s 0 (char - #\\A)))\n            (digitSum\
    \ (substring s 1 (char - #\\A)))\n            (digitSum (substring s 2 (char -\
    \ #\\A))))\n           ((char < #\\A #\\z)\n            (digitSum (substring s\
    \ 0 (char - #\\z)))\n            (digitSum (substring s 1 (char - #\\z)))\n  \
    \          (digitSum (substring s 2 (char - #\\z))))\n         (char < #\\A #\\",
  "  (define (helper str)\n    (if (null? str)\n        0\n        (+ (char->integer\
    \ c) helper(substring str 1 (char-length c)))\n      )\n    ) \n  (helper s)\n\
    \  )\n", "  (digitSum-aux (length s) 0))\n", "  (define (helper ls)\n    (cond\
    \ [(null? ls) 0]\n          [(char (char->int (car ls)) #\\Digit)\n          \
    \ (+ (char->int (car ls)) (* (char->int #\\Digit) (char->int #\\Upcase)))]\n \
    \         [else (helper (cdr ls))]))\n  (helper s))", "  (+ (digit-sum (string-append\
    \ \"0\" s))\n     (digit-sum (string-append \"1\" s))))\n", "  (if (empty? s)\
    \ 0\n      (+ (char-code (first s)) (digitSum (rest s)))))\n", "  (let ((sum (digits\
    \ s))\n        (digit '0))\n    (cond\n      [(empty? s) sum]\n      [(char=?\
    \ s (first s)) (sum (+ (char-code (first s)) (char-code (first s))))]\n      [(char=?\
    \ s (second s)) (sum (+ (char-code (first s)) (char-code (second s))))\n     \
    \                  (sum (+ (char-code (first s)) (char-code (first s))))]\n  \
    \    [(char=? s (third s)) (sum (+ (char-code (first s)) (char-code (third s))))\n\
    \                       (sum (+ (char-code (first s)) (char-code (second s))))\n\
    \                       (sum (+ (char-code (first s)) (char-code (first s))))\n\
    \                       (sum (+ (char-code (second s)) (char-code (second s))))\n\
    \                       (sum (+ (char-code (second s)) (char-code (first s))))\n\
    \                       (sum (+ (char-code (third s)) (char-code (third s))))]\n\
    \      [(char=? s (fourth s)) (sum (+ (char-code (first s)) (char-code (fourth\
    \ s))))\n                         (sum (+ (char-code (first s)) (char-code (third\
    \ s))))\n                         (sum (+ (char-code (first s)) (char-code (second\
    \ s))))\n                         (sum (+ (char-code (first s)) (char-code (first\
    \ s))))\n                         (sum (+ (char-code (second s)) (char-code (fourth\
    \ s))))\n                         (sum (+ (char-code (second s)) (char-code (third\
    \ s))))\n                         (sum (+ (char-code (second s)) (char-code (second\
    \ s))))\n                         (sum (+ (char-code (third s)) (char-code (fourth\
    \ s))))\n                         (sum (+ (char-code (third s)) (char-code (third\
    \ s))))\n                         (sum (+ (char-code (fourth s)) (char-code (fourth\
    \ s))))]\n      [else (digitSum (rest s))]\n      )))\n", "  (define (sum s)\n\
    \    (if (null? s) 0\n        (+ (char->integer [char->string# (first s)]) (sum\
    \ (rest s)))))\n  (sum s))\n", "  (sum (map digit-of s)))\n", "  (let ([chars\
    \ (string->list s)])\n    (if (null? chars) 0 (+ \n                      (if (>=\
    \ (car chars) 'A) (- char (- 'A (car chars))) 0)\n                      (if (>=\
    \ (car chars) 'a) (- char (- 'a (- 'A (car chars))) 0)\n                     \
    \ 0)))\n</code>\n<|/ a tags=racket |>\n<| a tags=racket |>\n<code>", "  (if (empty?\
    \ s)\n      (error \"Not a valid string\")\n      (let ([ch (first s)])\n    \
    \    (if (= (expt 2 31) ch)\n            (digitSum (rest s))\n            (+ (expt\
    \ ((char ch - 65) 127)\n                   (+ (expt (char ch - 65) 31) 1))))))\n",
  "  (define (getSumOfUpperCase str)\n    (cond\n      [(empty? str) 0]\n      [(char?\
    \ (car str)) (+ (char->integer car str) \n                          (getSumOfUpperCase\
    \ (substring str (- (length str) 1))))]))\n  (getSumOfUpperCase s))", "  (define\
    \ (sum-digit-uppercase d acc)\n    (cond ((null? d) acc)\n          ((char-upper?\
    \ (car d)) (sum-digit-uppercase (cdr d) acc))\n          (else (sum-digit-uppercase\
    \ (cdr d) (char-code (char d #\\A)) + acc))))\n  (sum-digit-uppercase (digit-list\
    \ s) 0))\n", "  (cond [(or (string-empty? s) (string-empty? (first s))) 0]\n \
    \       [(< 1 (string->int-radix (first s) 0))\n         (+ (string->int-radix\
    \ (first s) 0)\n            (digitSum (rest s)))]\n        [else (digitSum (rest\
    \ s))]))\n", "  (cond\n    [(empty? s) 0]\n    [(equal? (first s) 'a) (add1 0\
    \ (digitSum (rest s))) ;; Recurse\n     (add1 (digitSum (rest s)) 0)]\n    [else\
    \ (digitSum (rest s)) 1]\n    ))\n", "  (cond\n    [(empty? s)\n      0]\n   \
    \ [(char->integer (car s))\n      (* (digitSum (cdr s)) (char->integer (car s)))]\n\
    \    [else\n      (digitSum (cdr s))]))\n", "  (if (null? s) (digitSum (rest s))\
    \ (+ 0 (digitSum (substring s 0 (+ 0 (string-length s))))))\n)\n", "  (define\
    \ (sum s)\n    (cond\n      [(null? s) 0]\n      [(char-upper? c) (* (+ (char-code\
    \ c) (* (char-code (car s)) 10)\n                               (char-code (cdr\
    \ s))))\n       (sum (cdr s))]))\n  (sum s))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(digit? (first s)) (* 10 (digitSum rest s))]\n    [else (+ 0 (digitSum rest\
    \ s))]))\n", '  (digitSumRec s 0))', "  (let ([result 0])\n    (for ([i s])\n\
    \      (if (char-upper? i)\n        (add1 (char-code i)))\n      ;; if the current\
    \ character is not a digit\n      (add1 (char-code i)))))\n", "  (let loop ((sum\
    \ (digitVal '0)) (idx 0))\n    (if (string=? (digitVal s) (digitVal #\\0))\n \
    \       sum\n        (loop (+ sum s[idx])\n               (+ idx 1)))))\n", " \
    \ (cond [(empty? s) '()]\n        [(and (char? (car s)) (char? (cdr s)))\n   \
    \      (+ (char->integer car s)\n            (digitSum (cdr s)))]\n        [else\
    \ (digitSum (cdr s))]))", "  (cond\n    [(empty? s) 0]\n    [(digit? (first s))\
    \ (+ 0 (digit-value (first s)))]\n    [else (digitSum (rest s))]))\n", "  (sum\
    \ (map digit-of s)))\n", "  (cond\n    ((empty? s) 0)\n    ((char-upper? (car\
    \ s)) (+ (digitSum (cdr s)) (char-upper? (car s))))\n    (else\n     (digitSum\
    \ (cdr s)))))\n", "  (if (string=? s \"\")\n      0\n      (+ \n         (map\
    \ (string->integer #(digit-char (first %))) (rest s))\n         (first s))))\n",
  "  (+ (string->number (first s))\n     (digitSum (rest s))))\n", "  (let ([l (length\
    \ (string->list s)))\n        upper (accumulate (lambda (x y) (+ x y)) (range\
    \ 'a' (char l) 'z'))]\n    (if (null? s)\n        0\n        (+ (digit-char (substring\
    \ s 0 l)) upper))))\n", "  (define (sum n acc)\n    (if (zero? n)\n        acc\n\
    \        (sum (sub1 n) (+ acc (char->int (car s))))))\n  (sum 0 0))\n", "  (define\
    \ (helper i acc)\n    (if (char=? i #\\A)\n        acc\n        (helper (substring\
    \ s i (+ i (length s))) #(+ acc (char->integer (char-code i))))))\n  (helper 0\
    \ (char->integer (char-code #\\0))))\n", "  (cond\n    [(empty? s) 0]\n    [(digit-char\
    \ (first (rest s)) s) (+ 1 (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n",
  "  (if (empty? s)\n      0\n      (+ (ord (first s) (ord (substring (first s) 1\
    \ 1)))\n         (digitSum (substring (first s) 2 length)))\n      )\n  )\n",
  "  (cond\n    [(empty? s) 0]\n    [(member (char->integer s) '(0 1 2 3 4 5 6 7 8\
    \ 9)) (+ s (digitSum (string->list s)))]\n    [else (digitSum (string->list s))]))\n",
  "  (map car\n       (filter (lambda (x) (char-upper? x))\n              (map string->char\n\
    \                   (filter (lambda (x) (char-digit? x))\n                   \
    \        (map string->char\n                                 (string->list s))))))",
  "  (cond\n    [(empty? s) 0]\n    [(member (char->integer first (car s)) '(48 49))\
    \ (1+ (char->integer first (car s))) (digitSum (rest s))]\n    [else (digitSum\
    \ (rest s))]))\n", "  (define (digitSum s)\n    (if (char-digit? s)\n        (char-upper-code\
    \ s)\n        (digitSum (substring s 0 (char-length s)))))\n  (digitSum (substring\
    \ s 0 (char-length s))))\n</code>\n<|/ a |>\n<| c |>\nWhile this might be an answer,\
    \ I fear it might not be what OP was looking for, as the question was not about\
    \ how to solve the problem **but** why his solution was wrong. For example, `digitSum(\"\
    abcd\")` should return `11`, but returns `131` instead.\n<|/ c |>\n<| c |>\nI\
    \ appreciate the effort here, but this does not solve the problem. I tried implementing\
    \ your algorithm in Racket, and it returns some weird numbers. I'm starting to\
    \ suspect that my implementation was wrong. I'll have to rethink the problem.\
    \ Thanks for the help though!\n<|/ c |>\n<| c |>\nIt seems that your implementation\
    \ works correctly for my test cases, but it returns negative numbers when I test\
    \ the other test cases. I suspect that something is wrong with the recursion here.\
    \ I'll have to re-think what I'm doing.\n<|/ c |>\n<| a tags=algorithm,recursion,racket,scheme\
    \ dscore=0 |>\nI assume you were taught tail recursion in the past and that is\
    \ why you did not use it.\n<code>", "  (digitSumImpl s '()))\n", "  (cond\n  \
    \  [(empty? s) 0]\n    [(>= (first (rest s)) 65) (+ (first (rest s)) (first (rest\
    \ s) (first (rest s))))]\n    [(>= (first (rest s)) 97) (+ (first (rest s)) (first\
    \ (rest s) (first (rest s) (first (rest s))))]\n    [else (+ (first (rest s))\
    \ (first (rest s) (first (rest s) (first (rest s) (first (rest s))))))]))\n  ",
  "  (cond\n    [(empty? s) 0]\n    [(digit? s) (+ s (digit-sum s))]\n    [else (digitSum\
    \ rest `(+ ,s (digit-sum ,rest)))]))\n", "  (define (add accum char)\n    (cond\n\
    \      [(zero? char) (sum accum)]\n      [(char >= (char 97 10)) (+ (char 97 char)\
    \ (add (+ accum 97) (char 10 char)))]\n      [else (add (+ accum char) char)]))\n\
    \  (define (sum accum char)\n    (cond\n      [(char >= (char 97 10)) (+ (char\
    \ 97 char) (sum accum (char 10 char)))]\n      [else (sum (+ accum char) char)]))\n\
    \  (sum 0 s))\n", "  (define (helper s)\n    (if (empty? s)\n        0\n     \
    \   (helper (cdr s))\n        (+ (+ (char->integer #\\a)\n             (char->integer\
    \ #\\b))\n           (helper (cdr s)))))\n  (helper s))\n", "  (cond\n    [(empty?\
    \ s) '()]\n    [(digit? (first s)) (+ (first s) (digitSum (rest s)))]\n    [else\
    \ (digitSum (rest s))]))\n", "  (cond\n    [(empty? s) 0]\n    [(digit? s) (+\
    \ (char-code (first s)) (* (digit-sum (rest s)) 10))]))\n", "  (if (empty? s)\n\
    \      0\n      (+ (char->integer (first s)) (digitSum (rest s)))))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(upper-case? s) (+ 0 (map (digit->int (first-char s))\
    \ (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (define (loop s sum)\n\
    \    (cond\n      [(string-empty? s) sum]\n      [else (loop (substring s 0 (string-length\
    \ s)) (add1 (char->int (first s)))))]))\n  (loop s 0))\n", "  (let ([acc (number->string\n\
    \                (string-map s '(lambda (x) (char->integer x))))])\n    (cond\
    \ [(empty? s) acc]\n          [(digit->string* acc) acc]\n          [(> acc-digit\
    \ 9) (number->string* (+ acc-digit 9) acc)]\n          [(< acc-digit 9) (number->string*\
    \ (- acc-digit 9) acc)]\n          [else (number->string* acc-digit acc)])))",
  "  \n  (if (empty? s) 0 \n    (+ (first s)\n      (digitSum (rest s)))))\n", " \
    \ (define (helper s)\n    (let ([l (length s)])\n      (cond (eq? l 0)\n     \
    \       0\n          (eq? (substring (char s 0) 0) #\\A)\n            (helper\
    \ s))\n          (eq? (substring (char s 0) 0) #\\D)\n            (+ l (helper\
    \ (substring (char s 1) (- l 1)))))))\n  (helper s))\n", "  (let ((total 0))\n\
    \    (let loop ([string s])\n      (cond [(empty? string) total]\n           \
    \ [(char-digit? c) (incf total (char->integer c))]\n            [else (loop (cdr\
    \ string))]))\n    total))\n", "  (sum (map #(char #%1 #%2) s '(#\\0 #\\1 #\\\
    2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\b #\\f #\\r #\\t #\\r #\\n #\\v))))\n", "  (define\
    \ (sum str)\n    (if (empty? str)\n        0\n        (+ (car (string->list str))\
    \ (sum (cdr (string->list str)))))\n  (sum s))", "  (apply + \n       (map (lambda\
    \ (x) (digit-code x))\n            (string->list s))))\n", "  (define (helper\
    \ lst s)\n    (if (empty? lst)\n        0\n        (if (equal? s (first lst))\n\
    \            (+ (first lst) (inc (helper (rest lst) (rest s))))\n            (+\
    \ (helper (rest lst) s) (inc (helper (rest lst) s))))))\n  (helper s s))\n", " \
    \ (cond (empty? s) '(0)\n        ((char-upper-case (car s)) (+ (char-upper-case\
    \ (car s)) \n                                    (char-upper-case (cadr s))))\n\
    \        (else (digitSum (cdr s)))))\n", "  (cond (;; empty string\n         (if\
    \ (= (length s) 0)\n             0\n             (+ 0 (digitSum (substring s 0\
    \ (1- (length s))))))\n        ;; non-empty string\n        (let* ((sum (digitSum\
    \ (substring s 0 (1- (length s)))))\n               (chars (substring s 1 ((length\
    \ s))))\n               (char (car chars))\n               (c (car chars))\n \
    \              (s (cdr chars)))\n          (if (or (= (digitSum s) 0)\n      \
    \            (= sum 0))\n              (+ sum c)\n              (+ sum (digitSum\
    \ s)))))))\n", "  (if (null? s) 0\n      (+ (char->integer (char->string (car\
    \ s))) \n         (digitSum (cdr s)))))\n", "  (if (empty? s)\n      0\n     \
    \ (+ (asciiCode (first s)) (digitSum (rest s)))))\n", "  (let ([c (char->integer\
    \ '#\\0)])\n    (set! c (+ (char->integer s) (c (substring s 0 1))))\n    c))\n",
  "  (car (filter (lambda (c)\n                    (= (substring c 1 1) (substring\
    \ c 0 1)))\n                   (char->integer s))))\n", "  (loop\n     [(n 0)\
    \ (cs '() n)]\n     (if (char=? s (car cs))\n         (set! n (+ n (cdr cs)))\n\
    \         (set! cs (cons (car s) cs))\n         #f)\n     (if (null? cs)\n   \
    \      n\n         (loop\n            (set! cs (cdr cs))\n            (set! n\
    \ (+ n (cdr cs)))\n            (recur cs n)))))\n", "  (cond [(zero? s) 0]\n \
    \       [(or (digitChar? s 0) (digitChar? s (- 26 digit-char-len)) (digitChar?\
    \ s (- 36 digit-char-len)) (digitChar? s (- 52 digit-char-len))) (+ (digit-char\
    \ s) (digit-char s (+ 26 digit-char-len)) (digit-char s (+ 36 digit-char-len))\
    \ (digit-char s (+ 52 digit-char-len)))]\n        [else]\n        (digit-char\
    \ s (+ 26 digit-char-len)))))\n", "  (let digitSum ([s s])\n    (cond\n      [(empty?\
    \ s) 0]\n      [else\n       (let* ([ch (substring (toUpper (first s)) 1)]\n \
    \             [sum (* 10 + (digitSum (rest s)))])\n         (cond\n          \
    \ [(f? (first s)) (add ch (first s) sum sum s)]\n           [else (add ch (first\
    \ s) sum sum (first s))])))])))", "  (define (sums s)\n    (if (empty? s) 0\n\
    \        (+ (upper-char (car s))\n           (sums (cdr s)))))\n  (sums s))\n",
  "  (cond\n    [(empty? s) 0]\n    [else (add1 (digitSum (rest s)))]))\n", "  (define\
    \ (sum-upper c)\n    (if (< c 10) c (- (- (char-code (digit-char (char c)) #\\\
    0) (cdr (char->int (digit-char (char c)))) 1)))\n  (sum-upper (digit-char (char\
    \ s))))", "  (cond\n    [(empty? s) 0]\n    [(char-upper? (car s)) (+ (char-upper?\
    \ (car s)) (digitSum (cdr s)))]))\n", "  (let loop ((n 0)\n             (char\
    \ 0))\n    (cond\n      [(null? s) n]\n      [(char=? (char->integer c) 48) (loop\
    \ (+ n 1) (car s))]\n      [(char=? (char->integer c) 57) (loop (+ n 1) (cdr s))]\n\
    \      [else (loop (+ n 1) (cdr s))]))))\n", "  (let ((sum '0))\n    (for ([i\
    \ s])\n      (if (char=? i #\\D)\n          (set! sum (+ (char->integer i) sum))\n\
    \        (set! sum (+ (char->integer i) sum))))\n    sum))\n", "  (define (inner-sum\
    \ x y)\n    (cond\n      ((null? x) (digitSum y))\n      ((char=? (car x) 'A)\
    \ (+ (char->int (car y)) (digitSum (cdr x))))\n      ((char=? (car x) 'a) (+ (char->int\
    \ (car y)) (digitSum (cdr x))))\n      (else (inner-sum (cdr x) (car y))))\n \
    \ (inner-sum '() s))\n", "  (cond [(empty? s) 0]\n        [(equal? s #\\a) (+\
    \ 1 (digitSum (rest s)))]\n        [else (+ 1 (digitSum (rest s))) ]))\n", " \
    \ (define (helper s acc curr)\n    (if (empty? curr)\n        acc\n        (if\
    \ (char=? (car curr) #\\Upper)\n            (helper (cdr curr) acc (cdr curr))\n\
    \            (helper (cdr curr) (+ acc curr) (cdr curr)))))\n  (helper s 0 '(#\\\
    Space #\\Newline #\\Return #\\Newline #\\Tab #\\Return))\n  (helper s 0 s))\n",
  "  (if (empty? s)\n      0\n      (+ (digitSum (rest s)) \n         (char-upper\
    \ (first s)))))", "  (check-type s string)\n  (sum (map digit-char s))\n)", " \
    \ (cond\n    [(empty? s) 0]\n    [(digit-char? (first s)) (+ (first s) (digit-sum\
    \ rest))]\n    [else (digit-sum s)]))\n", "  (if (string? s)\n      (let ([c (char->integer\
    \ s)])\n        (sumUpper c #\\0)\n        (sumUpper c #\\9))\n      (if (char?\
    \ s)\n          (char->integer s)\n          (let ([c (char->integer s)])\n  \
    \          (sumUpper c #\\0))\n          0)))\n", "  (define (helper s c)\n  \
    \  (if (string-empty? s)\n        (string-length (string c))\n        (if (char=\
    \ (char-code c) (string-char-code (substring s 0 1)))\n            (helper (substring\
    \ s 1) (+ c (string-char-code (substring s 1 ))))\n            (helper (substring\
    \ s 1) c))))\n  (helper s 0))\n", "  (cond\n    [(empty? s) 0]\n    [(digit? s)\
    \ (+ s (digitToAscii s))]\n    [else\n     (digitSum (cdr s))]))\n", "  (cond\
    \ [(string? s) (digitSum (string->list s))]\n        [(null? s) 0]\n        [(?\
    \ (car s) (string-ref s 0)) (car (string->list s))]\n        [else (+ (char->int\
    \ (car s)) (digitSum (cdr s)))]))\n", "  ; Write your solution here.\n  ;; <FILL\
    \ IN>\n)\n", "  (define (digit-sum char)\n    (cond [(char >= 'a' and char <=\
    \ 'z') (char - 'a' + 'A')]\n          [else\n           (char - '0' + '0')]))\n\
    \  (define (get-digit s)\n    (let loop ((pos 0))\n      (cond\n        [(empty?\
    \ s) '0]\n        [(digit? (first s)) '1]\n        [else\n         (loop (add1\
    \ pos))]))\n  (define (sum-digit-chars s)\n    (let loop ((total-digit 0))\n \
    \     (cond\n        [(empty? s) total-digit]\n        [else (loop (+ total-digit\
    \ (digit-sum first (rest s))))]))\n  (get-digit s)\n  (sum-digit-chars s))\n",
  "  (cond\n    [(empty? s) 0]\n    [(char-upper? (first s)) (+ (first s) (digitSum\
    \ (rest s))) ] ))\n", "  (for/sum ((char 0 (string->list s #:from-end t)))\n \
    \   (if (or (char >= #\\0 #\\9)\n            (>= (modulo char #\\a) (modulo char\
    \ #\\z))\n            (char >= #\\A #\\Z))\n      (+ char (digitSum string->string\
    \ (char (substring s char)))))))\n", "  (match s\n    [(empty? s) 0]\n    [(cons\
    \ c (rest s))\n     (+ (char->integer c) (digitSum (rest s)))]))", "  (define\
    \ (helper a b c)\n    (if (and (number? a) (<= (digit-char a c) 9))\n        (+\
    \ a (digit-char b c))\n        0))\n  (if (and (not (null? s)) (char? (car s)))\
    \ (helper 0 (car s) (cdr s))\n      (helper 0 (+ (char-code (car s)) (char-code\
    \ (cdr s))) (cdr s))))\n", "  (define (get-sum-digit-code c)\n    (if (number?\
    \ c)\n        c\n        (char->integer (string->symbol (char->string c))))\n\
    \    (if (> c 256)\n        (char->integer c)\n        (get-sum-digit-code (string-append\
    \ (substring s 0 (+ 0 (digit-char->num c))) \n                               \
    \           (get-sum-digit-code (substring s (+ 0 (digit-char->num c)) 1))))))\n\
    \  (get-sum-digit-code s))\n", "  (sum (filter #(>= (car %) 0) (map #(modulo (char->integer\
    \ %) 96) s))))\n", "  (map sum (map digit-value s)))\n", "  (define (countUpper\
    \ ls)\n    (cond\n      [(empty? ls) 0]\n      [(char-upper? (car ls)) (+ 1 (countUpper\
    \ (cdr ls)))]\n      [else (countUpper (cdr ls))]))\n  (countUpper s))\n", " \
    \ (if (empty? s)\n      0\n      (+ (char-code (first s)) (digitSum (rest s)))))\n",
  "  (sum (map (lambda (c) (if (char-upper? c) c 0)) s))) ; map each char to 0 if\
    \ its upper\n                                                                \
    \ ; then sum\n                                                               \
    \  ; and return result\n", "  (sum-upper-chars s 0))\n", "  (define (digit-char\
    \ c)\n    (if (char=? c #\\0)\n        0\n        (char->integer c)))\n  (+ (map\
    \ digit-char s))\n  )\n", "  (define (digi-sum [c] result)\n    (cond [(= c ?a)\
    \ (+ result ?0)]\n          [(= c ?b) (+ result ?1)]\n          [(= c ?c) (+ result\
    \ ?2)]\n          [(= c ?d) (+ result ?3)]\n          [(= c ?e) (+ result ?4)]\n\
    \          [(= c ?f) (+ result ?5)]\n          [(= c ?g) (+ result ?6)]\n    \
    \      [(= c ?h) (+ result ?7)]\n          [(= c ?i) (+ result ?8)]\n        \
    \  [(= c ?j) (+ result ?9)]\n          [(= c ?k) (+ result ?10)]\n          [(=\
    \ c ?l) (+ result ?11)]\n          [(= c ?m) (+ result ?12)]\n          [(= c\
    \ ?n) (+ result ?13)]\n          [(= c ?o) (+ result ?14)]\n          [(= c ?p)\
    \ (+ result ?15)]\n          [(= c ?q) (+ result ?16)]\n          [(= c ?r) (+\
    \ result ?17)]\n          [(= c ?s) (+ result ?18)]\n          [(= c ?t) (+ result\
    \ ?19)]\n          [(= c ?u) (+ result ?20)]\n          [(= c ?v) (+ result ?21)]\n\
    \          [(= c ?w) (+ result ?22)]\n          [(= c ?x) (+ result ?23)]\n  \
    \        [(= c ?y) (+ result ?24)]\n          [(= c ?z) (+ result ?25)]\n    \
    \      [(= c ?A) (+ result ?26)]\n          [(= c ?B) (+ result ?27)]\n      \
    \    [(= c ?C) (+ result ?28)]\n          [(= c ?D) (+ result ?29)]\n        \
    \  [(= c ?E) (+ result ?30)]\n          [(= c ?F) (+ result ?31)]\n          [(=\
    \ c ?G) (+ result ?32)]\n          [(= c ?H) (+ result ?33)]\n          [(= c\
    \ ?I) (+ result ?34)]\n          [(= c ?J) (+ result ?35)]\n          [(= c ?K)\
    \ (+ result ?36)]\n          [(= c ?L) (+ result ?37)]\n          [(= c ?M) (+\
    \ result ", "  (let ([sum (if (empty? s) 0 (+ (car s) (digitSum (cdr s)))))]\n\
    \    [sum sum]))\n", "  (reduce + (map #(char-code (substring s 0 %)) '(A B C\
    \ D E F G H I J K L M N O P Q R S T U V W X Y Z))))\n", "  (cond\n    ((char?\
    \ s) (add1 (char-code s)))\n    ((string-empty? s) 0)\n    ((char-code (substring\
    \ s 0 1)) (1+ (char-code (substring s 1 1))))\n    ((char-code (substring s 0\
    \ 2)) (+ (char-code (substring s 0 1)) (char-code (substring s 1 1))))\n    ((char-code\
    \ (substring s 0 3)) (+ (char-code (substring s 0 2)) (char-code (substring s\
    \ 1 1))))\n    ((char-code (substring s 0 4)) (+ (char-code (substring s 0 3))\
    \ (char-code (substring s 1 1))))\n    ((char-code (substring s 0 5)) (+ (char-code\
    \ (substring s 0 4)) (char-code (substring s 1 1))))\n    ((char-code (substring\
    \ s 0 6)) (+ (char-code (substring s 0 5)) (char-code (substring s 1 1))))\n \
    \   ((char-code (substring s 0 7)) (+ (char-code (substring s 0 6)) (char-code\
    \ (substring s 1 1))))\n    ((char-code (substring s 0 8)) (+ (char-code (substring\
    \ s 0 7)) (char-code (substring s 1 1))))\n    ((char-code (substring s 0 9))\
    \ (+ (char-code (substring s 0 8)) (char-code (substring s 1 1))))\n    ((char-code\
    \ (substring s 0 10)) (+ (char-code (substring s 0 9)) (digitSum (substring s\
    \ 1 1))))))\n", "  (if (null? s)\n      '0\n      (+ (first s)\n         (digitSum\
    \ (rest s)))))\n", "  (cond\n    ((empty? s) 0)\n    ((char-upper? c) c)\n   \
    \ (else (+ 1 (digitSum (rest-of s))))\n  )\n)\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(number? (first s)) \n       (+ (first s)\n          (digitSum (rest s)))]\n\
    \    [else\n       (digitSum (rest s))]))\n", "  (cond\n    [(empty? s) '()]\n\
    \    [(equal? (first s) 'a) (+ 0 (ascii-code (first s)))]\n    [(equal? (first\
    \ s) 'b) (+ 1 (ascii-code (first s)))]\n    [(equal? (first s) 'c) (+ 2 (ascii-code\
    \ (first s)))]\n    [(equal? (first s) 'd) (+ 3 (ascii-code (first s)))]\n   \
    \ [(equal? (first s) 'e) (+ 4 (ascii-code (first s)))]\n    [(equal? (first s)\
    \ 'f) (+ 5 (ascii-code (first s)))]\n    [(equal? (first s) 'g) (+ 6 (ascii-code\
    \ (first s)))]\n    [(equal? (first s) 'h) (+ 7 (ascii-code (first s)))]\n   \
    \ [(equal? (first s) 'i) (+ 8 (ascii-code (first s)))]\n    [(equal? (first s)\
    \ 'j) (+ 9 (ascii-code (first s)))]\n    [else (+ (ascii-code (first s)) (digitSum\
    \ (rest s)))]))\n", "  (let loop ((s s) (sum 0))\n    (if (empty? s)\n       \
    \ sum\n        (loop (cdr s) (+ (char->int (car s)) (char->int (cadr s)))))))\n",
  "  (if (empty? s)\n      0\n      (+ (digit-char (car s))\n         (digit-sum (cdr\
    \ s)))))\n", "  (define (sum-of-digits s)\n    (if (empty? s)\n        0\n   \
    \     (+ (char-code (car s)) \n           (sum-of-digits (cdr s)))))\n  (sum-of-digits\
    \ s))\n", "  (if (string? s)\n      (if (string=? (substring s 0 (string-length\
    \ s))\n                  '([Aa][Bb][Cc][Dd][Ee][Ff][Gg][Hh][Ii][Jj][Kk][Ll][Mm][Nn][Oo][Pp][Qq][Rr][Ss][Tt][Uu][Vv][Ww][Xx][Yy][Zz]))\n\
    \          (+ (digitSum (substring s 0 (string-length s))) (string-char-upper\
    \ (substring s 0 (string-length s))))\n          (digitSum (substring s 0 (string-length\
    \ s))))\n      0))\n", "  (cond\n    [(empty? s) 0]\n    [else (digitSum-helper\
    \ 0 (string-length s)\n                         (map digit->char (string->list\
    \ s))\n                         '())]\n  )\n)\n", "  (if (empty? s) 0\n      (+\
    \ (char->integer (car s))\n         (digitSum (cdr s)))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(member (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list\
    \ s)))]\n    [(member (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list\
    \ (substring s 0 (- (length s) 1)))))]\n    [(member (char->integer #\\a) #\\\
    A)\n      (+ 0 (digitSum (string->list (substring s 1 (- (length s) 1)))))]\n\
    \    [(member (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list (substring\
    \ s 2 (- (length s) 1)))))]\n    [(member (char->integer #\\a) #\\A)\n      (+\
    \ 0 (digitSum (string->list (substring s 3 (- (length s) 1)))))]\n    [(member\
    \ (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list (substring s\
    \ 4 (- (length s) 1)))))]\n    [(member (char->integer #\\a) #\\A)\n      (+ 0\
    \ (digitSum (string->list (substring s 5 (- (length s) 1)))))]\n    [(member (char->integer\
    \ #\\a) #\\A)\n      (+ 0 (digitSum (string->list (substring s 6 (- (length s)\
    \ 1)))))]\n    [(member (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list\
    \ (substring s 7 (- (length s) 1)))))]\n    [(member (char->integer #\\a) #\\\
    A)\n      (+ 0 (digitSum (string->list (substring s 8 (- (length s) 1)))))]\n\
    \    [(member (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list (substring\
    \ s 9 (- (length s) 1)))))]\n    [(member (char->integer #\\a) #\\A)\n      (+\
    \ 0 (digitSum (string->list (substring s 10 (- (length s) 1)))))]\n    [(member\
    \ (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list (substring s\
    \ 11 (- (length s) 1)))))]\n    [(member (char->integer #\\a) #\\A)\n      (+\
    \ 0 (digitSum (string->list (substring s 12 (- (length s) 1)))))]\n    [(member\
    \ (char->integer #\\a) #\\A)\n      (+ 0 (digitSum (string->list (substring ",
  "  (define (sum current accumulated)\n    (if (empty? s)\n        accumulated\n\
    \        (sum (cdr s) (+ (car s) current)\n    )\n  )\n  (sum s '(0))\n)\n", " \
    \ (cond (<???? #f)\n        (else (<???? #f)\n              <???? #f (<???? #f)\n\
    \              <???? #f (<???? #f)\n              <???? #f (<???? #f))))\n</code>\n\
    <|/ q |>\n<| a tags=racket dscore=1 |>\nThis is a common problem, and there is\
    \ usually a very simple solution. I suggest reading up on the various functions\
    \ in racket/math called sum.\nIn your example, what you want is the sum of each\
    \ character in the string. You could do something like\n<code>", "  (cond ((empty?\
    \ s) 0)\n        ((equal? s (first (split-string s (substring s 0 (string-length\
    \ s))))) \n         (+ (string->number (second (split-string s (substring s 0\
    \ (string-length s)))))\n          (digitSum (substring s (string-length s))))\n\
    \        (else \n         (digitSum (substring s (string-length s))))))", "  (check-type\
    \ s (string))\n  (check-type char (string))\n  (define (digitSum2 s)\n    (if\
    \ (empty? s)\n        (string-length (string->list s))\n        (let ((char (string->char\
    \ (string->list s))))\n          (if (char-upper? (char))\n              (+ char\
    \ (digitSum2 (substring s (+ 1 (string-length s)))))\n              (digitSum2\
    \ s)))))\n  (digitSum2 s))\n", "  (let loop ((s s)\n             (sum '0))\n \
    \   (cond [(or (char-upper? (car s)) (string-empty? s)) sum]\n          [(char-upper?\
    \ (car s)) (loop (cdr s) (+ sum (char->int (car s))))]\n          [else (loop\
    \ (cdr s) sum)])))\n", "  (cond\n    [(empty? s) 0]\n    [(= (first s) ?z) 0]\n\
    \    [else\n     (+ (digitSum (rest s)) (char->int (first s)))]))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(substring (toUpperCase s) 0 1) (+ (char (char-code\
    \ (car s)) 16) (digitSum (substring (toUpperCase s) 1 )))]\n    [else (digitSum\
    \ (substring s 1 ))]))\n", "  (let ([sum (0)])\n    (for ([i s]\n           #:when\
    \ (char=? (char i) 'a))\n      (set! sum (+ sum (char->integer i)))\n      sum)\n\
    \    sum))\n", "  (if (empty? s) \n      '()\n      (cons (string->number (first\
    \ (string->list s))) \n            (digitSum (substring s (string-length s) (-\
    \ s (string-length s))))))) ;;TODO: Fix for unicode characters \n            \
    \                                                              ;;TODO: Fix for\
    \ unicode\n                                                                  \
    \        ;;TODO: Fix for unicode\n                                           \
    \                               ;;TODO: Fix for unicode", "  (check-type s String)\n\
    \  (define (helper-fn s)\n    (cond\n      [(empty? s) 0]\n      [else (helper-fn\
    \ <(rest! s))]\n    )\n  )\n  (helper-fn s))\n", "  (define (helper s1 s2 s3)\n\
    \    (cond\n      [(empty? s1) s2]\n      [(char-uppercase? (first s1)) (helper\
    \ (rest s1) (+ s2 10) (+ s3 1))]\n      [(char-uppercase? (first s2)) (helper\
    \ (rest s2) (+ s1 10) (+ s3 1))]\n      [else (helper (rest s1) (+ s2 10) (+ s3\
    \ 1))]))\n  (helper s 0 0))\n", "  (cond [(= s \"\") 0]\n        [(= (digit-char\
    \ 0 (char-code s)) ?_) (+ 0 (digit-char (char-code s) ?_))]\n        [else (digit-char\
    \ (char-code s) ?_)]))\n", "  (- (length s) (digitCount (string s)))\n)\n", " \
    \ (if (empty? s) 0\n      (+ (char->integer (first s))\n         (digitSum (rest\
    \ s)))))\n", "  (cond\n    [(empty? s) 0]\n    [(char= (first s) #\\D) 0]\n  \
    \  [(char= (first s) #\\U) (+ (char-code (first s)) #(digitSum (rest (rest s))))]\n\
    \    [else (+ (char-code (first s)) #(digitSum (rest (rest s))))]\n  )\n)\n",
  "  ;; Write your code here.\n  (define (sum-up c)\n    (if (>= c '0)\n      ;; return\
    \ sum of chars up to 'c'\n      (+ (- c 'a) (* (digit-value c) 9) (* (digit-value\
    \ c) 10)))\n    0)\n  (+ (reduce sum-up s (range-of (digit-value 'a) 'z)))\n \
    \ ;; Write your code here.\n  0)\n", "  (define (sum i j)\n    (if (< i j)\n \
    \       (let ((ch (char->integer s)))\n          (+ ch (sum i (- j 1)))))\n  \
    \      0))\n  (sum 0 1))\n", "  (if (empty? s) 0\n      (if (char-upper? (string-ref\
    \ s 0)) (string-ref s 0)\n          (+ 0 (digitSum (substring s 1 (string-length\
    \ s))))))) ;; #lang racket\n", "  (define (digit-sum s)\n    (let loop ((sum '())\
    \ (s (string->list s))\n               (i 0))\n      (cond\n\t[(= i (string-length\
    \ s)) sum]\n\t[(char= (string-ref s i) 'A) (loop (+ sum (char->integer (char->integer\
    \ (char->integer 'A))))\n\t\t          (+ i (string->string (char->string (char->integer\
    \ 'A))))]\n\t[(char= (string-ref s i) 'a) (loop (+ sum (char->integer (char->integer\
    \ (char->integer 'a'))))\n\t\t          (+ i (string->string (char->string (char->integer\
    \ 'a'))))])\n\t[else (loop (+ sum (char->integer (char->integer (char->integer\
    \ (char->integer s (+ i 1))))))\n\t\t   (+ i (string->string (char->string (char->integer\
    \ s (+ i 1)))))]\n\t))\n  (digit-sum s))", "  (define (digits xs) (if (null? xs)\n\
    \                        0\n                        (+ (digits (cdr xs))\n   \
    \                        (first xs))))\n  (define first (car s))\n  (define (digit-sum\
    \ xs) (digits xs))\n  (digit-sum (map #(char->integer #\\+)\n                \
    \   (map #(char->integer #\\-)\n                         (map #(char->integer\
    \ #\\#)\n                               (map #(char->integer #\\^)\n         \
    \                              (map #(char->integer #\\)\n                   \
    \                          (map #(char->integer #\\+)\n                      \
    \                             (map #(char->integer #\\-)\n                   \
    \                                      (map #(char->integer #\\#)\n          \
    \                                                     (map #(char->integer #\\\
    ^)\n                                                                     (map\
    \ #(char->integer #\\)\n                                                     \
    \                     (map #(char->integer #\\+)\n                           \
    \                                                  (map #(char->integer #\\-)\n\
    \                                                                            \
    \       (map #(char->integer #\\#)\n                                         \
    \                                              (map #(char->integer #\\^)\n  \
    \                                                                            \
    \               (map #(char->integer #\\)\n                                  \
    \                                                               (map #(char->integer\
    \ #\\+)\n                                                                    \
    \                                   (map #(char->integer #\\-)\n             \
    \                                                                            \
    \                    (map #(char->integer #\\#)\n                            \
    \                                                                            \
    \         (map #(char->integer #\\^)\n                                       \
    \                                                                            \
    \  (map #(char->integer #\\)\n                                               \
    \                                                                          (map\
    \ #(char->integer #\\+)\n                                                    \
    \                                                                         (map\
    \ #(char->integer #\\-)\n                                                    \
    \                                                                            \
    \  (map #(char->integer #\\#)\n                                              \
    \                                                                            \
    \            (map #(char->integer #\\^)\n                                    \
    \                                                                            \
    \                          (map #(char->integer #\\)\n                       \
    \                                                                            \
    \                                                              (map #(char->integer\
    \ #\\+)\n                                                                    \
    \                                                                            \
    \                      (map #(char->integer #\\-)\n                          \
    \                                                                            \
    \                                                                   (map #(char->integer\
    \ #\\#)\n                                                                    \
    \                                                                            \
    \                               (map #(char->integer #\\^)\n                 \
    \                                                                            \
    \                                                                            \
    \          (map #(char->integer #\\)\n                                       \
    \                                                                            \
    \                                                                    (map #(char->integer\
    \ #\\+)\n                                                                    \
    \                                                                            \
    \                                         (map #(char->integer #\\-)\n       \
    \                                                                            \
    \                                                                            \
    \                              (map #(char->integer #\\#)\n                  \
    \                                                                            \
    \                                                                            \
    \                     (map #(char->integer #\\^)\n                           \
    \                                                                            \
    \                                                                            \
    \              (map #(char->integer #\\)\n                                   \
    \                                                                            \
    \                                                                            \
    \           (map #(char->integer #\\+)\n                                     \
    \                                                                            \
    \                                                                            \
    \          (map #(char->integer #\\-)\n                                      \
    \                                                                            \
    \              ", "  (cond\n    [(empty? s) 0]\n    [(<= (number? (first (rest\
    \ s))) 48) (+ \n                                 (number? (first (rest s)) 48)\n\
    \                                 (digitSum (rest s))\n                      \
    \           )]\n    [else (+ \n            (digitSum (rest s))\n            (+\
    \ (number? (first (rest s))) 48)\n            )]))\n", "  (+ (char-code (first\
    \ s)) \n     (digitSum (rest s))))\n", "  (if (string? s)\n      (digitSum string-map\
    \ s)\n      (digitSum (string->list s))))\n", "  (if (or (null? s) (empty? s))\
    \ (digitSum (substring s 0 0)) 0))\n", "  (cond\n    [(empty? s) 0]\n    [(equal?\
    \ (string->char-code s) 'A) (+ (string->char-code s) 10)\n      (digitSum (substring\
    \ (substring s 0 1) 1 string->char-code s))]\n    [else (digitSum (substring s\
    \ 0 1))]))\n", "  (let ((sum (digits s)))\n    (if (null? s)\n        0\n    \
    \    (+ sum (digit (first s))))))\n", "  (let ([s (string->list (string-map #(if\
    \ (char->integer %)\n                                    (char->integer %)\n \
    \                                 (error \"Not an integer!\"))\n             \
    \                       s))])\n    (apply + '(map (lambda(x) (if (> 0 x (modulo\
    \ (char->integer s) 26)) x)) s))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c\
    \ |>\nWow, that was fast! Thank you for taking the time to write this and answer\
    \ this question. I know this would be much easier using recursion, but I wanted\
    \ to try it out using map/filter/lambda. I'm not very familiar with racket yet,\
    \ so I guess this was a good learning exercise. Thanks again!\n<|/ c |>\n<| a\
    \ tags=racket,scheme |>\nI'm new here and I'm a total newbie when it comes to\
    \ Scheme so please forgive my ignorance.\nI did manage to create a solution that\
    \ seems to work. \n<code>", "  (reverse\n   (map char->int \n        (lambda (c)\
    \ \n          (if (char->int c) \n              (+ char->int c) \n           \
    \   0))\n         (string->list s))))\n", "  (cond\n    [(empty? s) 0]\n    [(digit?\
    \ (first s)) (+ 10 (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(char-upper? (car s)) (+ (char-upper? (car s))(digitSum\
    \ (cdr s)))]\n    [else (digitSum (cdr s))]))", "  (define sum (0))\n  (for ([(i\
    \ n) (string-length s)]\n        (cond\n          [(= i 0) sum]\n          [(char-upper?\
    \ (substring s i i))\n           (+ sum (char-code (char (char-lower-case (substring\
    \ s i i)) \n               (char-code (char-upper-case (substring s i i))))))]\n\
    \          [else (error \"Unknown input\")]))\n  sum)\n", "  (let loop ((s s)\n\
    \             (sum 0))\n    (cond\n      [(empty? s) sum]\n      [(char-upper?\
    \ (first s)) (loop (rest s)\n                              (+ sum (char->int (first\
    \ s))))]\n      [(char-upper? (rest s)) (loop (rest s)\n                     \
    \         (+ sum (char->int (first s))))]\n      [else (loop (rest s)\n      \
    \           (+ sum (char->int (first s))))]))))\n", "  (cond [(empty? s) 0]\n\
    \        [(digit? s) (+ (char->integer c) (digitSum (rest s)))]\n        [else\
    \ (digitSum (rest s))]))\n", "  (cond [(empty? s)\n         0]\n        [(digit?(first\
    \ s))\n         (+ (first s)(digitSum (rest s)))]\n        [else (digitSum (rest\
    \ s))]))\n", "  (for/sum ([i (length s)])\n    (if (<= i 0)\n      0\n      (let\
    \ ((j (substring (s i) 0))\n            (r (char->integer (char-code (substring\
    \ j j 0)))))\n        (+ r (digitSum (substring (s i (+ 1 j))))))))) ;; #lang\
    \ racket\n</code>\n<|/ a tags=racket,scheme |>\n<| a dscore=1 |>\n<code>\n#lang\
    \ racket\n", "  (+ (char-code (first s)) \n     (digitSum (rest s))))\n", "  (apply\
    \ + (map digit->int s)))\n", "  (define (loop (s s)\n             (if (empty?\
    \ s)\n                 0\n                 (+ (char->integer [first (first s)])\
    \ (loop (rest s) (char->integer [first (first s)]))))))\n  (loop s s))\n</cell>\n\
    <code language=dyalog-kernel>", "  (let ([m 0]\n        [max 128]\n        [sum\
    \ (+ sum max-m)]\n        [s (string-map s (fn [c] (if (>= (code c) max) 0 (+\
    \ (code c) m)))])\n        [c s])\n    (loop\n       [len string-length (string-map\
    \ s (fn [c] (if (>= (code c) max) 0 (+ (code c) m))))]\n       (if (= len 0)\n\
    \           sum\n           (let ([c1 (char s 0)])\n             (set! sum (+\
    \ (code c1) sum))\n             (set! m (max m)))\n           (set! len 1)\n \
    \          (loop\n              [len string-length (string-map s (fn [c] (if (>=\
    \ (code c) max) 0 (+ (code c) m))))]\n             (if (= len 0)\n           \
    \      sum\n                 (let ([c1 (char s 0)])\n                   (set!\
    \ sum (+ (code c1) sum))\n                   (set! m (max m)))))\n           (set!\
    \ len 1)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
