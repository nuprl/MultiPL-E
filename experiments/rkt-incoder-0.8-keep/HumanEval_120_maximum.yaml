name: HumanEval_120_maximum
language: rkt
prompt: "#lang racket\n\n;; Given an array arr of integers and a positive integer\
  \ k, return a sorted list \n;; of length k with the maximum k numbers in arr.\n\
  ;; Example 1:\n;; Input: arr = [-3, -4, 5], k = 3\n;; Output: [-4, -3, 5]\n;; Example\
  \ 2:\n;; Input: arr = [4, -4, 4], k = 2\n;; Output: [4, 4]\n;; Example 3:\n;; Input:\
  \ arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n;; Output: [2]\n;; Note:\n;; 1. The length\
  \ of the array will be in the range of [1, 1000].\n;; 2. The elements in the array\
  \ will be in the range of [-1000, 1000].\n;; 3. 0 <= k <= len(arr)\n(define (maximum\
  \ arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n\
  \    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))\n    (check-equal?\
  \ (candidate (list 4 -4 4) 2) (list 4 4))\n    (check-equal? (candidate (list -3\
  \ 2 1 2 -1 -2 1) 1) (list 2))\n    (check-equal? (candidate (list 123 -123 20 0\
  \ 1 2 -3) 3) (list 2 20 123))\n    (check-equal? (candidate (list -123 20 0 1 2\
  \ -3) 4) (list 0 1 2 20))\n    (check-equal? (candidate (list 5 15 0 3 -13 -8 0)\
  \ 7) (list -13 -8 0 0 3 5 15))\n    (check-equal? (candidate (list -1 0 2 5 3 -10)\
  \ 2) (list 3 5))\n    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))\n  \
  \  (check-equal? (candidate (list 4 -4) 2) (list -4 4))\n    (check-equal? (candidate\
  \ (list -10 10) 2) (list -10 10))\n    (check-equal? (candidate (list 1 2 3 -23\
  \ 243 -400 0) 0) (list ))\n))\n\n(test-humaneval)"
completions: ["  (define (max-helper arr k max-so-far current-max current-index)\n\
    \    (cond\n      [(= k 0)\n      (cons current-max max-so-far current-index)]\n\
    \      [(null? (cdr arr))\n      (if (= (- k current-index) 0)\n          (cons\
    \ (car arr) max-so-far)\n          (max-helper (cdr arr) (k) (cons (car arr) (cons\
    \ current-max max-so-far) (+ current-index 1))))]\n      [(> (car arr) current-max)\n\
    \      (max-helper arr (- k current-index) current-max current-index)]\n     \
    \ [else (max-helper (cdr arr) (k) (cons (car arr) (cons current-max max-so-far)\
    \ (+ current-index 1)))])\n  (max-helper arr k #f 0))\n", "  (define (helper arr\
    \ k acc)\n    (if (= k 0)\n        acc\n        (helper (rest (rest arr)) (- k\
    \ 1) (if (> (max acc) (- (max acc) arr)) (max acc) (- (max acc) arr))))))\n  (helper\
    \ arr k '()))\n", "  (cond\n    ((= k 0) (map max arr))\n    ((= k 1) (cons arr\
    \ arr))\n    (else (let ((tail (maximum (rest arr) (k-1))))\n      (cons (max\
    \ arr (first tail)) tail)))))\n)\n", "  (cond\n    [(< k 0)\n     (error \"k is\
    \ negative\")\n     ]\n    [(empty? arr) empty]\n    [(= k (length arr)) arr]\n\
    \    [else (cons (max (first arr) (- k 1))\n                (maximum (rest arr)\
    \ k))]))", "  (cond\n    [(null? (rest arr)) '()]\n    [(= k 0)\n     (cons (first\
    \ arr) (maximum (rest arr) (sub1 k)))]\n    [else (cons (first arr) (maximum (rest\
    \ arr) (sub1 k)))]\n   ))\n", "  (cond\n    [(empty? arr) empty]\n    [(= k (length\
    \ arr)) (list arr)]\n    [else (cons (max (rest arr) k) (maximum (rest arr) (sub1\
    \ k)))]))\n", "  (cond [(= k 0) (list)] \n        [else (let ([max (apply max\
    \ arr)])\n                 (append (maximum (sub1 arr) (sub1 k)) max))]))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(= k (length arr)) (append arr '())]\n  \
    \  [else (append (take-k arr k) (maximum (drop-k arr k) (- k 1)))]))\n", "  (define\
    \ (helper arr k acc nil)\n    (cond ((null? arr) (list acc))\n          ((= k\
    \ 0) (helper (rest arr) (k-1 (car acc)) (cons (car acc) nil) nil))\n         \
    \ (else (helper (rest arr) (k-1 (car acc)) (cdr acc) (cdr nil)))))\n  (helper\
    \ (reverse arr) k nil nil))\n", "  (sort (sort arr (lambda (x y) (> (max x y)\
    \ y)) (lambda (x y) (<= (max x y) y)))\n         (lambda (x y) (<= (- x (- y k))\
    \ (- y k)))\n         (lambda (x y) (> (- x (- y k)) (- y k)))\n         (lambda\
    \ (x y) (> (- x k) (- y k)))\n         (lambda (x y) (< (- x k) (- y k))))\n \
    \        (lambda (x y) (<= (- x (- y k)) (- y k))))\n</code>\n<|/ a dscore=0 tags=scheme,racket,sorting\
    \ |>\n<| a tags=scheme,racket,sorting |>\n<code>", "  (if (= k 0)\n      '()\n\
    \      (let ([max-val (first arr)]\n            [max-index (first arr)]\n    \
    \        [curr-index (first arr)])\n        (if (>= k max-index)\n           \
    \ '()\n            (if (= curr-index max-index)\n                (cons (first\
    \ arr) (cdr max-val))\n                (cons (first arr) (maximum (cdr arr) (-\
    \ k 1))))))))\n", "  (cond\n    ((empty? arr) (list nil))\n    ((= k 0) (first\
    \ arr))\n    ((> (first arr) (maximum (rest arr) (sub1 k))))\n    (else (append\
    \ (maximum (rest arr) (sub1 k)) (list (first arr))))))\n", "  (cond [(< k 0) '()]\n\
    \        [else (cons \n               (max (rest arr) (- k 1))\n             \
    \  (maximum (rest arr) (- k 1))))]\n  )\n)\n", "  (cond\n    [(< arr (length-arr))\n\
    \     (cons arr (maximum (rest arr) (add1 k)))]\n    [else (maximum (rest arr)\
    \ k)]\n  ))\n", "  (cond\n    [(null? arr) (make-vector k #f)]\n    [(< (length\
    \ (first arr)) k) (maximum (rest arr) (- k 1))]\n    [else (cons (first arr) (maximum\
    \ (rest arr) (- k 1))]\n  )\n)\n", "  (let loop ((i 0)\n             (max '()))\n\
    \    (cond\n      ((< i (length arr))\n       (reverse max)\n      )\n      ((<\
    \ (elt arr i) max)\n       (loop (+ i 1) (cons (elt arr i) max)))\n      (else\
    \ (loop (+ i 1) max))))\n)\n", "  (if (= k 0)\n      arr\n      (append (subseq\
    \ arr (- k 1))\n              (maximum arr (- k 1)))))\n", "  (define (maximum-helper\
    \ i temp)\n    (cond ((>= i k) temp)\n          ((< arr i) \n           (cons\
    \ \n             (maximum-helper (+ i 1) \n                          (cons (max\
    \ temp \n                                   (- arr (+ i 1))) \n              \
    \              (sub1 arr))))\n          (else \n           (maximum-helper (+\
    \ i 1) (max temp arr))))))\n  (maximum-helper 1 '()))\n", "  (if (null? arr) \n\
    \      '()\n      (if (= k 0)\n          (append (list -1000)\n              \
    \    arr)\n          (if (> (car arr) (-1000))\n              (append (list (car\
    \ arr))\n                       (maximum (cdr arr) (sub1 (car arr)))\n       \
    \                (maximum (cdr arr) (cdr arr) (sub1 (car arr))))))))\n", "  (sort\
    \ (cons 0 arr) (lambda (x y) (- (max x y) (min x y))))\n)\n", "  (let loop ((idx\
    \ 0) (max 0) (arr arr))\n    (if (zero? idx)\n        (cons max (loop (+ idx 1)\
    \ 0 (cdr arr))) (loop (+ idx 1) (max (car arr)) (cdr arr))))))\n", "  (if (= k\
    \ 0)\n      (cons 0 (if (> (length arr) k) (list arr) ()))\n      (let ([tail\
    \ (maximum (rest arr) (sub1 k))]\n            [head (first tail)])\n        (cons\
    \ (max head (max tail (car tail)))\n              (maximum (cdr tail) (sub1 k))))))\
    \ ; #lang racket\n", "  (if (< k 0)\n      (list-of (sublist arr (- k 0))) ; k\
    \ numbers in arr \n      (list-of arr))) ; no k numbers in arr\n", "  (cond [(=\
    \ k 0) (list ())]\n        [(= k 1) (cons (car arr) ())]\n        [else (append\
    \ (maximum (rest arr) (sub1 k)) \n                      (maximum (rest arr) (sub1\
    \ k))))]))\n", "  (cond\n    [(empty? arr) (list-of k)]\n    [(<= k 0) (list-of\
    \ k)]\n    [else (cons (max arr (sub1 k)) (maximum (sub1 arr) k))]))", "  (define\
    \ (helper arr k max)\n    (cond\n      [(empty? arr) empty]\n      [(or (= k (length\
    \ arr)) (<= k max)) (helper arr (sub1 k) max)]\n      [else (cons (max (car arr)\
    \ (sub1 k)) (helper (cdr arr) (sub1 k) max))]))\n  (helper arr k (length arr)))\n",
  "  (let ([max-num (first arr)] \n        [arr (rest arr)])\n    (cond [(empty? arr)\n\
    \           empty]\n          [(= k (length arr))\n           (list max-num)]\n\
    \          [else\n           (let ([left (maximum arr (sub1 k))]\n           \
    \       [right (maximum arr (add1 k))]\n                  [max-num (apply max\
    \ (map max-num\n                                          (cons left right)\n\
    \                                          (cons (first arr) (second arr))))])\n\
    \             (cond [(< max-num left)\n                    max-num]\n        \
    \           [(< max-num right)\n                    max-num]\n               \
    \    [else (cons max-num max-num)]))]))\n", "  (if (< k 0)\n      '()\n      (cons\
    \ (max (rest arr) k) (maximum (rest arr) (sub1 k))))))\n", "  (cond\n    ((= k\
    \ 0) '())\n    ((= k (length arr)) (list arr))\n    ((= (length arr) k) (list\
    \ arr))\n    ((< (car arr) (cadr arr)) (maximum (cdr arr) (- k 1)))\n    (else\
    \ (cons (car arr) (maximum (cdr arr) k))))))\n", "  (let ([mn #(- -1000 (min (+\
    \ k 1) 1000))])\n    (lambda (x) (cond\n                    [((<= k 0) (< x (apply\
    \ min arr)))] \n                    [((< x (apply min arr))) x]\n            \
    \        [else (cond [(< m (apply min arr)) x]\n                             \
    \  [else (cond [(< x (apply max arr)) x]\n                                   \
    \      [else (cond [(< x (apply max arr)) x]\n                               \
    \                    [(< x (apply min arr)) (cons x (apply mn arr))])))]))))\n",
  "  (if (null? arr)\n      '()\n      (cons (max (car arr) (- k 1))\n           \
    \ (maximum (cdr arr) (- k 1)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\n\
    It's not easy to follow a solution like this, which is why I posted the question.\
    \ I guess I'm just trying to understand why my code doesn't work though. Thanks\
    \ though!\n<|/ c |>\n<| c |>\n: It's a problem of not understanding how to solve\
    \ a programming problem by stepping through it with a pencil and paper. Writing\
    \ code with a pencil and paper is the only way to understand what it is doing.\
    \ That's how you become a great programmer. Being a good programmer is a critical\
    \ part of being a good programmer -- it's important to be good, and by being good\
    \ you should be able to understand code by understanding it with a pencil and\
    \ paper. Programming is all about understanding how it works.\n<|/ c |>\n<| c\
    \ |>\n: By the way, I added a solution using recursion.\n<|/ c |>\n<| c |>\nWow,\
    \ I wish I could have thought of that! Thanks a bunch!\n<|/ c |>\n<| c |>\n, what\
    \ if I want to find the maximum of each sublist in a list of lists and return\
    \ it as a list of lists? How would I do that?\n<|/ c |>\n<| a |>\nThis is a classic\
    \ recursive problem. You'll want to use recursion because you cannot iterate over\
    \ an iterator in Scheme.\n<code>", "  (define (iter k arr)\n    (cond\n      [(=\
    \ k 0) arr]\n      [(> k 0) (iter (sub1 k) \n                       (append (append\
    \ (iter k (max arr (sub1 k))))\n                               (list arr)))]\n\
    \      [else (iter (sub1 k) \n                  (cons (max arr (sub1 k)) arr))]))\n\
    \  (iter k arr))\n", "  (cond\n    [(empty? arr) (list empty)]\n    [(null? (rest\
    \ arr)) (list (car arr))]\n    [(= k (length arr))\n     (if (> (car arr) (maximum\
    \ (cdr arr) (k - 1))) (list car arr))]\n    [else (cons (max (car arr) (cdr arr))\
    \ (maximum (cdr arr) (k - 1))) ]))\n", "  (let loop ((k k)\n             (acc\
    \ '()))\n    (if (< k 0)\n        (reverse acc)\n        (loop (- k 1) (cons (max\
    \ arr (- k 1)) acc))))))\n", "  (let loop ((i 0) (max '() (sub1 (in-range (-1000\
    \ 1000))))\n             (arr arr))\n    (cond\n      ((null? arr) max)\n    \
    \  ((= i k) (if (> max (car arr)) (car max) max))\n      ((< i (sub1 k)) (loop\
    \ (add1 i) (cdr max) (cdr arr)))\n      (else\n       (loop (add1 i) (cdr max)\
    \ (cdr arr))))))\n", "  (letfn [(helper ([arr arr]\n                 [k k]\n \
    \                [max '()])]\n    (if (< k 0) arr\n        (helper (rest arr)\n\
    \                (k - 1) ; k decreases\n                (if (< k (length arr))\
    \ (cons max (maximum arr (- k 1))) (cons max '())))))]\n    (helper arr k '())))\n",
  "  (let ([i 0]\n        [max #f]\n        [l #t])\n    (cond\n      [(empty? arr)\
    \ #t]\n      [(< (first arr) max) l]\n      [else (let ([max (first arr)])\n \
    \             (cond [(empty? (rest arr)) (if (l? (first arr)) (reverse arr) (cons\
    \ max arr)))]\n                    [else (let ([v (first arr)])\n            \
    \              (if (< (first arr) v)\n                              (if (> max\
    \ (first arr))\n                                  (set! max (first arr))\n   \
    \                               (let ([i (+ 1 i)])\n                         \
    \           (cond [(< v max) (set! max v) (set! i (+ 1 i)))]\n               \
    \                           [else (set! max (first arr)) (set! i (+ 1 i)))]\n\
    \                                      )\n                              (let ([i\
    \ (+ 1 i)])\n                                (cond [(< v max) (set! max v) (set!\
    \ i (+ 1 i)))]\n                                      [else (set! max (first arr))\
    \ (set! i (+ 1 i)))]\n                                  )\n                  \
    \            )\n                            ]\n                    )]\n      )]))\n",
  "  (cond\n    [(empty? arr) (list nil)]\n    [(empty? (rest arr)) (list nil)]\n\
    \    [(= k 1) (first arr)]\n    [else (if (> k (length (first arr)))\n       \
    \      (car arr)\n             (maximum (rest arr) (sub1 k)))]))\n", "  (cond\
    \ [(empty? arr)\n         empty]\n        [(= (length arr) k)\n         (take\
    \ k (sort arr bigger)]\n        [else\n         (take k (sort arr smaller))]\n\
    \        ))\n", "  (define (helper arr k acc)\n    (cond\n      [(= k 0) (cons\
    \ (car acc) (helper arr (- k 1) (cdr acc)))]\n      [(< k 0) (helper (car arr)\
    \ (sub1 k) (cons (car arr) (helper arr (- k 1) acc)))]\n      [else (helper (cdr\
    \ arr) (- k 1) (cons (car arr) (helper arr k acc)))]))\n  (helper arr k '()))\n",
  "  (define (insert x)\n    (cond ((> x k) (list x))\n          ((>= (- (car arr)\
    \ x) (* k x)) (cons (car arr) (insert (- (car arr) x) k)))\n          ((< x (car\
    \ arr)) (cons (car arr) (insert x (+ k 1))))\n          (else (insert x))))\n\
    \  (insert (max (car arr) k)))\n", "  (cond\n    [(empty? arr) empty]\n    [(empty?\
    \ (rest arr)) (list (- (first arr) (first arr)))]\n    [else (cons (max (rest\
    \ arr) k) (maximum (rest arr) (add1 k)))]))\n", "  (define (max-helper arr k)\n\
    \    (cond ((= k 0) (sort arr))\n          ((= k (length arr)) arr)\n        \
    \  ((null? (cdr arr)) (cons (car arr) '()))\n          ((< (car arr) (cadr arr))\n\
    \           (max-helper (cdr arr) (sub1 k))\n          (else (cons (car arr) (max-helper\
    \ (cdr arr) (sub1 k))))))\n  (max-helper arr k))\n", "  (cond\n    [(null? arr)\
    \ (list 0 '())]\n    [(= (length arr) k) (list 0 (first arr) '())]\n    [else\
    \ (cons\n         (cond\n          [(< (first arr) (second arr)) (cons (first\
    \ arr) (maximum (rest arr) (sub1 k)))]\n          [(>= (first arr) (second arr))\
    \ (maximum (rest arr) (sub1 k))]\n          [(= (first arr) '()) (cons (second\
    \ arr) (maximum (rest arr) (k - 1)))]\n          [(= '() (first arr)) (maximum\
    \ (rest arr) (k - 1))]\n          [(> '() (first arr)) (maximum (rest arr) (k\
    \ - 1))]\n          [(> '() (second arr)) (maximum (rest arr) (sub1 k))])])]))\n",
  "  (if (<= k 0)\n      '()\n      (if (empty? arr)\n          (list arr)\n     \
    \     (if (> (car arr) (cadr arr))\n              (append (list (maximum arr (-\
    \ k 1))) (car arr))\n              (maximum (cdr arr) (- k 1))))))))\n#lang racket\n",
  "  (cond [(empty? arr) empty]\n        [(= k (length arr)) (list arr)]\n       \
    \ [else (append (maximum (rest arr) (- k 1))\n                      (list (max\
    \ arr (first arr)))\n                      (maximum (rest arr) (- k 1))])))\n",
  "  (cond\n    [(empty? arr) (list nil)]\n    [(= k 1) (first arr)]\n    [else (append\
    \ (first arr) (maximum (rest arr)\n                                     (- k 1)))]))\n",
  "  (cond\n    [(empty? arr) (list empty)]\n    [(= k 0) (cons (car arr) empty)]\n\
    \    [else (append (maximum (rest arr) (sub1 k)) \n                   (cons (car\
    \ arr) (maximum (rest arr) (sub1 k))))]))\n", "  (cond\n    ((= k 0) '())\n  \
    \  ((= k (length arr)) arr)\n    (else\n     (cons \n      (max (sub1 k) \n  \
    \         (car arr)\n           (maximum (sub2 k) \n                     (cdr\
    \ arr)))\n      (maximum (sub1 k) \n              (cdr arr)\n              (maximum\
    \ (sub2 k) \n                      (cdr arr))))))\n", "  (cond\n    ((and (null?\
    \ arr) (>= k 0))\n     (list #f #f))\n    ((= k 0)\n     (list arr))\n    ((>=\
    \ (length arr) k)\n     (list arr))\n    ((>= k 1)\n     (append arr (cons (max\
    \ (rest arr) (- k 1)) #f)))\n    ((>= (length (first arr)) k)\n     (append (first\
    \ arr) (cons (max (rest arr) (- k 1)) #f)))\n    (else\n     (append arr (cons\
    \ (max (rest arr) (- k 1)) (max (rest arr) (- k 2)) #f))))\n", "  (cond [(empty?\
    \ arr) (empty-list)] \n        [else (cons (max (first arr)) (maximum (rest arr)\
    \ (- k 1)))]))) \n  ", "  (cond\n    [(< k 0) '()]\n    [(= k 0) '(first arr)]\n\
    \    [else (append (maximum (rest arr)\n                           (- k 1))\n\
    \                  (append (take k (first arr))\n                          (maximum\
    \ (rest arr)\n                                  (- k 1)))]))))\n", "  (cond\n\
    \    ((empty? arr) '())\n    ((= k 0) (first arr))\n    ((= k (length arr)) (list\
    \ (first arr)))\n    (else (append (max (rest arr) (k -1)) (list first (max arr\
    \ (- k 1)))))))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou can write it like this:\n\
    <code>", "  (if (or (= k 0) (<= (length arr) k))\n      '()\n      (cons (max\
    \ (rest arr) (sub1 k)) (maximum (rest arr) (sub1 k))))))\n", "  (if (= k 0)\n\
    \      '()\n      (let ([max-num (car arr)\n              nums (cdr arr)\n   \
    \           max (car max-num)])\n        (if (<= k 0)\n            (if (< num\
    \ max)\n                (list max-num)\n                (cons max-num (maximum-helper\
    \ nums (- k (- k 1)))))))))\n", "  (cond [(or (empty? arr) (= k 0))\n        \
    \ '()]\n        [(= k 1)\n         (list* (car arr) (maximum (cdr arr) (- k 1)))]\n\
    \        [else\n         (cons (max (car arr) (maximum (cdr arr) (- k 1))) (maximum\
    \ (cdr arr) (- k 1))))]\n))", "  (if (= k 0)\n      arr\n      (let ([max (car\
    \ arr)]\n            [rest (cdr arr)])\n        (if (= k 1)\n            (cons\
    \ max rest)\n            (cons max (maximum rest k-1)))))) \n", "  (if (or (=\
    \ k 0) (null? arr)) arr\n      (if (or (= (length arr) k) (= k 0))\n         \
    \ (list\n           (sort (append (sub1 arr (- k 1)) arr) <)\n           (reverse\
    \ (sort (append arr (sub1 arr (- k 1))) <))\n           (sort (append (sub1 arr\
    \ (- k 1)) arr) <)\n           (reverse (sort (append arr (sub1 arr (- k 1)) (sub1\
    \ (reverse arr) k)) <))\n           (sort (append arr (sub1 arr (- k 1)) arr)\
    \ <)\n           (reverse (sort (append arr (sub1 arr (- k 1)) (sub1 (reverse\
    \ arr) k)) <))\n           (sort (append arr (sub1 arr (- k 1)) arr) <)\n    \
    \       (reverse (sort (append arr (sub1 arr (- k 1)) (sub1 (reverse arr) k))\
    \ <))\n           (sort (append arr (sub1 arr (- k 1)) arr) <)\n           (reverse\
    \ (sort (append arr (sub1 arr (- k 1)) (sub1 (reverse arr) k)) <))\n         \
    \  (sort (append arr (sub1 arr (- k 1)) arr) <)\n           (reverse (sort (append\
    \ arr (sub1 arr (- k 1)) (sub1 (reverse arr) k)) <))\n           (sort (append\
    \ arr (sub1 arr (- k 1)) arr) <)\n           (reverse (sort (append arr (sub1\
    \ arr (- k 1)) (sub1 (reverse arr) k)) <))\n           (sort (append arr (sub1\
    \ arr (- k 1)) arr) <)\n           (reverse (sort (append arr (sub1 arr (- k 1))\
    \ (sub1 (reverse arr) k)) <))\n           (sort (append arr (sub1 arr (- k 1))\
    \ arr) <)\n           (reverse (sort (append arr (sub1 arr (- k 1)) (sub1 (reverse\
    \ arr) k)) <))\n           (sort (append arr (sub1 arr (- k 1)) arr) <)\n    \
    \       (reverse (sort (append arr (sub1 arr (- k 1)) (sub1 (reverse arr) k))\
    \ <))\n           (sort (append arr (sub1 arr (- k 1)) arr) <)\n           (reverse\
    \ (sort (append arr (sub1 arr (- k 1)) (sub1 (reverse arr) k)) <))\n         \
    \  (sort (append arr (", "  (define (helper arr k count)\n    (if (= count k)\n\
    \        (cons max (helper arr k (+ count 1)))\n        (helper (append (cons\
    \ max arr) \n                      (cons (car arr) (cons (car arr) (list count)))\
    \ \n                      (cdr arr) \n                      (cons (cdr arr) (cons\
    \ count (cdr arr))) \n                      (cons count (cdr arr)) \n        \
    \              (cons (car arr) (cons (car arr) (list count))) \n             \
    \         (cdr arr) \n                      (cons (cdr arr) (cons count (cdr arr))))\n\
    \                  k (+ count 1))))\n  (helper arr k 0))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(= k (length arr)) arr]\n    [else (cons (max (rest arr) (-\
    \ k 1)) (maximum (rest arr) (- k 1))) ]))", "  (sort arr >\n          (lambda\
    \ (x)\n            (if (> x 0) (+ x k) (+ k 1)))))\n</code>\n<|/ a dscore=0 tags=sorting,racket,max,scheme\
    \ |>\n<| a tags=sorting,racket,max,scheme |>\n<code>", "  (define (helper acc\
    \ arr k)\n    (cond ((> k 0) acc)\n          ((< k 0) ())\n          ((= k 0)\
    \ (cons -1 acc))\n          ((< 0 (- k 1)) arr)\n          (else (helper (cond\
    \ ((< (- k 1) (- arr 0)) 0)\n                                 ((= (- k 1) (- arr\
    \ 0)) (- (- k 1) (- arr 0))))\n                       (- k 1)\n              \
    \         (- arr 0))))\n  (helper [] arr k))", "  (cond\n    [(null? arr) '()]\n\
    \    [(zero? k) arr]\n    [(= k 0) '()]\n    [else (let* ((j (sub1 (quotient (-\
    \ k 1) (length arr)))\n                  (x max)\n                  (i 0))\n \
    \             (loop for i from 0 to j \n                unless (< x arr[i])\n\
    \                do (set! x (car arr))\n                (set! arr (cdr arr))\n\
    \                (set! i (+ i 1)))]\n              (cons (car arr) \n        \
    \            (maximum arr (- k 1))))))])\n</code>\n<code>\n#lang racket\n", " \
    \ (cond [(< k 0)\n         (list)] \n        [(= k 0)\n         (list arr)]\n\
    \        [else\n         (append (max (rest arr) (k-1))\n                  (list*\
    \ max arr\n                          (cond [(< (car arr) (car rest))\n       \
    \                           (max (rest arr) (k-1))]\n                        \
    \    [(> car arr) (list arr)]\n                            [else (list arr)])]))]))\n",
  "  (if (null? arr)\n      arr\n      (cons (max \n            (sub1 arr (- k 1))\n\
    \            (maximum (sub1 arr (- k 1))\n                (- k 1))) \n       \
    \     (maximum (rest arr) k))))\n", "  (cond [(null? arr)\n         (list nil)]\n\
    \        [(= k 0)\n         (cons (car arr) (maximum arr (- k 1)))]\n        [else\n\
    \         (let ([max-value (car arr)])\n           (append (maximum (cdr arr)\
    \ (- k 1))\n                  (list (max max-value (car arr)))))))\n", "  (cond\n\
    \    [(empty? arr) empty]\n    [else (if (< k (length arr))\n              (cons\
    \ (max arr (- k 1)) (maximum (rest arr) k))\n              (maximum (rest arr)\
    \ k))]))\n", "  (define (top-k acc k)\n    (if (= k 0)\n        acc\n        (top-k\
    \ (cons (max (car acc) (car arr)) acc) (sub1 (+ k 1)))))\n  (top-k empty? k))\n",
  "  (cond\n    [(empty? arr) (list '())]\n    [(= (length arr) k) (cons (first arr)\
    \ (maximum (rest arr) (k-1)))]\n    [else (append (maximum (rest arr) (k-1)) (cons\
    \ (first arr) (maximum (rest arr) (k-1))))]))\n", "  (if (null? arr)\n      '()\n\
    \      (max\n       (max\n        (sub1 (last arr)) (sub1 (first arr)))\n    \
    \   (max \n        (max\n         (maximum arr (sub1 k))\n         (maximum arr\
    \ (sub1 k)))\n        (max \n         (max\n          (max arr (sub1 k)) (max\
    \ arr (sub1 k)))\n         (max \n          (max\n           (maximum arr (sub1\
    \ k)) (maximum arr (sub1 k)))\n           (maximum arr (sub1 k))))))))", "  (cond\n\
    \    [(empty? arr) empty]\n    [(= k 0) (cons (first arr) (maximum (rest arr)\
    \ 0))]\n    [else (cons (max (first arr) (k-1)) (maximum (rest arr) (sub1 k)))]\n\
    \  )\n)\n", "  (cond\n    ((null? arr) (list))\n    ((= k 0) (reverse (tail arr)))\n\
    \    (else (append (max (tail arr) (- k 1))\n                  (maximum arr (-\
    \ k 1))))))\n", "  (cond [(null? arr) '()]\n        [(> (car arr) k) (cons (car\
    \ arr) (maximum (cdr arr) (- k 1)))]\n        [else (maximum (cdr arr) k)]))\n",
  "  (define (get-max-k arr)\n    (cond ((null? arr) ())\n          ((null? (cdr arr))\
    \ (first arr))\n          ((> (first arr) (car arr)) (cons (first arr) (get-max-k\
    \ (cdr arr))))\n          (else (get-max-k (cdr arr))))\n  (cond ((null? arr)\
    \ (list 0))\n        ((> (first arr) 0) (list 0))\n        (else (cons (get-max-k\
    \ (cdr arr)) (maximum (cdr arr) k))))\n  )\n", "  (define (count-max a k count)\n\
    \    (if (= count k)\n        a\n        (if (> (car a) (cadr a))\n          \
    \  (count-max (cdr a) k (+ count 1))\n            (count-max a k (+ count 1)))))\n\
    \  (count-max arr k 0))\n</code>\n<|/ a |>\n<| c |>\nThis is not quite correct.\
    \ `maximum` only takes `k` as argument, not `arr`. And `maximum` does not return\
    \ a list but returns the maximum number of the list. `[(define (maximum arr k)\
    \ (apply append (map car arr (subseq arr 0 k))))]` gives a list for the maximum\
    \ of the array `arr`, but does not find the maximum number of the array.\n<|/\
    \ c |>\n<| c |>\n, I think it's correct now, but I don't know how it got that\
    \ way.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (if (= k 0)\n      (list)\n  \
    \    (append (maximum arr (sub1 k)) (take (maximum arr (sub1 k)) (sub1 k))))))\n\
    </code>\n<|/ q tags=racket,scheme |>\n<| c |>\nPlease don't post images, just\
    \ copy and paste the code in the question. Thanks.\n<|/ c |>\n<| a |>\nA simple\
    \ solution is using Racket's (->> ) macro, which evaluates the function on the\
    \ right and passes the return value to the function on the left:\n<code>", " \
    \ (sort arr >)\n  (subseq (subseq arr 0 k) k))\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for your effort. I tried your solution on https://leetcode.com/problems/maximum-subarray-sum-equal-to-k-given-integer-array\
    \ but somehow it doesn't work for the case that k is larger than the length of\
    \ the array. I'm wondering why?\n<|/ c |>\n<| c |>\nThe above solution works for\
    \ this test case. Can you post the problem link in the comment?\n<|/ c |>\n<|\
    \ c |>\nI uploaded the problem link here: https://leetcode.com/problems/maximum-subarray-sum-equal-to-k-given-integer-array/\
    \ Thanks!\n<|/ c |>\n<| c |>\nThanks for that. I've updated the code with a version\
    \ that works with that test case.\n<|/ c |>\n<| c |>\nThanks! I accepted your\
    \ answer but I think I should upvote your answer too since you have added a solution\
    \ where k is larger than the length of the array.\n<|/ c |>\n<| a tags=sorting,racket,arrays\
    \ |>\nI like how this is very similar to others except for the actual sorting\
    \ part.  Here is an implementation using the sort and subseq functions from the\
    \ standard library.\n<code>", "  (cond\n    [(= k 0) (list nil)]\n    [(< k 0)\
    \ (error 'negative k)] \n    [(< k 1) (error 'k is too large)]\n    [else (cons\
    \ (max arr (sub1 k)) (maximum (rest arr) (sub1 k)))]))\n", "  (cond\n    [(empty?\
    \ arr) (list)]\n    [(= k 0) (list first)]\n    [else (append (maximum (rest arr)\
    \ (- k 1))\n                   (list (first arr)))]))\n", "  (define (max-sub\
    \ sub k)\n    (cond [(empty? sub) (sub)]\n          [(< (car sub) (car arr)) (max-sub\
    \ (cdr sub) (add1 k))]\n          [else (max-sub (cdr sub) (add1 k))]))\n  (max-sub\
    \ arr k))\n", "  (define (largest-k arr k res)\n    (if (= k (length res))\n \
    \       res\n        (largest-k (cdr arr) (sub1 (+ k 1)) (cons (car arr) res))))\n\
    \  (largest-k arr k '()))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| c\
    \ |>\nI like the recursive solution and the way you used the accumulator. However,\
    \ the problem is that the `largest-k-helper` needs to have an accumulator that\
    \ is a pair, not a list. I was able to modify your solution to allow a list as\
    \ the accumulator. Here's what I ended up with: https://gist.github.com/aalex085/663debdb0c161044e891e7ba6da3cb00\n\
    <|/ c |>\n<| c |>\nThanks for the feedback! I updated my solution accordingly.\n\
    <|/ c |>\n<| c |>\nAwesome, thanks again! The solution has now been updated to\
    \ use `list`s as the accumulator. :)\n<|/ c |>\n<| a |>\nMy solution would be\
    \ the following:\n<code>\n#lang racket\n", "  (let ([arr1 (cut arr k)]\n     \
    \   [arr2 (cut arr (- k 1))])\n    (if (null? (rest arr1))\n        '()\n    \
    \    (cons (max (rest arr1) arr2)\n              (maximum (rest arr2) (- k 1))))))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(< k 0) '()]\n    [else (cons (car arr) (maximum\
    \ (cdr arr) (sub1 k)))]))\n</code>\n<|/ a dscore=0 tags=racket,arrays,scheme |>\n\
    <| a tags=racket,arrays,scheme |>\nThis implementation uses the basic algorithm\
    \ to find the maximum k elements in an array. \n<code>", "  (if (= k (length arr))\n\
    \      (list arr)\n      (cons (max arr (sub1 k)) (maximum (rest arr) (sub1 k))))))\n",
  "  (sort arr\n        (lambda (x) (< (car x) (car arr)) \n                    (<\
    \ (cdr x) (cdr arr)))))\n", "  (cond ((null? arr) '())\n        ((null? (cdr arr))\
    \ (cons (car arr) (maximum (cddr arr) k)))\n        (else (append (maximum (cdr\
    \ arr) k) (list car arr)))))\n", "  (cond [(empty? arr) (list) (list)]\n     \
    \   [(= k 1) (first (first (tail arr)))]\n        [else\n         (append (take\
    \ (maximum (drop 1 arr) (k-1)) (- k 1))\n                 (list (take (maximum\
    \ (drop 2 arr) (- k 2)) (- k 2)))\n                 (list (take (maximum (drop\
    \ 3 arr) (- k 3)) (- k 3)))\n                 (list (take (maximum (drop 4 arr)\
    \ (- k 4)) (- k 4)))\n                 (list (take (maximum (drop 5 arr) (- k\
    \ 5)) (- k 5)))\n                 (list (take (maximum (drop 6 arr) (- k 6)) (-\
    \ k 6)))\n                 (list (take (maximum (drop 7 arr) (- k 7)) (- k 7)))\n\
    \                 (list (take (maximum (drop 8 arr) (- k 8)) (- k 8)))\n     \
    \            (list (take (maximum (drop 9 arr) (- k 9)) (- k 9)))))])) ;; #lang\
    \ racket\n", "  (let loop ((len (length arr))\n             (max-k 0)\n      \
    \       (result '()))\n    (cond ((< len k)\n           (loop (sub1 len) max-k\
    \ (cons arr (cons max-k result))))\n          ((= k len)\n           (cons result\
    \ (cons arr (cons max-k result))))\n          ((= (% len k) 0)\n           (loop\
    \ (sub1 len) (+ max-k (first arr)) (cons arr (cons max-k result))))\n        \
    \  (else\n           (loop (sub1 len) (- k 1) (cons arr (cons max-k result))))))\
    \ \n", "  (define (max-helper arr acc)\n    (cond\n      ((null? arr) acc)\n \
    \     ((null? (cdr arr)) (cons (car arr) acc))\n      (else (if (= k (car arr))\
    \ (max (cdr arr) (+ acc 1)) \n               (max (cdr arr) (cons (car arr) (+\
    \ acc 1))))))\n  (max-helper arr '()))\n", "  (let loop ((arr arr)\n         \
    \    (result '())\n             (i 0))\n    (cond\n      [(null? arr) result]\n\
    \      [else (loop (cdr arr)\n                 (cons (max 0 (car arr)) result)\n\
    \                 (+ i 1))]\n    )\n  )\n)\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(empty? (rest arr)) (cons (car arr) '())]\n    [else (let ([max (car arr)])\n\
    \             (max (maximum (cdr arr) (add1 k))))]))\n", "  (if (= k 0)\n    \
    \  '()\n      (append (sort (append arr (list->array (sort (remove (- (length\
    \ arr) 1) (array->list arr)))) \n                         cmp=<)\n           \
    \   (maximum (remove (- (length arr) 1) (array->list arr)) (sub1 k))))))\n", " \
    \ (if (= k 0)\n      (list arr)\n      (append (append (list (max (rest arr) 0))\n\
    \                      (list (max arr (- (length arr) 1)))))\n    )\n  )\n", " \
    \ (let\n    ([max-k (sort (cons (first arr) (apply cdr arr)) (lambda (x y) (if\
    \ (= y 0) 0 \n                                                               \
    \ (max (if (> x 0) x 0) (if (< x 0) (length arr) 0))))))\n      (if (= k 0) arr\n\
    \          (append (subseq max-k k 1) (subseq max-k 0 k))))))\n  ", "  (if (=\
    \ k 0) (append (list arr) (list (car arr))) \n      (append (list (car arr)) (maximum\
    \ (cdr arr) (- k 1)))))\n", "  (cond\n    [(empty? arr) empty]\n    [(zero? k)\
    \ arr]\n    [(< k length) (sort (append (maximum arr (sub1 k)) arr) (max-compare\
    \ arr))]\n    [else (sort (append (maximum arr (sub1 k)) arr) (min-compare arr))]))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(= k 0) (first arr)]\n    [else (append\
    \ (first arr) (maximum (rest arr) (sub1 k)))]))\n", "  (if (= k 0)\n      (list\
    \ arr)\n      (append (sort (take arr (- k 1))) (maximum (drop arr k) (- k 1)))))",
  "  (if (<= 0 k)\n      (error \"k must be positive\")\n      (if (= k 0)\n     \
    \     (list arr)\n          (append (maximum arr (- k 1))\n                  \
    \ (list max (rest arr) (k))\n                   (maximum (rest arr) (- k 1))))))\n",
  "  (cond\n    [(empty? arr) (list '())]\n    [(empty? (rest arr)) (list arr)]\n\
    \    [(= 0 (mod k (length arr)))\n     (append (list arr) (maximum (rest arr)\
    \ (sub1 k)))]\n    [else\n     (append (maximum (first arr) (sub1 k)) (maximum\
    \ (rest arr) (sub1 k)))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(= k 0)\
    \ (first (maximum arr (- k 1)))]\n    [else (append (first (maximum arr (- k 1)))\
    \ (maximum (rest arr) (- k 1))]))\n)\n", "  (if (= k 0)\n      '()\n      (let\
    \ ([max (car arr)])\n        (cond [(> max k) (append (maximum (rest arr) (sub1\
    \ k)) (list (car arr)))]\n              [else (append (list (car arr)) (maximum\
    \ (rest arr) (sub1 k)))])))\n  )\n)\n", "  (if (= k 0)\n      (cons (max (first\
    \ arr) (second arr)) (maximum (rest arr) (k - 1))) \n      (cons (max (first arr))\
    \ (maximum (rest arr) (- k 1)))))\n", "  (cond\n    [(empty? arr) '()]\n    [(=\
    \ k (length arr)) (list nconc (first arr) (rest arr))]\n    [else (max (rest arr)\
    \ (- k 1))]))\n", "  (cond\n    [(= k 0) #()]\n    [(= k (length (car arr)))\n\
    \     (cons (car arr) (maximum (cdr arr) (sub1 k)))]\n    [else (maximum (cdr\
    \ arr) (sub1 k)))]))\n", "  (cond [(empty? arr) (list 0)]\n        [(= k 0) (list\
    \ arr)]\n        [else (append (list\n                        (max (rest arr)\
    \ (- k 1))\n                        (first arr))\n                        (maximum\
    \ (rest arr) (- k 1))]))]))\n", "  (let loop ((arr arr) (k (+ 1 k)))\n    (cond\
    \ ((< k 0) (list arr))\n          ((< k #(length arr)) (loop (rest arr) (- k 1)))\n\
    \          (else (let ((max (first arr)))\n                    (loop (rest arr)\
    \ (- k 1))\n                    (append arr (list max)))))))\n", "  (cond\n  \
    \  ((null? arr) '())\n    ((= k (length arr)) arr)\n    ((< (car arr) (cadr arr))\
    \ (append (maximum arr (- k (car arr)))\n                                    \
    \ (list (car arr))\n                                     (maximum (cdr arr) k)))\n\
    \    (else (append (maximum (car arr) (- k 1))\n                   (list (car\
    \ arr))\n                   (maximum (cdr arr) k))))\n", "  (cond\n    [(empty?\
    \ arr) (list -1)]\n    [else (cons (max (rest arr) k) (maximum (rest arr) k))]\n\
    \  )\n)\n", "  (let loop ((a arr (int 0)) (b '() (int 0)) (c (sub1 (length a))))\n\
    \    (cond ((= c 0) b)\n          ((= c k) (cons a b))\n          ((< c k) (recur\
    \ (cons a (cdr b)) (cdr b) (+ 1 c)))\n          (else (recur (cdr a) (cdr b) (+\
    \ 1 c))))))\n</code>\n<|/ a dscore=1 tags=algorithm,arrays,racket,sorting,scheme\
    \ |>\n<| a |>\nIt's easier to use a recursive function than a list comprehension.\n\
    <code>", "  (if (= k 0)\n      '()\n      (let loop ((lst '())\n             \
    \    (max (car arr) (- k 1))\n                 (rest arr))\n        (cond\n  \
    \        ((null? rest) lst)\n          ((>= (length lst) k) (cdr lst))\n     \
    \     (else (loop (append lst (list (car rest))\n                            \
    \  (max max (- k (length lst)))\n                              (cdr rest))))))))",
  "  (define (helper arr k ans)\n    (cond\n      [(empty? arr) (append (reverse ans)\
    \ (reverse (first arr)))]\n      [(= k (length arr)) (reverse (first arr))]\n\
    \      [(< (first arr) (second arr)) (helper (rest arr) (- k 1) (cons (first arr)\
    \ ans))]\n      [(> (first arr) (second arr)) (helper (rest arr) (+ k 1) (cons\
    \ (second arr) ans))]\n      [(> (first arr) (reverse (first arr))) (helper (rest\
    \ arr) (+ k 1) (cons (first arr) ans))]\n      [(< (first arr) (reverse (first\
    \ arr))) (helper (rest arr) (- k 1) (cons (first arr) ans))]\n      [else (helper\
    \ (rest arr) (+ k 1) (cons (first arr) ans))]\n      ))\n  (helper arr k nil))\n",
  "  (define (helper arr i max)\n    (cond\n      [(empty? arr)\n       (cond\n  \
    \       [(>= i max)\n          (list max)]\n         [else (list i)]\n       )]\n\
    \      [(< i max)\n       (cond\n         [(< (last arr) max)\n          (helper\
    \ (rest arr)\n                   (+ i 1)\n                   (last arr))\n   \
    \       (helper (rest arr)\n                   (+ i 1)\n                   (max\
    \ arr))\n          (helper (rest arr)\n                   (+ i 1)\n          \
    \         (max arr))\n          (helper (rest arr)\n                   (+ i 1)\n\
    \                   (max arr))\n          (helper (rest arr)\n               \
    \    (+ i 1)\n                   (max arr))\n          (helper (rest arr)\n  \
    \                 (+ i 1)\n                   (max arr))\n          (helper (rest\
    \ arr)\n                   (+ i 1)\n                   (max arr))\n          (helper\
    \ (rest arr)\n                   (+ i 1)\n                   (max arr))\n    \
    \      (helper (rest arr)\n                   (+ i 1)\n                   (max\
    \ arr))\n          (helper (rest arr)\n                   (+ i 1)\n          \
    \         (max arr))\n          (helper (rest arr)\n                   (+ i 1)\n\
    \                   (max arr))\n          (helper (rest arr)\n               \
    \    (+ i 1)\n                   (max arr))\n          (helper (rest arr)\n  \
    \                 (+ i 1)\n                   (max arr))\n          (helper (rest\
    \ arr)\n                   (+ i 1)\n                   (max arr))\n          (helper\
    \ (rest arr)\n                   (+ i 1)\n                   (max arr))\n    \
    \      (helper (rest arr)\n                   (+ i 1)\n                   (max\
    \ arr))\n          (helper (rest arr)\n                   (+ i 1)\n          \
    \         (max arr))\n          (helper (rest arr)\n                   (+ i 1)\n\
    \                   (max arr))\n          (helper (rest arr)\n               \
    \    (+ i 1)\n                   (max arr))\n          (helper (rest arr)\n  \
    \                 (+ i 1)\n                   (max arr))\n          (helper (rest\
    \ arr)\n                   (+ i 1)\n                   (max arr))\n          (helper\
    \ (rest arr)\n                   (+ i 1)\n                   (max arr))\n    \
    \      (helper (rest arr)\n                   (+ i 1)\n                   (max\
    \ arr))\n          (helper (rest arr)\n                   (+ i 1)\n          \
    \        ", "  (cond\n    [(null? arr) empty]\n    [(zero? k) (cons (car arr)\
    \ (maximum (cdr arr) (k - 1)))]\n    [else (cons (car arr) (maximum (cdr arr)\
    \ (k - 1))))]\n  )\n)", "  (if (null? arr)\n      '()\n      (let loop ((a (car\
    \ arr)) (acc (cons 0 (car acc))) (rest (cdr arr)))\n        (cond\n          ((<\
    \ a 0) (append acc (reverse (loop 0 (reverse (subseq rest 0))))))\n          ((<\
    \ acc (car acc)) (loop (car arr) (cons a acc) (cdr rest)))\n          (else (loop\
    \ a (cons a acc) rest)))))\n", "  (sort arr >)\n  (reverse (take k arr)))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(= k 0) (first arr)]\n    [else (cons (max\
    \ (rest arr) (- k 1))\n              (maximum (rest arr) (- k 1))\n          \
    \    )]))", "  (cond\n    [(empty? arr) '()]\n    [(= k 0) (first arr)]\n    [else\
    \ (cons (max (rest arr) k) (maximum (rest arr) (sub1 k)))]))\n", "  (if (= k 0)\n\
    \      '()\n      (append (sort (max arr (- k 1))) '())\n      )\n    )\n", " \
    \ (cond\n    [(null? arr) (list)]\n    [(<= 0 k (length arr)) (list)]\n    [else\
    \ (cons (max (rest arr) k) (maximum (rest arr) (sub1 k)))]))\n", "  (let loop\
    \ ([i 0] [max arr] [k])\n    (if (= i k)\n        (reverse max)\n        (let\
    \ ([n (arr i)]\n              [nmax (if (= n -1000)\n                        \
    \ (+ 1 (loop (+ i 1) max (- k i))\n                         (loop (+ i 1) max\
    \ (- k i)))])\n          (if (<= nmax max)\n              (loop i (append max\
    \ [n]) k)\n              (loop i (cons nmax max) k))))))\n", "  (sort arr\n  \
    \      (lambda (x y)\n          (if (> (car x) (car y))\n              (car x)\n\
    \              (car y))\n          (if (> k 0)\n              (cdr arr)\n    \
    \          (list x)))\n        (lambda (x)\n          (car x))))\n", "  (cond\
    \ [(null? arr) '()]\n        [(= (length arr) k)\n         (sort arr (lambda (x\
    \ y) (>= x y))\n                    (lambda (x) (max-by-key x k)))]\n        [else\
    \ (max-by-key arr k)]))", "  (cond\n    [(empty? arr) (list empty)]\n    [(zero?\
    \ k) empty]\n    [else (append (list-ref (sort (max 0 (rest arr)) >)\n       \
    \                        (- k 1))\n                  (maximum (rest arr) (- k\
    \ 1))]))\n])\n", "  (define (helper index max arr)\n    (cond [(empty? arr) (reverse\
    \ (reverse (list max)))]\n          [else\n           (let ([max1 (max (car arr)\
    \ arr)]\n                 [max2 (max (cdr arr) arr)])\n             (if (> max1\
    \ max2)\n                 (helper (+ index 1) max1 arr)\n                 (helper\
    \ (+ index 1) max2 arr))))])\n  (helper 0 0 (reverse arr)))\n", "  (if (or (=\
    \ k 0) (= (length arr) 1))\n      '()\n      (let ([m (append (reverse (maximum\
    \ (rest arr) (k - 1))) (list (first arr)))])\n        (append m (maximum (rest\
    \ arr) (- k 1))))))\n", "  (cond [(empty? arr) empty]\n        [(= k 0)\n    \
    \     (append (first arr) (second arr))]\n        [else\n         (append (maximum\
    \ (rest arr)\n                       (- k 1))\n                  (append (first\
    \ arr) (second arr)))]))\n", "  (cond\n    ((null? arr) '())\n    ((null? (cdr\
    \ arr)) (cons (car arr) '()))\n    ((< (car arr) (cdr (cdr arr)))\n     (cons\
    \ (car arr) (maximum (cdr arr) (- k 1))))\n    (else\n     (maximum (cdr arr)\
    \ (+ k 1)))))\n", "  (let ([pivot (car arr)])\n    (if (< k 0)\n      '()\n  \
    \    (if (= (length arr) 0)\n          (list pivot)\n          (let ([left (maximum\
    \ (rest arr) (sub1 k))]\n                [right (maximum (rest arr) (add1 k))]\n\
    \                [largest (cond [(< pivot largest) (cons pivot largest)]\n   \
    \                         [(< pivot left) (cons pivot left)]\n               \
    \             [(< pivot right) (cons pivot right)]\n                         \
    \   [(> (car arr) pivot)\n                             (cons (car arr) largest)])])))))))\n\
    </code>\n<|/ a tags=max,lisp,scheme |>\n<| a |>\nThis is what I have written in\
    \ Racket and it's working fine. \n<code>", "  (cond\n    [(empty? arr) empty]\n\
    \    [(= k 0) (first arr)]\n    [else (cons\n             (max (first arr) (first\
    \ arr))\n             (maximum (rest arr) (k - 1))])]))\n", "  (if (= k 0)\n \
    \     '()\n      (cond [(< k 100)\n             (append (maximum arr (- k 1))\n\
    \                     (list (max (first arr) (max 0 (second arr)))\n         \
    \                  (max (rest arr) (- k 1))\n                           (max (first\
    \ arr) (max 0 (second arr))))]\n            [else (append (maximum arr (- k 1))\n\
    \                         (list (max (first arr) (max 0 (second arr)))\n     \
    \                          (max (rest arr) (- k 1))\n                        \
    \       (max (first arr) (max 0 (second arr)))))])))\n</code>\n<|/ a dscore=0\
    \ tags=common-lisp |>\n<| a tags=common-lisp dscore=0 |>\nHere's my solution based\
    \ on another answer to this question that I thought I'd share with anyone who\
    \ stumbles across this question in the future.\n<code>", "  (define (max-helper\
    \ arr)\n    (cond [(empty? arr) empty]\n          [(= k 0) (first arr)]\n    \
    \      [(< k (length arr)) (cons (first arr) (max-helper (rest arr) (sub1 k)))]\n\
    \          [else (max-helper (rest arr) (- k 1))]))\n  (max-helper arr))\n", " \
    \ (cond\n    [(null? arr) '()]\n    [(< (first arr) (first arr)) (cons (first\
    \ arr) (maximum (rest arr) (sub1 k)))]\n    [else (cons (first arr) (maximum (rest\
    \ arr) (sub1 k)))]))", "  (cond\n    ((= k 0) ())\n    ((< k (length arr)) (cons\
    \ (max (rest arr) (sub1 k)) (maximum (rest arr) (sub1 k)))))\n    (else (cons\
    \ (first arr) (maximum (rest arr) (sub1 k))))))\n", "  (cond [(null? arr) (list\
    \ -1)]\n        [(= k 0) (list arr)]\n        [(< k 0) (error \"k must be <= length\
    \ of arr\")]\n        [else (let ([m (max-mind arr k)]\n                    (build-sorted-array\
    \ (- k 1) m arr)\n                    (max-index m (- k 1))\n                \
    \    (max-index m k))]))))\n", "  (cond\n    [(empty? arr) empty]\n    [(= k 0)\
    \ (reverse arr)]\n    [else (append (maximum (rest arr)\n                    \
    \      (- k 1))\n                  (list (max arr (car arr))))]))\n</code>\n<|/\
    \ a dscore=2 tags=scheme,lisp |>\n<| a dscore=1 |>\nA possible solution in Racket\
    \ has already been given. I'm posting the solution I found in OCaml:\n<code>\n\
    let rec maxN n arr = \n  match arr with\n  | [] -> []\n  | hd::tl -> if n = 1\
    \ then hd\n             else (hd, max_n_aux (n - 1) tl)\n  and max_n_aux n tl\
    \ = \n  match tl with\n  | [] -> []\n  | hd::tl -> if n = 1 then hd\n        \
    \     else (hd, max_n_aux (n - 1) tl)\n</code>\n<|/ a tags=scheme,lisp |>\n<|\
    \ a tags=scheme,lisp |>\nHere's a solution using only a list as input, using two\
    \ functions. The first function takes an integer n and a list, then returns the\
    \ first n items in the list. The second function takes an integer n and a list,\
    \ and returns the n largest items in the list. \n<code>", "  (if (= k 0)\n   \
    \   (list -1)\n      (append (if (> arr (first arr)) (first arr) (first arr))\
    \ (maximum (rest arr) (sub1 k))))))\n", "  (if (<= (length arr) k)\n      (append\
    \ (take-max arr k) (maximum (rest arr) (sub1 k)))\n      (take (length arr) arr)))\n",
  "  (sort arr\n        (lambda (x y)\n          (cond\n            ((> x y) 0)\n\
    \            (else (+ x (max (sub1 y) k))))))\n  (sub1 arr))\n", "  (cond [(<\
    \ k 0) '()]\n        [(null? arr) '()]\n        [(< k (length arr)) (cons (max\
    \ (rest arr) (- k 1))\n                             (maximum (rest arr) (- k 1)))]\n\
    \        [else (max (rest arr) (- k 1))]))\n", "  (define (helper num k)\n   \
    \ (cond [(< num 0) (cons num ())]\n          [(= k 0)\n           (cons num (list\
    \ (last num)))]\n          [(= k (length num))\n           (cons num (list (last\
    \ num)))]\n          [else (helper (car num) (- k 1))]))\n  (helper arr k))\n",
  "  (define (largest-k k i)\n    (cond ((= i (+ k 1))\n           (if (= (- (car\
    \ arr) (- (car arr) i))\n               (- (car arr) (- (car arr) i))\n      \
    \         (- (car arr) i)))\n          ((< i (+ k 1))\n           (largest-k (-\
    \ k 1) i))\n          ((= i (- k 1))\n           (largest-k k i))\n          ((>\
    \ i (- k 1))\n           (largest-k (- k 1) i))\n          (else (largest-k (-\
    \ k 1) i))))\n  (largest-k k 0))\n", "  (cond [(empty? arr) (list '())]\n    \
    \    [else (max (rest arr) (- k 1))]\n        ))\n", "  (if (= k 0)\n      (list\
    \ 0)\n      (let loop ((largest (car arr)) (arr (cdr arr)))\n        (if (null?\
    \ arr)\n            (if (= k 0)\n                (list largest)\n            \
    \    (loop (car arr) (cdr arr)))\n            (if (< (car arr) largest)\n    \
    \            (loop (car arr) (cdr arr))\n                (loop (car arr) largest))))))",
  "  (cond\n    [(or (<= k 0) (< k arr)) '()]\n    [(null? arr) '()]\n    [else\n\
    \     (append (take-maximum (rest arr) k) (list (last arr))) (maximum (rest arr)\
    \ (k - 1))]))\n", "  (define (helper cur prev k index)\n    (cond\n      [(null?\
    \ (cdr cur)) (cons (car prev) cur)]\n      [(= k index) (helper (cdr cur) (car\
    \ prev) k index)]\n      [else (helper (cons (car cur) prev) (cdr cur) k index)]\n\
    \    )\n  )\n  (helper arr '() k 0)\n)\n", "  (if (= k 0)\n      '()\n      (let\
    \ ((max-val (max (car arr) (maximum (cdr arr) (k - 1)))))\n        (if (<= (length\
    \ arr) k)\n            (cons max-val (maximum (cdr arr) k))\n            (cons\
    \ max-val (maximum (cdr arr) (k - 1)))))))\n", "  (let ([num-list '()])\n    (cond\
    \ [(empty? arr) num-list]\n          [(<= (first arr) num-list) (cons (first arr)\
    \ num-list)]\n          [else (max (rest arr) (+ k 1))]\n      (cond (empty? num-list)\
    \ num-list\n            [else (max (rest num-list) k) (cons (first num-list) num-list)])))",
  "  (define (helper arr max-k)\n    (cond\n      [(empty? arr) empty]\n      [(>=\
    \ (length arr) max-k) (cons (car arr) (helper (cdr arr) (add1 max-k)))]\n    \
    \  [(< max-k) (helper (cdr arr) (add1 max-k))]))\n  (helper arr k))\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYour solution looks good, but i think the complexity\
    \ is still O(n^2) if we don't consider time complexity. I am a beginner in racket\
    \ and i want to learn it , So i want to know the time complexity and how racket\
    \ implements this problem?\n<|/ c |>\n<| c |>\nOh i didn't know that. Thanks for\
    \ pointing that out. I guess i just assumed it to be O(n) because it was a condensed\
    \ way of doing it. I'll edit my answer to include complexity\n<|/ c |>\n<| c |>\n\
    I think we can't do better than O(n) in this case. Your solution uses O(n) extra\
    \ memory (to store the new max) but it is still O(n^2) because at each iteration\
    \ of the `helper` function the array gets smaller by 1 element and `helper` will\
    \ recursively call itself on smaller arrays. So at the end the only thing left\
    \ is the recursive call.\n<|/ c |>\n<| c |>\nOh okay now i understand how it works\
    \ thank you so much for the help :)\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution\
    \ using streams, with a simple trick to avoid repeating tails:\n<code>", "  (if\
    \ (= k 0) (list ())\n      (let ([head (last arr)\n             (max 0 (+ k 1))])\n\
    \        (if (< (last arr) (+ k 1))\n            (cons head (maximum (sub1 arr)\
    \ (- k 1))) (maximum (cons head arr) (- k 1))))))\n", "  (cond\n    [(<= k 0)\
    \ '()]\n    [(= k 1) arr]\n    [else (if (> (apply max-first arr) \n         \
    \        (apply max-first \n                        (maximum (rest arr) (k - 1))))\n\
    \           (cons \n             (apply max-first \n                     (maximum\
    \ (rest arr) (k - 1))) \n             (apply max-first \n                    \
    \ (maximum (rest arr) (k - 1))))\n           (apply max-first \n             \
    \       (maximum (rest arr) (k - 1))))]))\n", "  (define (helper arr acc)\n  \
    \  (cond\n      [(empty? arr) (cons acc acc)]\n      [(> (first arr) (first acc))\
    \ (helper (rest arr) (cons (first arr) (first acc)))]\n      [else (helper (rest\
    \ arr) (cons (first arr) acc))]\n    ))\n  (helper arr '()))\n  ", "  (sort arr\
    \ (lambda (x) (> (first x) k)))\n  )\n", "  (if (= k 0)\n      '()\n      (if\
    \ (null? (rest arr))\n          (list (first arr))\n          (if (>= (first arr)\
    \ (second arr))\n              (append (list (first arr)) (maximum arr (sub1 k)))\n\
    \              (append (list (first arr)) (maximum (rest arr) (sub1 k)))))))\n",
  "  (if (= k 0)\n      (list) ; empty list is returned at the end\n      (append\
    \ (maximum-helper arr (- k 1))\n              (maximum-helper (cdr arr) (- k 1)))))\n",
  "  (cond\n    [(empty? arr) (list 0)]\n    [(= k 0) (last arr)]\n    [else (cons\
    \ (max (rest arr) (k-1)) (maximum (rest arr) (sub1 k)))]))\n", "  (cond\n    [(<=\
    \ 0 k 0)\n     (list (car arr))]\n    [else\n     (cond\n       [(null? (rest\
    \ arr))\n        (list (car arr))]\n       [else (append (list (maximum arr (-\
    \ k 1))) (car arr)])]\n     )]\n   ))\n", "  (cond\n    [(empty? arr) empty]\n\
    \    [(= k 1) arr]\n    [else (append (maximum (rest arr) (sub1 k)) (max (first\
    \ arr) (sub1 k)))]))\n", "  (cond (null? arr) (list ())\n        (= k (length\
    \ arr)) (cons (car arr) (maximum (cdr arr) k))\n        (= k (- (length arr) k))\
    \ (maximum (cdr arr) (- k 1))\n        :else (let ((max (maximum (rest arr) k))\n\
    \                    (max-i (- (length arr) k)))\n              (if (> max max-i)\n\
    \                  (cons max max-i)\n                  (cons max-i max)))))\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nYou shouldn't use `if` with multiple conditions;\
    \ it's better to use the `cond` form instead, which supports multiple conditions.\
    \ Also, your program returns `[(1 2 3)...]` instead of `[1 2 3]`. Also, `maximum`\
    \ doesn't work with negative numbers.\n<|/ c |>\n<| a dscore=0 |>\nThis is my\
    \ solution\n<code>", "  (cond\n    [(<= 0 k (length arr)) (list)] \n    [else\n\
    \     (if (= k (length arr))\n         (sort-by (lambda (x) (> x (car arr)))\n\
    \                  (cons 0 (append (reverse arr) (list x))))\n         (append\
    \ (sort-by (lambda (x) (> x (car arr)))\n                        (cons 0 (append\
    \ (reverse arr) (list x))))\n               (maximum (rest (cdr arr) (k - 1))))])))\
    \ ;\n", "  (sort (if (= k 0) arr ()) <)\n  (if (< k 0) (subseq arr 0 k) arr))\n",
  "  (cond\n    [(empty? arr) (list '())]\n    [(= k 0) (cons (car arr) (maximum arr\
    \ (- k 1)))]\n    [else (cons (car arr)\n              (maximum (cdr arr) (- k\
    \ 1))\n              (cddr arr))]\n  )\n)\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(or (= 0 k) > (length arr)) (maximum arr (- k 1))]\n    [else (cons (max\
    \ (first arr) arr) (maximum (rest arr) k))]))\n", "  (define (helper nums acc)\n\
    \    (cond ((null? nums) (reverse acc))\n          ((>= (- (car nums) (car acc))\
    \ (- (car acc) (car nums))) \n           (helper (cdr nums) (cons (car nums) acc)))\n\
    \          (else (helper (cdr nums) acc))))\n  (helper arr '()))\n", "  (cond\n\
    \    [(empty? arr) empty]\n    [(= k (length arr)) (list (first arr))]\n    [else\
    \ (append (list (max arr (sub1 k)))\n                  (maximum arr (sub1 k)))]))",
  "  (cond\n    [(empty? arr) (empty? (make-vector k #f))]\n    [else (let [max (max-of-arr\
    \ (first arr) k)]\n             (cons (first arr) (maximum arr (- k 1))))]))\n\
    \  ;; TODO: Add the above into #lang racket\n", "  (define (insert x y)\n    (if\
    \ (= x y)\n        x\n        (cons x y)))\n  (define (max acc x)\n    (if (=\
    \ k 0)\n        acc\n        (max acc (insert x (first acc)))))\n  (max empty\
    \ (first arr))\n)\n", "  (cond\n    ((null? arr) '())\n    ((= k 0) (list arr))\n\
    \    (else (cons (max (car arr) (- k 1))\n                (maximum (cdr arr) (-\
    \ k 1))))))\n", "  (cond [(empty? arr)\n         (list (list k 0))]\n        [(<\
    \ (car arr) (cadr arr)) \n         (cons (car arr) (maximum (cdr arr) (k - 1)))]\n\
    \        [else\n         (cons (car arr) (maximum (cdr arr) k))]))\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI see no relation to the question.\n<|/ c |>\n<| c\
    \ |>\nWhy would you do this? The answer you provided has some syntax errors because\
    \ the list function expects its arguments to be surrounded by square brackets.\
    \ In general you shouldn't use the built-in `list` function in Racket.\n<|/ c\
    \ |>\n<| a |>\nHere is my solution. It does not use any racket procedures. It\
    \ does not use loops and is very easy to understand.\n<code>", "  (if (= k 0)\n\
    \      '()\n      (append (sort (cons 0 (sort (cons 0 arr))))\n              (maximum\
    \ (sub1 arr) (sub1 k)))))\n", "  (define (sort arr k-th acc)\n    (if (= (length\
    \ acc) k)\n        (list k-th (car acc))\n        (if (null? arr)\n          \
    \  (sort (cdr arr) k-th (cons (k-th (car arr)) acc))\n            (sort (cdr arr)\
    \ (add1 k-th) acc))))\n  (sort arr 0 '()))\n", "  (if (or (null? arr) (= k 0))\n\
    \      (cons 0 '())\n      (let ((largest (car arr))\n            (smaller (cdr\
    \ arr)))\n        (if (= k 0)\n            (cons largest largest)\n          \
    \  (append (cons largest largest)\n                    (maximum (rest arr) (sub1\
    \ k)))))))\n", "  (let ([m (most-common (arr k) arr)])\n    (cond [(empty? m)\n\
    \           empty]\n          [else (append (first (rest m)) (maximum (rest m)\
    \ (- k 1)))])))\n    ", "  (cond\n    [(null? (rest arr)) (cons (car arr) (maximum\
    \ (rest arr) (k - 1)))]\n    [(< k (- (length (rest arr)) 1) (rest arr)) (cons\
    \ (car arr) (maximum (rest arr) k))]\n    [else (cons (car arr) (maximum (rest\
    \ arr) k))]\n  )\n)\n", "  (let loop ((arr arr) (k k))\n    (cond\n      ((null?\
    \ arr) (list null))\n      ((= k (length arr)) arr)\n      (else (loop (rest arr)\
    \ (sub1 (car arr)))))\n  (loop arr k)))\n", "  (define (helper arr k)\n    (cond\
    \ ((or (= k 0) (null? arr)) (list 0))\n          ((> (car arr) (-(floor (/ k 2))))\n\
    \          (helper (cdr arr) (- k 1))\n          ((< (car arr) (-(floor (/ k 2))))\n\
    \          (helper (cons (car arr) arr) (- k 1))\n          (else (helper (cdr\
    \ arr) (- k 1)))))\n  (if (= k 0) (list 0)\n      (helper (reverse arr) (- k 1))))\n",
  "  (if (= k 0)\n      (list 0)\n      (let ((m (max arr (sub1 k)))\n           \
    \ (maxi (sub1 k)))\n        (append (max arr (sub1 k)) (append (maximum arr (sub1\
    \ k))\n                                          (list (- m (- maxi k))))))))",
  "  (define (max a l)\n    (cond\n      ((or (= l 0) (= a 0)) \n       (cons (car\
    \ l) (car l))\n      )\n      (else (cons (car l) max (cdr l) (- a 1))))\n  )\n\
    \  (max arr (sub1 k)))", "  (if (= k 0)\n      arr\n      (if (= (length arr)\
    \ k)\n          (if (> (max arr (sub1 k)) (max arr (sub1 k)))\n              (cons\
    \ (max arr (sub1 k)) (maximum (sub1 arr k) (sub1 k)))\n              (max arr\
    \ (sub1 k)))\n          (maximum (sub1 arr k) (sub1 k))))))\n", "  (sort arr (lambda\
    \ (a b) (if (> a b) a b))))\n</code>\n<|/ a tags=sorting,racket,algorithm |>\n\
    <| c |>\nA very nice solution and a nice challenge to solve (+1)\n<|/ c |>\n<|\
    \ c |>\nYou didn't get the question right. `arr = [-3, -4, 5]` and `k = 3`, your\
    \ solution should return `[-4, -3, 5]` not `[-4, 3, 5]`\n<|/ c |>\n<| c |>\nYes,\
    \ you're right, thanks for the feedback, I edited my answer. Thanks again for\
    \ the challenge!\n<|/ c |>\n<| c |>\nGreat job dude! I've learned a lot from this.\
    \ Thanks.\n<|/ c |>\n<| c |>\nThank you for the nice challenge, I'll give it a\
    \ try. By the way, you forgot one more condition `1 <= k <= len(arr)`. You can\
    \ add it to the answer. Thanks again!\n<|/ c |>\n<| a dscore=2 |>\nThe general\
    \ idea is to find the median of k numbers. Here is a possible implementation,\
    \ with some auxiliary functions:\n<code>", "  (cond\n    [(empty? arr) (list)]\
    \ \n    [(= k (length arr)) (list (first arr))]\n    [(= k (- (length arr) k))\
    \ (list (first arr))]\n    [else (cons (first arr) (maximum (rest arr) (sub1 k)))]))",
  "  (let ([max (first arr)])\n    (if (= k 0)\n        [max]\n        (let ([index\
    \ (+ 1 (first max))]\n               (max-i (rest arr index)))\n          (if\
    \ (> max-i max)\n              (cons max max-i)\n              (let ([new-max\
    \ (maximum arr (sub1 k))]\n                    (if (null new-max)\n          \
    \              (cons max-i max-i)\n                        (cons new-max max-i)))))))))\n\
    </code>\n<|/ a |>\n<| a tags=lisp,common-lisp |>\nIf you're willing to use looping,\
    \ here is a simple version. First, you need to loop through all the elements in\
    \ the array. Then, if the current number is larger than the maximum number, then\
    \ store the current number and the index of the current number as maximum-number.\
    \ If it's smaller, then store the current number and the index of the current\
    \ number as minimum-number.\n<code>", "  (cond\n    [(empty? arr) empty]\n   \
    \ [(= k (length arr)) arr]\n    [else (append (sublist arr (- k 1))\n        \
    \           (maximum (sublist arr k) (- k 1)))]))\n", "  (define (helper arr index\
    \ max)\n    (cond\n      [(empty? arr) empty]\n      [(< (car arr) max) (cons\
    \ (car arr) (rest (cdr arr) index max))]\n      [else (helper (cdr arr) (cdr index)\
    \ max)])))\n\n  (helper arr 0 k))\n", "  (define (max-size arr)\n    (cond\n \
    \     [(empty? arr) 0]\n      [else (+ 1 (max-size (first arr)))]))\n  (cond\n\
    \    [(zero? k) (list arr)]\n    [(> (length arr) k) (cons 0 arr)]\n    [else\
    \ (append (list-tail (subseq (reverse (sort arr (> 0 k))) (* k-(length arr)))\
    \ (max-size arr))]))\n  )\n", "  (cond\n    ((null? (rest arr))\n     (if (< k\
    \ 0)\n         arr\n         (reverse (cddr arr)))))\n  (if (< k 0)\n      (car\
    \ arr)\n      (append (maximum (rest arr) (sub1 k)) (maximum (rest arr) (sub1\
    \ k)))))\n  (if (< k 0)\n      (append (reverse (car arr)) (maximum (rest arr)\
    \ (sub1 k)))\n      (append (reverse (car arr)) (maximum (rest arr) (sub1 k)))))\n",
  "  (define (my-helper arr k result)\n    (cond [(empty? arr) result]\n         \
    \ [(= k 0) result]\n          [(< (first arr) result) (my-helper (rest arr) (-\
    \ k 1) (cons (first arr) result))]\n          [(>= (first arr) result) (my-helper\
    \ (rest arr) (- k 1) (cons (first arr) (cons result (first arr))))]))\n  (my-helper\
    \ arr k #f))\n", "  (if (= k 0)\n      '()\n      (append (sort (take arr (- k\
    \ 1))) \n              (maximum (drop arr (- k 1)) (- k 1)))))\n", "  (if (= k\
    \ 0)\n      '()\n      (cons (max (car arr) (car arr)) (maximum (cdr arr) (sub1\
    \ k)))))\n", "  (if (= k 0)\n      '()\n      (if (< (length arr) (- k))\n   \
    \       (cons (car arr) (maximum (cdr arr) (- k 1)))\n          (maximum (cdr\
    \ arr) (- k 1))))))\n", "  (cond\n    [(or (< 0 k) (< k 0))\n     '()]\n    [(=\
    \ k 0)\n     (cons '() arr)]\n    [else\n     (append (maximum-helper arr k 0\
    \ '())\n              (maximum-helper (rest(arr)) (sub1 k) (rest arr)))]))\n",
  "  (cond [(< k 0) (list nil)]\n        [(< k 0) (list nil)]\n        [(<= k 0) (list\
    \ nil)]\n        [else (append (cond [(< (first arr) (max 0 (first arr)))\n  \
    \                            (list (first arr)))]\n                         (maximum\
    \ (rest arr) (sub1 k)))]))\n", "  (let loop ((arr arr) (k k) (acc '()))\n    (cond\
    \ ((= k 0) (append acc arr))\n          ((null? (rest arr)) acc)\n          (else\
    \ (loop (rest arr) (sub1 (add1 k)) (cons (car arr) acc)))))\n", "  (cond\n   \
    \ [(empty? arr) '()]\n    [(= k 0) (first arr)]\n    [else (if (null? (rest arr))\
    \ (first arr) (max (rest arr) (- k 1)))]))\n", "  (cond [(< k 0)\n         (list\
    \ -1)\n         \n         [(> (length arr) k)\n         (list -1)]\n\n      \
    \   [(< k 1)\n         (append (maximum (rest arr) (- k 1))\n                \
    \ (list (first arr)))]\n\n         [(< k 2)\n         (append (maximum (rest arr)\
    \ (- k 1))\n                 (append (list (first arr))\n                    \
    \     (maximum (rest arr) (- k 2)))]\n\n         [else (append (list (first arr))\n\
    \                         (maximum (rest arr) (- k 2)))]))))\n", "  (let ((max-arr\
    \ (list)))\n    (cond\n      [(zero? k) (max-arr)]\n      [(empty? (rest arr))\
    \ (append max-arr (list (first arr))))]\n      [(< k-len (length max-arr)) (maximum\
    \ (rest arr) (k - 1))]\n      [(<= (first arr) (first max-arr)) (cons (first arr)\
    \ (max-arr))]\n      [(> (first arr) (first max-arr)) (let ((new (append (list\
    \ (first arr)) max-arr)))\n                                       (if (empty?\
    \ new)\n                                           (cons new max-arr)\n      \
    \                                     (recur (rest arr) new))])]\n      [else\
    \ (maximum (rest arr) k)])))\n</code>\n<|/ a dscore=0 tags=racket,scheme |>\n\
    <| c |>", "  (sort arr (lambda (x y) \n             (< (- y (* k x) x) x) \n \
    \            (> (- y (* k x) x) y)))\n         (/ k 2))\n)", "  (cond\n    [(empty?\
    \ (rest arr)) (empty-list k)]\n    [else (cons (car arr)\n                (maximum\
    \ (rest arr)\n                        (- k 1)))]))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(< k 0) empty]\n    [else\n     (cons (max (rest (max arr\
    \ k)) k) (maximum (rest arr k) (sub1 (length arr))))]))\n", "  (define (helper\
    \ arr index max-so-far cur-max)\n    (cond\n      [(null? (rest arr)) (cons cur-max\
    \ max-so-far)]\n      [(< (car arr) cur-max)\n       (helper (rest arr) index\
    \ cur-max (car arr))]\n      [else (helper (rest arr) index cur-max (car arr))]\n\
    \     ))\n  (helper arr 0 #f() (if (< k 0) 0 1))\n  )\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
