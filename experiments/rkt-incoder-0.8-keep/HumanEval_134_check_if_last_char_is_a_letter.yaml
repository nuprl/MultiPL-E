name: HumanEval_134_check_if_last_char_is_a_letter
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns True if the last character\n\
  ;; of a given string is an alphabetical character and is not\n;; a part of a word,\
  \ and False otherwise.\n;; Note: \"word\" is a group of characters separated by\
  \ space.\n;; Examples:\n;; check_if_last_char_is_a_letter(\"apple pie\") \u279E\
  \ False\n;; check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n;; check_if_last_char_is_a_letter(\"\
  apple pi e \") \u279E False\n;; check_if_last_char_is_a_letter(\"\") \u279E False\n\
  (define (check_if_last_char_is_a_letter txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n\
  \    (check-equal? (candidate \"apple\") #f)\n    (check-equal? (candidate \"apple\
  \ pi e\") #t)\n    (check-equal? (candidate \"eeeee\") #f)\n    (check-equal? (candidate\
  \ \"A\") #t)\n    (check-equal? (candidate \"Pumpkin pie \") #f)\n    (check-equal?\
  \ (candidate \"Pumpkin pie 1\") #f)\n    (check-equal? (candidate \"\") #f)\n  \
  \  (check-equal? (candidate \"eeeee e \") #f)\n    (check-equal? (candidate \"apple\
  \ pie\") #f)\n    (check-equal? (candidate \"apple pi e \") #f)\n))\n\n(test-humaneval)"
completions: ["  (if (char-alphabetic? (last txt))\n      (not (keyword-symbol? txt))\n\
    \      (check-keyword txt)))\n", "  (= txt (substring (string (substring txt (-\
    \ 1 txt)) (length txt)) (length txt))))\n)\n", "  (cond\n    ((string-empty? txt)\
    \ #f)\n    ((string-tail-has-space txt) #f)\n    ((string-ref-char txt (string-length\
    \ (string-ref txt (- 1 (string-length (string-ref txt 0)))))) \n     (char=? (string-ref-char\
    \ txt (string-length (string-ref txt (- 1 (string-length (string-ref txt 0))))))\
    \ #\\a))\n    ((string-ref-char txt (string-length (string-ref txt (- 1 (string-length\
    \ (string-ref txt 0)))))) \n     (char=? (string-ref-char txt (string-length (string-ref\
    \ txt (- 1 (string-length (string-ref txt 0)))))) #\\b))\n    ((string-ref-char\
    \ txt (string-length (string-ref txt (- 1 (string-length (string-ref txt 0))))))\
    \ \n     (char=? (string-ref-char txt (string-length (string-ref txt (- 1 (string-length\
    \ (string-ref txt 0)))))) #\\c))\n    ((string-ref-char txt (string-length (string-ref\
    \ txt (- 1 (string-length (string-ref txt 0)))))) \n     (char=? (string-ref-char\
    \ txt (string-length (string-ref txt (- 1 (string-length (string-ref txt 0))))))\
    \ #\\d))\n    ((string-ref-char txt (string-length (string-ref txt (- 1 (string-length\
    \ (string-ref txt 0)))))) \n     (char=? (string-ref-char txt (string-length (string-ref\
    \ txt (- 1 (string-length (string-ref txt 0)))))) #\\e))\n    ((string-ref-char\
    \ txt (string-length (string-ref txt (- 1 (string-length (string-ref txt 0))))))\
    \ \n     (char=? (string-ref-char txt (string-length (string-ref txt (- 1 (string-length\
    \ (string-ref txt 0)))))) #\\f))\n    ((string-ref-char txt (string-length (string-ref\
    \ txt (- 1 (string-length (string-ref txt 0)))))) \n     (char=? (string-ref-char\
    \ txt (string-length (string-ref txt (- 1 (string-length (string-ref txt 0))))))\
    \ #\\n))\n    ((string-ref-char txt (string-length (string-ref txt (- 1 (string-length\
    \ (string-ref txt 0)))))) \n     (char=? (string-ref-char txt (string-length (string-ref\
    \ txt (- 1 (string-length (string-ref txt 0)))))) #\\v))\n    ((string-ref-char\
    \ txt (string-length (string-ref txt (- 1 (string-length (string-ref txt 0))))))\
    \ \n", "  (equal? (string-last-char txt) (string-char (string->list txt))\n  \
    \       (string->list txt)))\n", "  (cond [(empty? txt) #f]\n        [(equal?\
    \ (last txt) #\\a) false]\n        [(equal? (last txt) #\\z) false]\n        [(equal?\
    \ (last txt) #\\A) false]\n        [(equal? (last txt) #\\Z) false]\n        [(equal?\
    \ (last txt) #\\_) false]\n        [else (equal? (last txt) #\\space) false]\n\
    \        [else (equal? (last txt) #\\tab) false]\n        [else (equal? (last\
    \ txt) #\\newline) false]\n        [else (equal? (last txt) #\\return) false]\n\
    \        [else (equal? (last txt) #\\newline) false]\n        [else (equal? (last\
    \ txt) #\\tab) false]\n        [else (equal? (last txt) #\\space) false]\n   \
    \     [else (equal? (last txt) #\\tab) false]\n        [else (equal? (last txt)\
    \ #\\space) false]\n        [else (equal? (last txt) #\\tab) false]\n        [else\
    \ (equal? (last txt) #\\space) false]\n        [else (equal? (last txt) #\\tab)\
    \ false]\n        [else (equal? (last txt) #\\space) false]\n        [else (equal?\
    \ (last txt) #\\tab) false]\n        [else (equal? (last txt) #\\space) false]\n\
    \        [else (equal? (last txt) #\\tab) false]\n        [else (equal? (last\
    \ txt) #\\space) false]\n        [else (equal? (last txt) #\\tab) false]\n   \
    \     [else (equal? (last txt) #\\space) false]\n        [else (equal? (last txt)\
    \ #\\tab) false]\n        [else (equal? (last txt) #\\space) false]\n        [else\
    \ (equal? (last txt) #\\tab) false]\n        [else (equal? (last txt) #\\space)\
    \ false]\n        [else (equal? (last txt) #\\tab) false]\n        [else (equal?\
    \ (last txt) #\\space) false]\n        [else (equal? (last txt) #\\tab) false]\n\
    \        [else (equal? (last txt) #\\space) false]\n        [else (equal? (last\
    \ txt) #\\tab) false]\n        [else (equal? (last txt) #\\space) false]\n   \
    \     [else (equal? (last txt) #\\tab) false]\n        [else (equal? (last txt)\
    \ #\\space) false]\n        [else (", "  (and (char=? (substring txt (- 1 (string-length\
    \ txt))) (aref (array->list (array->string '(\"a\")) 0))\n         (char=? (substring\
    \ txt (- 1 (string-length txt))) (aref (array->list (array->string \"AEIOUaeiou\"\
    ) 0))\n         (char=? (substring txt (- 1 (string-length txt))) (aref (array->list\
    \ (array->string \"aeiou\") 0))\n         (char=? (substring txt (- 1 (string-length\
    \ txt))) (aref (array->list (array->string \"AEIOUaeiou\") 0))\n         (char=?\
    \ (substring txt (- 1 (string-length txt))) (aref (array->list (array->string\
    \ \"a\") 0)))\n  (not (and (char=? (substring txt (- 1 (string-length txt))) (aref\
    \ (array->list (array->string \"a\")) 0))\n           (char=? (substring txt (-\
    \ 1 (string-length txt))) (aref (array->list (array->string \"AEIOUaeiou\") 0))\n\
    \           (char=? (substring txt (- 1 (string-length txt))) (aref (array->list\
    \ (array->string \"aeiou\") 0))\n           (char=? (substring txt (- 1 (string-length\
    \ txt))) (aref (array->list (array->string \"AEIOUaeiou\") 0))\n           (char=?\
    \ (substring txt (- 1 (string-length txt))) (aref (array->list (array->string\
    \ \"a\") 0))))))\n", "  (cond [(string-length? txt 0)\n         #f]\n        [(and\
    \ (character? (car txt))\n              (not\n               (in-word\n      \
    \          (strip-word (car txt))\n                (cdr txt))))\n         #t]\n\
    \        [(and (character? (car txt))\n              (in-word\n              \
    \ (strip-word (car txt))\n               (cdr txt)))\n         #f]\n        [else\
    \ (check_if_last_char_is_a_letter (cdr txt))]))\n", "  (cond [(empty? txt) #false]\n\
    \        [(equal? (last txt) ?a) (not (starts-with? (last txt) #?a))]))", "  (if\
    \ (equal? (last txt) alpha)\n      (not (member? (last txt) word))\n      #f))\n",
  "  (cond [(empty? txt) #f]\n        [(last (car txt)) (eqv? (car (car txt)) (last\
    \ (cdr txt)))]\n        [else #t]))\n", "  (let ((last-char (string-ref txt -1)))\n\
    \    (cond ((char=? last-char ?A) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?Z) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?a) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?z) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?0) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?9) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?_) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?-) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?_) (check-if-last-char-is-a-word-letter txt))\n\
    \          ((char=? last-char ?-) (check-if-last-char-is-a-word-letter txt))\n\
    \          (else (check-if-last-char-is-a-word-letter txt))))\n", "  (equal? (string-last-char\
    \ txt) (string-ref txt -1)))\n", "  (and (char->integer (last txt)) ; Convert\
    \ to integer\n       (not (number? (last txt))))) ; Is not an integer\n</code>\n\
    <|/ a tags=racket,lisp,scheme |>\n<| c |>\nThis is great! Thank you very much\
    \ for the answer. I really need to learn more about list comprehensions and other\
    \ functions.\n<|/ c |>\n<| a tags=racket,lisp,scheme |>\nFor a purely functional\
    \ solution (without recursion), use this:\n<code>", "  (cond [(empty? txt) #f]\n\
    \        [(equal? (last txt) ?a)\n         (not (member (last txt) '(? a e i o\
    \ u y AE AI EE II OI UY YA YE YI YO)))]\n        [else (check_if_last_char_is_a_letter\
    \ (rest txt))]))\n", "  (cond\n    [(empty? txt) #f]\n    [(last? (string->list\
    \ txt)) #f]\n    [(member (string->list txt) (alphabet)) #f]\n    [(member (string->list\
    \ txt) (word \"#\")) #f]\n    [else #t]))\n", "  (cond\n    [(empty? txt) empty]\n\
    \    [(equal? (last txt) space) empty]\n    [else (if (char? (last txt))\n   \
    \           (and (char->integer (last txt)) \n                   (not (member\
    \ (last txt) '(a e i o u y A E I O U Y)))\n               (not (member (last txt)\
    \ '(o u y A E I O U Y))))]))\n</code>\n<|/ a tags=scheme |>\n<| c |>\nThank you!\
    \ I appreciate the detailed answer. The code I posted was just an attempt to be\
    \ thorough. I'm learning Racket, which is why the code is so similar. I do have\
    \ one more question regarding the code. I know that `char->integer` expects an\
    \ argument that is itself a character, but what would be the best way to make\
    \ such a conversion? My thought was to convert it to an integer, subtract its\
    \ ASCII value, and add it back again afterwards, but I'm not sure if that is correct.\n\
    <|/ c |>\n<| c |>", "  (cond\n    [(or (char-alphabetic? txt) (string-empty? txt))\
    \ False]\n    [(equal? (string-last txt) (char-alphabetic? txt)) True]\n    [else\
    \ (check_if_last_char_is_a_letter txt)]\n  )\n)\n", "  (let ((chars (string->list\
    \ (string->symbols txt))))\n    (loop for (char-pos (length chars)-1 downto 0)\n\
    \          (not (member char-pos chars))))\n", "  (or (char-alphabetic (char-last-char\
    \ txt))\n      (string-last-char txt #\\Space)))\n", "  (cond\n    [(empty? txt)\
    \ (display \"False\")\n     (display \"True\")\n    ]\n    [(member (last-char\
    \ txt) (list->string (map (lambda(x) (char->integer x)) (get-all-chars txt))))\
    \ \n     (display \"True\")\n    ]\n    [else (display \"False\")]))\n", "  (let\
    \ loop ((i 0)\n             (cur (string/reverse txt)))\n    (cond\n      [(empty?\
    \ cur) false]\n      [(equal? (char/lower-case cur) empty?) false]\n      [(equal?\
    \ (string/last cur) empty?) (loop (+ i 1) (append (list cur) '()))]\n      [(char/lower-case\
    \ (string/last cur)) true]\n      [else (loop (+ i 1) (append (list cur) '()))]\n\
    \      )))\n", "  (and (char-alphabet (car txt)) (not (contains-space (cdr txt))))\n\
    )\n", "  (cond\n    ((empty? txt) '#f)\n    ((char=? (last txt) (char-alphabetic))\
    \ (not (starts-with? (last txt) \" \"))) #t\n    (else '#f)))\n", "  (cond\n \
    \   [(empty? txt) #f]\n    [(is-letter? (last txt)) #t]\n    [else (check_if_last_char_is_a_letter\
    \ txt)]));;#lang racket\n", "  (cond\n    [(empty? txt) false]\n    [(char? txt)\
    \ (char-before (last txt) alphabet) ]\n    [else false]))\n", "  (if (null? txt)\
    \ false\n      (let* ((last-char (last txt))\n             (last-char-alph (char->integer\
    \ last-char))\n             (last-char-alph-alph (char->integer last-char-alph))\n\
    \             (last-char-alph-alph-alph (char->integer last-char-alph-alph))\n\
    \             (last-char-alph-alph-alph-alph (char->integer last-char-alph-alph-alph))\n\
    \             (last-char-alph-alph-alph-alph-alph (char->integer last-char-alph-alph-alph-alph))\n\
    \             (last-char-alph-alph-alph-alph-alph-alph (char->integer last-char-alph-alph-alph-alph-alph))\n\
    \             (last-char-alph-alph-alph-alph-alph-alph-alph (char->integer last-char-alph-alph-alph-alph-alph-alph))\n\
    \             (last-char-alph-alph-alph-alph-alph-alph-alph-alph (char->integer\
    \ last-char-alph-alph-alph-alph-alph-alph-alph-alph))\n             (last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph\
    \ (char->integer last-char-alph-alph-alph-alph-alph-alph-alph-alph))\n       \
    \      (last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph (char->integer\
    \ last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph))\n            \
    \ (last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph (char->integer\
    \ last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph))\n       \
    \      (last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph\
    \ (char->integer last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph))\n\
    \             (last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph\
    \ (char->integer last-char-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph-alph))\n\
    \             (last-char-", "  (cond\n    [(empty? txt) false]\n    [(not (equal?\
    \ (last (string->list (string->character txt))) ?a)) false]\n    [else true]))\n",
  "  (define lst (reverse (split txt #\\Space)))\n  (check-expect (empty? lst) #f)\n\
    \  (define last_char (cadr lst))\n  (define is_word\n    (let ((word (cdr lst)))\n\
    \      (if (empty? word)\n        #t\n        (let ((c (car word)))\n        \
    \  (cond\n            ((char=? c #\\A) #t)\n            (else #f)))))\n  (check-expect\
    \ (or (char=? last_char #\\A) is_word) #t)\n  (check-expect (not (equal? (car\
    \ lst) last_char)) #t)\n  (check-expect (not (equal? (cdr lst) last_char)) #t))\n",
  "  (if (string? txt)\n      (let ((last_char (string-ref txt (string-length txt)\
    \ -1)))\n        (char=? (last-char-of-group txt last-char) ?a) ; ASCII value\
    \ of 'a'\n        (char=? (last-char-of-group txt last-char) ?z) ; ASCII value\
    \ of 'z'\n        (char=? (last-char-of-group txt last-char) ?A) ; ASCII value\
    \ of 'A'\n        (char=? (last-char-of-group txt last-char) ?Z) ; ASCII value\
    \ of 'Z'\n        (char=? (last-char-of-group txt last-char) ?-) ; ASCII value\
    \ of '-'\n        (char=? (last-char-of-group txt last-char) ?_) ; ASCII value\
    \ of '_')\n        false)\n      false))\n", "  (cond\n    [(empty? txt) False]\n\
    \    [(equal? (first txt) (substring txt (length txt) (length txt)))\n      (empty?\
    \ (rest (rest txt)))]\n    [else (true)]))\n", "  (cond\n    [(string-match \"\
    [a-z][a-z ]+\" txt) (equal? txt (string-sub (string-ref txt (length (string-ref\
    \ txt -1)) 1))) ]\n    [else false]\n   ))\n", "  (let loop ((text txt) (count\
    \ 0) (last #t) (char #f) (temp \"\"))\n    (cond ((null? text) #f)\n         \
    \ ((char? (car text))\n           (let ((char (car text)))\n             (set!\
    \ count (inc count))\n             (if (char=? char #\\a)\n                 (set!\
    \ last #t)\n                 (set! temp (append temp char))\n               (set!\
    \ last (not last))\n             ))\n          ((and (char=? char #\\_)\n    \
    \           (char=? (car text) (cadr text))\n               (not (null? (cdr text))))\n\
    \           (loop (cdr text) (+ count 1) (char=? (car text) (cadr text)) #f (append\
    \ temp (car text))))\n          ((char=? (car text) #\\_)\n           (loop (cdr\
    \ text) (+ count 1) (char=? (car text) (cadr text)) #t (append temp (car text))))\n\
    \          ((not (null? (cdr text)))\n           (loop (cdr text) (+ count 1)\
    \ #t #f (append temp (car text)))))\n    (and last #t)))\n", "  (cond\n    ((string?\
    \ txt)\n     (string-last-char-is-letter txt))\n    ((list? txt)\n     (member\
    \ txt (check-last-char-is-letter-or-not)))\n    (else\n     (false))))\n", " \
    \ (let ((word (split-string (substring txt -1 -1) \" \"))) ;; Remove space\n \
    \     (cond ((char= (char-before (car word) ?a) ?a)\n             (not (member\
    \ (last word) '(\"i\" \"o\" \"u\" \"e\" \"\")))) ;; Not a letter\n           \
    \ (else (not (member (last word) '(\"i\" \"o\" \"u\" \"e\" \"\")))) ;; Alphabetical\n\
    \      (list txt word)))\n", "  (let* ((lst (string-split txt \" \"))\n      \
    \   (last (string-ref lst -1))\n         (char (char->integer (last -1)))\n  \
    \       (isalpha (char-alphabetic? char))\n         (rest (cdr lst)))\n    (and\
    \ (not isalpha)\n         (or (empty? rest)\n             (check-if_last_char_is_a_letter\
    \ rest)))))\n", "  (cond\n    [(char=? txt (last (char-seq-to-list (string->list\
    \ txt))))\n     (and (char=? (last txt) ?a) (not (member (last txt) '(#\\space\
    \ #\\tab #\\newline #\\return)))]\n    [else false]))\n", "  (cond [(empty? txt)\
    \ #f]\n        [(equal? (last txt) ?a) #t]\n        [(equal? (last txt) ?i) #t]\n\
    \        [(equal? (last txt) ?e) #t]\n        [else #f]))\n", "  (let ((last_char\
    \ (car txt))\n        (next_char (cadr txt)))\n    (and (char-alphabetic? last_char)\n\
    \         (not (string-contains? next_char \" \")))\n  )\n)\n", "  (cond [(empty?\
    \ txt) #f]\n        [(not(char?(last txt))) #f]\n        [else (= (last txt) (char\
    \ #\\a))]))\n", "  (equal? (string/last txt) (string/last txt) (string/last txt)\
    \ \n          \"check_if_last_char_is_a_letter: cannot find the last letter of\
    \ the string.\"))\n", "  (= (length txt)\n     (string-length txt)\n     (substring-after\
    \ txt (length txt)))\n  (= (char-alphabetic? (substring txt (length txt)) 0)\n\
    \     (not (string-contains? txt \" \"))))\n", "  (cond\n    ((empty? txt) #t)\n\
    \    ((ends-with? txt \" \") #f)\n    ((char-alphabetic? (last-char (reverse txt)))\
    \ #t)\n    ((char-not-part (last-char (reverse txt)) \" \")) #f\n    (else #f)))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(string-match (regexp-quote (substring txt\
    \ -1 (string-length txt)))\n                    #\"[a-z]+\")\n     (string-match\
    \ (regexp-quote (substring txt -1 (string-length txt)))\n                    #\"\
    ^[a-z]+$\")\n     #f]\n    [else #t]))\n", "  (cond [(empty? txt) #false]\n  \
    \      [(last-char-is-a-letter txt) #true]\n        [(last-char-is-a-letter (substring\
    \ (last txt) 0 1)) false]\n        [else (check-if-last-char-is-a-letter (substring\
    \ (last txt) 0 1))]\n        ))\n", "  (let\n    ((last_char (substring txt (length\
    \ txt) 1)))\n    (cond\n      [(char-whitespace? last_char) false]\n      [(char-letter?\
    \ last_char) false]\n      [(char-digit? last_char) false]\n      [else (true)])))\
    \ ; end cond\n</cell>\n<cell>", "  (let loop ((txt (read-string txt))\n      \
    \       (lst (string->list txt)))\n    (if (or (null? txt)\n            (null?\
    \ lst))\n        #t\n        (and (< (length lst) 3)\n             (char-alphabetic?\
    \ (last lst))\n             (not (string-chars-match? (last lst) #\\Space)))\n\
    \        (loop (substring txt 0 (- (length txt) 1))\n              lst))))\n",
  "  (cond\n    [(equal? (last txt) ?a) (not (equal? (last txt) ?w))] \n    [else\
    \ (check-last-char-is-in-word (last txt))]))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(not (= (length txt) 1)) (not (last-char-is? txt #\\A))]\n    [(last-char-is?\
    \ txt #\\A) (not (last-char-is? (substring txt 0 -1) #\\A))]\n    [(last-char-is?\
    \ (substring txt 0 -1)) #f]\n    [else #t]))\n", "  (cond\n    [(empty? txt) true]\n\
    \    [(char? (last txt)) (cond\n                         [(equal? (last txt) ?a)\
    \ (not (null? (split-at (last txt) 1 true))) false]\n                        \
    \ [(equal? (last txt) ?e) (not (null? (split-at (last txt) 2 true))) false]\n\
    \                         [(equal? (last txt) ?i) (not (null? (split-at (last\
    \ txt) 3 true))) false]\n                         [(equal? (last txt) ?o) (not\
    \ (null? (split-at (last txt) 4 true))) false]\n                         [(equal?\
    \ (last txt) ?u) (not (null? (split-at (last txt) 5 true))) false]\n         \
    \                [(equal? (last txt) ?A) (not (null? (split-at (last txt) 6 true)))\
    \ false]\n                         [(equal? (last txt) ?E) (not (null? (split-at\
    \ (last txt) 7 true))) false]\n                         [(equal? (last txt) ?I)\
    \ (not (null? (split-at (last txt) 8 true))) false]\n                        \
    \ [(equal? (last txt) ?O) (not (null? (split-at (last txt) 9 true))) false]\n\
    \                         [(equal? (last txt) ?U) (not (null? (split-at (last\
    \ txt) 10 true))) false]\n                         [else (true)]) (last txt)]))]\n\
    \    [else false]))\n", "  (and (char-alphabetic? (last txt))\n       (not (word?\
    \ txt (car (reverse txt))))))\n", "  (cond\n    [(empty? txt) #f]\n    [(ends-with?\
    \ (string-ref txt (- 1 (string-length txt))) #\\a) #t]\n    [else #f]\n  ))\n",
  "  (let loop ((text txt)\n             (index 0)\n             (is_letter false))\n\
    \    (cond\n      [(char=? text #\\space)\n       (loop (substring text 0 index)\n\
    \             (+ index 1)\n             true)]\n      [(char=? (char text index)\
    \ #\\a)\n       (loop (substring text 0 index)\n             (+ index 1)\n   \
    \          true)]\n      [(char=? (char text index) #\\z)\n       (loop (substring\
    \ text 0 index)\n             (+ index 1)\n             true)]\n      [(char=?\
    \ (char text index) #\\D)\n       (loop (substring text 0 index)\n           \
    \  (+ index 1)\n             true)]\n      [(char=? (char text index) #\\W)\n\
    \       (loop (substring text 0 index)\n             (+ index 1)\n           \
    \  false)]\n      [(char=? (char text index) #\\s)\n       (loop (substring text\
    \ 0 index)\n             (+ index 1)\n             true)]\n      [else\n     \
    \  (loop (substring text 0 index)\n             (+ index 1)\n             false)]\n\
    \     )\n  )\n)\n", "  (= (length txt)\n     (string-length txt))\n  (not (= (string-ref\
    \ txt (string-length txt)-1) #\\space))\n  (= (string-ref txt (string-length txt)-1)\
    \ #\\letter)\n  (not (member (char->string #\\space) (string-split txt #\\space))))\n",
  "  (define (loop txt)\n    (cond\n      [(empty? txt) #f]\n      [(char->integer\
    \ (last txt)) #t]\n      [else (loop (rest txt))]))\n  (loop (reverse txt)))\n",
  "  (cond\n    [(null? txt) false]\n    [(last-char? txt) (not (last-char-is-word?\
    \ txt txt))]\n    [else (check-if-last-char-is-a-letter (cdr txt))]\n  ))\n",
  "  (and (char= (char-at-pos txt (char-length txt)) #\\A)\n       (not (check_if_last_char_is_a_word\n\
    \               (string->list (string->string txt))))))\n", "  (cond\n    ((=\
    \ (length txt) 0) false)\n    ((char=? (last txt) #\\a) false)\n    ((char=? (last\
    \ txt) #\\z) false)\n    ((char=? (last txt) #\\A) false)\n    ((char=? (last\
    \ txt) #\\Z) false)\n    ((char=? (last txt) #\\0) false)\n    ((char=? (last\
    \ txt) #\\9) false)\n    ((char=? (last txt) #\\8) false)\n    ((char=? (last\
    \ txt) #\\7) false)\n    ((char=? (last txt) #\\6) false)\n    ((char=? (last\
    \ txt) #\\5) false)\n    ((char=? (last txt) #\\4) false)\n    ((char=? (last\
    \ txt) #\\3) false)\n    ((char=? (last txt) #\\2) false)\n    ((char=? (last\
    \ txt) #\\1) false)\n    ((char=? (last txt) #\\0) false)\n    ((char=? (last\
    \ txt) #\\9) false)\n    ((char=? (last txt) #\\8) false)\n    ((char=? (last\
    \ txt) #\\7) false)\n    ((char=? (last txt) #\\6) false)\n    ((char=? (last\
    \ txt) #\\5) false)\n    ((char=? (last txt) #\\4) false)\n    ((char=? (last\
    \ txt) #\\3) false)\n    ((char=? (last txt) #\\2) false)\n    ((char=? (last\
    \ txt) #\\1) false)\n    ((char=? (last txt) #\\0) false)\n    ((char=? (last\
    \ txt) #\\9) false)\n    ((char=? (last txt) #\\8) false)\n    ((char=? (last\
    \ txt) #\\7) false)\n    ((char=? (last txt) #\\6) false)\n    ((char=? (last\
    \ txt) #\\5) false)\n    ((char=? (last txt) #\\4) false)\n    ((char=? (last\
    \ txt) #\\3) false)\n    ((char=? (last txt) #\\2) false)\n    ((char=? (last\
    \ txt) #\\1) false)\n    ((char=? (last txt) #\\0) false)\n    ((char=? (last\
    \ txt) #\\9) false)\n    ((char=? (last txt) #\\8) false)\n    ((char=? (last\
    \ txt) #\\7) false)\n    ((char=? (last txt) #\\6) false)\n    ((char=? (last\
    \ txt) #\\5) false)\n    ((char=? (last txt) #\\4) false)", "  (cond [(empty?\
    \ txt) #false]\n        [(last (last txt)) (or (char->integer last) #false)]\n\
    \        [else (or (char->integer last) #true)]))\n", "  (cond\n    [(empty? txt)\
    \ (equal? #\\False (check-if-last-char-is-a-letter #\\True))\n     (equal? #\\\
    False (check-if-last-char-is-a-letter #\\False))]\n    [(last-char-is-alpha? (last\
    \ txt)) (check-if-last-char-is-a-letter #\\True)\n     (check-if-last-char-is-a-letter\
    \ #\\False)]\n    [else (check-if-last-char-is-a-letter #\\False)]))\n", "  (let\
    \ ((last-char #f))\n    (check-type txt string)\n    (for ((char (reverse txt)))\
    \ (or (or (char-alphabetic? char) (char-part-of-word char))\n                \
    \                            (set! last-char char))))\n    (not last-char))\n",
  "  (cond\n    ((null? txt) #f)\n    ((char? (car txt)) #f)\n    ((equal? (car txt)\
    \ (last txt))\n     (not (check_if_last_char_is_a_word (cdr txt))))))\n", "  (let\n\
    \      ((last-char (string->list txt))\n       (last-char-is-a-letter #f)\n  \
    \     (last-char-is-a-word #f)\n       (word-count 0)\n       (word-index 0)\n\
    \       (word-chars \"\"))\n    (loop\n       with last-char\n       for i\n \
    \      for char\n       for word-chars\n       do\n         (if (string=? char\
    \ last-char)\n             (begin\n               (check-if-last-char-is-a-word\
    \ last-char word-chars)\n               (if (string=? last-char word-chars)\n\
    \                   (begin\n                     (check-if-last-char-is-a-letter\
    \ last-char)\n                     (if (equal? last-char word-chars)\n       \
    \                  (begin (check-if-last-char-is-a-letter last-char)\n       \
    \                        (set! last-char-is-a-letter #t)\n                   \
    \            (return)\n                               (set! word-chars (cons char\
    \ word-chars))\n                               (set! last-char-is-a-word #t)\n\
    \                               (return)\n                               (set!\
    \ word-count (+ 1 (length word-chars))\n                                     (set!\
    \ word-chars (cons char word-chars))\n                                     (set!\
    \ word-index (+ i 1))\n                                     (return)\n       \
    \                          ))\n                     (return)))\n             \
    \  (return))\n         (if (equal? char #\\Space)\n             (begin\n     \
    \          (check-if-last-char-is-a-word last-char word-chars)\n             \
    \  (if (string=? last-char word-chars)\n                   (begin\n          \
    \           (check-if-last-char-is-a-letter last-char)\n                     (if\
    \ (equal? last-char word-chars)\n                         (begin (check-if-last-char-is-a-letter\
    \ last-char)\n                               (set! last-char-is-a-letter #t)\n\
    \                               (return)\n                               (set!\
    \ word-chars (cons char word-chars))\n                               (set! last-char-is-a-word\
    \ #t)\n                               (return)\n                             \
    \  (set! word-count (+ 1 (length word-chars))\n                              \
    \       (set! word-chars (cons char word-chars))\n                           \
    \          (set! word-index (+ i 1))\n                                     (return)\n\
    \                                 ))\n                     (return)))\n      \
    \         (return))\n         (begin\n          (check-if-last-char-is-a-word\
    \ last-char word-chars)\n          (set! last-char (cons char last-char))\n  \
    \        (set! word-count (+ 1 (length word-chars)))\n          (set! word-chars\
    \ (con", "  (cond\n    [(string-length txt <= 0)\n     #f]\n    [(equal? (string-ref\
    \ txt (string-length (string-reverse txt))) '#\\space)\n     #f]\n    [(equal?\
    \ (string-ref txt (string-length (string-reverse txt))) '#\\tab)\n     #f]\n \
    \   [(equal? (string-ref txt (string-length (string-reverse txt))) '#\\newline)\n\
    \     #f]\n    [else\n     (not (equal? (string-ref txt (string-length (string-reverse\
    \ txt))) '#\\space))]))\n", "  (check-type txt String)\n  (let loop ((txt txt)\
    \ (i 0) (c #f))\n    (cond\n      [(or (empty? txt) (eq? (substring (string txt)\
    \ i (- i 1)) #\\s))\n       (not c)]\n      [(char->integer (string-ref txt i))\n\
    \       (loop (string-ref txt (add1 i)) (add1 i) (not c))]\n      [else\n    \
    \   (loop (string-ref txt i) i (not c))]))))\n", "  (cond\n    [(empty? txt) false]\n\
    \    [(string-char-type txt (car txt)) true]\n    [else (and (not (string-char-type\
    \ txt (car txt))) (not (check-if_last_char_is_a_word\n                       \
    \                     (substring (append txt \" \") 0 (- (length txt) 1))))]))\n",
  "  (cond [(string? txt) (check-last-char-is-letter txt)]\n        [else (check-last-char-is-letter\
    \ '\"\")]))\n", "  (cond ((= (length txt) 0)\n         #f)\n        ((= (char-after-last\
    \ (string->list txt) char) '#)\n         #t)\n        (else (check-if-last-char-is-a-word\
    \ (substring txt 0 (- (length txt) 1))))))\n", "  (cond\n    [(equal? txt \"\"\
    ) false]\n    [(empty? txt) false]\n    [(or (char=? (string-ref txt (length (string-ref\
    \ txt -1))) ?a) (char=? (string-ref txt (length (string-ref txt -1))) ?z)) false]\n\
    \    [else true]))\n", "  (equal? (remainder txt 32) 65))\n", "  (and (not (string-empty?\
    \ txt))\n       (character? (last txt))\n       (not (equal? (last txt) (last-char\
    \ (last txt))))))\n", "  (check-type txt string)\n  (or (char? (last txt))\n \
    \     (and (not (string-contains-word? txt last #\\space)) (string-char-upper-case?\
    \ (last txt))))) ;; #lang racket\n", "  (let* ((len (string-length txt))\n   \
    \      (chars (string->list txt)))\n    (cond\n      [(and (= len 0)\n       \
    \     (null? chars))\n       #t]\n      [(or\n          (char? (car chars))\n\
    \          (string-char-at-pos (- len 1) (car chars))\n          (string-char-at-pos\
    \ (- len 2) (car chars)))\n       #t]\n      [else\n       (not (check-if_last_char_is_a_word\
    \ txt))]))) ;; False\n", "  (cond [(null? txt) false]\n        [(equal? (substring\
    \ txt (length (string-upcase txt))) \"\")\n         false]\n        [(equal? (substring\
    \ txt (length (string-upcase txt)) 1) (substring txt (length (string-upcase txt))\
    \ 0))\n         false]\n        [else\n         (let ([char (substring txt (length\
    \ (string-upcase txt)) 1))]\n           (equal? (char->integer char) \n      \
    \             (char->integer (char->integer 'a') \n                      (char->integer\
    \ 'z'))\n           )\n         ]\n       )\n      )\n  )\n", "  (cond [(empty?\
    \ txt) false]\n        [(check-if-last-char-is-letter-test (last txt) (car txt))]))\n",
  "  (if (string-match \"[A-z]$\" (substring txt 0 -1))\n      true\n      false))\n\
    </code>\n<|/ a tags=scheme,lisp,racket |>\n<| a |>\nYou can take advantage of\
    \ R5RS that allows recursive structures and avoid using tail call optimisations\
    \ (TCO)\n<code>", "  (let ((len (string-length txt)))\n    (cond ((= len 0)\n\
    \           (check-for-letter-or-other-character txt 0))\n          ((char? (substring\
    \ txt 0 (- len 1)))\n           (check-for-letter-or-other-character txt 0))\n\
    \          (else\n           (check-for-letter-or-other-character txt (- len 1))))))\n",
  "  (cond\n    ((null? txt) #f)\n    ((equal? (last txt) space) #f)\n    (else\n\
    \     (char=? (last txt) space)\n     (char=? (last txt) #f)\n     #t))))\n",
  "  (cond\n    [(null? txt) false]\n    [(char= (last txt) ?a) (not (in_word ?a txt))]\n\
    \    [else true]))\n", "  (and (= 0 (string-length (string-reverse txt))) \n \
    \      (let loop ((txt-length (string-length (string-reverse txt)))\n        \
    \          (idx 0)\n                  (result #f))\n         (cond ((or (= (modulo\
    \ txt-length 2) 0)\n                   (= (mod txt-length 3) 0))\n           \
    \     (begin\n                  (set! idx (+ idx (string-length txt)))\n     \
    \             (set! result #t))\n                ((string=? (string-ref txt idx)\n\
    \                           #\\a)\n                 (set! result #t))))\n    \
    \       ((or (= (modulo txt-length 1) 0)\n                   (= (mod txt-length\
    \ 2) 0))\n            (begin\n              (set! idx (+ idx (string-length txt)))\n\
    \              (set! result #t))\n           ((string=? (string-ref txt idx)\n\
    \                       #\\z)\n            (set! result #t))\n           ((or\
    \ (= (modulo txt-length 1) 0)\n                   (= (mod txt-length 3) 0))\n\
    \            (begin\n              (set! idx (+ idx (string-length txt)))\n  \
    \            (set! result #t))\n           ((string=? (string-ref txt idx)\n \
    \                      #\\z)\n            (set! result #t))\n           ((or (=\
    \ (modulo txt-length 2) 0)\n                   (= (mod txt-length 3) 0))\n   \
    \         (begin\n              (set! idx (+ idx (string-length txt)))\n     \
    \         (set! result #t))\n           ((string=? (string-ref txt idx)\n    \
    \                   #\\z)\n            (set! result #t))\n           ((or (= (modulo\
    \ txt-length 3) 0)\n                   (= (mod txt-length 3) 0))\n           \
    \ (begin\n              (set! idx (+ idx (string-length txt)))\n             \
    \ (set! result #t))\n           ((string=? (string-ref txt idx)\n            \
    \           #\\z)\n            (set! result #t))\n           ((or (= (modulo txt-length\
    \ 4) 0)\n                   (= (mod txt-length 4) 0))\n            (begin\n  \
    \            (set! idx (+ idx (string-length txt)))\n              (set! result\
    \ #t))\n           ((string=? (string-ref txt idx)\n                       #\\\
    z)\n            (set! result #t))\n           ((or (= (modulo txt-length 5) 0)\n\
    \                   (= (mod txt-length 5) 0))\n            (begin\n          \
    \    (set! idx (+ idx (string-length txt)))\n              ", "  (cond\n    [(empty?\
    \ txt)\n     (false)]\n    [(char-alphabetic? (last txt))\n     (not (member-of\
    \ txt word))]))\n", "  (cond\n    [(empty? txt) false]\n    [(equal? (last txt)\
    \ (char->integer #\\a)) true]\n    [else (check-if-last-char-is-a-letter (rest\
    \ txt))]))\n", "  (let* ((last-char (string/last txt \" \"))\n         (last-char-upper\
    \ (string/upper-case last-char))\n         (last-char-upper-ok (string/includes?\
    \ last-char-upper \"Aa\")))\n    (or (null? txt)\n        (not last-char-upper-ok)))\n",
  "  (cond\n    [(char-alphabetic? txt) false]\n    [(= (length txt) (substring (length\
    \ txt) -1) (substring txt 0 (- (length txt) 1))) true]\n    [else false]))\n",
  "  (define (in_words txt)\n    (string->list\n     (subseq\n      (remove (lambda\
    \ (x)\n                (string-match #px\"\\\\w\" x))\n              txt))))\n\
    \  (and (set->list (in-words (string->list txt))) ; remove duplicates\n      \
    \ (string-match (string->list \"\\\\w\") txt)))\n", "  (cond\n    ((null? txt)\n\
    \     'False)\n    ((char=? (last txt) ?a)\n     (not (char=? (last txt) ?e)))\n\
    \    (else\n     (check_if_last_char_is_a_letter (rest txt)))))\n", "  (let ([char-list\
    \ \n          (substring (check-string-chars txt \" \")\n                   0\
    \ \n                   (check-string-length txt \" \"))])\n    (= (string-length\
    \ char-list) 0)))\n", "  (cond\n    [(empty? txt) false]\n    [(last-char-is-letter?\
    \ (car txt)) true]\n    [(last-char-is-letter? (cdr txt)) false]\n    [else (check_if_last_char_is_a_letter\
    \ (cdr txt))]))\n", "  (if (equal? txt \"\")\n      false\n      (let ((last-char\
    \ last))\n        (if (equal? (substring txt (length txt)) last-char)\n      \
    \      (check-last-char (substring txt (length txt) 1))\n            (check-last-char\
    \ (substring txt 0 last-char))\n        )\n      )\n  )\n)\n", "  (let ((str (string->list\
    \ txt)))\n    (cond ((null? str) #f)\n          ((char=? (last str) (char->integer\
    \ ?a)) #f)\n          ((char=? (last str) (char->integer ?z)) #f)\n          ((char=?\
    \ (last str) (char->integer ?A)) #f)\n          ((char=? (last str) (char->integer\
    \ ?Z)) #f)\n          ((char=? (last str) (char->integer ?0)) #t)\n          (else\
    \ #t)\n    )))\n", "  (or (char=? (char txt #\\Space) (char txt #\\Space))\n \
    \     (char=? (char txt #\\Space) (char txt #\\Upcase))\n      (char=? (char txt\
    \ #\\Space) (char txt #\\Lowercase))\n      (char=? (char txt #\\Space) (char\
    \ txt #\\Alpha))\n      (char=? (char txt #\\Space) (char txt #\\Uppercase))\n\
    \      (char=? (char txt #\\Space) (char txt #\\Number))))\n", "  (cond [(empty?\
    \ txt) #f]\n        [(last-char-alphabetic? (car txt))\n         (not (ends-with?\
    \ txt (cadr txt)))]\n        [else (check_if_last_char_is_a_letter (cdr txt))]))\n",
  "  (cond\n    [(empty? txt) False]\n    [(last-char txt) (not (last-char (string->list\
    \ txt)))]\n    [else (check_if_last_char_is_a_letter (rest txt))]))\n", "  (cond\
    \ ((string? txt) false)\n        ((and (char? (string-ref txt 0))\n          \
    \    (eq? (car txt) (string-ref txt (- 1 (string-length txt))))\n            \
    \  (char? (substring txt (- 1 (string-length txt))))) true)\n        (else (check_if_last_char_is_a_letter\
    \ (substring txt 1)))))\n", "  (let ([chars (split txt \" \")])\n    (not (and\
    \ (= (length chars) 1)\n               (char-not (char-at (last chars) #\\a))\n\
    \               (char-at (last chars) #\\a))))))\n</code>\n<|/ a dscore=1 tags=racket\
    \ |>\n<| a tags=racket dscore=0 |>\nFor an alternative to implementing a solution\
    \ that does not use regular expressions, here is a solution based on recursion\
    \ and loops:\n<code>\n#lang racket\n", "  (let ([last-char (last (string->list\
    \ txt))])\n    (cond\n      [(char=? last-char ?a)\n       (char=? last-char ?b)]\n\
    \      [(char=? last-char ?z)\n       (char=? last-char ?x)]\n      [(char=? last-char\
    \ ?h)\n       (char=? last-char ?s)\n       (char=? last-char ?u)]\n      [(char=?\
    \ last-char ?w)\n       (char=? last-char ?o)\n       (char=? last-char ?p)\n\
    \       (char=? last-char ?d)]\n      [(char=? last-char ?e)\n       (char=? last-char\
    \ ?q)]\n      [else\n       (char=? last-char ?n)]))))\n", "  (and (not (or (char-syntax\
    \ (char-before (last txt) 65) 65) (cdr (cdr txt))))\n       (or (char-syntax (char-before\
    \ (last txt) 97) 97) (cdr (cdr txt))))))\n", "  (or (string-ref txt (length (string-upcase\
    \ txt))) (string-ref txt (length (string-downcase txt)))))\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(not (character? txt)) #f]\n    [(not (list? (last txt))) #f]\n\
    \    [else (and\n          (member (last txt) '(a b c d e f g h i j k l m n o\
    \ p q r s t u v w x y z))\n          (character? (last txt)))))\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(not(last-char? txt)) #t]\n    [(last-char? (string-ref\
    \ txt -1)) #f]\n    [else #t]\n  ))\n", "  (let* ([last-char (last txt)]\n   \
    \      [last-char-is-word (and (char->integer last-char)\n                   \
    \             (= (character-type last-char) #\\space))])\n    (not last-char-is-word)))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(not (character? txt)) #t]\n    [(character?\
    \ (last txt)) (check_if_last_char_is_a_letter txt)]\n    [else (if (last-word\
    \ txt)\n              #t\n              #f)]\n    ))\n", "  (not (= txt \"\")))\n",
  "  (cond\n    ((= (length txt) 1)\n     (= (char-at txt 0) ?a))\n    ((char-at (txt)\
    \ (- 1 (length txt)))\n     (char-at (txt) (- 1 (length txt))))\n    (else\n \
    \    (cond \n      ((char-at (txt) 0)\n       (char-at (txt) (- 1 (length txt)))\n\
    \       #t)\n      ((char-at (txt) (- 1 (length txt)))\n       (char-at (txt)\
    \ (- 1 (length txt)))\n       #t)\n      (else\n       (check-if-last-char-is-a-word\n\
    \        (substring (txt) (- 1 (length txt)))))\n      #f)\n     )))\n", "  (cond\
    \ [(null? txt) #f]\n        [(last-char-is-alphabetical txt) true]\n        [else\
    \ false]))\n", "  (let* ((len (string-length txt))\n         (last-char (string-ref\
    \ txt (- len 1)))\n         (last-char-not-space (or (char-whitespace? last-char)\
    \ false))\n         (last-char-not-letter (not (or (char-alphabetic? last-char)\
    \ last-char-not-space)))\n         (last-char-not-word\n          (and (= len\
    \ 1)\n               (= last-char '_)\n               (not (set? (string-to-list\
    \ txt))))))\n    (= last-char-not-word (not))))\n", "  (cond ((empty? txt) #f)\n\
    \        ((char=? txt (last txt)) #t)\n        (else (check-last-char-is-a-letter\
    \ (rest txt)))))\n", "  (= (length txt) (- 1 (string-length txt)))\n  (char->integer\
    \ (substring (string txt) (- 1 txt))))\n", "  (cond\n    [(empty? txt) #false]\n\
    \    [(alpha? (last (reverse txt))) #false]\n    [else #true]))\n", "  (= txt\n\
    \    (string-ref txt (- (string-length txt) 1)))\n  (string-match #rx\"^[a-z]+$\"\
    \ txt))\n", "  (or (char=? txt #\\Space)\n      (char=? txt #\\UppercaseLetter)\n\
    \      (char=? txt #\\LowercaseLetter)\n      (char=? txt #\\Digit)))\n", "  (cond\n\
    \    ((null? txt) #t)\n    ((char? (car txt)) (char->integer (car txt)) #t)\n\
    \    ((string=? (car txt) (substring txt 0 (string-length txt)))\n     (let ((la\
    \ (length (substring txt 0 (string-length txt))))\n           (r (string-length\
    \ txt)))\n       (char->integer (car txt)) (integer? la r) #t)\n    (else #f)\n\
    \  )\n)\n", "  (and (char=? txt #\\a)\n       (not (char=? (substring txt -1)\
    \ \" \"))))\n", "  (or (char=? txt #\\z)\n      (char=? (string->list txt) (-\
    \ (string->length txt) (length txt))))) ;; <--", "  (= (length txt) (length #\\\
    space))\n  (let loop ((last-char #f)\n             (txt txt))\n    (if (= last-char\
    \ #t)\n        (t\n         (loop (substring txt (- 1 (string-length txt)))\n\
    \               (substring txt 0 1))))\n    (let ((last-char (char-at-pos (string-length\
    \ txt) txt)))\n      (when (char=? (char-upcase last-char) #\\a)\n        (loop\
    \ (substring txt (- 1 (string-length txt)))\n               (substring txt 0 1)))))\n",
  "  (let ((last '())\n        (word (split txt #\\space)))\n    (cond\n      ((null?\
    \ word) last)\n      ((last (last (last (last word)))) last)\n      ((char? (last\
    \ (last word))) (check-char-is-a-letter last))\n      (else (check-char-is-a-letter\
    \ last))))\n", "  (let ((word (words-in-string txt)))\n    (cond\n      [(empty?\
    \ word) false]\n      [(string=? (substring txt (length txt)) (substring word\
    \ (length word))) false]\n      [(string=? (substring txt (length txt)) (substring\
    \ word (length word)))]\n      [else true])))\n</code>\n<|/ a |>\n<| c |>\nThanks,\
    \ this is definitely a better option! I made some slight changes to it, but I'm\
    \ getting a lot of errors when running your code. Can you take a look at the edited\
    \ post and see if you could get it working?\n<|/ c |>\n<| c |>\nOh yes, I see\
    \ what you're doing now. Still working on it. Thanks so much for helping me with\
    \ this!\n<|/ c |>\n<| c |>\nI'm now getting this error after changing `string=?`\
    \ to `string=` - `Error: expecting ';' in input` I've looked into it, and it seems\
    \ that this error is saying that it expects a `;` but instead finds a `[`. Any\
    \ idea on how to fix this?\n<|/ c |>\n<| c |>\nYes, I forgot the first parenthesis\
    \ in `(substring txt (length txt))`. I fixed it in the edit\n<|/ c |>\n<| c |>\n\
    No worries - thanks for helping me out with this :) I'm getting a lot of syntax\
    \ errors now, but I'm hopeful I can fix them by fixing this. Thanks again!\n<|/\
    \ c |>\n<| a dscore=0 |>\nI like Jack's answer best. I just want to mention that\
    \ in lisp you generally want to avoid doing things with list structures like that\
    \ because they tend to have O(n^2) performance. This may or may not be an issue\
    \ for you.\nYou could also use a regexp match to determine if your string contains\
    \ any word characters (letters, numbers, underscores, or hyphens).\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThanks for the tip! I'm pretty new to scheme so I just figured\
    \ I'd try it out, but I'll definitely keep this in mind!\n<|/ c |>\n<| a dscore=0\
    \ tags=racket,scheme |>\nYou have the right idea, you just need to combine it\
    \ all into one function rather than multiple helper functions. Also, rather than\
    \ using length as a parameter, use string-length. Lastly, use string= to compare\
    \ strings rather than string=?, because we're just checking that one substring ",
  "  (cond\n    [(empty? txt) empty]\n    [(equal? (last txt) ?z) empty]\n    [(equal?\
    \ (last txt) ?a) (check-if-last-char-is-a-word (substring txt 0 -1)\n        \
    \                                         (substring txt 1 (length (substring\
    \ txt 0 -1))))]\n    [(equal? (last txt) ?e) (check-if-last-char-is-a-word (substring\
    \ txt 0 -1)\n                                                 (substring txt 1\
    \ (length (substring txt 0 -1))))]\n    [(equal? (last txt) ?i) empty]\n    [(equal?\
    \ (last txt) ?o) empty]\n    [(equal? (last txt) ?u) empty]\n    [(equal? (last\
    \ txt) ?n) empty]\n    [else (check-if-last-char-is-a-word (substring txt 0 -1)\
    \ (substring txt (length (substring txt 0 -1)) 1))]\n    )\n  )\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(not (eq? (last txt) (string-char (char-code (last\
    \ txt)))))\n     (not (member (subseq txt 0 (- (length txt) 1)) \"aeiouy\"))]\n\
    \    [else\n     (check-if-last-char-is-a-letter (subseq txt (- 1 (length txt))))]\n\
    \   ))\n", "  (cond\n    [(empty? txt) #f]\n    [(equal? (string-downcase (last\
    \ txt)) (string-downcase (substring (last txt) (length (last txt)))) #t]\n   \
    \ [else #f]))\n", "  (cond [(string=? (string-ref txt (string-length txt))\n \
    \                 #\\a)\n         #t]\n        [(string=? (string-ref txt (string-length\
    \ txt))\n                  #\\z)\n         #t]\n        [(string=? (string-ref\
    \ txt (string-length txt))\n                  #\\z)\n         #f]\n        [(string=?\
    \ (string-ref txt (string-length txt))\n                  #\\e)\n         #t]\n\
    \        [(string=? (string-ref txt (string-length txt))\n                  #\\\
    i)\n         #t]\n        [(string=? (string-ref txt (string-length txt))\n  \
    \                #\\p)\n         #t]\n        [(string=? (string-ref txt (string-length\
    \ txt))\n                  #\\s)\n         #t]\n        [(string=? (string-ref\
    \ txt (string-length txt))\n                  #\\e)\n         #f]\n        [(string=?\
    \ (string-ref txt (string-length txt))\n                  #\\i)\n         #f]\n\
    \        [(string=? (string-ref txt (string-length txt))\n                  #\\\
    p)\n         #f]\n        [(string=? (string-ref txt (string-length txt))\n  \
    \                #\\s)\n         #f]\n        [else\n         #f]\n      )\n)\n",
  "  (cond\n    ((null? txt) false)\n    ((char=? last txt) #f)\n    ((char=? last\
    \ txt) (char-equal? last 'a))\n    ((char=? last txt) (char-equal? last 'b))\n\
    \    ((char=? last txt) (char-equal? last 'c))\n    ((char=? last txt) (char-equal?\
    \ last 'd))\n    ((char=? last txt) (char-equal? last 'e))\n    ((char=? last\
    \ txt) (char-equal? last 'f))\n    ((char=? last txt) (char-equal? last 'g))\n\
    \    ((char=? last txt) (char-equal? last 'h))\n    ((char=? last txt) (char-equal?\
    \ last 'i))\n    ((char=? last txt) (char-equal? last 'j))\n    ((char=? last\
    \ txt) (char-equal? last 'k))\n    ((char=? last txt) (char-equal? last 'l))\n\
    \    ((char=? last txt) (char-equal? last 'm))\n    ((char=? last txt) (char-equal?\
    \ last 'n))\n    ((char=? last txt) (char-equal? last 'o))\n    ((char=? last\
    \ txt) (char-equal? last 'p))\n    ((char=? last txt) (char-equal? last 'q))\n\
    \    ((char=? last txt) (char-equal? last 'r))\n    ((char=? last txt) (char-equal?\
    \ last 's))\n    ((char=? last txt) (char-equal? last 't))\n    ((char=? last\
    \ txt) (char-equal? last 'u))\n    ((char=? last txt) (char-equal? last 'v))\n\
    \    ((char=? last txt) (char-equal? last 'w))\n    ((char=? last txt) (char-equal?\
    \ last 'x))\n    ((char=? last txt) (char-equal? last 'y))\n    ((char=? last\
    \ txt) (char-equal? last 'z))\n    ((char=? last txt) (char-equal? last 'A))\n\
    \    ((char=? last txt) (char-equal? last 'B))\n    ((char=? last txt) (char-equal?\
    \ last 'C))\n    ((char=? last txt) (char-equal? last 'D))\n    ((char=? last\
    \ txt) (char-equal? last 'E))\n    ((char=? last txt) (char-equal", "  (cond\n\
    \    [(string-length txt) false]\n    [(string-last-char txt) (char->integer (char->string\
    \ txt))\n     (string->list txt)]\n    [else (error 'check-if-last-char-is-a-letter\
    \ txt \"non-alphabetical character\")]))\n", "  (match txt\n    ['() (empty? txt)\n\
    \     [_ (empty? txt)]\n     [_ _ (char->integer (last txt))]\n     [_ (char->integer\
    \ (last txt)) #t]\n     [_ (char->integer (last txt)) #f]\n     [_ (empty? txt)\
    \ #f]\n     ]))\n", "  (and (char=? (string-ref txt (- 1 string->length)) #\\\
    a)\n       (not (null? (string-ref txt (- 1 string->length))))))\n", "  (cond\n\
    \    [(empty? txt) false]\n    [(character? (car txt))\n     (cond [(not (check_if_last_char_is_a_letter\
    \ (cdr txt)))\n            (= (car txt) (car (cdr txt)))]\n           [else true])]\n\
    \    [else false]))\n", "  (cond [(string? txt) (= (length (string-tail txt -1))\
    \ 1)]\n        [(string-contains? \"a b c d e f g h i j k l m n o p q r s t u\
    \ v w x y z\" (car txt)) (= (length (string-tail txt -1)) 0)]\n        [else false]))\n",
  "  (define last\n    (substring txt (length (string-ref txt (length (string-length\
    \ txt)))))\n    (string->list\n     (string->symbol\n      (if (string=? (string-ref\
    \ last 0) (symbol->string '#\\Space))\n          (symbol->string '#\\Space)\n\
    \          (symbol->string '#\\Nonspace))))\n  (if (equal? txt (symbol->string\
    \ '#\\Space))\n      (equal? last '#\\Space)\n      (equal? (string->list (symbol->string\
    \ '#\\Nonspace)) '#\\Nonspace)))\n", "  (define words (make-vector 8 (string-length\
    \ (string-trim txt) 0)))\n  (define (word?\n         (word word)\n         (rest\
    \ str))\n    (cond\n      [(empty? str) (equal? word \"\")]\n      [(char=? (car\
    \ str) word) (equal? word \"\")]\n      [else (word? (rest str) (car str))]))\n\
    \n  (word? (car txt) (cdr txt))\n)\n", "  (let* ((ch (string->character (string->string\
    \ txt))))\n    (if (and (string-endswith txt (character #\\Space))\n         \
    \    (not (character-in-string ch 'word)))\n        (not (character-in-string\
    \ ch 'letter))\n      (boolean->list #f))))\n", "  (or (string=? txt\n       \
    \          \"#\\a\" #\\A #\\b #\\B #\\c #\\C #\\d #\\D #\\e #\\E #\\f #\\F\n \
    \                #\\g #\\G #\\h #\\H #\\i #\\I #\\j #\\J #\\k #\\K #\\l #\\L #\\\
    m\n                 #\\M #\\n #\\N #\\o #\\O #\\p #\\P #\\q #\\Q #\\r #\\R #\\\
    s #\\S #\\t #\\T\n                 #\\v #\\V #\\w #\\W #\\x #\\X #\\y #\\Y #\\\
    z #\\Z)\n      (symbol=? (last txt) #\\a #\\A #\\b #\\B #\\c #\\C #\\d #\\D #\\\
    e #\\E #\\f #\\F\n                 #\\g #\\G #\\h #\\H #\\i #\\I #\\j #\\J #\\\
    k #\\K #\\l #\\L #\\m\n                 #\\M #\\n #\\N #\\o #\\O #\\p #\\P #\\\
    q #\\Q #\\r #\\R #\\s #\\S #\\t #\\T\n                 #\\v #\\V #\\w #\\W #\\\
    x #\\X #\\y #\\Y #\\z #\\Z)))\n", "  (if (string-empty? txt)\n      false\n  \
    \    (let ((l (string/last txt)))\n        (and (char-alphabetic? l) (not (member\
    \ (string/reverse l) '(#\\space #\\newline)))))\n      )\n  )\n", "  (let ((check\
    \ (string/ends-with? txt \"z\")))\n    (cond\n      [(null? txt) #f]\n      [(check-not?\
    \ #t) #f]\n      [(string/match (string/substring txt 0 -1)\n                \
    \      \"[a-h]\") #f]\n      [(string/match (string/substring txt 0 -1)\n    \
    \                  \"[A-H]\") #t]\n      [(string/match (string/substring txt\
    \ 0 -1)\n                      \"[Z]\") #f]\n      [(string/match (string/substring\
    \ txt 0 -1)\n                      \"[z]\") #t]\n      [(string/match (string/substring\
    \ txt 0 -1)\n                      \"[A-Za-z]\") #t]\n      [else #f]\n      ]))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(eq? (last txt) space) #f]\n    [else (eq?\
    \ (last txt) letter)]))\n", "  (cond [(empty? txt) false]\n        [(char? (last\
    \ txt)) (boolean? (check-if-last-char-is-a-word txt))]\n        [else true]))\n",
  "  (cond\n    [(empty? txt) #false]\n    [(equal? (last-char txt) #\\A) #true]\n\
    \    [else #false]))\n", "  (let loop ((lst (split txt #\" \")) (r 0))\n    (cond\
    \ ((null? lst) #t)\n          ((char=? (car lst) ?A) #f)\n          ((char=? (car\
    \ lst) ?Z) #f)\n          ((char=? (car lst) ?a) #f)\n          ((char=? (car\
    \ lst) ?z) #f)\n          ((char=? (car lst) ?0) #f)\n          ((char=? (car\
    \ lst) ?9) #f)\n          ((char=? (car lst) ?-) #f)\n          ((char=? (car\
    \ lst) ?_) #f)\n          ((char=? (car lst) ?+) #f)\n          ((char=? (car\
    \ lst) ?_) #f)\n          ((char=? (car lst) ?!) #f)\n          ((char=? (car\
    \ lst) ?%) #f)\n          ((char=? (car lst) ?&) #f)\n          ((char=? (car\
    \ lst) ?') #f)\n          ((char=? (car lst) ?') #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?%) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?%) #f)\n          ((char=? (car\
    \ lst) ?#) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?$) #f)\n          ((char=? (car\
    \ lst) ?$) #f)\n          ((char=? (car lst) ?", "  (define last-char (substring\
    \ (last txt) 0 -1))\n  (and (not (member (char->string last-char) '(#\\w #\\s)))\
    \ #false))\n            ", "  (cond [(string? txt)\n         (< (string-length\
    \ txt) 1)\n         true]\n        [(character? txt)\n         (or (char-alphabetic?\
    \ (get-char txt)) (check-if-last-char-is-a-word-char (get-char txt)))]\n     \
    \   [else false]))\n", "  (or (char-alphabetic? (last txt))\n      (or (string=?\
    \ (string-ref txt (- 1 (string-length txt)))\n                   (string-append\
    \ (substring txt 0 (string-length txt)))\n                   (string-append (substring\
    \ txt 1 (string-length txt))))))) ;; true\n", "  (cond\n    [(empty? txt) false]\n\
    \    [(character? (last txt))\n     (and (not (word_starts? txt (last txt))) (character?\
    \ (last txt)))]\n    [else (check_if_last_char_is_a_letter txt)]))\n", "  (define\
    \ (helper txt i j) (and (not (empty? txt)) (char= (char-ref txt (+ i 1)) #\\A)))\n\
    \  (define (char_at_end txt) (char= txt #\\Z))\n  (define (char_at_beg txt) (char=\
    \ txt #\\A))\n  (define (char_at_start txt) (char= txt #\\Z))\n  (define (contains_space\
    \ txt) (= i (string-length txt) ))\n  (cond ((helper (reverse txt) i j)\n    \
    \     (if (or_else (helper (reverse txt) (- i 1) j) (helper (reverse txt) (- i\
    \ 1) (+ j 1)))\n             (helper (reverse txt) (- i 1) j)\n             (helper\
    \ (reverse txt) (- i 1) (+ j 1))))\n        ((helper (reverse txt) i j)\n    \
    \     (if (or\n                ((= j 0) (helper (reverse txt) (- i 1) 0))\n  \
    \              (helper (reverse txt) (- i 1) j))\n             (helper (reverse\
    \ txt) (- i 1) j)\n             (helper (reverse txt) (- i 1) (+ j 1))))\n   \
    \     ((char_at_end txt)\n         (if (or_else (char_at_end (reverse txt)) (char_at_end\
    \ (reverse txt) (- i 1)))\n             (char_at_end (reverse txt)) (char_at_end\
    \ (reverse txt) (- i 1))))\n        ((char_at_beg txt)\n         (if (or_else\
    \ (char_at_beg (reverse txt)) (char_at_beg (reverse txt) (- i 1)))\n         \
    \    (char_at_beg (reverse txt)) (char_at_beg (reverse txt) (- i 1))))\n     \
    \   ((char_at_start txt)\n         (if (or_else (char_at_start (reverse txt))\
    \ (char_at_start (reverse txt) (- i 1)))\n             (char_at_start (reverse\
    \ txt)) (char_at_start (reverse txt) (- i 1))))\n        ((contains_space txt)\n\
    \         (if (or\n                ((= j 0) (contains_space (reverse txt) (- i\
    \ 1)))\n                (contains_space (reverse txt) (- i 1))))\n         #t\n\
    \         (helper (reverse txt) (- i 1) j)))\n  (not (null txt)))\n", "  (cond\n\
    \    [(string-chars-including-char \"a\" txt)\n     (not(ends-with? txt (last-char\
    \ txt)))]\n    [else\n     (true)])) ; return true\n</code>\n<|/ a dscore=1 tags=racket,scheme\
    \ |>\n<| c |>\nThanks for your answer but this won't help me in finding the solution\
    \ of my question because I am trying to find a solution based on a specific logic\
    \ not using any library such as \"string\" and \"last\"\n<|/ c |>\n<| c |>\nI\
    \ apologize, that is what I was trying to say. You are correct in that string\
    \ and last are not libraries.\n<|/ c |>\n<| a tags=racket,scheme dscore=0 |>\n\
    This should work:\n<code>", "  (cond\n    ((empty? txt) True)\n    ((char-alphabetic?\
    \ (last txt)) (not (word-ends-with? txt \" \"))))\n  )\n)\n", "  (cond [(empty?\
    \ txt) false]\n        [(char? (last txt)) (char? (last txt))]\n        [else\
    \ (is_word txt)]))\n", "  (cond\n    [(empty? txt)              #t\n     (equal?\
    \ (first txt) #\\space)        #f\n     ]\n    [(equal? (first txt) #\\letter)\
    \ #t\n     (equal? (last (rest txt)) #\\space)        #t\n     ]\n    [(equal?\
    \ (first txt) #\\letter) #f\n     (equal? (last (rest txt)) #\\letter)       \
    \ #f\n     ]\n    [else                          #f\n     ]\n    )\n  )\n", " \
    \ (cond\n    ((equal? txt \"\") False)\n    ((equal? (string-last-char txt) #\\\
    A) (not (equal? (string-last-word txt) #\\A)))\n    (else (check_if_last_char_is_a_letter\
    \ (string-last-word txt))))) ;; #lang racket\n", "  (cond\n    [(char-alphabetic?\
    \ (string-ref txt -1))\n     (string-ref\n      (remove-if\n       (lambda (x)\n\
    \         (not (char-alphabetic? x))\n         (string= txt (string x)))\n   \
    \    txt)\n     ]\n    [t #f]))\n", "  (cond\n    ((empty? txt) empty)\n    ((char?\
    \ (last txt)) (char? (last txt))\n     (not (char? (last txt)))\n     (char? (last\
    \ txt)))\n    ((char? (last txt)) (check_if_last_char_is_a_letter (rest txt))\n\
    \     (empty? (rest txt))\n     (empty? (last txt)))\n    (else (check_if_last_char_is_a_letter\
    \ (rest txt))))\n  )\n", "  (cond ((empty? txt) #f)\n        ((char-alphabetic\
    \ (last (chars-before txt ' ')))\n         (not (member (last txt) '(a e i o u\
    \ y)))\n         #t)\n        (else (check-if-last-char-is-a-letter txt))))\n",
  "  (cond\n    [(empty? txt) false]\n    [(character? txt) false]\n    [(last (split\
    \ txt \" \")) false]\n    [else true]))\n", "  (cond\n    ((empty? txt) #t)\n\
    \    ((equal? txt\n               (substring (length? txt) -1 1))\n     (char->integer\
    \ (last txt)))\n    (else\n     (equal? (check-last-char-is-a-word txt)\n    \
    \       (check-last-char-is-a-word (substring txt (+ 0 (length? txt)))))))\n",
  "  (cond\n    [(empty? txt) empty]\n    [(last (car txt)) (last txt)]\n    [else\
    \ (not\n      (and\n        (char->integer (last txt))\n        (char->integer\
    \ (last txt)) - 26\n        (char->integer (last txt)) - 64\n        (char->integer\
    \ (last txt)) - 96))))])\n", "  (cond [(empty? txt) (check-for-word txt)]\n  \
    \      [(last txt) false]\n        [else (= (last txt) 'a)\n        (= (last txt)\
    \ 'e)\n        (check-for-word (string-replace txt (last txt) \"\"))]))\n", " \
    \ (cond\n    [(empty? txt) #f]\n    [(ends-with? (last txt) (aref (car txt) -1))\n\
    \     (not (check-if-last-char-is-a-word? (first txt)))]\n    [else (check-if-last-char-is-a-word?\
    \ (first txt))]))\n", "  (let ((str (string->list txt)))\n    (cond ((empty? str)\
    \ false)\n          ((not (list->string->list str))\n           (check-for-all-chars-in-str\
    \ (string->string txt))\n           (check-for-all-chars-in-str (string->string\
    \ txt))\n          (else (check-for-all-chars-in-str (string->string txt))))))\n",
  "  (cond\n    [(empty? txt) false]\n    [(last (last txt)) (or (char= (last txt)\
    \ ?A)\n                        (char= (last txt) ?N))]))\n", "  (cond\n    ((empty?\
    \ txt) #f)\n    ((string= (substring (last txt) 0 1) #\\a) #t)\n    ((string=\
    \ (substring (last txt) 0 1) #\\z) #f)\n    (else #f)))\n", "  (cond [(empty?\
    \ txt) false]\n        [(equal? (last txt) #\\A #\\Z ) false]\n        [(equal?\
    \ (last txt) #\\A #\\Z) #false]\n        [(equal? (last txt) #\\A #\\A ) true]))\n",
  "  (let ([last_char (string-last-char txt)])\n    (and (not (member last_char #\\\
    a)) (member last_char #\\w))))\n", "  (cond\n    ((empty? txt)\n     false)\n\
    \    ((char-alphabetic? (last (rest txt))) \n     (not (char-in-word? (last txt))))\n\
    \    (else (check_if_last_char_is_a_letter (rest txt)))))\n", "  (cond\n    [(empty?\
    \ txt)\n     (false)]\n    [(equal? (last txt) ?a)\n     (not(equal? (last txt)\
    \ ?e))]\n    [else\n     (check_if_last_char_is_a_letter (rest txt))]))\n", " \
    \ (let ((chars (string->list txt)))\n    (if (and (null? chars)\n            \
    \ (char->null? chars))\n        #t\n        (let ((last-char (char->string-1 chars)))\n\
    \          (and (char->alphabetic? last-char)\n               (not (string-ref-outside-word?\
    \ last-char txt)))))))\n", "  (cond ((= (length txt) 0) False)\n        ((char->integer\
    \ (last txt)) (= (char->integer (last txt)) #\\space))\n        ((char->integer\
    \ (last (reverse txt))) (not (= (char->integer (last (reverse txt))) #\\space)))\n\
    \        (else (return (boolean (char->integer (last txt)))))\n))\n", "  (let\
    \ ((last-char (string-ref txt -1))) ; Last character\n    (if (char=? last-char\
    \ #\\a) ; Ascii code of alphabet character\n        #f\n        (char=? (aref\
    \ (string last-char #\\Space) #\\a) #f))))\n", "  (cond ((null? txt) #f)\n   \
    \     ((not (equal? (char-after (car txt)) (string #\\A))) #t)\n        (else\
    \ (check-if-last-char-is-a-word (car txt)) (check-if-last-char-is-a-word (cdr\
    \ txt)))))\n", "  (let ([alph-chars '(a b c d e f g h i j k l m n o p q r s t\
    \ u v w x y z)])\n    (check-type txt string)\n    (not (null? txt))\n    (let\
    \ ([last (length txt)])\n      (check-type last integer)\n      (let ([last-char\
    \ (substring txt 0 last)])\n        (check-type last-char character)\n       \
    \ (not (member last-char alph-chars))))))\n", "  (cond\n    [(empty? txt) false]\n\
    \    [(character? (last-char txt)) \n     (not (last_char_is_a_word txt (last-char\
    \ txt)))]\n    [else (check-if-last-char-is-a-letter txt)]))\n", "  (cond [(equal?\
    \ txt \"\")\n         (false)]\n        [(equal? (string-last-char txt) #\\A)\n\
    \         (false)]\n        [else\n         (eqv? (string-last-char txt) #\\A)\n\
    \         (false)]))\n", "  (let* ([last-char (char-at (length txt) txt)]\n  \
    \       [last-char-is-a-word (is-word? (last-char txt))])\n    (and (not last-char-is-a-word)\n\
    \         (char=? (last-char txt) alpha))))\n", "  (define (word txt)\n    (string-match\
    \ (substring txt 0 (string-length txt)) \"[[:alpha:]]+\"))\n  (and (word txt)\
    \ (not (word? (substring txt 1 (string-length txt))))))\n", "  (define (loop txt)\n\
    \    (if (string? txt)\n        (let ((str (string->list txt)))\n          (if\
    \ (string? (car str))\n              (loop (cdr str))\n              (or (char->integer\
    \ (last str))\n                   (char->integer (last str) 26)))\n        false)))\n\
    \  (loop txt))\n", "  (cond\n    [(empty? txt) #f]\n    [(ends-with? (string-last-char\
    \ txt) alphabetical-char) #t]\n    [else (check-if-last-char-is-a-word txt)]))\n",
  "  (define words (string-split-by-space txt))\n  (define last-char (car words))\n\
    \  (define rest (cdr words))\n  (cond\n    [(or (and (char=? (char-code last-char)\
    \ 97) (char=? (char-code last-char) 65)) (string=? rest \"apple\"))\n     (char=?\
    \ (char-code last-char) 65)]\n    [(char=? (char-code last-char) 97)\n     (not\
    \ (char=? (char-code last-char) 65))]\n    [else false]))\n", "  (define (is-last-char-a\
    \ char)\n    (= char (char-code #\\a)))\n\n  (let ((last-char (substring (txt)\
    \ -1)))\n    (cond\n      [(and (char-alphabetic? last-char)\n            (not\
    \ (string-match \"^\\\\w+\" last-char)))\n       (not is-last-char-a)]\n     \
    \ [else (is-last-char-a)]))\n", "  (and (char-alphabetic (string->list (string->string\
    \ txt)))\n       (not (string-contains-word \"a a a a a\" txt))))\n", "  (if (null?\
    \ (string-length txt))\n      #f\n      (and (char=? (string-ref txt (- 1 (string-length\
    \ txt)))\n                  (first-char))\n           (char=? (string-ref txt\
    \ (string-length txt))\n                  last-char))\n      #t))\n", "  (= (char-alphabetic\
    \ (last-char txt)) #t)\n  (not (string-contains? \"word \" txt #:string)))\n",
  "  (cond [(empty? txt) false]\n        [(char txt #\\Space)\n         (not (member\
    \ (char-code txt) #\\Space))]\n        [(char txt #\\Newline)\n         (not (member\
    \ (char-code txt) #\\Newline))]\n        [else\n         (char-alphabetic? (char-code\
    \ txt))]))\n", "  (cond\n    [(empty? txt) false]\n    [(ends-with? txt (last\
    \ txt)) (or (char-alphabetic? (last txt))\n                                (check-if-last-char-is-part-of-a-word\
    \ txt))]))\n", "  (cond\n    [(empty? txt) true]\n    [(last-char-alphabetic?\
    \ txt #\\Space) true]\n    [(last-char-alphabetic? txt #\\Newline) true]\n   \
    \ [(last-char-alphabetic? txt #\\Tab) true]\n    [else false]))\n", "  (cond\n\
    \    [(empty? txt) True]\n    [(ends-with? (substring txt -1 0) (char #\\A)) True]\n\
    \    [else False]))\n", "  (cond\n    ((empty? txt) False)\n    ((string-equal?\
    \ (last txt) #\\a) False)\n    ((string-equal? (last txt) #\\b) False)\n    ((string-equal?\
    \ (last txt) #\\c) False)\n    ((string-equal? (last txt) #\\d) False)\n    ((string-equal?\
    \ (last txt) #\\e) False)\n    ((string-equal? (last txt) #\\F) False)\n    ((string-equal?\
    \ (last txt) #\\G) False)\n    ((string-equal? (last txt) #\\H) False)\n    ((string-equal?\
    \ (last txt) #\\I) False)\n    ((string-equal? (last txt) #\\J) False)\n    ((string-equal?\
    \ (last txt) #\\K) False)\n    ((string-equal? (last txt) #\\L) False)\n    ((string-equal?\
    \ (last txt) #\\M) False)\n    ((string-equal? (last txt) #\\N) False)\n    ((string-equal?\
    \ (last txt) #\\O) False)\n    ((string-equal? (last txt) #\\P) False)\n    ((string-equal?\
    \ (last txt) #\\Q) False)\n    ((string-equal? (last txt) #\\R) False)\n    ((string-equal?\
    \ (last txt) #\\S) False)\n    ((string-equal? (last txt) #\\T) False)\n    ((string-equal?\
    \ (last txt) #\\U) False)\n    ((string-equal? (last txt) #\\V) False)\n    ((string-equal?\
    \ (last txt) #\\W) False)\n    ((string-equal? (last txt) #\\x) False)\n    ((string-equal?\
    \ (last txt) #\\y) False)\n    ((string-equal? (last txt) #\\z) False)\n    ((string-equal?\
    \ (last txt) #\\') False)\n    ((string-equal? (last txt) #\\\") False)\n    ((string-equal?\
    \ (last txt) #\\;) False)\n    ((string-equal? (last txt) #\\.) False)\n    ((string-equal?\
    \ (last txt) #\\,) False)\n    ((string-equal? (last txt) #\\.) False)\n    ((string-equal?\
    \ (last txt) #\\:) False)\n    ((string-equal? (last txt) #\\;) False)\n    ((string-equal?\
    \ (last txt) #\\!) False)\n    ((string-equal? (last txt) #\\?) False)\n    ((string-equal?\
    \ (last txt) #\\;) False)\n    ((string-equal? (last txt) #\\:) False)\n    ((string-equal?\
    \ (last txt) #\\;) False)\n    ((string-equal? (last txt) #\\;) False)\n    ((string-equal?\
    \ (last txt) #\\;) False)\n    ((string-equal? (last txt) #\\;) False)\n    ((string-equal?\
    \ (last txt) #\\;", "  (cond\n    ((null? txt) false)\n    ((char-alphabet (car\
    \ txt))\n     (not (string-contains? txt (car txt))))\n    (else true)))\n", " \
    \ (cond\n    [(empty? txt) False]\n    [(char-alphabetic? (car txt)) (not (char-in-word?\
    \ (car txt)))]\n    [else (check_if_last_char_is_a_letter (cdr txt))]\n  )\n)\n",
  "  (if (empty? txt)\n      #f\n      (or (char=? (last txt) (string-ref txt (- 0\
    \ (string-length txt)))) #t)))\n", "  (= (length txt) (length string))\n  (let\
    \ ((chars (split-string (string txt) \" \"))) ; \"apple\" \"pie\"\n    (or (char-alphabetic?\
    \ (last chars))\n        (last-char-is-a-word chars))))\n", "  (cond ((string-length?\
    \ txt)\n         (string-char-at (string-downcase txt) (string-length txt)))\n\
    \        (else false)))\n", "  (cond [(string? txt) (string-match? last-char txt\
    \ #rx[a-z]) ; Last character must be a letter\n       (string? txt) (equal? (last-char\
    \ txt #rx[a-z]) \"\") ; Last character must not be a letter\n       (string? txt)\
    \ (equal? (last-char txt #rx[[:upper:]])) #t] ; Last character must be a letter\n\
    \       (else #f)]))\n", "  (let ((word (split txt \" \"))\n        (char (last\
    \ word)))\n    (cond\n      [(char=? (char-alphabetic? char) true)\n       (not\
    \ (member? (last word) word))]])))\n", "  (let ((last-char (string-ref txt (-\
    \ (string-length txt) 1))))\n    (cond\n      [(last-char ?a)\n       #f]\n  \
    \    [(last-char ?a ?u ?u ?u ?u ?u ?u ?u ?u)\n       #f]\n      [(last-char ?a\
    \ ?u ?u ?u ?u ?u ?u ?u ?u ?u)\n       #f]\n      [(last-char ?a ?u ?u ?u ?u ?u\
    \ ?u ?u ?u ?u)\n       #t]\n      [(last-char ?a ?u ?u ?u ?u ?u ?u ?u ?u ?u)\n\
    \       #t]\n      [(last-char ?a ?u ?u ?u ?u ?u ?u ?u ?u ?u)\n       #t]\n  \
    \    [(last-char ?a ?u ?u ?u ?u ?u ?u ?u ?u ?u)\n       #t]\n      [else #f])))\n",
  "  (cond ((null? txt) #f)\n        ((char->boolean (last txt)) #t)\n        (else\
    \ (check-if-last-char-is-a-word (last txt))))) ;; #lang racket\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(not (and (char? (last txt))\n               (char-alphabetic?\
    \ (last txt))))\n     (lambda () (check-if_last_char_is_a_letter (substring txt\
    \ 0 (- (length txt) 1)))]\n    [(check-if_last_char_is_a_letter (substring txt\
    \ 0 (- (length txt) 1)))\n     (lambda () (check-if_last_char_is_a_letter (substring\
    \ txt 0 (- (length txt) 1))))]\n    [else #t]\n  )\n)\n", "  (= txt (substring\
    \ txt (length txt) 1))\n  ;; Check whether the last character is a letter or not\n\
    \  ;; Note: This doesn't consider case sensitivity.\n  (and (= (char txt (length\
    \ txt)) (char #\\A (length txt)))))\n", "  (let ([words (split-string (last txt)\
    \ #\\space)]) ; split \"word\" by space\n    (if (null? words)\n      ; empty\
    \ string\n      (or\n       (equal? (first txt) (first words))\n       (equal?\
    \ (first words) (first txt))\n       (equal? (first words) (last txt)))))) ; empty\
    \ word\n", "  (cond [(string=? txt \"\") false]\n        [(string-char=? (string-ref\
    \ txt (string-length txt)) (char #\\a)) false]\n        [else true]))\n", "  (cond\
    \ [(string-empty? txt) #f]\n        [(string-last-char txt) (not (last-char-is-word\
    \ txt))]\n        [(last-char-is-word txt) (not (last-char-is-word txt))]\n  \
    \      [else #t]))\n", "  (let loop ((i 0)\n             (string txt))\n    (cond\n\
    \      [(null? string) false]\n      [(char=? #\\Space (string-ref string i))\n\
    \       (loop (add1 i) (substring string i (length string)))]\n      [else true])))\n",
  "  (cond [(empty? txt) empty]\n        [(equal? (string-ref txt (- 1 (string-length\
    \ txt))) ?a)\n         (not (contains-word (substring (string txt) (- 1 (string-length\
    \ txt)) 1) ?a))\n        ]\n        [else empty]))\n", "  (cond\n    [(empty?\
    \ txt) (eqv? (char (char-before-last txt)) #\\a) (cond [(empty? txt) true]\n \
    \                                                               [(char? (char-after-last\
    \ txt)) false]\n                                                             \
    \   [(char? (char-before-last-spaced txt)) false]\n                          \
    \                                      [(char? (char-before-last-char txt)) true])]\n\
    \    [else (eqv? (char (char-before-last txt)) #\\a) (check_if_last_char_is_a_letter\
    \ txt)]))\n", "  (cond\n    [(empty? txt) False]\n    [(alpha? (last txt)) (check-if-last-char-is-a-word-or-not-in-the-middle?\
    \ txt (last txt))]\n    [else (check_if_last_char_is_a_letter txt)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
