name: HumanEval_130_tri
language: rkt
prompt: "#lang racket\n\n;; Everyone knows Fibonacci sequence, it was studied deeply\
  \ by mathematicians in \n;; the last couple centuries. However, what people don't\
  \ know is Tribonacci sequence.\n;; Tribonacci sequence is defined by the recurrence:\n\
  ;; tri(1) = 3\n;; tri(n) = 1 + n / 2, if n is even.\n;; tri(n) =  tri(n - 1) + tri(n\
  \ - 2) + tri(n + 1), if n is odd.\n;; For example:\n;; tri(2) = 1 + (2 / 2) = 2\n\
  ;; tri(4) = 3\n;; tri(3) = tri(2) + tri(1) + tri(4)\n;; = 2 + 3 + 3 = 8 \n;; You\
  \ are given a non-negative integer number n, you have to a return a list of the\
  \ \n;; first n + 1 numbers of the Tribonacci sequence.\n;; Examples:\n;; tri(3)\
  \ = [1, 3, 2, 8]\n(define (tri n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate tri))\n\
  \    (check-equal? (candidate 3) (list 1 3 2 8))\n    (check-equal? (candidate 4)\
  \ (list 1 3 2 8 3))\n    (check-equal? (candidate 5) (list 1 3 2 8 3 15))\n    (check-equal?\
  \ (candidate 6) (list 1 3 2 8 3 15 4))\n    (check-equal? (candidate 7) (list 1\
  \ 3 2 8 3 15 4 24))\n    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))\n\
  \    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))\n    (check-equal?\
  \ (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))\n\
  \    (check-equal? (candidate 0) (list 1))\n    (check-equal? (candidate 1) (list\
  \ 1 3))\n))\n\n(test-humaneval)"
completions: ["  (if (< n 2)\n      [n]\n      (+ (tri (- n 1)) (tri (- n 2))\n  \
    \       (tri (+ n 1)))))\n", "  (cond ((= n 0) '())\n        (else (append (tri\
    \ (- n 1)) (list (/ n 2))))))\n", "  (let ((i 0) (j (+ i 1))))\n    (if (= i n)\n\
    \      (list i)\n      (let ((x (+ (tri j) (tri (+ j 1))))))\n        (if (even?\
    \ n)\n            (cons (+ i j) x)\n            (cons x i))))))\n", "  (let loop\
    \ ((nth (+ (* 3 2) n) 1)\n              (tri-tail '(1 2 3)))\n    (if (= nth 0)\
    \ tri-tail (recur (sub1 nth) (cons (+ nth 1) tri-tail)))))\n", "  (if (= n 0)\
    \ '())\n  (cons (+ (/ (+ (tri (- n 1)) (tri (- n 2)))\n            (+ n (/ n 2))))\n\
    \        (tri (- n 1))))\n</code>\n<|/ a tags=racket,fibonacci,scheme |>\n<| c\
    \ |>\nIt would be nice if you could add a paragraph or two explaining how this\
    \ works and why it works.\n<|/ c |>\n<| c |>\nI thought that was the intent of\
    \ the question.  I added a description at the bottom of my answer.\n<|/ c |>\n\
    <| c |>\nThe question has been edited to add some explanation; I hope it helps.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's an implementation in Racket that doesn't use\
    \ any special data structures beyond the basic list to keep track of the current\
    \ and previous Fibonacci numbers:\n<code>", "  (if (< n 2)\n      (list n)\n \
    \     (+ (tri (- n 1))\n         (tri (- n 2))\n         (tri (+ n 1)))))\n",
  "  (if (= n 0)\n      '(0 1 2)\n      (cons 3 (+ (tri (sub1 n)) (+ (tri (sub2 n))\
    \ (+ (tri (add1 n)) '()))))))\n", "  (cond\n    [(zero? n) '()]\n    [(even? n)\
    \ (append '() (tri (sub1 n) (+ n 1))) (tri (sub1 n))])\n    [else (tri (sub1 n)\
    \ (+ n 1) (+ (/ n 2) 1))]))\n", "  (if (= n 0)\n      '()\n      (cons (+ (/ n\
    \ 2) 1)\n            (tri (- n 1)))))\n", "  (define (tri n acc a1 a2)\n    (cond\
    \ ((= n 0) (append acc (list a1)))\n          ((even? n) (tri (/ n 2) (cons a\
    \ (+ a1 a2))\n                          (+ a 1) (+ a 2)))\n          (else   \
    \   (tri (- n 1) (cons a a1) a a2))))\n  (tri n '() 0 (+ n 1)))\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=scheme,racket,lisp |>\nThis one will work in Racket,\
    \ which has tail recursion and lists:\n<code>", "  (cond\n    ((= n 0) '())\n\
    \    ((even? n) (cons 1 (tri (sub1 n))))\n    ((odd? n) (tri (sub1 n) (tri (sub1\
    \ n) (tri (add1 n)))))))\n", "  (define (tri-helper i acc)\n    (if (= i 0) acc\n\
    \        (tri-helper (- i 1) (cons i (tri-helper i acc))))))\n  (tri-helper n\
    \ nil))\n", "  (let loop ((i 0) (s 0))\n    (if (= i n)\n        (list s)\n  \
    \      (loop (+ i 1) (+ s (/ i 3))))))\n", "  (if (= n 1)\n      [3]\n      (cons\
    \ ((+ (/ n 2) 1)\n             (tri (- n 1))\n             (tri (+ n 1)))\n  \
    \          (+ n 1)\n            (tri n))))", "  \n  (cond\n    ((= n 0) '(1))\n\
    \    ((= n 1) '(3))\n    ((even? (remainder n 2)) (+ (tri (/ n 2)) (tri (- (+\
    \ n 1) 2))))\n    (else (+ (tri (- n 1)) (remainder (+ n 1) 2)))))\n", "  (if\
    \ (= n 0)\n      (list 1)\n      (append (tri (- n 1)) (tri (- n 2))(tri (+ n\
    \ 1)))))\n\n#lang racket\n", "  (if (< n 3)\n      n\n      (append (+ (* 3 (tri\
    \ (sub1 n)))) (tri (sub1 (+ n 1))))))\n", "  (if (zero? n) '()\n      (cons (+\
    \ (tri (- n 2)) \n              (tri (- n 1))\n              (tri (+ n 1))))\n\
    \      '()))\n", "  (if (or (= n 0) (= n 1))\n      (list n)\n      (+ (tri (/\
    \ n 2)) (tri (- n 1))) (tri (+ n 1))))\n", "  (define (tri-helper a b c)\n   \
    \ (if (= b 0)\n        (cons a c)\n        (tri-helper (+ a c) b (+ b c))))\n\
    \  (tri-helper 3 1 2))\n", "  (cond ((= n 0) '())\n        ((even? (remainder\
    \ n 2)) (cons 1 (tri (sub1 n))))\n        (else (cons 1 (tri (sub1 n) (tri (sub1\
    \ n)))))))\n</code>\n<|/ a |>\n<| a tags=racket,scheme |>\nHere is an efficient\
    \ version using an accumulator to reduce the complexity of the recursion \n<code>",
  "  \n  (if (< n 1)\n      (list 1)\n      (cons (+ (/ n 2) (tri (- n 1)))\n    \
    \        (tri (- n 2))\n            (tri (+ n 1)))))\n\n#lang racket\n", "  (cond\
    \ [(= n 0) (list 3)]\n        [(even? n) (+ 1 (/ (+ (tri (/ n 2)) (tri (- n 1)))\
    \ 2))]\n        [(odd? n) (tri (- n 1)) (+ (tri (+ n 1) (tri (+ n 2)) n))]\n \
    \       [else (error \"Unknown n!\")]))\n", "  (if (= n 0)\n      '()\n      (cons\
    \ \n       (+ (/ n 2)\n          (tri (- n 1))\n          (tri (+ n 1))))\n  ))\n",
  "  (if (even? n)\n      (+ (tri (- n 1) (/ n 2))\n         (tri (- n 2) (+ (/ n\
    \ 2) 1))\n         (tri (+ n 1) (+ (/ n 2) 1))\n         (tri (+ n 2) (+ (/ n\
    \ 2) 1)))\n      (tri (- n 1) (+ (/ n 2) 1)\n           (tri (- n 2) (+ (/ n 2)\
    \ 1))\n           (tri (+ n 1) (+ (/ n 2) 1))\n           (tri (+ n 2) (+ (/ n\
    \ 2) 1)))))\n</code>\nThe above is also the solution for n=3.\n<|/ a dscore=3\
    \ |>\n<| c |>\nWhy `#lang racket` and not `#lang scheme`?\n<|/ c |>\n<| c |>\n\
    I didn't specify this in the question but I am actually using Racket which is\
    \ an implementation of Scheme. The `#lang racket` notation is just another way\
    \ to write the program in a Racket program.\n<|/ c |>\n<| c |>\nThis was the only\
    \ solution I saw which used tail recursion.  It appears that tail recursion is\
    \ a feature of Racket, and it's easy to write tail recursion using Scheme.  I\
    \ used the Racket documentation at http://docs.racket-lang.org/tui/tail-recursion.html\n\
    <|/ c |>\n<| a |>\nThis solution is in C#. \n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace\
    \ Task_9\n{\n    class Program\n    {\n        static void Main(string[] args)\n\
    \        {\n            var result = Calculate(3);\n            Console.Write(result);\n\
    \            Console.Read();\n        }\n\n        static int Calculate(int input)\n\
    \        {\n            int first = 1;\n            int last = 1;\n          \
    \  int result = 0;\n            int i = 0;\n            int index = 0;\n\n   \
    \         if (input < 0)\n            {\n                return result;\n    \
    \        }\n            if (input == 0)\n            {\n                return\
    \ 1;\n            }\n\n            while (i <= input)\n            {\n       \
    \         first = last + first;\n                last = last;\n              \
    \  result += first;\n                i++;\n            }\n            return result;\n\
    \        }\n    }\n}\n</code>\n<|/ a tags=scheme,racket,lisp,functional-programming,python\
    \ dscore=1 |>\n<| a dscore=1 tags=scheme,racket,lisp,functional-programming,python\
    \ |>\n<code>\ndef fib(n):  # return Fibonacci series up to n \n    a, b = ", " \
    \ (if (< n 1)\n      #f\n      (cons 1 \n            (tri (sub1 n))\n        \
    \    (tri (sub2 n))\n            (tri (add1 n)))))", "  (if (even? n)\n      (tri\
    \ (- n 2))\n      (tri (- n 1) (+ n 1) (+ n 2))))\n", "  (cond\n    [(= n 0)\n\
    \     (list 1)]\n    [(even? n)\n     (cons (/ n 2)\n           (tri (sub1 n)))]\n\
    \    [else\n     (tri (sub1 n)\n          (+ n 1)\n          (+ n 2))]))", " \
    \ (define (tri n)\n    (if (< n 1)\n        '()\n        (cons (+ (/ n 2)) (tri\
    \ (- n 1)))))\n  (tri n))\n", "  (if (zero? n)\n      '(1 3 2 8)\n      (cons\
    \ (+ (/ n 2) (/ (+ 1 n) (+ 2 n))) (tri (- n 1)))))\n", "  (if (= n 0) '()\n  \
    \    (cons n (tri (- n 1))\n            (tri (- n 2) (+ n 1))\n            (tri\
    \ (+ n 3) (+ n 2) (+ n 1)))))\n", "  (if (= n 0)\n      [1 3]\n      (tri (sub1\
    \ n) (+ 3 (/ n 2)))))\n", "  (cond [(= n 0) (list 1)]\n        [(even? (- n 1))\n\
    \         (cons (+ (tri (- n 1)) (tri (- n 2))) (+ (tri (+ n 1))\n           \
    \                                       (tri (+ n 2))))]\n        [(odd? (- n\
    \ 1))\n         (cons (+ (tri (- n 1)) (tri (- n 2))) \n               (+ (tri\
    \ (+ n 1))\n                  (tri (+ n 2))))]))\n", "  (if (= n 0) (list 1)\n\
    \      (let ((x (+ (tri (- n 1)) \n                    (tri (- n 2)) \n      \
    \              (tri (+ n 1))))) \n        (list x x x x)))) \n", "  (if (zero?\
    \ n) \n      (cons '() '())\n      (cons (- n (/ (+ (tri (- n 1))\n          \
    \              (tri (- n 2)))\n                    (/ n 2))\n            (tri\
    \ (+ n 1)))))) ", "  (if (= n 0)\n      ;; Base case.\n      []\n      ;; Recursive\
    \ case.\n      (cons (+ (/ 1 2) (tri (- n 1)))\n            (+ (/ 2 3) (tri (-\
    \ n 2))\n                 (+ (/ 3 4) (tri (+ n 1))))))))\n", "  (cond\n    [(=\
    \ n 1) (list 3)]\n    [(= n 2) (list 1 3)]\n    [(even? (remainder n 2)) (cons\
    \ (+ (tri (- n 1)) (tri (- n 2))) (cons (tri (- n 1)) (tri (- n 2))))]\n    [else\
    \ (cons (+ (tri (- n 1)) (tri (- n 2))) (cons (tri (- n 1)) (tri (- n 2))))]))\n",
  "  (if (= n 2)\n      [3]\n      (cons 1 (tri (- n 2)) (tri (+ n 1)))))\n", "  (cond\n\
    \    ((= n 1) '(1))\n    ((= n 2) '(1 2))\n    (else (+ (tri (- n 1)) (tri (-\
    \ n 2))\n             (tri (+ n 1))))))\n", "  (cond ((= n 0) '())\n        (else\
    \ (cons (+ (/ n 2) (tri (- n 1))) (tri (+ n 1))))))\n", "  (cond [(= n 0) (list\
    \ 3)]\n        [(= n 1) (list 1)]\n        [(even? n) (+ (tri (- n 2)) (tri (+\
    \ n 1)))]\n        [(odd? n) (+ (tri (- n 1)) \n                    (tri (- n\
    \ 2)) \n                    (tri (+ n 1)))]))\n", "  (cond ((= n 0) (list 1))\n\
    \        ((= n 1) (list 3))\n        (else (+ (tri (- n 1))\n                \
    \ (tri (- n 2))\n                 (tri (+ n 1))))))\n", "  (if (zero? n)\n   \
    \   '()\n      (+ (tri (/ n 2))\n         (tri (- (+ n 1) 2))\n         (tri (+\
    \ n 1)))))\n", "  (let ([a (1)\n         b ((/ (+ 1 n) 2)\n             a)\n \
    \        c ((/ (+ 1 n) 3)\n             b)\n         d (- c a)])\n    (cond [(even?\
    \ n)\n           (cons b c)\n           (cons c d)]\n          [else (cons a (+\
    \ b c))]))\n", "  (if (= n 1)\n      [3]\n      (+ (tri (- n 1)) \n         (tri\
    \ (- n 2)) \n         (tri (+ n 1)))))\n", "  (cond\n    [(zero? n) '()]\n   \
    \ [(= (modulo n 2) 0) (list n (+ n 1))]\n    [(= (modulo n 2) 1) (list n (+ n\
    \ (/ n 2))) (+ n (/ n 2))])) ;; (+ n (/ n 2))]", "  (cond\n    [(= n 0) '(1 3)]\n\
    \    [(even? n) (tri (/ n 2)(+ 1 (/ n 2) (/ n (+ 1 2)))]\n    [else (tri (- n\
    \ 1) (+ (- n 1) (- n 2) (+ n 1)))]))\n</code>\n<|/ a tags=scheme |>\n<| c |>\n\
    I tried to improve the solution and make it more general. Is it ok? I hope so.\
    \ Thanks!\n<|/ c |>\n<| a dscore=0 tags=scheme |>\n<code>", "  (cond\n    [(=\
    \ n 0) (cons 0 '(1 3 2 8))]\n    [(even? (/ n 2)) (cons (+ (/ n 2) (/ n 1 2))\
    \ (tri (- n 1)))]\n    [(odd? (/ n 2)) (cons (tri (- n 1)) (+ (/ n 1) (/ n 1 2)))]))\n\
    </code>\n<|/ a |>\n<| c |>\nThank you, that's a nice solution. Is it possible\
    \ to make code more concise with only one `cond`?\n<|/ c |>\n<| c |>\nYes, of\
    \ course it is possible. I can post a one-liner example for you if you want.\n\
    <|/ c |>\n<| c |>\nThanks, I think I'll try one :)\n<|/ c |>\n<| a tags=racket,recursion,scheme\
    \ |>\nOne possible way to do this in Racket:\n<code>", "  (define (tri-helper\
    \ n a b c sum)\n    (if (= n 0) (list sum)\n        (tri-helper (- n 1) a b (+\
    \ c a) sum)\n    )\n  )\n  (tri-helper n 1 1 1 (+ n 1))\n)\n", "  (cond\n    ((=\
    \ n 0) (list 1))\n    ((odd? n) (cons (+ (tri (- n 1))\n                     \
    \   (tri (- n 2)))\n                   (tri (+ n 1))))\n    (else (cons (+ (tri\
    \ (- n 1))\n                    (tri (- n 2)))\n               (tri (+ n 1))))))\n",
  "  (if (= n 0)\n      '()\n      (cons (+ (/ n 2) (tri (- n 1)))\n            (tri\
    \ (- n 2)))))\n", "  (if (zero? n) \n      (list)\n      (+ (tri (- n 1)) (tri\
    \ (- n 2)) (tri (+ n 1)))))\n", "  (if (= n 1)\n      (list 3)\n      (+ (tri\
    \ (- n 1)) (tri (- n 2)) (tri (+ n 1)))))\n", "  (cond [(= n 0) (list 1)]\n  \
    \      [(even? n) (+ (tri (/ n 2)) (tri (- n 1)))]\n        [else (tri (- n 1))\n\
    \              (tri (- n 2)) \n              (tri (+ n 1))]))\n", "  (cond [(=\
    \ n 0) (list 1)]\n        [(= n 1) (list 3)]\n        [(even? n) (cons (+ tri\
    \ (/ n 2)) (tri (- n 1)))]\n        [(odd? n) (tri (- n 1)) (+ (tri (+ n 1) (tri\
    \ (- n 2)))]))) \n", "  (cond\n    [(= n 0) (list 3)]\n    [(even? n) (cons (+\
    \ (/ 2 n) tri (- n 1))) (cons tri (+ 1 n))]\n    [(odd? n) (cons (+ (/ 2 n) tri\
    \ (- n 1)) (cons (+ 1 n) tri))]\n    [else (cons (+ (/ 2 n) tri (- n 1)) (cons\
    \ (+ 1 n) tri) (cons (+ n 1) (tri n))]))) ; this line is for my IDE; remove it\
    \ after code finishes\n", "  (cond\n    [(= n 1) '(1)]\n    [(even? n) (cons 1\
    \ (tri (sub1 n)))]\n    [(odd? n) (cons (tri (sub1 n)) (tri (sub1 n)))]\n    [else\
    \ (tri (sub1 n)) (tri (sub1 n))]))\n", "  (cond ((= n 0) '(1 2 3))\n        ((even?\
    \ n) (+ 3 (tri (/ n 2))))\n        (else (+ 3 (tri (- n 1))\n                \
    \   (tri (+ n 1)))))))\n", "  (if (= n 1)\n      (list 3)\n      (+ (tri (- n\
    \ 1)) (tri (- n 2)) (tri (+ n 1)))))", "  (cond\n    [(= n 0) (list 3)]\n    [(even?\
    \ (remainder n 2)) (cons (+ n (/ n 2)) (tri (- n 1)))]\n    [(odd? (remainder\
    \ n 2)) (tri (+ n 1) (+ n 1) (+ n 1))]))\n", "  (cond [(= n 0) '()]\n        [(=\
    \ n 1) '(1)]\n        [(= (modulo n 2) 1) (tri (sub1 n) (+ (sub1 n) (/ n 2)))]\n\
    \        [else (tri (sub1 n) (+ (sub1 n) (/ n 2))) (tri (sub1 n) (+ (sub1 n) (/\
    \ n 2)))]))\n", "  (let ((tri1 3) (tri2 1))\n    (cond\n      ((zero? n) '())\n\
    \      ((odd? n) (+ (tri1 tri2) tri2))\n      (else (+ (tri1 tri2) (tri2 (tri1\
    \ tri2))))))))\n", "  (if (= n 1)\n      (list)\n      (cons (+ (tri (- n 1))\
    \ (tri (- n 2))) (tri (+ n 1)))))", "  (if (= n 1)\n      [3 1]\n      (+ \n \
    \      (tri (- n 1)) (/ n 2))))\n", "  (if (even? n) (+ (/ 3 2) (tri (- n 2)))\
    \ (tri (+ n 1))))\n", "  (if (= n 0) \n      [1]\n      \n      (append \n   \
    \    (tri (- n 1)) \n       (tri (- n 2) (+ n 1))\n       (tri (- n 3) (+ n 2)\
    \ (+ n 1)))))\n", "  (cond [(= n 0) '()]\n        [(= n 1) '(3 1)]\n        [(=\
    \ (remainder n 2) 0) (cons (+ (/ n 2) (/ n 2)) (+ (/ n 3) (/ n 3)))]\n       \
    \ [else (cons (+ (/ n 3) (/ n 2)) (tri (- n 1)))]))\n", "  (if (= n 0)\n     \
    \ (list)\n      (cons (+ (/ n 2) 1 (/ n 3))\n            (tri (- n 1))\n     \
    \       (tri (+ n 1)))))\n</code>\n<|/ a dscore=0 tags=racket,scheme |>\n<| a\
    \ dscore=0 tags=racket,scheme |>\nScheme has many functions to calculate fibonacci\
    \ numbers. Here is an implementation with Racket that uses tail-recursion:\n<code>",
  "  (cond [(= n 1) '(3 1)]\n        [(= n 2) '(1 3 1)]\n        [(even? n) (tri (sub1\
    \ n) (tri (sub1 n) (tri (add1 n))))]\n        [(odd? n) (tri (add1 n) (tri (add1\
    \ n) (tri (sub1 n))))]))\n", "  (if (= n 0) '(0) \n      (+ (/ n 2) (tri (- n\
    \ 1)))))\n", "  (if (= n 1)\n      (list 3)\n      (cons (+ (/ n 2) 1) (tri (-\
    \ n 1)))))\n", "  (define (tri1 n sum)\n    (cond ((< n 0) '())\n          ((=\
    \ n 0) (list sum))\n          ((= n 1) (list sum))\n          (else (tri1 (- n\
    \ 1) (+ sum n)))))\n  (tri1 n (+ 1 n)))\n", "  (define (fib 0)\n    (const (cons\
    \ 0 1 )))\n  (define (tri-helper n res cur)\n    (if (= n 0)\n      (reverse res)\n\
    \      (tri-helper (- n 1) \n                  (cons (+ (car cur) (cadr cur))\
    \ res)\n                  (cons (+ (caddr cur) (cadddr cur)) cur))))\n  (tri-helper\
    \ n (empty empty) (cons (car fib) (fib n)) ))\n", "  (if (= n 1)\n      (list\
    \ 3)\n      (cons (+ 3 (tri (sub1 n)))\n            (tri (sub1 n)))\n      )\n\
    \    )\n  )\n", "  (if (= n 0) \n      '()\n      (cons (+ (/ n 2) (tri (- n 1)))\
    \ (tri (- n 2)))))\n</code>\nThe program above should give you:\n<code>", "  (cond\n\
    \    [(zero? n) '()]\n    [(even? (remainder n 2)) (cons (+ n 1) (tri (sub1 n)))]\n\
    \    [else (cons (+ n 1) (tri (sub1 n)))]))\n</code>\n<|/ a |>\n<| c |>\nNitpick:\
    \ `(cons (+ n 1) (tri (sub1 n)))` does not *call* the function, it *evaluates*\
    \ the function and uses the result.\n<|/ c |>\n<| c |>\nIt seems that the second\
    \ clause of `(cond ...)` is unnecessary. Scheme has tail recursion, so that `cons`\
    \ can never be called in the first clause.\n<|/ c |>\n<| c |>\n, thank you, you're\
    \ right, I was too conservative.\n<|/ c |>\n<| c |>\nNote that this code is wrong.\
    \ Try it with n = 2. It returns `'()`, not `'(2 3)`.\n<|/ c |>\n<| a tags=racket,fibonacci,scheme\
    \ dscore=2 |>\nThis solution is very similar to Oscar's except that I have used\
    \ quotients (rather than divisions) to determine the number of times to recurse\
    \ (this is important since it makes recursion much simpler).\n<code>", "  (cond\
    \ [(= n 0) '()]\n        [(= n 1) '(3)]\n        [(even? (modulo n 2)) (+ 1 (/\
    \ n 2))  (tri (sub1 n))]\n        [(odd? (modulo n 2)) (+ 1 (tri (sub1 n))) (tri\
    \ (add1 n))]\n        [else (tri (sub1 n)) (tri (add1 n))]))", "  (cond ((= n\
    \ 0) '())\n        ((= n 1) '(3))\n        ((odd? n) (cons (+ (/ n 2) (tri (-\
    \ n 1))) (tri (- n 2))))\n        (else (cons (+ (/ n 3) (tri (- n 1))) (tri (-\
    \ n 2)) (tri (+ n 1))))))\n</code>\n<code>", "  (cond [(zero? n) '()]\n      \
    \  [(even? n) (+ 3 (tri (sub1 n)))]\n        [else (+ (tri (sub1 n)) (tri (sub1\
    \ n)) (tri (add1 n))]))) ;; #lang racket\n", "  (let loop ((a 1) (b 3) (c 2) (d\
    \ 3))\n    (cond\n      [(= n 0) '()]\n      [(even? n) (cons a (loop (+ a b)\
    \ c (+ a c d) n)]\n      [else (cons b (loop (+ a b c) d (+ a b c d) n)])))) \n",
  "  (if (zero? n) \n      (list 1) \n      (+ (tri (- n 2)) (tri (- n 1))) (tri (+\
    \ n 1))))\n", "  (if (= n 1)\n      (list 1)\n      (append (tri (sub1 n))\n \
    \             (tri (sub1 n) 1) (tri (sub1 n) 2))))\n</cell>\n<text>\nThe previous\
    \ function definition defines a recursive function named tri accepting a natural\
    \ number n. This function returns the desired list when the input parameter is\
    \ 1. Otherwise, it returns the list with the first n numbers plus the last n+1\
    \ numbers of the Tribonacci sequence.\n\n\n</text>\n<code language=complex-number>",
  "  (if (<= n 1)\n      [3]\n      (+ (/ n 2)\n         (tri (- n 1))\n         (tri\
    \ (+ n 1)))))\n", "  (if (= n 1)\n      '(1)\n      (append (tri (- n 1)) (tri\
    \ (- n 2)) (tri (+ n 1)))))\n", "  (define (tri-helper n sum-helper)\n    (cond\n\
    \      [(zero? n) (list sum-helper)]\n      [(even? n) (tri-helper (/ n 2) (+\
    \ sum-helper (/ n 2)))]\n      [else (tri-helper (- n 1) (+ sum-helper (/ n 3)))]))\n\
    \  (tri-helper n 0))\n", "  (cond [(= n 1) (list 3)]\n        [(even? n) (cons\
    \ (+ n 1) (tri (- n 1)))]\n        [else (tri (- n 1) (+ n 1))]))\n", "  (cond\n\
    \    [(zero? n) '()]\n    [(even? n) (cons 1 (tri (sub1 n)))]\n    [else (cons\
    \ (+ (tri (sub1 n)) (tri (sub1 n))) (tri (add1 n)))]))\n", "  (cond ((= n 1) '(3))\n\
    \        ((even? n) (+ (tri (/ n 2)) (tri (- n 1))))\n        (else (tri (- n\
    \ 1)) (tri (+ n 1)))))\n</code>\nAnd here's the final implementation in Scheme/Racket:\n\
    <code>", "  (cond\n    [(= n 1) '(3) ]\n    [(even? n) (+ (tri (/ n 2))\n    \
    \             (tri (- (+ 1 n) 1)))]\n    [else (tri (- n 1)) (+ (tri (- n 2))\n\
    \                 (tri (+ n 1))) ]\n  ))\n", "  (if (even? n)\n      (cons 3 (tri\
    \ (- n 1))\n            (tri (- n 2))\n            (tri (+ n 1)))\n      (cons\
    \ 1 \n            (tri (- n 2))\n            (tri (+ n 1)))))\n", "  (if (= n\
    \ 0)\n      '()\n      (cons (+ (/ n 2) (tri (- n 1))) (tri (- n 2)))))\n", " \
    \ (if (or (= n 2) (even? n))\n      (append (list 3) (tri (- n 1)))\n      (append\
    \ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1)))))\n", "  (if (even? n)\n      (cons\
    \ 3 (tri (sub1 n)))\n      (tri (add1 n)\n            (cons 1 (tri (sub1 n))\n\
    \                  (tri (add1 n))))))", "  (if (= n 0)\n      (list 1)\n     \
    \ (append (tri (sub1 n)) (tri (sub1 n)))))\n", "  (if (< n 2)\n      (cons 1 (tri\
    \ (- n 1)))\n      (cons 2 (tri (- n 2)) (tri (+ n 1)))))\n", "  (if (= n 0) '())\n\
    \  (cons (+ (* 3 1 (/ n 2)) (* 1 (/ n 2)) (+ (* n 2) (* n 3)))))\n", "  (cond\
    \ ((= n 0) (list n)) (even? n (cons (+ n 1) (tri (- n 2))) (tri (+ n 1)))))\n",
  "  (cond [(= n 1) (list 3)]\n        [(even? (remainder n 2)) (cons (+ 3 n) (tri\
    \ (- n 1)))]\n        [else (tri (- n 1)) (tri (- n 2)) (+ n (/ 2 n))]))\n</code>\n\
    <|/ a dscore=2 tags=scheme,racket |>\n<| a dscore=1 |>\nThe basic idea of Fibonacci\
    \ numbers is the following: if n is even, take 3n+1 and divide it by 2; if n is\
    \ odd, take 3n+3 and divide it by 2. If you keep doing this, you will eventually\
    \ get to the number you want.\nThe first two numbers would be 1 and 2, and that\
    \ is the recursion base case. Then, we are interested in what happens if the number\
    \ given is odd. Since n is odd, we can take 3n+1 and divide it by 2, thus giving\
    \ us 3n+2. We can repeat the procedure for the even case by replacing n by 3n+3.\
    \ Now we have the number 3n+3 that we are looking for, which we can return as\
    \ a list containing the numbers 1..n.\nThe code for finding the tribonacci numbers\
    \ is as follows: \n<code>", "  (cond [(= n 0) '()]\n        [(= n 1) '(3)]\n \
    \       [(even? n) (+ (tri (- n 2)) (tri (+ n 1)))]\n        [else (+ (tri (-\
    \ n 1)) (tri (+ n 1))) (tri (+ n 1))]))\n", "  (define (tri-helper n)\n    (if\
    \ (zero? n)\n        '()\n        (cons (+ (/ n 2) (/ (modulo n 2 n) 2)) (tri-helper\
    \ (- n 2)))))\n  (tri-helper n))\n", "  (if (or (< n 0) (= n 1)) \n      '()\n\
    \      (cons (+ (/ n 2) (tri (- n 1))) (tri (+ n 1)))))\n", "  (cond\n    [(=\
    \ n 0) '()]\n    [(even? (rem n 2)) (cons (+ n 1) (tri (- n 1)))]\n    [else (tri\
    \ (- n 1))]))\n", "  (let loop ((n (- n 1))\n             (l (- n 2) 1)\n    \
    \         (r (+ n 1)))\n    (if (= n 1)\n        '()\n        (cons (+ l r) (loop\
    \ (- n 1) (+ l r) (+ r l))))))\n", "  (if (zero? n)\n      '()\n      (cons (+\
    \ (/ n 2) 1)\n            (tri (- n 1)))))\n", "  (if (<= n 1)\n      '()\n  \
    \    (cons ((car tri) (+ (car tri) (car (cdr tri)))) \n            (tri (+ (car\
    \ tri) (/ n 2))))))\n", "  (if (= n 0)\n      (list 3)\n      (tri (- n 1))\n\
    \      (tri (- n 1))\n      (tri (+ n 1))))\n", "  (cond\n    [(= n 1) '(1 3)]\n\
    \    [(even? n) (+ (tri (- n 2)) (tri (- n 1)))]\n    [else (+ (tri (- n 1)) (tri\
    \ (+ n 1)))]))\n", "  (cond ((= n 0) '())\n        ((= n 1) (list 3))\n      \
    \  (else (append (tri (sub1 n)) (tri (sub1 n) (sub1 n))\n                    \
    \  (tri (sub1 n) (add1 n) (add1 n))))))\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    A more simple solution using recursion function:\n<code>", "  (if (= n 0)\n  \
    \    '()\n      (let ([t (tri (- n 1))])\n        (append (list t) (tri (- n 2))))))\n",
  "  (cond\n    [(= n 0) (list 3)]\n    [(even? n) (cons (+ 3 (tri (/ n 2))) (tri\
    \ (- n 1)))]\n    [(odd? n) (tri (- n 1) (+ 3 (tri (- n 2))))]))", "  (if (= n\
    \ 0)\n      '()\n      (cons (+ (/ n 2)\n               (tri (- n 1)))\n     \
    \       (tri (+ n 1)))))\n", "  (let loop ((i 3) (tri-result '()))\n    (cond\
    \ ((< i n) tri-result)\n          ((even? i)\n           (loop (+ i 1) (cons (-\
    \ i 1) tri-result)))\n          ((odd? i)\n           (loop (+ i (/ i 2)) (cons\
    \ (+ i (/ i 2)) tri-result))))))\n", "  (if (= n 0) (list 1)\n      (cons (+ (/\
    \ n 2) (tri (- n 1))) (tri (- n 2)))))\n", "  (cond ((= n 0) (list 3))\n     \
    \   ((= n 1) (list 1))\n        (else (append (tri (- n 1))\n                \
    \      (tri (- n 2))\n                      (tri (+ n 1))))))\n", "  (cond [(=\
    \ n 0) (list 3)]\n        [(even? n) (cons (+ n (/ n 2)) (tri (sub1 n)))]\n  \
    \      [(odd? n) (cons (+ (tri (sub1 n)) (tri (sub1 n)) (tri (add1 n))))]))\n\
    </cell>\n<cell>", "  (if (zero? n)\n      '()\n      (let loop ((a 3) (b 1) (c\
    \ (/ n 2) (+ a b) (+ c a))\n                (d c (+ b c) (+ a d)))\n        (if\
    \ (zero? d)\n            (append (list a) (tri (- n 1)))\n            (loop (+\
    \ a b) (+ b c) (+ c d))))))\n", "  (let loop ((a 3) (b (+ 1 a) (c (/ 2 a)))\n\
    \             (d b (+ (/ 2 a) c)))\n    (if (= n 0) (list a)\n        (loop (+\
    \ a d) (+ b c) (+ c d))))) ; <= a <= d\n</code>\nAt the REPL:\n<code>\nWelcome\
    \ to Racket v5.10.1.\n> racket\nWelcome to Racket v5.10.1.\n> (tri 3)\n'(1 3 2\
    \ 8)\n> (tri 4)\n'(1 3 5 8 13)\n> (tri 10)\n'(1 3 5 8 13 21 34 55 89 144 233 377\
    \ 610)\n</code>\n<|/ a dscore=3 tags=racket,scheme,lisp |>\n<| c |>\nNice! The\
    \ reason for the error in my first answer was that the recursion was missing the\
    \ base case. It should have been `(if (= n 0) ...)` and not `(if (= n 0) (list\
    \ ...))`.\n<|/ c |>\n<| a dscore=3 tags=racket,scheme,lisp |>\nThis is an answer\
    \ using Scheme, and not Scheme/Racket. \n<code>", "  (cond\n    [(= n 0) (list\
    \ 3)]\n    [(even? (mod n 2)) (cons (+ (/ n 2) 1) (tri (- n 2)))]\n    [else (tri\
    \ (- n 1) (+ n 1) (+ n 2) (+ n 3))]))\n", "  (if (= n 1)\n      '(3)\n      (+\
    \ (tri (- n 1))\n         (tri (- n 2))\n         (tri (+ n 1)))))\n", "  (if\
    \ (= n 0)\n      '()\n      (append (+ (/ (+ n 1) 2) (tri (- n 1))) (tri (- n\
    \ 2)))))\n", "  (if (= n 0)\n      '()\n      (append (tri (sub1 n))\n       \
    \       (+ tri (sub1 n) (sub1 n))\n              (+ tri (sub1 n) (+ n 1)))))\n",
  "  (if (= n 0)\n      [3]\n      (cons 3 (tri (- n 1))\n            (+ 2 (tri (+\
    \ n 2))))))", "  (let loop ((i 2) (acc '())\n             (curr '()))\n    (cond\
    \ ((= n 0) acc)\n          ((odd? n) (loop (- n 1) (cons (+ curr i) acc) curr))\n\
    \          ((even? n) (loop (- n 1) (cons curr (+ curr (/ n 2))) curr))\n    \
    \      (else (loop (- n 1) (cons curr acc) (+ curr (/ n 2))))))))\n", "  (cond\
    \ ((= n 0) '())\n        ((even? n) (append (tri (/ n 2))\n                  \
    \        (tri (- n 2))\n                          (tri (+ n 1))))\n        (else\
    \ (append (tri (- n 1))\n                       (tri (- n 2))\n              \
    \         (tri (+ n 1))))))\n", "  ((cons (+ 3 (/ n 2)) (if (odd? n) \n      \
    \                     (tri (- n 1))\n                           (tri (+ n 1))))))\n",
  "  (cond [(zero? n) (list n)]\n        [(even? n) (cons (+ (/ n 2) (tri (- n 1)))\n\
    \                         (tri (- n 2)))]\n        [else (tri (- n 1)) (tri (-\
    \ n 2)) (tri (+ n 1))]))\n", "  (cond\n    [(zero? n) '()]\n    [(zero? (sub1\
    \ n)) (cons 3 (tri (sub1 n)))]\n    [else (cons (+ (/ n 2) (tri (sub1 n)))\n \
    \              (tri (sub1 n)))]))\n", "  (cond [(= n 0) (list 3)]\n        [(even?\
    \ n) (cons (tri (- n 1) (+ n 1)) (+ (tri (- n 2) (+ n 2)) 1))]\n        [(odd?\
    \ n) (cons (tri (- n 1) (+ n 1)) (+ (tri (- n 2) (+ n 2)) (+ n 1)))]))\n", " \
    \ (cond [(= n 1) '(3)]\n        [(even? n) (+ (tri (- n 1))(tri (- n 2))(tri (+\
    \ n 1)))]\n        [(odd? n) (tri (- n 1))(tri (- n 2))(tri (+ n 1))(tri (+ n\
    \ 2))]))", "  (cond [(= n 0) '(1 3)]\n        [(= n 1) '(2 3)]\n        [else\
    \ (+ (/ n (tri (- n 1))) (+ (/ n (tri (- n 2))) (+ (/ n (tri (+ n 1))))))]))\n",
  "  (if (= n 0)\n      (reverse '())\n      (+ (tri (- n 1))\n         (tri (- n\
    \ 2))\n         (tri (+ n 1)))))\n</code>", "  (if (zero? n)\n      '()\n    \
    \  (cons ((+ 3 (/ n 2)) (tri (- n 1)))\n            (tri (+ n 1)))))\n", "  (if\
    \ (even? n)\n      (cons (+ (/ n 2) (/ n 4) (/ n 6))\n            (tri (- n 1))))\n\
    \  (cons (+ (/ n 2) (/ n 3))\n        (tri (- n 1)))))\n", "  (cond\n    [(= n\
    \ 2) (list 3)]\n    [(even? n) (cons (+ 1 n) (tri (sub1 n)))]\n    [else (tri\
    \ (sub1 n) (+ 1 n) (tri (sub1 n) (+ 1 n)))))\n", "  (if (= n 0)\n      (list 1)\n\
    \      (cons 1 (+ (tri (- n 1)) (tri (- n 2))))))\n</code>\n<|/ a tags=racket,recursion,scheme,lisp\
    \ dscore=0 |>\n<| a dscore=0 |>\nThis is an implementation of the algorithm (which\
    \ is easy to understand) using tail recursion (TinyScheme syntax):\n<code>", " \
    \ (if (= n 0)\n      [3]\n      (cons \n       (+ (tri (- n 1))\n          (tri\
    \ (- n 2))\n          (tri (+ n 1)))))))\n", "  (define (tri-helper a b c)\n \
    \   (if (zero? b)\n        (list c)\n        (+ (tri-helper (- b 1) a (+ c a))\
    \ (/ b 2))))\n  (tri-helper 1 1 1))\n", "  (define (tri-aux2 i last)\n    (if\
    \ (zero? i)\n        '()\n        (cons (+ (tri-aux1 i last)\n               \
    \  (tri-aux1 i (+ last (/ i 2)))\n                 (tri-aux1 i (+ last (+ (/ i\
    \ 2) 1)))))))\n  (define (tri-aux1 i last)\n    (if (zero? i)\n        last\n\
    \        (tri-aux1 i (+ last (/ i 2)))))\n  (tri-aux2 n 0))\n", "  (if (< n 1)\n\
    \      (list)\n      (append (tri (- n 1))\n              (list (+ (/ n 2)) (tri\
    \ (+ n 1)))\n              (tri (+ n 1)))))\n", "  (cond [(= n 0)\n         '()]\n\
    \        [(= n 1)\n         (list 1)]\n        [(odd? n)\n         (cons (+ 1\
    \ (tri (- n 1))) (+ (tri (- n 2)) (tri (- n 3))))]\n        [else\n         (cons\
    \ (+ 1 (tri (- n 1))) (+ (tri (- n 2)) (tri (- n 3))) (+ (tri (- n 4)) (tri (-\
    \ n 5))))]))\n", "  (let loop ((a 0) (b 1) (acc '()))\n    (if (= n 0)\n     \
    \   (reverse acc)\n        (loop (+ a b) (+ b a) (cons (a+b) acc)))))\n", "  (cond\n\
    \    [(even? n) (cons 1 (tri (sub1 n)))]\n    [else (tri (sub1 n) (tri (sub1 n)\
    \ (tri (add1 n))))]))\n", "  (let ((tri (lambda (n) (+ (/ 2 n) (* 3 (tri (/ n\
    \ 2))))))) \n    (if (= n 0)\n        '()\n        (cons n (tri (- n 1))))))\n",
  "  (define (tri-helper n)\n    (if (= n 0)\n        (cons 1 '())\n        (tri-helper\
    \ (- n 1))\n      )\n    (cons (+ (tri-helper (/ n 2)) (tri-helper (- n 1))) '())\n\
    \  )\n  (tri-helper n)\n)\n", "  (if (= n 0) '()\n      (cons (+ n (tri (- n 1)))\
    \ (tri (- n 2)))))\n", "  (if (< n 3)\n      (cons n (tri (- n 1)))\n      (append\
    \ (tri (- n 2)) (tri (+ n 1)))))\n", "  (if (zero? n)\n      (list 1)\n      (cons\
    \ (+ (/ n 2) (tri (- n 1))) (tri (+ n 1)))))\n", "  (if (= n 0)\n      (list 1)\n\
    \      (append (tri (/ n 2)) (tri (+ (/ n 2) 1)))\n  )\n)\n</code>\n<|/ a dscore=2\
    \ tags=scheme |>\n<| c |>\nThis answer is so great, but I do have a question.\
    \ Why is it that `(append (tri (/ n 2)) (tri (+ (/ n 2) 1)))` doesn't work? `tri\
    \ (/ n 2)` will get called twice, but each one will give the same result. How\
    \ can that happen?\n<|/ c |>\n<| c |>", "  (define (tri-iter n a b c d)\n    (cond\
    \ [(= n 0) (list (+ a b) c d)]\n          [(= n 1) (list a b (+ c d))])\n    (tri-iter\
    \ (sub1 n) (+ a b) (+ b c) (+ c d) (+ d a))))\n  (tri-iter n () () () ()))\n",
  "  (cond\n    [(= n 0) '()]\n    [(even? n) (cons 1 (tri (/ n 2))) (+ n (tri (-\
    \ n 1)))]\n    [else (tri (- n 1)) (+ n (tri (- n 2))) (+ n (tri (+ n 1)))]))\n",
  "  (cond\n    ((= n 0) '(1 2 3))\n    ((= n 1) '(1))\n    ((even? (remainder n 2))\
    \ (cons (+ (/ n 2)) (tri (sub1 n))))\n    (else (tri (add1 n)))\n  )\n)\n", " \
    \ (if (= n 1)\n      [1 n]\n      (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1)))))",
  "  (if (<= n 1)\n      '()\n      (cons (+ (/ n 2)\n               (tri (- n 1))\n\
    \               (tri (+ n 1)))\n            (tri n))))\n", "  (if (= n 0)\n  \
    \    '()\n      (cons (+ (/ 2 n) (tri (- n 1)))\n            (+ (/ 1 n) (tri (-\
    \ n 2)))\n            (+ (/ 1 n) (tri (+ n 1))))))", "  (cond\n    [(zero? n)\
    \ empty]\n    [(even? n) (cons (add1 n) (tri (sub1 n)))]\n    [(odd? n) (tri (add1\
    \ n) (tri (sub1 n) (tri (sub1 n))))]))\n", "  (define (tri-iter tri-a tri-b tri-c)\n\
    \    (if (<= n 3)\n        (list tri-a tri-b tri-c)\n        (tri-iter (+ tri-a\
    \ tri-b) (+ tri-c tri-b) (+ tri-a tri-c))))\n  (tri-iter 3 (+ 2 (/ n 2)) 2))\n\
    </code>\n<|/ a |>\n<| a |>\nMy solution in Racket is as follows\n<code>", "  (cond\n\
    \    [(= n 1) '()]\n    [(even? n) (cons (car n) (tri (sub1 n)))]\n    [(odd?\
    \ n) (tri (sub1 n) (add1 (car n))))]))\n", "  (let tri0 (+ (/ n 2) 1)\n    (tri1\n\
    \      (- n 1)\n      (+ tri0 tri0)\n      (/ n 2)\n      tri0\n      (+ tri0\
    \ tri0))))", "  (if (zero? n) '()\n      (cons (+ n (/ 2 n) (/ n 3))\n       \
    \     (tri (- n 1)))))\n", "  (cond ((= n 0) nil)\n        ((even? n) (cons 1\
    \ (tri (- n 1))))\n        (else (cons (+ (tri (- n 1)) (tri (- n 2)) (tri (+\
    \ n 1))) \n                      (tri (+ n 2))))))", "  (if (zero? n)\n      '()\n\
    \      (cons n (tri (sub1 n))\n            (tri (add1 n)))))\n", "  (cond ((=\
    \ n 0) '())\n        ((= n 1) (list 1))\n        (else (+ (tri (sub1 n))\n   \
    \               (/ (tri (sub1 n)) 2)))))\n", "  (if (= n 0)\n      (list 3)\n\
    \      (append (tri (sub1 n)) (tri (sub2 n)))))\n</code>\n<|/ a tags=recursion,racket,scheme\
    \ |>\n<| c |>\nThank you for this. The `append` function is what I was looking\
    \ for. I tried to use `(list 3)` as a base case but it wasn't working.\n<|/ c\
    \ |>\n<| a |>\n<code>", "  (if (odd? n)\n      (cons (+ (/ n 2) (tri (sub1 n)))\n\
    \            (tri (sub1 n)))\n      (cons (+ (/ n 2) (tri (sub1 n)))\n       \
    \     (tri (sub1 n))\n            (+ (/ n 2) (tri (add1 n))))))\n", "  (cond [(=\
    \ n 1) '(3)]\n        [(even? n) (+ (tri (- n 1)) (tri (- n 2)))]\n        [(odd?\
    \ n) (tri (+ n 1))]))\n", "  (if (= n 0)\n      '(0)\n      (append (tri (- n\
    \ 1)) (tri (- n 2)) (tri (+ n 1)))))\n", "  (cond\n    [(= n 0) '()]\n    [(even?\
    \ n) (cons (+ n (/ n 2)) (tri (- n 1)))]\n    [(odd? n) (cons (+ n (/ n 2)) (tri\
    \ (- n 1)))]\n    [else (tri (- n 1))]))\n", "  (if (= n 1)\n      (list 1)\n\
    \      (+ (tri (- n 2)) (tri (- n 1)) (tri (+ n 1)))))\n", "  (cond\n    [(= n\
    \ 1) '(3) ]\n    [(even? (mod n 2)) (+ 1 (/ n 2))(+ 1 (/ n 2))]\n    [else (tri\
    \ (- n 1)) (tri (- n 2)) (tri (+ n 1))]\n  )\n)\n", "  (if (= n 1)\n      [3]\n\
    \      (cons (+ (/ n 2)) (tri (- n 1)))))\n", "  (cond ((= n 2) (list 3))\n  \
    \      ((even? (remainder n 2)) (cons (+ n (/ 2 n)) (tri (- n 1))))\n        (else\
    \ (cons (+ n (* 3 1 (/ 2 n))) (tri (- n 1))))))\n", "  (cond\n    ((zero? n) '())\n\
    \    ((even? n) (tri (- n 1)))\n    (else (tri (- n 2)) (tri (+ n 1)))))\n", " \
    \ (cond ((= n 0) '())\n        (else (cons (+ n (quotient n 3)) \n           \
    \         (tri (- n 1))))))\n", "  (if (even? n)\n      (+ (tri (- n 1))\n   \
    \      (tri (- n 2))\n         (tri (+ n 1))\n         (tri (+ n 2))\n       \
    \  (tri (+ n 3))\n         (tri (+ n 4))))\n      '()) ;; a list which contains\
    \ n numbers. Remember that Tribonacci sequence ", "  (let ((a 1) (b 0) (c 1))\
    \ (if (even? n)\n                           (cons a (tri (sub1 n))) (cons (tri\
    \ (sub1 n)) (tri (sub1 n) (caddr b) (caddr c))))))\n", "  (if (= n 0)\n      '()\n\
    \      (cons 1 (tri (- n 1))\n             (tri (- n 2))\n             (tri (+\
    \ n 1)))))\n", "  (if (= n 0)\n      '()\n      (+ (tri (- n 1)) (tri (- n 2))\
    \ (tri (+ n 1)))))\n", "  (cond\n    [(= n 0) (list n)]\n    [(even? n) (+ (tri\
    \ (- n 2)) (tri (- n 1)))]\n    [(odd? n) (tri (- n 1) (+ n 1) (+ n 2))]))\n",
  "  (if (= n 0)\n      '(1 2 3)\n      (append (tri (sub1 n)) (tri (sub1 (+ n 1))))))",
  "  (if (= n 1)\n      (list 3)\n      (append (tri (/ n 2)) (tri (+ n 1)))))\n\n\
    #lang racket\n", "  (if (= n 1)\n      (list 1)\n      (append (tri (- n 1))\n\
    \              (tri (- n 2))\n              (tri (+ n 1)))))\n", "  (if (= n 0)\n\
    \      [3]\n      (+ tri (/ n 2)\n           (+ (tri (- n 1))\n              (tri\
    \ (+ n 1))))))\n", "  (if (even? n) \n      (append (cons (- n 3) (/ (+ n 3) 2))\n\
    \              (tri (- n 1))) \n      (cons (+ n 3) (tri (+ n 2)))))\n", "  (if\
    \ (zero? n)\n      '(1 1 1)\n      (append (tri (sub1 n)) (tri (sub2 (add1 n)))\n\
    \              (tri (add2 n)))))\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIn addition\
    \ to Bill's answer, here is an iterative solution in Racket (Scheme dialect):\n\
    <code>", "  (if (zero? n)\n      (list 3)\n      (+ (/ (+ (tri (- n 1)) (tri (-\
    \ n 2))) (tri (+ n 1)))\n         (/ (+ (tri (- n 2)) (tri (+ n 2)) (tri (+ n\
    \ 1)))\n             (tri (+ n 3))))))\n</cell>\n<cell>", "  (cond [(= n 0) '(1\
    \ 3)]\n        [(even? (modulo n 2)) (append (tri (sub1 n)) '(2))]\n        [(odd?\
    \ (modulo n 2)) (append (tri (sub1 n)) '(1 3))]))\n</cell>\n<text>\nExercise\n\
    Write a function that takes two integers m and n and returns their sum of the\
    \ factorials of the first n terms of that fibonacci series.\n\nExample:\n", " \
    \ (define (tri-helper n acc)\n    (cond\n      [(= n 1)\n       (reverse acc)]\n\
    \      [(even? n) (tri-helper (/ n 2) (cons 1 acc))]\n      [else (tri-helper\
    \ (- n 1) (cons (+ n 2) acc))]))\n  (tri-helper n '()))\n", "  (cond\n    [(=\
    \ n 0) '(0 1 2 3)]\n    [(even? n) (cons (+ (tri (/ n 2))\n                  \
    \      (tri (- n 2))\n                        (tri (+ n 1)))\n               tri\
    \ (/ n 2))]\n    [else (tri (- n 1) (+ n 1) (+ n 1))]))) ;; (tri (- n 1) (+ n\
    \ 1) (+ n 1))]))))", "  (if (= n 0)\n      (list n)\n      (append (tri (- n 1)\
    \ ) (tri (- n 2) (tri (+ n 1) (tri (+ n 2) n))))))\n", "  (if (= n 0)\n      (list\
    \ 1)\n      (+ (tri (sub1 n)) (tri (sub2 n))))) ", "  (let loop ((result '())\n\
    \             (x (if (= n 0)\n                   '()\n                   (list\
    \ n)))\n             (x (append x (if (even? n) '()\n                        \
    \  (append x (list (- (quotient n 2) (tri (- n 2)))))))\n             (x (append\
    \ x (tri (- n 1)))))\n    (if (null? x) result\n        (loop (cons x (first x))\n\
    \               (rest x)\n               (rest x))))", "  ; base case\n  (if (=\
    \ n 0) (list 1)\n      ; recursive case\n      (append (tri (- n 1)) (list (-\
    \ n 1) (+ n 1)))))\n", "  (cond\n    ((= n 0) (list 1))\n    ((= n 1) (list 3))\n\
    \    (else (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))\n", "  (if (even?\
    \ n)\n      (add1 (tri (- n 2))\n             (tri (- n 1))\n             (tri\
    \ (+ n 1)))\n      (tri (- n 1) (- n 2) (+ n 1))))\n", "  (if (= n 0)\n      '()\n\
    \      (cons (+ (tri (/ n 2)) (tri (- n 1))) (tri (+ n 1)))))\n", "  (if (= n\
    \ 0)\n      [1 1]\n      (cons (+ (tri (/ n 2)) (tri (- n 1))) (tri (+ n 1)))))\n",
  "  (if (zero? n) \n      (list 1)\n      (+ (tri (sub1 n)) (tri (sub2 n))) (tri\
    \ (add1 n))))\n", "  (cond\n    [(= n 0) '()]\n    [(= n 1) '(1)]\n    [(even?\
    \ n) (append '(2) (tri (sub1 n) (sub1 n) (sub1 n)))]\n    [(odd? n) (tri (sub1\
    \ n) (add1 n) (sub1 n))]))", "  (let ((result (make-list n)))\n    (cond\n   \
    \   ((= n 0) (append result (list 3)))\n      ((= n 1) (append result (list 1)))\n\
    \      (else (append result (list (+ n (/ n 2)))) (tri (- n 1))))))", "  (if (zero?\
    \ n) '() (append (tri (- n 1)) (tri (- n 2))\n                           (tri\
    \ (+ n 1)))))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
