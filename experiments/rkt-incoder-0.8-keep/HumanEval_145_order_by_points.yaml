name: HumanEval_145_order_by_points
language: rkt
prompt: "#lang racket\n\n;; Write a function which sorts the given list of integers\n\
  ;; in ascending order according to the sum of their digits.\n;; Note: if there are\
  \ several items with similar sum of their digits,\n;; order them based on their\
  \ index in original list.\n;; For example:\n;; >>> order_by_points([1, 11, -1, -11,\
  \ -12]) == [-1, -11, 1, -12, 11]\n;; >>> order_by_points([]) == []\n(define (order_by_points\
  \ nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n\
  \    (check-equal? (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11))\n\
  \    (check-equal? (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56\
  \ 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457))\n    (check-equal?\
  \ (candidate (list )) (list ))\n    (check-equal? (candidate (list 1 -11 -32 43\
  \ 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9))\n    (check-equal? (candidate\
  \ (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? nums) '()]\n    [(sum-equal? (first nums)\n \
    \                 (second nums)) (rest (rest nums))]\n    [else\n     (cons \n\
    \      (first nums)\n      (order_by_points (rest nums))])]))", "  (if (null?\
    \ nums) nums\n      (let ([sum (+ 0 (first nums))])\n        (if (null? (rest\
    \ nums)) (reverse (rest nums))\n            (let ([next (order_by_points (rest\
    \ nums))])\n              (if (> (+ 0 (first nums)) sum)\n                  (cons\
    \ next nums)\n                  (cons (first nums) (cons (first nums) next))\n\
    \                )\n            )\n        )\n      )\n  )\n)\n", "  (define (sum-digits\
    \ x)\n    (cond\n      [(= 0 (mod x 10)) x]\n      [(= 1 (mod x 10)) (* 10 x)]\n\
    \      [else (* 10 x) (+ (sum-digits (quotient x 10)) (* 2 x))]))\n\n  (define\
    \ (order-by-sum xs)\n    (cond\n      [(empty? xs) (empty)]\n      [(> (sum-digits\
    \ (first xs)) (- (first xs) (first xs)))\n       (append (rest (rest (rest (rest\
    \ xs))))\n               (list (first xs))\n               (order-by-sum (rest\
    \ xs))])\n      [(< (sum-digits (first xs)) (sum-digits (second xs)))\n      \
    \ (append (rest (rest (rest (rest xs))))\n               (list (first xs))\n \
    \              (order-by-sum (rest xs))]\n      [(= (sum-digits (first xs)) (sum-digits\
    \ (second xs)))\n       (list (first xs))\n       (append (rest (rest (rest (rest\
    \ xs))))\n               (list (first xs))\n               (order-by-sum (rest\
    \ xs))]\n      [(> (sum-digits (first xs)) (sum-digits (third xs)))\n       (append\
    \ (rest (rest (rest (rest xs))))\n               (list (first xs))\n         \
    \      (order-by-sum (rest xs))]\n      [(= (sum-digits (first xs)) (sum-digits\
    \ (third xs)))\n       (list (first xs))\n       (append (rest (rest (rest (rest\
    \ xs))))\n               (list (first xs))\n               (order-by-sum (rest\
    \ xs))]\n      [else (list (first xs))\n              (order-by-sum (rest xs))])))\n\
    \n  (append (order-by-sum (reverse (sort nums < (lambda (x) (sum-digits x)))))\
    \ nums))\n", "  (define (helper n acc ls)\n    (cond\n      [(empty? ls) (reverse\
    \ acc)]\n      [(<= 0 (cdr n) (car ls))\n       (helper (cdr n) (cons (car ls)\
    \ acc) (cdr ls))]\n      [else (helper (cdr n) (cons (car ls) acc) (cdr ls))]))\n\
    \  (helper nums '() (append nums [0 ])))\n", "  (cond\n    ((null? nums) '())\n\
    \    ((empty? (rest nums)) nums)\n    ((= (digit-sum head (rest nums)) 0) (cons\
    \ head nums))\n    (else (let ([index (sub1 (max-digit (rest nums)))]\n      \
    \         (if (null? (tail nums))\n                   (begin (set! head head)\
    \ nums)\n                   (let ([new-head (cons (first nums) (cons head (rest\
    \ nums)))]\n                     (set! head new-head)\n                     (order_by_points\
    \ (rest nums))))))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks so much, it's\
    \ greatly appreciated!\n<|/ c |>\n<| a |>\nHere is a simple recursive function\
    \ in Racket:\n<code>", "  (cond\n    [(empty? nums) nums]\n    [(integer? (first\
    \ nums)) (cons (first nums) (order_by_points (rest nums)))]\n    [else (cons (order_by_points\
    \ (first nums)) (order_by_points (rest nums)))]\n  )\n)\n", "  (let ((sum (foldr\
    \ (\u03BB (x acc) (+ x (modulo (* x 10) 10)))\n                    0 nums))\n\
    \        (index 0))\n    (loop for i from (length nums) to 0 while sum > 0\n \
    \         collect (cons nums i))\n    (sort nums <)\n    (apply append (map (\u03BB\
    \ (x y) (+ x y)) nums index))))\n", "  (sort nums\n        (lambda (n1 n2)\n \
    \         (if (zero? n1) (sub1 n2)\n              (if (zero? n2) (sub1 n1)\n \
    \                 (+ (* (quotient n1 10) (quotient n2 10))\n                 \
    \    (* (remainder n1 10) (remainder n2 10))))))\n        'asc))\n</cell>\n<text>\n\
    The last thing we need is a function to read and output the integers from the\
    \ given file name. The function read_ints_from_file opens the file named by file-name,\
    \ reads all integers from the file and returns them as a list. Here is the code\
    \ for the function:\n\n\n</text>\n<code language=racket-lang>\n#lang racket\n",
  "  (cond\n    [(null? nums) '()]\n    [(> (length (string->list (digits (first nums))))\n\
    \         (length (string->list (digits (first nums)))))\n      (if (> (length\
    \ (string->list (digits (first nums))))\n             (length (string->list (digits\
    \ (first nums)))))\n          (list->string (digits (first nums)))\n         \
    \ (order_by_points nums))]\n    [(< (length (string->list (digits (first nums))))\n\
    \         (length (string->list (digits (first nums)))))\n      (if (< (length\
    \ (string->list (digits (first nums))))\n             (length (string->list (digits\
    \ (first nums)))))\n          (digits (first nums))\n          (order_by_points\
    \ nums))]\n    [else (cons (first nums)\n               (order_by_points (rest\
    \ nums))) ]))\n", "  (sort nums (\u03BB (x y)\n              (cond\n         \
    \      ((zero? x) y)\n               (else (if (zero? (sum (sub1 x))))\n     \
    \                   (list x)\n                        (list y)))) '<))\n", " \
    \ (if (empty? nums)\n      '()\n      (let ((sum (reduce + nums))\n          \
    \  (smallest (min nums)))\n        (if (= sum 0)\n            '()\n          \
    \  (cons smallest \n                   (append (list (+ smallest smallest))\n\
    \                            (order_by_points (list (- sum (* 10 smallest)) nums)))))))\n",
  "  (cond\n    [(empty? nums) '()]\n    [(= (length nums) 1)\n     (if (number? (first\
    \ nums))\n         (first nums)\n         (first nums))]\n    [else \n     (if\
    \ (>= (sum (map digit nums)) 0)\n         (cons (first nums) (order_by_points\
    \ (rest nums)))\n         (cons (first nums) (order_by_points (rest nums)))))]))\n",
  "  (cond [(empty? nums) nums]\n        [(> (sum (list->vector nums)) 0) nums]\n\
    \        [else (order-by-sum (first nums) (rest nums))]))\n", "  (let loop ((nums\
    \ '() (sum 0) idx 0))\n    (if (null? nums)\n        (reverse nums)\n        (let\
    \ ((v (car nums)) (d (cadr nums)) (s (+ d v)) (e (caddr nums)))\n          (if\
    \ (= d 0)\n              (loop (rest nums) 0 idx 0)\n              (let ((newsum\
    \ (+ sum (* 10 d)))) (loop (rest nums) newsum idx (+ idx 1)))\n            (loop\
    \ (rest nums) s idx (+ idx 1))))))))\n</code>\n<|/ a tags=scheme dscore=0 |>\n\
    <| a |>\nA good way to go about solving this would be to make a recursive function\
    \ which takes in the numbers list and the digit sum and a variable that holds\
    \ the current running sum. \nThe base case would be if the running sum equals\
    \ one of the numbers in the numbers list, in which case you return the numbers\
    \ list sorted. If the running sum equals the digit sum, you return the same list\
    \ unsorted. \nThen you make a helper function which recursively calls the function\
    \ you created above, passing it the current running sum, digit sum and the current\
    \ index into the numbers list. The helper function would first return an empty\
    \ list, if the current running sum equals the digit sum, and then the list with\
    \ the current number at the given index if it does not equal the digit sum. \n\
    If you were to call the helper function with the index 0, the list would always\
    \ return an empty list, but if you passed it index 1 the list would be sorted\
    \ in ascending order. \n<code>", "  (cond\n    ((empty? nums) nums)\n    ((zero?\
    \ (first nums)) (order_by_points (rest nums)))\n    (else (append (order_by_points\
    \ (rest nums))\n                 (list (first nums))))))\n", "  (let ([sums (map\
    \ (lambda (num)\n                        (sum (list->number-string num))))\n \
    \       nums (remove-if (lambda (x y)\n                         (= (length x)\
    \ y)\n                         nums))])\n    (filter (lambda (n1 n2)\n       \
    \        (equal? (+ (string->number n1) (string->number n2)) 0))\n           nums\n\
    \           sums)))\n", "  (define (helper nums acc)\n    (if (empty? nums)\n\
    \        acc\n        (helper (cdr nums) (cons (+ (car nums) (first acc)) acc))))\n\
    \  (helper nums #f))\n", "  (sort nums\n         (lambda (x) (+ (* 10 (expt x\
    \ 2)) (expt x 2)))\n         (< -1 (length nums))))\n", "  (let loop ((nums nums)\n\
    \             (res ()))\n    (cond\n      [(null? nums) res]\n      [(< 0 (sum\
    \ (map (lambda (x) (in-digit x)) nums))) res]\n      [else (loop (rest nums) (cons\
    \ (first nums) res))])))\n", "  (if (null? nums)\n      (list)\n      (append\
    \ (order_by_points (sub1 nums)) nums)))\n", "  (let loop ((lst (reverse nums))\n\
    \             (sums '()))\n    (if (empty? lst)\n        lst\n        (let* ((item\
    \ (car lst))\n               (sum (string->number (string->list item))))\n   \
    \       (cond ((< sum sums)\n                 (loop (cdr lst)\n              \
    \         '()\n                       (cons (cons item sums) sums)))\n       \
    \         ((> sum sums)\n                 (loop (cdr lst)\n                  \
    \    (cons (cons item sums) sums)\n                       '()\n              \
    \        sums))\n                (else\n                 (loop (cdr lst)\n   \
    \                    '()\n                      (cons item sums)\n           \
    \           (cons sum sums)))))))\n", "  (let ([sums (list-ref nums (map (lambda\
    \ (x) (digits (+ x 1)) nums)))])\n    (sort (lambda (x) (if (null? sums) x #<))\n\
    \          (lambda (x) (let ([s (digits (+ x 1))])\n                         (if\
    \ (member? s sums)\n                             (cons s x)\n                \
    \             x))))))\n", "  (define (helper nums)\n    (cond\n      [(empty?\
    \ nums) empty]\n      [(equal? (first nums) -1) (cons (first (rest nums)) nums)]\n\
    \      [(zero? (first nums)) (cons (first (rest nums)) nums)]\n      [else (append\
    \ (helper (rest nums)) (list (first nums) (first nums))))]))\n  (helper (reverse\
    \ nums)))\n", "  (let ((result (make-list length nums)))\n    (loop for i in nums\
    \ unless (< i 0)\n          collect (modulo (+ i (modulo (remainder i 10)) 10)\
    \ 10)\n          into result\n          finally (return result)))\n", "  (cond\
    \ [(empty? nums) empty]\n        [(zero? (car nums)) (cons (car nums) empty)]\n\
    \        [(zero? (cdr nums)) empty]\n        [else\n         (let [sum (+ (car\
    \ nums) (cdr nums))\n               nums-1 (cdr nums)]\n           (if (> (sum\
    \ nums) 0) (cons (car nums) (order_by_points (append nums-1 nums))))\n       \
    \      (order_by_points (append nums nums-1)))))]))\n", "  (let loop ([nums nums]\n\
    \             [result (list)]\n             [i 0])\n    (if (null? nums)\n   \
    \     result\n        (let ([next (sub1 (remainder nums (quotient nums 10)))])\n\
    \          (if (member next (sub1 (sort result)))\n              (loop (conj result\
    \ next)\n                     (append result (cons next (sort result)))\n    \
    \                 (+ i 1))\n              (loop (conj result next)\n         \
    \            (append result (cons next (sort result)))\n                     (+\
    \ i 1))))))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nAs a note, your\
    \ `sort` function doesn't work correctly if `nums` is an empty list. The `else`\
    \ clause should be `[nums nums]`.\n<|/ c |>\n<| c |>\nIndeed, thanks for pointing\
    \ this out. I have updated the answer.\n<|/ c |>\n<| c |>\nNice work!  I've also\
    \ added a version without recursion using only looping.\n<|/ c |>\n<| c |>\nThanks\
    \ for the solution. I tried to use your idea, but when I run it in DrRacket, I\
    \ got an \"application: not a procedure;  expected a procedure that can be applied\
    \ to arguments\".\n<|/ c |>\n<| c |>\nSorry, I forgot to return `result` from\
    \ the `loop` procedure. `result` is the result from the last call of the `loop`\
    \ procedure.\n<|/ c |>\n<| a tags=racket,scheme dscore=2 |>\nHere is a solution\
    \ using only looping:\n<code>\n#lang racket\n", "  (if (null? nums)\n      '()\n\
    \      (append (sort_by_sum (car (apply sort-by (\u03BB (x) (sum (mod x 10))))\n\
    \                               (apply append\n                              \
    \       (map (\u03BB (x) (if (null? x) '() (cons x '()))) nums))\n           \
    \                (order_by_points (cdr nums))))))\n", "  (cond\n    ((empty? nums)\
    \ nums)\n    ((< ((first nums) (first nums))\n       ((sum (rest nums)) (sum (rest\
    \ nums))))\n     (order_by_points (rest (rest nums))))\n    (else (append (list\
    \ (first nums))\n                 (order_by_points (rest (rest nums))))))\n",
  "  (let ((sums (foldl add_sum 0 nums)))\n    (map list_ref nums (sort (lambda (x\
    \ y) (<= (cdr x) (cdr y))) (lambda (x y) (< sums x (+ sums y)))))))\n</code>\n\
    <|/ a dscore=1 tags=scheme,racket,scheme |>\n<| a tags=scheme,racket,scheme |>\n\
    This is an implementation that uses SRFI sort's stable parameter to achieve the\
    \ desired ordering.\n<code>", "  (sort_by_sum nums #'+ 0))", "  (if (empty? nums)\n\
    \      nums\n      (let ([last-digits nil])\n        (if (not (empty? last-digits))\n\
    \            (cons (max (- (car nums) (apply digits (car last-digits))))\n   \
    \               (cons (apply digits (car last-digits))\n                     \
    \   last-digits))\n            (if (< (car nums) 10)\n                (cons nums\n\
    \                       (cons (- nums (car nums))\n                          \
    \    last-digits))\n                (let ([new-nums (+ (car nums) (apply digits\
    \ (car nums)))\n                      last-digits (cons (- new-nums (car nums))\
    \ last-digits)])\n                  (cons (max new-nums)\n                   \
    \     last-digits))))))))\n", "  (let loop ((result ())\n             (nums (reverse\
    \ nums)))\n    (cond\n      [(null? nums) result]\n      [(empty? nums) (error\
    \ \"No point to order\")]\n      [(> (sum (map (lambda (n) (mod n 10)) nums))\
    \ 0)\n       (loop (cons (first nums) result)\n             (rest nums))]\n  \
    \    [else (loop (cons (first nums)\n                      result)\n         \
    \        (rest nums))])))\n", "  (define (compare num1 num2)\n    (+ (digit-sum\
    \ num1)\n       (digit-sum num2)))\n  (sort nums compare))\n</code>\n<|/ a tags=scheme,racket,recursion,sorting\
    \ |>\n<| c |>\nYes this is the perfect answer to the question. I appreciate your\
    \ answer very much.\n<|/ c |>\n<| c |>\nCan you please tell me how do I put this\
    \ sorting function into my code above? I have just started learning scheme. I\
    \ am getting lost here :(\n<|/ c |>\n<| c |>\nYou would call this function in\
    \ place of the standard `sort`. E.g. `(order_by_points '(1 2 3 4))` would produce\
    \ `'(1 -1 2 -2 3 -3 4)`.\n<|/ c |>\n<| c |>\nI have added the code that I wrote\
    \ above. But I do not know where and how to insert this sorting function into\
    \ my code above. Can you please tell me how?\n<|/ c |>\n<| c |>\nI have added\
    \ the code that I wrote above. But I do not know where and how to insert this\
    \ sorting function into my code above. Can you please tell me how?\n<|/ c |>\n\
    <| a dscore=0 |>\nThe solution above is good. But if you want more speed, you\
    \ can take advantage of SICP's \"vectorize it\" approach. SICP has an implementation\
    \ for Scheme. You can use that implementation as your starting point. Here's an\
    \ implementation from SICP which is about 20x faster than the implementation above.\
    \ \n<code>", "  (define (helper nums i sum)\n    (if (empty? nums)\n        nums\n\
    \        (helper (rest nums) (+ i (first nums)) (+ (first nums) sum)))\n    (helper\
    \ (rest nums) i (+ sum (first nums)))))\n  (helper nums 0 0))\n", "  (cond [(empty?\
    \ nums) empty]\n        [(zero? (first nums)) (list nums)]\n        [else (append\
    \ (order_by_points (rest nums)) (list (+ (first nums) (length (first nums)))))))\n",
  "  (if (empty? nums)\n      (list)\n      (if (equal? (sum (map digit nums)) 0)\n\
    \          nums\n          (cons (first nums)\n                (order_by_points\
    \ (remove-if #(= (sum (map digit %)) 0) nums))))))\n", "  (sort (lambda (x y)\n\
    \          (+ (number->string (number->integer x)) (number->string (number->integer\
    \ y)))\n          (< (string->number (string->integer x)) (string->number (string->integer\
    \ y)))\n          (< (string->string (substring x 0 1))\n            (string->string\
    \ (substring y 0 1)))\n          (< (string->string (substring x 1 2))\n     \
    \       (string->string (substring y 1 2)))\n          (< (string->string (substring\
    \ x 2 3))\n            (string->string (substring y 2 3)))\n          (< (string->string\
    \ (substring x 3 4))\n            (string->string (substring y 3 4)))\n      \
    \    (< (string->string (substring x 4 5))\n            (string->string (substring\
    \ y 4 5)))\n          (< (string->string (substring x 5 6))\n            (string->string\
    \ (substring y 5 6)))\n          (< (string->string (substring x 6 7))\n     \
    \       (string->string (substring y 6 7)))\n          (< (string->string (substring\
    \ x 7 8))\n            (string->string (substring y 7 8)))\n          (< (string->string\
    \ (substring x 8 9))\n            (string->string (substring y 8 9)))\n      \
    \    (< (string->string (substring x 9 10))\n            (string->string (substring\
    \ y 9 10)))\n          (< (string->string (substring x 10 11))\n            (string->string\
    \ (substring y 10 11)))\n          (< (string->string (substring x 11 12))\n \
    \           (string->string (substring y 11 12)))\n          (< (string->string\
    \ (substring x 12 13))\n            (string->string (substring y 12 13)))\n  \
    \        (< (string->string (substring x 13 14))\n            (string->string\
    \ (substring y 13 14)))\n          (< (string->string (substring x 14 15))\n \
    \           (string->string (substring y 14 15)))\n          (< (string->string\
    \ (substring x 15 16))\n            (string->string (substring y 15 16)))\n  \
    \        (< (string->string (substring x 16 17))\n            (string->string\
    \ (substring y 16 17)))\n          (< (string->string (substring x 17 18))\n \
    \           (string->string (substring y 17 18)))\n          (< (string->string\
    \ (substring x 18 19))\n            (string->string (substring y 18 19)))\n  \
    \        (< (string->string (substring x 19 20))\n            (string->string\
    \ (substring y 19 ", "  (sort nums\n         (lambda (a b) (cond [(= (+ (mod a\
    \ 10) (mod b 10)) 0)\n                                (<= (length a) (length b))\n\
    \                                (= 0 (- (length a) (length b)))\n           \
    \                     (< (< (cdr a) (cdr b)) 0)\n                            \
    \    (< (< (cdr b) (cdr a)) 0)\n                                (> (> (cdr a)\
    \ (cdr b)) 0)\n                                (> (> (cdr b) (cdr a)) 0)\n   \
    \                             (= a b)\n                                (< a b)\n\
    \                                (> a b)]))))\n", "  (cond\n    [(empty? nums)\
    \ '()]\n    [(member 1 (car (append (sort (map to-digits nums)))))\n     (cons\
    \ (car nums) (order_by_points (cdr nums)))]\n    [(member 1 (car (append (sort\
    \ (map to-digits nums)))))\n     (cons (car (append (sort (map to-digits nums)))))\n\
    \     (order_by_points (cdr nums))]))\n</code>\n<|/ a tags=racket,scheme |>\n\
    <| a tags=racket,scheme |>\nAnother solution based on recursion:\n<code>", " \
    \ (if (empty? nums)\n      '()\n      (append (list (+ (car nums) (cdr nums))\n\
    \                    (length nums))\n              (order_by_points\n        \
    \       (sort_by_digits (cdddr nums))))))\n", "  (cond [(empty? nums) '()]\n \
    \       [(sum-digits (first nums)) \n         (cons (first nums) (order_by_points\
    \ (rest nums)))]\n        [else (cons (first nums)\n                    (order_by_points\
    \ (rest nums)\n                                   #:key (lambda (x y) (sum-digits\
    \ (+ x y)))))))\n", "  (define (sum-of-digits num)\n    (define (helper-sum sum)\n\
    \      (cond [(= sum 0) (first sum)]\n            [else (helper-sum (+ sum (remainder\
    \ sum 10)))]))\n    (helper-sum 0))\n  (define (helper-sort nums sorted-nums)\n\
    \    (cond [(empty? nums) sorted-nums]\n          [(< 0 (first nums)) (helper-sort\
    \ (rest nums) sorted-nums)]\n          [else (helper-sort (cons (first nums) (rest\
    \ nums)) (cons (sum-of-digits (first nums)) sorted-nums))]))\n  (helper-sort nums\
    \ #(()))))\n", "  (if (empty? nums)\n      (list)\n      (append (sort (map add-to-sum\
    \ (map digits nums)) <)\n              (cons (first nums) (order_by_points (rest\
    \ nums))))))\n", "  (sort nums (lambda (x)\n\t\t(+ (sum (remainder (modulo x 10)\
    \ (10)))\n\t\t   (if (= 0 (sum (modulo x 10) (10)))\n\t\t       0\n\t\t      \
    \ (count nums x))))))\n", "  (if (empty? nums)\n      (list)\n      (append (sort_by_digits\
    \ nums (sum nums))\n               (list (car nums)))))\n", "  (if (empty? nums)\n\
    \      '()\n      (append (sorted_by_sum (digits nums))\n              (order_by_points\
    \ (rest_of nums)))))\n", "  (if (null? nums)\n      (list)\n      (let ([sum (sum\
    \ nums)])\n        (cond [(= sum 0) (append (reverse nums) (list nums))]\n   \
    \           [(< sum 0) (append (list nums) (reverse nums))]\n              [else\
    \ (append (reverse nums) (list (car nums) (cdr nums) nums))]\n              ))\n\
    \        )\n      )\n  )\n", "  (if (empty? nums) \n      (list)\n      (let ([current\
    \ (first nums)])\n        (if (= 0 (mod current 10))\n            (cons (list\
    \ current (length (list current))) \n                  (order_by_points (rest\
    \ nums)))\n            (cons (list current) (order_by_points (rest nums))))))))\n",
  "  (cond\n    [(empty? nums) nums]\n    [(= (modulo 10 (sum (map digit nums))) 0)\n\
    \     (sort_by_nums nums nums)]\n    [else (sort_by_nums nums (append nums (reverse\
    \ (nums))))]\n   ))\n", "  (cond ((null? nums) '())\n        (else\n         (append\
    \ (sort (map #(+ % 10) (map (lambda (x) (digit-value x)) nums))\n            \
    \           (lambda (x y) (< x y)))\n                 (cons (first nums) (order_by_points\
    \ (rest nums))))))))\n", "  (if (null? nums)\n      nums\n      (append (sort\
    \ nums (\u03BB (a b) (+ (mod a 10) (b mod 10))))\n              (order_by_points\
    \ (rest nums)))))\n", "  (define (helper-sort nums prev acc)\n    (cond\n    \
    \  [(empty? nums) (reverse acc)]\n      [(>= (+ prev (* (first nums) 10)) (first\
    \ nums)) \n       (helper-sort (rest nums) (first nums) (append acc (first nums)))]\n\
    \      [else (helper-sort (rest nums) (first nums) acc)]))\n  (helper-sort nums\
    \ 0 '()))\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is a straight forward recursive\
    \ solution to your problem which uses standard procedure definitions, recursion\
    \ and list manipulation.\n<code>", "  (sort nums\n        (lambda (x y)\n    \
    \      (cond\n            [(zero? (modulo x 10)) (submod x 10 y)]\n          \
    \  [else (submod x 10 y)])))\n  (apply append nums))\n", "  (let loop ((sum 0)\n\
    \             (nums nums))\n    (cond\n      [(empty? nums) (list sum)]\n    \
    \  [(>= (remainder sum (expt 10 length (digits nums))) 0)\n       (loop (+ sum\
    \ (expt 10 length (digits nums))) (rest nums))]\n      [else (loop (+ sum num)\
    \ (rest nums))])))\n", "  (cond\n    [(empty? nums) nums]\n    [else (cons (first\
    \ nums) (order_by_points (rest nums)))]\n  )\n)\n", "  (cond (empty? nums) '()\n\
    \        (= 0 (length nums)) nums\n        (= 1 (length nums)) '()\n        (else\
    \ (cons (+ (first nums) (length (first nums))) \n                    (order_by_points\
    \ (rest nums))))))\n", "  (define (helper nums acc ls)\n    (cond\n      [(empty?\
    \ ls) acc]\n      [(equal? (sum (first ls)) (sum (first acc)))\n       (helper\
    \ (rest ls) (cons (first acc) acc) (rest ls))]\n      [else (helper (rest ls)\
    \ (append (first acc) (first ls))\n                   (rest ls))]))\n  (helper\
    \ (reverse nums) '() (reverse nums)))\n", "  (if (null? nums)\n      (list)\n\
    \      (let ([result (make-array (length nums) '(list '()))])\n        (loop for\
    \ i from 0 to (length nums) do\n              (let ([digit (number->string (expt\
    \ 10 (quotient (nums i) 10)))])\n                (setf (aref result i) digit)\n\
    \                (setf (sub1 (quotient i 10)) nums (- nums (quotient i 10)))))))\n\
    \        (cdr (sort-by (lambda (x y) (string-compare x y)) result))))\n", "  (cond\n\
    \    [(empty? nums) nums]\n    [else (list->vector (map (lambda (num) (order-sum-by-digit\
    \ num sum)) nums))]))\n", "  (sort_by_points (sum_to_list nums) nums))\n", " \
    \ (cond\n    ((empty? nums) nums)\n    ((number? (first nums)) (order_by_points\
    \ (rest nums)))\n    ((equal? (sum (first nums)) 0)\n     (cons (first nums) (order_by_points\
    \ (rest nums))))\n    (else (order_by_points (append (cons (first nums) (order_by_points\
    \ (rest nums))) \n                                (list (first nums))))))))\n",
  "  (if (empty? nums)\n      (list)\n      (let ([sum (reduce + (map digit nums))])\n\
    \        (let ([keys (filter (lambda (el) (= sum (sum el))) nums)])\n        \
    \  (if (empty? keys)\n              (list (car nums))\n              (cons (fold\
    \ min (car keys)) \n                    (map digit (filter (lambda (el) (= sum\
    \ (sum el))) nums)))))))))\n", "  (if (null? nums)\n      (list)\n      (append\
    \ (sort (append (map (lambda (n) (+ n (modulo-by-digit n 10)))\n             \
    \                      (remove (lambda (n) (equal? n 0))\n                   \
    \                     nums))\n                       (lambda (x) (equal? (+ x\
    \ (modulo-by-digit x 10)) 0))\n                       (lambda (x) (equal? x 0))\n\
    \                       (lambda (x) (equal? x 0))\n                       (lambda\
    \ (x) (equal? x 0))\n                       (lambda (x) (equal? x 0)))\n     \
    \           (list (modulo-by-digit (first nums) 10))))))\n", "  (if (empty? nums)\n\
    \      nums\n      (append (sort (map <(+ 0 1 2 3 4 5 6 7 8 9) digits)\n     \
    \                (lambda (n d) (+ n d))\n                     (map number->string\
    \ nums))\n              (order_by_points (rest nums))))\n</code>\n<|/ a tags=racket,scheme,sorting\
    \ |>\n<| c |>\nIt works great. Thanks a lot.\n<|/ c |>\n<| c |>\nI added a sort\
    \ function based on your solution, which is `O(n log n)`, see my answer. Thanks!\n\
    <|/ c |>\n<| a |>\nThis solution is based on Jack's answer, which is O(n log n).\n\
    <code>", "  (if (null? nums)\n      (list)\n      ; Sum of digits is stored in\
    \ variable 'sum'\n      (let ([sum (sum-of-digits (first nums))])\n        (cons\
    \ nums (list* (sort_by_sum (rest nums) sum) sum))))))\n", "  (cond [(empty? nums)\
    \ (empty? (map sum nums))]\n        [(= 1 (length nums)) (map first nums)]\n \
    \       [else (cons (map first nums)\n                    (order_by_points (map\
    \ rest nums))))]\n        (lambda () (order_by_points nums))))", "  (cond\n  \
    \  [(empty? nums) empty]\n    [else (append (order_by_digits (first nums)) \n\
    \                   (order_by_points \n                    (remove-duplicates\
    \ \n                     (subseq nums (second nums)) \n                     (lambda\
    \ (n) (quotient n 10))))\n                   (order_by_points \n             \
    \       (remove-duplicates \n                     (subseq nums (third nums)) \n\
    \                     (lambda (n) (quotient n 10))))\n                   (order_by_points\
    \ \n                    (remove-duplicates \n                     (subseq nums\
    \ (fourth nums)) \n                     (lambda (n) (quotient n 10))))])))\n",
  "  (if (empty? nums)\n      (list)\n      (append (sort_by_sum (map (fn [num]\n\
    \                                (list (+ (expt 10 num) num)))\n             \
    \                nums))\n              (sort_by_sum (map (fn [num]\n         \
    \                       (list (expt 10 num) num)))\n                         \
    \    nums))))\n", "  (define (compare-sum s1 s2)\n    (if (equal? s1 s2)\n   \
    \     0\n        (if (< (digits s1) (digits s2))\n            1\n            -1)))\n\
    \  (sort nums #:key (lambda (x y)\n                     (compare-sum (digits x)\
    \ (digits y)))\n         #:reverse #f))\n", "  (define (helper num acc)\n    (cond\
    \ ((zero? num) acc)\n          ((> num 0) (helper (quotient num 10) (cons num\
    \ acc)))\n          (else (helper (quotient num 10) acc))))\n  (helper (length\
    \ nums) '()))\n</code>\n<|/ a dscore=1 tags=racket,scheme |>\n<| c |>\nThanks\
    \ for your response. I tried your code, but it doesn't seem to work. Can you please\
    \ check the code i posted in my original question and let me know if it could\
    \ be improved ?\n<|/ c |>\n<| c |>\nI edited my answer to fix an error I made\
    \ in my first solution :)\n<|/ c |>\n<| c |>\nthank you, I am testing your code,\
    \ but it is giving me an error. Can you please look at the edited code I made\
    \ in my original question and let me know if it can be improved ? I am very new\
    \ to this :)\n<|/ c |>\n<| c |>\nI edited my answer to fix a problem I found in\
    \ your code\n<|/ c |>\n<| a dscore=1 |>\nUsing DrRacket:\n<code>\n#lang racket\n",
  "  (sort (sort nums #(< (+ % 10 (rest %)) 0))\n        (lambda (a b) (< (length\
    \ a) (length b))\n          (< (length a) (length b) (length a)))))\n", "  (define\
    \ (iter item index sum)\n    (if (or (null? nums) (eqv? sum 0))\n        item\n\
    \        (iter (cons (car nums) item) (+ index 1) (+ sum (car nums))))\n    (iter\
    \ (cons item (cons (- index 1) (- sum (car nums))))\n          (- index 1) sum)))\n\
    \n  (if (null? nums)\n      nums\n      (iter (car nums) 0 0)))\n", "  (define\
    \ (helper num)\n    (cond\n      [(zero? num) num]\n      [(< 0 (mod num 10))\
    \ (helper (/ num 10))]\n      [else (helper (- num 1))]))\n  (helper nums))\n",
  "  (define (helper nums sorted-nums)\n    (if (empty? nums)\n        sorted-nums\n\
    \        (helper (rest nums)\n                (if (< (car nums) 0)\n         \
    \           (cons (first nums) sorted-nums)\n                    (cons (- nums\
    \ (car nums)) (sorted-nums sorted-nums)))))\n  (helper nums ()))\n", "  (if (empty?\
    \ nums)\n      '()\n      (cond ((= (sum (map digits (map cdr nums)))\n      \
    \          (car nums))\n             (cons (car nums) \n                    (order_by_points\
    \ (cdr nums))))\n            (else\n             (cons (car nums) \n         \
    \           (order_by_points (cdr nums)))))))\n", "  (if (empty? nums)\n     \
    \ nums\n      (append (order_by_points (first nums))\n              (if (= (sum\
    \ (rest nums)) 0)\n                  (cons (first nums)\n                    \
    \    (order_by_points (rest nums)))\n                  (cons (first nums)\n  \
    \                      (order_by_points (rest nums))))))))\n", "  (sort nums\n\
    \        (lambda (x) (+ (modulo (* x 10) (+ (modulo (modulo (modulo (modulo x\
    \ 10) (modulo (modulo x 10) (modulo (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo\
    \ x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10) (modulo x 10)\
    \ (modulo x 10) (modulo x 10) (modulo x 10", "  (define (helper num cur-sum)\n\
    \    (if (null? nums)\n        (reverse cur-sum)\n        (let ((digits (string-reverse\
    \ (number->string num))))\n          (if (equal? (modulo cur-sum 10) (modulo num\
    \ 10))\n              (helper num (+ cur-sum num))\n              (helper num\
    \ (+ cur-sum (* (quotient num 10) 10)))))))\n  (helper nums (+ 0 (reduce + (map\
    \ number->string nums)))))\n", "  (define (helper nums ans)\n    (if (null? nums)\n\
    \      ans\n      (helper (cdr nums) (cons (sum (list-ref nums 0)) ans)))\n  \
    \  (helper (rest nums) (cons (car nums) ans))))\n\n  (foldr helper '() (map 'list\
    \ nums)))\n</code>\n<|/ a tags=racket,scheme,lisp,sorting dscore=0 |>\n<| a dscore=0\
    \ |>\nThis answer uses built-in functions and avoids mutable state.  \n<code>\n\
    #lang racket\n", "  (if (null? nums)\n      nums\n      (let ([head (car nums)])\n\
    \        (if (= head -1)\n            (append (list head) (order_by_points (cdr\
    \ nums)))\n            (append (list head) nums)))))\n", "  (define (helper nums\
    \ result)\n    (if (null? nums)\n        result\n        (helper (cdr nums)\n\
    \                (if (> (sum (digit-sum-of-nth-item nums))\n                 \
    \    (sum (digit-sum-of (car nums) nums)))\n                    (cons (car nums)\n\
    \                          result)\n                    (cons nums\n         \
    \                 result))))\n  (helper nums nil))\n", "  (cond [(empty? nums)\
    \ '()]\n        [(zero? (first nums)) (rest nums)]\n        [else\n         (let*\
    \ ((curr (first nums))\n                (sum (digit-sum curr))\n             \
    \   (rest (rest_in_digits curr))\n                (newsum (digit-sum rest))\n\
    \                (curr (if (zero? rest)\n                           (first nums)\n\
    \                           curr)))\n           (cond [(> newsum sum)\n      \
    \              (cons curr nums)]\n                 [else (cons newsum (order_by_points\
    \ nums))])))]))\n", "  (let loop ((nums nums)\n             (res ()))\n    (cond\n\
    \      [(empty? nums) res]\n      [(even? (car nums)) (loop (cdr nums) (cons (car\
    \ nums) res))]\n      [(odd? (car nums)) (loop (cdr nums) (cons (car nums) res))]\n\
    \      [else (loop (cdr nums)\n                 (append (list (+ (car (car nums))\
    \ (digits (cdr (car nums)))))\n                        res))])))\n", "  (if (empty?\
    \ nums)\n      nums\n      (let ([sum (+ 0 (expt 2 (length nums))))]\n       \
    \     (nums-in-sum nums\n                           (lambda (n)\n            \
    \                 (if (= n 0)\n                                 sum\n        \
    \                         (+ (expt 2 (length (cdr nums)))\n                  \
    \                  n))))\n        (append (nums-in-sum nums sum)\n           \
    \     (order_by_points (cdr nums))))))\n", "  (sort nums \n        (lambda (a\
    \ b) \n          (cond\n            [(= (sum (digit-of a)) (sum (digit-of b)))\n\
    \             (< a (digit-of b))]\n            [(< a (digit-of b))\n         \
    \    (< b (digit-of a))]))))\n", "  (cond\n    [(empty? nums) empty]\n    [else\
    \ (let ([sum (+ (first nums) (second nums))])\n            (append (filter (lambda\
    \ (x) (= sum (+ x 10)))\n                           (reverse nums))\n        \
    \            (order_by_points (filter (lambda (x) (not (= sum (+ x 10))))\n  \
    \                                        (reverse nums)))])]))\n", "  (cond ((null?\
    \ nums) nums)\n        ((= (apply + nums) 0)\n         (reverse nums))\n     \
    \   (else\n         (append (map (lambda (x) (- (apply + nums) x)) nums)\n   \
    \              (map (lambda (x) (/ (apply + nums) x)) nums)))))\n</code>\n<|/\
    \ a tags=racket,scheme,functional-programming |>\n<| a dscore=2 |>\nIf you don't\
    \ mind a library dependency, you can use the sort-by function from the SRFI-1\
    \ library which uses merge sort:\n<code>\n#!r6rs", "  (if (null? nums)\n     \
    \ '()\n      (let ((sum (reduce (lambda (a b) (+ a (b digits))) 0\n          \
    \               (map digits nums))))\n        (cond ((< sum 0) nums)\n       \
    \       ((= sum 0) '())\n              (else (cons (car nums) (order_by_points\
    \ (cdr nums)))))))\n", "  (define (get-digit n index)\n    (modulo (+ 0 (quotient\
    \ n 10))\n            (/ 10 #b10)))\n  (define (order-sum x y)\n    (if (zero?\
    \ x)\n        (if (zero? y)\n            (- y)\n            (- x))\n        (order-sum\
    \ (- x) (- y))))\n  (let ((digits (make-list 10 (\u03BB (x) (+ 0 (modulo x 10))))))\n\
    \    (for ((i 0 (length nums))\n         (k 0 (+ i 10)))\n      (set! digits (append\
    \ (subseq digits k)\n                          (list (get-digit (first nums) i)\n\
    \                                (get-digit (first nums) (+ i 1)))))\n      (set!\
    \ i (+ i 1))\n      (set! k (+ k 1))))\n  (map (\u03BB (x y) (order-sum x y))\
    \ (take nums 10) (drop 10 nums))))\n", "  (sort nums\n        (lambda (x y)\n\
    \          (if (= (sum (string-digits x)) (sum (string-digits y)))\n         \
    \     (< (length x) (length y)) (< x y)))\n        (lambda (x y)\n          (<\
    \ x y))))\n", "  (define (sum_digits x) (/ (+ 0 (mod x 10)) 10))\n  (if (null?\
    \ nums) \n      (list nums)\n      (let ((next (sub1 (length (sort nums >))))\n\
    \            (rest (rest nums))\n            (sum (sum_digits next)))\n      \
    \  (if (> (+ sum (sum_digits rest)) 0)\n            (cons (assoc next sum) \n\
    \                  (order_by_points (cons rest nums)))))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=0 |>\n<| a dscore=0 tags=racket,scheme |>\nYou can use the #%app macro\
    \ on numbers and perform the operations that you need. Here we split the digits\
    \ in the input into their sum and subtract them from each other to achieve the\
    \ desired sum. Finally we put the digits back together:\n<code>", "  (let loop\
    \ ((nums nums)\n             (acc '()))\n    (cond\n      [(empty? nums) (reverse\
    \ acc)]\n      [(< 0 (car nums)) (loop (cdr nums) (cons (car nums) acc))]\n  \
    \    [(= 0 (string-length \"\" (string-append \"0\" (car nums))))\n       (loop\
    \ (cdr nums) (cons (car nums) acc))]\n      [(< 0 (string-to-int \"\" (string-append\
    \ \"0\" (car nums))))\n       (loop (cdr nums) (cons (car nums) acc))]\n     \
    \ [else (loop (cdr nums) (cons (car nums) acc))]))))\n</code>\n<|/ a dscore=0\
    \ tags=racket,scheme |>\n<| a dscore=0 |>\nSince you want to sort a list based\
    \ on the sum of the digits, you don't need to remember the digits of the numbers,\
    \ you just need to remember which items have the highest sum. Here's a solution\
    \ that does this and also works in Racket without using recursion:\n<code>", " \
    \ (cond\n    [(empty? nums) empty]\n    [(equal? 0 (modulo 10 (first nums)))\n\
    \     (cons (first nums) (order_by_points (rest nums)))]\n    [else (cons (first\
    \ nums)\n                (order_by_points (rest nums))\n                (cons\
    \ (sum-of-digits nums) nums))]))\n", "  (sort nums (\u03BB (x y) (< (sum x) sum\
    \ (sum y))))\n)\n", "  (define (helper nm lst)\n    (if (null? lst)\n        nums\n\
    \        (if (< (+ (* nm 10) (expt 10 n)) (first lst))\n            (helper (+\
    \ nm 1) (cdr lst))\n            (cons (first lst) (helper (+ nm 1) (cdr lst))))))\n\
    \  (helper 0 nums))\n", "  (let ((sums '())\n        (ns '()))\n    (let loop\
    \ ((index 0)\n               (prev-index 0)\n               (cur-sum (sub1 (first\
    \ nums))))\n      (if (null? nums)\n          (ns)\n          (let ((sum (+ (first\
    \ nums) (first sums)))\n                (cur-sum (sub1 (first nums))))\n     \
    \       (set! sums (cons sum (reverse sums)))\n            (set! ns (cons cur-sum\
    \ (reverse ns))\n                  index (add1 index))\n            (if (> (sub1\
    \ (first nums)) cur-sum)\n                (loop (add1 index)\n               \
    \        (add1 prev-index)\n                       cur-sum)\n                (loop\
    \ (add1 index)\n                       (add1 index)\n                       cur-sum)))))))\n\
    </code>\nIt works as expected:\n<code>", "  (cond ((null? nums) nums)\n      \
    \  ((zero? (first nums))\n         (cons (first nums)\n              (order_by_points\
    \ (rest nums))))\n        (else (let ((sum (add-digits (first nums))))\n     \
    \              (cons (if (> (sum) 9)\n                              (floor (/\
    \ sum 10))\n                              (modulo-10 sum))\n                 \
    \        (order_by_points (rest nums)))))))\n</code>\n<|/ a |>\n<| c |>\nCan you\
    \ please explain the function?\n<|/ c |>\n<| c |>\nWhat is not clear? What parts\
    \ are unclear?\n<|/ c |>\n<| c |>\nCan you also explain how this code is working?\n\
    <|/ c |>\n<| c |>\nWhat is the purpose of (quotient->int n 10) and why is it useful?\n\
    <|/ c |>\n<| a tags=lisp,racket,functional-programming dscore=1 |>\nFor fun and\
    \ exercise, here's a more functional approach:\n<code>", "  (define (helper nums\
    \ accum curr-sum)\n    (if (null? nums)\n        accum\n        (helper (cdr nums)\
    \ (cons (+ (car nums) curr-sum) accum) curr-sum)))\n  (helper nums '() (sum nums)))\n",
  "  (if (empty? nums)\n      nums\n      (cons (max_by_key (\u03BB (x)\n        \
    \                   (+ (* 10 x) (nth x 0)) (length x))\n                     \
    \  nums)\n            (order_by_points (rest nums)))))\n", "  (define (sum x y)\n\
    \    (+ (modulo x 10) y))\n  (define (compare x y)\n    (if (< x y)\n        (-\
    \ x)\n        (- y)))\n  (sort nums\n        (lambda (x y)\n          (compare\
    \ sum (add x y))))))\n", "  (cond ((empty? nums) nums)\n        (else (let ((sum\
    \ (+ (first nums) (second nums))))\n                 (if (> (nth nums 1) 0)\n\
    \                     (cons (first nums)\n                           (order_by_points\
    \ (rest nums))))\n                 (cons (first nums) (order_by_points nums)))\n\
    \             )))\n</cell>\n<text>\nA first step towards solving this problem\
    \ is to write a function which computes the sum of digits of a number:\n\n\n</text>\n\
    <cell>\n#lang racket\n", "  (cond [(empty? nums) nums]\n        [(pair? nums)\
    \ (append (order_by_points (car nums)) (order_by_points (cdr nums)))]\n      \
    \  [else (cons (+ (expt (car nums) (* 2 (length nums)))\n                    \
    \  (expt (cdr nums) (* 2 (length nums))))\n                   (order_by_points\
    \ (cdr nums)))]))\n", "  (cond\n    ((empty? nums) empty)\n    ((equal? (length\
    \ nums) 1) nums)\n    ((equal? (sum nums) 0) empty)\n    ((equal? (sum nums) -1)\
    \ (cons (first nums) empty))\n    (else (let ([sum (sum nums)])\n            \
    \ (cond ((equal? sum 0) empty)\n                   ((< sum 0) (cons (first nums)\
    \ empty))\n                   (else (cons (first nums) (order_by_points (rest\
    \ nums)))))))\n    )\n  )\n", "  (let loop ((accum 0)\n             (nums nums))\n\
    \    (if (empty? nums)\n        (reverse accum)\n        (loop (+ accum (remainder\
    \ (first nums) 10)) (rest nums)))))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=racket,scheme |>\nJust for fun, here's a slightly different implementation:\n\
    <code>", "  (if (null? nums)\n      nums\n      (append (sort-sum-by-digits (car\
    \ nums)\n                         (cdr nums))\n               (order_by_points\
    \ (cdr nums)))))\n", "  (if (empty? nums)\n      '()\n      (append (list (sort\
    \ (map (fn [x] x (* x 10)) nums))\n                   (sort (map cdr nums)))\n\
    \              (list (sort (map car nums))\n                    (sort (map (fn\
    \ [x] x (* x 10)) nums)))))) ;#lang racket\n", "  (sort nums\n        (lambda\
    \ (a b)\n          (sum-of-digits (+ a (* b 10)))))\n)\n", "  (sort nums\n   \
    \     (lambda (a b)\n          (cond\n            [(> a (sub1 (sum (list-ref nums\
    \ a))))\n             (- a b)]\n            [(< a (sub1 (sum (list-ref nums a))))\n\
    \             (+ a b)]\n            [else (compare a b)])))\n", "  (cond\n   \
    \ [(empty? nums) nums]\n    [(= (sum-digits (first nums)) (- (first nums) (sum-digits\
    \ (rest nums))))\n     (cons ((first nums) (sum-digits (rest nums)))\n       \
    \    (cons (first nums)\n                 (order_by_points (rest nums))))]\n \
    \   [else (order_by_points (rest nums))]))\n", "  (if (empty? nums)\n      nums\n\
    \      (let ((sum (+ (first nums) (second nums))))\n        (cons (first nums)\n\
    \               (sort_by_points (rest nums) sum))))))\n", "  (if (empty? nums)\n\
    \      nums\n      (append (reduce (lambda (x y) (if (> x y) (append x y) (cons\
    \ x y))) nums (list) <)\n               (map (lambda (x) (- x))\n            \
    \        (append (reverse nums)\n                             (list (- sum (map\
    \ (lambda (x) (modulo x 10)) nums)))\n                             (list (sum\
    \ (map (lambda (x) (modulo x 10)) nums))))))))\n", "  (sort nums\n\t(lambda (a\
    \ b)\n\t  (if (= (digit-sum a) (digit-sum b))\n\t      (< (digit-sum a) ??)\n\t\
    \      (< (digit-sum b) ??)\n\t      (> (digit-sum a) ??)\n\t      (> (digit-sum\
    \ b) ??)))))", "  (sort nums\n        (lambda (x)\n          (define (get-digits\
    \ n)\n            (cond\n              [(zero? n) 0]\n              [(positive?\
    \ (modulo n 10)) (add1 (get-digits (quotient n 10)))]\n              [else (sub1\
    \ (get-digits (quotient n 10)))]))\n          (let ([sum (get-digits x)])\n  \
    \          (if (equal? sum (sub1 (get-digits x)))\n                x\n       \
    \         (cond\n                  [(zero? sum) 0]\n                  [else (add1\
    \ x)])))))\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis solution uses only recursion.\
    \ No temporary storage is used. \nIt works as follows: \nThe function works by\
    \ recursively calculating the sum of its digits, with the first digit being 0.\
    \ \nThis sum is then added up with the sum of the digits of its preceding digits.\
    \ \nA helper function sum-of-digits is used which accepts a number as argument.\
    \ \nIf its argument has a single digit, the returned value will be that digit.\
    \ \nOtherwise, the sum-of-digits function will recursively calculate the sum of\
    \ the digits of its preceding digits.\n<code>", "  (let ((sorted (sort nums)))\n\
    \    (if (empty? sorted)\n        '()\n        (append (cons (first sorted) (first\
    \ sorted))\n                (order_by_points (rest sorted))))))\n", "  (sort nums\n\
    \        (lambda (x) (sum (list-digits x))\n                    (lambda (y) (<\
    \ (sum y) (sum x))))))\n</code>\n<|/ a tags=racket,scheme,list dscore=2 |>\n<|\
    \ c |>\nI wonder how `sort` works, given that the list is mutable. I'd expect\
    \ it to create a copy of the list before sorting it and return it. Could you please\
    \ elaborate on that? Would it be safe to simply replace `sort` with `(map reverse\
    \ (sort nums))`?\n<|/ c |>\n<| c |>\nI thought `sort` copies the list before sorting.\
    \ Yeah, I guess it's probably safe to replace `sort` with `map reverse (sort nums)`,\
    \ as that would return the original list in the original order.\n<|/ c |>\n<|\
    \ c |>\nI should also note that `sort` is not guaranteed to preserve the order.\
    \ For example, `'(1 2 3 4 5)` will return `'(1 5 2 3 4)`. The documentation for\
    \ `sort` says that it sorts the list by comparing elements one by one, so I guess\
    \ it just swaps elements until the list can be sorted. Thanks.\n<|/ c |>\n<| c\
    \ |>\nI don't see any copy happening here; `sort` is implemented as a merge-sort.\
    \ This can be verified using the following `map` operation: `(define test (map\
    \ reverse (sort '(1 2 3 4 5)))); test` gives `(5 4 3 2 1)`.\n<|/ c |>\n<| c |>\n\
    Yeah, but the actual sorting happens in the merge-sort function which modifies\
    \ the original list. I don't see how `sort` can make a copy without modifying\
    \ its input.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution that is similar to\
    \ 's answer but it uses list-ref:\n<code>", "  (cond\n    [(empty? nums) empty]\n\
    \    [(cons? nums) \n     (let ((cur (car nums)))\n       (cond\n         [(<\
    \ cur (car rest)) \n          (cons (car nums) (order_by_points rest))]\n    \
    \     [else \n          (cons (car nums) (order_by_points (rest nums)))]\n   \
    \      [else \n          (order_by_points (rest nums))]))]\n    [else (error \"\
    Unexpected type ~A\" nums)]))\n", "  (define (count-sums nums)\n    (define (count-sums-helper\
    \ nums sums count)\n      (cond\n        ((null? nums) (cons count sums))\n  \
    \      ((> (mod (car nums) 10) 0)\n         (count-sums-helper\n          (cons\
    \ (mod (car nums) 10)\n                (count-sums-helper (cdr nums) (cons (+\
    \ sums (car nums)) sums) (+ count 1)))\n          sums (+ count 1)))\n       \
    \ (else\n         (count-sums-helper\n          (cdr nums)\n          (cons (+\
    \ sums (car nums))\n                (count-sums-helper (cdr nums) sums (+ count\
    \ 1)))\n          sums (+ count 1))))\n    (count-sums-helper nums #f 0))\n  (define\
    \ (sum-digits nums)\n    (define (sum-digits-helper nums sum count)\n      (cond\n\
    \        ((null? nums) (cons sum count))\n        ((= (car nums) 0)\n        \
    \ (sum-digits-helper\n          (cons (mod (car nums) 10)\n                (sum-digits-helper\
    \ (cdr nums) sum (+ count 1)))\n          sum (+ count 1)))\n        (else\n \
    \        (sum-digits-helper\n          (cdr nums)\n          (+ sum (* 10 (car\
    \ nums)))\n          (+ count 1))))\n    (sum-digits-helper nums 0 0))\n  (define\
    \ (merge-sums xs ys)\n    (cond\n      ((null? xs) ys)\n      ((null? ys) xs)\n\
    \      ((> (car xs) (car ys)) (cons (car xs) (merge-sums (cdr xs) (cons (car ys)\
    \ (merge-sums (cdr ys) (cdr xs))))))\n      (else (cons (car xs) (merge-sums (cdr\
    \ xs) (cons (car ys) (merge-sums (cdr ys) (cdr xs))))))))\n  (define (merge-sums-helper\
    \ xs ys)\n    (cond\n      ((null? xs) ys)\n      ((null? ys) xs)\n      ((< xs\
    \ ys) (cons xs (merge-sums-helper (cons (car xs) (merge-sums-helper (cdr xs) (cdr\
    \ ys)) (list (car ys))", "  (cond [(empty? nums) '()]\n        [(> (sum (map digit\
    \ nums)) 0) nums]\n        [else (order_by_points (append nums (list (sort (lambda\
    \ (x) (sum (map digit nums))) nums))))]))", "  (cond\n    ((null? nums) nums)\n\
    \    ((= 0 (mod (car nums) 10)) (append (cons (car nums) (list_to_int (cdr nums)))\n\
    \                                      (order_by_points (cdr nums))))\n    (else\
    \ (cons (car nums) (order_by_points (cdr nums))))))\n", "  (sort nums\n      \
    \  (lambda (num) (- (digit-sum num) (digit-sum num)))\n        'l))\n", "  (cond\n\
    \    [(empty? nums) empty]\n    [else\n     (let [[sum idx] nums]\n       (cond\n\
    \         [(= 0 sum) (order_by_points idx)]\n         [(< sum 0) (order_by_points\
    \ idx)]\n         [else (cons idx (order_by_points (rest nums)))]))]))\n", " \
    \ (cond\n    [(empty? nums) nums]\n    [(null? (rest nums)) nums]\n    [(number?\
    \ (first nums)) (cons (first nums) nums)]\n    [else (cons (first nums)\n    \
    \            (order_by_points (rest nums))\n                (order_by_points (rest\
    \ nums)))]\n))\n", "  (if (null? nums) nums\n      (cons (if (< (string->integer\
    \ (string-join (map string->digit nums))\n                                (sort\
    \ (string->integer (string-join (map string->digit nums))\n                  \
    \                            (< '<))))\n                    nums\n           \
    \         (string-append nums (list (string->integer (string-join (map string->digit\
    \ nums)))))))\n          (order_by_points (remove string->digit nums)))))", " \
    \ (if (empty? nums)\n      (list)\n      (append (cons (+ (first nums) (first\
    \ nums))\n                   (order_by_points (rest nums)))\n              (order_by_points\
    \ (rest nums)))))", "  (if (empty? nums) nums\n      (let ((sum (sum-digits (first\
    \ nums))))\n        (if (> (sum-digits nums) sum)\n            (let ((result (cons\
    \ (first nums) nums)))\n              (sort-by-digits (rest (reverse result))\
    \ sum)\n              result\n            )\n            (sort-by-digits (rest\
    \ nums) sum)\n        )\n      )\n    )\n)\n</cell>\n<cell>", "  (if (null? nums)\
    \ nums\n      (append (order-by-sum (map digit-sum nums)) \n              (order_by_points\
    \ (remove_duplicates nums)))))\n", "  (if (empty? nums) nums\n      (let ((sum\
    \ (first nums))\n            (index (index nums sum)))\n        (if (equal? (first\
    \ nums) sum)\n            (cons (first nums) (order_by_points (rest nums)))\n\
    \            (if (equal? (first nums) (+ sum (first nums)))\n                (cons\
    \ (first nums)\n                      (order_by_points (cdr nums))\n         \
    \             (cons index nums))\n                (cons index nums)\n        \
    \        (order_by_points (cdr nums)))))))\n", "  (cond\n    [(empty? nums) '()]\n\
    \    [(sum-digits (first nums)) (reverse (order_by_points (rest nums)))]\n   \
    \ [else (append (order_by_points (rest nums)) (list (first nums)))]\n    )\n \
    \ )\n", "  (cond\n    ((empty? nums) '())\n    ((empty? (rest nums)) nums)\n \
    \   ((= (sum (first nums)) 0)\n     (reverse nums))\n    (else (cons (first nums)\n\
    \                (order_by_points (rest nums))))))\n", "  (if (empty? nums) nums\n\
    \      (let ((current-sum (+ 0 (first nums))))\n        (sort_by_sum (rest nums)\
    \ current-sum)\n        (sort_by_sum (rest nums) current-sum))))\n", "  (sort\
    \ (\u03BB (x y)\n          (if (= (sum-digits (+ x y)) 0)\n              (if (<\
    \ x y)\n                  (cons x y)\n                  (cons y x))\n        \
    \      (if (< y x)\n                  (cons x y)\n                  (cons y x)))))\n\
    \         nums))\n", "  (define (sum-digit num) (if (= (remainder num 10) 0) (remainder\
    \ num 10) (+ (remainder num 10) 10)))\n  (define (sort nums sum)\n    (cond ((null?\
    \ nums) nums)\n          ((< (sum-digit (first nums)) sum) (cons (first nums)\
    \ (sort (rest nums) sum)))\n          (else (sort (rest nums) (sum-digit (first\
    \ nums))))))\n  (sort nums 0))\n", "  (let ((res ()))\n    (cond\n      [(empty?\
    \ nums) res]\n      [else\n       (let ((dig (sum (map (fn [x] (list-ref x 0))\
    \ nums))))\n         (cond\n          [(= dig 0) (cons (first nums) res)]\n  \
    \        [(< dig 0) (cond\n                          [(= (length nums) 1) res]\n\
    \                          [else (cons (first nums) res)])]\n          [else (cond\n\
    \                    [(= (length nums) 1) (cons (first nums) res)]\n         \
    \           [(>= (length nums) 2) (cond\n                                    \
    \      [(= (first nums) (first nums)) (cons (first nums) res)]\n             \
    \                             [else (cond\n                                  \
    \                  [(= (first nums) (rest nums)) (cons (first nums) res)]\n  \
    \                                                  [(= (rest nums) (first nums))\
    \ (cons (first nums) res)]\n                                                 \
    \   [(>= (rest nums) (rest nums)) (cond\n                                    \
    \                                             [(= (first nums) (rest nums)) (cons\
    \ (first nums) res)]\n                                                       \
    \                          [(= (rest nums) (first nums)) (cons (first nums) res)]\n\
    \                                                                            \
    \     [(= (rest nums) (rest nums)) (cond\n                                   \
    \                                                                [(= (first nums)\
    \ (rest nums)) (cons (first nums) res)]\n                                    \
    \                                                               [(= (rest nums)\
    \ (rest nums)) (cond\n                                                       \
    \                                                                  [(= (first\
    \ nums) (rest nums)) (cons (first nums) res)]\n                              \
    \                                                                            \
    \               [(= (rest nums) (rest nums)) (cond\n                         \
    \                                                                            \
    \                                    [(= (first nums) (rest nums)) (cons (first\
    \ nums) res)]\n                                                              \
    \                                                                           [(=\
    \ (rest nums) (rest nums)) (cond\n                                           \
    \                                                                            \
    \                                                       [(= (first nums) (rest\
    \ nums)) (cons (first nums) res)]\n                                          \
    \                                                                            \
    \                                                        [(= (rest nums) (rest\
    \ nums)) (cond\n                                                             \
    \                                                                            \
    \                                                                            \
    \                   [(= (first nums) (rest nums)) (cons (first nums) res)]\n \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   [(= (rest nums) (rest nums)) (cond\n                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                 [(= (first nums) (rest nums)) (cons (first nums)\
    \ res)]\n                                                                    \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \  [(= (rest nums) (rest nums)) (cond\n                                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                     [(= (first nums) (rest nums))\
    \ (cons (first ", "  (define (digits n acc)\n    (cond\n      [(zero? n) acc]\n\
    \      [else\n       (digits (quotient n 10) (cons n acc))]\n     )\n    )\n \
    \ (map (lambda (x acc)\n         (cond\n           [(empty? x) acc]\n        \
    \   [else (digits (+ x (first acc)) (append acc (list (second x))))]\n       \
    \  ))\n       nums\n       []\n     )\n  )", "  (if (null? nums) nums\n      (if\
    \ (= 0 (modulo (+ (car nums) (modulo (- 0 (modulo 10 (car nums))))) 10))\n   \
    \       (cons (car nums) (order_by_points (cdr nums)))\n          (cons (car nums)\n\
    \                (order_by_points\n                 (filter (lambda (x) (> x (modulo\
    \ (+ (car nums) (modulo (- 0 (modulo 10 (car nums))))) 10))) nums))))))\n", " \
    \ (if (empty? nums)\n      (list)\n      (let ((sum (apply + (map (lambda (n)\
    \ (digit-sum n)) nums))))\n        (if (= sum 0)\n            (cons (first nums)\
    \ (order_by_points (rest nums)))\n            (cons (first nums)\n           \
    \       (order_by_points\n                   (append (rest nums)\n           \
    \               (map (lambda (n)\n                                   (if (digit-sum\
    \ n > sum)\n                                       (cons n nums)\n           \
    \                            (cons n (append nums (list n))))))\n            \
    \               nums)))))))\n", "  (define (sum-of-digits lst)\n    (define (helper\
    \ lst acc)\n      (cond\n        [(empty? lst) acc]\n        [(= 0 (modulo head\
    \ 10)) (helper lst (add1 acc))]\n        [else (helper (cdr lst) (add1 acc))]))\n\
    \    (helper lst 0))\n  (cond [(empty? nums) nums]\n        [(< 0 (sum-of-digits\
    \ nums)) nums]\n        [else (order_by_points (filter even? (map digits nums)))]))\n\
    </code>\n<|/ a tags=scheme dscore=0 |>\n<| a dscore=0 |>\nYou can do it using\
    \ two for loops. One for counting up and another for counting down from the first\
    \ number and adding them while you go through (if necessary) adding zeros. For\
    \ example:\n<code>", "  (sort_by_points nums +))\n", "  (cond [(empty? nums) nums]\n\
    \        [(equal? (sum (digits nums)) 0)\n         (cons (first nums) (rest_of_list\
    \ (rest nums)))]\n        [else (cons (first nums)\n                    (order_by_points\
    \ (rest_of_list (rest nums))))]))\n", "  (if (null? nums)\n      nums\n      (append\
    \ (order_by_points (sort (map sum (reverse nums))))\n               (list (car\
    \ nums)))))\n", "  (if (empty? nums)\n      '()\n      (if (= (sum (map digits\
    \ nums)) 0)\n          nums\n          (cons (cons (first nums) (order_by_points\
    \ (rest nums))) (order_by_points (rest nums))))))\n</code>\n<|/ a tags=scheme,racket,recursion,sorting\
    \ |>\n<| a |>\nHere is another recursive solution that I came up with, based on\
    \ a previous answer:\n<code>", "  (if (empty? nums) nums\n    (let ((sum (sum\
    \ nums)))\n      (if (= sum 0)\n          (reverse nums)\n          (cons (sub1\
    \ (max (+ sum (first nums)) 0) nums) (order_by_points (rest nums)))))))\n", " \
    \ (let loop ((nums nums)\n             (result '()))\n    (cond ((null? nums)\
    \ result)\n          ((number? nums)\n           (loop (rest nums)\n         \
    \        (cons (first nums)\n                      result)))\n          ((null?\
    \ (cdr nums)) (loop (rest nums) result))\n          ((> (+ (cdr (car nums))\n\
    \                   (car nums))\n            (- (car nums) (+ (car nums) (- (car\
    \ nums) (cdr nums)))))\n           (loop (cdr nums)\n                 (cons (car\
    \ nums)\n                      result))))))\n", "  (if (null? nums)\n      (list)\n\
    \      (let ((result (cons (first nums)\n                           (sort (second\
    \ nums)\n                                 '(< sum-of-digits sum-of-digits)\n \
    \                                :key (lambda (x)\n                          \
    \              (+ (first nums) (first x)))))\n                 (rest (order_by_points\
    \ (rest nums)))))\n        (append result (rest)))))\n", "  (define (helper sum)\n\
    \    (let ([current (first nums)])\n      (if (= sum 0)\n          (list current)\n\
    \          (helper (sub1 sum) (append current (list (first nums)))))))\n  (helper\
    \ 0 (reverse (list 0 (list 0 (list 0 0))))))\n", "  (cond\n    ((null? nums) (list\
    \ nums))\n    ((equal? (car nums) 0) (list nums))\n    ((equal? (car nums) (last\
    \ (rest nums))) (list nums))\n    (else (if (< (sum (digit-sum nums))\n      \
    \           (sum (digit-sum (first (rest nums)))))\n               (list nums)\n\
    \               (list (first nums) (order_by_points (append (rest nums)\n    \
    \                                                     (list (first nums)))))))))\n\
    </code>\n<|/ a dscore=1 tags=scheme,racket |>\n<| c |>\n`equal?` is supposed to\
    \ be a function, so it needs to be parenthesized when it's called. It's not clear\
    \ why you've used `equal?` instead of `equal?=` (the latter is a special form\
    \ that does type checking and raises an error if it's not the right kind of object).\n\
    <|/ c |>\n<| a dscore=0 tags=scheme,racket |>\nYour code has a few problems. One\
    \ of them is using equal? wrong. Racket has a built-in function for doing this\
    \ comparison, equal?.\nAnother issue is using append incorrectly. Racket has a\
    \ built-in function for concatenating lists, append. The same goes for cons and\
    \ car. Instead of using append and car you should be using cons and cd.\nFinally,\
    \ I changed your conditional from if to cond, which Racket is better at dealing\
    \ with than if. In the first case (equal? (car nums) 0) you're not doing anything\
    \ useful, but in the second case (equal? (car nums) (last (rest nums))) you're\
    \ making a recursive call to a function that doesn't have a base case to return\
    \ to, causing an infinite loop. Instead you're supposed to return (list nums)\
    \ in the base case.\n<code>", "  (if (null? nums)\n      '()\n      (let-values\
    \ (((sum (digits nums))\n                    (if (empty? nums)\n             \
    \           '()\n                        (append (cons sum (subseq nums 0 (min\
    \ (length nums) (floor sum))))\n                                (subseq nums (min\
    \ (length nums) (floor sum))\n                                (length (subseq\
    \ nums (min (length nums) (floor sum))) 1)))))\n                 ((order (append\
    \ (subseq nums (min (length nums) (floor sum))) '())\n                       \
    \    (nums (append (subseq nums (min (length nums) (floor sum))) '())\n      \
    \                     sum)))\n        (append (append (list (reverse (append (reverse\
    \ order))))\n                  (list (reverse (append (reverse (append (reverse\
    \ order)))))\n                  (list (reverse (append (reverse (append (reverse\
    \ order))))))\n                (list (reverse (append (reverse (append (reverse\
    \ (append (reverse order))))))))\n        (order_by_points (append order nums)))))\n",
  "  (cond\n    [(empty? nums) '()]\n    [(< 0 (sum (map digit nums)) 0)\n     (cons\
    \ 0 (order_by_points (map digit nums)))]\n    [else (cons (car nums) (order_by_points\
    \ (map rest nums)))]))\n", "  (sort nums \n        (lambda (a b)\n          (=\
    \ (sum (number->list a)) (sum (number->list b))))))\n", "  (if (empty? nums) nums\n\
    \      (cons (first nums) (order_by_points (rest nums)))))\n", "  (if (null? nums)\n\
    \      '()\n      (let ((sum (sum_of_digits nums)))\n        (if (< (abs sum)\
    \ 10000) ; For numbers with > 10 digits, just sort them by their digit.\n    \
    \        (if (> (count_digits (quotient sum 10)) 1) ; For numbers with > 1 digit,\
    \ sort them by their digit.\n                (cons (quotient sum 10)\n       \
    \               (order_by_points (rest nums))))))))\n", "  (cond\n    [(empty?\
    \ nums) nums]\n    [(null? (rest nums)) nums]\n    [else (append (reduce add_digits\
    \ nums)\n                   (order_by_points (rest nums))))]\n))\n", "  (cond\n\
    \    [(empty? nums) empty]\n    [(cons? nums) \n     (sort \n      (lambda (x)\
    \ (sum_digits x)) \n      (order_by_points \n       (remove (lambda (x) (sum_digits\
    \ x)) nums))\n      )]))\n", "  (define (get-sum n)\n    (if (zero? n)\n     \
    \   0\n        (+ (remainder (modulo n 10) (* 10 10)) (get-sum (quotient n 10)))))\n\
    \  (let ([sum (apply + nums)])\n    (if (empty? nums)\n        nums\n        (let\
    \ ([sum2 (apply + nums)])\n          (cond (< (get-sum sum) (get-sum sum2)) nums\
    \ (sort-helper\n                                                        (append\
    \ nums (list sum2))\n                                                        (apply\
    \ + nums)))))))\n</code>\n<|/ a |>\n<| c |>\nYour code is incorrect for the question\
    \ requirements. In the first example, `order_by_points([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11]`, but your code gives me `[-1, 11]`.  And I believe\
    \ your solution fails if there's more than one possible solution.\n<|/ c |>\n\
    <| c |>\nYes, I did see the requirement to return the original order as well,\
    \ thanks for pointing that out. Updated my answer to return the original order\
    \ as well as an order which does not contain duplicates.\n<|/ c |>\n<| c |>\n\
    I've also added an extra answer, which does everything in one pass through the\
    \ list. It uses `(apply insert-sorted)` from the [`ordered-set`](http://docs.racket-lang.org/ordered-set/index.html)\
    \ library, but you can also implement your own `insert-sorted` function using\
    \ [`find-index`](http://docs.racket-lang.org/reference/pairs.html?q=find-index#%28def._%28%28lib._racket%2Flist..rkt%29._find-index%29%29).\n\
    <|/ c |>\n<| a tags=algorithm,scheme |>\nHere's another way to do it, using insert-sorted\
    \ from the ordered-set library:\n<code>", "  (sort nums\n        (lambda (a b)\
    \ (< (+ a (sum b)) (+ b (sum a 1))))\n        #'<))\n", "  (let ((digits '()))\n\
    \    (let loop ((lst nums))\n      (if (null? lst)\n          lst\n          (let\
    \ ((cur-sum (sum (first lst))))\n            (if (empty? digits)\n           \
    \     (cons (first lst) (loop (rest lst)))\n                (let ((sum (+ sum\
    \ (first digits))))\n                  (if (= sum cur-sum)\n                 \
    \     (cons (first lst) (loop (rest lst)))\n                      (let ((sum-diff\
    \ (- cur-sum sum)))\n                        (if (= sum-diff 0)\n            \
    \                (loop (rest lst))\n                            (let ((first-diff\
    \ (- sum (- sum-diff 1)))\n                                  (lst (subseq lst\
    \ 0 (min (length (first lst)) (length digits)))))\n                          \
    \    (cons (first lst) (loop (rest lst)))))))))))\n    (order_by_points_helper\
    \ digits 0)))\n", "  (sort nums \n        ; Sort by sum of digits\n        ; ((lambda\
    \ (a b) (sum (digits a)) sum (digits b)) 'a 'b) \n        (lambda (a b) (sum (digits\
    \ a)) (- sum (digits b))) \n        ; Natural order\n        '(eq)))", "  (cond\n\
    \    [(empty? nums) empty]\n    [(> ?(first nums) ?(first nums)) empty]\n    [else\
    \ (cons ?(first nums) (order_by_points rest nums))]))\n", "  (if (empty? nums)\n\
    \      nums\n      (append (sort_by_digits nums +) (order_by_points (subseq (rest\
    \ nums) 0 nums)))))\n", "  (define (count-sums nums)\n    (let loop ((nums nums)\n\
    \              (acc '()))\n      (cond\n        ((null? nums) (reverse acc))\n\
    \        (else (loop (cdr nums)\n                   (cons (+ (car nums) (car acc))\
    \ acc))))))\n  (count-sums nums))\n", "  (define (helper n)\n    (cond\n     \
    \ [(null? n) n]\n      [(= (mod (sum (map digits (rest n)))) 0)\n       (cons\
    \ n (helper (rest n)))]\n      [(> n (first n)) (helper (rest n))]\n      [else\
    \ (cons (first n) (helper (rest n)))]))\n  (helper nums))\n", "  (if (null? nums)\n\
    \      (list)\n      (let ([sum (sum (map digits (map reverse nums))) \n     \
    \        (nums (map reverse nums))])\n        (if (= sum 0)\n            (if (null?\
    \ (member 1 nums))\n                (cons (first nums) (order_by_points (rest\
    \ nums)))\n                (cons (first nums) (order_by_points (rest nums) \n\
    \                                                (cons (first nums) \n       \
    \                                             (rest nums))))))\n        (order_by_points\
    \ (rest nums)))))\n", "  (if (null? nums) nums\n      (let ((sum (reduce (lambda\
    \ (x y) (+ x (mod y 10)))\n                           (map (lambda (x) (mod x\
    \ 10)) nums))))\n        (if (null? sum) nums\n            (if (< sum 0) (cons\
    \ sum (reverse nums))\n                (cons (car nums) (order_by_points (cdr\
    \ nums))))))))\n", "  (if (empty? nums)\n      '()\n      (let ((sum (+ 0 (first\
    \ nums))))\n        (if (list? (rest nums))\n            (let ((result (map (lambda\
    \ (x) (+ x (first nums))) nums)))\n              (if (equal? result 0)\n     \
    \             '()\n                  (cons result (order_by_points (rest nums))))))\n\
    \        (if (equal? sum 0)\n            (cons (first nums) (order_by_points (rest\
    \ nums))))\n        (cons (first nums) (order_by_points (rest nums)))))))\n",
  "  (if (null? nums)\n      (list)\n      (let* ((item (car nums))\n            \
    \ (sum (+ item (digit_sum item)))\n             (index (length nums))\n      \
    \       (sums (list (cons sum index))))\n        (cons (car nums)\n          \
    \    (order_by_points (cdr nums)))))))\n", "  (sort nums (fn [x y]\n         \
    \     (let ([x (string->number (string-ref x 2))\n                    y (string->number\
    \ (string-ref y 2))])\n                (cond\n                  [(< x y) (+ y\
    \ x)] [(< y x) (+ x y)]\n                  [else (+ x y)])))\n        )\n    \
    \    )\n", "  (cond\n    [(empty? nums) '()]\n    [(= (length (cdr nums)) 1) (car\
    \ nums)]\n    [else (cons (car nums)\n                (order_by_points (map (lambda\
    \ (x) (+ x #%)) (cdr nums))))]))\n", "  (cond\n    [(empty? nums) nums]\n    [(>\
    \ (sum nums) 0) nums\n     (sort\n      (cond [(number? (car nums)) (order_by_points\
    \ (cdr nums))]\n            [(> (cdr nums) 0) (cons (car nums)\n             \
    \                   (order_by_points (cdr nums)))]\n            [else (cons (car\
    \ nums)\n                       (order_by_points (cdr nums)))]))]))\n", "  (if\
    \ (null? nums)\n      nums\n      (append (order-sum-by-digits-in-numbers nums)\
    \ (order_by_points (rest nums)))))\n", "  (cond ((null? nums) nums)\n        ((zero?\
    \ (first nums))\n         (first nums))\n        (else\n         (cons (first\
    \ nums)\n               (order_by_points (rest nums)))))))\n", "  (if (empty?\
    \ nums)\n      '()\n      (cons (max 0 (+ (first nums) (order_by_points (rest\
    \ nums))))\n            (order_by_points (rest nums)))))\n", "  (let loop ((tail\
    \ nums) (sums '()))\n    (if (null? tail)\n        (reverse sums)\n        (loop\
    \ (rest tail) (cons (+ (car tail) (car sums)) (cons (cadr tail) sums))))))\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work for `'(1 2 3 4 5 6 7 8)`\n<|/ c |>\n<| c\
    \ |>\nIt works fine on that input, it returns `(2 1 3 4 5 6 8 7)`. How is it failing?\n\
    <|/ c |>\n<| c |>\n`'(1 2 3 4 5 6 7 8)` returns `(2 1 3 4 5 6 8 7)`\n<|/ c |>\n\
    <| c |>\nI believe that's because you're sorting by position.  If you switch position\
    \ with sum of digits it works fine.  `(order_by_points '(1 2 3 4 5 6 7 8))` returns\
    \ `(2 1 3 4 5 6 7 8)`\n<|/ c |>\n<| c |>\nOh, I see, didn't realize that's what\
    \ you wanted. Thanks!\n<|/ c |>\n<| a tags=racket,scheme dscore=1 |>\nHere's how\
    \ I solved the problem (which was inspired by this post):\n<code>", "  (if (empty?\
    \ nums)\n      '()\n      (cons (if (> (+ (car nums) (most-negative-digit nums))\n\
    \                    (most-negative-digit (cadr nums)))\n                (car\
    \ nums)\n                (cadr nums))\n            (order_by_points (cdr nums)))))\n",
  "  (let loop ([lst (reverse nums)] [acc 0])\n    (if (null? lst)\n        acc\n\
    \        (loop (cdr lst) (+ (car lst) (* acc 10))))))\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 |>\nHere is a solution using only functional programming (no\
    \ mutation). As this uses functional programming it can be easily understood as\
    \ a 'pure function':\n<code>", "  (let ([points (map (fn [num] (floor (* num 10))\
    \ nums)) \n             \n             (index (foldr (lambda (point n acc) \n\
    \                             (if (zero? n) \n                             acc\
    \ (cons (car acc) \n                                      (cons (+ point (cdr\
    \ acc)) (cdr acc)))) \n                             #f (car nums))))])\n    (map\
    \ (fn [num] \n          (if (member (% num 10) points)\n          (cond \n   \
    \         ((zero? index)\n             (cons num nums))\n            (else\n \
    \            (cons (car nums) nums))))\n         nums)))\n#lang racket\n", " \
    \ (define (helper i j list)\n    (if (null? list)\n        '()\n        (if (equal?\
    \ (digit-sum list) (digit-sum nums))\n            (conj list (car list))\n   \
    \         (helper (cdr i) (add1 j) (cdr list)))))\n  (helper 0 nums nums))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat happens if two numbers have the same sum?\n<|/\
    \ c |>\n<| c |>\nI've edited my answer, thanks. I added an `if` statement to prevent\
    \ duplicate sums.\n<|/ c |>\n<| a |>\nI have solved the problem using hash table\
    \ and sorting by hash table key. \n<code>", "  (let ([digits (map digits nums)])\n\
    \    (if (null? nums)\n        '()\n        (let ([sum (+ 0 (apply + digits))])\n\
    \          (cons (if (< sum 0) (first nums) (second nums))\n                (order_by_points\
    \ (rest (filter (fn [[i j]] (< sum 0) (+ i j)))))))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a dscore=1 |>\n<code>", "  (if (empty? nums) '()\n      (append\n   \
    \    (for ((n nums) (i 0) (sum 0))\n         `(,(+ (first n) (* i 10)))\n    \
    \     sum)\n       #:result\n       (for ((n nums) (i 0) (sum 0))\n         (cond\n\
    \           ((empty? n) '())\n           ((and (< sum 10) (remainder sum (remainder\
    \ sum 10)))\n            (append (list (cons sum (first n))) sum)\n          \
    \  (order_by_points (rest n)))\n           (else (append (list (cons sum (first\
    \ n))) (order_by_points (rest n)))\n         )\n       )\n       )\n      ))\n",
  "  (if (null? nums) nums\n      (if (= (+ 0 (first nums)) (first nums))\n      \
    \    (if (> (sum nums) (sum nums))\n              (cons (first nums) (order_by_points\
    \ (rest nums)))\n              (order_by_points (rest nums)))))\n  nums)\n", " \
    \ (let ([sums (apply + (map #(modulo 10 %) (map digit-to-int nums))))]\n    (cond\n\
    \      [(empty? nums) '()]\n      [(= (count (find-max (lambda (el) (>= sum el))\
    \ sums) nums) (sort sums #'<))]\n      [else (sort (cons (max sums) nums) #'<)])))\n",
  "  (if (empty? nums)\n      '()\n      (append (sort (map sum (number->string nums)))\
    \ \n               (list (car nums)))))\n", "  (let ([sum 0])\n    (for/sum ([idx\
    \ nums])\n      (set! sum (+ sum (expt (% idx 10) 10) ) )\n    )\n    (for/sum\
    \ ([idx nums])\n      (set! sum (- sum (expt (% idx 10) 10) ) )\n    )\n    (for/sum\
    \ ([idx nums])\n      (set! sum (+ sum idx) ) )\n    (reverse (sort (lambda (x\
    \ y) (= (+ x y) sum)) nums ))\n))\n", "  (cond\n    [(empty? nums) empty]\n  \
    \  [(zero? (first nums)) empty]\n    [else (append (order_by_points (rest nums))\
    \ (list (first nums)))]\n  )\n)\n", "  (cond\n    [(empty? nums) nums]\n    [else\
    \ (cons\n            (let ([num (first nums)])\n               (cond\n       \
    \          [(zero? num) (order_by_points (rest nums))]\n                 [(add\
    \ (mod num 10)) (cons (first nums)\n                                         (order_by_points\
    \ (rest nums)))]\n                 [else (cons (first nums)\n                \
    \             (order_by_points (rest nums)))]))]))))\n", "  (sort (\u03BB (a b)\
    \ (+ a (sum_digits b)))\n        nums\n        :key 'car\n        :reverse #t\n\
    \        :key 'cdr))\n", "  (cond\n    [(empty? nums) (list nums)]\n    [(digit-sum\
    \ (first nums)) \n     (append (order_by_points (rest nums)) \n             (list\
    \ (first nums) (digit-sum (first nums))))]\n    [else\n     (append (order_by_points\
    \ (rest nums)) \n             (list (first nums) (digit-sum (first nums))))]\n\
    \   )\n )\n", "  (if (null? nums)\n      '()\n      (let ([sum (sum (map (lambda\
    \ (x) (modulo x 10)) nums))])\n        (if (> (car sum) 0)\n            (cons\
    \ (car nums) (order_by_points (filter (lambda (x) (not (modulo x 10)) nums))))\n\
    \            (cons (car nums) (order_by_points (filter (lambda (x) (not (modulo\
    \ x 10)) nums))))\n            (cons (car nums) (order_by_points (filter (lambda\
    \ (x) (not (modulo x 10)) nums))))\n            (order_by_points (filter (lambda\
    \ (x) (not (modulo x 10)) nums))))))))\n", "  (define (sum_of_digits num)\n  \
    \  (if (< 0 num)\n        0\n        (+ (modulo num 10) (* (remainder num 10)\
    \ 10))\n      )\n  )\n\n  (define (sum_of_digits_helper nums sum)\n    (if (null?\
    \ nums)\n        sum\n        (sum_of_digits_helper (cdr nums) (+ (modulo sum\
    \ 10) (sum_of_digits (car nums))))\n      )\n  )\n\n  (sum_of_digits_helper nums\
    \ 0)\n)\n", "  (cond\n    [(empty? nums) nums]\n    [else (append (list first\
    \ (first nums))\n                  (order_by_points (rest nums)))]))\n", "  (cond\n\
    \    [(empty? nums) '()]\n    [(not (positive? (first nums))) nums]\n    [else\
    \ (append (order_by_points ((first nums) (sub (first nums) (first nums)))) (sub\
    \ (first nums) (first nums))))]))\n", "  (define (sum lst)\n    (cond ((null?\
    \ lst) 0)\n          ((zero? (car lst)) (car lst))\n          (else (+ (sum (cdr\
    \ lst)) (sum (cdr lst))))))\n  (define (compare-sum s1 s2)\n    (cond ((> s1 s2)\
    \ (compare-sum s1 (- s2 s1)))\n          ((= s1 s2) (if (= 0 (sum s1)) s2 s1))\n\
    \          (else (if (= 0 (sum s2)) s1 s2))))\n  (map compare-sum nums (sort nums\
    \ reverse))\n  )\n", "  (define (sum-to-digits nums)\n    (if (empty? nums)\n\
    \        0\n        (+ (first nums) (sum-to-digits (rest nums)))))\n  (define\
    \ (sort-sums-first nums)\n    (cond ((< (sum-to-digits nums) (sum-to-digits (rest\
    \ nums)))\n          (cons (first nums) (sort-sums-first (rest nums))))\n    \
    \      ((= (sum-to-digits nums) (sum-to-digits (rest nums)))\n          (cons\
    \ (first nums) (sort-sums-first (rest nums))))\n          (else (cons (first nums)\
    \ nums))))\n  (sort-sums-first nums))\n</code>\n<|/ a dscore=1 tags=functional-programming,scheme,lisp,racket\
    \ |>\n<| c |>\nThank you for the answer. Could you please write it on english\
    \ language ? I hope I can understand it better than I can.\n<|/ c |>\n<| c |>\n\
    Sorry,.  Please see my recent edit.  I hope that helps clarify some points.\n\
    <|/ c |>\n<| c |>\nThank you for your answer. Can you please explain more about\
    \ what this code is doing?\n<|/ c |>\n<| c |>\nSure.  Please see the edit.\n<|/\
    \ c |>\n<| c |>\nThank you for your answer. Could you please explain more about\
    \ what this code is doing? I'm new to functional programming.\n<|/ c |>\n<| a\
    \ tags=functional-programming,scheme,lisp,racket |>\nHere is the code in Racket:\n\
    <code>\n#lang racket\n", "  (cond\n    [(empty? nums) empty]\n    [(= (first nums)\
    \ 0) (order_by_points (rest nums))]\n    [else (cond\n            ;; Sum their\
    \ digits\n            ;; (= (sum n) 0) = equal\n            ;; (not (= (sum n)\
    \ 0)) = negative\n            ;; (> n 0) = positive\n            ;; (< n 0) =\
    \ negative\n            [(= (sum nums) 0) (order_by_points (rest nums))]\n   \
    \         [(= (sum nums) 9) (order_by_points (rest nums))]\n            [else\
    \ (cond\n                    [(= (sum nums) 10) (cons (first nums) (order_by_points\
    \ (rest nums)))]\n                    [else (cons (first nums) (order_by_points\
    \ (rest nums))) ]\n                    )]))]))\n", "  (let ((sum (apply + nums)))\n\
    \    (map list nums (filter #(<= sum %) nums))))\n", "  (if (null? nums)\n   \
    \   (list nil)\n      (let ([sum (sum-of-digits nums)\n            key (sub1 (quotient\
    \ sum 10))\n            acc (cons nums nil)])\n        (if (< sum 0)\n       \
    \     (cons (first acc) acc)\n            (cons (first acc)\n                \
    \  (append (sub1 (quotient sum 10)) (order_by_points\n                       \
    \                             (cons (rest acc) nil))))))))\n", "  (if (empty?\
    \ nums) nums\n      (append (sort (num->string nums))\n               (list (car\
    \ nums)))))\n", "  (if (null? nums)\n      '()\n      (let loop ((carry '()) (nums\
    \ (cdr nums)) (sum '()))\n        (cond ((null? nums)\n               carry)\n\
    \              ((eq? (first nums) (first sum))\n               (loop (cons (first\
    \ nums) carry) (tail nums) (cons (first sum) sum)))\n              (else (loop\
    \ (cons (first sum) carry) (tail nums) (cons (first nums) sum)))))))\n</code>\n\
    <|/ a tags=racket,scheme dscore=2 |>\n<| a |>\n<code>", "  (define (sort nums\
    \ sum)\n    (cond\n      [(null? nums) (reverse nums)]\n      [(< sum sum (first\
    \ nums)) (cons first nums)]\n      [(< (second sum) (sum (second nums)) (first\
    \ nums)) (sort (cons (first nums) (second nums)) sum)]\n      [else (cons (first\
    \ nums) (sort (second nums) (sum (second nums)))] (sort (rest nums) sum)]))\n\
    \  (sort nums 0 (first nums)))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou might\
    \ use #lang racket for this. In Racket you can use the sort procedure with custom\
    \ comparator. Here's how you can do it with #lang racket:\n<code>\n#lang racket\n",
  "  (define (sort-by-r-digit nums)\n    (define (aux xs)\n      (sort xs (lambda\
    \ (a b) \n\t\t    (+ \n\t\t     (if (< a b)\n\t\t       (- a b)\n\t\t       (if\
    \ (zero? (+ a (- b a)))\n\t\t\t(- a (- b a))\n\t\t\t(- a b)\n\t\t       )\n\t\t\
    \     )\n\t\t     (length (string->list (number->string a)) )\n\t\t     (length\
    \ (string->list (number->string b)) )\n\t\t    )\n\t    ) \n\t    ) \n    (cond\
    \ [(empty? nums) nums]\n\t  [(= (length nums) 1)\n\t   (cons (car nums) nums)]\n\
    \t  [(< (length nums) 2)\n\t   (aux nums)]\n\t  [else (aux nums)]\n\t  )\n\t \
    \ )\n  (sort-by-r-digit nums)\n  )\n", "  (define (compare x y)\n    (+ (* x 10)\
    \ (* y 10)))\n\n  (if (null? nums) '())\n  (let ((head (car nums)))\n    (append\
    \ (list (car nums)) (sort\n                           (cdr nums)\n           \
    \                #'(< compare compare)))\n    (order_by_points (cdr nums))))\n\
    </cell>\n<cell>\n#lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
