name: HumanEval_51_remove_vowels
language: rkt
prompt: "#lang racket\n\n;; remove_vowels is a function that takes string and returns\
  \ string without vowels.\n;; >>> remove_vowels('')\n;; ''\n;; >>> remove_vowels('abcdef')\n\
  ;; 'bcdf'\n;; >>> remove_vowels('aaaaa')\n;; ''\n;; >>> remove_vowels('aaBAA')\n\
  ;; 'B'\n;; >>> remove_vowels('zbcd')\n;; 'zbcd'\n(define (remove_vowels text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"abcdef\n\
  ghijklm\") \"bcdf\nghjklm\")\n    (check-equal? (candidate \"fedcba\") \"fdcb\"\
  )\n    (check-equal? (candidate \"eeeee\") \"\")\n    (check-equal? (candidate \"\
  acBAA\") \"cB\")\n    (check-equal? (candidate \"EcBOO\") \"cB\")\n    (check-equal?\
  \ (candidate \"ybcd\") \"ybcd\")\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? text) '']\n        [(equal? text 'a) (substring text\
    \ 0 -1)]\n        [(equal? text 'e) (substring text 0 -1)]\n        [(equal? text\
    \ 'i) (substring text 0 -1)]\n        [(equal? text 'o) (substring text 0 -1)]\n\
    \        [(equal? text 'u') (substring text 0 -1)]\n        [else (substring text\
    \ 0 -1)]))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) 'a)\
    \ (cons (first text)\n                                 (cdr (remove_vowels (rest\
    \ text))))]\n    [(equal? (first text) 'e) (cons (first text)\n              \
    \                   (cdr (remove_vowels (rest text))))]\n    [(equal? (first text)\
    \ 'i) (cons (first text)\n                                 (cdr (remove_vowels\
    \ (rest text))))]\n    [(equal? (first text) 'o) (cons (first text)\n        \
    \                         (cdr (remove_vowels (rest text))))]\n    [(equal? (first\
    \ text) 'u) (cons (first text)\n                                 (cdr (remove_vowels\
    \ (rest text))))]\n    [else (cons (first text)\n                (remove_vowels\
    \ (rest text))) ]))\n", "  (cond [(empty? text) empty]\n        [(equal? #\\a\
    \ (first text)) (remove_vowels (rest text))]\n        [(equal? #\\e (first text))\
    \ (remove_vowels (rest text))]\n        [(equal? #\\i (first text)) (remove_vowels\
    \ (rest text))]\n        [(equal? #\\o (first text)) (remove_vowels (rest text))]\n\
    \        [(equal? #\\u (first text)) (remove_vowels (rest text))]\n        [else\
    \ (cons first text)]))\n", "  (cond\n    [(empty? text)\n     '']\n    [(equal?\
    \ (first text) 'a')\n     (append (remove_vowels (rest text)) (drop 1 (first text)))]\n\
    \    [(equal? (first text) 'e')\n     (append (remove_vowels (rest text)) (drop\
    \ 1 (first text)))]\n    [(equal? (first text) 'i')\n     (append (remove_vowels\
    \ (rest text)) (drop 1 (first text)))]\n    [(equal? (first text) 'o')\n     (append\
    \ (remove_vowels (rest text)) (drop 1 (first text)))]\n    [(equal? (first text)\
    \ 'u')\n     (append (remove_vowels (rest text)) (drop 1 (first text)))]\n   \
    \ [(equal? (first text) 'A')\n     (append (remove_vowels (rest text)) (drop 1\
    \ (first text)))]\n    [(equal? (first text) 'E')\n     (append (remove_vowels\
    \ (rest text)) (drop 1 (first text)))]\n    [(equal? (first text) 'I')\n     (append\
    \ (remove_vowels (rest text)) (drop 1 (first text)))]\n    [(equal? (first text)\
    \ 'O')\n     (append (remove_vowels (rest text)) (drop 1 (first text)))]\n   \
    \ [(equal? (first text) 'U')\n     (append (remove_vowels (rest text)) (drop 1\
    \ (first text)))]\n    [else\n     (append (first text) (remove_vowels (rest text)))\
    \ ]\n   )\n)\n", "  (cond\n    [(empty? text) empty]\n    [(member #\\a text)\n\
    \     (cond\n       [(empty? (rest text)) (reverse (rest text))]]\n    [(member\
    \ #\\e text)\n     (cond\n       [(empty? (rest text)) (reverse (rest text))]]\n\
    \    [(member #\\i text)\n     (cond\n       [(empty? (rest text)) (reverse (rest\
    \ text))]]\n    [(member #\\o text)\n     (cond\n       [(empty? (rest text))\
    \ (reverse (rest text))]]\n    [(member #\\u text)\n     (cond\n       [(empty?\
    \ (rest text)) (reverse (rest text))]]\n    [else (cons (first text) (remove_vowels\
    \ (rest text)))]))\n", "  (let ([\n        (vowels '(a e i o u)\n          #:rest\
    \ (list text)]\n        #:len (length text)]\n        [result '()])\n    (if (<\
    \ len 0)\n        (reverse result)\n        (let ((index (if (null? rest) 0 (car\
    \ rest)))\n               (rest (cdr rest)))\n          (if (null? vowels)\n \
    \             (if (string= index 0)\n                  (cons (car text) result)\n\
    \                  (cons (car vowels) result)\n                  (cons (car text)\
    \ (cons index result)))\n              (let ([\n                     (vowels (cons\
    \ (car text) (cons index result)))\n                     (index (- index (length\
    \ vowels)))\n                     (rest (cdr rest))])\n                (remove_vowels\
    \ rest)\n                (remove_vowels vowels)\n                (remove_vowels\
    \ text)))))\n", "  (cond\n    [(empty? text)\n     text]\n    [(equal? (first\
    \ text) 'a)\n     (rest text)\n     (remove_vowels (rest text))\n     ]\n    [(equal?\
    \ (first text) 'e)\n     (rest text)\n     (remove_vowels (rest text))\n     ]\n\
    \    [(equal? (first text) 'i)\n     (rest text)\n     (remove_vowels (rest text))\n\
    \     ]\n    [(equal? (first text) 'o)\n     (rest text)\n     (remove_vowels\
    \ (rest text))\n     ]\n    [(equal? (first text) 'u)\n     (rest text)\n    \
    \ (remove_vowels (rest text))\n     ]\n    [else\n     (cons (first text) (remove_vowels\
    \ (rest text)))]\n    ))\n", "  (cond [(empty? text)\n         empty]\n      \
    \  [(cons? text)\n         (remove_vowels (first text))\n         (remove_vowels\
    \ (rest text))]))\n", "  (cond\n    [(empty? text)\n     '']\n    [(not (list?\
    \ text))\n     text]\n    [(equal? (first text) 'a')\n     (filter (lambda (x)\
    \ (equal? (first x) 'a') (drop 1 text)))]\n    [(equal? (first text) 'e')\n  \
    \   (filter (lambda (x) (equal? (first x) 'e') (drop 1 text)))]\n    [(equal?\
    \ (first text) 'i')\n     (filter (lambda (x) (equal? (first x) 'i') (drop 1 text)))]\n\
    \    [(equal? (first text) 'o')\n     (filter (lambda (x) (equal? (first x) 'o')\
    \ (drop 1 text)))]\n    [(equal? (first text) 'u')\n     (filter (lambda (x) (equal?\
    \ (first x) 'u') (drop 1 text)))]\n    [else\n     (cons (first text)\n      \
    \     (remove_vowels (drop 1 text)))]))\n", "  (cond\n    [(empty? text) text]\n\
    \    [(equal? (char text 0) #\\a) (substring text 1)]\n    [(equal? (char text\
    \ 0) #\\e) (substring text 2)]\n    [(equal? (char text 0) #\\i) (substring text\
    \ 3)]\n    [(equal? (char text 0) #\\o) (substring text 4)]\n    [(equal? (char\
    \ text 0) #\\u) (substring text 5)]\n    [else (substring text 0 1)]))\n", " \
    \ (cond\n    [(empty? text)  '']\n    [(member #\\A text)  '']\n    [else    \
    \          (cons (car text) (remove_vowels (cdr text)))]))\n", "  (cond\n    [(empty?\
    \ text) text]\n    [(equal? (first (rest text)) #\\a #\\e #\\i #\\o #\\u)\n  \
    \   (remove_vowels (rest text))\n    ]\n    [(equal? (first (rest text)) #\\y\
    \ #\\o #\\u #\\a #\\i)\n     (cons (first text) (remove_vowels (rest text)))\n\
    \    ]\n    [else (cons (first text) (remove_vowels (rest text)))]\n   )\n  )\n",
  "  (cond\n    [(empty? text) text]\n    [(not (member (first text) 'aeiou')) (cons\
    \ (first text) (remove_vowels (rest text)))]\n    [else (cons (first text) (remove_vowels\
    \ (rest text))) ]\n    )\n  )\n", "  (if (empty? text)\n      '\n      (cond ((or\n\
    \                (char=? (first text) #\\a)\n                (char=? (first text)\
    \ #\\e)\n                (char=? (first text) #\\i)))\n            (rest (remove_vowels\
    \ (rest text)))))\n</code>\n<code>\n#lang racket\n", "  (cond [(empty? text) \"\
    \"]\n        [else (cons (first text)\n                    (remove_vowels (rest\
    \ text)))]))\n</code>\n<|/ a |>\n<| a tags=scheme |>\nThis problem is actually\
    \ not that difficult. Instead of removing vowels from the text, we can only consider\
    \ the character at that position to be a vowel.\n<code>", "  (cond ((or (string=?\
    \ text \"\") (string=? text \"abc\")) \"\")\n        ((string=? text \"a\") text)\n\
    \        ((string=? text \"e\") text)\n        ((string=? text \"i\") text)\n\
    \        ((string=? text \"o\") text)\n        ((string=? text \"u\") text)\n\
    \        (else text)))\n", "  (cond [(empty? text)\n         \"\"]\n        [(=\
    \ (first text) #\\a)\n         (rest text)]\n        [(= (first text) #\\e)\n\
    \         (rest text)]\n        [(= (first text) #\\i)\n         (rest text)]\n\
    \        [(= (first text) #\\o)\n         (rest text)]\n        [(= (first text)\
    \ #\\u)\n         (rest text)]\n        [else\n         (cons text (remove_vowels\
    \ (rest text)))]))\n", "  (cond (#t (if (member #\\a text)\n                (if\
    \ (member #\\A text)\n                    (if (member #\\e text)\n           \
    \             (if (member #\\i text)\n                            (if (member\
    \ #\\o text)\n                                (if (member #\\u text)\n       \
    \                             (if (member #\\y text)\n                       \
    \                 (if (member #\\H text)\n                                   \
    \         (if (member #\\l text)\n                                           \
    \     (if (member #\\O text)\n                                               \
    \     (if (member #\\R text)\n                                               \
    \         (if (member #\\s text)\n                                           \
    \                 text\n                                                     \
    \       (if (member #\\Z text)\n                                             \
    \                   text))))))))\n                       (if (member #\\A text)\n\
    \                            (if (member #\\e text)\n                        \
    \        (if (member #\\i text)\n                                    (if (member\
    \ #\\o text)\n                                        (if (member #\\u text)\n\
    \                                            (if (member #\\y text)\n        \
    \                                        (if (member #\\H text)\n            \
    \                                        (if (member #\\l text)\n            \
    \                                            (if (member #\\O text)\n        \
    \                                                    (if (member #\\R text)\n\
    \                                                                (if (member #\\\
    s text)\n                                                                    (if\
    \ (member #\\Z text)\n                                                       \
    \                 text)))))))))))))\n                  (if (member #\\A text)\n\
    \                      (if (member #\\e text)\n                          (if (member\
    \ #\\i text)\n                              (if (member #\\o text)\n         \
    \                         (if (member #\\u text)\n                           \
    \           (if (member #\\y text)\n                                         \
    \ (if (member #\\H text)\n                                              (if (member\
    \ #\\l text)\n                                                  (if (member #\\\
    O text)\n                                                      (if (member #\\\
    R text)\n                                                          (if (member\
    \ #\\s text)\n                                                              text\n\
    \                                                              (if (member #\\\
    Z text)\n                                                                text))))))))))))\n\
    \                  text)))\n</code>\nFor example the above can be written more\
    \ concisely as follows:\n<code>", "  (cond\n    [(empty? text)\n     \"\"]\n \
    \   [(equal? (car text) 'a')\n     (cons (cdr text) (remove_vowels (cdr text)))]\n\
    \    [(equal? (car text) 'e')\n     (cons (cdr text) (remove_vowels (cdr text)))]\n\
    \    [(equal? (car text) 'i')\n     (cons (cdr text) (remove_vowels (cdr text)))]\n\
    \    [(equal? (car text) 'o')\n     (cons (cdr text) (remove_vowels (cdr text)))]\n\
    \    [(equal? (car text) 'u')\n     (cons (cdr text) (remove_vowels (cdr text)))]\n\
    \    [else (cons (car text) (remove_vowels (cdr text)))]))\n", "  (define vows\
    \ '(' 'a' 'e' 'i' 'o' 'u' 'A' 'E' 'I' 'O' 'U'))\n  (map (lambda (x)\n        \
    \ (let ([found (member (char->string x) vows)])\n           (when (not found)\n\
    \             (printf \"~a\" x)))))\n  (printf \"~a\" text))\n", "  (cond\n  \
    \  [(empty? text) text]\n    [(eq? (first text) 'a) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'e) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'i) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'o) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'u) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'A) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'E) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'I) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'O) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'U) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'y) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'Y) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'a) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'b) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'c) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'd) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'f) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'g) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'h) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'j) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'k) (cons (second text) (remove_vowels\
    \ (rest text)))]\n    [(eq? (first text) 'l) (cons (second text) (remove_vowel",
  "  (cond\n    [(empty? text) text]\n    [else\n      (let\n        ([vowels (list?\
    \ 'abcde')]) ;; 'a' through 'e'\n        (if (empty? vowels)\n            text\n\
    \            (cons (if (member (first text) vowels) (first text) (rest text))\
    \ (remove_vowels (rest text))))]))))\n", "  (remove-if (lambda (character) (character\
    \ = 'a' || character = 'e' || character = 'i' || character = 'o' || character\
    \ = 'u')) text))\n", "  (cond [(empty? text)\n         (string->list '())]\n \
    \       [(cons? text)\n         (append (remove_vowels (car text)) (remove_vowels\
    \ (cdr text)))]\n        [else\n         (append (car text) (remove_vowels (cdr\
    \ text)))]))\n", "  (cond [(empty? text) \"\"]\n        [(member? (first text)\
    \ 'aeiou) \n         (first text)]\n        [else (remove_vowels (rest text))]))\n",
  "  (cond\n    ((empty? text)\n     \"\")\n    ((char-subset? (first text) 'a')\n\
    \     (substring (first text) (second text)))\n    ((char-subset? (first text)\
    \ 'e')\n     (substring (first text) (third text)))\n    ((char-subset? (first\
    \ text) 'i')\n     (substring (first text) (fourth text)))\n    ((char-subset?\
    \ (first text) 'o')\n     (substring (first text) (fifth text)))\n    ((char-subset?\
    \ (first text) 'u')\n     (substring (first text) (sixth text)))\n    ((char-subset?\
    \ (first text) 'A')\n     (substring (first text) (seventh text)))\n    ((char-subset?\
    \ (first text) 'E')\n     (substring (first text) (eighth text)))\n    ((char-subset?\
    \ (first text) 'I')\n     (substring (first text) (ninth text)))\n    ((char-subset?\
    \ (first text) 'O')\n     (substring (first text) (tenth text)))\n    ((char-subset?\
    \ (first text) 'U')\n     (substring (first text) (eleventh text)))\n    (else\n\
    \     (cons (first text) (remove_vowels (rest text))))))\n", "  (map (lambda (x)\n\
    \         (if (string=? x \"A\" #t #f x))\n         x))\n       (string->list\
    \ text)))\n", "  (cond\n    [(empty? text)\n      empty]\n    [(string-contains?\
    \ vowels \"A\" text) (string-delete text 0)]\n    [(string-contains? vowels \"\
    B\" text) (string-delete text 1)]\n    [(string-contains? vowels \"C\" text) (string-delete\
    \ text 2)]\n    [(string-contains? vowels \"D\" text) (string-delete text 3)]\n\
    \    [(string-contains? vowels \"E\" text) (string-delete text 4)]\n    [(string-contains?\
    \ vowels \"F\" text) (string-delete text 5)]\n    [(string-contains? vowels \"\
    G\" text) (string-delete text 6)]\n    [(string-contains? vowels \"H\" text) (string-delete\
    \ text 7)]\n    [(string-contains? vowels \"I\" text) (string-delete text 8)]\n\
    \    [(string-contains? vowels \"J\" text) (string-delete text 9)]\n    [(string-contains?\
    \ vowels \"K\" text) (string-delete text 10)]\n    [(string-contains? vowels \"\
    L\" text) (string-delete text 11)]\n    [(string-contains? vowels \"M\" text)\
    \ (string-delete text 12)]\n    [(string-contains? vowels \"N\" text) (string-delete\
    \ text 13)]\n    [(string-contains? vowels \"O\" text) (string-delete text 14)]\n\
    \    [(string-contains? vowels \"P\" text) (string-delete text 15)]\n    [(string-contains?\
    \ vowels \"Q\" text) (string-delete text 16)]\n    [(string-contains? vowels \"\
    R\" text) (string-delete text 17)]\n    [(string-contains? vowels \"S\" text)\
    \ (string-delete text 18)]\n    [(string-contains? vowels \"T\" text) (string-delete\
    \ text 19)]\n    [(string-contains? vowels \"U\" text) (string-delete text 20)]\n\
    \    [(string-contains? vowels \"V\" text) (string-delete text 21)]\n    [(string-contains?\
    \ vowels \"W\" text) (string-delete text 22)]\n    [(string-contains? vowels \"\
    X\" text) (string-delete text 23)]\n    [(string-contains? vowels \"Y\" text)\
    \ (string-delete text 24)]\n    [(string-contains? vowels \"Z\" text) (string-delete\
    \ text 25)]\n    [(string-contains? vowels \"a\" text) (string-delete text 26)]\n\
    \    [(string-contains? vowels \"b\" text) (string-delete text 27", "  (cond\n\
    \    [(empty? text) text]\n    [(cons? text) (cons (first text) (remove_vowels\
    \ (rest text)))]\n    [(symbol=? (first text) (first 'aeiou)) (first text)] \n\
    \    [else (cons (first text) (remove_vowels (rest text)))]))\n", "  (match text\n\
    \    [(empty)\n     empty]\n    [else\n     (for/fold ([acc ''])\n           \
    \   ([char (in-string text #\\a))\n              (in-string text #\\z)])\n   \
    \   (cons (cond\n              [(char= char (in-string text #\\a)) #\\a]\n   \
    \           [(char= char (in-string text #\\e)) #\\e]\n              [(char= char\
    \ (in-string text #\\i)) #\\i]\n              [(char= char (in-string text #\\\
    o)) #\\o]\n              [(char= char (in-string text #\\u)) #\\u])]\n      (remove_vowels\
    \ (substring text 0 (string->length text))))]))\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\n<code>", "  (cond\n    [(string-empty? text) \"\"]\n    [(equal? (char-at\
    \ (car text)) #\\/) \"\"]\n    [(equal? (char-at (car text)) #\\a) \"\"]\n   \
    \ [(equal? (char-at (car text)) #\\b) \"\"]\n    [(equal? (char-at (car text))\
    \ #\\c) \"\"]\n    [(equal? (char-at (car text)) #\\d) \"\"]\n    [(equal? (char-at\
    \ (car text)) #\\e) \"\"]\n    [(equal? (char-at (car text)) #\\F) \"\"]\n   \
    \ [(equal? (char-at (car text)) #\\n) \"\"]\n    [(equal? (char-at (car text))\
    \ #\\N) \"\"]\n    [(equal? (char-at (car text)) #\\O) \"\"]\n    [(equal? (char-at\
    \ (car text)) #\\p) \"\"]\n    [(equal? (char-at (car text)) #\\q) \"\"]\n   \
    \ [(equal? (char-at (car text)) #\\s) \"\"]\n    [(equal? (char-at (car text))\
    \ #\\t) \"\"]\n    [(equal? (char-at (car text)) #\\v) \"\"]\n    [(equal? (char-at\
    \ (car text)) #\\u) \"\"]\n    [(equal? (char-at (car text)) #\\W) \"\"]\n   \
    \ [(equal? (char-at (car text)) #\\w) \"\"]\n    [(equal? (char-at (car text))\
    \ #\\Z) \"\"]\n    [(equal? (char-at (car text)) #\\s) \"\"]\n    [(equal? (char-at\
    \ (car text)) #\\;) \"\"]\n    [(equal? (char-at (car text)) #\\) \"\"]\n    [(equal?\
    \ (char-at (car text)) #\\) \"\"]\n    [(equal? (char-at (car text)) #\\)) \"\"\
    ]\n    [(equal? (char-at (car text)) #\\.) \"\"]\n    [(equal? (char-at (car text))\
    \ #\\,) \"\"]\n    [(equal? (char-at (car text)) #\\:) \"\"]\n    [", "  (filter\
    \ (lambda (c) (and (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\\
    o)))\n          text))\n", "  (cond [(equal? text '') text]\n        [(member\
    \ (car text) 'aeiouAEIOU) (cadr text)]\n        [(member (car text) 'yY) (cadr\
    \ text)]\n        [else (cons (car text) (remove_vowels (cdr text)))))\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\nThe simplest way without recursion would be:\n<code>",
  "  (let ([vowels (list 'a b c d e f g h i j k l m n o p q r s t u v w x y z)])\n\
    \    (cond\n      [(empty? text) \"\"]\n      [(contains? text #\\a) (remove-if\
    \ (lambda (c)\n                                     (cond\n                  \
    \                    [(empty? vowels) true]\n                                \
    \      [else (member c vowels)]))\n                              text)]\n    \
    \  [(contains? text #\\b) (remove-if (lambda (c)\n                           \
    \          (cond\n                                      [(empty? vowels) true]\n\
    \                                      [else (member c vowels)]))\n          \
    \                    text)]\n      [(contains? text #\\c) (remove-if (lambda (c)\n\
    \                                     (cond\n                                \
    \      [(empty? vowels) true]\n                                      [else (member\
    \ c vowels)]))\n                              text)]\n      [(contains? text #\\\
    d) (remove-if (lambda (c)\n                                     (cond\n      \
    \                                [(empty? vowels) true]\n                    \
    \                  [else (member c vowels)]))\n                              text)]\n\
    \      [(contains? text #\\e) (remove-if (lambda (c)\n                       \
    \              (cond\n                                      [(empty? vowels) true]\n\
    \                                      [else (member c vowels)]))\n          \
    \                    text)]\n      [(contains? text #\\f) (remove-if (lambda (c)\n\
    \                                     (cond\n                                \
    \      [(empty? vowels) true]\n                                      [else (member\
    \ c vowels)]))\n                              text)]\n      [(contains? text #\\\
    g) (remove-if (lambda (c)\n                                     (cond\n      \
    \                                [(empty? vowels) true]\n                    \
    \                  [else (member c vowels)]))\n                              text)]\n\
    \      [(contains? text #\\h) (remove-if (lambda (c)\n                       \
    \              (cond\n                                      [(empty? vowels) true]\n\
    \                                      [else (member c vowels)]))\n          \
    \                    text)]\n      [(contains? text #\\i) (remove-if (lambda (c)\n\
    \                                     (cond\n                                \
    \      [(empty? vowels) true]\n                                      [else (member\
    \ c vowels)]))\n                              text)]\n      [(contains? text #\\\
    j) (remove-if (lambda (c)\n                                     (cond\n      \
    \                                [(empty? vowels) true]\n                    \
    \                  [else (member c vowels)]))\n                              text)]\n\
    \      [(contains? text #\\k) (remove-if (lambda (c)\n                       \
    \              (cond\n                                      [(empty? vowels) true]\n\
    \                                      [else (member c vowels)]))\n          \
    \                    text)]\n      [(contains? text #", "  (cond [(empty? text)\
    \ \"\"]\n        [(or (char-at (car text) 0) + -)\n         (cons (char-at (car\
    \ text) 0) (remove_vowels (cdr text)))]\n        [else (remove_vowels (cdr text))]))\n",
  "  (filter #(not\n            (string=? (string-ref text 0) #\\a\n             \
    \          #\\b\n                       #\\c\n                       #\\d\n  \
    \                     #\\e\n                       #\\f\n                    \
    \   #\\g\n                       #\\h\n                       #\\i\n         \
    \              #\\j\n                       #\\k\n                       #\\l\n\
    \                       #\\m\n                       #\\n\n                  \
    \     #\\o\n                       #\\p\n                       #\\q\n       \
    \                #\\r\n                       #\\s\n                       #\\\
    t\n                       #\\v\n                       #\\w\n                \
    \       #\\y\n                       #\\z\n                       #\\A\n     \
    \                  #\\B\n                       #\\C\n                       #\\\
    D\n                       #\\E\n                       #\\F\n                \
    \       #\\G\n                       #\\H\n                       #\\I\n     \
    \                  #\\J\n                       #\\K\n                       #\\\
    L\n                       #\\M\n                       #\\N\n                \
    \       #\\O\n                       #\\P\n                       #\\Q\n     \
    \                  #\\R\n                       #\\S\n                       #\\\
    T\n                       #\\V\n                       #\\W\n                \
    \       #\\Y\n                       #\\Z\n                       #\\aa\n    \
    \                   #\\ab\n                       #\\ac\n                    \
    \   #\\ad\n                       #\\ae\n                       #\\af\n      \
    \                 #\\ag\n                       #\\ah\n                      \
    \ #\\ai\n                       #\\aj\n                       #\\ak\n        \
    \               #\\al\n                       #\\am\n                       #\\\
    an\n                       #\\ao\n                       #\\ap\n             \
    \          #\\aq\n                       #\\ar\n                       #\\as\n\
    \                       #\\at\n                       #\\au\n                \
    \       #\\av\n                       #\\aw\n                       #\\ax\n  \
    \                     #\\ay\n                       #\\az\n                  \
    \     #\\bA\n                       #\\bB\n                       #\\bC\n    \
    \                   #\\bD\n                       #\\bE\n                    \
    \   #\\bF\n                       #\\bG\n                       #\\bH\n      \
    \                 #\\bI\n                       #\\bJ\n                      \
    \ #\\bK\n                       #\\bL\n                       #\\bM\n        \
    \               #\\bN\n                       #\\bO\n                       #\\\
    bP\n                       #\\bQ\n                       #\\bR\n             \
    \          #\\bS\n                       #\\bT\n                       #\\bU\n\
    \                       #\\bV\n                       #\\bW\n                \
    \       #\\bX\n                       #\\bY\n                       #\\bZ\n  \
    \                     #\\b{\n                       #", "  (cond\n    [(empty?\
    \ text)                  \"\"]\n    [(equal? (first text) 'a) \"\"]\n    [(equal?\
    \ (first text) 'e) \"\"]\n    [(equal? (first text) 'i) \"\"]\n    [(equal? (first\
    \ text) 'o) \"\"]\n    [(equal? (first text) 'u) \"\"]\n    [else\n     (cond\n\
    \       [(equal? (first text) 'A) \"\"]\n       [(equal? (first text) 'E) \"\"\
    ]\n       [(equal? (first text) 'I) \"\"]\n       [(equal? (first text) 'O) \"\
    \"]\n       [(equal? (first text) 'U) \"\"]\n       [else                    \
    \     (first text)]])]))\n", "  (cond\n    [(empty? text) empty]\n    [(= (first\
    \ text) 'a) (cons (car text) (remove_vowels (cdr text)))]\n    [(= (first text)\
    \ 'e) (cons (car text) (remove_vowels (cdr text)))]\n    [(= (first text) 'i)\
    \ (cons (car text) (remove_vowels (cdr text)))]\n    [(= (first text) 'o) (cons\
    \ (car text) (remove_vowels (cdr text)))]\n    [(= (first text) 'u) (cons (car\
    \ text) (remove_vowels (cdr text)))]\n    [else (cons (car text) (remove_vowels\
    \ (cdr text)))]\n  )\n)\n", "  (cond\n    [(empty? text) text]\n    [(vowel? text)\
    \ text]\n    [else (cons (car text) (remove_vowels (cdr text))) ]))\n", "  (cond\n\
    \    [(empty? text)\n     (empty? text)]\n    [(member? (car text) 'aeiouyAEIOUY])\n\
    \     (car text)]\n    [else\n     (cons (car text) (remove_vowels (cdr text)))]))\n\
    </code>\n<|/ a |>\n<| c |>\nA good answer, and something I've seen others do before\
    \ I read this post. :-)  One thing I'd like to point out is that the second clause\
    \ (else) is redundant. `cond` already returns 'true' or 'false' when the condition\
    \ is 'true'. So `[else (cons (car text) (remove_vowels (cdr text)))]` can be written\
    \ as `[(car text) (remove_vowels (cdr text))]`.\n<|/ c |>\n<| c |>\n, thanks for\
    \ pointing this out. I've been programming for a while in Scheme, but now I decided\
    \ to read more about Racket and I completely forgot about that.\n<|/ c |>\n<|\
    \ c |>\nAwesome! Thanks for sharing this.\n<|/ c |>\n<| a tags=scheme,racket |>\n\
    <code>", "  (let ([vowels '(aa ae ai ao aU AA AE AI AO AU ca ce ci co cu ga ge\
    \ gi gu ka ke ki ko kU KA KE KI KO\n           KU cc cn cc gn gc gh gj gu na ne\
    \ ni no nu pa pe pi pO po pu Ra Re Ri Ro RU Sa Se\n           Si so su ta te ti\
    \ Tu TU Te tO ua ue ui uo uu va ve vi vo vu Wa We Wi Wo WU]\n         results\
    \ (filter #(not= (first %) vowels) (map car (split-string (remove-if (lambda (x)\
    \ (equal? (first %) x)) text))))])\n    (make-string (car results) (cdr results))))\n",
  "  (cond\n    [(empty? text) empty]\n    [(eq? (first text) 'a) (remove 'a text)]\
    \ \n    [(eq? (first text) 'e) (remove 'e text)] \n    [(eq? (first text) 'i)\
    \ (remove 'i text)] \n    [(eq? (first text) 'o) (remove 'o text)] \n    [(eq?\
    \ (first text) 'u) (remove 'u text)] \n    [else (append text (first text))]))",
  "  (define vowels '(a e i o u))\n  (define (check text)\n    (if (string=? text\
    \ '())\n        '()\n        (loop\n           for ch in (list->string text)\n\
    \           for vowel in vowels\n           while (string=? ch (string->list vowel))\n\
    \           collect ch))\n  (check-empty text)\n  (check-not-empty text)\n  (check-letters\
    \ text)\n  (check-letters-only text)\n  (check-letters-only text)\n  (check-number\
    \ text)\n  (check-number-only text)\n  (check-symbols text)\n  (check-symbols-only\
    \ text)\n  (check-number text)\n  (check-letter-only text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-symbol text)\n  (check-symbol text)\n  (check-number\
    \ text)\n  (check-symbol text)\n  (check-letter text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-letter text)\n  (check-symbol text)\n  (check-letter-only\
    \ text)\n  (check-symbol text)\n  (check-number text)\n  (check-symbol text)\n\
    \  (check-letter text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-letter\
    \ text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-symbol text)\n  (check-symbol text)\n  (check-letter-only\
    \ text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n\
    \  (check-letter text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-letter\
    \ text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-symbol text)\n  (check-letter-only text)\n\
    \  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n  (check-letter-only\
    \ text)\n  (check-symbol text)\n  (check-letter text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-letter text)\n  (check-symbol text)\n  (check-letter-only\
    \ text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-symbol text)\n  (check-letter-only text)\n\
    \  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n  (check-letter-only\
    \ text)\n  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n\
    \  (check-letter-only text)\n  (check-symbol text)\n  (check-letter-only text)\n\
    \  (check-symbol text)\n  (check-letter-only text)\n  (check-symbol text)\n  (check-letter-only\
    \ text)\n  (", "  (cond\n    [(empty? text) text]\n    [(equal? (first (reverse\
    \ text)) 'a) (substring (remove 'a text) 1)]\n    [(equal? (first (reverse text))\
    \ 'e) (substring (remove 'e text) 1)]\n    [(equal? (first (reverse text)) 'i)\
    \ (substring (remove 'i text) 1)]\n    [(equal? (first (reverse text)) 'o) (substring\
    \ (remove 'o text) 1)]\n    [(equal? (first (reverse text)) 'u) (substring (remove\
    \ 'u text) 1)]\n    [else (substring (remove (first text) text))]\n  ))\n", " \
    \ (cond\n    [(empty? text) empty]\n    [else (if (member vowels text) (substring\
    \ text 0 (- (string-length text) 1)) empty)])\n  )\n)", "  (cond\n    [(string-empty?\
    \ text) text]\n    [(includes? #\\a text) \"\"]\n    [(includes? #\\e text) \"\
    \"]\n    [(includes? #\\i text) \"\"]\n    [(includes? #\\o text) \"\"]\n    [(includes?\
    \ #\\u text) \"\"]\n    [(includes? #\\A text) \"\"]\n    [(includes? #\\E text)\
    \ \"\"]\n    [(includes? #\\I text) \"\"]\n    [(includes? #\\O text) \"\"]\n\
    \    [(includes? #\\U text) \"\"]\n    [else text]))\n", "  (cond\n    [(empty?\
    \ text) empty]\n    [(not(char-in-set? (vowels) text)) text]\n    [else (cons\
    \ (substring (text 0 (- (length text) 1)) text))]))\n", "  (filter #(and (vowel?\
    \ (car %))\n                (not (equal? (car %) (cdr %)))\n                (not\
    \ (equal? (cdr %) 'z'))\n                (not (equal? (cdr %) 'Z'))\n        \
    \        (not (equal? (cdr %) 'y'))\n                (not (equal? (cdr %) 'Y'))\n\
    \                (not (equal? (cdr %) 'w'))\n                (not (equal? (cdr\
    \ %) 'W'))\n                (not (equal? (cdr %) 'v'))\n                (not (equal?\
    \ (cdr %) 'V'))\n                (not (equal? (cdr %) 'u'))\n                (not\
    \ (equal? (cdr %) 'U'))\n                (not (equal? (cdr %) 'i'))\n        \
    \        (not (equal? (cdr %) 'I'))\n                (not (equal? (cdr %) 'o'))\n\
    \                (not (equal? (cdr %) 'O'))\n                (not (equal? (cdr\
    \ %) 'a'))\n                (not (equal? (cdr %) 'A'))\n                (not (equal?\
    \ (cdr %) 's'))\n                (not (equal? (cdr %) 'S'))\n                (not\
    \ (equal? (cdr %) 'e'))\n                (not (equal? (cdr %) 'E'))\n        \
    \        (not (equal? (cdr %) 'd'))\n                (not (equal? (cdr %) 'D'))\n\
    \                (not (equal? (cdr %) 'h'))\n                (not (equal? (cdr\
    \ %) 'H'))\n                (not (equal? (cdr %) 'l'))\n                (not (equal?\
    \ (cdr %) 'L'))\n                (not (equal? (cdr %) 'u'))\n                (not\
    \ (equal? (cdr %) 'U'))\n                (not (equal? (cdr %) 'm'))\n        \
    \        (not (equal? (cdr %) 'M'))\n                (not (equal? (cdr %) 'n'))\n\
    \                (not (equal? (cdr %) 'N'))\n                (not (equal? (cdr\
    \ %) 'o'))\n                (not (equal? (cdr %) 'O'))\n                (not (equal?\
    \ (cdr %) 'p'))\n                (not (equal? (cdr %) 'P'))\n                (not\
    \ (equal? (cdr %) 'r'))\n                (not (equal? (", "  (cond\n    ((null?\
    \ text) text)\n    ((string=? text '()) '())\n    ((string=? text 'bcd) 'bcd))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [else (cons (first text) (remove_vowels\
    \ (rest text)))]))\n</cell>\n<code language=dyalog-kernel>", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(equal? (first text) 'a) (remove-vowels (rest text))] \n \
    \   [(equal? (first text) 'e) (remove-vowels (rest text))] \n    [(equal? (first\
    \ text) 'i) (remove-vowels (rest text))] \n    [(equal? (first text) 'o) (remove-vowels\
    \ (rest text))] \n    [(equal? (first text) 'u) (remove-vowels (rest text))] \n\
    \    [(equal? (first text) 'A) (remove-vowels (rest text))] \n    [(equal? (first\
    \ text) 'E) (remove-vowels (rest text))] \n    [(equal? (first text) 'I) (remove-vowels\
    \ (rest text))] \n    [(equal? (first text) 'O) (remove-vowels (rest text))] \n\
    \    [(equal? (first text) 'U) (remove-vowels (rest text))] \n    [else (cons\
    \ (first text) (remove_vowels (rest text))) ]\n    )\n  )\n", "  (define (helper\
    \ str char)\n    (cond\n      [(char=? char #\\a) (substring str 2)]\n      [(char=?\
    \ char #\\b) (substring str 1)]\n      [(char=? char #\\c) (substring str 1)]\n\
    \      [else (str str)]))\n  (cond [(empty? text) empty]\n        [else (helper\
    \ text (first text))]))\n", "  (cond\n    [(empty? text) text]\n    [else (let\
    \ ([chars (string->list (string->chars text))])\n            (remove_vowels chars))]))\n\
    </code>\n<|/ a dscore=2 tags=scheme,racket,string |>\n<| c |>\nThanks for the\
    \ help and tips! I see what I have done wrong now.\n<|/ c |>\n<| c |>\n, it's\
    \ good that you have found a solution, but you need to be careful about the recursion\
    \ when trying to understand it. It may seem like a trivial function, but when\
    \ you start having complex problems, it can save you a lot of headaches.\n<|/\
    \ c |>\n<| a tags=scheme,racket,string dscore=1 |>\nThe code you provided is pretty\
    \ much exactly what you want, but you do not have a base case that stops the recursion,\
    \ and you forgot to remove the vowel characters.\nHere is one way to do it (with\
    \ comments in the code):\n<code>", "  (if (empty? text)\n      text\n      (cons\
    \ (first text) (remove_vowels (rest text))))) ; first char is first char", " \
    \ (let loop ((text text) (vowels '(a e i o u y))\n             (result '()))\n\
    \    (cond\n      [(empty? text) result]\n      [(member (car text) vowels) (loop\
    \ (cdr text) vowels result)]\n      [else (loop (cdr text) vowels (cons (car text)\
    \ result))]))\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n<| a dscore=0 |>\n\
    You want to remove vowels from a string - you probably want to create a procedure:\n\
    <code>", "  (cond\n    ((empty? text)\n     (string! text))\n    ((string=? (car\
    \ text) 'a) (substring text 0 (- (length text) 1)))\n    ((string=? (car text)\
    \ 'e) (substring text 0 (- (length text) 1)))\n    ((string=? (car text) 'i) (substring\
    \ text 0 (- (length text) 1)))\n    ((string=? (car text) 'o) (substring text\
    \ 0 (- (length text) 1)))\n    ((string=? (car text) 'u) (substring text 0 (-\
    \ (length text) 1)))\n    ((string=? (car text) 'A) (substring text 0 (- (length\
    \ text) 1)))\n    ((string=? (car text) 'E) (substring text 0 (- (length text)\
    \ 1)))\n    ((string=? (car text) 'I) (substring text 0 (- (length text) 1)))\n\
    \    ((string=? (car text) 'O) (substring text 0 (- (length text) 1)))\n    ((string=?\
    \ (car text) 'U) (substring text 0 (- (length text) 1)))\n    ((string=? (car\
    \ text) 'a) (substring text 0 (- (length text) 1)))\n    ((string=? (car text)\
    \ 'e) (substring text 0 (- (length text) 1)))\n    ((string=? (car text) 'i) (substring\
    \ text 0 (- (length text) 1)))\n    ((string=? (car text) 'o) (substring text\
    \ 0 (- (length text) 1)))\n    ((string=? (car text) 'u) (substring text 0 (-\
    \ (length text) 1)))\n    ((string=? (car text) 'A) (substring text 0 (- (length\
    \ text) 1)))\n    ((string=? (car text) 'E) (substring text 0 (- (length text)\
    \ 1)))\n    ((string=? (car text) 'I) (substring text 0 (- (length text) 1)))\n\
    \    ((string=? (car text) 'O) (substring text 0 (- (length text) 1)))\n    ((string=?\
    \ (car text) 'U) (substring text 0 (- (length text) 1)))\n    (else (cons (car\
    \ text) (remove_vowels (cdr text)))))\n  )\n", "  (string-replace-all text \"\
    a\" \"z\")\n  (string-replace-all text \"b\" \"y\")\n  (string-replace-all text\
    \ \"c\" \"y\")\n  (string-replace-all text \"d\" \"y\")\n  (string-replace-all\
    \ text \"e\" \"y\")\n  (string-replace-all text \"f\" \"y\")\n  (string-replace-all\
    \ text \"g\" \"y\")\n  (string-replace-all text \"h\" \"y\")\n  (string-replace-all\
    \ text \"i\" \"y\")\n  (string-replace-all text \"j\" \"y\")\n  (string-replace-all\
    \ text \"k\" \"y\")\n  (string-replace-all text \"l\" \"y\")\n  (string-replace-all\
    \ text \"m\" \"y\")\n  (string-replace-all text \"n\" \"y\")\n  (string-replace-all\
    \ text \"o\" \"y\")\n  (string-replace-all text \"p\" \"y\")\n  (string-replace-all\
    \ text \"q\" \"y\")\n  (string-replace-all text \"r\" \"y\")\n  (string-replace-all\
    \ text \"s\" \"y\")\n  (string-replace-all text \"t\" \"y\")\n  (string-replace-all\
    \ text \"u\" \"y\")\n  (string-replace-all text \"v\" \"y\")\n  (string-replace-all\
    \ text \"w\" \"y\")\n  (string-replace-all text \"x\" \"y\")\n  (string-replace-all\
    \ text \"y\" \"y\")\n  (string-replace-all text \"z\" \"y\")\n  text)\n", "  (let\
    \ loop ((text text))\n    (if (null? text)\n        '\n        (let ((char (car\
    \ text)))\n          (if (char-alphabetic? char)\n              (loop (cdr text))\n\
    \              (cons char loop)))\n      (append (filter remove-vowels-predicate\
    \ (cdr text))\n              (loop (cdr text))))))\n", "  (cond [(empty? text)\n\
    \         \"\"]\n        [(member? (car text) 'aeiou)\n         (cons (car text)\n\
    \               (remove_vowels (cdr text)))]\n        [else\n         (cons (car\
    \ text)\n               (remove_vowels (cdr text)))]))", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [else (if (vowel? (car text)) (cdr text) (cons (car text) (remove_vowels\
    \ (cdr text))))]))\n", "  (if (empty? text)\n      '\n      (let ((vowels 'aeiouy)))\n\
    \        (if (member text vowels)\n            (substring text 0 (- (length text)\
    \ 1))\n            (cons text (remove_vowels (rest text)))))))\n</code>\n<code>",
  "  (cond\n    [(empty? text) empty]\n    [(char #\\a)(empty)]\n    [(char #\\b)(empty)]\n\
    \    [(char #\\d)(empty)]\n    [(char #\\e)(empty)]\n    [(char #\\f)(empty)]\n\
    \    [(char #\\g)(empty)]\n    [(char #\\h)(empty)]\n    [(char #\\i)(empty)]\n\
    \    [(char #\\j)(empty)]\n    [(char #\\k)(empty)]\n    [(char #\\l)(empty)]\n\
    \    [(char #\\m)(empty)]\n    [(char #\\n)(empty)]\n    [(char #\\o)(empty)]\n\
    \    [(char #\\p)(empty)]\n    [(char #\\q)(empty)]\n    [(char #\\s)(empty)]\n\
    \    [(char #\\t)(empty)]\n    [(char #\\v)(empty)]\n    [(char #\\w)(empty)]\n\
    \    [(char #\\y)(empty)]\n    [else (append\n           (if (char->int (first\
    \ text))\n               (remove_vowels (rest text))\n               empty)\n\
    \             (first text))]))\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>",
  "  (cond ((empty? text) '())\n        ((equal? (car text) 'a) (remove-vowels text)\n\
    \          (equal? (car text) 'u) (remove-vowels (cdr text))\n          (equal?\
    \ (car text) 'i) (remove-vowels (cdr text))\n          (equal? (car text) 'o)\
    \ (remove-vowels (cdr text))\n          (equal? (car text) 'e) (remove-vowels\
    \ (cdr text))\n          (equal? (car text) 'A) (remove-vowels (cdr text))\n \
    \         (equal? (car text) 'U) (remove-vowels (cdr text))\n          (equal?\
    \ (car text) 'I) (remove-vowels (cdr text))\n          (equal? (car text) 'O)\
    \ (remove-vowels (cdr text))\n          (equal? (car text) 'E) (remove-vowels\
    \ (cdr text))\n          (equal? (car text) 'b) (remove-vowels (cdr text))\n \
    \         (equal? (car text) 'z) (remove-vowels (cdr text))\n          (equal?\
    \ (car text) 'c) (remove-vowels (cdr text))\n          (equal? (car text) 'd)\
    \ (remove-vowels (cdr text))\n          (equal? (car text) 'Z) (remove-vowels\
    \ (cdr text))\n          (equal? (car text) 's) (remove-vowels (cdr text))\n \
    \         (equal? (car text) 'S) (remove-vowels (cdr text))\n          (equal?\
    \ (car text) 'h) (remove-vowels (cdr text))\n          (equal? (car text) 'H)\
    \ (remove-vowels (cdr text))\n          (equal? (car text) 'r) (remove-vowels\
    \ (cdr text))\n          (equal? (car text) 'D) (remove-vowels (cdr text))\n \
    \         (equal? (car text) 'f) (remove-vowels (cdr text))\n          (equal?\
    \ (car text) 'G) (remove-vowels (cdr text))\n          (equal? (car text) 'b)\
    \ (remove-vowels (cdr text))\n          (equal? (car text) 'f) (remove-vowels\
    \ (cdr text))\n          (equal? (car text) 'g) (remove-vowels (cdr text))\n \
    \         (equal? (car text) '", "  (cond\n    [(empty? text)  '']\n    [(matches\
    \ '[aeiou]) empty]\n    [else       (append  (char-before (first text) 'a) (remove_vowels\
    \ (rest text))) ] ) )\n", "  (string/join (remove #{\\aa \\e \\i \\o \\u} text)))\n",
  "  (cond\n    ((= (length text) 0) text)\n    ((char=? (car text) 'a) (remove-vowels\
    \ text) (substring (cdr text) 1))\n    ((char=? (car text) 'e) (remove-vowels\
    \ (substring (cdr text) 1) text) (substring (cdr text) 2))\n    ((char=? (car\
    \ text) 'i) (remove-vowels (substring (cdr text) 1) (substring (cdr text) 2) text)\
    \ (substring (cdr text) 3))\n    ((char=? (car text) 'o) (remove-vowels (substring\
    \ (cdr text) 1) (substring (cdr text) 2) (substring (cdr text) 3) text) (substring\
    \ (cdr text) 4))\n    ((char=? (car text) 'u) (remove-vowels (substring (cdr text)\
    \ 1) (substring (cdr text) 2) (substring (cdr text) 3) (substring (cdr text) 4)\
    \ text) (substring (cdr text) 5))\n    ((char=? (car text) 'y) (remove-vowels\
    \ (substring (cdr text) 1) (substring (cdr text) 2) (substring (cdr text) 3) (substring\
    \ (cdr text) 4) (substring (cdr text) 5) text) (substring (cdr text) 6))\n   \
    \ ((char=? (car text) 'z) (remove-vowels (substring (cdr text) 1) (substring (cdr\
    \ text) 2) (substring (cdr text) 3) (substring (cdr text) 4) (substring (cdr text)\
    \ 5) (substring (cdr text) 6) text) (car text))\n    (else text)))\n", "  (cond\n\
    \    [(empty? text)         text]\n    [(cons? text)\n     (let ([head (car text)])\
    \ (remove_vowels head) (cons (car text) text)]\n     [else (cons (car text) text)]))])\n",
  "  (cond\n    [(empty? text)\n     \"\"]\n    [(vowel? (car text)) (cons (car text)\
    \ (remove_vowels (cdr text)))]\n    [else\n     (cons (car text) (remove_vowels\
    \ (cdr text)))]))", "  (cond\n    [(empty? text) text]\n    [(starts-with? (car\
    \ text) 'z) (cons (car text) (remove_vowels (cdr text)))]\n    [else (cons (car\
    \ text) (remove_vowels (cdr text)))]))\n", "  (cond\n    [(empty? text) text]\n\
    \    [(equal? (car text) 'a) (remove_vowels (cdr text))] \n    [(equal? (car text)\
    \ 'u) (remove_vowels (cdr text))] \n    [(equal? (car text) 'e) (remove_vowels\
    \ (cdr text))] \n    [(equal? (car text) 'o) (remove_vowels (cdr text))] \n  \
    \  [(equal? (car text) 'i) (remove_vowels (cdr text))] \n    [(equal? (car text)\
    \ 'A) (remove_vowels (cdr text))] \n    [(equal? (car text) 'U) (remove_vowels\
    \ (cdr text))] \n    [(equal? (car text) 'E) (remove_vowels (cdr text))] \n  \
    \  [(equal? (car text) 'O) (remove_vowels (cdr text))] \n    [(equal? (car text)\
    \ 'I) (remove_vowels (cdr text))] \n    [else (cons (car text) (remove_vowels\
    \ (cdr text)))]))\n", "  (define (remove-vowels-loop text accum next-char) \n\
    \    (if (string? text)\n        (if (string=? text \"a\")\n            (remove-vowels-loop\
    \ text (cons \"a\" (append accum next-char)) \"b\")\n            (remove-vowels-loop\
    \ text (cons next-char (append accum next-char)) \"c\"))\n        (if (string=?\
    \ text \"e\")\n            (remove-vowels-loop text (cons \"e\" (append accum\
    \ next-char)) \"f\")\n            (remove-vowels-loop text (cons next-char (append\
    \ accum next-char)) \"g\"))))\n  (remove-vowels-loop text '() \"\"))\n", "  (let\
    \ ([vowels 'aeiouAEIOU])\n    (cond\n      [(empty? text) text]\n      [(map (fn\
    \ [_ (_|vowels)] _)\n           (remove-if char=? (string-fold string=? text vowels)))\
    \ text]\n      [else (remove_vowels (substring text 0 (string-length text)))])))\n",
  "  (define (f text)\n    (if (empty? text)\n        text\n        (f (substring\
    \ (char text 0) (length-char text)) (substring (char text 1) (length-char text)))))\n\
    \  (f text))\n", "  (if (string-empty? text)\n      text\n      (cond (vowel?\
    \  (string-ref text 0)\n                     #t (remove_vowels (string-downcase\
    \ (string-ref text 1)))))\n        ))\n", "  (loop for c in text\n        collect\
    \ (cond\n                 ((not(char=? c 'a') (char=? c 'e') (char=? c 'i') (char=?\
    \ c 'o') (char=? c 'u')) c)\n                 ((char=? c 'a') \"\")\n        \
    \         ((char=? c 'e') \"\")\n                 ((char=? c 'i') \"\")\n    \
    \             ((char=? c 'o') \"\")\n                 ((char=? c 'u') \"\")\n\
    \                 (else c))))\n</code>\n<|/ a |>\n<| a dscore=3 |>\nI believe\
    \ that this is the fastest way to do it.\n<code>", "  (cond\n    [(empty? text)\
    \ empty]\n    [(equal? text (first text)) (second text)]\n    [else (cons (first\
    \ text) (remove_vowels (rest text)))]))\n</code>\n<|/ a tags=racket,scheme |>\n\
    <| a tags=racket,scheme |>\nIf your problem is solved then you cannot ask any\
    \ more questions. \nIf you found my answer useful then you may want to upvote\
    \ it and mark it as accepted answer.\n<code>", "  (cond\n    [(empty? text) empty]\n\
    \    [(cons? text) (concat (remove_vowels (car text)) (remove_vowels (cdr text)))]\n\
    \    [else (cons (car text) (remove_vowels (cdr text)))]))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nHow about using recursion to eliminate `vowels` in the first step?\n\
    <|/ c |>\n<| c |>\n: I added a recursive version.\n<|/ c |>\n<| a tags=scheme,racket,recursion\
    \ |>\nSince this is homework, I'll give you a hint.  The language has both a list\
    \ and a string type.  The list type is essentially a linked list, and strings\
    \ are a sequence of characters.  When you're working with a string like \"abc\"\
    , you just go through each character, and keep track of which ones you're keeping.\
    \  When you're working with a list like '(a b c), you just look at the first element,\
    \ then the second, etc.  There are a couple of ways to keep track of which characters\
    \ you've kept in a string.\n<|/ a dscore=1 |>\n<| a dscore=1 tags=scheme,racket,recursion\
    \ |>\nHere is an example that works on any character set, not just letters.\n\
    <code>", "  (cond\n    [(empty? text) text]\n    [(consonant? (first text)) (remove_vowels\
    \ (rest text))]\n    [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (let loop ((text text))\n    (if (string-empty? text)\n        '\n        (cond\
    \ ((equal? (char-code (first text)) #\\a) (delete-char (first text)))\n      \
    \        ((equal? (char-code (first text)) #\\b) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\c) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\d) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\e) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\f) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\g) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\h) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\i) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\j) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\k) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\l) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\m) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\n) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\o) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\p) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\q) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\s) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\t) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\v) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\w) (delete-char (first text)))\n\
    \              ((equal? (char-code (first text)) #\\y) (", "  (match text\n  \
    \  [\"'\" \"\"]\n    [\"+\" \" \"]\n    [\"-\" \" \"]\n    [\"*\" \" \"]\n   \
    \ [\"/\" \" \"]\n    [\"-\" \" \"]\n    [\"&\" \"\"]\n    [\"!\" \"\"]\n    [\"\
    /\" \"\"]\n    [(empty? text) (empty? text)]\n    [else (cond [(string=? (car\
    \ (substring text 0 2)) \"'\") (cdr (substring text 0 2))]\n              [(string=?\
    \ (car (substring text 0 2)) \"&\") (cdr (substring text 0 2))]\n            \
    \  [(string=? (car (substring text 0 2)) \"!\") (cons (car text) (remove_vowels\
    \ (cdr text)))]\n              [(string=? (car (substring text 0 2)) \"+\") (cons\
    \ (car text) (remove_vowels (cdr text)))]\n              [(string=? (car (substring\
    \ text 0 2)) \"-\") (cons (car text) (remove_vowels (cdr text)))]\n          \
    \    [(string=? (car (substring text 0 2)) \"*\") (cons (car text) (remove_vowels\
    \ (cdr text)))]\n              [(string=? (car (substring text 0 2)) \"/\") (cons\
    \ (car text) (remove_vowels (cdr text)))]\n              [(string=? (car (substring\
    \ text 0 2)) \"/\") (cons (car text) (remove_vowels (cdr text)))]\n          \
    \    [(string=? (car (substring text 0 2)) \"/\") (cons (car text) (remove_vowels\
    \ (cdr text)))]\n              [(string=? (car (substring text 0 2)) \"-\") (cons\
    \ (car text) (remove_vowels (cdr text)))]\n              [(string=? (car (substring\
    \ text 0 2)) \"+\") (cons (car text) (remove_vowels (cdr text)))]\n          \
    \    [(string=? (car (substring text 0 2)) \"+\") (cons (car text) (remove_vowels\
    \ (cdr text)))]\n              [(string=? (car (substring text 0 2)) \"+\") (cons\
    \ (car text) (remove_vowels (cdr text)))]\n              [(string=? (car (substring\
    \ text 0 2)) \"+\") (cons (car text) (remove_vowels (cdr text)))]\n          \
    \    [(string=? (car (substring text 0 2)) \"+\") (cons (", "  (if (string-empty?\
    \ text)\n      \"\"\n      (let ([char (first text)]\n            [index (subseq\
    \ text 0 1)]\n            [tail (remove-vowels (rest text))])\n        (if (or\
    \ (char=? char #\\a) (char=? char #\\e) (char=? char #\\i) (char=? char #\\o)\
    \ (char=? char #\\u))\n            tail\n            (cons char (remove_vowels\
    \ tail))))))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| a dscore=1 |>\n\
    This is another way:\n<code>", "  (string-map #(if (= (char-code %) 97) (char-code\
    \ %) (char-code %)) text))\n</code>\n<|/ a tags=racket,string,list,scheme |>\n\
    <| a dscore=0 tags=racket,string,list,scheme |>\nThe most efficient way would\
    \ be to first convert it to an atom in Racket by using the hash function\n<code>",
  "  (cond\n    [(empty? text) \"\"]\n    [else\n      (cond\n        [(equal? (first\
    \ text) 'a) (cons (first text) (remove_vowels (rest text)))]\n        [(equal?\
    \ (first text) 'e) (cons (first text) (remove_vowels (rest text)))]\n        [(equal?\
    \ (first text) 'i) (cons (first text) (remove_vowels (rest text)))]\n        [(equal?\
    \ (first text) 'o) (cons (first text) (remove_vowels (rest text)))]\n        [(equal?\
    \ (first text) 'u) (cons (first text) (remove_vowels (rest text)))]\n        [else\
    \ (cons (first text) (remove_vowels (rest text)))])))])\n", "  (cond\n    ((empty?\
    \ text) text)\n    ((eqv? (car text) 'a) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'e) (cons (car text) empty))\n    ((eqv? (car text) 'i) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'o) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'u) (cons (car text) empty))\n    ((eqv? (car text) 'A) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'E) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'I) (cons (car text) empty))\n    ((eqv? (car text) 'O) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'U) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'b) (cons (car text) empty))\n    ((eqv? (car text) 'c) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'd) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'f) (cons (car text) empty))\n    ((eqv? (car text) 'g) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'h) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'j) (cons (car text) empty))\n    ((eqv? (car text) 'k) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'l) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'm) (cons (car text) empty))\n    ((eqv? (car text) 'n) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 'p) (cons (car text) empty))\n    ((eqv?\
    \ (car text) 'q) (cons (car text) empty))\n    ((eqv? (car text) 'r) (cons (car\
    \ text) empty))\n    ((eqv? (car text) 's) (cons (car text) empty))\n    ((eq",
  "  (cond\n    [(empty? text) text]\n    [(equal? (first text) vowel) (rest text)]\n\
    \    [else (cons (first text) (remove_vowels (rest text)))]))\n", "  (define (vowels\
    \ text)\n    (cond\n      [(empty? text) \"\"]\n      [(char=? (first text) #a)\
    \ (cons (first text) (vowels (rest text)))]\n      [(char=? (first text) #e) (cons\
    \ (first text) (vowels (rest text)))]\n      [(char=? (first text) #i) (cons (first\
    \ text) (vowels (rest text)))]\n      [(char=? (first text) #o) (cons (first text)\
    \ (vowels (rest text)))]\n      [(char=? (first text) #u) (cons (first text) (vowels\
    \ (rest text)))]\n      [else (cons (first text) (vowels (rest text)))]\n    \
    \  ))\n  (vowels text))\n", "  (cond ((= 0 (string-length text)) text)\n     \
    \   ((char= (char-code #\\a) (string->list text))\n         (char->string (string-append\
    \ \n                             (substring text 0 (- (string-length text) 1))\n\
    \                             '())))\n        (else (cond (char= (char-code #\\\
    e) (string->list text))\n                    (char->string (string-append \n \
    \                                      (substring text 0 (- (string-length text)\
    \ 1))\n                                       '()))\n                    (char=\
    \ (char-code #\\i) (string->list text))\n                    (char->string (string-append\
    \ \n                                       (substring text 0 (- (string-length\
    \ text) 1))\n                                       '()))\n                  \
    \  (char= (char-code #\\o) (string->list text))\n                    (char->string\
    \ (string-append \n                                       (substring text 0 (-\
    \ (string-length text) 1))\n                                       '()))\n   \
    \                 (char= (char-code #\\u) (string->list text))\n             \
    \       (char->string (string-append \n                                      \
    \ (substring text 0 (- (string-length text) 1))\n                            \
    \           '()))\n                    (else (cond (char= (char-code #\\A) (string->list\
    \ text))\n                                (char->string (string-append \n    \
    \                                              (substring text 0 (- (string-length\
    \ text) 1))\n                                                  '()))\n       \
    \                         (char= (char-code #\\Z) (string->list text))\n     \
    \                           (char->string (string-append \n                  \
    \                                (substring text 0 (- (string-length text) 1))\n\
    \                                                  '()))))))))\n", "  (cond\n\
    \    [(empty? text) empty]\n    [else\n     (string-append (take-while\n     \
    \                  (\u03BB (x)\n                         (eq? (char->string x)\
    \ 'a'\n                               'a'\n                               'A'\n\
    \                               'a'\n                               'A')\n   \
    \                      'aBcD')\n                       (reverse text))]))])\n",
  "  (cond [(empty? text) text]\n        [else (append (filter (lambda (c) (char=?\
    \ (char-code c) 'aeiou')) text))]))\n</code>\n<|/ a tags=racket,scheme |>\n<|\
    \ c |>\nThis solution is O(n). A more efficient solution would use a hash map\
    \ to store letters that occur more than once. This would also give O(n). A solution\
    \ with an additional global variable could use the same hashmap for storing the\
    \ results and give O(n).\n<|/ c |>\n<| c |>\n: I agree, using hash-table for memoization\
    \ is much better than using global variable for storing memoized results.\n<|/\
    \ c |>\n<| c |>\nA hash-table is O(1) for inserting and O(n) for the lookup though.\
    \ Using a global variable (as in the accepted answer) is also O(n).\n<|/ c |>\n\
    <| c |>\n: O(n) in both case for using hash-table and global variable. The only\
    \ difference is that in the hash table solution you can modify the function to\
    \ store more than 1 result and in global variable you can only modify the function\
    \ to store 1 result.\n<|/ c |>\n<| c |>\nA hash-table uses O(n) memory but is\
    \ O(1) to access and O(n) to insert. Using a global variable uses O(n) memory\
    \ but is O(1) to access and O(1) to insert.\n<|/ c |>\n<| a |>\nThe simplest thing\
    \ you could do is use Racket and define a function with something like this\n\
    <code>\n#lang racket", "  (cond [(empty? text) \"\"]\n        [(eqv? #\\a #\\\
    A) (append (string #\\a #\\A #\\b #\\B #\\c #\\C) (list (char #\\a #\\A #\\b #\\\
    B #\\c #\\C))]\n        [(eqv? #\\e #\\E) (append (string #\\e #\\E #\\i #\\I\
    \ #\\o #\\O) (list (char #\\e #\\E #\\i #\\I #\\o #\\O))]\n        [(eqv? #\\\
    i #\\I) (append (string #\\i #\\I #\\o #\\O) (list (char #\\i #\\I #\\o #\\O))]\n\
    \        [(eqv? #\\o #\\O) (append (string #\\o #\\O #\\u #\\U) (list (char #\\\
    o #\\O #\\u #\\U))]\n        [(eqv? #\\u #\\U) (append (string #\\u #\\U #\\o\
    \ #\\O) (list (char #\\u #\\U #\\o #\\O))]\n        [else (append text (list (char\
    \ #\\a #\\A #\\b #\\B #\\c #\\C #\\e #\\E #\\f #\\F #\\g #\\G #\\h #\\H #\\i #\\\
    I #\\k #\\K #\\l #\\L #\\m #\\M #\\n #\\N #\\p #\\P #\\r #\\R #\\s #\\S #\\t #\\\
    T #\\v #\\V #\\w #\\W #\\x #\\X))))))\n", "  (define (remove-vowel vowel)\n  \
    \  (string/replace text vowel ''))\n  (remove-vowel (string/join '() '())))\n",
  "  (cond [(string=? text '') text]\n        [(string=? text 'a) text]\n        [(string=?\
    \ text 'e) text]\n        [(string=? text 'i) text]\n        [(string=? text 'o)\
    \ text]\n        [(string=? text 'u) text]\n        [(bool=? text #t) text]\n\
    \        [else (string (reverse (remove (member 'a (string text)) (reverse (remove\
    \ (member 'e (string-repeat 'e #\\a) text)) (reverse (remove (member 'i (string-repeat\
    \ 'i #\\a) text)) (reverse (remove (member 'o (string-repeat 'o #\\a) text)) (reverse\
    \ (remove (member 'u (string-repeat 'u (string-repeat 'a #\\a) text))))))]))\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  (cond ((string=? text '')) '\n\
    \        ((string=? text 'a')) ''\n        ((string=? text 'A')) ''\n        ((string=?\
    \ text 'e')) ''\n        ((string=? text 'E')) ''\n        ((string=? text 'i'))\
    \ ''\n        ((string=? text 'I')) ''\n        ((string=? text 'o')) ''\n   \
    \     ((string=? text 'O')) ''\n        ((string=? text 'u')) ''\n        ((string=?\
    \ text 'U')) ''\n        (else (cond ((string=? (char->integer text) #\\a) ''\n\
    \                       ((string=? (char->integer text) #\\A) ''\n           \
    \            ((string=? (char->integer text) #\\e) ''\n                      \
    \ ((string=? (char->integer text) #\\E) ''\n                       ((string=?\
    \ (char->integer text) #\\i) ''\n                       ((string=? (char->integer\
    \ text) #\\I) ''\n                       ((string=? (char->integer text) #\\o)\
    \ ''\n                       ((string=? (char->integer text) #\\O) ''\n      \
    \                 ((string=? (char->integer text) #\\u) ''\n                 \
    \      ((string=? (char->integer text) #\\U) ''\n                       (else\
    \ text))))))))))\n</code>\n<|/ a tags=lisp,racket,scheme |>\n<| c |>\n+1 for a\
    \ very thorough answer. I'd also like to mention that a more idiomatic solution\
    \ for removing the vowels from a string would be `(define (remove-vowels string)\
    \ (remove-if string=? #\\a #\\A #\\e #\\E #\\i #\\I #\\o #\\O #\\u #\\U string))`\n\
    <|/ c |>\n<| c |>\nYes. That's a better solution. I'll edit my answer to include\
    \ your suggestion.\n<|/ c |>\n<| c |>\nGreat answer. I'll also post an answer\
    \ with a Scheme implementation that uses recursion.\n<|/ c |>\n<| a |>\nThis can\
    \ be done with recursion and a list comprehension:\n<code>", "  (cond [(empty?\
    \ text) text]\n        [(equal? (first text) 'a) (second text)]\n        [(equal?\
    \ (first text) 'e) (second text)]\n        [(equal? (first text) 'i) (second text)]\n\
    \        [(equal? (first text) 'o) (second text)]\n        [(equal? (first text)\
    \ 'u) (second text)]\n        [else\n         (cons (first text) (remove_vowels\
    \ (rest text)))]))\n", "  (cond\n    [(empty? text) empty]\n    [(equal 'a' (first\
    \ text)) (substring text 0 1)]\n    [(equal 'b' (first text)) (substring text\
    \ 0 2)]\n    [(equal 'c' (first text)) (substring text 0 3)]\n    [(equal 'd'\
    \ (first text)) (substring text 0 4)]\n    [(equal 'e' (first text)) (substring\
    \ text 0 5)]\n    [(equal 'f' (first text)) (substring text 0 6)]\n    [(equal\
    \ 'g' (first text)) (substring text 0 7)]\n    [(equal 'h' (first text)) (substring\
    \ text 0 8)]\n    [(equal 'i' (first text)) (substring text 0 9)]\n    [(equal\
    \ 'j' (first text)) (substring text 0 10)]\n    [(equal 'k' (first text)) (substring\
    \ text 0 11)]\n    [(equal 'l' (first text)) (substring text 0 12)]\n    [(equal\
    \ 'm' (first text)) (substring text 0 13)]\n    [(equal 'n' (first text)) (substring\
    \ text 0 14)]\n    [(equal 'o' (first text)) (substring text 0 15)]\n    [(equal\
    \ 'p' (first text)) (substring text 0 16)]\n    [(equal 'q' (first text)) (substring\
    \ text 0 17)]\n    [(equal 'r' (first text)) (substring text 0 18)]\n    [(equal\
    \ 's' (first text)) (substring text 0 19)]\n    [(equal 't' (first text)) (substring\
    \ text 0 20)]\n    [(equal 'u' (first text)) (substring text 0 21)]\n    [(equal\
    \ 'v' (first text)) (substring text 0 22)]\n    [(equal 'w' (first text)) (substring\
    \ text 0 23)]\n    [(equal 'x' (first text)) (substring text 0 24)]\n    [(equal\
    \ 'y' (first text)) (substring text 0 25)]\n    [(equal 'z' (first text)) (substring\
    \ text 0 26)]\n    [else text]))\n", "  (filter (lambda (char)\n            (char=?\
    \ (char->integer char) 65)\n            (char=? (char->integer char) 66)\n   \
    \         (char=? (char->integer char) 67)\n            (char=? (char->integer\
    \ char) 68)\n            (char=? (char->integer char) 69)\n            (char=?\
    \ (char->integer char) 70)\n            (char=? (char->integer char) 71)\n   \
    \         (char=? (char->integer char) 72)\n            (char=? (char->integer\
    \ char) 73)\n            (char=? (char->integer char) 74)\n            (char=?\
    \ (char->integer char) 75)\n            (char=? (char->integer char) 76)\n   \
    \         (char=? (char->integer char) 77)\n            (char=? (char->integer\
    \ char) 78)\n            (char=? (char->integer char) 79)\n            (char=?\
    \ (char->integer char) 80)\n            (char=? (char->integer char) 81)\n   \
    \         (char=? (char->integer char) 82)\n            (char=? (char->integer\
    \ char) 83)\n            (char=? (char->integer char) 84)\n            (char=?\
    \ (char->integer char) 85)\n            (char=? (char->integer char) 86)\n   \
    \         (char=? (char->integer char) 87)\n            (char=? (char->integer\
    \ char) 88)\n            (char=? (char->integer char) 89)\n            (char=?\
    \ (char->integer char) 90)\n            (char=? (char->integer char) 91)\n   \
    \         (char=? (char->integer char) 92)\n            (char=? (char->integer\
    \ char) 93)\n            (char=? (char->integer char) 94)\n            (char=?\
    \ (char->integer char) 95)\n            (char=? (char->integer char) 96)\n   \
    \         (char=? (char->integer char) 97)\n            (char=? (char->integer\
    \ char) 98)\n            (char=? (char->integer char) 99)\n            (char=?\
    \ (char->integer char) 100)\n            (char=? (char->integer char) 101)\n \
    \           (char=? (char->integer char) 102)\n            (char=? (char->integer\
    \ char) 103)\n            (char=? (char->integer char) 104)\n            (char=?\
    \ (char->integer char) 105)\n            (char=? (char->integer char) 106)\n \
    \           (char=? (char->", "  (cond\n    [(empty? text) \"\"]\n    [(equal?\
    \ (first text) #\\a) (remove_vowels (rest text))\n     (cons (first text) (rest\
    \ text))]\n    [(equal? (first text) #\\e) (remove_vowels (rest text))\n     (cons\
    \ (first text) (rest text))]\n    [(equal? (first text) #\\i) (remove_vowels (rest\
    \ text))\n     (cons (first text) (rest text))]\n    [(equal? (first text) #\\\
    o) (remove_vowels (rest text))\n     (cons (first text) (rest text))]\n    [(equal?\
    \ (first text) #\\u) (remove_vowels (rest text))\n     (cons (first text) (rest\
    \ text))]\n    [else (cons (first text) (remove_vowels (rest text)))]))\n", " \
    \ (cond [(empty? text) empty]\n        [(equal? (first text) 'a) empty]\n    \
    \    [(equal? (first text) 'e) empty]\n        [(equal? (first text) 'i) empty]\n\
    \        [(equal? (first text) 'o) empty]\n        [(equal? (first text) 'u) empty]\n\
    \        [else (cons (first text) (remove_vowels (rest text)))]))\n", "  (cond\n\
    \    ((empty? text)\n     '())\n    ((eqv? (first text) 'z)\n     '())\n    ((eqv?\
    \ (first text) 'j)\n     '())\n    ((eqv? (first text) 's)\n     '())\n    ((eqv?\
    \ (first text) 't)\n     '())\n    ((eqv? (first text) 'p)\n     '())\n    ((eqv?\
    \ (first text) 'o)\n     '())\n    ((eqv? (first text) 'n)\n     '())\n    ((eqv?\
    \ (first text) 'd)\n     '())\n    ((eqv? (first text) 'c)\n     '())\n    ((eqv?\
    \ (first text) 'v)\n     '())\n    ((eqv? (first text) 'a)\n     '())\n    ((eqv?\
    \ (first text) 'o)\n     '())\n    ((eqv? (first text) 'e)\n     '())\n    ((eqv?\
    \ (first text) 'w)\n     '())\n    ((eqv? (first text) 'n)\n     '())\n    ((eqv?\
    \ (first text) 'i)\n     '())\n    ((eqv? (first text) 'g)\n     '())\n    ((eqv?\
    \ (first text) 'u)\n     '())\n    ((eqv? (first text) 't)\n     '())\n    ((eqv?\
    \ (first text) 'i)\n     '())\n    ((eqv? (first text) 'g)\n     '())\n    ((eqv?\
    \ (first text) 'u)\n     '())\n    ((eqv? (first text) 'y)\n     '())\n    ((eqv?\
    \ (first text) 'j')\n     '())\n    ((eqv? (first text) 's')\n     '())\n    ((eqv?\
    \ (first text) 'b')\n     '())\n    ((eqv? (first text) 'r')\n     '())\n    ((eqv?\
    \ (first text) 'g')\n     '())\n    ((eqv? (first text) 'f')\n     '())\n    ((eqv?\
    \ (first text) 'r')\n     '())\n    ((eqv? (first text) 'h')\n     '())\n    ((eqv?\
    \ (first text) 's')\n     '())\n    ((eqv? (first text) 'c')\n     '())\n    ((eqv?\
    \ (first text) 'b')\n     '())\n    ((eqv? (first text) 'd')\n     '())\n    ((eqv?\
    \ (first text) 'h')\n     '())\n    ((eqv? (first text) 'j')\n     '())\n    ((eqv?\
    \ (first text) 'r')\n     '())\n    ((eq", "  (cond\n    ((empty? text)\n    \
    \ '())\n    ((vowel? (car text))\n     (cons (car text) (remove_vowels (cdr text))))\n\
    \    (else (cons (car text) (remove_vowels (cdr text)))))) ; recurse and remove\
    \ vowels \n                                                                  \
    \  ; (cdr text) can be empty string\n                                        \
    \                            ; if we reach this point\n                      \
    \                                              ; then we know that this string\
    \ is \n                                                                    ; a\
    \ vowel and we can recurse and remove\n                                      \
    \                              ; vowels from this part of the \n             \
    \                                                       ; string.", "  (cond\n\
    \    [(empty? text) \"\"]\n    [else (append (remove-if #(= (first %) (first '()))\
    \ (rest text)) \n      (remove_vowels (rest text))])]))\n", "  (if (null? text)\n\
    \      text\n      (cond [(or (char-equal? #\\A text)\n              (char-equal?\
    \ #\\a text))\n            (remove-vowels (cdr text))]\n            [(char-equal?\
    \ #\\z (car text))\n             (remove-vowels (cdr text))]\n            [(char-equal?\
    \ #\\V (car text))\n             (cond [(char-equal? #\\a (car text))\n      \
    \               (remove-vowels (cons (car text) (cdr text)))]\n              \
    \           [(char-equal? #\\e (car text))\n                       (cons #\\i\
    \ text (cdr text))]\n                         [(char-equal? #\\i (car text))\n\
    \                       (cons #\\o text (cdr text))]\n                       \
    \  [(char-equal? #\\o (car text))\n                       (cons #\\u text (cdr\
    \ text))]\n                         [(char-equal? #\\u (car text))\n         \
    \              (cons #\\l text (cdr text))]\n                         [(char-equal?\
    \ #\\l (car text))\n                       (cons #\\l text (cdr text))]\n    \
    \                     [(char-equal? #\\L (car text))\n                       (cons\
    \ #\\l text (cdr text))]\n                         [(char-equal? #\\L (car text))\n\
    \                       (cons #\\l text (cdr text))]\n                       \
    \  [(char-equal? #\\N (car text))\n                       (cons #\\n text (cdr\
    \ text))]\n                         [(char-equal? #\\n (car text))\n         \
    \              (cons #\\o text (cdr text))]\n                         [(char-equal?\
    \ #\\o (car text))\n                       (cons #\\u text (cdr text))]\n    \
    \                     [(char-equal? #\\u (car text))\n                       (cons\
    \ #\\l text (cdr text))]\n                         [(char-equal? #\\l (car text))\n\
    \                       (cons #\\l text (cdr text))]\n                       \
    \  [(char-equal? #\\L (car text))\n                       (cons #\\l text (cdr\
    \ text))]\n                         [(char-equal? #\\L (car text))\n         \
    \              (cons #\\l text (cdr text))]\n                         [(char-equal?\
    \ #\\N (c", "  (remove-if (\u03BB (a) (equal? (char->integer a) 65))\n       \
    \     text))\n", "  (replace text #{'A 'a 'E 'e 'I 'i 'O 'o 'U 'u} ''))\n</code>\n\
    <|/ a tags=racket,scheme |>\n<| c |>\nThanks so much for your reply, it makes\
    \ sense now but I am getting the error: \n\n\"define takes two arguments, but\
    \ found 3: #<procedure:remove_vowels>\"\n<|/ c |>\n<| c |>\n`define` must be followed\
    \ by a name and a value. The first is the name and the second is the value. You\
    \ probably used `define` to define a procedure that takes an argument. The solution\
    \ is to add an extra argument to `define`.\n<|/ c |>\n<| c |>\nI changed it to:\n",
  "  (cond\n    [(empty? text) empty]\n    [(member (first text) 'a) (cond\n     \
    \                            [(member (first text) 'A) empty]\n              \
    \                   [(member (first text) 'b) empty]\n                       \
    \          [(member (first text) 'c) empty]\n                                \
    \ [(member (first text) 'd) empty]\n                                 [(member\
    \ (first text) 'e) empty]\n                                 [(member (first text)\
    \ 'f) empty]\n                                 [else (first text)]\n         \
    \                        )]\n    [else (cond\n               [(member (first text)\
    \ 'A) (string-append (rest text) 'a')]\n               [(member (first text) 'B)\
    \ (string-append (rest text) 'b')]\n               [(member (first text) 'C) (string-append\
    \ (rest text) 'c')]\n               [(member (first text) 'D) (string-append (rest\
    \ text) 'd')]\n               [(member (first text) 'E) (string-append (rest text)\
    \ 'e')]\n               [(member (first text) 'F) (string-append (rest text) 'f')]\n\
    \               [else (string-append (rest text) (first text))]))]))\n", "  (cond\n\
    \    [(empty? text) text]\n    [(equal? (first text) 'a) (remove_vowels (substring\
    \ text (+ 2 1) (length text)))]\n    [(equal? (first text) 'e) (remove_vowels\
    \ (substring text (+ 2 1) (length text)))]\n    [(equal? (first text) 'i) (remove_vowels\
    \ (substring text (+ 3 1) (length text)))]\n    [(equal? (first text) 'o) (remove_vowels\
    \ (substring text (+ 3 1) (length text)))]\n    [(equal? (first text) 'u) (remove_vowels\
    \ (substring text (+ 3 1) (length text)))]\n    [(equal? (first text) 'A) (remove_vowels\
    \ (substring text (+ 4 1) (length text)))]\n    [(equal? (first text) 'E) (remove_vowels\
    \ (substring text (+ 4 1) (length text)))]\n    [(equal? (first text) 'I) (remove_vowels\
    \ (substring text (+ 4 1) (length text)))]\n    [(equal? (first text) 'O) (remove_vowels\
    \ (substring text (+ 4 1) (length text)))]\n    [(equal? (first text) 'U) (remove_vowels\
    \ (substring text (+ 4 1) (length text)))]\n    [else (cons (first text) (remove_vowels\
    \ (rest text))) ]\n))\n", "  (if (null? text)\n      '\n      (let* ([text (coerce\
    \ text string)]\n             [cons (list? '(#\\a #\\e #\\i #\\o #\\u)\n     \
    \                    (string->list text))]\n             [chars (append cons cons)])\n\
    \        (string->list text\n          (lambda (c)\n            (not (member (car\
    \ cons) (chars)))))))\n  text)\n", "  (cond\n    ((empty? text) '')\n    ((equal?\
    \ (first text) #\\a) (rest (rest text)))\n    ((equal? (first text) #\\e) (substring\
    \ (substring (first text) (- 1 (length text)) (- 1 (length text))) 1 text))\n\
    \    ((equal? (first text) #\\i) (substring (substring (first text) (- 1 (length\
    \ text)) (- 1 (length text))) 2 text))\n    ((equal? (first text) #\\o) (substring\
    \ (substring (first text) (- 1 (length text)) (- 1 (length text))) 2 text))\n\
    \    ((equal? (first text) #\\u) (substring (substring (first text) (- 1 (length\
    \ text)) (- 1 (length text))) 3 text))\n    ((equal? (first text) #\\y) (rest\
    \ (rest text)))\n    ((equal? (first text) #\\U) (substring (substring (first\
    \ text) (- 1 (length text)) (- 1 (length text))) 2 text))\n    ((equal? (first\
    \ text) #\\Y) (substring (substring (first text) (- 1 (length text)) (- 1 (length\
    \ text))) 3 text))\n    ((equal? (first text) #\\B) (substring (substring (first\
    \ text) (- 1 (length text)) (- 1 (length text))) 2 text))\n    ((equal? (first\
    \ text) #\\G) (substring (substring (first text) (- 1 (length text)) (- 1 (length\
    \ text))) 3 text))\n    ((equal? (first text) #\\Z) (substring (substring (first\
    \ text) (- 1 (length text)) (- 1 (length text))) 3 text))\n    ((equal? (first\
    \ text) #\\z) (substring (substring (first text) (- 1 (length text)) (- 1 (length\
    \ text))) 3 text))\n    ((equal? (first text) #\\Z) (substring (substring (first\
    \ text) (- 1 (length text)) (- 1 (length text))) 3 text))\n    ((equal? (first\
    \ text) #\\z) (substring (substring (first text) (- 1 (length text)) (- 1 (length\
    \ text))) 3 text))\n    ((equal? (first text) #\\Z) (substring (substring (first\
    \ text) (- 1 (length text)) (- 1 (length text))) 3 text))\n    ((equal? (first\
    \ text) #\\z) (substring (substring (first text) (- 1 (length text)) (- 1 (length\
    \ text))) 3 text))\n    ((equal? (first text) #\\Z) (substring (substring (first\
    \ text) (- 1 (length text)) (- 1 (length text))) 3 text))\n    ((equal? (first\
    \ text) #\\z) (substring (substring (first text) (- 1 (length text", "  (cond\n\
    \    [(equal? text '') '']\n    [(equal? text 'a) '']\n    [(equal? text 'e) '']\n\
    \    [(equal? text 'i) '']\n    [(equal? text 'o) '']\n    [(equal? text 'u) '']\n\
    \    [(equal? text 'A) '']\n    [(equal? text 'E) '']\n    [(equal? text 'I) '']\n\
    \    [(equal? text 'O) '']\n    [(equal? text 'U) '']\n    [else (concat text\
    \ (substring text 1 (length (filter (lambda (x) (not (equal? (substring text x)\
    \ 'A') 'A') 'AEIOU')))))]))\n", "  (cond [(null? text) text]\n        [(member\
    \ #\\a text)\n         (substring (substring text 0 (- (string-length text) 1))\
    \ text))\n         (else (substring (substring text 0 (- (string-length text)\
    \ 1)) text))])\n)\n", "  (filter #(if (vowel? #) '#\n                #) text))\n",
  "  (cond\n    [(equal? text \"\") \"\"]\n    [(equal? (char-code text) 65) (string\
    \ \"\")]\n    [else (string-append (remove-vowels-aux (string \"\") text) \"\"\
    )]))\n", "  (cond\n    ((empty? text) \"\")\n    ((equal? (first (car text)) #a)\
    \ (remove_vowels (rest (cdr text))))\n    ((equal? (first (car text)) #e) (remove_vowels\
    \ (rest (cdr text))))\n    ((equal? (first (car text)) #i) (remove_vowels (rest\
    \ (cdr text))))\n    ((equal? (first (car text)) #o) (remove_vowels (rest (cdr\
    \ text))))\n    ((equal? (first (car text)) #u) (remove_vowels (rest (cdr text))))\n\
    \    ((equal? (first (car text)) #U) (remove_vowels (rest (cdr text))))\n    ((equal?\
    \ (first (car text)) #Y) (remove_vowels (rest (cdr text))))\n    ((equal? (first\
    \ (car text)) #Y) (remove_vowels (rest (cdr text))))\n    (else (cons (car text)\
    \ (remove_vowels (rest (cdr text)))))))\n", "  (cond ((null? text) text)\n   \
    \     ((equal? (first text) 'a) (remove-if-not (equal? (first text) 'a') (rest\
    \ text)))\n        ((equal? (first text) 'e) (remove-if-not (equal? (first text)\
    \ 'e') (rest text)))\n        ((equal? (first text) 'i) (remove-if-not (equal?\
    \ (first text) 'i') (rest text)))\n        ((equal? (first text) 'o) (remove-if-not\
    \ (equal? (first text) 'o') (rest text)))\n        ((equal? (first text) 'u')\
    \ (remove-if-not (equal? (first text) 'u') (rest text)))\n        ((equal? (first\
    \ text) 'y) (remove-if-not (equal? (first text) 'y') (rest text)))))\n</code>\n\
    #lang racket\n<|/ a |>\n<| c |>\nThat `cond` syntax is quite nice :)\n<|/ c |>\n\
    <| a tags=scheme |>\nYou can make your function work like this:\n<code>", "  (cond\n\
    \    ((empty? text)\n     (empty))\n    ((char-upper? (first text))\n     (append\
    \ (remove_vowels (rest text)) (remove_vowels (rest text))))\n    (else\n     (append\
    \ text (first text))))) ;; #lang racket\n", "  (let ([vowels 'aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXzZ])\n\
    \    (cond\n      [(empty? text) text]\n      [(equal? text #\\a) (substring text\
    \ 0 (string-length text))]\n      [(equal? text #\\b) (substring text 0 (string-length\
    \ text))]\n      [(equal? text #\\c) (substring text 0 (string-length text))]\n\
    \      [(equal? text #\\d) (substring text 0 (string-length text))]\n      [(equal?\
    \ text #\\e) (substring text 0 (string-length text))]\n      [(equal? text #\\\
    f) (substring text 0 (string-length text))]\n      [(equal? text #\\g) (substring\
    \ text 0 (string-length text))]\n      [(equal? text #\\h) (substring text 0 (string-length\
    \ text))]\n      [(equal? text #\\i) (substring text 0 (string-length text))]\n\
    \      [(equal? text #\\j) (substring text 0 (string-length text))]\n      [(equal?\
    \ text #\\k) (substring text 0 (string-length text))]\n      [(equal? text #\\\
    l) (substring text 0 (string-length text))]\n      [(equal? text #\\n) (substring\
    \ text 0 (string-length text))]\n      [(equal? text #\\o) (substring text 0 (string-length\
    \ text))]\n      [(equal? text #\\p) (substring text 0 (string-length text))]\n\
    \      [(equal? text #\\q) (substring text 0 (string-length text))]\n      [(equal?\
    \ text #\\r) (substring text 0 (string-length text))]\n      [(equal? text #\\\
    s) (substring text 0 (string-length text))]\n      [(equal? text #\\t) (substring\
    \ text 0 (string-length text))]\n      [(equal? text #\\v) (substring text 0 (string-length\
    \ text))]\n      [(equal? text #\\z) (substring text 0 (string-length text))]\n\
    \      [(equal? (substring text 0 (string-length text)) #\\a) (substring text\
    \ 0 (string-length text))]\n      [(equal? (substring text 0 (string-length text))\
    \ #\\b) (substring text 0 (string-length text))]\n      [(equal? (substring text\
    \ 0 (string-length text)) #\\c) (substring text 0 (string-length text))]\n   \
    \   [(equal? (substring ", "  (string-replace\n   (string->symbols (remove (string->list\
    \ text))\n                    #:key (lambda (c) (string->list\n              \
    \                     #:key (lambda (c2) (string->list (char->symbol c2))\n  \
    \                                       #:test (lambda (c2) (member c2 'aeiou')))))\n\
    \                    #:replacement (lambda (c) (list c)))))\n", "  (cond (empty?\
    \ text) empty\n        (string=? text 'a) (substring text 0 (- 1 (length text)))\n\
    \        (string=? text 'e) (substring text 0 (- 1 (length text)))\n        (string=?\
    \ text 'i) (substring text 0 (- 1 (length text)))\n        (string=? text 'o)\
    \ (substring text 0 (- 1 (length text)))\n        (string=? text 'u) (substring\
    \ text 0 (- 1 (length text)))\n        :else text))\n", "  (remove-if-not #(and\
    \ (char=? (car %) 'a') (char=? (car %) 'e') (char=? (car %) 'i')\n           \
    \          (char=? (car %) 'o') (char=? (car %) 'u'))\n                text))\n",
  "  (cond [(empty? text) '']\n        [(equal? (first text) 'a) (cons (first text)\
    \ (remove_vowels (rest (rest text)))]\n        [(equal? (first text) 'e) (cons\
    \ (first text) (remove_vowels (rest (rest text)))]\n        [(equal? (first text)\
    \ 'i) (cons (first text) (remove_vowels (rest (rest text)))]\n        [(equal?\
    \ (first text) 'o) (cons (first text) (remove_vowels (rest (rest text)))]\n  \
    \      [(equal? (first text) 'u') (cons (first text) (remove_vowels (rest (rest\
    \ text)))]\n        [(equal? (first text) 'A) (cons (first text) (remove_vowels\
    \ (rest (rest text)))]\n        [(equal? (first text) 'E) (cons (first text) (remove_vowels\
    \ (rest (rest text)))]\n        [(equal? (first text) 'I) (cons (first text) (remove_vowels\
    \ (rest (rest text)))]\n        [(equal? (first text) 'O) (cons (first text) (remove_vowels\
    \ (rest (rest text)))]\n        [(equal? (first text) 'U') (cons (first text)\
    \ (remove_vowels (rest (rest text)))]\n        [else (cons (first text) (remove_vowels\
    \ (rest (rest text))))]))\n", "  (if (null? text)\n      '\n      (cond [(member?\
    \ #\\a text)\n              (cons #\\a (remove_vowels (substring text 1)))]\n\
    \            [(member? #\\b text)\n              (cons #\\b (remove_vowels (substring\
    \ text 1)))]\n            [(member? #\\c text)\n              (cons #\\c (remove_vowels\
    \ (substring text 1)))]\n            [(member? #\\d text)\n              (cons\
    \ #\\d (remove_vowels (substring text 1)))]\n            [(member? #\\e text)\n\
    \              (cons #\\e (remove_vowels (substring text 1)))]\n            [(member?\
    \ #\\f text)\n              (cons #\\f (remove_vowels (substring text 1)))]\n\
    \            [(member? #\\g text)\n              (cons #\\g (remove_vowels (substring\
    \ text 1)))]\n            [(member? #\\h text)\n              (cons #\\h (remove_vowels\
    \ (substring text 1)))]\n            [(member? #\\i text)\n              (cons\
    \ #\\i (remove_vowels (substring text 1)))]\n            [(member? #\\j text)\n\
    \              (cons #\\j (remove_vowels (substring text 1)))]\n            [(member?\
    \ #\\k text)\n              (cons #\\k (remove_vowels (substring text 1)))]\n\
    \            [(member? #\\l text)\n              (cons #\\l (remove_vowels (substring\
    \ text 1)))]\n            [(member? #\\m text)\n              (cons #\\m (remove_vowels\
    \ (substring text 1)))]\n            [(member? #\\n text)\n              (cons\
    \ #\\n (remove_vowels (substring text 1)))]\n            [(member? #\\o text)\n\
    \              (cons #\\o (remove_vowels (substring text 1)))]\n            [(member?\
    \ #\\p text)\n              (cons #\\p (remove_vowels (substring text 1)))]\n\
    \            [(member? #\\q text)\n              (cons #\\q (remove_vowels (substring\
    \ text 1)))]\n            [(member? #\\r text)\n              (cons #\\r (remove_vowels\
    \ (substring text 1)))]\n            [(member? #\\s text)\n              (cons\
    \ #\\s (remove_vowels (substring text 1)))]\n            [(member? #\\t text)\n\
    \              (cons #\\t (remove_", "  (cond [(empty? text) \"\"]\n        [(member\
    \ (char-code #\\a) text) \"\"]\n        [(member (char-code #\\e) text) \"\"]\n\
    \        [(member (char-code #\\i) text) \"\"]\n        [(member (char-code #\\\
    o) text) \"\"]\n        [(member (char-code #\\u) text) \"\"]\n        [else (substring\
    \ (text 0) (length (filter #(= (char-code #\\a) (char-code %))text) 1)]))\n</code>\n\
    <|/ a |>\n<| c |>\nthank you for showing me the cond function, that's what I needed\
    \ to solve the problem\n<|/ c |>\n<| c |>\nYou're welcome. My intention of writing\
    \ was to show you that there's an alternative to writing a chain of `if`s and\
    \ `cond`s for an `if` expression like that. `cond`s make your code look a lot\
    \ more like Lisp and look nicer. One day you may even want to use Racket and have\
    \ your cake and eat it too.\n<|/ c |>\n<| c |>\nthank you, I realize that I can\
    \ use cond expressions to replace ifs\n<|/ c |>\n<| a dscore=1 |>\nI made this\
    \ as an exercise, and my own answer uses no ifs.\n<code>", "  (cond [(empty? text)\
    \ empty]\n        [(equal? (first text) 'a) (if (equal? (rest text) 'A) 'B (rest\
    \ text))] \n        [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (remove-if (lambda (c) (member c 'aeiouAEIOU))\n             text))\n", "  (cond\
    \ [(equal? text \"\") \"\"]\n        [(member? (char-code 'a) text) (substring\
    \ text 0 (string-length text))]\n        [(member? (char-code 'e) text) (substring\
    \ text 0 (string-length text))]\n        [(member? (char-code 'i) text) (substring\
    \ text 0 (string-length text))]\n        [(member? (char-code 'o) text) (substring\
    \ text 0 (string-length text))]\n        [(member? (char-code 'u) text) (substring\
    \ text 0 (string-length text))]\n        [else (substring text 0 (string-length\
    \ text))]))\n", "  (let loop ((text text)\n             (vowels '(a e i o u)\n\
    \                      (y o u e o a i e o u o i o u i o u y o i e o u e o y o\
    \ e y o i a e y a i e y o a o a i e y i a a y o i o i o a e o a e i a i o a i\
    \ y i y o a o i e y a o i e y a o a i o a i y e o a i o a i y o a i o e y a o\
    \ a i e y o a i e y a o a i o a i y o a i o y a i a o o a o i y a i e y a i o\
    \ a i y a i o y o i e y o a i e y a i o a i y o a i o a e i y a i o a i y o a\
    \ i o i y o i a i a o i e y o a i o a i y o a i o a i y o a i o a o i y o a i\
    \ o y a i a o o a o i y a i e y a i o a i y o a i o a e i y a i o a i y o a i\
    \ o a e i y o a i o a i y o a i o y a i a o o a o i y a i e y a i o a i y o a\
    \ i o a e i y a i o a i y o a i o a e i y o a i o a i y o a i o y a i a o o a\
    \ o i y a i e y a i o a i y o a i o a e i y o a i o a i y o a i o y a i a o o\
    \ a o i y a i e y a i o a i y o a i o a e i y o a i o a i y o a i o a e i y o\
    \ a i o a i y o a i o y a i a o o a o i y a i e y a i o a i y o a i o a e i y\
    \ o a i o a i y o a i o a e i y o a i o a i y o a i o y a i a o o a o i y a i\
    \ e y a i o a i y o ", "  (remove (lambda (x) (member x 'aeiou'))\n          text))\n",
  "  (let loop ((text text)\n             (count 0)\n             (output '()))\n\
    \    (cond\n      [(empty? text) (reverse output)]\n      [(char=? #\\A text)\
    \ '']\n      [(char=? (first text) #\\A)\n       (set! count (+ count 1))\n  \
    \     (loop (rest text) count output)]\n      [(char=? #\\A text)\n       (cond\n\
    \         [(< count 0) (loop (rest text) count output)]\n         [else (set!\
    \ count (- count 1))\n            (loop (rest text) count (cons (first text) output))]\n\
    \         [else output])]\n      [(char=? (first text) #\\A)\n       (set! count\
    \ (+ count 1))\n       (loop (rest text) count output)]\n      [(char=? (first\
    \ text) #\\z)\n       (cond\n         [(< count 0) (loop (rest text) count output)]\n\
    \         [else (set! count (- count 1))\n            (loop (rest text) count\
    \ (cons (first text) output))]\n         [else output])]\n      [(char=? (first\
    \ text) #\\z)\n       (set! count (+ count 1))\n       (loop (rest text) count\
    \ output)]))\n</code>\n<|/ a tags=scheme,racket,functional-programming dscore=1\
    \ |>\n<| a |>\nThis is how I got this problem to work - not sure if it's the most\
    \ efficient way though.\n<code>", "  (cond\n    ((string? text)\n     (cond\n\
    \       ((string-match '[aeiouAEIOU]\n                      (string text))\n \
    \       (string->char (string-without-chars\n                          (string\
    \ text)\n                          '[aeiouAEIOU])))\n       ((string-match '[a-z]\n\
    \                      (string text))\n        (string->char (string-without-chars\n\
    \                          (string text)\n                          '[a-z])))\n\
    \       ((string-match '[A-Z]\n                      (string text))\n        (string->char\
    \ (string-without-chars\n                          (string text)\n           \
    \               '[A-Z])))\n       ((string-match '[0-9]\n                    \
    \  (string text))\n        (string->char (string-without-chars\n             \
    \             (string text)\n                          '[0-9])))))\n", "  ;; (cond\n\
    \  ;;   [(string=? text \"\") \"\"]\n  ;;   [else (string->chars text)\n  ;; \
    \   (remove-vowels (string->chars text))]))\n  (cond\n   [(string=? text \"\"\
    ) \"\"]\n   [else (string->chars text)\n    (remove_vowels (string->chars text))]))\n",
  "  (cond\n    [(empty? text) '']\n    [(map (fn [x] \n             `(not= ,x ,(first\
    \ text)))\n          (rest text))\n     (remove_vowels (rest text))]))\n", " \
    \ (cond\n    [(empty? text) text]\n    [(equal? (first text) 'a) (second text)]\n\
    \    [(equal? (first text) 'e) (second text)]\n    [(equal? (first text) 'i) (second\
    \ text)]\n    [(equal? (first text) 'o) (second text)]\n    [(equal? (first text)\
    \ 'u) (second text)]\n    [else (cons (first text)\n              (remove_vowels\
    \ (rest text)))]))\n", "  (if (null? text)\n      '\n      (if (char-alphabetic?\
    \ (car text))\n          (if (string? (cdr text))\n              (cons (car text)\
    \ (remove_vowels (cdr text)))\n              (cons text (remove_vowels (cdr text))))\n\
    \          (cons (car text) (remove_vowels (cdr text)))))\n  )\n", "  (cond\n\
    \    [(empty? text) text]\n    [(equal? text (first-char text))\n     (remove_vowels\
    \ (rest-of-string text))\n     ]\n    [else (cons (first-char text)\n        \
    \        (remove_vowels (rest-of-string text)))]\n  ))\n", "  (remove-if (lambda\
    \ (x) (member x 'aeiou')) text))\n", "  (cond\n    [(empty? text) \"\"]\n    [else\n\
    \     (string-append (substring text 0 (string-length text)) \n              \
    \       (substring (remove (vowels?) text) 0 (string-length text)))]))\n", " \
    \ (cond [(string=? text '') text]\n        [(string=? (remove-if #(member? (first\
    \ %) 'aeiouy)) text)\n         #(remove-if #(member? (first %) 'aeiouy)) text]\n\
    \        [else (cons text (remove_vowels (rest text))) ]))\n", "  (cond\n    [(empty?\
    \ text) empty]\n    [(member (first text) #'(') (remove_vowels (rest text))])\n\
    \    [else (cons (first text) (remove_vowels (rest text)))]))\n", "  (cond [(=\
    \ text \"\") \"\"]\n        [(char= text 'a) (substring text 0 (- 1 'a))] \n \
    \       [(char= text 'e) (substring text 0 (- 1 'e))] \n        [(char= text 'i)\
    \ (substring text 0 (- 1 'i))] \n        [(char= text 'o) (substring text 0 (-\
    \ 1 'o))] \n        [(char= text 'u) (substring text 0 (- 1 'u))] \n        [(else\n\
    \           (substring text 0 (- (length text) 2)))))\n", "  (cond\n    [(empty?\
    \ text) empty]\n    [(consonant? (car text)) (remove_vowels (cdr text))] \n  \
    \  [else (cons (car text) (remove_vowels (cdr text)))]))", "  (cond\n    ((empty?\
    \ text) text)\n    ((equal? text #\\a) (substring text (- 1 (string-length text))))\n\
    \    ((equal? text #\\b) (substring text (- 1 (string-length text))))\n    ((equal?\
    \ text #\\c) (substring text (- 1 (string-length text))))\n    ((equal? text #\\\
    d) (substring text (- 1 (string-length text))))\n    ((equal? text #\\e) (substring\
    \ text (- 1 (string-length text))))\n    ((equal? text #\\g) (substring text (-\
    \ 1 (string-length text))))\n    ((equal? text #\\h) (substring text (- 1 (string-length\
    \ text))))\n    ((equal? text #\\i) (substring text (- 1 (string-length text))))\n\
    \    ((equal? text #\\j) (substring text (- 1 (string-length text))))\n    ((equal?\
    \ text #\\k) (substring text (- 1 (string-length text))))\n    ((equal? text #\\\
    l) (substring text (- 1 (string-length text))))\n    ((equal? text #\\n) (substring\
    \ text (- 1 (string-length text))))\n    ((equal? text #\\o) (substring text (-\
    \ 1 (string-length text))))\n    ((equal? text #\\p) (substring text (- 1 (string-length\
    \ text))))\n    ((equal? text #\\r) (substring text (- 1 (string-length text))))\n\
    \    ((equal? text #\\s) (substring text (- 1 (string-length text))))\n    ((equal?\
    \ text #\\t) (substring text (- 1 (string-length text))))\n    ((equal? text #\\\
    v) (substring text (- 1 (string-length text))))\n    ((equal? text #\\w) (substring\
    \ text (- 1 (string-length text))))\n    ((equal? text #\\X) (substring text (-\
    \ 1 (string-length text))))\n    ((equal? text #\\Z) (substring text (- 1 (string-length\
    \ text))))\n    ((equal? text #\\a) (substring text (- 1 (string-length text))))\n\
    \    ((equal? text #\\b) (substring text (- 1 (string-length text))))\n    ((equal?\
    \ text #\\c) (substring text (- 1 (string-length text))))\n    ((equal? text #\\\
    d) (substring text (- 1 (string-length text))))\n    ((equal? text #\\e) (substring\
    \ text (- 1 (string-length text))))\n    ((equal? text #\\g) (substring text (-\
    \ 1 (string-length ", '  (re-seq (string->symbol "[aeiouAEIOU]") text))', "  (let\
    \ ([vowels '(a e i o u)])\n    (filter #(not(member % vowels)) text)))", "  (cond\n\
    \    [(empty? text) text]\n    [(cons? text) (cond\n                        [(null\
    \ text) \"\"]\n                      [(cons? #:c text)\n                     \
    \   (cond\n                          [(empty? (rest text))\n                 \
    \           (cons (car text) (remove_vowels (cdr text)))]\n                  \
    \        [else (cons (car text)\n                                        (remove_vowels\
    \ (cdr text)))]))]\n    [else (cons (car text)\n                  (remove_vowels\
    \ (cdr text)))]))\n", "  (cond [(empty? text)\n         \"\"]\n        [(cons?\
    \ text) (cons (first (first (first text))) (rest (first (first text))))]\n   \
    \     [else (cons (first (first (first text))) (remove_vowels (rest (first (first\
    \ text))))])))\n", "  (string-replace text #{\\a|e|i|o|u}''))\n", "  (let ([chars\
    \ (string->chars text)])\n    (cond [(empty? chars) text]\n          [(string=?\
    \ (first chars) 'a) \n           (let ([second (second chars)])\n            \
    \ (if (string=? (first second) 'a) (remove_vowels (second chars)) \n         \
    \       (append (first second) (remove_vowels (rest chars)))))]\n          [(string=?\
    \ (first chars) 'e) \n           (let ([second (second chars)])\n            \
    \ (if (string=? (first second) 'e) (remove_vowels (second chars)) \n         \
    \       (append (first second) (remove_vowels (rest chars)))))]\n          [(string=?\
    \ (first chars) 'i) \n           (let ([second (second chars)])\n            \
    \ (if (string=? (first second) 'i) (remove_vowels (second chars)) \n         \
    \       (append (first second) (remove_vowels (rest chars)))))]\n          [(string=?\
    \ (first chars) 'o) \n           (let ([second (second chars)])\n            \
    \ (if (string=? (first second) 'o) (remove_vowels (second chars)) \n         \
    \       (append (first second) (remove_vowels (rest chars)))))]\n          [(string=?\
    \ (first chars) 'u) \n           (let ([second (second chars)])\n            \
    \ (if (string=? (first second) 'u) (remove_vowels (second chars)) \n         \
    \       (append (first second) (remove_vowels (rest chars)))))]\n          [(string=?\
    \ (first chars) 'Y) \n           (let ([second (second chars)])\n            \
    \ (if (string=? (first second) 'Y) (remove_vowels (second chars)) \n         \
    \       (append (first second) (remove_vowels (rest chars)))))]\n          [else\
    \ (remove_vowels (rest chars))]\n      )))\n", "  (match text\n    ([(or (not\
    \ text) (empty? text))] text)\n    ([(or (empty? text) (char=? (first text) #\\\
    a)) (first text)])\n    ([(char=? (first text) #\\e)\n      (match (cdr text)\n\
    \         ([(cdr (or (match (rest text)\n                       ([(char=? (first\
    \ text) #\\a)\n                         (empty? text)]\n                     \
    \  [(char=? (first text) #\\e)\n                         (match (rest text) ([])))]))])\n\
    \         ([(cdr (or (match (rest text)\n                         ([(char=? (first\
    \ text) #\\a)\n                          (char=? (first text) #\\e)])\n      \
    \                 [(char=? (first text) #\\e)\n                         (match\
    \ (rest text)\n                               ([(char=? (first text) #\\a)\n \
    \                                (empty? text)]))]))]))]))]))))\n", "  (string-map\
    \ remove-if-not\n              (string-match #rx\"[aeiou]\" text)\n          \
    \    text))\n", "  (cond ((string=? text \"\") \"\")\n        ((string=? text\
    \ \"z\") \"\")\n        ((string=? text \"Z\") \"\")\n        ((string=? text\
    \ \"zB\") \"\")\n        ((string=? text \"zc\") \"\")\n        ((string=? text\
    \ \"zC\") \"\")\n        ((string=? text \"zcD\") \"\")\n        ((string=? text\
    \ \"zCd\") \"\")\n        ((string=? text \"zCdF\") \"\")\n        ((string=?\
    \ text \"zCdf\") \"\")\n        ((string=? text \"zCdfg\") \"\")\n        ((string=?\
    \ text \"zCdfgf\") \"\")\n        ((string=? text \"zCdfgf\") \"\")\n        ((string=?\
    \ text \"zCdfgfK\") \"\")\n        ((string=? text \"zCdfgfKa\") \"\")\n     \
    \   ((string=? text \"zCdfgfKaB\") \"\")\n        ((string=? text \"zCdfgfKab\"\
    ) \"\")\n        ((string=? text \"zCdfgfKabd\") \"\")\n        ((string=? text\
    \ \"zCdfgfKabdc\") \"\")\n        ((string=? text \"zCdfgfKabdcD\") \"\")\n  \
    \      ((string=? text \"zCdfgfKabdcDf\") \"\")\n        ((string=? text \"zCdfgfKabdcDfg\"\
    ) \"\")\n        ((string=? text \"zCdfgfKabdcDfgf\") \"\")\n        ((string=?\
    \ text \"zCdfgfKabdcDfgfK\") \"\")\n        ((string=? text \"zCdfgfKabdcDfgfka\"\
    ) \"\")\n        ((string=? text \"zCdfgfKabdcDfgfkaB\") \"\")\n        ((string=?\
    \ text \"zCdfgfKabdcDfgfkab\") \"\")\n        ((string=? text \"zCdfgfKabdcDfgfkabd\"\
    ) \"\")\n        ((string=? text \"zCdfgfKabdcDfgfkabdc\") \"\")\n        ((string=?\
    \ text \"zCdfgfKabdcDfgfkabdcf\") \"\")\n        ((string=? text \"zCdfgfKabdcDfg",
  "  (cond\n    [(empty? text) \"\"]\n    [(or (char-lower (char text 0)) (char-upper\
    \ (char text 0))) text]\n    [else (append (remove_vowels (substring text 0 -1))\n\
    \                   (list (char-lower (char text 0)))\n                   (list\
    \ (char-upper (char text 0)))\n                   (list (char-title (char text\
    \ 0))))]))\n</code>\n<|/ a |>\n<| a tags=racket,string |>\n<code>", "  (remove-if\
    \ (lambda (x)\n              (equal? (char-code x) 'a'))\n             text))\n",
  "  (if (string=? text \"\")\n      text\n      (append\n       text\n       (remove\n\
    \        (cdr\n         (remove\n          (string=? #\\a text)\n          (string=?\
    \ #\\b text)\n          (string=? #\\c text)\n          (string=? #\\d text)\n\
    \          (string=? #\\e text)\n          (string=? #\\f text)\n          (string=?\
    \ #\\g text)\n          (string=? #\\h text)\n          (string=? #\\i text)\n\
    \          (string=? #\\j text)\n          (string=? #\\k text)\n          (string=?\
    \ #\\l text)\n          (string=? #\\m text)\n          (string=? #\\n text)\n\
    \          (string=? #\\o text)\n          (string=? #\\p text)\n          (string=?\
    \ #\\q text)\n          (string=? #\\r text)\n          (string=? #\\s text)\n\
    \          (string=? #\\t text)\n          (string=? #\\v text)\n          (string=?\
    \ #\\w text)\n          (string=? #\\127 text)\n          (string=? #\\255 text)\n\
    \          (string=? #\\361 text)\n          (string=? #\\481 text)\n        \
    \  (string=? #\\559 text)\n          (string=? #\\613 text)\n          (string=?\
    \ #\\653 text)\n          (string=? #\\663 text)\n          (string=? #\\711 text)\n\
    \          (string=? #\\741 text)\n          (string=? #\\771 text)\n        \
    \  (string=? #\\801 text)\n          (string=? #\\841 text)\n          (string=?\
    \ #\\861 text)\n          (string=? #\\891 text)\n          (string=? #\\911 text)\n\
    \          (string=? #\\939 text)\n          (string=? #\\959 text)\n        \
    \  (string=? #\\979 text)\n          (string=? #\\1001 text)\n          (string=?\
    \ #\\1029 text)\n          (string=? #\\1049 text)\n          (string=? #\\1071\
    \ text)\n          (string=? #\\1091 text)\n          (string=? #\\1111 text)\n\
    \          (string=? #\\1133 text)\n          (string=? #\\1155 text)\n      \
    \    (string=? #\\1177 text)\n          (string", "  \n  (cond\n    [(empty? text)\
    \ empty]\n    [(symbolp (first text)) (first text)]\n    [else (cons (first text)\n\
    \                (remove_vowels (rest text))])]))\n", "  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)))\n  (cond ((string-length? text 0)\n         text)\n\
    \        ((not (is-vowel? (first text)))\n         (cons (first text) (remove-vowels\
    \ (rest text))))\n        (t (remove-vowels (rest text))))\n</code>\n<|/ a dscore=1\
    \ tags=racket,recursion,string |>\n<| c |>\nThank you very much for these suggestions,\
    \ I really appreciate it. I still need to work through it but when I get it I'll\
    \ post the code here.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (cond\n    [(empty?\
    \ text)\n     empty]\n    [(equal? (first text) 'a)\n     (cons (substring text\
    \ (length text) 2))]\n    [(equal? (first text) 'e)\n     (cons (substring text\
    \ (length text) 2))]\n    [(equal? (first text) 'i)\n     (cons (substring text\
    \ (length text) 2))]\n    [(equal? (first text) 'o)\n     (cons (substring text\
    \ (length text) 2))]\n    [(equal? (first text) 'u)\n     (cons (substring text\
    \ (length text) 2))]\n    [(equal? (first text) 'y)\n     (cons (substring text\
    \ (length text) 2))]\n    [else\n     (cons (first text))]\n    )\n  )\n", " \
    \ (loop\n     for vowel 'aAiIoOuU\n     for char 'aAiIoOuU\n     for str '()\n\
    \     for index 0\n     while char\n     for c in\n     (loop while char\n   \
    \        for i in\n           (range 0 text.length)\n           do (set! str (cons\
    \ char str))\n           (set! index (+ index 1))\n           (cond\n        \
    \     ((char=? char vowel) (set! index (+ index 1)))\n             ((char=? (car\
    \ str) char) (set! index (+ index 1)))\n             ((< index 0) (set! index\
    \ (- index 1)))\n             ((char=? (car str) (car str)) (set! str (cdr str)))\n\
    \             else '()\n           )\n         )\n     for i in\n     (range (length\
    \ text) index)\n     do (set! str (cons (car str) str))\n     finally (return\
    \ (cons (reverse str))))\n  )\n", "  (cond\n    [(empty? text) \"\"]\n    [(match\
    \ (regexp-opt '[aeiouy])\n             text\n             (string= text 'a)\n\
    \             #t)\n     (concat \"\" (substring (string text) 0 (string-length\
    \ text)))]\n    [else (concat \"\" text)]))\n", "  (cond\n    [(empty? text)\n\
    \     '']\n    [(not (member? (car text) 'aAeEiIoOuU'))\n     (cons (car text)\
    \ (remove_vowels (cdr text)))]\n    [else\n     (cons (car text)\n           (remove_vowels\
    \ (cdr text)))]))\n</cell>\n<code language=racket-language>\n#lang racket\n",
  "  (let ([vowels 'aeiouy])\n    (cond\n      [(empty? text) \"\"]\n      [(member\
    \ #\\a (first text)) (substring text 0 (- (length text) 1))]\n      [(member #\\\
    b (first text)) (substring text 1 (- (length text) 1))]\n      [(member #\\c (first\
    \ text)) (substring text 2 (- (length text) 1))]\n      [(member #\\d1 (first\
    \ text)) (substring text 1 (- (length text) 1))]\n      [(member #\\d (first text))\
    \ (substring text 2 (- (length text) 1))]\n      [(member #\\e (first text)) (substring\
    \ text 3 (- (length text) 1))]\n      [(member #\\f (first text)) (substring text\
    \ 4 (- (length text) 1))]\n      [(member #\\g (first text)) (substring text 4\
    \ (- (length text) 1))]\n      [(member #\\h (first text)) (substring text 4 (-\
    \ (length text) 1))]\n      [(member #\\i (first text)) (substring text 4 (- (length\
    \ text) 1))]\n      [(member #\\j (first text)) (substring text 4 (- (length text)\
    \ 1))]\n      [(member #\\k (first text)) (substring text 4 (- (length text) 1))]\n\
    \      [(member #\\l (first text)) (substring text 4 (- (length text) 1))]\n \
    \     [(member #\\m (first text)) (substring text 4 (- (length text) 1))]\n  \
    \    [(member #\\n (first text)) (substring text 4 (- (length text) 1))]\n   \
    \   [(member #\\o (first text)) (substring text 4 (- (length text) 1))]\n    \
    \  [(member #\\p (first text)) (substring text 4 (- (length text) 1))]\n     \
    \ [(member #\\q (first text)) (substring text 4 (- (length text) 1))]\n      [(member\
    \ #\\r (first text)) (substring text 4 (- (length text) 1))]\n      [(member #\\\
    s (first text)) (substring text 4 (- (length text) 1))]\n      [(member #\\t (first\
    \ text)) (substring text 4 (- (length text) 1))]\n      [(member #\\u (first text))\
    \ (substring text 4 (- (length text) 1))]\n      ", "  (define (vovels str)\n\
    \    (cond ((empty? str) \"\")\n          ((equal? (first (rest str)) #\\a) \"\
    \")\n          ((equal? (first (rest str)) #\\b) \"\")\n          ((equal? (first\
    \ (rest str)) #\\c) \"\")\n          ((equal? (first (rest str)) #\\d) \"\")\n\
    \          ((equal? (first (rest str)) #\\e) \"\")\n          ((equal? (first\
    \ (rest str)) #\\F) \"\")\n          ((equal? (first (rest str)) #\\G) \"\")\n\
    \          ((equal? (first (rest str)) #\\h) \"\")\n          ((equal? (first\
    \ (rest str)) #\\i) \"\")\n          ((equal? (first (rest str)) #\\j) \"\")\n\
    \          ((equal? (first (rest str)) #\\k) \"\")\n          ((equal? (first\
    \ (rest str)) #\\l) \"\")\n          ((equal? (first (rest str)) #\\m) \"\")\n\
    \          ((equal? (first (rest str)) #\\n) \"\")\n          ((equal? (first\
    \ (rest str)) #\\o) \"\")\n          ((equal? (first (rest str)) #\\p) \"\")\n\
    \          ((equal? (first (rest str)) #\\q) \"\")\n          ((equal? (first\
    \ (rest str)) #\\r) \"\")\n          ((equal? (first (rest str)) #\\s) \"\")\n\
    \          ((equal? (first (rest str)) #\\t) \"\")\n          ((equal? (first\
    \ (rest str)) #\\v) \"\")\n          ((equal? (first (rest str)) #\\w) \"\")\n\
    \          ((equal? (first (rest str)) #\\X) \"\")\n          ((equal? (first\
    \ (rest str)) #\\Y) \"\")\n          ((equal? (first (rest str)) #\\Z) \"\")\n\
    \          (else\n           (cons (first (rest str)) (vovels (rest (rest str)))))))\n\
    \  (vovels text))\n", "  (cond [(empty? text) text]\n        [(memb (first text)\
    \ 'aeiouAEIOU) (rest text)]\n        [(member 'a text) (substring text 0 1)]\n\
    \        [else (substring text 0 -1)]))\n", "  (cond\n    [(empty? text) \"\"\
    ]\n    [(member? (char->string 'a) (char->string text))\n     (string-append (string-remove\
    \ 'a text) (string-remove 'a text))\n    ]\n    [(member? (char->string 'e) (char->string\
    \ text))\n     (string-append (string-remove 'e text) (string-remove 'e text))\n\
    \    ]\n    [(member? (char->string 'i) (char->string text))\n     (string-append\
    \ (string-remove 'i text) (string-remove 'i text))\n    ]\n    [(member? (char->string\
    \ 'o) (char->string text))\n     (string-append (string-remove 'o text) (string-remove\
    \ 'o text))\n    ]\n    [(member? (char->string 'u) (char->string text))\n   \
    \  (string-append (string-remove 'u text) (string-remove 'u text))\n    ]\n  \
    \  [else text]\n  )\n)\n", "  (reverse\n   (string->list\n    (remove\n     (map\
    \ string-not\n         (filter\n          (lambda (char)\n            (char->integer\n\
    \             (char->string char)))\n         (string->list text))\n      '(1\
    \ 2 3 4 5 6 7 8 9 0 a b c d e f g h i j k l m n o p q r s t u v w x y z))))) ;;#lang\
    \ racket", "  (cond\n    [(string? text)\n     (cond\n       [(string=? (string\
    \ text) 'a)\n        (cdr (remove (string-match 'a' text) (list 'b 'c)))]\n  \
    \     [(string=? (string text) 'e)\n        (cdr (remove (string-match 'e' text)\
    \ (list 'f 'g 'h)))]\n       [(string=? (string text) 'i)\n        (cdr (remove\
    \ (string-match 'i' text) (list 'j 'k 'l)))]\n       [(string=? (string text)\
    \ 'o)\n        (cdr (remove (string-match 'o' text) (list 'm 'n 'p)))]\n     \
    \  [(string=? (string text) 'u)\n        (cdr (remove (string-match 'u' text)\
    \ (list 'q 'r 's 't)))]\n       [(string=? (string text) 'y)\n        (cdr (remove\
    \ (string-match 'y' text) (list 'z))))]\n    [(string? \"\")\n     \"\"]\n   \
    \ [else\n     (cond\n       [(string=? (string text) 'a)\n        (remove (string-match\
    \ 'a' text) (list 'b 'c))])]\n    [else\n     (cond\n       [(string=? (string\
    \ text) 'e)\n        (remove (string-match 'e' text) (list 'f 'g 'h))])]\n   \
    \ [else\n     (cond\n       [(string=? (string text) 'i)\n        (remove (string-match\
    \ 'i' text) (list 'j 'k 'l))])]\n    [else\n     (cond\n       [(string=? (string\
    \ text) 'o)\n        (remove (string-match 'o' text) (list 'm 'n 'p))])]\n   \
    \ [else\n     (cond\n       [(string=? (string text) 'u)\n        (remove (string-match\
    \ 'u' text) (list 'q 'r 's 't))])]\n    [else\n     (cond\n       [(string=? (string\
    \ text) 'y)\n        (remove (string-match 'y' text) (list 'z))])]\n    [else\n\
    \     (cond\n       [(string=? (string text) 'z) \"\"]\n       [else\n       \
    \ (remove (string-match 'z' text) (list 'a))))]))\n", "  (cond [(string? text)\n\
    \         (remove-if #(cond [(string? %)\n                             (not (string=?\
    \ #(A E I O U) (string-ref % 1)))]\n                         [(string? %)\n  \
    \                           (not (string=? #(B C D F) (string-ref % 1)))]))\n\
    \         (string text)]\n        [else (error \"Wrong type\" text)]))\n", " \
    \ (cond\n    ((null? text)\n     text)\n    ((string=? (char-code (car text))\
    \ (char #\\a)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\e)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\i)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\o)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\u)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\A)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\E)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\I)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\O)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\U)) (remove-vowels (cdr text)))\n    ((string=? (char-code (car text))\
    \ (char #\\z)) (remove-vowels (cdr text)))\n    (else (cons (char-code (car text))\
    \ (remove-vowels (cdr text))))))\n", "  (cond\n    [(empty? text) empty]\n   \
    \ [(equal? (char->string (car text))\n              (string->char 'a' \"aeiou\"\
    ))\n     (remove_vowels (cdr text))\n     ])\n  )\n", "  (match text\n    ((string\
    \ \"\") (string \"\"))\n    ((string x) \n     (let ([y (string-map string #(if\
    \ (char=? (char x) (car %)) #\\c #\\v))])\n       (string-map string #(if (string=?\
    \ (append y (car %)) (car %)) #\\c #\\v)) ))))\n", "  (cond\n    [(empty? text)\
    \ \"\"]\n    [(equal? (first text) 'a) (remove_vowels (rest text))]\n    [(equal?\
    \ (first text) 'e) (remove_vowels (rest text))]\n    [(equal? (first text) 'i)\
    \ (remove_vowels (rest text))]\n    [(equal? (first text) 'o) (remove_vowels (rest\
    \ text))]\n    [(equal? (first text) 'u) (remove_vowels (rest text))]))\n", " \
    \ (string/replace (remove-if #(and (char=? (first %) 'A) (char=? (second %) 'a'))\n\
    \                        text\n                        :start1 0\n           \
    \             :end1 (string-length text))\n                  #\\A ''\n       \
    \           #\\e ''))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first\
    \ text) 'a) (append (first text) (second text))]\n    [(equal? (first text) 'e)\
    \ (append (first text) (second text))]\n    [(equal? (first text) 'i) (append\
    \ (first text) (second text))]\n    [(equal? (first text) 'o) (append (first text)\
    \ (second text))]\n    [(equal? (first text) 'u) (append (first text) (second\
    \ text))]\n    [(equal? (first text) 'A) (append (first text) (second text))]\n\
    \    [(equal? (first text) 'E) (append (first text) (second text))]\n    [(equal?\
    \ (first text) 'I) (append (first text) (second text))]\n    [(equal? (first text)\
    \ 'O) (append (first text) (second text))]\n    [(equal? (first text) 'U) (append\
    \ (first text) (second text))]\n    [else (append (first text) (second text))]))\n",
  "  (if (empty? text)\n      ''\n      (let ((letter (car text)))\n        (if (vowel?\
    \ letter)\n            (if (equal? (car text) (car (cdr text)))\n            \
    \    (remove_vowels (cdr text))\n                (cons (car text) (remove_vowels\
    \ (cdr text))))\n            (cons (car text) (remove_vowels (cdr text))))))))\n",
  "  (cond\n    [(empty? text) empty]\n    [(eq? (first text) 'a) (remove-vowels (rest\
    \ text))] \n    [(eq? (first text) 'e) (remove-vowels (rest text))]\n    [(eq?\
    \ (first text) 'i) (remove-vowels (rest text))]\n    [(eq? (first text) 'o) (remove-vowels\
    \ (rest text))]\n    [(eq? (first text) 'u') (remove-vowels (rest text))]\n  \
    \  [(eq? (first text) 'A') (remove-vowels (rest text))]\n    [(eq? (first text)\
    \ 'E') (remove-vowels (rest text))]\n    [(eq? (first text) 'I') (remove-vowels\
    \ (rest text))]\n    [(eq? (first text) 'O') (remove-vowels (rest text))]\n  \
    \  [(eq? (first text) 'U') (remove-vowels (rest text))]\n    [else  (first text)\
    \ (remove-vowels (rest text))]))\n", "  (define vowels '(a e i o u))\n  (define\
    \ not-vowels '(a e i o u))\n  (define not-vowels-end (position text? not-vowels))\n\
    \  (define (loop-remove not-v not-v-end text)\n    (if (= not-v-end (length text))\n\
    \        text\n        (loop-remove (subseq text 0 not-v-end) not-v-end (subseq\
    \ text not-v-end text))))\n  (loop-remove not-vowels not-vowels-end text))\n",
  "  (cond\n    [(empty? text) empty]\n    [(equal? (first text) 'a) (remove-if (char->boolean\
    \ #\\a) #text 1)]\n    [(equal? (first text) 'e) (remove-if (char->boolean #\\\
    e) #text 1)]\n    [(equal? (first text) 'i) (remove-if (char->boolean #\\i) #text\
    \ 1)]\n    [(equal? (first text) 'o) (remove-if (char->boolean #\\o) #text 1)]\n\
    \    [(equal? (first text) 'u) (remove-if (char->boolean #\\u) #text 1)]\n   \
    \ [else (remove-if (char->boolean #\\y) #text 1)]\n  )\n)\n", "  (define (iter\
    \ char)\n    (if (char=? #\\a  (char=? #\\e  (char=? #\\i  (char=? #\\o (char=?\
    \ #\\u)))\n                       char=? #\\A  (char=? #\\E  (char=? #\\I  (char=?\
    \ #\\O (char=? #\\U)))\n                       char=? #\\z  (char=? #\\Z))))\n\
    \    (char-append char ')))\n  (iter (string->char (string->list text))))\n",
  "  (cond [(string? text) text]\n        [else (cons (string->list (string->string\
    \ text))\n                   (remove-if string=? #{\\aA \\e \\i \\o \\u \\x} {string->string\
    \ text})\n                   (remove-if string=? #{\\e i o u} {string->string\
    \ text}))]))\n", "  (cond\n    [(empty? text)\n      empty]\n    [(and (char->integer?\
    \ (first text)) (char->integer? (first text)))\n      (reverse (cons (first text)\
    \ (remove_vowels (rest text))))]\n    [else\n      (reverse (cons (first text)\
    \ (remove_vowels (rest text))))]))\n", "  (cond\n    [(empty? text) empty]\n \
    \   [(equal? (first text) #\\a) empty]\n    [(equal? (first text) #\\e) empty]\n\
    \    [(equal? (first text) #\\i) empty]\n    [(equal? (first text) #\\o) empty]\n\
    \    [else (cons (first text) (remove_vowels (rest text)))]))\n", "  (cond\n \
    \   [(empty? text) text]\n    [(equal text\n        'a) '']\n    [(equal text\n\
    \        'z) '']\n    [(equal text\n        'A) '']\n    [(equal text\n      \
    \  'Z) '']\n    [(equal text\n        '0) '']\n    [(equal text\n        '1) '']\n\
    \    [else (cond\n             [(not (member 'a text))\n              (cond\n\
    \               [(not (member 'A text))\n                (cond\n             \
    \    [(not (member '0 text))\n                  (cond\n                   [(not\
    \ (member '1 text))\n                    (cond\n                     [(not (member\
    \ '2 text))\n                      (cond\n                       [(not (member\
    \ '3 text))\n                        (cond\n                         [(not (member\
    \ '4 text))\n                          (cond\n                           [(not\
    \ (member '5 text))\n                             (cond\n                    \
    \          [(not (member '6 text))\n                               (cond\n   \
    \                             [(not (member '7 text))\n                      \
    \           (cond\n                                 [(not (member '8 text))\n\
    \                                  (cond\n                                   [(not\
    \ (member '9 text))\n                                    text])])])])])])])])]))]))]))))\n",
  "  (define (iter text acc)\n    (if (char=? (car text) 'a' 'e' 'i' 'o' 'u')\n  \
    \      (iter (cdr text) (car acc))\n        (iter (cdr text) acc)))\n  (iter text\
    \ text))\n", "  (cond\n    [(empty? text) \"\"]\n    [(string-include? 'a text)\
    \ \"\"]\n    [(string-include? 'e text) \"\"]\n    [(string-include? 'i text)\
    \ \"\"]\n    [(string-include? 'o text) \"\"]\n    [(string-include? 'u text)\
    \ \"\"]\n    [(empty? (string-append text 'b')) (string-append text 'b')]\n  \
    \  [(empty? (string-append text 'a')) (string-append text 'a')]\n    [(empty?\
    \ (string-append text 'o')) (string-append text 'o')]\n    [(empty? (string-append\
    \ text 'u')) (string-append text 'u')]\n    [(string-include? 'd text) \"\"]\n\
    \    [(string-include? 'l text) \"\"]\n    [(string-include? 'o text) \"\"]\n\
    \    [(string-include? 's text) \"\"]\n    [(string-include? 'y text) \"\"]\n\
    \    [(string-include? 'z text) \"\"]\n    [(string-include? 'x text) \"\"]\n\
    \    [(string-include? 'c text) \"\"]\n    [(string-include? 'n text) \"\"]\n\
    \    [(string-include? 'm text) \"\"]\n    [(string-include? 'g text) \"\"]\n\
    \    [(string-include? 't text) \"\"]\n    [(string-include? 'd text) \"\"]\n\
    \    [(string-include? 'l text) \"\"]\n    [(string-include? 'o text) \"\"]\n\
    \    [(string-include? 's text) \"\"]\n    [(string-include? 'y text) \"\"]\n\
    \    [(string-include? 'z text) \"\"]\n    [(string-include? 'x text) \"\"]\n\
    \    [(string-include? 'c text) \"\"]\n    [(string-include? 'n text) \"\"]\n\
    \    [(string-include? 'm text) \"\"]\n    [(string-include? 'g text) \"\"]\n\
    \    [(string-include? 't text) \"\"]\n    [(string-include? 'd text) \"\"]\n\
    \    [(string-include? 'l text) \"\"]\n    [(string-include? 'o text) \"\"]\n\
    \    [(string-include? 's text) \"\"]\n    [(string-include? 'y text) \"\"]\n\
    \    [(string-include? 'z text) \"\"]\n    [(string-include? 'x text) \"\"]\n\
    \    [(string-include? 'c text) \"\"]\n    [(string-include? 'n text) \"\"]\n\
    \    [(string-include", "  (let ([vowels '(a-z)]) ; a is a vowel by default\n\
    \    (let ([result '()])\n      (map (lambda (c)\n             (if (not (member\
    \ c vowels))\n                 (append result (list c))\n                 result))\n\
    \           text))\n    (append result '())))\n", "  (cond [(= text \"\") \"\"\
    ]\n        [(member (car text) 'aeiouAEIOU) (cdr text)]\n        [else (cons (car\
    \ text) (remove_vowels (cdr text)))]))\n", "  (cond\n    [(empty? text) \"\"]\n\
    \    [(member #\\aa text) (substring text 1)]\n    [(member #\\e text) (substring\
    \ text 2)]\n    [(member #\\i text) (substring text 1)]\n    [(member #\\o text)\
    \ (substring text 2)]\n    [(member #\\u text) (substring text 1)]\n    [else\
    \ (substring text 0)]))\n", "  (cond\n    ((empty? text) text)\n    ((equal? (first\
    \ text) 'a) (remove 'a text))\n    ((equal? (first text) 'e) (remove 'e text))\n\
    \    ((equal? (first text) 'i) (remove 'i text))\n    ((equal? (first text) 'o)\
    \ (remove 'o text))\n    ((equal? (first text) 'u) (remove 'u text))\n    (else\
    \ text)))\n", "  (if (empty? text)\n      '\n      (if (equal? (first text) 'a)\n\
    \          (second text)\n          (if (equal? (first text) 'e)\n           \
    \   (second text)\n              (if (equal? (first text) 'i)\n              \
    \    (second text)\n                  (if (equal? (first text) 'o) \n        \
    \              (second text)\n                      (if (equal? (first text) 'u)\n\
    \                          (second text)\n                          (if (equal?\
    \ (first text) 'y)\n                              (second text)\n            \
    \                  (if (equal? (first text) 'a) \n                           \
    \       (second text)\n                                  (if (equal? (first text)\
    \ 'e) \n                                      (second text)\n                \
    \                      (if (equal? (first text) 'i) \n                       \
    \                   (second text)\n                                          (if\
    \ (equal? (first text) 'o) \n                                              (second\
    \ text)\n                                              (if (equal? (first text)\
    \ 'u) \n                                                  (second text)\n    \
    \                                              (if (equal? (first text) 'y)\n\
    \                                                      (second text)\n       \
    \                                               'z)))))))))))))\n", "  (let ([vowels\
    \ '(a e i o u)] #(list a e i o u))\n    (filter (lambda (c)\n              (or\
    \ (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\\
    u)))\n            text))\n    (lambda ())))\n", "  (cond\n    ((= text '') text)\n\
    \    ((equal? (char text 0) #\\a) '')\n    ((equal? (char text 0) #\\b) '')\n\
    \    ((equal? (char text 0) #\\c) '')\n    ((equal? (char text 0) #\\d) '')\n\
    \    ((equal? (char text 0) #\\e) '')\n    ((equal? (char text 0) #\\F) '')\n\
    \    ((equal? (char text 0) #\\n) '')\n    ((equal? (char text 0) #\\o) '')\n\
    \    ((equal? (char text 0) #\\p) '')\n    ((equal? (char text 0) #\\s) '')\n\
    \    ((equal? (char text 0) #\\t) '')\n    ((equal? (char text 0) #\\v) '')\n\
    \    ((equal? (char text 0) #\\A) '')\n    ((equal? (char text 0) #\\B) '')\n\
    \    ((equal? (char text 0) #\\C) '')\n    ((equal? (char text 0) #\\D) '')\n\
    \    ((equal? (char text 0) #\\E) '')\n    ((equal? (char text 0) #\\F) '')\n\
    \    ((equal? (char text 0) #\\n) '')\n    ((equal? (char text 0) #\\o) '')\n\
    \    ((equal? (char text 0) #\\p) '')\n    ((equal? (char text 0) #\\s) '')\n\
    \    ((equal? (char text 0) #\\t) '')\n    ((equal? (char text 0) #\\v) '')\n\
    \    ((equal? (char text 0) #\\A) '')\n    ((equal? (char text 0) #\\B) '')\n\
    \    ((equal? (char text 0) #\\C) '')\n    ((equal? (char text 0) #\\D) '')\n\
    \    ((equal? (char text 0) #\\E) '')\n    ((equal? (char text 0) #\\F) '')\n\
    \    ((equal? (char text 0) #\\n) '')\n    ((equal? (char text 0) #\\o) '')\n\
    \    ((equal? (char text 0) #\\p) '')\n    ((equal? (char text 0) #\\s) '')\n\
    \    ((equal? (char text 0) #\\t) '')\n    ((equal? (char text 0) #\\v) '')\n\
    \    ((equal? (char text 0) #\\A) '')\n    ((equal? (char text 0) #\\B) '')\n\
    \    ((equal? (char text 0) #\\C) '')\n    ((equal? (char text 0) #\\D", "  (if\
    \ (empty? text) \n      text\n      (if (member (first text) 'aeiouAEIOU)\n  \
    \        (cons (first text) (remove_vowels (rest text)))\n          (cons (first\
    \ text) (remove_vowels (rest text)))))) ; <-- here is the error\n</code>\n<|/\
    \ a tags=scheme,racket dscore=0 |>\n<| c |>\nHi John Wang, thank you for helping\
    \ me understand this problem - I've got another question about this same code\
    \ that I'll post as a separate question if you don't mind?\n<|/ c |>\n<| c |>\n\
    I posted a new question here: http://stackoverflow.com/questions/33091543/scheme-program-to-remove-vowels-from-string\n\
    <|/ c |>\n<| a dscore=0 |>\nThe problem is with the second cond. You want to return\
    \ a list of characters, not a single one. \nWhat you do is: cons (first text)\
    \ (remove_vowels (rest text)) which means you create a list with the first and\
    \ second element of the list. Then in the else clause, you return that list as\
    \ second element of the list returned by the function.\nA solution could be:\n\
    <code>", "  (cond\n    [(empty? text) text]\n    [(equal? (first text) 'a) (if\
    \ (equal? (first text) 'A) (second text) (first text))] \n    [(equal? (first\
    \ text) 'e) (if (equal? (first text) 'E) (second text) (first text))] \n    [(equal?\
    \ (first text) 'i) (if (equal? (first text) 'I) (second text) (first text))] \n\
    \    [(equal? (first text) 'o) (if (equal? (first text) 'O) (second text) (first\
    \ text))] \n    [(equal? (first text) 'u') (if (equal? (first text) 'U) (second\
    \ text) (first text))] \n    [(equal? (first text) 'y) (if (equal? (first text)\
    \ 'Y) (second text) (first text))] \n    [else (append (remove_vowels (rest text))\n\
    \                (first text))]))\n", "  (cond\n    [(empty? text)\n     empty]\n\
    \    [(equal? (first text) #\\a)\n     empty]\n    [(equal? (first text) #\\e)\n\
    \     empty]\n    [(equal? (first text) #\\i)\n     empty]\n    [(equal? (first\
    \ text) #\\o)\n     empty]\n    [(equal? (first text) #\\u)\n     (substring (remove-if\
    \ #(equal? (first %) #\\a) #\\a text))]\n    [else\n     (substring (remove-if\
    \ #(equal? (first %) #\\a) #\\a text))]))\n", "  (cond\n    [(empty? text) text]\n\
    \    [(contains? #\\a (first text)) (remove_vowels (rest text))] \n    [else (cons\
    \ (first text) (remove_vowels (rest text))) ]))\n", "  (cond\n    [(string-empty?\
    \ text) text]\n    [(equal? (char-at (first text)) #\\a) (substring (first text)\
    \ 2 3)]\n    [(equal? (char-at (first text)) #\\e) (substring (first text) 2 2)]\n\
    \    [(equal? (char-at (first text)) #\\i) (substring (first text) 2 2)]\n   \
    \ [(equal? (char-at (first text)) #\\o) (substring (first text) 2 2)]\n    [(equal?\
    \ (char-at (first text)) #\\u) (substring (first text) 2 3)]\n    [else (cons\
    \ (first text) (remove_vowels (rest text)))]\n  ))\n</code>\nTo remove all vowels,\
    \ you can use\n<code>", "  (let ((vowels '(a e i o u)))\n    (cond\n      [(empty?\
    \ text) text]\n      [(contains? vowels (car text)) (remove-if (lambda (x) (member\
    \ x vowels)) text)]\n      [else (cons (car text) (remove_vowels (cdr text)))\
    \ ])))\n", "  (cond ((= (length text) 0)\n         '())\n        ((string=? (caar\
    \ text) #\\a)(string-append (string (car text)) \n                           \
    \                (remove-vowels (cdr text))\n                                \
    \           ))\n        (else (string-append (string (car text)) \n          \
    \                     (remove-vowels (cdr text))\n                           \
    \    (remove-vowels (cdr text))\n                               ))\n        )\n\
    \    )\n)\n", "  (cond [(empty? text) empty]\n        [else (append (filter (lambda\
    \ (x) (equal? (car x) 'a) (remove-vowels (cdr text))) '(A B C D E F G H I J K\
    \ L M N O P Q R S T U V W X Y Z)) (remove_vowels (cdr text))]))) \n", "  (cond\n\
    \    [(empty? text) \"\"]\n    [(member (car text) '(') (cdr text))\n     (remove_vowels\
    \ (cdr text))]\n    [else (cons (car text)\n              (remove_vowels (cdr\
    \ text)))]))\n", "  (let loop ((text text)\n             (i 0)\n             (str\
    \ '()))\n    (if (char=? text #\\a)\n        str\n        (loop (substring text\
    \ i 1)\n             (+ i 1)\n             (cons text str)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
