name: HumanEval_7_filter_by_substring
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that contain\
  \ given substring\n;; >>> filter_by_substring([], 'a')\n;; []\n;; >>> filter_by_substring(['abc',\
  \ 'bacd', 'cde', 'array'], 'a')\n;; ['abc', 'bacd', 'array']\n(define (filter_by_substring\
  \ strings substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n    (check-equal? (candidate (list \"xxx\" \"asd\"\
  \ \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"\
  xxxAAA\" \"xxx\"))\n    (check-equal? (candidate (list \"grunt\" \"trumpet\" \"\
  prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\"))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    ((null? strings) strings)\n    ((equal? (car strings)\
    \ substring) (strings))\n    (else (cons (car strings) (filter_by_substring (filter_by_substring\
    \ (cdr strings) substring) substring)))\n  ))\n", "  (cond (empty? strings) empty\
    \ \n        (equal? (car strings) substring) (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring))\n        (else (filter_by_substring (filter_by_substring\
    \ strings (cdr strings)) (substring (car strings))))))\n", "  (filter (lambda\
    \ (x) (string=? x substring)) strings))\n", "  (cond\n    [(string? strings) (filter\
    \ strings (lambda (str) (member substring str)))]\n    [else strings]))\n", " \
    \ (if (null? strings)\n      '()\n      (append (filter_by_substring (substring\
    \ strings) (car strings)) (list (car strings)))))\n", "  (if (null? strings) strings\n\
    \      (let ([found (null? (find substring strings))])\n        (if (not found)\
    \ strings\n            (filter_by_substring (filter (lambda (x) (not (string-contains\
    \ x substring))) strings) substring)))))\n", "  (define (internal acc string)\n\
    \    (cond [(empty? string) (reverse acc)]\n          [(string=? substring string)\
    \ (cons string acc)]\n          [else (internal acc (string/tail string))]))\n\
    \  (internal '() (first strings)))\n", "  (cond [(empty? strings) strings]\n \
    \       [(substring? (first strings)) (cons (first strings) (filter_by_substring\
    \ (subseq strings (+ 0 (length strings))) substring))]\n        [else (filter_by_substring\
    \ (subseq strings (+ 0 (length strings))) substring)]))\n", "  (filter (\u03BB\
    \ (string) (member substring string)) strings))\n</code>\n<|/ a dscore=2 tags=scheme,functional-programming,racket,list\
    \ |>\n<| c |>\n`filter` was introduced in R6RS Scheme so if you're using Scheme\
    \ you may as well use Racket directly.\n<|/ c |>\n<| c |>\nI did actually know\
    \ that, but I wasn't aware of how to do this using Racket - I've learnt a lot\
    \ - thanks for your help - it's working great now\n<|/ c |>\n<| c |>\nThe original\
    \ answer doesn't use `filter` but `remove-if`, which I believe is unavailable\
    \ in R6RS Scheme. `filter` is part of R5RS.\n<|/ c |>\n<| c |>\n`remove-if` is\
    \ from `SRFI-137`, which is part of the R5RS specification, so I thought that\
    \ it would be available in R5RS. The [SRFI-139](http://www.scheme.com/tspl4/srfi-139.htm)\
    \ specification seems to indicate that it is.\n<|/ c |>\n<| c |>\nAh yes, it does,\
    \ as [R7RS also introduces it](http://www.scheme.com/tspl4/srfi-139.htm).\n<|/\
    \ c |>\n<| a tags=scheme,functional-programming,racket,list dscore=1 |>\nScheme\
    \ has remove-if which you can easily adapt from the example code in the R5RS Reference\
    \ Manual.\n<code>", "  (cond [(empty? strings) strings]\n        [(equal? (car\
    \ strings) substring) (rest strings)]\n        [else (cons (car strings)\n   \
    \                 (filter_by_substring (filter_by_substring (tail strings) substring)\
    \ substring))]))\n", "  (cond\n    ((null? strings) strings)\n    ((member? (string-ref\
    \ strings (length (string-match (string-ref strings substring)) 0)) substring)\
    \ (string-append (string-ref strings (length (string-match (string-ref strings\
    \ substring)) 0)) substring))\n    (else (filter_by_substring (filter_by_substring\
    \ (string-append (string-ref strings (length (string-match (string-ref strings\
    \ substring)) 0)) substring) (string-ref strings (length (string-match (string-ref\
    \ strings substring)) 0)) ))\n  )\n)\n", "  (filter (lambda (x) (string-contains\
    \ x substring)) strings))\n", "  (cond\n    [(string? (car strings)) (cons (car\
    \ strings) (filter_by_substring (rest strings) substring))\n     (filter_by_substring(rest\
    \ strings) substring)]\n    [else (filter_by_substring strings (string-append\
    \ substring (string-join (car strings))))]))\n", "  (map (\u03BB (string) (if\
    \ (string-contains? string substring) string '())))\n  (strings))\n", "  (cond\
    \ [(empty? strings) strings]\n        [else (string-equal? (string-ref strings\
    \ 0) substring)\n               (filter_by_substring (substring strings)\n   \
    \                              ' (string-equal? (string-ref strings 0) substring))]\n\
    \        ))\n", "  (cond\n    [(null? strings) strings]\n    [(member? (first\
    \ strings) substring) (strings (filter_by_substring (rest strings) substring))]))\n",
  "  (define (inner-loop i acc)\n    (cond ((null? strings) acc)\n          ((equal?\
    \ (substring (car strings)) substring) (inner-loop (cdr strings) (cons (car strings)\
    \ acc)))\n          (else (inner-loop (cdr strings) acc))\n          ))\n  (inner-loop\
    \ 0 '()))\n", "  (map (\u03BB (s)\n         (cond\n           ((string=? s substring)\
    \ s)\n           ((boolean=? (string-index s substring) 0)\n            (cond\
    \ ((empty? s) (string-append s \"*\"))\n                   (else (string-append\
    \ s substring))))))\n       strings))\n", "  (define (helper lst string i found)\n\
    \    (cond\n      [(empty? lst) found]\n      [else (helper (cdr lst) string\n\
    \                   (+ (length string) i)\n                   (not (substring\
    \ string i)))]))\n  (let loop ((lst strings) (string substring) (i 0))\n    (if\
    \ (null? lst)\n        found\n        (loop (cdr lst) string\n             (+\
    \ i 1)))))\n</code>\nI haven't tested the above, so there might be typos or bugs\
    \ in there. Also, it can be simplified a lot.\n<|/ a |>\n<| c |>\nThanks for the\
    \ solution and for explaining the algorithm to me. It makes it much clearer for\
    \ me to understand why my code wasn't working properly. :)\n<|/ c |>\n<| a tags=racket,scheme\
    \ dscore=0 |>\nI figured out how to do it in Racket using filter function. Basically\
    \ I used the predicate 'contains?' and used filter to filter the list based on\
    \ the 'contains? ' predicate. Here's the code:\n<code>", "  (filter strings?\n\
    \          (lambda (s)\n            (string=? s substring))))\n</code>\n<|/ a\
    \ tags=filter,racket,substring |>\n<| a |>\nJust to show a recursive solution:\n\
    <code>\n#lang racket\n", "  (map (\u03BB (string) (let ((idx (string-index-of\
    \ string substring))\n                            (substring (substring string\
    \ 0 idx))\n                            (rest (substring string idx #+string)))\n\
    \                  (cond ((< idx 0) string\n                         (else (string-append\
    \ (substring string 0 idx) rest)))))\n       strings))\n", "  (cond\n    [(string-equal\
    \ strings substring) strings]\n    [else (cons (first strings)\n             \
    \   (filter_by_substring (drop (second strings) 1)\n                         \
    \        substring))]\n    ))\n", "  (map (lambda (s) (if (string=? s substring)\
    \ s))\n       strings))\n</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n\
    <h4 id=\"_the_two_different_ways_to_run_your_program\">The two different ways\
    \ to run your program</h4>\n<div class=\"paragraph\">\n<p>The two ways to run\
    \ your program are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Using an\
    \ editor that supports running your program and typing in the program</p>\n</li>\n\
    <li>\n<p>Using an editor that does not support running your program but has a\
    \ console available.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>These\
    \ editors allow you to use either of the following commands:</p>\n</div>\n<div\
    \ class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>run</code></dt>\n<dd>\n\
    <p>Run the program and wait for it to complete.</p>\n</dd>\n<dt class=\"hdlist1\"\
    ><code>run</code> <code>&lt;program&gt;</code></dt>\n<dd>\n<p>Run the program\
    \ and wait for it to complete.</p>\n</dd>\n<dt class=\"hdlist1\"><code>run</code>\
    \ <code>&lt;options&gt; <code>&lt;program&gt;</code></dt>\n<dd>\n<p>Run the program\
    \ and wait for it to complete.</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\"\
    >\n<p>The <code>&lt;options&gt;</code> are as follows:</p>\n</div>\n<div class=\"\
    dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>--interactive</code></dt>\n<dd>\n\
    <p>When you run an interactive program, the program is run in\ninteractive mode.\
    \ Normally, in non-interactive mode, an editor will\nnot allow the user to write\
    \ to the output or to read from the\ninput. Use this option to make the program\
    \ interactive.</p>\n</dd>\n<dt class=\"hdlist1\"><code>-i, --interactive-mode=&lt;mode&gt;</code></dt>\n\
    <dd>\n<p>When you run an interactive program, the program is run in\ninteractive\
    \ mode. Normally, in non-interactive mode, an editor will\nnot allow the user\
    \ to write to the output or to read from the\ninput. Use this option to make the\
    \ program interactive.</p>\n</dd>\n<dt class=\"hdlist1\"><code>--batch</code></dt>\n\
    <dd>\n<p>When you run an interactive program, the program is run in\nbatch mode.\
    \ Normally, in non-interactive mode, an editor will\nnot allow the user to write\
    \ to the output or to read from the\ninput. Use this option to make the program\
    \ interactive.</p>\n</dd>\n<dt class=\"hdlist1\"><code>-B, --batch-mode=&lt;mode&gt;</code></dt>\n\
    <dd>\n<p>When you run an interactive program, the program is run in\nbatch mode.\
    \ Normally, in non-interactive mode, an editor will\nnot allow the user to write\
    \ to the output or to read from the\ninput. Use this option", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(member (car strings) substring) (filter_by_substring\
    \ (cdr strings) substring)]\n    [else (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring))]\n  ))\n", "  (filter (lambda (str) (substring str\
    \ 0))\n          strings))\n", "  (cond\n    [(empty? strings) empty]\n    [(empty?\
    \ (rest strings)) strings]\n    [else (cons (first strings)\n                (filter_by_substring\
    \ (rest strings) substring))]\n   )\n  )", "  (filter (lambda (string)\n     \
    \       (or (equal? string (substring string)) (string-equal string substring)))\n\
    \          strings))\n", "  (let ([l (length strings)])\n    (lambda (n)\n   \
    \   (if (= n 0)\n          strings\n          (if (string-contains-substring (car\
    \ strings) substring)\n              (filter_by_substring (cdr strings) substring)\n\
    \              (cons (car strings) (filter_by_substring (cdr strings) substring)))))))\n",
  "  (filter (lambda (s)\n            (equal? (string-length s) (string-length substring)))\n\
    \          strings))\n", "  (filter (lambda (str) (find substring str)) strings))\n",
  "  (filter (\u03BB (x) (string-contains substring x)) strings))\n</code>\n<|/ a\
    \ tags=racket,string,string-matching,filter,list dscore=2 |>\n<| c |>\nThank you!\
    \ I was not expecting a solution so compact and efficient. Very well explained!\n\
    <|/ c |>\n<| c |>\nIf `filter_by_substring` was called `string-contains-substring`,\
    \ then this function would not be idiomatic Racket.\n<|/ c |>\n<| a tags=racket,string,string-matching,filter,list\
    \ |>\nUsing regex\n<code>\n#lang racket\n", "  (define (helper str found)\n  \
    \  (cond\n      [(empty? str) found]\n      [(equal? (first str) substring) (helper\
    \ (rest str) (cons (first str) found))]\n      [else (helper (rest str) (cons\
    \ (first str) found))]\n      )\n    )\n  (helper strings nil))\n", "  (map (fn\
    \ [[str index]]\n         (if (string=? str (substring index)) str null))\n  \
    \     (remove-if string=? substring strings)))\n", "  (cond [(empty? strings)\
    \ strings]\n        [(equal? (car strings) substring) (cons (car strings) (filter_by_substring\
    \ (filter_by_substring (cdr strings) substring) substring))]\n        [else (cons\
    \ (car strings) (filter_by_substring (cdr strings) substring))]))\n", "  (map\
    \ string->symbol (filter (lambda (s) (string-contains? s substring))\n       \
    \                           strings)))\n", "  (filter strings (lambda (str)\n\
    \                  (contains? (substring str) substring))))\n", "  (define (helper\
    \ strings substring result)\n    (cond\n      [(null? strings) result]\n     \
    \ [(string-equal? substring (first strings)) (helper (rest strings) substring\
    \ (cons (first strings) result))]\n      [(string-equal? (first strings) substring)\
    \ (helper (rest strings) substring (cons (first strings) result))]\n      [else\
    \ (helper (rest strings) substring (cons (first strings) result))]\n      )\n\
    \    )\n  (helper strings substring '()))\n</code>\n<|/ a dscore=3 tags=racket,scheme\
    \ |>\n<| c |>\nThis is great for strings, and I like how you handle them in a\
    \ recursive way. I think it would be good to note that this could be done with\
    \ only a single call to the string-match function; but then you would have to\
    \ write it in a way that returns the matching string, which is not necessarily\
    \ the case with this function.\n<|/ c |>\n<| c |>\nI like your solution too, I\
    \ really liked how you use an accumulator to build the result. I actually have\
    \ a problem with the accumulator: it doesn't seem to be in order of the input\
    \ list. Perhaps this is because I don't understand how it works. I guess what\
    \ happens is that it's just putting every element in the list as the result. That's\
    \ not really what I want to do.\n<|/ c |>\n<| c |>\nMy solution was designed so\
    \ that you wouldn't have to do anything to the accumulator if you wanted to do\
    \ that, but you're right that if you wanted to do the accumulator version you\
    \ would. You can get that result with `(list-ref (filter_by_substring strings\
    \ substring) 0)`.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere's how you could\
    \ do this with a single recursive call, and with no mutable state:\n<code>", " \
    \ (define (helper strings substring)\n    (cond\n      [(empty? strings) empty]\n\
    \      [(equal? (first strings) substring) (cons (first strings) strings)]\n \
    \     [else (helper (rest strings) substring)]\n      ))\n  (helper strings substring))\n\
    </code>\nThe same thing written in #lang racket.\n<code>", "  (define (helper\
    \ lst substr)\n    (cond ((null? lst) '())\n          ((string=? (car lst) substr)\
    \ (cdr lst))\n          (else (helper (cdr lst) substr))))\n  (helper strings\
    \ substring))\n", "  (define (iter remaining-strings candidate-string)\n    (cond\
    \ [(empty? remaining-strings)\n           candidate-string]\n          [(eqv?\
    \ substring\n                   (first candidate-string))\n           (iter (rest\
    \ remaining-strings)\n                   (rest candidate-string))]\n         \
    \ [else\n           (iter remaining-strings (cons candidate-string (first candidate-string)))]))\n\
    \  (iter strings empty))\n", "  (map \n   (\u03BB (string) (if (string-contains\
    \ string substring) string '#f)\n           )\n   strings))\n", "  (cond ((empty?\
    \ strings) '())\n        ((equal? (first strings) substring) (strings strings))\n\
    \        (else (append (filter_by_substring (filter_by_substring (first strings)\
    \ substring) (strings strings))\n                     (filter_by_substring (rest\
    \ strings) substring))))))\n", "  (cond [(empty? strings) strings]\n        [(member\
    \ (string-ref strings 0) substring) (string-append strings (list (string-ref strings\
    \ 0))\n                                                  (filter_by_substring\
    \ (string-ref strings 1) substring))]\n        [else (string-append strings (list\
    \ strings)\n                                                  (filter_by_substring\
    \ (string-ref strings 1) substring))]))\n", "  (cond\n    [(empty? strings) strings]\n\
    \    [(empty? substring) strings]\n    [else (cons (string->list substring)\n\
    \               (filter_by_substring (filter (string->list substring) strings)\n\
    \                                   (rest substring)))]))\n", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(equal? (car strings) substring) (filter_by_substring\
    \ (rest strings) substring)]\n    [else (cons (car strings)\n                (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (filter (lambda (s) (equal? (substring\
    \ s) (string-length s))) strings))\n  ;; ^ strings are strings of variable length\n\
    \  ;; => filter strings for strings containing substring\n  ;; => filter strings\
    \ for strings starting with the given substring\n  ;; => strings are strings of\
    \ variable length\n  ;; => strings are strings of variable length\n  )\n", " \
    \ (cond [(empty? strings) strings]\n        [(equal? substring \"\") strings]\n\
    \        [else (filter (lambda (x) (equal? (string-length x) (string-length substring)))\
    \ strings)]))\n", "  (map (lambda (str)\n         (cond\n          [(string=?\
    \ str substring) str]\n          [(string=? substring str) str]\n          [else\
    \ \"\"]))\n       strings))\n", "  (cond\n    ((null? strings) strings)\n    (else\
    \ (cons (string->list (string-match\n                                (string-ref\
    \ strings 0)\n                                substring))\n               (filter_by_substring\n\
    \                  (string-tail strings)\n                  substring))))\n)\n",
  "  (cond [(empty? strings) '()]\n        [(equal? (first strings) substring) (tail\
    \ strings)]\n        [else (cons (first strings)\n                    (filter_by_substring\
    \ (tail strings)\n                                   substring))]\n        ))\n",
  "  (cond\n    [(empty? strings) strings]\n    [(substring (string-ref (string-ref\
    \ strings 0) 0) (length substring)) (filter_by_substring (string-ref strings 0)\
    \ substring)]\n    [else (cons (string->symbol (string-upcase (string-ref strings\
    \ 0))) (filter_by_substring (string-ref strings 1) substring))]))\n", "  (filter\
    \ \n   (lambda (string) (contains-substring string substring))\n   strings))\n",
  "  (filter (lambda (el) (member el substring)) strings))\n", "  (filter substring\
    \ strings))\n", "  (map (lambda (x)\n         (if (string=? x substring) x))\n\
    \       strings))", "  (cond\n    ((empty? strings) strings)\n    ((equal? (car\
    \ strings) substring) strings)\n    (else (cons (car strings) (filter_by_substring\
    \ (filter (cdr strings) substring)))))\n)\n", "  (filter (lambda (str) (string-contains\
    \ str\n                                         (string-length substring)))\n\
    \          strings))\n", "  (cond [(empty? strings) strings]\n        [(equal?\
    \ substring (string-ref (string-ref (string-ref (string-first strings) 0) 0) 0))\
    \ (list-copy strings)]\n        [else (cons (string->list (string-ref (string-ref\
    \ (string-ref (string-first strings) 0) 0) 0) (filter_by_substring (list-copy\
    \ strings) substring)))))\n", "  (filter (lambda (s) (string-contains? s substring))\n\
    \          strings))\n", "  (filter (lambda (x)\n            (string=? x substring))\n\
    \          strings))\n", "  (filter (\u03BB (string) (contains-any substring string))\
    \ strings))\n", "  (cond [(empty? strings) strings]\n        [(equal? (first strings)\
    \ substring) strings]\n        [else (cons (first strings) (filter_by_substring\
    \ (filter_by_substring (rest strings) substring) substring))]))\n", "  (cond [(empty?\
    \ strings) strings]\n        [(equal? (car strings) substring) (cons (car strings)\
    \ (filter_by_substring (cdr strings) substring))]\n        [else (cons (car strings)\
    \ (filter_by_substring (cdr strings) substring))]))\n", "  (filter (lambda (str)\
    \ (equal? (substring str) (string-length substring))) strings))\n", "  (map (lambda\
    \ (str)\n         (when (string=? substring str)\n           str)))\n  strings)\n",
  "  (filter (lambda (string) (member string substring)) strings))\n</cell>\n<text>\n\
    Exercise: Write a function that takes a string and a predicate and returns the\
    \ list of strings in the same order as they were given except that the ones for\
    \ which the predicate returns true are removed.\n\n\n</text>\n<cell>", "  (filter\
    \ (lambda (x) (string=? x substring)) strings))\n", "  (cond [(empty? strings)\
    \ strings]\n        [(substring (string-ref (string-ref (string-ref strings 0))\
    \ 0)) strings]\n        [else (cons (string-ref strings 0)\n                 \
    \   (filter_by_substring (substring (string-ref strings 0)) substring))]))\n",
  "  (cond\n    [(empty? strings) strings]\n    [(string-contains-substring strings\
    \ substring) strings]\n    [else (cons (first strings)\n                (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (define (helper strings substring idx result)\n\
    \    (cond [(empty? strings)\n           result]\n          [(equal? substring\
    \ (first strings))\n           (helper (rest strings) substring (rest idx) (cons\
    \ strings (rest result)))]\n          [else\n           (helper (rest strings)\
    \ substring (rest idx) (cons strings (rest result)))]))\n  (helper strings substring\
    \ 0 '()))\n", "  (filter (fn [s] (string=? (substring s) substring)) strings))\n",
  "  (cond\n    [(empty? strings) strings]\n    [(= (first strings) substring) (filter_by_substring\
    \ (tail strings) substring)]\n    [else (cons (first strings) (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (map filter (lambda (candidate)\n     \
    \           (string=? (substring candidate) substring)))\n  strings)\n", "  (filter\
    \ string? (lambda (s)\n                    (and (string=? substring s)\n     \
    \                   (string=? s substring)))\n          strings))\n", "  (cond\n\
    \    [(string-empty? strings) '()]\n    [(string-contains? strings substring)\
    \ strings])\n  )\n", "  (cond\n    [(string? strings) (string-match substring\
    \ strings)]\n    [else (strings)]))\n", "  (cond\n    [(empty? strings) strings]\n\
    \    [(substring (car strings)) strings]\n    [else (cons (car strings)\n    \
    \            (filter_by_substring (remove-if (lambda (s)\n                   \
    \                           (equal? (substring s) (string-car strings))) strings)\n\
    \                                substring)))]))\n", "  (filter (lambda (string)\n\
    \            (string=? (string-ref string 0)\n                      substring))\n\
    \          strings))\n", "  (cond\n    ((null? strings) strings)\n    ((member\
    \ substring strings) strings))\n  )\n)", "  (filter (\u03BB (s) (string-contains\
    \ s substring)))\n  (strings))\n", "  (cond ((empty? strings) '())\n        ((substring?\
    \ (car strings) substring) (cdr strings))\n        (else (string-append (filter_by_substring\
    \ (cdr strings) substring) \n                             [(car strings)]))))\
    \ \n", "  (filter (lambda (s) (contains? (string-ref s 0) substring))\n      \
    \    strings))\n", "  (filter\n   (lambda (s)\n     (string=? (substring s) (string-length\
    \ substring))) strings))\n", "  (map (lambda (x)\n         (if (string-contains?\
    \ x substring)\n             (append (list x) (filter_by_substring (subseq x 0\
    \ (string-length x))\n                                                substring))\n\
    \             x))\n       strings))\n", "  (cond [(null? strings) strings]\n \
    \       [else (filter_by_substring1 (filter_by_substring1 (filter_by_substring1\
    \ (filter_by_substring1 (filter_by_substring1 strings substring) substring) substring)\
    \ substring) substring)]))\n", "  (cond [(empty? strings) strings]\n        [else\
    \ (cons (first strings)\n                    (filter_by_substring (rest strings)\n\
    \                                     substring))]\n        ))\n", "  (filter\
    \ (fn [_] (string-contains substring _)) strings))\n", "  (map (fn [string]\n\
    \         (cond\n           ((equal? (string-ref string 0) substring) #t)\n  \
    \         (else #f)))\n       strings))\n</code>\nThis code has some minor changes,\
    \ and a couple that would be useful for implementing some of the other answers\
    \ here:\nFirst, the map in filter_by_substring can be simplified to (map identity\
    \ strings).\nSecond, I would write filter_by_substring using list comprehensions,\
    \ since it looks more like other programming languages, and it seems like a more\
    \ elegant way to express the logic:\n<code>", "  (cond [(empty? strings) strings]\n\
    \        [(eq? (first strings) substring) (filter_by_substring (rest strings)\
    \ substring)]\n        [else (cons (first strings)\n                    (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (if (empty? strings)\n      '()\n     \
    \ (if (substring (string-chars string))\n          (cons (string->string strings)\
    \ (filter_by_substring (remove-char strings (string-length string)) substring))\n\
    \          (string->string strings))))\n", "  (define (sub?-of-substring x y)\n\
    \    (string=? (substring x) (substring y)))\n  (filter sub?-of-substring strings))\n",
  "  (cond [(empty? strings) strings]\n        [(equal? (car strings) substring) strings]\n\
    \        [else (append (filter_by_substring (filter_by_substring (filter_by_substring\
    \ strings substring) (cdr strings)) substring) (car strings))]))\n", "  (cond\n\
    \    [(empty? strings) strings]\n    [(member? substring strings) (filter_by_substring\
    \ (filter_by_substring strings substring) substring)]))\n", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(string-contains? substring* string) (cons (string-downcase\
    \ string) (filter_by_substring (string-tail string) substring))]\n    [else (filter_by_substring\
    \ (string-tail string) (append substring (list string)))]))", "  (cond [(empty?\
    \ strings) strings]\n        [(substring (string-ref strings 0))\n         (cons\
    \ (string-ref strings 0)\n               (filter_by_substring (substring (rest\
    \ strings))\n                                 substring))]))\n", "  (if (null?\
    \ strings) strings)\n  (if (string=? substring strings)\n      strings\n     \
    \ (append (string-match? (substring strings)\n                              (substring\
    \ strings))\n              strings))))\n", "  (filter (fn [[s1 s2]] (string-includes?\
    \ s1 s2))\n          strings))\n", "  (cond [(empty? strings) strings]\n     \
    \   [(equal? (first strings) substring) (filter_by_substring (rest strings) substring)]\n\
    \        [else (cons (first strings)\n                    (filter_by_substring\
    \ (filter_by_substring (rest strings) substring) substring))]))\n", "  (cond ((null?\
    \ strings) '())\n        ((equal? (car strings) substring) (cons (car strings)\
    \ (filter_by_substring (substring (cdr strings)) substring)))\n        (else (cons\
    \ (car strings) (filter_by_substring (substring (cons (car strings) (cdr strings))\
    \ substring))))))\n", "  (cond ((empty? strings) strings)\n        ((equal? (first\
    \ strings) substring) (filter_by_substring (rest strings) substring))\n      \
    \  (else (cons (first strings) (filter_by_substring (rest strings) substring)))))\
    \ \n", "  (cond\n    [(string=? substring x) (cons x strings)]\n    [else (filter_by_substring\
    \ (string-list substring) strings)]))\n", "  (if (null? strings) strings)\n  (if\
    \ (= 0 (string-length substring) (string-length strings)) strings\n      (filter\
    \ (lambda (str) (= (string-ref str 0) substring))\n              strings)))\n",
  "  (define (match-substring string substring)\n    (string=? string substring))\n\
    \  (filter (lambda (string)\n           (and\n            (define match (match-substring\
    \ string substring))\n            (not (null? string)))\n           strings)\n\
    \          strings))\n", "  (cond\n    [(null? strings) strings]\n    [(member\
    \ (car strings) substring) strings]\n    [else (filter_by_substring (cdr strings)\
    \ substring)]\n  ))\n", "  (filter (lambda (s) (find-substring s substring strings))\n\
    \          strings))\n", "  (filter (lambda (string)\n            (string=? substring\
    \ string))\n          strings))\n", "  (filter (lambda (s) (string-match s substring))\n\
    \          strings))", "  (cond\n    ((null? strings) '())\n    ((member (car\
    \ strings) substring) (strings))\n    (else (cons (car strings)\n            \
    \    (filter_by_substring (filter_by_substring (cdr strings) substring)\n    \
    \                             substring))))\n)\n", "  (filter \n   (\u03BB (x)\n\
    \     (equal? x substring))\n   strings))\n", "  (filter (lambda (str) (find substring\
    \ str))\n         strings))\n", "  (filter (lambda (str)\n            (string-match-p\
    \ substring str))\n          strings))\n", "  (map (\u03BB (string) (let ((found\
    \ #f)) (when (string-match substring string) (set! found t) (when! found (return\
    \ string))))) strings))\n", "  (cond [(empty? strings) '()]\n        [(list? (first\
    \ strings)) (cons (first strings) (filter_by_substring (map (lambda (sub) (substring\
    \ sub)) (first strings))) (rest strings))]\n        [else (cons (first strings)\
    \ (filter_by_substring (map (lambda (sub) (substring sub)) strings)))))\n", " \
    \ (cond\n    ((null? strings) '())\n    ((equal? (car strings) substring) strings)\n\
    \    (else (cons (car strings) (filter_by_substring (filter_by_substring (cdr\
    \ strings) substring))))))\n", "  (map string->string\n       (filter string->string=?\
    \ substring\n                  (string-match string->string substring\n      \
    \                         strings\n                               :start 0\n \
    \                              :end (length substring))))))\n", "  (cond [(empty?\
    \ strings) strings]\n        [(empty? (rest strings)) (substring (first strings)\
    \ substring)]\n        [else (filter_by_substring((filter_by_substring (first\
    \ strings) substring)\n                                    (rest strings)))]))\n",
  "  (cond [(empty? strings) strings]\n        [(equal? (first strings) substring)\
    \ (filter_by_substring (rest strings) substring)]\n        [else (strings (first\
    \ strings) (filter_by_substring (rest strings) substring))]))\n", "  (filter (lambda\
    \ (x) (member x substring)) strings))\n</code>\n<|/ a |>\n<| c |>\nThank you!\
    \ How would you modify this for R6RS Scheme?\n<|/ c |>\n<| c |>\n`filter_by_substring`\
    \ is part of the R6RS language, so it's not really about Scheme, it's a language\
    \ extension for Scheme. You can find more info about it here: http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-17.html#node_sec_5.5.3\n\
    <|/ c |>\n<| a |>\nThis isn't in Scheme, but I suspect it can be modified to work\
    \ with a little work.\n<code>", "  (if (null? strings)\n      '()\n      (if (equal?\
    \ (car strings) substring)\n          (cdr strings)\n          (cons (car strings)\n\
    \                (filter_by_substring (filter_by_substring (cdr strings) substring)\
    \ substring)))))\n", "  (filter string\n          (lambda (element)\n        \
    \    (string=? substring element))\n          strings))\n", "  (map (fn [(string)\
    \ (cond\n                      [(string-contains string substring) (string)]\n\
    \                      [else (string-append string substring)]) (strings)]\n \
    \       ; Return an empty list if the input list is empty\n        ; Otherwise,\
    \ keep only strings containing given substring\n        ; Otherwise, append the\
    \ substring to each string in input list\n      ))\n)\n", "  (filter (lambda (s)\n\
    \           (string=? substring s))\n         strings))\n", "  (filter (lambda\
    \ (str) (equal? (string-match substring str) 0)) strings))\n", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(member (first strings) substring) \n     (filter_by_substring\
    \ (rest strings) substring)]\n    [else (cons (first strings) (filter_by_substring\
    \ (rest strings) substring))]\n  )\n)\n", "  (filter (\u03BB (x) (string=? substring\
    \ x)) strings))\n", "  (filter (lambda (s)\n            (string= s substring))\n\
    \          strings))\n</code>\nAs you can see, we call filter and filter with\
    \ lambda. First we filter only strings that contains the substring, then we call\
    \ the lambda function for each string in the result list. Thus, we return a new\
    \ list containing only strings that contains the substring. \nTo learn more about\
    \ filter, visit this link.\n<|/ a |>\n<| a tags=racket,lisp dscore=2 |>\nScheme\
    \ doesn't have a built-in filter function; however, it's easy to write your own:\n\
    <code>", "  (cond (empty? strings) empty \n        (else\n         (if (string=?\
    \ substring (car strings)) \n             (cons strings (filter_by_substring (cdr\
    \ strings) substring))\n             (cons strings (filter_by_substring (filter_by_substring\
    \ (cdr strings) substring) substring))))))\n", "  (cond [(empty? strings) strings]\n\
    \        [(substring (string-ref strings 0)) \n         (filter_by_substring (substring\
    \ (string-ref strings 0)) substring)]\n        [else (cons (string-ref strings\
    \ 0)\n                    (filter_by_substring (substring (string-ref strings\
    \ 0)) substring))]))\n", "  (filter (\u03BB (x) (= (string-length x) (string-length\
    \ substring))) (map string->list strings)))\n", "  (cond [(empty? strings) strings]\n\
    \        [(equal? (car strings) substring) strings]\n        [else (cons (car\
    \ strings) (filter_by_substring (filter_by_substring (rest (cdr strings)) substring))])))\
    \ ;;; note the double recursive call here\n", "  (map filter (lambda (str) (string-contains\
    \ substring str)))\n  (string-append-all \"\" strings))\n", "  (filter (lambda\
    \ (s) (string-contains s substring))\n         strings))\n", "  (filter (lambda\
    \ (s) (includes? s substring)) strings))\n", "  (if (or (empty? strings) (string-empty?\
    \ substring))\n      strings\n      (cons (string->string\n             (first\
    \ strings))\n            (filter_by_substring\n             (rest strings)\n \
    \            substring))))\n", "  (cond [(empty? strings) strings]\n        [else\
    \ (filter_by_substring (drop-last strings)\n                                 (append\
    \ (drop-last substring)\n                                        strings))]))\n",
  "  (if (empty? strings)\n      '()\n      (cond ((or (string=? substring (car strings))\
    \ (substring (car strings) equals ''))\n             (cons (car strings) (filter_by_substring\
    \ (filter_by_substring (cdr strings) substring) substring)))\n            (else\
    \ (filter_by_substring (filter_by_substring (cdr strings) substring) substring))))\n",
  "  (cond ((empty? strings) '())\n        ((substring? (car strings)) (strings))\n\
    \        (else (cons (car strings)\n                    (filter_by_substring (filter\
    \ (lambda (s) (substring? s)) strings)\n                                     \
    \  (car strings))))))\n", "  (cond [(null? strings) strings]\n        [(member?\
    \ substring strings) strings]\n        [else (filter_by_substring (substring strings))]))\n",
  "  (map (\u03BB (el) (member el (substring strings))) strings))\n", "  (cond [(null?\
    \ strings) strings]\n        [(eq? (car strings) substring) strings]\n       \
    \ [else (cons (car strings)\n                    (filter_by_substring (cdr strings)\
    \ substring))]))\n", "  (filter (\u03BB (x)\n           (equal? (string-substring\
    \ x substring) substring)) strings))\n", "  (define (f string sub)\n    (match\
    \ string\n      [(cons x y) (cons (f x sub) (f y sub))]\n      [(cons x y) (cons\
    \ x y)]\n      [(cons _ y) (cons _ y)]\n      [_ (cons _ y)]\n      ))\n  (map\
    \ f strings substring))\n", "  (filter (lambda (s) (substring s in strings))\n\
    \          strings))\n", "  (filter (lambda (elem)\n            (string=? (string-length\
    \ elem) (string-length substring))\n            (string-contains? elem substring))\n\
    \          strings))\n", "  (define (contains substring strings)\n    (or (equal?\
    \ substring \"\")\n        (equal? (string-match substring strings) true)))\n\
    \  (filter contains strings))\n", "  (filter string? strings-containing-substring\
    \ substring))\n", "  (cond [(empty? strings) strings]\n        [(equal? (first\
    \ strings) substring) (subsequence strings 1)]\n        [else (filter_by_substring\
    \ (subsequence strings 1) substring)]))\n", "  (cond [(empty? strings) strings]\n\
    \        [else (if (string=? substring (car strings))\n                  (filter_by_substring\
    \ (filter (lambda (x) (not= substring x)) strings) substring)\n              \
    \    (filter_by_substring (strings (cdr strings)) substring))]))\n", "  (filter\
    \ (\u03BB (s) (string=? substring s)) strings))\n  ;; >>> filter_by_substring(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n  ;; ['abc', 'bacd', 'array']\n", "  (remove-if-not\
    \ (lambda (x) (member x substring))\n                strings))\n", "  (filter\
    \ (lambda (s) (string-equal? (string-length s) (string-length substring))\n  \
    \            (string-equal? s substring))\n          strings))\n", "  (map string->string\n\
    \       (remove-if-not (\u03BB (s) (equal s (substring string))) strings)))\n",
  "  (if (null? strings) strings\n      (if (string=? substring (car strings)) \n\
    \          (filter_by_substring (cdr strings) substring)\n          (cons (car\
    \ strings) (filter_by_substring (cdr strings) substring))))) ;#lang racket\n",
  "  (cond [(empty? strings) strings]\n        [else (filter_by_substring\n      \
    \          (filter (lambda (x) (equal? substring x))\n                       \
    \ strings)\n                substring)]\n))\n", "  (cond [(empty? strings) strings]\n\
    \        [(equal? (first strings) substring) (filter_by_substring (rest strings)\
    \ substring)]\n        [else (cons (first strings) (filter_by_substring (rest\
    \ strings) substring))]))\n", "  (cond\n    [(null? strings) strings]\n    [(equal?\
    \ (car strings) substring) (cons (car strings) (rest (filter_by_substring (filter\
    \ (cdr strings) substring) (cons (car strings) (cdr strings)))))]\n    [else (cons\
    \ (car strings) (filter_by_substring (filter (cdr strings) substring) (cons (car\
    \ strings) (cdr strings))))]))\n", "  (filter (\u03BB (s) (member substring s))\
    \ strings))\n", "  (if (empty? strings) (strings string)\n      (let ((tail (filter_by_substring\
    \ (tail strings) substring)))\n        (if (string-equal? substring (string-ref\
    \ tail 0))\n            (cons string (tail strings))\n            tail))))\n",
  "  (define (subseq? a b)\n    (and (char=? a b) (char=? (char-code a) (char-code\
    \ b))))\n  (define (filter-subseq? subseq substr)\n    (or (null? subseq)\n  \
    \      (and (subseq? subseq substr) (null? (cdr subseq)))))\n  (define (filter-seq-by-substring\
    \ subseq str)\n    (or (null? subseq)\n        (filter-subseq? subseq (substring\
    \ str))))\n  (filter (filter-seq-by-substring substring strings))\n  )\n", " \
    \ (cond [(empty? strings) strings]\n        [else (cons (first strings)\n    \
    \                (filter_by_substring (next strings) substring))]))\n", "  (filter\
    \ (lambda (s) (equal? (string-match substring s) 0))\n          strings))\n",
  "  (map #(if (string-contains % substring)\n           %\n           %)\n      \
    \ strings))\n", "  (cond [(empty? strings) strings]\n        [(member substring\
    \ strings) strings]\n        [else (cons strings (filter_by_substring (remove\
    \ substring strings)))]))\n", "  (cond\n    ((empty? strings) strings)\n    ((equal?\
    \ (car strings) substring) strings)\n    (else (cons (car strings)\n         \
    \      (filter_by_substring (filter_by_substring (filter_by_substring strings\
    \ (cdr strings)) substring)\n                                 substring)))))\n",
  "  (filter (lambda (x)\n            (string-contains? x substring))\n          strings))\n",
  "  (remove-if-not (lambda (x)\n                  (or (string=? substring x)\n  \
    \                    (equal? substring x))\n                  )\n            \
    \    strings))\n", "  (cond ((or (null? strings) (string-length substring > 0))\n\
    \         strings)\n        ((string=? substring (string-ref (string-ref strings\
    \ 0) 0))\n         (cons strings (filter_by_substring (list-tail strings) substring)))\n\
    \        (else\n         (filter_by_substring (list-tail strings) substring))))\n",
  "  (filter substring strings))\n", "  (cond\n    [(string=? substring (car strings))\
    \ (cons (car strings) strings)]\n    [else (string-append \"NOT FOUND \" (cons\
    \ substring (filter_by_substring strings (cdr strings))))]))\n", "  (cond [(empty?\
    \ strings) strings]\n        [else (append (filter_by_substring (tail strings))\
    \ (cons (first strings) (filter_by_substring (rest strings) substring)))]))\n",
  "  (cond\n    [(null? strings) strings]\n    [(equal? (car strings) substring) (filter_by_substring\
    \ (cdr strings) substring)]\n    [else (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring))]))", "  (cond [(empty? strings) strings]\n       \
    \ [(equal? (first strings) substring) (filter_by_substring (tail strings) substring)]\n\
    \        [else (cons (first strings) (filter_by_substring (rest strings) substring))]))\n",
  "  (filter #(or (equal? (string-ref strings 0) (string-ref % 0)) (string-ref % 1))\n\
    \          strings))\n", "  (cond [(empty? strings) strings]\n        [(empty?\
    \ substring) strings]\n        [(equal? (string-ref strings (car substring)) substring)\
    \ (filter_by_substring strings (cdr substring))]\n        [else (cons (car strings)\
    \ (filter_by_substring (cdr strings) substring))]))\n", "  (if (null? strings)\n\
    \      strings\n      (if (mem? (car strings) substring)\n          (filter_by_substring\
    \ (cdr strings) substring)\n          (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring)))))\n", "  (filter (lambda (x) (member x substring))\
    \ strings))\n  ;; (define (filter_by_substring strings substring)\n  ;;   (filter\
    \ (lambda (x) (member x substring)) strings))\n", "  (filter (lambda (x) (string=?\
    \ x substring)) strings))\n", "  (filter (lambda (x)\n            (string= x substring))\n\
    \          strings))\n", "  (cond [(empty? strings) '()]\n        [else (append\
    \ (filter_by_substring (rest strings) substring)\n                       (cons\
    \ (first strings) empty))]))\n", "  (filter (\u03BB (s) (and (equal? s (substring\
    \ substring)) (string-contains? s substring))) strings))\n", "  (filter (lambda\
    \ (str) (mem? (substring str) strings)) strings))\n", "  (cond\n    [(string-length\
    \ substring)\n     (filter strings (lambda (element) (equal? (string-length substring)\
    \ (string-length element))))]\n    [else\n     (filter strings (lambda (element)\
    \ (equal? (string-index element substring) 0)))]))\n</code>\n<|/ a tags=racket,substring,functional-programming,scheme\
    \ |>\n<| a dscore=0 tags=racket,substring,functional-programming,scheme |>\nI\
    \ find this more natural than the other answers:\n<code>", "  (cond [(empty? strings)\
    \ strings]\n        [(substring (string-ref strings 0))\n         (filter_by_substring\
    \ (string-cdr strings) substring)]\n        [else (cons (string-ref strings 0)\n\
    \                    (filter_by_substring (string-cdr strings) substring))]))\n",
  "  (filter (lambda (x)\n            (string=? (string-match (string-ref x 0) substring)\
    \ 0))\n         strings))\n", "  (cond [(null? strings) '()]\n        [(equal?\
    \ (car strings) substring) (cons (car strings) '())]\n        [else (cons (car\
    \ strings)\n                    (filter_by_substring (filter (lambda (x) (equal?\
    \ (car strings) x)) (cdr strings)) substring))]))\n", "  (map (lambda (string)\n\
    \         (if (string=? substring string)\n             (append string (string-append\
    \ '#t (filter_by_substring string substring)))\n             string))\n      \
    \ (filter (lambda (string) (or (string=? substring string) (null? string)))\n\
    \               strings)))\n", "  (filter (lambda (s) (substring (s 0) (string-length\
    \ s))) strings))\n", "  (cond [(empty? strings) strings]\n        [(equal? (first\
    \ strings) substring) (filter_by_substring (rest strings) substring)]\n      \
    \  [else (cons (first strings)\n                    (filter_by_substring (rest\
    \ strings) substring))]))\n</cell>\n<text>\nExercise 3: Implement \"split-at-most\"\
    \nImplement split-at-most that takes an input list of strings and returns the\
    \ list of strings with at most n substrings. All the substrings must be consecutive,\
    \ and they must be shorter than the total number of substrings.\n\nHint: Remember\
    \ to use modulo operation, and that you can use the filter function.\n\n\n</text>\n\
    <code language=dyalog-kernel>\n#lang racket\n", "  (define (helper current remaining\
    \ tail)\n    (cond [(empty? tail) remaining]\n          [(equal? (first tail)\
    \ substring) (cons current tail)]\n          [else (helper (first tail) (cons\
    \ (first tail) remaining) (rest tail))]\n          ))\n  (helper \"\" strings\
    \ \"\"))\n", "  (filter string? strings))\n", "  (define (helper strings substring)\n\
    \    (cond\n      [(empty? strings) strings]\n      [(equal? (first strings) substring)\
    \ (helper rest substring)]\n      [else (helper (rest strings) substring)]))\n\
    \  (helper strings substring))\n", "  (filter (lambda (s) (string-match substring\
    \ s))\n          strings))\n", "  (cond [(empty? strings) '()]\n        [(eq?\
    \ (substring string) (first strings)) (rest strings)]\n        [else (cons (first\
    \ strings) (filter_by_substring (rest strings) substring))]))\n", "  (map (lambda\
    \ (x) (contains x substring)) strings))\n", "  (filter (lambda (s) (string-contains\
    \ s substring)))\n  (strings))\n", "  (cond [(empty? strings) strings]\n     \
    \   [(equal? (string-ref (string-ref strings 0) 0) substring) strings]\n     \
    \   [else (cons (string-ref strings 0) (filter_by_substring (substring (cons (string-ref\
    \ strings 1) strings))))]))\n", "  (cond [(empty? strings) strings]\n        [(equal?\
    \ (car strings) substring) (filter_by_substring (cdr strings) substring)]\n  \
    \      [else (cons (car strings) (filter_by_substring (cdr strings) substring))]))\n",
  "  (let loop ((result '())\n             (remaining (remove-if (lambda (str)\n \
    \                                     (equal? (string->string str) substring))\n\
    \                                 strings)))\n    (cond\n      [(null? remaining)\
    \ (reverse result)]\n      [else\n       (loop (conj result (first remaining))\n\
    \             (rest remaining))]))\n</code>\n<|/ a |>\n<| a dscore=1 |>\nI personally\
    \ like's answer above using remove-if. Another possibility would be to use filter:\n\
    <code>", "  (cond\n    [(string-empty? strings) strings]\n    [(substring? (car\
    \ strings)) (cons (car strings) (filter_by_substring (remove-if-not (lambda (s)\
    \ (string-match substring s)) (cdr strings)) (filter_by_substring (remove-if-not\
    \ (lambda (s) (string-match substring s)) (car strings)))) (filter_by_substring\
    \ (cdr strings))]\n    [else (filter_by_substring (cdr strings))]))\n", "  (cond\
    \ [(empty? strings) strings]\n        [(member (car strings) substring) (string-append\
    \ (car strings) \"-\")]\n        [else (filter_by_substring (rest strings) substring)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
