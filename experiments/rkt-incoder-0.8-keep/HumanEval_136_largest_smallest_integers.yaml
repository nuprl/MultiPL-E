name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns a tuple (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as None.\n;; Examples:\n;; largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None,\
  \ 1)\n;; largest_smallest_integers([]) == (None, None)\n;; largest_smallest_integers([0])\
  \ == (None, None)\n(define (largest_smallest_integers lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) (list (none))]\n    [else (let*\n      \
    \      ([negative (filter (lambda (x) (< x 0)) lst)])\n              (cond\n \
    \              [(empty? negative) (none)]\n               [else (let*\n      \
    \                ([positive (filter (lambda (x) (> x 0)) lst)])\n            \
    \         (cond\n                      [(empty? positive) (none)]\n          \
    \            [else (let ([max (first negative) (first positive)])\n          \
    \                     (cond\n                                [(empty? max) (list\
    \ (none))]\n                                [else (let ([max (max (first positive)\
    \ max) (in-range (first positive) (first negative))])\n                      \
    \                   (cons max positive)))])])])]))]))\n", "  (cond [(empty? lst)\
    \ (tuple empty)]\n        [(< (car lst) 0)\n         (tuple (car lst) (car lst))]\n\
    \        [else\n         (if (< (car lst) (largest-smallest (cdr lst)))\n    \
    \         (tuple (largest-smallest (car lst)) (cdr lst))\n             (tuple\
    \ (cdr lst) largest-smallest (car lst)))]))\n", "  (let ((max (car lst))\n   \
    \     (min (cadr lst)))\n    (cond\n      [(< min max) (list (cons min max))]\n\
    \      [(= max min) (list (cons max min))]\n      [else (list (cons max min))])))\
    \ ;; [(2 1) (3 4) 5 7]\n", "  (cond\n    ;; We have no negative or positive integers.\n\
    \    ;; Return them as None.\n    ((null? lst) '(None None))\n    ;; At least\
    \ one integer is a negative integer.\n    ((< (car lst) 0)) '(None (car lst))\n\
    \    ;; All negative integers come before positive integers.\n    ((> (car lst)\
    \ 0)) '((car lst) (largest_smallest_integers (cdr lst)))\n    ;; All positive\
    \ integers come before negative integers.\n    ((< (car lst) 0)) '((largest_smallest_integers\
    \ (cdr lst)) (car lst))\n    ;; There is only one integer in the list, which is\n\
    \    ;; either a negative or positive integer.\n    ((= (length lst) 1)) '((car\
    \ lst) (largest_smallest_integers (cdr lst)))\n    (else (error \"Unexpected list\
    \ length: ~a.\" lst))\n  )\n)\n", "  (if (empty? lst)\n      (list None None)\n\
    \      (let ((smallest (car lst))\n            (largest (car lst)))\n        (if\
    \ (< (car lst) 0)\n            (let ((smallest (car lst)))\n              (cons\
    \ (car lst) (largest_smallest_integers (cdr lst))))\n            (let ((largest\
    \ (car lst)))\n              (cons smallest largest)))))\n", "  (cond\n    [(empty?\
    \ lst) (list None None)] \n    [else\n     (let ([largest (max lst)]\n       \
    \    [smallest (min lst)])\n       (cond\n         [(> largest smallest) (list\
    \ None smallest)]\n         [(< largest smallest) (list smallest None)]\n    \
    \     [(= largest smallest) (list smallest smallest)]\n         [else (list smallest\
    \ smallest)]))]))\n", "  (cond\n    [(empty? lst) (list None None)] \n    [else\
    \ (cond\n             [(< (first lst) 0) (first lst)]\n             [(> (first\
    \ lst) 0) (second lst)]\n             [else (cond\n                     [(< (second\
    \ lst) 0) (first lst)]\n                     [(> (second lst) 0) (second lst)]\n\
    \                     [else (cond\n                             [(< (third lst)\
    \ 0) (first lst)]\n                             [(> (third lst) 0) (third lst)]\n\
    \                             [else (cond\n                                  \
    \   [(< (fourth lst) 0) (second lst)]\n                                     [(>\
    \ (fourth lst) 0) (fourth lst)]\n                                     [else (cond\n\
    \                                             [(< (fifth lst) 0) (third lst)]\n\
    \                                             [(> (fifth lst) 0) (fifth lst)]\n\
    \                                             [else (cond\n                  \
    \                                   [(< (sixth lst) 0) (fourth lst)]\n       \
    \                                              [(> (sixth lst) 0) (sixth lst)]\n\
    \                                                     [else (cond\n          \
    \                                                   [(< (seventh lst) 0) (fifth\
    \ lst)]\n                                                             [(> (seventh\
    \ lst) 0) (seventh lst)]\n                                                   \
    \          [else (cond\n                                                     \
    \                [(< (eighth lst) 0) (sixth lst)]\n                          \
    \                                           [(> (eighth lst) 0) (eighth lst)]\n\
    \                                                                     [else (cond\n\
    \                                                                           [(<\
    \ (ninth lst) 0) (seventh lst)]\n                                            \
    \                               [(> (ninth lst) 0) (ninth lst)]\n            \
    \                                                               [else (cond\n\
    \                                                                            \
    \       [(< (tenth lst) 0) (eighth lst)]\n                                   \
    \                                                [(> (tenth lst) 0) (tenth lst)]\n\
    \                                                                            \
    \       [else (cond\n                                                        \
    \                                    [(< (eleventh lst) 0) (tenth lst)]\n    \
    \                                                                            \
    \            [(> (eleventh lst) 0) (eleventh lst)]\n                         \
    \                                                                   [else (cond\n\
    \                                                                            \
    \                       [(< (twelfth lst) 0) (eleventh lst)]\n               \
    \                                                                            \
    \        [(> (twelfth lst) 0) (twelfth lst)]\n                               \
    \                                                                    [else (cond\n\
    \                                                                            \
    \                              [(< (thirteenth lst) 0) (twelfth lst)]\n      \
    \                                                                            \
    \                        [(> (thirteenth lst) 0) (thirteenth lst)]\n         \
    \                                                                            \
    \                     [else (cond\n                                          \
    \                                                                       [(< (fourteenth\
    \ lst) 0) (thirteenth lst)]\n                                                \
    \                                                                 [(> (fourteenth ",
  "  (if (null? lst)\n      (cond [(< 0 lst) (cons lst '())]\n            [(<= 0 lst)\
    \ (cons lst '())]\n            [else (cons '() lst)]))\n  (let ((largest-integer\
    \ (car lst))\n        (smallest-integer (cdr lst)))\n    (if (< largest-integer\
    \ smallest-integer)\n      (largest_smallest_integers (cons largest-integer (largest-smallest_integers\
    \ smallest-integer)))\n      (largest_smallest_integers (cons smallest-integer\
    \ (largest-smallest_integers smallest-integer))))))\n", "  (if (empty? lst)\n\
    \      (cond ((< 0 lst) (listof none) '(None))\n            ((< lst 0) (listof\
    \ none) '(None))\n            (else (cons (first lst) (largest_smallest_integers\
    \ (rest lst))))))\n</code>\n<|/ a tags=scheme,racket |>\n<| c |>\nThanks for your\
    \ answer, but I only want to use cond and not define so as to practice using cond.\n\
    <|/ c |>\n<| c |>\nThe point is to use `cond` instead of `define` as that's what\
    \ you are asked to do in the question, and that is what you did in your answer.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a version using cond, which only requires the\
    \ smallest and largest functions to return a pair:\n<code>", "  (cond\n    [(empty?\
    \ lst) (list None None None)]\n    [(positive? (first lst)) (list (first lst)\
    \ (largest_smallest_integers (rest lst)))]\n    [else (list (first lst) (largest_smallest_integers\
    \ (rest lst)))]))\n", "  (let loop ((largest (car lst))\n             (smallest\
    \ (car lst)))\n    (cond ((null? lst)\n           (list largest\n            \
    \     smallest))\n          ((negative? (car lst))\n           (loop (car lst)\n\
    \                 (minimum smallest)))\n          ((positive? (car lst))\n   \
    \        (loop (maximum largest)\n                 (car lst)))\n          (else\n\
    \           (loop (largest largest)\n                 (smallest smallest))))))\n\
    </code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| a dscore=0 |>\nI made my own\
    \ solution to the question. I thought it would be useful to share it.\n<code>\n\
    #lang racket\n", "  (let loop ((lst lst)\n             (max (max lst))\n     \
    \        (min (min lst)))\n    (if (empty? lst)\n        (values max min)\n  \
    \      (loop (rest lst)\n              (if (>= max lst)\n                  (max\
    \ lst)\n                  max)\n              (if (<= min lst)\n             \
    \     (min lst)\n                  min))))))\n</cell>\n<code language=racket-student-catskills-programming>\n\
    #lang racket\n", "  (cond [(null? lst)\n         (list none none)]\n        [(<\
    \ (car lst) 0)\n         (list (car lst) none)]\n        [(> (car lst) 0)\n  \
    \       (list (none (car lst)) (car lst))]\n        [else (largest_smallest_integers\
    \ (cdr lst))]))\n", "  (cond\n    ((null? lst) (list 'None 'None))\n    ((null?\
    \ (cdr lst)) (list 'None 'None))\n    ((< (car lst) (cadr lst)) (list 'None (car\
    \ lst)))\n    ((< (car lst) (caddr lst)) (list 'None (cadr lst)))\n    ((> (car\
    \ lst) (caddr lst)) (list (cadr lst) 'None))\n    ((> (car lst) (cadr lst)) (list\
    \ 'None (caddr lst)))\n    (else (list (car lst) (caddr lst))))\n  )\n)\n", " \
    \ (cond [(empty? lst) (list (none? none) (exact->inexact 0))]\n        [(integer?\
    \ (first lst))\n         (let ([a (maximum (- lst (first lst)))])\n          \
    \ (let ([b (minimum (+ lst (first lst)))])\n             (cons (a) (cons b lst)))]\n\
    \        [else (let ([a (maximum (rest lst))])\n                (let ([b (minimum\
    \ (rest lst))])\n                  (cons (a) (cons b lst)))]\n        )]))\n",
  "  (if (or (null? lst) (empty? lst))\n      `(,lst)\n      (let* ((smallest (car\
    \ lst))\n             (largest (cdr lst))\n             (smallest-int (if (number?\
    \ smallest)\n                               smallest\n                       \
    \        (if (negative? smallest)\n                                   '(- (car\
    \ lst) smallest)\n                                   '(- (cdr lst) smallest))))\n\
    \             (largest-int (if (number? largest)\n                           \
    \    largest\n                               (if (positive? largest)\n       \
    \                            '(car lst) largest))))\n        (list largest-int\
    \ smallest-int)\n        (largest_smallest_integers (cdr lst)))))\n</cell>\n<text>\n\
    Challenge 1\nCreate a function that finds the largest and smallest number in a\
    \ list of numbers.\n", "  (cond\n    [(null? lst) (list (none? null?) (list))]\n\
    \    [else (cond\n            ;; Find positive and negative integers.\n      \
    \      ;; If the first element of 'lst' is a negative, return the\n          \
    \  ;; negative as 'a'. If the first element of 'lst' is a positive,\n        \
    \    ;; return the first element as 'a'; otherwise return 'a' as None.\n     \
    \       ;; Otherwise, return the first element as 'b' and a as 'a'.\n        \
    \    [(< (first lst) 0)\n             (list (first lst) (none? null?))]\n    \
    \        [else (cond\n                    ;; Find 'a' as positive integer.\n \
    \                   [(<= (first lst) 0)\n                     (list (first lst)\
    \ (first lst))]\n                    [else (cond\n                           \
    \  ;; Find 'b' as negative integer.\n                             [(< 0 (first\
    \ lst))\n                              (list (first lst) (none? null?))]\n   \
    \                          [else (list (first lst) (first lst))])])])]))\n", " \
    \ (let loop ((lst lst) (a null) (b null))\n    (cond [(empty? lst) (reverse (list\
    \ a b))]\n          [(positive? (first lst)) (loop (rest lst) (first lst) (ast\
    \ b))]\n          [(negative? (first lst)) (loop (rest lst) (ast b) (first lst))]\n\
    \          [else (loop (rest lst) (first lst) (first lst))]))))\n", "  (cond\n\
    \    [(empty? lst) (list (reverse '()) '())]\n    [(< 0 (car lst)) (list (reverse\
    \ (car lst)) (car lst))\n     ((> 0 (car lst)) (list (reverse (car lst)) (car\
    \ lst))\n     ((< 0 (cdr lst)) (list (reverse (cdr lst)) (cdr lst))\n     ((>\
    \ 0 (cdr lst)) (list (reverse (cdr lst)) (cdr lst))\n     [else (largest_smallest_integers\
    \ (cdr lst))]))]))\n", "  (cond\n    [(empty? lst)\n     (list None None)] \n\
    \    [(number? (car lst))\n     (if (negative? (car lst))\n         (cons (car\
    \ lst) (largest_smallest_integers (cdr lst)))\n         (largest_smallest_integers\
    \ (cdr lst)))] \n    [else\n     (largest_smallest_integers (cdr lst))]))\n",
  "  (cond [(empty? lst) '(None None)] [\n    (< (car lst) 0)\n    (cond [(< 0 (car\
    \ lst)) (car lst)]\n          [(> 0 (car lst)) (largest_smallest_integers (cdr\
    \ lst))]\n          [else (largest_smallest_integers (cdr lst))]\n          )\n\
    \    ]\n    [else (cons 'None (largest_smallest_integers (cdr lst)))]))\n", " \
    \ (cond\n    [(empty? lst) (list None None None None None None None None None\
    \ None None)]\n    [(integer? (first lst)) (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n    [else (let ((a (max-number-from-integers (first lst))))\n\
    \               (let ((b (min-number-from-integers (first lst))))\n          \
    \       (if (> a b)\n                     (cons a b)\n                     (largest_smallest_integers\
    \ (rest lst))))]))\n", "  (define (helper lst acc)\n    (cond\n      [(null? lst)\
    \ acc]\n      [(and (number? c) (negative? c)) (helper (cdr lst) (car acc))]\n\
    \      [else (helper (cdr lst) (cons (car lst) acc))]))\n  (helper lst '()))\n",
  "  (define (helper lst a b)\n    (cond\n      [(null? lst) (list a b)]\n      [(<\
    \ (first lst) (first b)) (helper (rest lst) (first b) a)]\n      [else (helper\
    \ (rest lst) a (first lst))]\n    )\n  )\n  (helper lst '() '()))\n", "  (define\
    \ (helper lst a b)\n    (cond ((null? lst) (b a))\n          ((< a (first lst))\
    \ (helper (rest lst) a (first lst)))\n          ((< (first lst) (first lst)) (helper\
    \ (rest lst) (first lst) a))\n          (else (helper (rest lst) (first lst) (first\
    \ lst))))\n  (helper lst 'nil '(lambda (x) (<= x 0))))", "  (cond [(empty? lst)\
    \ (list (none))]\n        [(< 0 (car lst)) (list (car lst) (cdr lst))]\n     \
    \   [else (list (car lst) (largest_smallest_integers (cdr lst)))]))\n", "  (cond\n\
    \    [(empty? lst) (list None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None ", "  (cond\n    [(empty?\
    \ lst) (list None None None)] \n    [(< 0 (car lst)) (list None (car lst) (cdr\
    \ lst))]\n    [else (list (car lst) (car lst) (largest_smallest_integers (cdr\
    \ lst)))]))\n", "  (cond\n     ;; If there are no elements, return an empty tuple.\n\
    \     ;; This condition can never be reached, but it's good to make sure\n   \
    \  ;; that this case will never happen.\n     ((null? lst) '())\n     ;; If a\
    \ positive integer is found, return it.\n     ((positive? lst) (first lst))\n\
    \     (else (largest_smallest_integers (rest lst))))) ;; (else-clause cond-clause)\n",
  "  (let loop ((result '()) (i 0))\n    (cond\n      [(null? lst) result]\n     \
    \ [(< i 5)\n       (loop (cons (car lst) result) (add1 i))]\n      [(> i 5)\n\
    \       (loop (cdr lst) (add1 i))]\n      [(equal? (car lst) 0)\n       (loop\
    \ (cons (car (cdr lst)) result) (add1 i))]\n      [(equal? (cdr lst) 0)\n    \
    \   (loop (cons (car (cdr (cdr lst))) result) (add1 i))]\n      [else (loop (cons\
    \ (car lst) result) (add1 i))]\n    )\n    (loop () 0)\n    (if (> result '())\n\
    \        (cons (reverse result) (list (- 0 (car result))))\n        (list '())\n\
    \    )\n  )\n)\n", "  (let loop ((smallest (first lst)) (lst lst))\n    (cond\
    \ ((null? lst)\n           (list smallest smallest))\n          ((< (first lst)\
    \ (first lst))\n           (loop (first lst) (second lst)))\n          (else\n\
    \           (loop (first lst) (second lst)))))\n", "  (cond [(empty? lst) (list\
    \ (cons nil 0))]\n        [(integer? (first lst)) (list (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n        [else (list (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n        )\n        )\n  )\n", "  (cond\n    [(empty? lst) (list\
    \ (car lst) (car lst))]\n    [(<= (car lst) (car (cdr lst)))\n     (list (car\
    \ lst) (car (cdr lst)))]\n    [else\n     (list (car lst) (largest_smallest_integers\
    \ (cdr lst)))]))\n", "  (cond ((null? lst) '())\n        ((not (pair? (car lst)))\n\
    \         (if (< (car lst) 0) (car lst) '()))\n        (else (cons (largest_smallest_integers\
    \ (cdr lst))\n                  (largest_smallest_integers (cdr lst))))))\n",
  "  (cond ((null? lst) '(None None))\n        ((< (first lst) 0) (second lst))\n\
    \        (else '(None (first lst))))\n)\n", "  (let loop ([neg-nums '()\n    \
    \           pos 0])\n    (cond [(null? lst) (values neg-nums pos)]\n         \
    \ [(number? lst) (values neg-nums pos)]\n          [(< -number (first lst))\n\
    \           (loop (cons (first lst)\n                      neg-nums)\n       \
    \          (add1 pos))]\n          [(< 1 (first lst))\n           (loop (cons\
    \ (first lst)\n                      neg-nums)\n                 (add1 pos))]\n\
    \          [else\n           (loop (rest lst)\n                 (add1 pos))])))\n",
  "  (cond [(empty? lst) (list 'none 'none)]\n        [(and (number? (car lst)) (>\
    \ car lst)) (cons (car lst) (largest_smallest_integers (cdr lst)))]\n        [else\
    \ (largest_smallest_integers (cdr lst))]))\n", "  (cond\n    [(null? lst)\n  \
    \   (list (list None None))]\n    [else (cons (expt -1 min (max lst)) (largest_smallest_integers\
    \ (rest lst)))]))\n", "  (let loop ((lst (reverse lst)) (smallest-positive (first\
    \ lst)) (largest-negative (first lst))\n             (smallest-negative-found\
    \ #f) (largest-positive-found #f))\n    (cond\n      [(null? lst) (values (reverse\
    \ (list smallest-positive largest-negative))\n                         (smallest-positive?\
    \ largest-negative)\n                         largest-negative? smallest-negative-found)\n\
    \       ]\n      [(< smallest-negative (car lst))\n       (loop (cdr lst)\n  \
    \           (first lst)\n             (if (< smallest-negative (car lst))\n  \
    \               smallest-negative\n                 largest-negative))\n     \
    \  ]\n      [(< largest-positive (car lst))\n       (loop (cdr lst)\n        \
    \     (first lst)\n             (if (< largest-positive (car lst))\n         \
    \        largest-positive\n                 smallest-positive))\n       ]\n  \
    \    [(not smallest-negative-found)\n       (if (= (car lst) largest-negative)\n\
    \           (loop (cdr lst)\n                 smallest-negative\n            \
    \     largest-negative\n                 #t\n                 #t))\n       (loop\
    \ (cdr lst)\n             (first lst)\n             (if (< largest-negative (car\
    \ lst))\n                 largest-negative\n                 smallest-negative))\n\
    \       ]\n      [(not largest-positive-found)\n       (if (= (car lst) smallest-positive)\n\
    \           (loop (cdr lst)\n                 smallest-positive\n            \
    \     largest-positive\n                 #t\n                 #t))\n       (loop\
    \ (cdr lst)\n             (first lst)\n             (if (< largest-positive (car\
    \ lst))\n                 largest-positive\n                 smallest-positive))\n\
    \       ]\n      [else\n       (loop (cdr lst)\n             (first lst)\n   \
    \          (if (< largest-negative (car lst))\n                 largest-negative\n\
    \                 smallest-negative))\n       ]\n      )\n    )\n  )\n)\n", " \
    \ (cond [(null? lst) (cons (car lst) (cons None (cons None lst)))]\n        [(<\
    \ car lst) (cons (car lst) (cons (car lst) None))]\n        [else (cons (car lst)\
    \ (cons (car lst) (cons None lst)))]))\n", "  (define (largest_smallest lst)\n\
    \    (cond [(empty? lst) (list 'None 'None)] \n          [(not (pair? (car lst)))\
    \ (list 'None 'None)]\n          [else (if (< 0 (car lst)) (largest_smallest (cdr\
    \ lst)) \n                     (largest_smallest (cdr lst)))))\n    (define (smallst_largest\
    \ lst)\n      (cond [(empty? lst) (list 'None 'None)] \n            [(not (pair?\
    \ (car lst))) (list 'None 'None)]\n            [else (if (> 0 (car lst)) (smallst_largest\
    \ \n                                  (cdr lst)) (smallst_largest \n         \
    \                         (cdr lst)))))\n    (define (max_min lst)\n      (cond\
    \ [(empty? lst) (list 'None 'None)] \n            [(not (pair? (car lst))) (list\
    \ 'None 'None)]\n            [else (if (< (car lst) 0) (max_min (cdr lst))\n \
    \                      (smallst_largest lst))]))\n    (largest_smallest lst))\n",
  "  (cond\n    [(empty? lst) (list None None None)]\n    [(< 0 (car lst)) (cons (car\
    \ lst) (largest_smallest_integers (cdr lst)))]\n    [(< 0 (cdr lst)) (largest_smallest_integers\
    \ lst)]\n    [else (largest_smallest_integers (cdr lst))]\n  )\n)\n", "  (cond\n\
    \    [(empty? lst) (list None None)]\n    [(positive? (first lst))\n     (cons\
    \ (first lst) (largest_smallest_integers (rest lst)))]\n    [else\n     (if (negative?\
    \ (first lst))\n         (cons (first lst) (largest_smallest_integers (rest lst)))\n\
    \         (largest_smallest_integers (rest lst)))]))\n", "  (cond\n     ;; Check\
    \ to make sure there isn't a empty list as input.\n     ((null? lst)\n      (list\
    \ None None))\n     ;; Check both negative and positive integers.\n     ((number?\
    \ (car lst))\n      ;; Create a tuple of both the negative and the positive integers.\n\
    \      (cons (-(car lst)) (largest_smallest_integers (cdr lst))))\n     ;; There\
    \ are only negative integers, so the largest must be the largest.\n     ((negative?\
    \ (car lst))\n      ;; Create a tuple of both the negative and the positive integers.\n\
    \      (cons (-(car lst)) (largest_smallest_integers (cdr lst))))\n     ;; There\
    \ are only positive integers, so the smallest must be the smallest.\n     ((positive?\
    \ (car lst))\n      ;; Create a tuple of both the negative and the positive integers.\n\
    \      (cons (-(car lst)) (largest_smallest_integers (cdr lst))))\n     ;; There\
    \ are no negative and positive integers, so return the whole list.\n     (t\n\
    \      (cons car lst))))\n", "  (cond\n    [(null? lst) '(None None)]\n    [(or\
    \ (< -(car lst) (car lsts))\n         (> -(car lst) (car lsts)))\n     (list (car\
    \ lst) (largest_smallest_integers (cdr lst)))]\n    [else (list (car lst) \n \
    \              (largest_smallest_integers (cdr lst)))]))\n", "  (cond\n    [(null?\
    \ lst)\n     (list->'a 'b 'None)] \n    [(list->'a 'b (car lst))\n     (let ([a\
    \ (largest_smallest_integers lst)])\n       (list->'b 'a (cdr lst)))]\n    [else\n\
    \     (let ([a (largest_smallest_integers (cdr lst))])\n       (list->'a b (cdr\
    \ lst)))]))\n", "  (cond\n    [(empty? lst) (list None None)]\n    [(positive?\
    \ (first lst)) (cons first lst)\n      (largest_smallest_integers (rest lst))]\n\
    \    [(negative? (first lst)) (list (first lst) None)\n      (largest_smallest_integers\
    \ (rest lst))]\n    [else (largest_smallest_integers (rest lst))]\n    ))\n",
  "  (let loop ((lst (reverse lst))\n             (max 0)\n             (min 0))\n\
    \    (if (null? lst)\n        (values (list max) (list min))\n        (let ((elt\
    \ (first lst)))\n          (if (< (car lst) elt)\n              (loop (rest lst)\n\
    \                     (max (car lst) max)\n                     (min min (caar\
    \ lst)))\n              (loop (rest lst)\n                     (max (car lst)\
    \ max)\n                     (min (caar lst) (caar lst))))))))\n</code>\n<|/ a\
    \ tags=racket,scheme dscore=1 |>\n<| c |>\nYes, this works and is very similar\
    \ to what I came up with, except for the loop termination condition. Thanks.\n\
    <|/ c |>\n<| a |>\nHere is another version (which I think is clearer) with a named\
    \ let. It uses a helper function called ismax which determines the maximum in\
    \ one pass and then uses map to return the maximum and minimum elements. It also\
    \ uses filter which filters out the none values and finally gets the length. It\
    \ uses recursion to determine if the first element is greater than the maximum\
    \ or lesser than the first element. This avoids the need to reverse the list (which\
    \ is a O(n) operation). The code should work correctly with any sequence, but\
    \ it does not work for empty sequences.\n<code>", "  (define (helper lst max min)\n\
    \    (if (empty? lst)\n        (list (cond ((< max min) max)\n               \
    \    ((> max min) min))\n              (if (< max min) (cons min (helper (rest\
    \ lst) (max min max))) '()))\n        (helper (rest lst) max (min max)))))\n \
    \ (helper lst #f\n          #f))\n", "  (let loop ((accum None)\n            \
    \ (max-neg 0)\n             (min-pos 0))\n    (if (null? lst)\n        (reverse\
    \ (list (reverse accum min-pos) (list accum max-neg)))\n        (loop (cons (car\
    \ lst)\n                   (if (<= (car lst)\n                          (min-pos))\n\
    \                       (cons (car lst) (min-pos))\n                       (if\
    \ (>= (car lst)\n                               (max-neg))\n                 \
    \      (cons (car lst) (max-neg))\n                       accum)))\n         \
    \      (if (<= (car lst) 0)\n                   (if (> max-neg (car lst))\n  \
    \                     (loop (cons (car lst) (max-neg) max-neg)\n             \
    \                  (car lst) (cdr lst))\n                       (loop (cons (car\
    \ lst) (min-pos) min-pos)\n                               (car lst) (cdr lst))))\n\
    \                   (if (< min-pos (car lst))\n                       (loop (cons\
    \ (car lst) (max-neg) max-neg)\n                               (car lst) (cdr\
    \ lst))\n                       (loop (cons (car lst) (min-pos) min-pos)\n   \
    \                            (car lst) (cdr lst)))))\n    (loop (reverse accum)\n\
    \          (if (> max-neg 0) (max max-neg)\n               (if (< min-pos 0) (min\
    \ min-pos)\n                   (if (null? accum) '(None) (first accum))))\n  \
    \        (if (< min-pos 0) (min min-pos)\n               (if (null? accum) '(None)\
    \ (first accum))))))\n", "  (cond\n    [(empty? lst) (list (list 'None 'None)\
    \ 'None)] \n    [else (let ((a (max (- lst (first lst)))\n                  (b\
    \ (min (+ lst (first lst)))))\n              (if (and (= a b)\n              \
    \        (< a (- b 1)))\n                  (list (list a b) lst)\n           \
    \       (list (list 'None 'None) lst)))]))) \n</code>\n<|/ a |>\n<| a |>\nHere's\
    \ another solution I came up with.  It's a little more code, but I thought I would\
    \ share it.\n<code>", "  (cond\n    [(empty? lst) (list (car lst) (cons (car (cdr\
    \ lst)) (cdr (cdr lst))))]\n    [(pair? (car lst))\n     (if (< car lst)\n   \
    \      (largest_smallest_integers (cdr lst))\n         (largest_smallest_integers\
    \ (cdr lst)))]\n    [else (largest_smallest_integers (cdr lst))]\n  ))\n", " \
    \ (cond\n    [(empty? lst) (list (none? (sort lst)))]\n    [(member (head lst)\
    \ (sort lst)) (list (head lst) (smallest-integer (tail lst)))]\n    [else (list\
    \ (none? (sort lst)) (smallest-integer (tail lst)))]))\n", "  (cond [(empty? lst)\
    \ '()]\n        [(< car lst) (list car lst)]\n        [else (cons (max (car lst)\
    \ (smallest_largest (cdr lst)))\n                     (largest_smallest_integers\
    \ (cdr lst)))]))\n", "  (cond\n    [(empty? lst) (list '() '())]\n    [else (let\n\
    \t    ([vals (remove-duplicates lst)\n\t       (max (car vals) (min (cadr vals)))\n\
    \t       (mins (remove (< max) (remove-duplicates (cdr vals))))])\n\t    (if (empty?\
    \ mins)\n\t       [(list max (car mins))]\n\t       [cons (list max (car mins))\
    \ (largest_smallest_integers (cons (car mins) (cdr mins)))]))]))\n", "  (cond\n\
    \    [(empty? lst) (cond (= (length lst) 1) (cond (< 0 (car lst)) (list (car lst)\
    \ (+ (car lst) 1))) (cond (>= 0 (car lst)) (list (car lst) (cdr lst))) (list (car\
    \ lst) '()))]\n    [else (let ([head (first lst)])\n           (cond\n       \
    \      [(< head 0) (cond (= (length lst) 1) (cond (< 0 (car lst)) (list (car lst)\
    \ (+ (car lst) 1))) (cond (>= 0 (car lst)) (list (car lst) (cdr lst))) (list (car\
    \ lst) '()))]\n             [(< head 1) (cond\n                        [(< 0 (car\
    \ lst)) (list (car lst) (+ (car lst) 1))]\n                        [(>= 0 (car\
    \ lst)) (list (car lst) (cdr lst))]\n                        (list (car lst) '()))]\n\
    \             [(> head 0) (cond\n                        [(< 1 (car lst)) (list\
    \ (car lst) (cdr lst))]\n                        [(>= 1 (car lst)) (list (car\
    \ lst) (+ (car lst) 1))]\n                        (list (car lst) '()))]\n   \
    \          [else (largest_smallest_integers (cdr lst))])]))\n", "  (cond\n   \
    \ [(null? lst) (list (none? lst #f) (none? lst #f))]\n    [(< (car lst) (- (car\
    \ lst) (first lst)))\n     (list (first lst) (car lst))]\n    [(< (first lst)\
    \ (car lst))\n     (list (first lst) (car lst))]\n    [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (define (helper lst max min) (cond ((null? lst) (min)\
    \ (max))\n                                    ((not (number? lst)) (null? (max)\
    \ (min))\n                                    ((< lst max) (helper (cdr lst) lst\
    \ max))\n                                    ((> lst min) (helper (cdr lst) min\
    \ lst))\n                                    (else (helper (cdr lst) min max))))\n\
    \  (helper lst #f #t))\n</cell>\n<code language=dyalog-kernel>", "  (let loop\
    \ ((lst lst)\n             (a (ref 0))\n             (b (ref 0)))\n    (cond [(empty?\
    \ lst)\n           (list a b)]\n          [(< a (first lst))\n           (loop\
    \ (rest lst)\n                 (+ a 1)\n                 (ref b))\n          \
    \ ]\n          [(< b (first lst))\n           (loop (rest lst)\n             \
    \    (ref a)\n                 (+ b 1))\n           ]\n          [else\n     \
    \      (loop (rest lst)\n                 (ref a)\n                 (ref b))\n\
    \           ]\n          )\n      )\n    )\n", "  (define (largest-smallest l)\n\
    \    (cond\n      [(empty? l) '()]\n      [(< l (car l)) (cons (car l) '())]\n\
    \      [(> l (car l)) (largest-smallest (cdr l))]\n      [else (largest-smallest\
    \ l)]\n      ))\n  (largest-smallest lst))\n", "  (if (empty? lst)\n      (list\
    \ None None)\n      (let ((largest (car lst)))\n        (if (<= largest 0)\n \
    \           (let ((smallest (cadr lst)))\n              (cons (list None None)\n\
    \                    (largest-smallest-integers smallest)))\n            (let\
    \ ((smallest (caddr lst)))\n              (cons (list None None)\n           \
    \         (largest-smallest-integers smallest)))\n            (let ((largest (caddr\
    \ lst)))\n              (cons (list None None)\n                    (largest-smallest-integers\
    \ largest)))))))\n", "  (cond\n    [(empty? lst) '()]\n    [else (let ((largest\
    \ (max (car lst) 0))\n                (smallest (min (car lst) 0)))\n        \
    \    (cons (if (< smallest largest)\n                       smallest\n       \
    \                largest)\n                   (largest_smallest_integers (cdr\
    \ lst))))]))\n", "  (cond\n    ((null? lst) (list None None))\n    ((< 0 (car\
    \ lst)) (list (car lst) (largest lst)))\n    ((> (car lst)) (list (car lst) smallest\
    \ (cdr lst)))\n    (else (list (car lst) (largest lst) smallest (cdr lst))))\n\
    \  )\n", "  (if (or (null? lst) (= 0 (length lst)))\n      (cond (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<????>))\n        (<????> (<????>))\n        (<????> (<????>))\n\
    \        (<????> (<???", "  (cond [(empty? lst) (list (list 'none 'none))]\n \
    \       [else (let ([largest (foldr (lambda (x y)\n                          \
    \             (if (< y x)\n                                           y\n    \
    \                                       x))\n                                \
    \ (first lst)\n                                 0))\n                  (smallest\
    \ (foldr (lambda (x y)\n                                       (if (< x y)\n \
    \                                          x\n                               \
    \            y))\n                                 (first lst)\n             \
    \                    0))])\n           (cond [(< largest smallest)\n         \
    \         (list (cons largest smallest) (first lst))\n                  (list\
    \ 'none 'none)]\n                 [else\n                  (list (cons smallest\
    \ largest) (first lst))\n                  (list 'none 'none)]]))))", "  (cond\n\
    \    ;; If there is only one element, return it as is.\n    ((= 1 (length lst))\
    \ lst)\n    ;; If there are multiple negative and positive numbers, return the\n\
    \    ;; one with the largest absolute value first. Return None for\n    ;; the\
    \ others.\n    ((< 0 (car lst)) (largest_smallest_integers (cdr lst)))\n    ((=\
    \ 0 (car lst)) (largest_smallest_integers (cdr lst)))\n    ((> (abs (car lst))\
    \ (abs (car lst))) (largest_smallest_integers (cdr lst)))\n    ((< (abs (car lst))\
    \ (abs (car lst))) (largest_smallest_integers (cdr lst)))\n    ;; If there are\
    \ multiple negative and positive numbers, return the one\n    ;; with the smallest\
    \ absolute value first. Return None for the\n    ;; others.\n    ((< 0 (car lst))\
    \ (smallest_largest_integers (cdr lst)))\n    ((= 0 (car lst)) (smallest_largest_integers\
    \ (cdr lst)))\n    ((> (abs (car lst)) (abs (car lst))) (smallest_largest_integers\
    \ (cdr lst)))\n    ((< (abs (car lst)) (abs (car lst))) (smallest_largest_integers\
    \ (cdr lst)))\n    ;; If there are multiple negative and positive numbers, return\
    \ the\n    ;; one with the largest absolute value first. Return None for the\n\
    \    ;; others.\n    ((< 0 (car lst)) (largest_smallest_integers (cdr lst)))\n\
    \    ((= 0 (car lst)) (largest_smallest_integers (cdr lst)))\n    ((> (abs (car\
    \ lst)) (abs (car lst))) (largest_smallest_integers (cdr lst)))\n    ((< (abs\
    \ (car lst)) (abs (car lst))) (largest_smallest_integers (cdr lst)))\n    ;; If\
    \ there are multiple negative and positive numbers, return the\n    ;; one with\
    \ the smallest absolute value first. Return None for the\n    ;; others.\n   \
    \ ((< 0 (car lst)) (smallest_largest_integers (cdr lst)))\n    ((= 0 (car lst))\
    \ (smallest_largest_integers (cdr lst)))\n    ((> (abs (car lst)) (abs (car lst)))\
    \ (smallest_largest_integers (cdr lst)))\n    ((< (abs (car lst)) (abs (car ",
  "  (cond\n    ((empty? lst) '(None None))\n    ((> (first lst) 0) (cons (first lst)\
    \ (largest_smallest_integers (rest lst))))\n    (else (largest_smallest_integers\
    \ (rest lst)))))\n", "  (cond\n    [(empty? lst) (list None None None None)]\n\
    \    [(<= (first lst) 0) (list None None None (first lst))]\n    [else (list (first\
    \ lst) (largest_smallest_integers (rest lst)))]))\n", "  (cond\n    ((empty? lst)\
    \ (list None None))\n    ((= (length? lst) 0) (list None None))\n    ((< (length?\
    \ lst) 1) (list None lst))\n    ((= (length? lst) 2) (list (max (first lst) (second\
    \ lst)) (minux (first lst) (second lst))))\n    (else (list (max (first lst) (second\
    \ lst)) (minux (first lst) (second lst)) (largest_smallest_integers (rest lst))))))\n",
  "  (define (helper lst acc)\n    (cond\n      [(empty? lst)\n       acc]\n     \
    \ [(integer? (car lst))\n       (helper (cdr lst) (cons (car lst) acc))]\n   \
    \   [else\n       (helper (cdr lst) (cons (car lst) (max (helper (cdr lst) acc))))]))\n\
    \  (let ([a (helper (reverse lst) '())]\n        [b (helper (reverse lst) '())])\n\
    \    (cond\n      [(empty? a) (list->atomic a)]\n      [else (let ([a (list->atomic\
    \ a)]\n                 [b (list->atomic b)])\n               (list a b))]))))\n",
  "  (cond [(null? lst) (cons nil nil)] \n        [(positive? (car lst)) (cons (car\
    \ lst) (largest_smallest_integers (cdr lst)))] \n        [(negative? (car lst))\
    \ (cons (car lst) (largest_smallest_integers (cdr lst)))] \n        [else (cons\
    \ (car lst) (largest_smallest_integers (cdr lst)))]))\n", "  (let ((head (first\
    \ lst)))\n    (cond\n      [(number? (rest lst)) (list (first lst) head)]\n  \
    \    [(number? head) (list (first lst) head)]\n      [else (largest_smallest_integers\
    \ (rest lst))]))))\n", "  (cond [(null? lst) (cons None (cons None lst))]\n  \
    \      [(number? (car lst))\n         (cons (cons car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n        [else (largest_smallest_integers (cdr lst))]))\n", " \
    \ (cond [(empty? lst) (list (none? 0 1 None None))]\n        [(<= (car lst) 0)\
    \ (list (car lst) None)]\n        [else (list (car lst) (smallest-neg lst))]))\n",
  "  (cond [(null? lst) '()]\n        [(< (car lst) 0)\n         (largest_smallest_integers\
    \ (cdr lst))]\n        [else (list (car lst) (smallest-negative (cdr lst)))]))\n",
  "  (cond [(empty? lst)\n         (list->pair (none? lst) (none? lst))\n        \
    \ ]\n        [else\n         (list->pair (max (rest lst)) (min (rest lst)))]))\n",
  "  (cond\n    [(empty? lst) (list None None)]\n    [else (max <empty>\n        \
    \        (min <empty>\n                 (car lst)\n                 (largest_smallest_integers\
    \ (cdr lst))))]))\n", "  (cond\n    ((null? lst) (listof null))\n    ((negative?\
    \ (car lst)) (listof (max lst (car lst))))\n    ((positive? (car lst)) (listof\
    \ (min lst (car lst))))\n    ((cons? lst) (list (largest_smallest_integers (car\
    \ lst))\n                       (largest_smallest_integers (cdr lst))))))\n",
  "  (let loop ((lst lst)\n             (max -Inf)\n             (min -Inf))\n   \
    \ (cond [(empty? lst) (cons (list None min) '())]\n          [(cons? lst) (loop\
    \ (rest lst)\n                          (max max (first lst))\n              \
    \            (min min))]))))\n", "  (cond [(null? lst) '()]\n        [(and (number?\
    \ (car lst))\n               (< (cdr lst) 0))\n         (list (car lst) (car lst))]\n\
    \        [else\n         (append (largest_smallest_integers (cdr lst))\n     \
    \             (list (car lst)))]))\n", "  (cond\n    ((empty? lst) (list (lst\
    \ '()) (lst '())))\n    ((number? (first lst)) (largest_smallest_integers (rest\
    \ lst)))\n    ((> (first lst) (second lst)) (list (first lst) (second lst)))\n\
    \    (else (list (first lst) (second lst)))))\n", "  (let loop ((lst lst)\n  \
    \           (result (if (null? lst)\n                        (cons None None)\n\
    \                        (let ((largest (max 0 (first lst)))\n               \
    \                 (smallest (min 0 (first lst))))\n                          (cons\
    \ (if (< largest smallest)\n                                    largest\n    \
    \                                smallest)\n                                (loop\
    \ (rest lst)\n                                      (if (< smallest largest)\n\
    \                                          (cons smallest result)\n          \
    \                                result))))))\n    (if (null? lst)\n        result\n\
    \        (loop (rest lst)\n              result))))\n", "  (let loop ((lst lst)\
    \ (a -Int.MaxValue) (b +Int.MaxValue))\n    (cond\n      [(empty? lst) '(None\
    \ None)]\n      [(not (positive? (first lst)))\n       (loop (rest lst) a b)]\n\
    \      [else (loop (rest lst) (first lst) b)]))))\n", "  (cond [(null? lst) (cond\
    \ [(not (pair? null?)) (list (cons null? null?)) (list (list null? null?))] (cons\
    \ null? (largest_smallest_integers (cdr lst)))))]\n        [(> (car lst) 0) (list\
    \ (cons (car lst) null?) (largest_smallest_integers (cdr lst)))]\n        [else\
    \ (list (cons (car lst) null?) (largest_smallest_integers (cdr lst)))]))\n", " \
    \ (cond\n    ((null? lst) (list None None))\n    ((< (first lst) (first lst))\n\
    \     (list (first lst) (first lst)))\n    (else (list (max (first lst) (first\
    \ lst)) (minu (first lst) (first lst))))\n  )\n)\n</cell>\n<cell>\n#lang racket\n",
  "  (let loop ((lst lst))\n    (cond [(null? lst) (list (car 'lst) (null? 'lst))]\n\
    \          [(< car lst) (loop (cdr lst))]\n          [else (loop (cdr lst))]))))\n",
  "  (cond\n    [(null? lst) (list (list None None) (list None None))]\n    [(< (car\
    \ lst) 0)\n     (list None (max (cdr lst) 0))]\n    [(< (cdr lst) 0)\n     (list\
    \ (max (car lst) 0) None)]\n    [else (list (max (car lst) 0) (min (cdr lst) 0))]))\n\
    </code>\n<|/ a tags=scheme,racket |>\n<| c |>\nThanks for showing me `cond`. I've\
    \ never seen that before, and it looks like it will make my life so much easier\n\
    <|/ c |>\n<| c |>\nNote that `cond` is in the Racket standard library since R5RS,\
    \ which has had it for a few years now.\n<|/ c |>\n<| c |>\nOh cool. Looks like\
    \ I'm going to be using that from now on. Thanks!\n<|/ c |>\n<| a tags=scheme,racket\
    \ dscore=1 |>\nI believe you can achieve this using a single predicate and some\
    \ list operations:\n<code>", "  (cond [(null? lst) '(None None)]\n        [(>\
    \ (car lst) (abs (car lst)))\n         (let ((smallest (car lst)))\n         \
    \  (define (helper lst smallest)\n             (cond [(null? lst) '(None smallest)]\n\
    \                   [(< (car lst) smallest) (helper (cdr lst) smallest)]\n   \
    \                [else (helper (cdr lst) (min (car lst) (smallest))))]))\n   \
    \      (largest_smallest_integers (cdr lst))]))\n", "  (cond\n    ((null? lst)\
    \ '())\n    ((list? (car lst)) (cond\n                      ((>= (- (car lst)\
    \ (cadr lst)) (caddr lst)) (list (car lst) (cons (car lst) (caddr lst)))\n   \
    \                   (else (list (car lst) '()))\n                      )))\n \
    \   (else (cons (car lst) '(largest_smallest_integers (cdr lst))))))\n", "  (cond\n\
    \    [(empty? lst) (list None None)]\n    [(> (first lst) 0) (list (first lst)\
    \ None)]\n    [else (list (first lst) (first lst))]\n  ))\n", "  (cond ((null?\
    \ lst) (list 'None 'None))\n        ((< 0 (car lst)) (list (car lst) (smallest\
    \ (cdr lst))))\n        (else (list (max (car lst) (smallest (cdr lst))) (max\
    \ (car lst) (cdr (cdr lst)))))))\n", "  (cond\n    ((empty? lst) '())\n    ((<\
    \ (first lst) (first lst)) (first lst))\n    (else\n     (largest_smallest_integers\
    \ (rest lst))))))\n", "  (cond [(null? lst)\n         (cond [(null? (cdr lst))\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list\
    \ 'None)\n                (list 'None)\n                (list 'None)\n       \
    \         (list 'None)\n                (list 'None)\n                (list 'None)\n\
    \                (list 'None)\n                (list 'None)\n                (list ",
  "  (let ([minval (car lst)\n        maxval (cddr lst)\n        i (0)])\n    (cond\n\
    \      [(< minval maxval) (cons (cons minval maxval) (largest_smallest_integers\
    \ lst))]\n      [else (if (< i maxval) (cons (car lst) (largest_smallest_integers\
    \ lst)) \n                (cons (car lst) (largest_smallest_integers lst)))]\n\
    \      [else (if (< i maxval) (cons (car lst) (largest_smallest_integers lst))\
    \ \n                (cons (car lst) (largest_smallest_integers lst)))]\n     \
    \ [else (if (< i maxval) (cons (car lst) (largest_smallest_integers lst)) \n \
    \               (cons (car lst) (largest_smallest_integers lst)))]\n      [else\
    \ (if (< i maxval) (cons (car lst) (largest_smallest_integers lst)) \n       \
    \         (cons (car lst) (largest_smallest_integers lst)))]\n      [else (if\
    \ (< i maxval) (cons (car lst) (largest_smallest_integers lst)) \n           \
    \     (cons (car lst) (largest_smallest_integers lst)))]\n      [else (if (< i\
    \ maxval) (cons (car lst) (largest_smallest_integers lst)) \n                (cons\
    \ (car lst) (largest_smallest_integers lst)))]\n      [else (if (< i maxval) (cons\
    \ (car lst) (largest_smallest_integers lst)) \n                (cons (car lst)\
    \ (largest_smallest_integers lst)))]\n      [else (if (< i maxval) (cons (car\
    \ lst) (largest_smallest_integers lst)) \n                (cons (car lst) (largest_smallest_integers\
    \ lst)))]\n      [else (if (< i maxval) (cons (car lst) (largest_smallest_integers\
    \ lst)) \n                (cons (car lst) (largest_smallest_integers lst)))]\n\
    \      [else (if (< i maxval) (cons (car lst) (largest_smallest_integers lst))\
    \ \n                (cons (car lst) (largest_smallest_integers lst)))]\n     \
    \ [else (if (< i maxval) (cons (car lst) (largest_smallest_integers lst)) \n \
    \               (cons (car lst) (largest_smallest_integers lst)))]\n      [else\
    \ (if (< i max", "  (cond [(or (empty? lst)\n             (null? lst))\n     \
    \    (tuple (list* '() '()))]\n        [(or (< -# (first lst))\n             (>\
    \ -# (first lst)))\n         (tuple (append (list (first lst)) '()) (list (first\
    \ lst)))]\n        [else\n         (tuple (cons (first lst) '()) (list (first\
    \ lst)))]))\n", "  (if (or (null? lst)\n          (null? (cdr lst)))\n      (list\
    \ (car lst) (car lst))\n      (let ((a (max (car lst)\n                      (max\
    \ (cddr lst)\n                          (lambda (x) (not (number? (car x))))))))\n\
    \        (list (list a a)\n               (if (<= a 0)\n                   (list\
    \ (car lst) (car lst))\n                   (list (car lst)\n                 \
    \       (caddr lst)))))\n      ))", "  (cond [(null? lst) (list (none? 0))]\n\
    \        [(number? (car lst)) (list (car lst))]\n        [(negative? (car lst))\
    \ (list (car lst))]\n        [else (cons (largest-from-negative-integers (cdr\
    \ lst))\n                  (smallest-from-positive-integers lst))]\n        ))\n",
  "  (let ([\n          (max nil)\n          (min nil)\n          (found nil)])\n\
    \    (cond\n      [(empty? lst) nil]\n      [(>= (first lst) max) (cons (first\
    \ lst) found)]\n      [(= min (first lst)) (cons (first lst) found)]\n      [(<\
    \ min (first lst)) (let ([l (largest_smallest_integers (rest lst))])\n       \
    \                      (cons (first l) (first lst) found)\n                  \
    \           (max l))]))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice answer! The\
    \ answer from is better, though, since it avoids the quadratic behaviour of the\
    \ sort function from Racket in terms of number of elements in the list.\n<|/ c\
    \ |>\n<| c |>\nI agree and thanks for the upvote. My answer just provides a different\
    \ way of thinking about the problem.\n<|/ c |>\n<| a tags=racket,scheme dscore=0\
    \ |>\nHere is an answer in Scheme that doesn't involve using an auxiliary variable:\n\
    <code>", "  (cond\n    ((null? lst)\n     (list (car lst) (cdr lst)))\n    ((<\
    \ (car lst) (largest_smallest_integers lst))\n     (list (car lst) (largest_smallest_integers\
    \ (cdr lst))))\n    ((> (car lst) (largest_smallest_integers lst))\n     (list\
    \ (car lst) (largest_smallest_integers lst))))))\n", "  (if (empty? lst)\n   \
    \   (list None None)\n      (let ((first (car lst))\n            (second (cadr\
    \ lst)))\n        (let ((largest (max first second))\n              (smallest\
    \ (min first second)))\n          (if (and (< largest smallest)\n            \
    \      (not (= largest smallest)))\n            (list (cons largest smallest)\n\
    \                  (cons smallest largest))\n            (list (cons smallest\
    \ largest)\n                  (cons largest smallest)))))))\n", "  (cond [(null?\
    \ lst)\n         #f]\n        [(< 0 (car lst))\n         (largest_smallest_integers\
    \ (cdr lst))\n         (largest_smallest_integers (cdr lst))]\n        [(< (car\
    \ lst) (first lst))\n         (largest_smallest_integers lst)\n         (first\
    \ lst)]\n        [else (first lst)]))\n", "  (define (helper lst)\n    (if (empty?\
    \ lst)\n        (values none none)\n        (let ((a (first lst))\n          \
    \    (b (second lst))\n              (t (helper (rest lst))))\n          (if (<\
    \ a b)\n              (values a b)\n              (values b a)))))\n  (helper\
    \ (reverse lst)))", "  (cond\n    ((null? lst) '())\n    ((null? (cdr lst)) '(0\
    \ 0))\n    ((< (car lst) (car (cdr lst)))\n     (list (car lst) (min (car (cdr\
    \ lst)) (- 0))))\n    ((> (car lst) (car (cdr lst)))\n     (list (car lst) (max\
    \ (car (cdr lst)) (+ 0)))\n    ))", "  (let loop ((lst lst)\n             (acc\
    \ '()))\n    (cond\n      [(null? lst) (list? (first (head lst)))\n      (loop\
    \ (rest lst) (cons (first lst) acc))]\n      [(negative? (first lst)) (loop (rest\
    \ lst) (nth (rest lst) acc))]\n      [(positive? (first lst)) (loop (rest lst)\
    \ (cons (first lst) acc))]\n      [else (loop (rest lst) acc)])))\n", "  (cond\n\
    \    ((empty? lst) (list empty))\n    ((< 0 (first lst)) (list (first lst) (second\
    \ lst)))\n    (else (list (first lst) (largest_smallest_integers (rest lst)))))\n\
    )\n", "  (let loop ((lst lst)\n             (a #f (first lst))\n             (b\
    \ #f (second lst)))\n    (if (null? lst)\n        (cons (list a b)\n         \
    \     (list a (first lst) b (second lst)))\n        (let ((elt (first lst)))\n\
    \          (loop (rest lst)\n                (if (< elt a) (set! a (elt a))\n\
    \                    (set! b (elt b)))\n                (if (< elt (first lst))\
    \ (set! (first lst) elt)\n                    (set! (second lst) elt)))))\n  (loop\
    \ (rest lst)\n        (if (< a b) (list a b)\n            (list a (first lst)\
    \ b (second lst)))))\n", "  (cond [(empty? lst) '()]\n        [(or (empty? (rest\
    \ lst)) (< (first lst) (first lst))) '()]\n        [else (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]))\n", '  (cond [(empty? lst) (list None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None ', "  (let loop ((lst lst) (result '()))\n    (cond ((null? lst) result)\n\
    \          ((< (car lst) (cadr lst)) (loop (cdr lst) (cons (car lst) result)))\n\
    \          ((> (car lst) (cadr lst)) (loop (cdr lst) (cons (car lst) result)))\n\
    \          (else (loop (cdr lst) (cons (car lst) result)))))\n  (loop (reverse\
    \ lst) '()))\n", "  (cond\n    [(empty? lst)\n     (list->symbol 'None 'None)\n\
    \     ]\n    [(integer? lst)\n     (list->symbol 'None (min (integer-value lst)\
    \ (inexact->inexact 0)))]\n    [else\n     (let ((a (car lst))\n           (b\
    \ (cadddr lst)))\n       (cond [(< a b)\n               (list (cons a b))\n  \
    \             ]\n             [(< b a)\n               (list (cons b (- a)))\n\
    \               ]\n             [else (list->symbol a b)\n              ]\n  \
    \         )])) \n</code>\n<|/ a |>\n<| c |>\nThis is great! One question: if I\
    \ wanted to modify it to return a list of integers (not symbols), how would I\
    \ do that?\n<|/ c |>\n<| c |>\nJust replace the `symbol->list` function in the\
    \ second line with `list->int`\n<|/ c |>\n<| a tags=scheme,lisp,racket |>\nThe\
    \ question is similar to \u201CFind the smallest and largest number in a list\u201D\
    \ in Lisp.  I wrote a solution using Racket.\n<code>\n#lang racket\n", "  (cond\n\
    \    [(empty? lst) (cond [(< 0 (first lst)) (first lst)]\n                   \
    \         [(= 0 (first lst)) (second lst)]\n                            [(> 0\
    \ (first lst)) (second lst)]))]\n    [else (largest_smallest_integers (rest lst))]))\n",
  "  (if (null? lst)\n      (list None None)\n      (let ((a (max (car lst)))\n  \
    \          (b (min (car lst))))\n        (list (max a b) (min a b))))))\n", " \
    \ (cond [(empty? lst) (cond [(empty? lst) (list 'None)] [else (list 'None)]) ]\n\
    \        [(and (pair? lst) (negative? (car lst))) (cond [(empty? lst) (list 'None)]\
    \ [else (list 'None)]) ]\n        [(and (pair? lst) (positive? (car lst))) (cond\
    \ [(empty? lst) (list 'None)] [else (list 'None)]) ]\n        [else (cond [(empty?\
    \ lst) (list 'None)] [else (list (car lst) (largest-smallest lst))]) ]))\n", " \
    \ (let loop ((lst lst)\n             (first #f) (second #f) (largest (car lst))\n\
    \             (smallest #f))\n    (cond ((null? lst)\n           (cond ((and (not\
    \ first) (not second))\n                  (list first largest))\n            \
    \     ((and (not second) (not largest))\n                  (list second smallest))\n\
    \                 ((and (not first) (not largest) (not second))\n            \
    \      (list largest (cdr lst))))\n             (else\n               (loop (cdr\
    \ lst) (not first) (not second) (if (< car lst) largest (car lst)))\n        \
    \       (loop (cdr lst) (not second) (not largest) (if (< cdr lst) smallest (cdr\
    \ lst)))))))\n", "  (cond\n    [(null? lst)\n     (let ((a (first lst)) (b (second\
    \ lst)))\n       (list a b))]\n    [(< (first lst) (second lst))\n     (let ((a\
    \ (first lst)) (b (second lst)))\n       (list a b))\n     (largest_smallest_integers\
    \ (rest lst))]\n    [(> (first lst) (second lst))\n     (let ((a (first lst))\
    \ (b (second lst)))\n       (list a b))\n     (largest_smallest_integers (rest\
    \ lst))]\n    [else\n     (let ((a (first lst)) (b (second lst)))\n       (list\
    \ a b))]))\n", "  (cond\n    [(null? lst) (list (list None) (list None))]\n  \
    \  [else\n     (cond\n       [(< (first lst) 0) (list (first lst) (first lst))]\n\
    \       [(>= (first lst) 0) (list (first lst) (first lst))]\n       [(< (second\
    \ lst) 0) (list (second lst) (first lst))]\n       [(>= (second lst) 0) (list\
    \ (second lst) (first lst))]\n       [(< (third lst) 0) (list (third lst) (first\
    \ lst))]\n       [(>= (third lst) 0) (list (third lst) (first lst))]\n       [(<\
    \ (fourth lst) 0) (list (fourth lst) (first lst))]\n       [(>= (fourth lst) 0)\
    \ (list (fourth lst) (first lst))]\n       [(< (fifth lst) 0) (list (fifth lst)\
    \ (first lst))]\n       [(>= (fifth lst) 0) (list (fifth lst) (first lst))]\n\
    \       [(< (sixth lst) 0) (list (sixth lst) (first lst))]\n       [(>= (sixth\
    \ lst) 0) (list (sixth lst) (first lst))]\n       [(< (seventh lst) 0) (list (seventh\
    \ lst) (first lst))]\n       [(>= (seventh lst) 0) (list (seventh lst) (first\
    \ lst))]\n       [(< (eighth lst) 0) (list (eighth lst) (first lst))]\n      \
    \ [(>= (eighth lst) 0) (list (eighth lst) (first lst))]\n       [(< (ninth lst)\
    \ 0) (list (ninth lst) (first lst))]\n       [(>= (ninth lst) 0) (list (ninth\
    \ lst) (first lst))]\n       [(< (tenth lst) 0) (list (tenth lst) (first lst))]\n\
    \       [(>= (tenth lst) 0) (list (tenth lst) (first lst))]\n       [(< (eleventh\
    \ lst) 0) (list (eleventh lst) (first lst))]\n       [(>= (eleventh lst) 0) (list\
    \ (eleventh lst) (first lst))]\n       [(< (twelfth lst) 0) (list (twelfth lst)\
    \ (first lst))]\n       [(>= (twelfth lst) 0) (list (twelfth lst) (first lst))]\n\
    \       [(< (thirteenth lst) 0) (list (thirteenth lst) (first lst))]\n       [(>=\
    \ (thirteenth lst) 0) (list (thirteenth ", "  (cond ((null? lst) '(None, None))\n\
    \        ((< 0 (car lst)) (car lst))\n        (else (let ((a (largest_smallest_integers\
    \ (cdr lst))))\n                   (cond ((< a 0 (car lst)) (car lst))\n     \
    \                    (else a))))))\n", "  (cond [(empty? lst) (list (cdr null))\n\
    \        (and (not (= (car lst) 0)) (not (= (cadr lst) 0))) (list (list (car lst)\
    \ (cadr lst)))]\n        [(< (car lst) 0)  (list (list (car lst) (cadr lst)))\n\
    \         (and (not (= (cadr lst) 0)) (not (= (car lst) 0))) (list (car lst) (list\
    \ (cadr lst)))]\n        [else (list (car lst) (list (cdr lst)))]))\n", "  (cond\
    \ [(empty? lst) (list None) (lambda () (list (first lst)))]\n        [(list? (first\
    \ lst)) (cons (largest-smaller (first lst)) (largest_smallest_integers (rest lst)))]\n\
    \        [else (cons (first lst) (lambda () (largest_smallest_integers (rest lst))))]))\n",
  "  (cond [(null? lst) '(None None None None None None None)]\n        [(< 0 (car\
    \ lst)) (largest_smallest_integers (cdr lst))] \n        [else (largest_smallest_integers\
    \ (cdr lst))]))\n", "  (cond\n    [(empty? lst) (list (identity (first lst)) (identity\
    \ (first lst)))]\n    [(< (first lst) (first lst))\n     (list (identity (first\
    \ lst)) (identity (first lst)))]\n    [(> (first lst) (first lst))\n     (list\
    \ (identity (first lst)) (identity (first lst)))]\n    [else (list (first (first\
    \ lst)) (second (first lst)))]\n  ))", "  (cond ((null? lst) '())\n        ((or\
    \ (> lst (second lst))\n             (< lst (first lst)))\n         (list (second\
    \ lst) (first lst)))\n        (else (append (largest_smallest_integers (rest lst))\n\
    \                      (list (first lst) '())))))\n", "  (let loop ((lst (cdr\
    \ lst)))\n    (cond ((null? lst) '(None None))\n          ((or (<= (first lst)\
    \ 0)\n               (<= (first lst) (- (first lst) 1)))\n           (loop (cdr\
    \ lst)))\n          (else\n           (loop (cdr lst)))))\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nOh, I see what you mean now. Thanks, though, I think this will\
    \ be very helpful for me.\n<|/ c |>\n<| c |>\nI've added a version with `cond`\
    \ :)\n<|/ c |>\n<| a tags=racket,scheme |>\nHere is a simple and efficient solution\
    \ that doesn't use any library functions. It does not mutate or mutate in any\
    \ way the input list or create a temporary list.\n<code>", "  (let loop ((largest\
    \ '())\n             (smallest '()))\n    (if (null? lst)\n        (list smallest\
    \ largest)\n        (loop (max (car lst) (if (> (car lst) largest)\n         \
    \                        (car lst) largest))\n              (min (car lst) (if\
    \ (< (car lst) smallest)\n                                   (car lst) smallest))))))\n",
  "  (cond [(empty? lst) '()]\n        [(and (integer? (car lst)) (negative? (car\
    \ lst)))\n         (cons (car lst) (largest_smallest_integers (cdr lst)))]\n \
    \       [else (cons (car lst) '(None))]))\n", "  (let loop ((lst lst)\n      \
    \       (result (null? (sort lst <))\n                      (null? (sort lst >))))\n\
    \    (if (or (null? lst) (null? (cdr lst)))\n        (cons result (null? (cdr\
    \ result)))\n        (loop (cdr lst)\n              (cons (max lst result)\n \
    \                   (null? (sort lst <))\n                    result))))))\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>", "  (cond [(null? lst) (list (list None None)\
    \ )]\n        [(number? (car lst)) (list (car lst) (largest (cdr lst)))]\n   \
    \     [else (list (car lst) (nth-smallest (cdr lst) (car lst)))]))\n", "  (let\
    \ loop ((lst (cons (car lst) (cdr lst))\n                  (smallest '())\n  \
    \                (largest '()))\n             (i 0 (+ i 1))\n             (min\
    \ '(#f #f)))\n    (if (null? lst)\n        (cons (car min) (cons (car max) (cons\
    \ (car i) (cons (cdr i) (cdr min))))) (loop (cdr lst) (cons (car min) (cons (car\
    \ max) (cons (car i) (cons (cdr i) (cdr min))))) (cons (car min) (cons (car max)\
    \ (cons (car i) (cons (cdr i) (cdr min)))))))", "  (let ([pair (largest_smallest_integers\
    \ lst)])\n    (cond\n      [(pair? (car pair))\n       (cons (car pair) (largest_smallest_integers\
    \ (cdr pair)))]\n      [(< -10000 (car pair)) (cdr pair)]\n      [else pair])))\n",
  "  (cond\n    ;; Empty list\n    ((null? lst) '())\n    \n    ;; One or two elements\n\
    \    ((= (length lst) 1) (first lst))\n    ((= (length lst) 2) (first lst) (second\
    \ lst))\n    \n    ;; More than two elements\n    ((> (length lst) 2) (\n    \
    \  (max (largest_smallest_integers (rest lst)) (first lst))\n      (max (largest_smallest_integers\
    \ (rest lst)) (second lst))))))\n", "  (cond [(null? lst) '()]\n        [(and\
    \ (number? (car lst))\n               (>= (number? (car lst)) (number? (car lst))))\
    \ '()]\n        [else (cons (car lst) (largest_smallest_integers (cdr lst)))]))\n",
  "  (cond [(empty? lst) (list () ())]\n        [(number? (car lst)) (cons (car lst)\
    \ ())]\n        [(list? (car lst)) (cons (largest_smallest_integers (car lst))\n\
    \                                 (largest_smallest_integers lst))]\n        [else\
    \ (list (cons (car lst) (largest_smallest_integers lst)))]))\n", "  (let ((largest\
    \ (first (sort lst <))\n          smallest (first (sort lst (< largest first))))))\n\
    \    (cond\n      [(empty? lst)\n       (list (list None smallest))]\n      [(>\
    \ largest first)\n       (list (list largest smallest))]\n      [else (list (list\
    \ largest smallest) (list largest first))])))\n", "  (let loop ((lst lst) (max-i\
    \ max-i-tmp) (min-i min-i-tmp) (a-tmp a-tmp-tmp) (acc '(None None)))\n    (cond\n\
    \      [(null? lst) acc]\n      [(< (first lst) (first acc)) (loop (rest lst)\
    \ (first lst) (second lst) (cons (first lst) (second acc)))]\n      [(> (first\
    \ lst) (first acc)) (loop (rest lst) (second lst) (first lst) (cons (first acc)\
    \ (second lst)))]\n      [else (loop (rest lst) (third lst) (first lst) (cons\
    \ (first acc) (fourth lst)))]))))\n", "  (cond\n    [(null? lst) '()]\n    [(<\
    \ 0 (car lst))\n     (cons (car lst) (largest_smallest_integers (cdr lst)))]\n\
    \    [else (largest_smallest_integers (cdr lst))]))\n", "  (cond\n    [(empty?\
    \ lst) (list None None)\n     (else (let ([a (first lst)])\n               (cond\n\
    \                [(< (first lst) a) (list (first lst) (first lst))]\n        \
    \        [else (list a (first lst))])))]\n    [else (largest_smallest_integers\
    \ (rest lst))]\n   ))\n", "  (cond\n    [(empty? lst) ()]\n    [(pair? lst) \n\
    \     (let ((largest (car lst)))\n       (cond\n         [(< largest 0) (list\
    \ None largest)]\n         [else (list largest (car lst))]))]\n    [else (largest_smallest_integers\
    \ (cdr lst))]))\n", "  (cond\n    ((null? lst) '(None None))\n    ((< (car lst)\
    \ 0) (car lst))\n    (else (largest_smallest_integers (cdr lst)))))\n", "  (cond\n\
    \    [(empty? lst) (list None None None)]\n    [else (let ((min (first lst)))\n\
    \             (let ((max (rest lst)))\n               (list (min (- max (first\
    \ lst)))\n                     (first lst)\n                     (max (- min (first\
    \ lst))))])]))\n", "  (if (null? lst)\n      (list None None)\n      (let ((a\
    \ (apply max lst)))\n        (let ((b (apply min lst)))\n          (if (< a b)\n\
    \              (list a b)\n              (list b a))))))\n", "  (cond\n    [(empty?\
    \ lst) (list nil nil)]\n    [else (let ((x (first lst))\n              (y (second\
    \ lst))\n              (a (largest-integer lst)))\n            (cond\n       \
    \       [(empty? a) (list nil nil)]\n              [(< (first a) 0) (list (first\
    \ a) nil)]\n              [(< (first a) (first y)) (list (first a) y)]\n     \
    \         [(< (first a) (first y)) (list (first x) (a))]\n              [(>= (first\
    \ a) (first y)) (list (first x) (a) (second x))]\n              [else (list (first\
    \ x) (second x))])])]))\n", "  (cond\n    ((empty? lst)\n     (list (list None\
    \ None)\n           (list None None)))\n    ((< 0 (first lst) (first lst))\n \
    \    (list (first lst)\n           (first lst)))\n    ((> (first lst) (first lst))\n\
    \     (list (first lst)\n           (first lst)))\n    ((< (first lst) (first\
    \ lst))\n     (list (first lst)\n           (first lst)))\n    ((> (first lst)\
    \ (first lst))\n     (list (first lst)\n           (first lst)))\n    (else (largest_smallest_integers\
    \ (rest lst)))))\n", "  (cond\n    ((empty? lst) (list '() '()))\n    ((> (first\
    \ lst) 0) (list (first lst) (first lst))\n     (list (first lst) (largest_smallest_integers\
    \ (rest lst))))\n    ((< (first lst) 0) (list (first lst) '())\n     (list (first\
    \ lst) (smallest_largest_integers (rest lst))))))\n", "  (cond\n    [(empty? lst)\
    \ (cond (empty? lst) (cond (empty? lst) (cons (list empty) empty) (list (list\
    \ empty empty)))\n                     (else (cons (list empty) empty)))]\n  \
    \  [(> first lst) (list (first lst) (largest_smallest_integers (rest lst)))]\n\
    \    [else (list (first lst) (largest_smallest_integers (rest lst)))]))\n", " \
    \ (cond\n    [(empty? lst) (list None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None ", "  (cond\n\
    \    ((null? lst) (list None None))\n    ((<= (first lst) (first lst (cdr lst)))\n\
    \     (list (first lst) (first lst (cdr lst))))\n    (else\n     (list (first\
    \ lst) (largest_smallest_integers (rest lst)))))\n", "  (let ((max-int (min (max\
    \ 0 lst)\n                       (reduce + (map (lambda (x) (if (< x 0) (- x)\
    \ x))\n                                   lst))))\n        (min-int (max (min\
    \ 0 lst)\n                       (reduce - (map (lambda (x) (if (< x 0) (- x)\
    \ x))\n                                   lst)))))\n    (cond ((and (not (or (<\
    \ min-int 0) (< max-int 0))\n                       (null? lst))\n           \
    \ (list (list max-int min-int) '()))\n          ((and (not (or (< max-int 0) (<\
    \ min-int 0))\n                       (null? lst))\n            (list max-int\
    \ min-int))\n          ((< min-int max-int)\n            (list (list max-int min-int))\n\
    \          ((< max-int min-int)\n            (list max-int min-int))\n       \
    \   (else (list max-int min-int))))))\n", "  (cond [(empty? lst) '()]\n      \
    \  [(< 0 (first lst)) (first lst)]\n        [else (first lst)]))\n", "  (define\
    \ (helper lst x y) (cond [(empty? lst) (list x y)]\n                         \
    \   [(< x (car lst)) (helper (cdr lst) x (cdr y))]\n                         \
    \   [(< y (car lst)) (helper (cdr lst) (car y) (cons (car lst) y))]))\n  (helper\
    \ lst nil nil))\n", "  (let loop ((lst lst)\n             (min (minimum lst))\n\
    \             (max (maximum lst))\n             (count 0))\n    (cond [(null?\
    \ lst)\n           (list min max count)]\n          [(< min (first lst))\n   \
    \        (loop (rest lst)\n                 (first lst)\n                 (first\
    \ lst)\n                 (add1 count))]\n          [(> max (first lst))\n    \
    \       (loop (rest lst)\n                 (first lst)\n                 (first\
    \ lst)\n                 (add1 count))]\n          [else\n           (loop (rest\
    \ lst)\n                 (first lst)\n                 (first lst)\n         \
    \        (add1 count))]))\n", "  (if (or (null? lst) (null? (cdr lst)))\n    \
    \  null\n      (let ((largest (max (car lst) (abs (car lst)))) (smallest (min\
    \ (car lst) (abs (car lst))))) (list (list largest smallest) \n              \
    \                                    (largest_smallest_integers (cdr lst))))))\n",
  "  (cond [(empty? lst) None]\n        [(cons? lst) \n         (let ((a (largest_integer\
    \ (first lst))\n                 (b (smallest_integer (first lst))))\n       \
    \        (rest lst))\n           (cond [(< a b)\n                  (list a b (rest\
    \ lst))]\n                 [(> a b)\n                  (list b (first lst) (first\
    \ lst))]\n                 [else (list (first lst) a (rest lst))]))]\n       \
    \ [else (let ((a (largest_integer (first lst))\n                       (b (smallest_integer\
    \ (first lst))))\n                 (rest lst))\n               (cond [(< a b)\n\
    \                      (list a b (rest lst))]\n                     [(> a b)\n\
    \                      (list b (first lst) (first lst))]\n                   \
    \  [else (list (first lst) a (rest lst))])]))))\n", "  (cond\n    [(empty? lst)\
    \ (list (list (list)))]\n    [(>= (first lst) 0) (list (list (first lst)))]\n\
    \    [else (list (first lst) (largest_smallest_integers (rest lst)))]\n  )\n)\n",
  "  (cond\n    [(empty? lst) (list (list nil 0))]\n    [else (list (cons (max (rest\
    \ lst)) (first lst)))]\n  )\n)\n", "  (cond\n    ((null? lst) (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (cons None (cons\
    \ None (cons None (cons None (cons None (cons None (cons None (", "  (let loop\
    \ ((lst lst)\n             (result (list (pair? lst) (number? lst))))\n    (cond\n\
    \      [(empty? lst) (return result)]\n      [(pair? (car lst))\n       (loop\
    \ (cdr lst)\n             (cons (max (car lst) (car result))\n               \
    \    result))]\n      [else (loop (cdr lst)\n                  (cons (min(car\
    \ lst) (car result))\n                        result))])))\n", "  (cond\n    [(empty?\
    \ lst) (list (none) (none))]\n    [(= 0 (first lst)) (list (none) (first lst))]\n\
    \    [else (let ([x (first lst)])\n              (cond\n                [(= 0\
    \ (second lst)) (list (x x) (first lst))]\n                [else (let ([y (nth\
    \ (rest lst) 1)])\n                         (list (max x y) (nth lst 0))])])]))]))\n",
  "  (let loop ((lst lst)\n             (max 0)\n             (min 0))\n    (cond\
    \ [(empty? lst) '()]\n          [else (loop (rest lst)\n                     \
    \  (cond [(< max 0)\n                              (loop (rest lst) (max 0 (car\
    \ lst)))]\n                                [else max]\n                      \
    \         [(< min 0)\n                               (loop (rest lst) (min 0 (car\
    \ lst)))]\n                                [else min]\n                      \
    \         [(< max 0)\n                               (loop (rest lst) (max 0 (car\
    \ lst)) min)]\n                                [else max]\n                  \
    \             [(< min 0)\n                               (loop (rest lst) (min\
    \ 0 (car lst)) max)]\n                                [else min])])))\n", "  (cond\n\
    \     ;; If there's no list, there's nothing to do.\n     ;; The empty list is\
    \ (None, None).\n     ((empty? lst) (None, None)\n       ;; If there is one positive\
    \ integer, there's nothing to do.\n       ;; The smallest possible positive integer\
    \ is 0.\n       ;; the smallest possible negative integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest integer is 0.\n       ;; The\
    \ smallest integer is 0.\n       ;; The smallest ", "  (cond\n    [(empty? lst)\n\
    \     (list (none? (car lst))\n           (car lst))]\n    [(positive? (car lst))\n\
    \     (cons (car lst)\n           (largest_smallest_integers (cdr lst)))]\n  \
    \  [(negative? (car lst))\n     (cons (car lst)\n           (largest_smallest_integers\
    \ (cdr lst)))]\n    [else\n     (largest_smallest_integers (cdr lst))]))\n", " \
    \ (cond [(empty? lst) (list None None)]\n        [(cons? lst) (let ((a (max (car\
    \ lst) (- (car lst)))))\n                         (let ((b (min (car lst) (+ (car\
    \ lst) 1))))\n                           (cons (cons a b) \n                 \
    \                (largest_smallest_integers (cdr lst)))\n                    \
    \       )])\n        [else (largest_smallest_integers (cdr lst))]))\n", "  (cond\n\
    \    [(empty? lst) '(None None)]\n    [(integer? (car lst)) (car lst)]\n    [else\
    \ (let ([first (largest_smallest_integers (cdr lst))]\n               [second\
    \ (smallest_largest_integers lst)])\n             (cond\n              [(< second\
    \ first) first]\n              [(< first second) second])))]))\n", "  (let loop\
    \ ((numbers '()))\n    (cond\n      ((null? lst)\n       (list '() (first numbers))\n\
    \       (first numbers))\n      ((< first numbers)\n       (loop (cons (first\
    \ numbers) numbers)\n             (rest lst)))\n      ((< first numbers)\n   \
    \    (loop (cons (first numbers) numbers)\n             (rest lst)))\n      (else\n\
    \       (loop (cons (first numbers) numbers)\n             (rest lst)))\n    \
    \  (else\n       (loop numbers (rest lst))))))\n", "  (let loop ((lst lst) (a\
    \ #f) (b #f))\n    (if (empty? lst)\n      (cond ((not a) (not b)) (list a b))\n\
    \      (let ((first (car lst)))\n        (cond\n          ((< first a) (loop (cdr\
    \ lst) (first a) (first b)))\n          ((< first b) (loop (cdr lst) (first a)\
    \ (first b)))\n          (else (loop (cdr lst) (first a) (first b)))))))\n", " \
    \ (cond\n    [(empty? lst) '(None None)]\n    [(not (pair? lst)) '(None None)]\n\
    \    [else (let ((x (car lst)) (y (car (cdr lst))))\n            (cond\n     \
    \         [(< y x) '(x y)]\n              [(< x y) '(y x)]\n              [(>\
    \ x y) '(y x)]\n              [(> y x) '(x y)]\n              [else (largest_smallest_integers\
    \ (cdr lst))]))]))\n", "  (cond [(empty? lst) (list None None)]\n        [(positive?\
    \ (car lst)) (let ([a (largest_smallest_integers (cdr lst))])\n              \
    \                 (list a (car lst)))]\n        [(negative? (car lst)) (let ([b\
    \ (largest_smallest_integers (cdr lst))])\n                               (list\
    \ b (car lst)))]\n        [else (list (largest_smallest_integers (cdr lst)) (largest_smallest_integers\
    \ (cdr lst))))]))\n", "  (let loop ((lst lst)\n             (largest 0)\n    \
    \         (smallest 0))\n    (cond\n      [(null? lst) (list (cons largest smallest)\
    \ '())]\n      [(< (car lst) largest) (loop (cdr lst) (car lst) smallest)]\n \
    \     [(< (car lst) smallest) (loop (cdr lst) largest (car lst))]\n      [else\
    \ (loop (cdr lst) largest (car lst))])))\n", "  (if (null? lst)\n      `(None,\
    \ None)\n      (let ((a (max (car lst) (- (car lst))))\n            (b (min (car\
    \ lst) (+ (car lst) 1))))\n        (list a b))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=2 |>\n<| c |>\nYes I agree that my code is not particularly efficient.\
    \  But this is an exercise that I'm learning on Scheme, and I haven't learned\
    \ any fancy tricks.  So I want to figure out how to solve this problem without\
    \ using fancy tricks.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution that doesn't\
    \ use any fancy tricks. Rather, it makes use of helper procedures. \nThe idea\
    \ is to take advantage of the fact that lists have a maximum element and minimum,\
    \ which can be determined using max-list and min-list.\nThe first helper procedure\
    \ that takes a list and an index as input, and returns the maximum element of\
    \ that list, and that element:\n<code>", "  (define (largest-smallest lst)\n \
    \   (if (empty? lst)\n        (cond ((< (car lst) 0))\n              ((< (car\
    \ lst) (cdr lst)))\n              (else (largest-smallest (cdr lst))))))\n  (largest-smallest\
    \ lst))\n", "  (cond ((null? lst)\n         #f)\n        ((< (first lst) (second\
    \ lst))\n         (first lst))\n        (else (second lst)))) ;; (first (second))\
    \ is better than (first #f)\n", "  (define (largest_smallest_integers lst prev)\n\
    \    (cond\n      [(empty? lst) (list (not (positive? prev)) (positive? prev))]\n\
    \      [(= (first lst) 0) (list (not (positive? prev)) (positive? prev))]\n  \
    \    [(< prev (first lst)) (list (not (positive? prev)) (positive? prev))\n  \
    \      (cons (first lst) (largest_smallest_integers (rest lst) (first lst)))]\n\
    \      [else (list (not (positive? prev)) (positive? prev))]))\n  (largest_smallest_integers\
    \ lst 0))\n", "  (cond ((null? lst) (list '() (quote ())))\n        ((and (< 0\
    \ (car lst)) (< 0 (cdr lst)))\n         (list (car (cdr lst))\n              \
    \ (quote (#f nil))\n               (largest_smallest_integers (cdr lst)))\n  \
    \      ((and (> 0 (car lst)) (> 0 (cdr lst)))\n         (list (car (cdr lst))\n\
    \               (largest_smallest_integers (cdr lst))\n               (quote (#f\
    \ nil)))\n        (else (list (car (cdr lst))\n                    (largest_smallest_integers\
    \ (cdr lst))\n                    (quote (#f nil)))))\n  ", "  (cond\n    [(empty?\
    \ lst) (list (list None None) (list None None))]\n    [(or (< first lst) (< second\
    \ lst))\n     (list (list (first lst) (second lst)) (list (second lst) None))]\n\
    \    [else (list (first lst) (second lst))]))\n", '  (cond [(empty? lst) (list
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None None None None None None None None None None
    None None None None None None None ', "  (cond\n    [(empty? lst) (list None None\
    \ None None None None None None None)]\n    [else\n     (let ([head (car lst)]\n\
    \           (tail (cdr lst)))\n       (cond\n         [(> head 0) (cons (- head\
    \ head) (largest_smallest_integers tail))]\n         [(< head 0) (largest_smallest_integers\
    \ tail)]\n         [else (largest_smallest_integers (cdr lst))]))]))\n", "  (let\
    \ loop ((largs #:null) (smals #:null) (lst lst)\n             (max 0))\n    (cond\n\
    \      [(null? lst) #:null]\n      [(not (number? (first lst))) #:null]\n    \
    \  [(> (first lst) max) #:null]\n      [(< (first lst) max) (loop (first lst)\
    \ (cons (first lst) smals)\n                                (cons (first lst)\
    \ smals) (+ max 1)))]\n      [(< (first lst) max) (loop (cons (first lst) smals)\n\
    \                                (cons (first lst) smals) (+ max 1)))]\n     \
    \ [(> (first lst) max) (loop (first lst) (cons (first lst) smals)\n          \
    \                      (cons (first lst) smals) max)]\n      [else (loop (first\
    \ lst) smals (cons (first lst) smals) max)])))\n", "  (cond [(null? lst) '()]\n\
    \        [(integer? (car lst)) (cons (car lst)\n                             \
    \       (largest_smallest_integers (cdr lst)))]\n        [else (cons (largest_smallest_integers\
    \ lst)\n                    (largest_smallest_integers (cdr lst)))]))\n", "  (cond\
    \ [(null? lst) (list->symbol (symbol->list (symbol->string '(null))))]\n     \
    \   [(< 0 (car lst)) (list (symbol->string (car lst)))]\n        [else (list (symbol->string\
    \ (car lst)))]))\n", "  (cond [(null? lst) '(None None)]\n        [(< 0 (car lst))\
    \ (largest_smallest_integers (cdr lst))]\n        [else (largest_smallest_integers\
    \ (cdr lst))]\n))\n", "  (cond [(null? lst) (list (none))]\n        [(< (first\
    \ lst) 0)\n         (list (first lst) (inf (first lst)))]\n        [else (list\
    \ (first lst) (inf (first lst)))]))\n", "  (let loop ((largest-negative-integer\
    \ null) (smallest-positive null))\n    (cond ((null? lst) (reverse (append smallest\
    \ largest)))\n          ((< (first lst) largest-negative-integer) (loop (first\
    \ lst) (first lst)))\n          (else (loop (first lst) (loop (rest lst) (first\
    \ lst))))))\n  (cond ((null? largest-negative-integer) (null? (rest smallest-positive)))\n\
    \        (else (cons (first largest-negative-integer) (append smallest largest))))))\n",
  "  (cond\n    ((null? lst) '())\n    ((< (car lst) 0) (largest_smallest_integers\
    \ (cdr lst)))\n    (else (cons (car lst) (largest_smallest_integers (cdr lst))))))\
    \ ; cons is a function defined in the DrRacket language to cons two lists together",
  "  (cond\n    [(empty? lst) (list None None)]\n    [(member? (first lst) '(0 1))\
    \ \n     (cons \n      (max (first lst) (- (first lst) (second lst))) \n     \
    \ (min (first lst) (second lst)))]\n    [else (largest_smallest_integers (rest\
    \ lst))]))\n", "  (define (helper lst acc -min -max)\n    (cond\n      [(empty?\
    \ lst) (list acc min)]\n      [(integer? (car lst))\n       (helper (cdr lst)\
    \ (car acc) (car lst) (car acc))]\n      [else (helper (cdr lst) (cons (car acc)\
    \ acc) min max)]))\n  (if (empty? lst)\n      (list '() '())\n      (helper (cdr\
    \ lst) '() '() '())))\n", "  (cond\n    [(empty? lst) (list None None)]\n    [else\
    \ (let ((a (max-negative-number-in-list lst))\n                 (b (min-positive-number-in-list\
    \ lst)))]\n        [(or (null? a)\n             (null? b))\n         (list None\
    \ None)]\n    [else (let ((a (max-negative-number-in-list lst))\n            \
    \     (b (min-positive-number-in-list lst)))]\n        [(and (not (number? a))\n\
    \               (not (number? b)))\n         (list None None)]\n    [else (let\
    \ ((a (max-negative-number-in-list lst))\n                 (b (min-positive-number-in-list\
    \ lst)))]\n        [(and (not (number? b))\n               (not (number? a)))\n\
    \         (list None None)]\n    [else (let ((a (max-negative-number-in-list lst))\n\
    \                 (b (min-positive-number-in-list lst)))]\n        [(and (not\
    \ (number? a))\n               (not (number? b)))\n         (list a b)])))\n",
  "  (define (largest-smallest lst)\n    (cond\n      [(empty? lst) (list None None)]\n\
    \      [(not (number? (car lst))) (list None None)]\n      [else (list (max 0\
    \ (car lst)) (min 1 (car lst)))))]))\n  (largest-smallest lst))\n", "  (cond [(null?\
    \ lst) (list (none))]\n        [(negative? (car lst))\n         (let ([smallest\
    \ (car lst)]\n               [largest (cadddr lst)])\n           (cond [(null?\
    \ smallest) (list (none))]\n                 [(null? largest) (list (none))]\n\
    \                 [else (cons (cadddr lst)\n                            (list\
    \ (cadddr lst) smallest\n                                  largest))]))]\n   \
    \     [else (cons (car lst)\n                   (largest_smallest_integers (cdr\
    \ lst)))]))))\n", "  (cond\n    ((null? lst)\n      (list (cons None 0) (cons\
    \ None 0)))\n    ((< (car lst) 0)\n      (list (cons None 0) (cons (car lst) 0)))\n\
    \    ((< (car lst) (car (cdr lst)))\n      (list (cons (car lst) 0) (cons (car\
    \ lst) (car (cdr lst))))))\n", "  (cond [(null? lst) (list (null? (car lst)) (null?\
    \ (cdr lst)))]\n        [else (largest_smallest_integers (cdr lst))]))\n", " \
    \ (cond\n    [(empty? lst) (none?)] \n    [(> (first lst) 0)\n     (list (max\
    \ 0 (first lst))\n           (first lst))]\n    [(< (first lst) 0)\n     (list\
    \ (first lst)\n           (max 0 (first lst)))]\n    [else (list (first lst)\n\
    \               (min 0 (first lst)))]))\n", "  (cond\n    [(null? lst) (list (none?\
    \ 0) (none? 0))]\n    [(integer? (first lst)) (list (first lst) (first lst))]\n\
    \    [else (cons (first lst) (largest_smallest_integers (rest lst)))]))\n", " \
    \ (define (helper lst max)\n    (cond\n      [(empty? lst) (list (reverse max)\
    \ empty)]\n      [(> (first lst) (first max)) (recur (rest lst) (cons (first lst)\
    \ max))]\n      [else (recur (rest lst) (cons (first lst) (first max)))]))\n \
    \ (helper lst empty))\n", "  (cond [(empty? lst) (cons None None)] [\n    (and\
    \ (>= (first lst) (second lst))\n         (< (length (rest lst)) (length (rest\
    \ lst))))\n     (cons (first lst) (largest_smallest_integers (rest lst)))]\n \
    \   [else (largest_smallest_integers (rest lst))]))\n</cell>\n<text>\nExercise\n\
    Write a function is_palindrome that takes a list of characters and returns True\
    \ or False depending on whether the list of characters is a palindrome. Print\
    \ the function out in scheme and check it works.\n\n\n</text>\n<cell>", "  (cond\n\
    \    ((null? lst) '()) ; there are no negative integers\n    ((< 0 (car lst) (cadr\
    \ lst)) (cons (car lst) (largest_smallest_integers (cdr lst))))\n    ((< 0 (car\
    \ lst) (cadr lst)) (cons (car lst) (largest_smallest_integers (cdr lst))))\n \
    \   (else (cons (car lst) (largest_smallest_integers (cdr lst))))))\n", "  (if\
    \ (null? lst)\n      (list None None)\n    (let ((x (car lst))\n          (y (largest_smallest_integers\
    \ (cdr lst))))\n      (if (< (+ x y) 0)\n          (list x y)\n          (list\
    \ None y)))))\n", "  (define (helper lst a b result)\n    (cond\n      [(empty?\
    \ lst) result]\n      [(< a (first lst)) (helper (rest lst) a b (cons a result))]\n\
    \      [(< b (first lst)) (helper (rest lst) a b (cons b result))]\n      [else\
    \ (helper (rest lst) (first lst) b (cons (a) (first result)))]\n    )\n  )\n \
    \ (helper lst '#f '#f (list '#f '#f))\n)\n", "  (cond\n    [(null? lst) (list\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None None None None None None None None None None None\
    \ None None None None None None ", "  (let loop ((lst (rest lst))\n          \
    \   (max-pos (car lst))\n             (min-pos (cdr lst)))\n    (cond ((null?\
    \ lst)\n           (list max-pos min-pos))\n          ((< max-pos min-pos)\n \
    \          (loop (rest lst) max-pos (car lst)))\n          ((< min-pos max-pos)\n\
    \           (loop (rest lst) min-pos (cdr lst))))))\n", "  (cond ((null? lst)\
    \ '())\n        ((< 0 (car lst))\n         (cons (car lst) (largest_smallest_integers\
    \ (cdr lst))))\n        ((< (car lst) 0) (cons (car lst) (largest_smallest_integers\
    \ (cdr lst))))\n        (else (largest_smallest_integers (cdr lst)))))\n", " \
    \ (cond\n    [(empty? lst)\n     (values None None)] [(positive? (first lst))\n\
    \                           (largest lst)]\n    [else\n     (values (first lst)\
    \ (smallest (rest lst)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
