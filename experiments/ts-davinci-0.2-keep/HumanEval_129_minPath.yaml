name: HumanEval_129_minPath
language: humaneval_to_typescript.py
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered lists of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered list of the values on the cells that the minimum\
  \ path go through.\n// Examples:\n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]],\
  \ k = 3\n// Output: [1, 2, 1]\n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k\
  \ = 1\n// Output: [1]\nfunction minPath(grid: number[][], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let l = 0; l\
    \ < k; l++) {\n        dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let\
    \ i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] =\
    \ grid[i][j];\n    }\n  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0;\
    \ i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        if (i > 0) {\n \
    \         dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n\
    \        if (i < n - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "    const n = grid.length;\n    const m = grid[0].length;\n    const\
    \ dp: number[][][] = [];\n    const path: number[][][] = [];\n    for (let i =\
    \ 0; i < n; i++) {\n        dp[i] = [];\n        path[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            dp[i][j] = [];\n            path[i][j] = [];\n\
    \            for (let l = 0; l < k; l++) {\n                dp[i][j][l] = Infinity;\n\
    \                path[i][j][l] = -1;\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dp[i][j][0] = grid[i][j];\n        }\n    }\n    for (let l = 1; l < k; l++)\
    \ {\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < m;\
    \ j++) {\n                for (let di = -1; di <= 1; di++) {\n               \
    \     for (let dj = -1; dj <= 1; dj++) {\n                        if (di === 0\
    \ && dj === 0) {\n                            continue;\n                    \
    \    }\n                        const ni = i + di;\n                        const\
    \ nj = j + dj;\n                        if (ni < 0 || ni >= n || nj < 0 || nj\
    \ >= m) {\n                            continue;\n                        }\n\
    \                        if (dp[ni][nj][l - 1] < dp[i][j][l]) {\n            \
    \                dp[i][j][l] = dp[ni][nj][l - 1];\n                          \
    \  path[i][j][l] = ni * m + nj;\n                        }\n                 \
    \   }\n                }\n            }\n        }\n    }\n    let min = Infinity;\n\
    \    let minI = -1;\n    let minJ = -1;\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j", "    const n = grid.length;\n    const m = grid[0].length;\n\
    \    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const visited = new\
    \ Set<string>();\n    const queue = [[0, 0, grid[0][0], [grid[0][0]]]];\n    while\
    \ (queue.length) {\n        const [i, j, sum, path] = queue.shift()!;\n      \
    \  if (path.length === k) {\n            return path;\n        }\n        for\
    \ (const [di, dj] of dirs) {\n            const ni = i + di;\n            const\
    \ nj = j + dj;\n            if (ni < 0 || ni >= n || nj < 0 || nj >= m) {\n  \
    \              continue;\n            }\n            const key = `${ni},${nj}`;\n\
    \            if (visited.has(key)) {\n                continue;\n            }\n\
    \            visited.add(key);\n            queue.push([ni, nj, sum + grid[ni][nj],\
    \ [...path, grid[ni][nj]]]);\n        }\n    }\n    return [];\n}\n", "  const\
    \ n = grid.length;\n  const m = grid[0].length;\n  const dp: number[][][] = [];\n\
    \  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j < m;\
    \ j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i = 0; i < n; i++) {\n\
    \    for (let j = 0; j < m; j++) {\n      for (let l = 0; l < k; l++) {\n    \
    \    dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++)\
    \ {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] = grid[i][j];\n    }\n\
    \  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0; i < n; i++) {\n   \
    \   for (let j = 0; j < m; j++) {\n        if (i > 0) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n        if (i < n\
    \ - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let l = 0; l\
    \ < k; l++) {\n        dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let\
    \ i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] =\
    \ grid[i][j];\n    }\n  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0;\
    \ i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        if (i > 0) {\n \
    \         dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n\
    \        if (i < n - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let l = 0; l\
    \ < k; l++) {\n        dp[i][j][l] = Number.MAX_SAFE_INTEGER;\n      }\n    }\n\
    \  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n   \
    \   dp[i][j][0] = grid[i][j];\n    }\n  }\n  for (let l = 1; l < k; l++) {\n \
    \   for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n     \
    \   if (i > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n        }\n        if (i < n - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j - 1][l - 1]);\n        }\n        if (j < m\
    \ - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \        }\n      }\n    }\n  }\n  let min = Number.MAX_SAFE_INTEGER;\n  let minI\
    \ = -1;\n  let", "  const n = grid.length;\n  const m = grid[0].length;\n  const\
    \ dp: number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n \
    \   for (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let\
    \ i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] =\
    \ grid[i][j];\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0;\
    \ j < m; j++) {\n      for (let l = 1; l < k; l++) {\n        const curr = grid[i][j];\n\
    \        const left = i > 0 ? dp[i - 1][j][l - 1] : Infinity;\n        const right\
    \ = i < n - 1 ? dp[i + 1][j][l - 1] : Infinity;\n        const up = j > 0 ? dp[i][j\
    \ - 1][l - 1] : Infinity;\n        const down = j < m - 1 ? dp[i][j + 1][l - 1]\
    \ : Infinity;\n        dp[i][j][l] = Math.min(curr, left, right, up, down);\n\
    \      }\n    }\n  }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n\
    \  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if\
    \ (dp[i][j][k - 1] < min) {\n        min = dp[i][j][k - 1];\n        minI = i;\n\
    \        minJ = j;\n      }\n    }\n  }\n  const res: number[] = [];\n  for (let\
    \ l = k - 1; l >= 0; l--) {\n    res.push(dp[minI][minJ][l]);\n    const left\
    \ = minI >", "  const n = grid.length;\n  const m = grid[0].length;\n  const visited\
    \ = new Set<string>();\n  const queue = [[0, 0, [grid[0][0]]]];\n  let minPath:\
    \ number[] = [];\n  let minPathLen = Infinity;\n  while (queue.length) {\n   \
    \ const [i, j, path] = queue.shift()!;\n    if (path.length === k) {\n      if\
    \ (path.length < minPathLen) {\n        minPath = path;\n        minPathLen =\
    \ path.length;\n      } else if (path.length === minPathLen) {\n        if (path.join('')\
    \ < minPath.join('')) {\n          minPath = path;\n        }\n      }\n     \
    \ continue;\n    }\n    if (i > 0 && !visited.has(`${i - 1} ${j}`)) {\n      queue.push([i\
    \ - 1, j, [...path, grid[i - 1][j]]]);\n      visited.add(`${i - 1} ${j}`);\n\
    \    }\n    if (i < n - 1 && !visited.has(`${i + 1} ${j}`)) {\n      queue.push([i\
    \ + 1, j, [...path, grid[i + 1][j]]]);\n      visited.add(`${i + 1} ${j}`);\n\
    \    }\n    if (j > 0 && !visited.has(`${i} ${j - 1}`)) {\n      queue.push([i,\
    \ j - 1, [...path, grid[i][j - 1]]]);\n      visited.add(`${i} ${j - 1}`);\n \
    \   }\n    if (j < m - 1 && !visited.has(`${i} ${j + 1}`)) {\n      queue.push([i,\
    \ j + 1, [...path, grid[i][j + 1]]]);\n      visited.add(`${i} ${j + 1}`);\n \
    \   }\n  }\n  return minPath;\n}\n\nconsole.log(minPath([[1, 2, 3], [4, 5, 6],",
  "  const n = grid.length;\n  const m = grid[0].length;\n  const dp: number[][][]\
    \ = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0;\
    \ j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i = 0; i < n; i++)\
    \ {\n    for (let j = 0; j < m; j++) {\n      for (let l = 0; l < k; l++) {\n\
    \        dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let i = 0; i < n;\
    \ i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] = grid[i][j];\n\
    \    }\n  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0; i < n; i++)\
    \ {\n      for (let j = 0; j < m; j++) {\n        if (i > 0) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n        if (i < n\
    \ - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let l = 0; l\
    \ < k; l++) {\n        dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let\
    \ i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] =\
    \ grid[i][j];\n    }\n  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0;\
    \ i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        if (i > 0) {\n \
    \         dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n\
    \        if (i < n - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "    const n = grid.length;\n    const m = grid[0].length;\n    const\
    \ dp: number[][][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n         \
    \   for (let l = 0; l < k; l++) {\n                dp[i][j][l] = Infinity;\n \
    \           }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            dp[i][j][0] = grid[i][j];\n        }\n\
    \    }\n    for (let l = 1; l < k; l++) {\n        for (let i = 0; i < n; i++)\
    \ {\n            for (let j = 0; j < m; j++) {\n                for (let di =\
    \ -1; di <= 1; di++) {\n                    for (let dj = -1; dj <= 1; dj++) {\n\
    \                        if (di === 0 && dj === 0) {\n                       \
    \     continue;\n                        }\n                        const ni =\
    \ i + di;\n                        const nj = j + dj;\n                      \
    \  if (ni < 0 || ni >= n || nj < 0 || nj >= m) {\n                           \
    \ continue;\n                        }\n                        dp[i][j][l] =\
    \ Math.min(dp[i][j][l], dp[ni][nj][l - 1]);\n                    }\n         \
    \       }\n            }\n        }\n    }\n    let min = Infinity;\n    let minI\
    \ = -1;\n    let minJ = -1;\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k - 1] < min) {\n           \
    \     min = dp[i][j][k - 1];\n                minI = i;\n                minJ\
    \ = j;\n            }\n        }\n    }\n    const res: number[] = [];\n    for\
    \ (let l", "  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] = grid[i][j];\n\
    \    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++)\
    \ {\n      for (let l = 1; l < k; l++) {\n        dp[i][j][l] = Infinity;\n  \
    \      if (i > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (i < n - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n        }\n        if (j < m\
    \ - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \        }\n      }\n    }\n  }\n  let min = Infinity;\n  let minI = -1;\n  let\
    \ minJ = -1;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++)\
    \ {\n      if (dp[i][j][k - 1] < min) {\n        min = dp[i][j][k - 1];\n    \
    \    minI", "  const n = grid.length;\n  const m = grid[0].length;\n  const visited\
    \ = new Set<string>();\n  const queue = [[0, 0, 0, [grid[0][0]]]];\n  let minPath\
    \ = [];\n  while (queue.length) {\n    const [i, j, pathLength, path] = queue.shift();\n\
    \    if (pathLength === k) {\n      if (!minPath.length || path.join('') < minPath.join(''))\
    \ {\n        minPath = path;\n      }\n      continue;\n    }\n    if (i - 1 >=\
    \ 0 && !visited.has(`${i - 1}-${j}`)) {\n      visited.add(`${i - 1}-${j}`);\n\
    \      queue.push([i - 1, j, pathLength + 1, [...path, grid[i - 1][j]]]);\n  \
    \  }\n    if (i + 1 < n && !visited.has(`${i + 1}-${j}`)) {\n      visited.add(`${i\
    \ + 1}-${j}`);\n      queue.push([i + 1, j, pathLength + 1, [...path, grid[i +\
    \ 1][j]]]);\n    }\n    if (j - 1 >= 0 && !visited.has(`${i}-${j - 1}`)) {\n \
    \     visited.add(`${i}-${j - 1}`);\n      queue.push([i, j - 1, pathLength +\
    \ 1, [...path, grid[i][j - 1]]]);\n    }\n    if (j + 1 < m && !visited.has(`${i}-${j\
    \ + 1}`)) {\n      visited.add(`${i}-${j + 1}`);\n      queue.push([i, j + 1,\
    \ pathLength + 1, [...path, grid[i][j + 1]]]);\n    }\n  }\n  return minPath;\n\
    }\n\nconsole.log(minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)); // [1, 2, 1]\n\
    console.", "    const n = grid.length;\n    const m = grid[0].length;\n    const\
    \ visited = new Set<string>();\n    const queue = [[0, 0, 0, []]];\n    let minPath\
    \ = [];\n    while (queue.length > 0) {\n        const [i, j, pathLength, path]\
    \ = queue.shift();\n        if (pathLength === k) {\n            if (minPath.length\
    \ === 0 || path < minPath) {\n                minPath = path;\n            }\n\
    \            continue;\n        }\n        if (i < 0 || i >= n || j < 0 || j >=\
    \ m) {\n            continue;\n        }\n        const key = `${i},${j}`;\n \
    \       if (visited.has(key)) {\n            continue;\n        }\n        visited.add(key);\n\
    \        const newPath = [...path, grid[i][j]];\n        queue.push([i - 1, j,\
    \ pathLength + 1, newPath]);\n        queue.push([i + 1, j, pathLength + 1, newPath]);\n\
    \        queue.push([i, j - 1, pathLength + 1, newPath]);\n        queue.push([i,\
    \ j + 1, pathLength + 1, newPath]);\n    }\n    return minPath;\n}\n", "  const\
    \ n = grid.length;\n  const m = grid[0].length;\n  const dp: number[][][] = [];\n\
    \  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j < m;\
    \ j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i = 0; i < n; i++) {\n\
    \    for (let j = 0; j < m; j++) {\n      for (let l = 0; l < k; l++) {\n    \
    \    dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++)\
    \ {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] = grid[i][j];\n    }\n\
    \  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0; i < n; i++) {\n   \
    \   for (let j = 0; j < m; j++) {\n        if (i > 0) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n        if (i < n\
    \ - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let l = 0; l\
    \ < k; l++) {\n        dp[i][j][l] = Infinity;\n      }\n    }\n  }\n  for (let\
    \ i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      dp[i][j][0] =\
    \ grid[i][j];\n    }\n  }\n  for (let l = 1; l < k; l++) {\n    for (let i = 0;\
    \ i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        if (i > 0) {\n \
    \         dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n        }\n\
    \        if (i < n - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  let min = Infinity;\n  let minI = -1;\n  let minJ = -1;\n  for (let i =\
    \ 0; i < n", "  const n = grid.length;\n  const m = grid[0].length;\n  const dp:\
    \ number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for\
    \ (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i === 0 && j\
    \ === 0) {\n        dp[i][j][0] = grid[i][j];\n      } else if (i === 0) {\n \
    \       dp[i][j][0] = dp[i][j - 1][0] + grid[i][j];\n      } else if (j === 0)\
    \ {\n        dp[i][j][0] = dp[i - 1][j][0] + grid[i][j];\n      } else {\n   \
    \     dp[i][j][0] = Math.min(dp[i - 1][j][0], dp[i][j - 1][0]) + grid[i][j];\n\
    \      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j <\
    \ m; j++) {\n      for (let l = 1; l < k; l++) {\n        if (i === 0 && j ===\
    \ 0) {\n          dp[i][j][l] = grid[i][j];\n        } else if (i === 0) {\n \
    \         dp[i][j][l] = dp[i][j - 1][l] + grid[i][j];\n        } else if (j ===\
    \ 0) {\n          dp[i][j][l] = dp[i - 1][j][l] + grid[i][j];\n        } else\
    \ {\n          dp[i][j][l] = Math.min(dp[i - 1][j][l], dp[i][j - 1][l]) + grid[i][j];\n\
    \        }\n      }\n   ", "  const n = grid.length;\n  const m = grid[0].length;\n\
    \  const dp: number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] =\
    \ [];\n    for (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n \
    \ for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for\
    \ (let l = 0; l < k; l++) {\n        dp[i][j][l] = Number.MAX_SAFE_INTEGER;\n\
    \      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j <\
    \ m; j++) {\n      dp[i][j][0] = grid[i][j];\n    }\n  }\n  for (let l = 1; l\
    \ < k; l++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m;\
    \ j++) {\n        if (i > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n        }\n        if (i < n - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n        }\n        if (j > 0)\
    \ {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j - 1][l - 1]);\n   \
    \     }\n        if (j < m - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n  }\n  let min = Number.MAX_SAFE_INTEGER;\n\
    \  let minI = -1;\n  let", "  const n = grid.length;\n  const m = grid[0].length;\n\
    \  const dp: number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] =\
    \ [];\n    for (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n \
    \ for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for\
    \ (let l = 0; l < k; l++) {\n        dp[i][j][l] = Number.MAX_SAFE_INTEGER;\n\
    \      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j <\
    \ m; j++) {\n      dp[i][j][0] = grid[i][j];\n    }\n  }\n  for (let l = 1; l\
    \ < k; l++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m;\
    \ j++) {\n        if (i > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n        }\n        if (i < n - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n        }\n        if (j > 0)\
    \ {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j - 1][l - 1]);\n   \
    \     }\n        if (j < m - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n  }\n  let min = Number.MAX_SAFE_INTEGER;\n\
    \  let minI = -1;\n  let", "  const n = grid.length;\n  const m = grid[0].length;\n\
    \  const dp: number[][][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] =\
    \ [];\n    for (let j = 0; j < m; j++) {\n      dp[i][j] = [];\n    }\n  }\n \
    \ for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for\
    \ (let l = 0; l < k; l++) {\n        dp[i][j][l] = Number.MAX_SAFE_INTEGER;\n\
    \      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j <\
    \ m; j++) {\n      dp[i][j][0] = grid[i][j];\n    }\n  }\n  for (let l = 1; l\
    \ < k; l++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m;\
    \ j++) {\n        if (i > 0) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n        }\n        if (i < n - 1) {\n          dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n        }\n        if (j > 0)\
    \ {\n          dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j - 1][l - 1]);\n   \
    \     }\n        if (j < m - 1) {\n          dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n  }\n  let min = Number.MAX_SAFE_INTEGER;\n\
    \  let minI = -1;\n  let"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
