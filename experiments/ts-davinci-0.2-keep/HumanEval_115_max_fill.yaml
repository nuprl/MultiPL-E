completions:
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
  \    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
  \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count\
  \ += capacity;\n            }\n            if (j === max) {\n                count\
  \ += capacity;\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    // max_fill(grid, capacity) = max_fill(grid, capacity\
  \ - 1) + max_fill(grid, 1)\n    // max_fill(grid, 1) = sum(grid[i][j])\n    // max_fill(grid,\
  \ capacity - 1) = max_fill(grid, capacity - 2) + max_fill(grid, 1)\n    // max_fill(grid,\
  \ capacity - 2) = max_fill(grid, capacity - 3) + max_fill(grid, 1)\n    // ...\n\
  \    // max_fill(grid, capacity - (capacity - 1)) = max_fill(grid, capacity - capacity)\
  \ + max_fill(grid, 1)\n    // max_fill(grid, capacity - capacity) = 0\n    // max_fill(grid,\
  \ capacity) = capacity * max_fill(grid, 1)\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                result++;\n            }\n        }\n    }\n    return\
  \ result * capacity;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill + 1;\n}\n"
- "    let result = 0;\n    let row_max = 0;\n    let col_max = 0;\n    let row_count\
  \ = grid.length;\n    let col_count = grid[0].length;\n    for (let row = 0; row\
  \ < row_count; row++) {\n        for (let col = 0; col < col_count; col++) {\n \
  \           if (grid[row][col] === 1) {\n                row_max = Math.max(row_max,\
  \ row);\n                col_max = Math.max(col_max, col);\n            }\n    \
  \    }\n    }\n    for (let row = 0; row <= row_max; row++) {\n        for (let\
  \ col = 0; col <= col_max; col++) {\n            if (grid[row][col] === 1) {\n \
  \               result += capacity;\n            }\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1],\
  \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]],\
  \ 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill\
  \ += 1;\n            } else {\n                if (fill > max_fill) {\n        \
  \            max_fill = fill;\n                }\n                fill = 0;\n  \
  \          }\n        }\n        if (fill > max_fill) {\n            max_fill =\
  \ fill;\n        }\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let rows = grid.length;\n    let cols = grid[0].length;\n    let total_water\
  \ = 0;\n    let total_fill = 0;\n    for (let i = 0; i < rows; i++) {\n        let\
  \ row_water = 0;\n        for (let j = 0; j < cols; j++) {\n            row_water\
  \ += grid[i][j];\n        }\n        total_water += row_water;\n        total_fill\
  \ += Math.ceil(row_water / capacity);\n    }\n    return total_fill;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    let rows = grid.length;\n    let cols = grid[0].length;\n\
  \    let row_max = new Array(rows).fill(0);\n    let col_max = new Array(cols).fill(0);\n\
  \    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols;\
  \ col++) {\n            row_max[row] = Math.max(row_max[row], grid[row][col]);\n\
  \            col_max[col] = Math.max(col_max[col], grid[row][col]);\n        }\n\
  \    }\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col\
  \ < cols; col++) {\n            result += Math.min(row_max[row], col_max[col]) -\
  \ grid[row][col];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_fill = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                row_fill++;\n       \
  \     }\n        }\n        result += Math.ceil(row_fill / capacity);\n    }\n \
  \   return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    let row_max = 0;\n    for (let row of grid) {\n      \
  \  row_max = Math.max(row_max, Math.max(...row));\n    }\n    for (let i = 0; i\
  \ < row_max; i++) {\n        for (let j = 0; j < grid.length; j++) {\n         \
  \   if (grid[j][i] === 1) {\n                result++;\n                grid[j][i]\
  \ = 0;\n            }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j\
  \ = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n               \
  \ fill++;\n            }\n        }\n        max_fill = Math.max(max_fill, fill);\n\
  \        result += fill;\n    }\n    return result - max_fill;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   max_fill = 0;\n        for (let well of row) {\n            if (well === 1)\
  \ {\n                max_fill++;\n            } else {\n                if (max_fill\
  \ > 0) {\n                    result += max_fill;\n                    max_fill\
  \ = 0;\n                }\n            }\n        }\n        if (max_fill > 0) {\n\
  \            result += max_fill;\n        }\n    }\n    return result;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell == 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  let well = grid[row];\n        let fill = 0;\n        for (let i = 0; i < well.length;\
  \ i++) {\n            if (well[i] === 1) {\n                fill++;\n          \
  \  }\n        }\n        result += Math.ceil(fill / capacity);\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let count = 0;\n    \
  \    for (let cell of row) {\n            if (cell === 1) {\n                count++;\n\
  \            } else {\n                if (count > 0) {\n                    result\
  \ += Math.ceil(count / capacity);\n                    count = 0;\n            \
  \    }\n            }\n        }\n        if (count > 0) {\n            result +=\
  \ Math.ceil(count / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, capacity - grid[i][j]);\n       \
  \     }\n        }\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let\
  \ row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                fill++;\n           \
  \ }\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    return\
  \ max_fill;\n}"
- "    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        let fill = 0;\n        for (let j = 0; j < grid[i].length; j++)\
  \ {\n            if (grid[i][j] === 1) {\n                fill++;\n            }\n\
  \        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    for (let i\
  \ = 0; i < grid.length; i++) {\n        let fill = 0;\n        for (let j = 0; j\
  \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
  \  fill++;\n            }\n        }\n        result += max_fill - fill;\n    }\n\
  \    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]],\
  \ 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\n\
  console.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            fill += cell;\n            if (fill ===\
  \ capacity) {\n                result++;\n                fill = 0;\n          \
  \  }\n        }\n        if (fill > 0) {\n            result++;\n        }\n   \
  \ }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
  \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            fill += cell;\n            if (fill ===\
  \ capacity) {\n                result++;\n                fill = 0;\n          \
  \  }\n        }\n        if (fill > 0) {\n            result++;\n        }\n   \
  \ }\n    return result;\n}\n\nconsole.log(1, max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1));\nconsole.log(6, max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(0, max_fill([[0, 0, 0], [0, 0, 0]],\
  \ 5));"
- "    let result = 0;\n    let n = grid.length;\n    let m = grid[0].length;\n  \
  \  let max_fill = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
  \ j < m; j++) {\n            if (grid[i][j] === 1) {\n                max_fill =\
  \ Math.max(max_fill, j);\n            }\n        }\n        result += max_fill;\n\
  \        max_fill = 0;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let\
  \ fill = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if\
  \ (grid[i][j] === 1) {\n                fill++;\n            }\n        }\n    \
  \    max_fill = Math.max(max_fill, fill);\n    }\n    return max_fill;\n}"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(6, max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(5, max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(0, max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_fill = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                row_fill++;\n       \
  \     }\n        }\n        result += Math.ceil(row_fill / capacity);\n    }\n \
  \   return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_height = 0;\n    for (let row of grid) {\n   \
  \     max_height = Math.max(max_height, Math.max(...row));\n    }\n    for (let\
  \ i = 0; i < max_height; i++) {\n        let row_fill = 0;\n        for (let row\
  \ of grid) {\n            for (let j = 0; j < row.length; j++) {\n             \
  \   if (row[j] > 0) {\n                    row[j]--;\n                    row_fill++;\n\
  \                }\n            }\n        }\n        result += Math.ceil(row_fill\
  \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let max = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] > max) {\n                max = row[j];\n          \
  \  }\n        }\n        result += max;\n    }\n    return result * capacity;\n\
  }\n\nconsole.log(0, max_fill([[0, 0, 0], [0, 0, 0]], 5));\nconsole.log(5, max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(6, max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
  \ === 1) {\n                result += capacity;\n            }\n        }\n    }\n\
  \    return result;\n}"
- "    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                max_fill = Math.max(max_fill, j);\n            }\n \
  \       }\n        count += max_fill;\n        max_fill = 0;\n    }\n    return\
  \ count;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
  \ === 1) {\n                result += capacity;\n            }\n        }\n    }\n\
  \    return result;\n}\n"
- "    let result = 0;\n    let row_count = grid.length;\n    let col_count = grid[0].length;\n\
  \    for (let row = 0; row < row_count; row++) {\n        for (let col = 0; col\
  \ < col_count; col++) {\n            if (grid[row][col] === 1) {\n             \
  \   grid[row][col] = 0;\n                result++;\n                let bucket =\
  \ capacity;\n                let row_index = row;\n                while (bucket\
  \ > 0 && row_index < row_count) {\n                    if (grid[row_index][col]\
  \ === 1) {\n                        grid[row_index][col] = 0;\n                \
  \        bucket--;\n                    }\n                    row_index++;\n  \
  \              }\n            }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                max_fill = Math.max(max_fill, j);\n            }\n \
  \       }\n        result += max_fill;\n        max_fill = Math.max(0, max_fill\
  \ - capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill_count = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                fill_count++;\n     \
  \       }\n        }\n        result += Math.ceil(fill_count / capacity);\n    }\n\
  \    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
  \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        for (let cell of row)\
  \ {\n            max_fill = Math.max(max_fill, cell);\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, i);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let result = 0;\n    let max_height = 0;\n    for (let row of grid) {\n   \
  \     let height = 0;\n        for (let cell of row) {\n            if (cell ===\
  \ 1) {\n                height++;\n            }\n        }\n        max_height\
  \ = Math.max(max_height, height);\n    }\n    for (let i = 0; i < max_height; i\
  \ += capacity) {\n        result++;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        let\
  \ row_max = Math.max(...row);\n        if (row_sum > capacity) {\n            result\
  \ += Math.ceil(row_sum / capacity) * row_max;\n        } else {\n            result\
  \ += row_max;\n        }\n    }\n    return result;\n}\n\nexport function main()\
  \ {\n    const res = max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1);\n    console.log(res);\n\
  }"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let col of row) {\n            fill += col;\n            if (fill === capacity)\
  \ {\n                result++;\n                fill = 0;\n            }\n     \
  \   }\n        if (fill > 0) {\n            result++;\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1],\
  \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]],\
  \ 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row = 0; row < grid.length;\
  \ row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n       \
  \     if (grid[row][col] === 1) {\n                max_fill = Math.max(max_fill,\
  \ row);\n            }\n        }\n    }\n    for (let row = 0; row < grid.length;\
  \ row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n       \
  \     if (grid[row][col] === 1) {\n                result += max_fill - row;\n \
  \           }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   for (let col of row) {\n            if (col === 1) {\n                max_fill++;\n\
  \            }\n        }\n    }\n    while (max_fill > 0) {\n        let current_fill\
  \ = 0;\n        for (let row of grid) {\n            for (let col of row) {\n  \
  \              if (col === 1) {\n                    current_fill++;\n         \
  \           col = 0;\n                }\n            }\n        }\n        max_fill\
  \ -= current_fill;\n        result++;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let max_fill = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                max_fill++;\n       \
  \     }\n        }\n        result += Math.ceil(max_fill / capacity);\n    }\n \
  \   return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row = 0; row < grid.length;\
  \ row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n       \
  \     if (grid[row][col] === 1) {\n                max_fill++;\n            }\n\
  \        }\n    }\n    for (let row = 0; row < grid.length; row++) {\n        for\
  \ (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
  \ === 1) {\n                result++;\n                grid[row][col] = 0;\n   \
  \             let fill = 1;\n                let bucket = capacity;\n          \
  \      while (bucket > 0 && fill < max_fill) {\n                    if (col + 1\
  \ < grid[row].length && grid[row][col + 1] === 1) {\n                        grid[row][col\
  \ + 1] = 0;\n                        fill++;\n                        bucket--;\n\
  \                    }\n                    if (col - 1 >= 0 && grid[row][col -\
  \ 1] === 1) {\n                        grid[row][col - 1] = 0;\n               \
  \         fill++;\n                        bucket--;\n                    }\n  \
  \                  if (row + 1 < grid.length && grid[row + 1][col] === 1) {\n  \
  \                      grid[row + 1][col] = 0;\n                        fill++;\n\
  \                        bucket--;\n                    }\n                    if\
  \ (row - 1 >= 0 && grid[row - 1][col] === 1) {\n                        grid[row\
  \ - 1][col] = 0;\n                        fill++;\n                        bucket--;\n\
  \                    }\n                }\n            }\n        }\n    }\n   \
  \ return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0)\
  \ {\n            result += row_max;\n            for (let j = 0; j < row.length;\
  \ j++) {\n                row[j] = Math.max(0, row[j] - capacity);\n           \
  \ }\n        }\n    }\n    return result;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            sum += row[j];\n        }\n        result += Math.ceil(sum / capacity);\n\
  \    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
  \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                max_fill++;\n\
  \            }\n        }\n    }\n    let fill = 0;\n    while (fill < max_fill)\
  \ {\n        fill = 0;\n        for (let row of grid) {\n            for (let well\
  \ of row) {\n                if (well === 1) {\n                    well = 0;\n\
  \                    fill++;\n                }\n            }\n        }\n    \
  \    result++;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill += capacity;\n            }\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
  \ === 1) {\n                result += capacity;\n            }\n        }\n    }\n\
  \    return result;\n}"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let count = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                count++;\n            }\n\
  \        }\n        result += Math.ceil(count / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        max_fill = Math.max(max_fill,\
  \ Math.max(...row));\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill = capacity;\n            } else {\n                fill--;\n\
  \            }\n            if (fill < 0) {\n                fill = 0;\n       \
  \     }\n        }\n        result += fill;\n    }\n    return result;\n}\n\nconsole.log(6,\
  \ max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(5, max_fill([[0,0,1,1],\
  \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(0, max_fill([[0,0,0], [0,0,0]],\
  \ 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   let fill = 0;\n        for (let cell of row) {\n            fill += cell;\n\
  \            if (fill > capacity) {\n                result += fill - capacity;\n\
  \                fill = capacity;\n            }\n        }\n        max_fill =\
  \ Math.max(max_fill, fill);\n    }\n    return result + max_fill;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  let max = 0;\n        for (let col = 0; col < grid[row].length; col++) {\n  \
  \          if (grid[row][col] === 1) {\n                max = col;\n           \
  \ }\n        }\n        if (max > 0) {\n            result += Math.ceil(max / capacity);\n\
  \        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                count++;\n            }\n        }\n        max = Math.max(max,\
  \ count);\n        count = 0;\n    }\n    return max * capacity;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill\
  \ += 1;\n            } else {\n                if (fill > max_fill) {\n        \
  \            max_fill = fill;\n                }\n                fill = 0;\n  \
  \          }\n        }\n        if (fill > max_fill) {\n            max_fill =\
  \ fill;\n        }\n    }\n    return max_fill;\n}\n"
- "    let total_fill = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n \
  \       for (let col of row) {\n            if (col === 1) {\n                total_fill++;\n\
  \            }\n        }\n        max_fill = Math.max(max_fill, total_fill);\n\
  \        total_fill = 0;\n    }\n    return max_fill;\n}"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                result += Math.floor(fill / capacity);\n\
  \                fill = 0;\n            }\n        }\n        result += Math.floor(fill\
  \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                max_fill++;\n\
  \            }\n        }\n    }\n    for (let row of grid) {\n        let fill\
  \ = 0;\n        for (let cell of row) {\n            if (cell === 1) {\n       \
  \         fill++;\n            }\n        }\n        if (fill === max_fill) {\n\
  \            result++;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    let max = 0;\n    for (let row of grid) {\n        max\
  \ = 0;\n        for (let i = 0; i < row.length; i++) {\n            if (row[i] ===\
  \ 1) {\n                max = i;\n            }\n        }\n        result += Math.ceil((max\
  \ + 1) / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0,\
  \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\n\
  console.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),\
  \ 5);\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5), 0);"
- "    let max_fill = 0;\n    for (let row of grid) {\n        for (let cell of row)\
  \ {\n            max_fill = Math.max(max_fill, cell);\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let row_max = 0;\n    let col_max = 0;\n    for (let i\
  \ = 0; i < grid.length; i++) {\n        row_max = 0;\n        for (let j = 0; j\
  \ < grid[i].length; j++) {\n            if (grid[i][j] > row_max) {\n          \
  \      row_max = grid[i][j];\n            }\n        }\n        result += row_max;\n\
  \    }\n    for (let j = 0; j < grid[0].length; j++) {\n        col_max = 0;\n \
  \       for (let i = 0; i < grid.length; i++) {\n            if (grid[i][j] > col_max)\
  \ {\n                col_max = grid[i][j];\n            }\n        }\n        result\
  \ += col_max;\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row = 0; row < grid.length;\
  \ row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n       \
  \     if (grid[row][col] === 1) {\n                max_fill++;\n            }\n\
  \        }\n    }\n    while (max_fill > 0) {\n        for (let row = 0; row < grid.length;\
  \ row++) {\n            for (let col = 0; col < grid[row].length; col++) {\n   \
  \             if (grid[row][col] === 1) {\n                    grid[row][col] =\
  \ 0;\n                    max_fill--;\n                    result++;\n         \
  \       }\n            }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] > max_fill)\
  \ {\n                max_fill = grid[i][j];\n            }\n        }\n    }\n \
  \   return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] > max_fill)\
  \ {\n                max_fill = grid[i][j];\n            }\n        }\n    }\n \
  \   return max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        for (let col of row)\
  \ {\n            max_fill = Math.max(max_fill, col);\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let curr_fill = 0;\n\
  \        for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n\
  \                curr_fill++;\n            } else {\n                if (curr_fill\
  \ > 0) {\n                    result += Math.ceil(curr_fill / capacity);\n     \
  \               curr_fill = 0;\n                }\n            }\n        }\n  \
  \      if (curr_fill > 0) {\n            result += Math.ceil(curr_fill / capacity);\n\
  \        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0],\
  \ [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]],\
  \ 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0)\
  \ {\n            result += row_max;\n            for (let j = 0; j < row.length;\
  \ j++) {\n                row[j] = Math.max(0, row[j] - capacity);\n           \
  \ }\n        }\n    }\n    return result;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let\
  \ fill = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if\
  \ (grid[i][j] === 1) {\n                fill++;\n            }\n        }\n    \
  \    max_fill = Math.max(max_fill, fill);\n    }\n    return max_fill;\n}"
- "    let max_fill = 0;\n    for (let row of grid) {\n        for (let well of row)\
  \ {\n            max_fill = Math.max(max_fill, well);\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let count = 0;\n    let max = 0;\n    let max_row = 0;\n    for (let i = 0;\
  \ i < grid.length; i++) {\n        let row = grid[i];\n        let row_count = 0;\n\
  \        for (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n\
  \                row_count++;\n            }\n        }\n        if (row_count >\
  \ max) {\n            max = row_count;\n            max_row = i;\n        }\n  \
  \  }\n    let row = grid[max_row];\n    for (let i = 0; i < row.length; i++) {\n\
  \        if (row[i] === 1) {\n            count++;\n        }\n    }\n    for (let\
  \ i = 0; i < grid.length; i++) {\n        if (i === max_row) {\n            continue;\n\
  \        }\n        let row = grid[i];\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                count++;\n          \
  \  }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2), 5);\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5), 0);"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let count = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                count++;\n            }\n\
  \        }\n        result += Math.ceil(count / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                max_fill\
  \ += capacity;\n            }\n        }\n    }\n    while (max_fill > 0) {\n  \
  \      for (let row of grid) {\n            for (let well of row) {\n          \
  \      if (well === 1) {\n                    well = 0;\n                    max_fill--;\n\
  \                }\n            }\n        }\n        result++;\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           result += capacity;\n            }\n        }\n    }\n    return result;\n\
  }"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  let row_sum = 0;\n        for (let col = 0; col < grid[row].length; col++) {\n\
  \            row_sum += grid[row][col];\n        }\n        result += Math.ceil(row_sum\
  \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let result = 0;\n  \
  \  let max_fill = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
  \ j < m; j++) {\n            if (grid[i][j] === 1) {\n                max_fill =\
  \ Math.max(max_fill, j);\n            }\n        }\n        result += max_fill;\n\
  \        max_fill = Math.max(0, max_fill - capacity);\n    }\n    return result;\n\
  }\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let n: number = grid.length;\n    let m: number = grid[0].length;\n    let\
  \ result: number = 0;\n    for (let i: number = 0; i < n; i++) {\n        let sum:\
  \ number = 0;\n        for (let j: number = 0; j < m; j++) {\n            sum +=\
  \ grid[i][j];\n        }\n        result += Math.ceil(sum / capacity);\n    }\n\
  \    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]],\
  \ 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\n\
  console.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                count++;\n            }\n        }\n        max_fill\
  \ = Math.max(max_fill, count);\n        count = 0;\n    }\n    return max_fill *\
  \ capacity;\n}"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  let filled = 0;\n        for (let col = 0; col < grid[row].length; col++) {\n\
  \            if (grid[row][col] === 1) {\n                filled++;\n          \
  \  }\n        }\n        result += Math.max(filled - capacity, 0);\n    }\n    return\
  \ result;\n}\n\nconsole.log(0, max_fill([[0, 0, 0], [0, 0, 0]], 5));\nconsole.log(5,\
  \ max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(6,\
  \ max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));"
- "    let result = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        let row = grid[i];\n        let count = 0;\n        for (let j = 0;\
  \ j < row.length; j++) {\n            if (row[j] === 1) {\n                count++;\n\
  \            }\n        }\n        max = Math.max(max, count);\n        result +=\
  \ count;\n    }\n    return result - max;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_row = 0;\n    for (let row = 0; row < grid.length;\
  \ row++) {\n        let max_col = 0;\n        for (let col = 0; col < grid[row].length;\
  \ col++) {\n            if (grid[row][col] === 1) {\n                max_col = col;\n\
  \            }\n        }\n        if (max_col > max_row) {\n            max_row\
  \ = max_col;\n        }\n    }\n    for (let row = 0; row < grid.length; row++)\
  \ {\n        for (let col = 0; col < grid[row].length; col++) {\n            if\
  \ (grid[row][col] === 1) {\n                result += max_row - col;\n         \
  \   }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_height = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        max_height = Math.max(max_height, Math.max(...grid[i]));\n   \
  \ }\n    for (let i = 0; i < max_height; i++) {\n        result += fill_level(grid,\
  \ capacity, i);\n    }\n    return result;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        for (let well of row)\
  \ {\n            max_fill = Math.max(max_fill, well);\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill += capacity;\n            }\n        }\n    }\n    return\
  \ max_fill;\n}"
- "    let result = 0;\n    let row_max = 0;\n    let col_max = 0;\n    for (let i\
  \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
  \ {\n            if (grid[i][j] === 1) {\n                row_max = Math.max(row_max,\
  \ j);\n                col_max = Math.max(col_max, i);\n            }\n        }\n\
  \    }\n    for (let i = 0; i <= col_max; i++) {\n        let row_fill = 0;\n  \
  \      for (let j = 0; j <= row_max; j++) {\n            if (grid[i][j] === 1) {\n\
  \                row_fill++;\n            }\n            if (row_fill === capacity)\
  \ {\n                result++;\n                row_fill = 0;\n            }\n \
  \       }\n        if (row_fill > 0) {\n            result++;\n        }\n    }\n\
  \    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
  \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(6, max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(5, max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(0, max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            let cell = row[j];\n            if (cell === 1) {\n           \
  \     fill++;\n            }\n        }\n        if (fill > capacity) {\n      \
  \      result += fill - capacity;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\nconsole.log(max_fill([[0, 0, 1,\
  \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2), 5);\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5), 0);"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
  \ === 1) {\n                result += capacity;\n            }\n        }\n    }\n\
  \    return result;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let count = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                count++;\n            }\n\
  \        }\n        result += Math.ceil(count / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let\
  \ row = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                fill++;\n           \
  \ }\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n    return\
  \ max_fill;\n}\n"
- "    let result = 0;\n    let max_fill = 0;\n    for (let row of grid) {\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                max_fill++;\n\
  \            }\n        }\n    }\n    for (let row of grid) {\n        let fill\
  \ = 0;\n        for (let well of row) {\n            if (well === 1) {\n       \
  \         fill++;\n            }\n        }\n        if (fill === max_fill) {\n\
  \            result += capacity;\n        } else {\n            result += fill;\n\
  \        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0],\
  \ [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]],\
  \ 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let current_fill = 0;\n\
  \        for (let well of row) {\n            if (well === 1) {\n              \
  \  current_fill++;\n            } else {\n                if (current_fill > 0)\
  \ {\n                    result += Math.ceil(current_fill / capacity);\n       \
  \             current_fill = 0;\n                }\n            }\n        }\n \
  \       if (current_fill > 0) {\n            result += Math.ceil(current_fill /\
  \ capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_sum = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            row_sum += row[j];\n        }\n        result += Math.ceil(row_sum\
  \ / capacity);\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            fill += well;\n            if (fill ===\
  \ capacity) {\n                result++;\n                fill = 0;\n          \
  \  }\n        }\n        if (fill > 0) {\n            result++;\n        }\n   \
  \ }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
  \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let n = grid.length;\n    let m = grid[0].length;\n    let max_fill = 0;\n\
  \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n    \
  \        if (grid[i][j] === 1) {\n                max_fill = Math.max(max_fill,\
  \ j);\n            }\n        }\n    }\n    return max_fill + 1;\n}\n"
- "    const n = grid.length;\n    const m = grid[0].length;\n    let res = 0;\n \
  \   for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = 0;\
  \ j < m; j++) {\n            sum += grid[i][j];\n        }\n        res += Math.ceil(sum\
  \ / capacity);\n    }\n    return res;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        if (fill > capacity) {\n            result += fill - capacity;\n\
  \        }\n    }\n    return result;\n}\n\nconsole.log(6, max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(5, max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(0, max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill\
  \ += 1;\n            } else {\n                if (fill > max_fill) {\n        \
  \            max_fill = fill;\n                }\n                fill = 0;\n  \
  \          }\n        }\n        if (fill > max_fill) {\n            max_fill =\
  \ fill;\n        }\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    const n = grid.length;\n    const m = grid[0].length;\n\
  \    const max_row = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n\
  \        for (let j = 0; j < m; j++) {\n            max_row[i] = Math.max(max_row[i],\
  \ grid[i][j]);\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        count\
  \ += max_row[i];\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j =\
  \ 0; j < m; j++) {\n            count += Math.max(0, max_row[i] - grid[i][j]);\n\
  \        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0],\
  \ [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]],\
  \ 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    let row_max = 0;\n    for (let row of grid) {\n      \
  \  row_max = Math.max(row_max, Math.max(...row));\n    }\n    for (let i = 0; i\
  \ < row_max; i++) {\n        result += fill_row(grid, capacity);\n    }\n    return\
  \ result;\n}\n"
- "    let result = 0;\n    let n = grid.length;\n    let m = grid[0].length;\n  \
  \  let row_max = new Array(n).fill(0);\n    let col_max = new Array(m).fill(0);\n\
  \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n    \
  \        row_max[i] = Math.max(row_max[i], grid[i][j]);\n            col_max[j]\
  \ = Math.max(col_max[j], grid[i][j]);\n        }\n    }\n    for (let i = 0; i <\
  \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            result += Math.min(row_max[i],\
  \ col_max[j]) - grid[i][j];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill\
  \ += 1;\n            } else {\n                if (fill > max_fill) {\n        \
  \            max_fill = fill;\n                }\n                fill = 0;\n  \
  \          }\n        }\n        if (fill > max_fill) {\n            max_fill =\
  \ fill;\n        }\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    let n = grid.length;\n    let m = grid[0].length;\n  \
  \  let row_max = new Array(n).fill(0);\n    let col_max = new Array(m).fill(0);\n\
  \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n    \
  \        row_max[i] = Math.max(row_max[i], grid[i][j]);\n            col_max[j]\
  \ = Math.max(col_max[j], grid[i][j]);\n        }\n    }\n    for (let i = 0; i <\
  \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            result += Math.min(row_max[i],\
  \ col_max[j]) - grid[i][j];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0)\
  \ {\n            result += row_max;\n            for (let j = 0; j < row.length;\
  \ j++) {\n                row[j] = Math.max(0, row[j] - capacity);\n           \
  \ }\n        }\n    }\n    return result;\n}\n\nconsole.log(0, max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));\nconsole.log(5, max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(6, max_fill([[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], 1));"
- "    let result = 0;\n    let row_max = 0;\n    for (let row of grid) {\n      \
  \  row_max = Math.max(...row);\n        result += row_max;\n        row.fill(row_max);\n\
  \    }\n    return result;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill += capacity;\n            }\n        }\n    }\n    return\
  \ max_fill;\n}"
- "    let max_fill = 0;\n    for (let row of grid) {\n        max_fill = Math.max(max_fill,\
  \ Math.max(...row));\n    }\n    return max_fill;\n}"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let col of row) {\n            if (col === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        for (let well of row)\
  \ {\n            max_fill = Math.max(max_fill, well);\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let max = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] > max) {\n                max = row[j];\n          \
  \  }\n        }\n        result += max;\n    }\n    return result;\n}\n"
- "    let num_rows = grid.length;\n    let num_cols = grid[0].length;\n    let num_buckets\
  \ = 0;\n    let max_fill = 0;\n    for (let i = 0; i < num_rows; i++) {\n      \
  \  for (let j = 0; j < num_cols; j++) {\n            if (grid[i][j] === 1) {\n \
  \               num_buckets++;\n                max_fill = Math.max(max_fill, j);\n\
  \            }\n        }\n    }\n    return num_buckets * capacity + max_fill;\n\
  }\n\nconsole.log(0, max_fill([[0,0,0], [0,0,0]], 5));\nconsole.log(5, max_fill([[0,0,1,1],\
  \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(6, max_fill([[0,0,1,0], [0,1,0,0],\
  \ [1,1,1,1]], 1));"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  let row_fill = 0;\n        for (let col = 0; col < grid[row].length; col++) {\n\
  \            if (grid[row][col] === 1) {\n                row_fill++;\n        \
  \    }\n        }\n        result += Math.ceil(row_fill / capacity);\n    }\n  \
  \  return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let row_max = 0;\n    for (let row of grid) {\n      \
  \  for (let col of row) {\n            if (col > row_max) {\n                row_max\
  \ = col;\n            }\n        }\n        result += row_max;\n        row_max\
  \ = 0;\n    }\n    return result * capacity;\n}\n"
- '    throw new Error("Method not implemented.");

  }

  console.time("Time cost");

  console.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)); // 6

  console.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));
  // 5

  console.log(max_fill([[0, 0, 0], [0, 0, 0]], 5)); // 0

  console.timeEnd("Time cost");'
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
  \ > 0) {\n                result += grid[row][col];\n                grid[row][col]\
  \ = 0;\n            }\n        }\n    }\n    return Math.ceil(result / capacity);\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill\
  \ += 1;\n            } else {\n                if (fill > max_fill) {\n        \
  \            max_fill = fill;\n                }\n                fill = 0;\n  \
  \          }\n        }\n        if (fill > max_fill) {\n            max_fill =\
  \ fill;\n        }\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let result = 0;\n    let row_count = grid.length;\n    let col_count = grid[0].length;\n\
  \    let row_max = new Array(row_count).fill(0);\n    let col_max = new Array(col_count).fill(0);\n\
  \    for (let row = 0; row < row_count; ++row) {\n        for (let col = 0; col\
  \ < col_count; ++col) {\n            row_max[row] = Math.max(row_max[row], grid[row][col]);\n\
  \            col_max[col] = Math.max(col_max[col], grid[row][col]);\n        }\n\
  \    }\n    for (let row = 0; row < row_count; ++row) {\n        for (let col =\
  \ 0; col < col_count; ++col) {\n            result += Math.min(row_max[row], col_max[col])\
  \ - grid[row][col];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    let row_max = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        row_max = 0;\n        for (let j = 0; j < grid[i].length; j++)\
  \ {\n            if (grid[i][j] > row_max) {\n                row_max = grid[i][j];\n\
  \            }\n        }\n        result += row_max;\n    }\n    return result;\n\
  }\n"
- "    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        max_fill = 0;\n        for (let j = 0; j < grid[i].length; j++)\
  \ {\n            if (grid[i][j] === 1) {\n                max_fill++;\n        \
  \    }\n        }\n        result += Math.ceil(max_fill / capacity);\n    }\n  \
  \  return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill += capacity;\n            }\n        }\n    }\n    return\
  \ max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well === 1) {\n                fill\
  \ += 1;\n            } else {\n                if (fill > max_fill) {\n        \
  \            max_fill = fill;\n                }\n                fill = 0;\n  \
  \          }\n        }\n        if (fill > max_fill) {\n            max_fill =\
  \ fill;\n        }\n    }\n    return max_fill;\n}"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j + 1);\n            }\n        }\n\
  \    }\n    return max_fill;\n}"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        let row_min = Math.min(...row);\n\
  \        if (row_max > 0) {\n            result += row_max;\n            for (let\
  \ j = 0; j < row.length; j++) {\n                row[j] -= row_max;\n          \
  \  }\n        }\n        if (row_min < 0) {\n            result += Math.abs(row_min);\n\
  \            for (let j = 0; j < row.length; j++) {\n                row[j] += Math.abs(row_min);\n\
  \            }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0)\
  \ {\n            result += row_max;\n            for (let j = 0; j < row.length;\
  \ j++) {\n                row[j] = Math.max(0, row[j] - capacity);\n           \
  \ }\n        }\n    }\n    return result;\n}\n\nconsole.log(0, max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));\nconsole.log(6, max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
  \ 1, 1, 1]], 1));\nconsole.log(5, max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
  \ 1], [0, 1, 1, 1]], 2));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(1, max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(5, max_fill([[0, 0, 1,\
  \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(0, max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        let row = grid[i];\n        let fill = 0;\n        for (let j\
  \ = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n               \
  \ fill++;\n            }\n        }\n        max_fill = Math.max(max_fill, fill);\n\
  \        result += fill;\n    }\n    return result - max_fill;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
  \     for (let well of row) {\n            if (well) {\n                fill++;\n\
  \            } else {\n                max_fill = Math.max(max_fill, fill);\n  \
  \              fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
  \ fill);\n    }\n    return max_fill;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j + 1);\n            }\n        }\n\
  \    }\n    return max_fill;\n}"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           result += capacity;\n            }\n        }\n    }\n    return result;\n\
  }\n"
- "    let result = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        max = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n    \
  \        if (grid[i][j] === 1) {\n                max++;\n            }\n      \
  \  }\n        result += Math.ceil(max / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    // your code goes here\n    return result;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j);\n            }\n        }\n \
  \   }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row = 0; row < grid.length; row++) {\n      \
  \  for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
  \ > 0) {\n                result += grid[row][col];\n                grid[row][col]\
  \ = 0;\n            }\n        }\n    }\n    return result;\n}\n"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill += capacity;\n            }\n        }\n    }\n    return\
  \ max_fill;\n}"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_fill = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        row_fill++;\n      }\n    }\n    result += Math.ceil(row_fill\
  \ / capacity);\n  }\n  return result;\n}\n\nconsole.log(1, max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(5, max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(0, max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_result = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                row_result++;\n     \
  \       }\n        }\n        result += Math.ceil(row_result / capacity);\n    }\n\
  \    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
  \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0)\
  \ {\n            result += row_max;\n            for (let j = 0; j < row.length;\
  \ j++) {\n                row[j] = Math.max(0, row[j] - capacity);\n           \
  \ }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let\
  \ fill = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n            if\
  \ (grid[i][j] === 1) {\n                fill++;\n            }\n        }\n    \
  \    max_fill = Math.max(max_fill, fill);\n    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_max = Math.max(...row);\n        if (row_max > 0)\
  \ {\n            result += row_max;\n            for (let j = 0; j < row.length;\
  \ j++) {\n                row[j] = Math.max(0, row[j] - capacity);\n           \
  \ }\n        }\n    }\n    return result;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let cell of row) {\n            if (cell === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n  \
  \              fill++;\n            } else {\n                if (fill > 0) {\n\
  \                    result += Math.ceil(fill / capacity);\n                   \
  \ fill = 0;\n                }\n            }\n        }\n        if (fill > 0)\
  \ {\n            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
  \ 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- '    throw new Error("Method not implemented.");

  }

  console.time("Time cost");

  console.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)); // 6

  console.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));
  // 5

  console.log(max_fill([[0, 0, 0], [0, 0, 0]], 5)); // 0

  console.timeEnd("Time cost");'
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            fill += well;\n            if (fill ===\
  \ capacity) {\n                result++;\n                fill = 0;\n          \
  \  }\n        }\n        if (fill > 0) {\n            result++;\n        }\n   \
  \ }\n    return result;\n}\n\nconsole.log(6, max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1));\nconsole.log(5, max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(0, max_fill([[0, 0, 0], [0, 0, 0]],\
  \ 5));"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let col of row) {\n            fill += col;\n            if (fill >= capacity)\
  \ {\n                result++;\n                fill = 0;\n            }\n     \
  \   }\n        if (fill > 0) {\n            result++;\n        }\n    }\n    return\
  \ result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1],\
  \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]],\
  \ 5));"
- "    let max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for\
  \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n\
  \                max_fill = Math.max(max_fill, j + 1);\n            }\n        }\n\
  \    }\n    return max_fill;\n}\n"
- "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
  \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
  \            } else {\n                if (fill > 0) {\n                    result\
  \ += Math.ceil(fill / capacity);\n                    fill = 0;\n              \
  \  }\n            }\n        }\n        if (fill > 0) {\n            result += Math.ceil(fill\
  \ / capacity);\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let fill = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                fill++;\n            }\n \
  \       }\n        result += Math.ceil(fill / capacity);\n    }\n    return result;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
language: ts
name: HumanEval_115_max_fill
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// Input: \n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity\
  \ : 1\n// Output: 6\n// Example 2:\n// Input: \n// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// Example 3:\n//\
  \ Input: \n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n\
  // Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
