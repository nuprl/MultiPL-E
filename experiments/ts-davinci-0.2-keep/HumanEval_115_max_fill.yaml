name: HumanEval_115_max_fill
language: humaneval_to_typescript.py
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// Input: \n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity\
  \ : 1\n// Output: 6\n// Example 2:\n// Input: \n// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// Example 3:\n//\
  \ Input: \n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n\
  // Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n\
    \        let row = grid[i];\n        let fill = 0;\n        for (let j = 0; j\
    \ < row.length; j++) {\n            if (row[j] === 1) {\n                fill++;\n\
    \            }\n        }\n        result += Math.ceil(fill / capacity);\n   \
    \ }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let result = 0;\n    for (let row of grid) {\n        let fill = 0;\n     \
    \   for (let well of row) {\n            if (well === 1) {\n                fill++;\n\
    \            } else {\n                if (fill > 0) {\n                    result\
    \ += Math.ceil(fill / capacity);\n                    fill = 0;\n            \
    \    }\n            }\n        }\n        if (fill > 0) {\n            result\
    \ += Math.ceil(fill / capacity);\n        }\n    }\n    return result;\n}\n\n\
    console.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]],\
    \ 5));", "    let result = 0;\n    for (let row of grid) {\n        let fill =\
    \ 0;\n        for (let well of row) {\n            if (well === 1) {\n       \
    \         fill++;\n            } else {\n                if (fill > 0) {\n   \
    \                 result += Math.ceil(fill / capacity);\n                    fill\
    \ = 0;\n                }\n            }\n        }\n        if (fill > 0) {\n\
    \            result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
    \ result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\n\
    console.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0],\
    \ [0,0,0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                max = Math.max(max, j);\n\
    \            }\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n            if\
    \ (j === max) {\n                count += capacity;\n            }\n        }\n\
    \    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
    \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "    let result = 0;\n    // max_fill(grid, capacity) = max_fill(grid,\
    \ capacity - 1) + max_fill(grid, 1)\n    // max_fill(grid, 1) = sum(grid[i][j])\n\
    \    // max_fill(grid, capacity - 1) = max_fill(grid, capacity - 2) + max_fill(grid,\
    \ 1)\n    // max_fill(grid, capacity - 2) = max_fill(grid, capacity - 3) + max_fill(grid,\
    \ 1)\n    // ...\n    // max_fill(grid, capacity - (capacity - 1)) = max_fill(grid,\
    \ capacity - capacity) + max_fill(grid, 1)\n    // max_fill(grid, capacity - capacity)\
    \ = 0\n    // max_fill(grid, capacity) = capacity * max_fill(grid, 1)\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                result++;\n   \
    \         }\n        }\n    }\n    return result * capacity;\n}\n", "    let max_fill\
    \ = 0;\n    for (let row of grid) {\n        let fill = 0;\n        for (let well\
    \ of row) {\n            if (well === 1) {\n                fill++;\n        \
    \    } else {\n                max_fill = Math.max(max_fill, fill);\n        \
    \        fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
    \ fill);\n    }\n    return max_fill;\n}\n", "    let max_fill = 0;\n    for (let\
    \ row of grid) {\n        let fill = 0;\n        for (let well of row) {\n   \
    \         if (well === 1) {\n                fill++;\n            } else {\n \
    \               max_fill = Math.max(max_fill, fill);\n                fill = 0;\n\
    \            }\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n\
    \    return max_fill;\n}", "    let result = 0;\n    for (let row of grid) {\n\
    \        let fill = 0;\n        for (let cell of row) {\n            if (cell\
    \ === 1) {\n                fill++;\n            } else {\n                if\
    \ (fill > 0) {\n                    result += Math.ceil(fill / capacity);\n  \
    \                  fill = 0;\n                }\n            }\n        }\n  \
    \      if (fill > 0) {\n            result += Math.ceil(fill / capacity);\n  \
    \      }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]],\
    \ 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));", "    let max_fill = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                max_fill = Math.max(max_fill,\
    \ j);\n            }\n        }\n    }\n    return max_fill + 1;\n}\n", "    let\
    \ result = 0;\n    let row_max = 0;\n    let col_max = 0;\n    let row_count =\
    \ grid.length;\n    let col_count = grid[0].length;\n    for (let row = 0; row\
    \ < row_count; row++) {\n        for (let col = 0; col < col_count; col++) {\n\
    \            if (grid[row][col] === 1) {\n                row_max = Math.max(row_max,\
    \ row);\n                col_max = Math.max(col_max, col);\n            }\n  \
    \      }\n    }\n    for (let row = 0; row <= row_max; row++) {\n        for (let\
    \ col = 0; col <= col_max; col++) {\n            if (grid[row][col] === 1) {\n\
    \                result += capacity;\n            }\n        }\n    }\n    return\
    \ result;\n}\n\nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\n\
    console.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0],\
    \ [0,0,0]], 5));", "    let max_fill = 0;\n    for (let row of grid) {\n     \
    \   let fill = 0;\n        for (let well of row) {\n            if (well === 1)\
    \ {\n                fill += 1;\n            } else {\n                if (fill\
    \ > max_fill) {\n                    max_fill = fill;\n                }\n   \
    \             fill = 0;\n            }\n        }\n        if (fill > max_fill)\
    \ {\n            max_fill = fill;\n        }\n    }\n    return max_fill;\n}\n",
  "    let max_fill = 0;\n    for (let row of grid) {\n        let fill = 0;\n   \
    \     for (let well of row) {\n            if (well === 1) {\n               \
    \ fill++;\n            } else {\n                max_fill = Math.max(max_fill,\
    \ fill);\n                fill = 0;\n            }\n        }\n        max_fill\
    \ = Math.max(max_fill, fill);\n    }\n    return max_fill;\n}\n", "    let rows\
    \ = grid.length;\n    let cols = grid[0].length;\n    let total_water = 0;\n \
    \   let total_fill = 0;\n    for (let i = 0; i < rows; i++) {\n        let row_water\
    \ = 0;\n        for (let j = 0; j < cols; j++) {\n            row_water += grid[i][j];\n\
    \        }\n        total_water += row_water;\n        total_fill += Math.ceil(row_water\
    \ / capacity);\n    }\n    return total_fill;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));", "    let result\
    \ = 0;\n    let rows = grid.length;\n    let cols = grid[0].length;\n    let row_max\
    \ = new Array(rows).fill(0);\n    let col_max = new Array(cols).fill(0);\n   \
    \ for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols;\
    \ col++) {\n            row_max[row] = Math.max(row_max[row], grid[row][col]);\n\
    \            col_max[col] = Math.max(col_max[col], grid[row][col]);\n        }\n\
    \    }\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0;\
    \ col < cols; col++) {\n            result += Math.min(row_max[row], col_max[col])\
    \ - grid[row][col];\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]], 5));", "    let result\
    \ = 0;\n    for (let row of grid) {\n        let fill = 0;\n        for (let i\
    \ = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n             \
    \   fill++;\n            } else {\n                if (fill > 0) {\n         \
    \           result += Math.ceil(fill / capacity);\n                    fill =\
    \ 0;\n                }\n            }\n        }\n        if (fill > 0) {\n \
    \           result += Math.ceil(fill / capacity);\n        }\n    }\n    return\
    \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let result\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let row_fill = 0;\n        for (let j = 0; j < row.length; j++) {\n \
    \           if (row[j] === 1) {\n                row_fill++;\n            }\n\
    \        }\n        result += Math.ceil(row_fill / capacity);\n    }\n    return\
    \ result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let max_fill\
    \ = 0;\n    for (let row of grid) {\n        let fill = 0;\n        for (let well\
    \ of row) {\n            if (well === 1) {\n                fill++;\n        \
    \    } else {\n                max_fill = Math.max(max_fill, fill);\n        \
    \        fill = 0;\n            }\n        }\n        max_fill = Math.max(max_fill,\
    \ fill);\n    }\n    return max_fill;\n}\n", "    let max_fill = 0;\n    for (let\
    \ row of grid) {\n        let fill = 0;\n        for (let well of row) {\n   \
    \         if (well === 1) {\n                fill++;\n            } else {\n \
    \               max_fill = Math.max(max_fill, fill);\n                fill = 0;\n\
    \            }\n        }\n        max_fill = Math.max(max_fill, fill);\n    }\n\
    \    return max_fill;\n}\n", "    let max_fill = 0;\n    for (let row of grid)\
    \ {\n        let fill = 0;\n        for (let well of row) {\n            if (well\
    \ === 1) {\n                fill++;\n            } else {\n                max_fill\
    \ = Math.max(max_fill, fill);\n                fill = 0;\n            }\n    \
    \    }\n        max_fill = Math.max(max_fill, fill);\n    }\n    return max_fill;\n\
    }\n", "    let result = 0;\n    let row_max = 0;\n    for (let row of grid) {\n\
    \        row_max = Math.max(row_max, Math.max(...row));\n    }\n    for (let i\
    \ = 0; i < row_max; i++) {\n        for (let j = 0; j < grid.length; j++) {\n\
    \            if (grid[j][i] === 1) {\n                result++;\n            \
    \    grid[j][i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\
    \nconsole.log(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1));\nconsole.log(max_fill([[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2));\nconsole.log(max_fill([[0,0,0], [0,0,0]],\
    \ 5));"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
