name: HumanEval_6_parse_nested_parens
language: humaneval_to_typescript.py
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  // [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string: string): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = parse_nested_parens;\n  assert.deepEqual(candidate(\"\
  (()()) ((())) () ((())()())\"),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"()\
  \ (()) ((())) (((())))\"),[1, 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"\
  ),[4]);\n}\n\ntest();"
completions: ["    const paren_groups = paren_string.split(' ');\n    const result:\
    \ number[] = [];\n    for (const paren_group of paren_groups) {\n        let max_nesting\
    \ = 0;\n        let current_nesting = 0;\n        for (const char of paren_group)\
    \ {\n            if (char === '(') {\n                current_nesting++;\n   \
    \             max_nesting = Math.max(max_nesting, current_nesting);\n        \
    \    } else if (char === ')') {\n                current_nesting--;\n        \
    \    }\n        }\n        result.push(max_nesting);\n    }\n    return result;\n\
    }\n", "  let paren_groups = paren_string.split(' ');\n  let paren_levels = [];\n\
    \  for (let paren_group of paren_groups) {\n    let paren_level = 0;\n    let\
    \ max_paren_level = 0;\n    for (let paren of paren_group) {\n      if (paren\
    \ === '(') {\n        paren_level++;\n      } else if (paren === ')') {\n    \
    \    paren_level--;\n      }\n      if (paren_level > max_paren_level) {\n   \
    \     max_paren_level = paren_level;\n      }\n    }\n    paren_levels.push(max_paren_level);\n\
    \  }\n  return paren_levels;\n}\n", "  let paren_groups = paren_string.split('\
    \ ');\n  let result = [];\n  for (let paren_group of paren_groups) {\n    let\
    \ stack = [];\n    let max_depth = 0;\n    for (let c of paren_group) {\n    \
    \  if (c === '(') {\n        stack.push(c);\n        max_depth = Math.max(max_depth,\
    \ stack.length);\n      } else if (c === ')') {\n        stack.pop();\n      }\n\
    \    }\n    result.push(max_depth);\n  }\n  return result;\n}\n", "  const paren_groups\
    \ = paren_string.split(' ');\n  const result: number[] = [];\n  for (const paren_group\
    \ of paren_groups) {\n    let max_depth = 0;\n    let current_depth = 0;\n   \
    \ for (const paren of paren_group) {\n      if (paren === '(') {\n        current_depth++;\n\
    \        max_depth = Math.max(max_depth, current_depth);\n      } else if (paren\
    \ === ')') {\n        current_depth--;\n      }\n    }\n    result.push(max_depth);\n\
    \  }\n  return result;\n}\n", "    let result: number[] = [];\n    let paren_groups:\
    \ string[] = paren_string.split(' ');\n    for (let paren_group of paren_groups)\
    \ {\n        let max_level: number = 0;\n        let level: number = 0;\n    \
    \    for (let i = 0; i < paren_group.length; i++) {\n            if (paren_group[i]\
    \ === '(') {\n                level++;\n                if (level > max_level)\
    \ {\n                    max_level = level;\n                }\n            }\
    \ else if (paren_group[i] === ')') {\n                level--;\n            }\n\
    \        }\n        result.push(max_level);\n    }\n    return result;\n}\n",
  "  const result: number[] = [];\n  const paren_groups = paren_string.split(' ');\n\
    \  for (const paren_group of paren_groups) {\n    let max_level = 0;\n    let\
    \ level = 0;\n    for (const paren of paren_group) {\n      if (paren === '(')\
    \ {\n        level++;\n        if (level > max_level) {\n          max_level =\
    \ level;\n        }\n      } else if (paren === ')') {\n        level--;\n   \
    \   }\n    }\n    result.push(max_level);\n  }\n  return result;\n}\n", "  const\
    \ parens = paren_string.split(' ');\n  const result: number[] = [];\n  for (const\
    \ paren of parens) {\n    let max = 0;\n    let count = 0;\n    for (const char\
    \ of paren) {\n      if (char === '(') {\n        count++;\n        if (count\
    \ > max) {\n          max = count;\n        }\n      } else if (char === ')')\
    \ {\n        count--;\n      }\n    }\n    result.push(max);\n  }\n  return result;\n\
    }\n", "  const paren_groups = paren_string.split(' ');\n  const result: number[]\
    \ = [];\n  for (const paren_group of paren_groups) {\n    let max_nesting = 0;\n\
    \    let current_nesting = 0;\n    for (const paren of paren_group) {\n      if\
    \ (paren === '(') {\n        current_nesting++;\n        max_nesting = Math.max(max_nesting,\
    \ current_nesting);\n      } else if (paren === ')') {\n        current_nesting--;\n\
    \      }\n    }\n    result.push(max_nesting);\n  }\n  return result;\n}\n", " \
    \ const parens = paren_string.split(' ');\n  const result: number[] = [];\n  for\
    \ (const paren of parens) {\n    let max = 0;\n    let count = 0;\n    for (const\
    \ char of paren) {\n      if (char === '(') {\n        count++;\n        if (count\
    \ > max) {\n          max = count;\n        }\n      } else if (char === ')')\
    \ {\n        count--;\n      }\n    }\n    result.push(max);\n  }\n  return result;\n\
    }\n", "  const result: number[] = [];\n  const parens = paren_string.split(' ');\n\
    \  for (const paren of parens) {\n    let max_depth = 0;\n    let depth = 0;\n\
    \    for (const char of paren) {\n      if (char === '(') {\n        depth++;\n\
    \        max_depth = Math.max(max_depth, depth);\n      } else if (char === ')')\
    \ {\n        depth--;\n      }\n    }\n    result.push(max_depth);\n  }\n  return\
    \ result;\n}\n", "  const paren_groups = paren_string.split(' ');\n  const result:\
    \ number[] = [];\n  for (const paren_group of paren_groups) {\n    let max_nesting\
    \ = 0;\n    let current_nesting = 0;\n    for (const paren of paren_group) {\n\
    \      if (paren === '(') {\n        current_nesting++;\n        max_nesting =\
    \ Math.max(max_nesting, current_nesting);\n      } else if (paren === ')') {\n\
    \        current_nesting--;\n      }\n    }\n    result.push(max_nesting);\n \
    \ }\n  return result;\n}\n", "  const paren_groups = paren_string.split(' ');\n\
    \  const result: number[] = [];\n  for (const group of paren_groups) {\n    let\
    \ max_depth = 0;\n    let current_depth = 0;\n    for (const char of group) {\n\
    \      if (char === '(') {\n        current_depth++;\n        max_depth = Math.max(max_depth,\
    \ current_depth);\n      } else if (char === ')') {\n        current_depth--;\n\
    \      }\n    }\n    result.push(max_depth);\n  }\n  return result;\n}\n", " \
    \   const paren_groups = paren_string.split(' ');\n    const result: number[]\
    \ = [];\n    for (const group of paren_groups) {\n        let max_level = 0;\n\
    \        let current_level = 0;\n        for (const char of group) {\n       \
    \     if (char === '(') {\n                current_level++;\n                max_level\
    \ = Math.max(max_level, current_level);\n            } else if (char === ')')\
    \ {\n                current_level--;\n            }\n        }\n        result.push(max_level);\n\
    \    }\n    return result;\n}\n", "    const paren_groups = paren_string.split('\
    \ ');\n    const paren_levels = [];\n    for (const paren_group of paren_groups)\
    \ {\n        const paren_level = parse_nested_parens_helper(paren_group);\n  \
    \      paren_levels.push(paren_level);\n    }\n    return paren_levels;\n}\n",
  "  const paren_groups = paren_string.split(' ');\n  const result: number[] = [];\n\
    \  for (const paren_group of paren_groups) {\n    let max_nesting = 0;\n    let\
    \ current_nesting = 0;\n    for (const char of paren_group) {\n      if (char\
    \ === '(') {\n        current_nesting++;\n        max_nesting = Math.max(max_nesting,\
    \ current_nesting);\n      } else if (char === ')') {\n        current_nesting--;\n\
    \      }\n    }\n    result.push(max_nesting);\n  }\n  return result;\n}\n", " \
    \ const paren_groups = paren_string.split(' ');\n  const result: number[] = [];\n\
    \  for (const paren_group of paren_groups) {\n    let max_depth = 0;\n    let\
    \ depth = 0;\n    for (const char of paren_group) {\n      if (char === '(') {\n\
    \        depth++;\n        max_depth = Math.max(max_depth, depth);\n      } else\
    \ if (char === ')') {\n        depth--;\n      }\n    }\n    result.push(max_depth);\n\
    \  }\n  return result;\n}\n", "  const paren_groups = paren_string.split(' ');\n\
    \  const max_nesting_levels = [];\n  for (const paren_group of paren_groups) {\n\
    \    const max_nesting_level = get_max_nesting_level(paren_group);\n    max_nesting_levels.push(max_nesting_level);\n\
    \  }\n  return max_nesting_levels;\n}\n", "  const paren_groups = paren_string.split('\
    \ ');\n  const result: number[] = [];\n  for (const paren_group of paren_groups)\
    \ {\n    let max_nesting = 0;\n    let nesting = 0;\n    for (const paren of paren_group)\
    \ {\n      if (paren === '(') {\n        nesting++;\n        max_nesting = Math.max(max_nesting,\
    \ nesting);\n      } else if (paren === ')') {\n        nesting--;\n      }\n\
    \    }\n    result.push(max_nesting);\n  }\n  return result;\n}\n", "  const paren_groups\
    \ = paren_string.split(' ');\n  const result: number[] = [];\n  for (const group\
    \ of paren_groups) {\n    let max_level = 0;\n    let level = 0;\n    for (const\
    \ char of group) {\n      if (char === '(') {\n        level++;\n        max_level\
    \ = Math.max(max_level, level);\n      } else if (char === ')') {\n        level--;\n\
    \      }\n    }\n    result.push(max_level);\n  }\n  return result;\n}\n", " \
    \ const paren_groups = paren_string.split(' ');\n  const paren_counts = [];\n\
    \  for (const paren_group of paren_groups) {\n    paren_counts.push(count_nested_parens(paren_group));\n\
    \  }\n  return paren_counts;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
