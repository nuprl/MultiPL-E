name: HumanEval_68_pluck
language: javascript
results:
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => Math.min(acc, curr));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = evens[0];\n    let minIndex = evensIndex[0];\n    for(let i = 0;\
    \ i < evens.length; i++){\n        if(evens[i] < min){\n            min = evens[i];\n\
    \            minIndex = evensIndex[i];\n        }\n    }\n    return [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallestEven = evens.length > 0 ? evens.reduce((a,\
    \ b) => Math.min(a, b)) : -1;\n    let index = arr.indexOf(smallestEven);\n  \
    \  return smallestEven > -1 ? [smallestEven, index] : [];\n}\n\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n \
    \ assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            even.push(arr[i]);\n            index.push(i);\n  \
    \      }\n    }\n    if(even.length === 0){\n        return [];\n    }\n    let\
    \ min = Math.min(...even);\n    let minIndex = index[even.indexOf(min)];\n   \
    \ return [min, minIndex];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length === 0 ? [] : [min, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let smallestEvenIndex\
    \ = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(x => x % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            index =\
    \ i;\n        }\n    }\n    return index === -1 ? [] : [min, index];\n}\n\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Infinity;\n\
    \    let minIndex = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            minIndex\
    \ = i;\n        }\n    }\n    return minIndex === -1 ? [] : [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallest = Infinity;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < smallest){\n            smallest = arr[i];\n         \
    \   index = i;\n        }\n    }\n    return index === -1 ? [] : [smallest, index];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let smallestEven = evens[0];\n    let smallestEvenIndex = evensIndex[0];\n\
    \    for(let i = 0; i < evens.length; i++){\n        if(evens[i] < smallestEven){\n\
    \            smallestEven = evens[i];\n            smallestEvenIndex = evensIndex[i];\n\
    \        }\n    }\n    return [smallestEven, smallestEvenIndex];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let odd = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            even.push(arr[i]);\n        }else{\n            odd.push(arr[i]);\n\
    \        }\n    }\n    if(even.length === 0){\n        return [];\n    }\n   \
    \ let min = Math.min(...even);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let smallestEven = [];\n    for(let i = 0; i <\
    \ arr.length; i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n\
    \            evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    smallestEven.push(Math.min(...evens));\n    smallestEven.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return smallestEven;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if(min === Infinity){\n\
    \        return [];\n    }\n    let index = arr.indexOf(min);\n    return [min,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => Math.min(a,b));\n    let smallestIndex = arr.indexOf(smallest);\n\
    \    return [smallest, smallestIndex];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0){\n        return [];\n    }\n    let min = Infinity;\n    let minIndex =\
    \ -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i] % 2 === 0 &&\
    \ arr[i] < min){\n            min = arr[i];\n            minIndex = i;\n     \
    \   }\n    }\n    if(minIndex === -1){\n        return [];\n    }\n    return\
    \ [min, minIndex];\n}\n\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Infinity;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            index =\
    \ i;\n        }\n    }\n    return index === -1 ? [] : [min, index];\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0)\n    if(evens.length === 0){\n        return []\n    }\n   \
    \ let smallest = evens.reduce((acc, curr) => acc < curr ? acc : curr)\n    let\
    \ index = arr.indexOf(smallest)\n    return [smallest, index]\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let minEven = Math.min(...evens);\n\
    \    let minEvenIndex = arr.indexOf(minEven);\n    return [minEven, minEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = arr.filter(x\
    \ => x % 2 === 0);\n    if(even.length === 0) return [];\n    let min = Math.min(...even);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = Math.min(...evens);\n    let minIndex = evensIndex[evens.indexOf(min)];\n\
    \    return [min, minIndex];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = evens[0];\n    let minIndex = evensIndex[0];\n    for(let i = 0;\
    \ i < evens.length; i++){\n        if(evens[i] < min){\n            min = evens[i];\n\
    \            minIndex = evensIndex[i];\n        }\n    }\n    return [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length > 0 ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a,b) => a < b ? a : b);\n    let smallestEvenIndex = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, smallestEvenIndex];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest\
    \ = evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    let smallestEven = evens.length > 0 ? Math.min(...evens)\
    \ : null;\n    let index = arr.indexOf(smallestEven);\n    return smallestEven\
    \ !== null ? [smallestEven, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallestEven = Math.min(...evens);\n    if(evens.length\
    \ === 0){\n        return [];\n    }\n    return [smallestEven, arr.indexOf(smallestEven)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let odd = [];\n    let result = [];\n    for(let i = 0; i < arr.length; i++){\n\
    \        if(arr[i] % 2 === 0){\n            even.push(arr[i]);\n        } else\
    \ {\n            odd.push(arr[i]);\n        }\n    }\n    if(even.length === 0){\n\
    \        return [];\n    } else {\n        let min = Math.min(...even);\n    \
    \    let index = arr.indexOf(min);\n        result.push(min);\n        result.push(index);\n\
    \        return result;\n    }\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallest = evens.length ? evens.reduce((a, b) => Math.min(a,\
    \ b)) : null;\n    let index = smallest ? arr.indexOf(smallest) : null;\n    return\
    \ smallest ? [smallest, index] : [];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[]\\n\\nshould\
    \ loosely deep-equal\\n\\n[\\n  0,\\n  1\\n]\\n    at test (/tmp/tmpepnvyqig.js:40:10)\\\
    n    at Object.<anonymous> (/tmp/tmpepnvyqig.js:47:1)\\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\\\
    n    at Module.load (node:internal/modules/cjs/loader:998:32)\\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [],\\n\
    \  expected: [ 0, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return result;\n    }\n    let min = evens[0];\n    let minIndex = evensIndex[0];\n\
    \    for(let i = 0; i < evens.length; i++){\n        if(evens[i] < min){\n   \
    \         min = evens[i];\n            minIndex = evensIndex[i];\n        }\n\
    \    }\n    result.push(min);\n    result.push(minIndex);\n    return result;\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    if(evens.length === 0){\n        return [];\n    }\n    return [min, index];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallestEven = evens.reduce((a,b) => Math.min(a,b));\n    let index =\
    \ arr.indexOf(smallestEven);\n    return [smallestEven, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if(min === Infinity){\n\
    \        return [];\n    }\n    let index = arr.indexOf(min);\n    return [min,\
    \ index];\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    return [smallest, arr.indexOf(smallest)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let idx = arr.indexOf(min);\n    return [min, idx];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let evensMin = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    evensMin.push(Math.min(...evens));\n    evensMin.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return evensMin;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    let min = Math.min(...evens);\n    for(let i =\
    \ 0; i < evens.length; i++){\n        if(evens[i] === min){\n            result.push(min);\n\
    \            result.push(evensIndex[i]);\n            return result;\n       \
    \ }\n    }\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let idx = arr.indexOf(min);\n    return\
    \ [min, idx];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallest = evens.length > 0 ? evens.reduce((a, b)\
    \ => Math.min(a, b)) : null;\n    let index = smallest !== null ? arr.indexOf(smallest)\
    \ : null;\n    return smallest !== null ? [smallest, index] : [];\n}\n\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if(min === Infinity){\n\
    \        return [];\n    }\n    let index = arr.indexOf(min);\n    return [min,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let smallestEven = [];\n    for(let i = 0; i < arr.length; i++){\n      \
    \  if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n        }\n    }\n\
    \    if(evens.length === 0){\n        return [];\n    }\n    smallestEven.push(Math.min(...evens));\n\
    \    smallestEven.push(arr.indexOf(Math.min(...evens)));\n    return smallestEven;\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallestEven =\
    \ null;\n    let smallestEvenIndex = null;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            if(smallestEven === null){\n\
    \                smallestEven = arr[i];\n                smallestEvenIndex = i;\n\
    \            } else if(arr[i] < smallestEven){\n                smallestEven =\
    \ arr[i];\n                smallestEvenIndex = i;\n            }\n        }\n\
    \    }\n    if(smallestEven === null){\n        return [];\n    }\n    return\
    \ [smallestEven, smallestEvenIndex];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Infinity;\n\
    \    let minIndex = -1;\n    let minIndex2 = -1;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0 && arr[i] < min){\n            min = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] === min){\n            minIndex2 = i;\n           \
    \ break;\n        }\n    }\n    if(minIndex2 === -1){\n        return [];\n  \
    \  }\n    return [min, minIndex2];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallest = evens.length ? evens.reduce((a, b) => Math.min(a,\
    \ b)) : null;\n    let index = smallest ? arr.indexOf(smallest) : null;\n    return\
    \ smallest ? [smallest, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[]\\n\\nshould\
    \ loosely deep-equal\\n\\n[\\n  0,\\n  1\\n]\\n    at test (/tmp/tmptdobck3i.js:41:10)\\\
    n    at Object.<anonymous> (/tmp/tmptdobck3i.js:48:1)\\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\\\
    n    at Module.load (node:internal/modules/cjs/loader:998:32)\\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [],\\n\
    \  expected: [ 0, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            even.push(arr[i]);\n     \
    \       index.push(i);\n        }\n    }\n    if(even.length === 0){\n       \
    \ return result;\n    }\n    let smallest = even[0];\n    let smallestIndex =\
    \ index[0];\n    for(let i = 0; i < even.length; i++){\n        if(even[i] < smallest){\n\
    \            smallest = even[i];\n            smallestIndex = index[i];\n    \
    \    }\n    }\n    result.push(smallest);\n    result.push(smallestIndex);\n \
    \   return result;\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let result = [];\n\
    \    let smallestEven = Infinity;\n    for(let i = 0; i < arr.length; i++){\n\
    \        if(arr[i] % 2 === 0 && arr[i] < smallestEven){\n            smallestEven\
    \ = arr[i];\n            result = [smallestEven, i];\n        }\n    }\n    return\
    \ result;\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let smallestEven = evens[0];\n    let smallestEvenIndex = evensIndex[0];\n\
    \    for(let i = 0; i < evens.length; i++){\n        if(evens[i] < smallestEven){\n\
    \            smallestEven = evens[i];\n            smallestEvenIndex = evensIndex[i];\n\
    \        }\n    }\n    return [smallestEven, smallestEvenIndex];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallestEven =\
    \ Infinity;\n    let smallestEvenIndex = Infinity;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0 && arr[i] < smallestEven){\n            smallestEven\
    \ = arr[i];\n            smallestEvenIndex = i;\n        }\n    }\n    if(smallestEven\
    \ === Infinity){\n        return [];\n    }\n    return [smallestEven, smallestEvenIndex];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallestEven =\
    \ Infinity;\n    let smallestEvenIndex = Infinity;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0 && arr[i] < smallestEven){\n            smallestEven\
    \ = arr[i];\n            smallestEvenIndex = i;\n        }\n    }\n    return\
    \ smallestEven === Infinity ? [] : [smallestEven, smallestEvenIndex];\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallest = Infinity;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < smallest){\n            smallest = arr[i];\n         \
    \   index = i;\n        }\n    }\n    return index === -1 ? [] : [smallest, index];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    if(evens.length === 0){\n        return [];\n    }\n    return [min, index];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(x => x % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0)\n    if(evens.length === 0){\n        return []\n    }\n   \
    \ let smallestEven = evens.reduce((a,b) => a < b ? a : b)\n    let index = arr.indexOf(smallestEven)\n\
    \    return [smallestEven, index]\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let smallest = evens[0];\n    let index = 0;\n    for(let i = 0; i < evens.length;\
    \ i++){\n        if(evens[i] < smallest){\n            smallest = evens[i];\n\
    \            index = i;\n        }\n    }\n    return [smallest, index];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[\\n  2,\\n\
    \  0\\n]\\n\\nshould loosely deep-equal\\n\\n[\\n  2,\\n  1\\n]\\n    at test\
    \ (/tmp/tmp0iyl38y9.js:48:10)\\n    at Object.<anonymous> (/tmp/tmp0iyl38y9.js:57:1)\\\
    n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js\
    \ (node:internal/modules/cjs/loader:1174:10)\\n    at Module.load (node:internal/modules/cjs/loader:998:32)\\\
    n    at Module._load (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [ 2, 0\
    \ ],\\n  expected: [ 2, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\\
    n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evenArr = arr.filter(num\
    \ => num % 2 === 0);\n    if(evenArr.length === 0){\n        return [];\n    }\n\
    \    let min = Math.min(...evenArr);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            even.push(arr[i]);\n            index.push(i);\n  \
    \      }\n    }\n    if(even.length === 0){\n        return [];\n    }\n    let\
    \ min = Math.min(...even);\n    let minIndex = index[even.indexOf(min)];\n   \
    \ return [min, minIndex];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length === 0 ? [] : [min, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest\
    \ = Math.min(...evens);\n    let index = arr.indexOf(smallest);\n    return [smallest,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let idx = arr.indexOf(min);\n    return [min, idx];\n}\n\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n \
    \ assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let index = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            index.push(i);\n \
    \       }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n   \
    \ let smallest = evens[0];\n    let smallestIndex = index[0];\n    for(let i =\
    \ 0; i < evens.length; i++){\n        if(evens[i] < smallest){\n            smallest\
    \ = evens[i];\n            smallestIndex = index[i];\n        }\n    }\n    return\
    \ [smallest, smallestIndex];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evenArr = arr.filter(x\
    \ => x % 2 === 0);\n    let minEven = Math.min(...evenArr);\n    let index = arr.indexOf(minEven);\n\
    \    return evenArr.length === 0 ? [] : [minEven, index];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    var evens = [];\n\
    \    var evensIndex = [];\n    var evensMin = [];\n    for(var i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    evensMin.push(Math.min(...evens));\n    evensMin.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return evensMin;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a,b) => a < b ? a : b);\n    let smallestEvenIndex = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, smallestEvenIndex];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let smallestEven = [];\n    for(let i = 0; i <\
    \ arr.length; i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n\
    \            evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    smallestEven.push(Math.min(...evens));\n    smallestEven.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return smallestEven;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let evensAndIndex = [];\n    for(let i = 0; i <\
    \ arr.length; i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n\
    \            evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    let smallestEven = Math.min(...evens);\n    let\
    \ smallestEvenIndex = evensIndex[evens.indexOf(smallestEven)];\n    evensAndIndex.push(smallestEven);\n\
    \    evensAndIndex.push(smallestEvenIndex);\n    return evensAndIndex;\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    var evens = arr.filter(function(num){\n\
    \        return num % 2 === 0;\n    });\n    if(evens.length === 0){\n       \
    \ return [];\n    }\n    var smallest = evens.reduce(function(a,b){\n        return\
    \ Math.min(a,b);\n    });\n    var index = arr.indexOf(smallest);\n    return\
    \ [smallest, index];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = evens[0];\n    let minIndex = evensIndex[0];\n    for(let i = 0;\
    \ i < evens.length; i++){\n        if(evens[i] < min){\n            min = evens[i];\n\
    \            minIndex = evensIndex[i];\n        }\n    }\n    return [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(n => n % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length > 0 ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    return [smallest, arr.indexOf(smallest)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(el\
    \ => el % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((acc, el) => el < acc ? el : acc);\n    let smallestEvenIndex\
    \ = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0){\n        return [];\n    }\n    let evens = arr.filter(num => num % 2 ===\
    \ 0);\n    if(evens.length === 0){\n        return [];\n    }\n    let smallest\
    \ = Math.min(...evens);\n    let index = arr.indexOf(smallest);\n    return [smallest,\
    \ index];\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length > 0 ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            even.push(arr[i]);\n     \
    \       index.push(i);\n        }\n    }\n    if(even.length === 0){\n       \
    \ return [];\n    }\n    let min = Math.min(...even);\n    let minIndex = index[even.indexOf(min)];\n\
    \    result.push(min);\n    result.push(minIndex);\n    return result;\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(x => x % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if (min === Infinity)\
    \ return [];\n    let index = arr.indexOf(min);\n    return [min, index];\n}\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest\
    \ = Math.min(...evens);\n    return [smallest, arr.indexOf(smallest)];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let idx = arr.indexOf(min);\n    return\
    \ [min, idx];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    let smallestEven = evens.length > 0 ? Math.min(...evens)\
    \ : null;\n    let index = arr.indexOf(smallestEven);\n    return smallestEven\
    \ !== null ? [smallestEven, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest\
    \ = Math.min(...evens);\n    let index = arr.indexOf(smallest);\n    return [smallest,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a, b) => Math.min(a, b));\n    return [smallestEven, arr.indexOf(smallestEven)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let minIndex = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            minIndex\
    \ = i;\n        }\n    }\n    return minIndex === -1 ? [] : [min, minIndex];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let smallestEven = Math.min(...evens);\n    let smallestEvenIndex = evensIndex[evens.indexOf(smallestEven)];\n\
    \    return [smallestEven, smallestEvenIndex];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallestEven = evens.reduce((a,b) => a < b ? a : b);\n    let smallestEvenIndex\
    \ = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0)\n    if(evens.length === 0) return []\n    let smallest = evens.reduce((a,b)\
    \ => a < b ? a : b)\n    let index = arr.indexOf(smallest)\n    return [smallest,\
    \ index]\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let smallest = evens[0];\n    let index = 0;\n    for(let i = 0; i < evens.length;\
    \ i++){\n        if(evens[i] < smallest){\n            smallest = evens[i];\n\
    \            index = i;\n        }\n    }\n    return [smallest, index];\n}\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[\\n  2,\\n\
    \  0\\n]\\n\\nshould loosely deep-equal\\n\\n[\\n  2,\\n  1\\n]\\n    at test\
    \ (/tmp/tmp1bhhvd2i.js:47:10)\\n    at Object.<anonymous> (/tmp/tmp1bhhvd2i.js:56:1)\\\
    n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js\
    \ (node:internal/modules/cjs/loader:1174:10)\\n    at Module.load (node:internal/modules/cjs/loader:998:32)\\\
    n    at Module._load (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [ 2, 0\
    \ ],\\n  expected: [ 2, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\\
    n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let idx = arr.indexOf(min);\n    return [min, idx];\n}\n\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n \
    \ assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => Math.min(acc, curr));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = evens[0];\n    let minIndex = evensIndex[0];\n    for(let i = 0;\
    \ i < evens.length; i++){\n        if(evens[i] < min){\n            min = evens[i];\n\
    \            minIndex = evensIndex[i];\n        }\n    }\n    return [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallestEven = evens.length > 0 ? evens.reduce((a,\
    \ b) => Math.min(a, b)) : -1;\n    let index = arr.indexOf(smallestEven);\n  \
    \  return smallestEven > -1 ? [smallestEven, index] : [];\n}\n\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n \
    \ assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            even.push(arr[i]);\n            index.push(i);\n  \
    \      }\n    }\n    if(even.length === 0){\n        return [];\n    }\n    let\
    \ min = Math.min(...even);\n    let minIndex = index[even.indexOf(min)];\n   \
    \ return [min, minIndex];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length === 0 ? [] : [min, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let smallestEvenIndex\
    \ = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(x => x % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            index =\
    \ i;\n        }\n    }\n    return index === -1 ? [] : [min, index];\n}\n\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Infinity;\n\
    \    let minIndex = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            minIndex\
    \ = i;\n        }\n    }\n    return minIndex === -1 ? [] : [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallest = Infinity;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < smallest){\n            smallest = arr[i];\n         \
    \   index = i;\n        }\n    }\n    return index === -1 ? [] : [smallest, index];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let smallestEven = evens[0];\n    let smallestEvenIndex = evensIndex[0];\n\
    \    for(let i = 0; i < evens.length; i++){\n        if(evens[i] < smallestEven){\n\
    \            smallestEven = evens[i];\n            smallestEvenIndex = evensIndex[i];\n\
    \        }\n    }\n    return [smallestEven, smallestEvenIndex];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let odd = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            even.push(arr[i]);\n        }else{\n            odd.push(arr[i]);\n\
    \        }\n    }\n    if(even.length === 0){\n        return [];\n    }\n   \
    \ let min = Math.min(...even);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let smallestEven = [];\n    for(let i = 0; i <\
    \ arr.length; i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n\
    \            evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    smallestEven.push(Math.min(...evens));\n    smallestEven.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return smallestEven;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if(min === Infinity){\n\
    \        return [];\n    }\n    let index = arr.indexOf(min);\n    return [min,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => Math.min(a,b));\n    let smallestIndex = arr.indexOf(smallest);\n\
    \    return [smallest, smallestIndex];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0){\n        return [];\n    }\n    let min = Infinity;\n    let minIndex =\
    \ -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i] % 2 === 0 &&\
    \ arr[i] < min){\n            min = arr[i];\n            minIndex = i;\n     \
    \   }\n    }\n    if(minIndex === -1){\n        return [];\n    }\n    return\
    \ [min, minIndex];\n}\n\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Infinity;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            index =\
    \ i;\n        }\n    }\n    return index === -1 ? [] : [min, index];\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0)\n    if(evens.length === 0){\n        return []\n    }\n   \
    \ let smallest = evens.reduce((acc, curr) => acc < curr ? acc : curr)\n    let\
    \ index = arr.indexOf(smallest)\n    return [smallest, index]\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let minEven = Math.min(...evens);\n\
    \    let minEvenIndex = arr.indexOf(minEven);\n    return [minEven, minEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = arr.filter(x\
    \ => x % 2 === 0);\n    if(even.length === 0) return [];\n    let min = Math.min(...even);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = Math.min(...evens);\n    let minIndex = evensIndex[evens.indexOf(min)];\n\
    \    return [min, minIndex];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = evens[0];\n    let minIndex = evensIndex[0];\n    for(let i = 0;\
    \ i < evens.length; i++){\n        if(evens[i] < min){\n            min = evens[i];\n\
    \            minIndex = evensIndex[i];\n        }\n    }\n    return [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length > 0 ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a,b) => a < b ? a : b);\n    let smallestEvenIndex = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, smallestEvenIndex];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest\
    \ = evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    let smallestEven = evens.length > 0 ? Math.min(...evens)\
    \ : null;\n    let index = arr.indexOf(smallestEven);\n    return smallestEven\
    \ !== null ? [smallestEven, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallestEven = Math.min(...evens);\n    if(evens.length\
    \ === 0){\n        return [];\n    }\n    return [smallestEven, arr.indexOf(smallestEven)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let odd = [];\n    let result = [];\n    for(let i = 0; i < arr.length; i++){\n\
    \        if(arr[i] % 2 === 0){\n            even.push(arr[i]);\n        } else\
    \ {\n            odd.push(arr[i]);\n        }\n    }\n    if(even.length === 0){\n\
    \        return [];\n    } else {\n        let min = Math.min(...even);\n    \
    \    let index = arr.indexOf(min);\n        result.push(min);\n        result.push(index);\n\
    \        return result;\n    }\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallest = evens.length ? evens.reduce((a, b) => Math.min(a,\
    \ b)) : null;\n    let index = smallest ? arr.indexOf(smallest) : null;\n    return\
    \ smallest ? [smallest, index] : [];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[]\\n\\nshould\
    \ loosely deep-equal\\n\\n[\\n  0,\\n  1\\n]\\n    at test (/tmp/tmpdxup6uju.js:40:10)\\\
    n    at Object.<anonymous> (/tmp/tmpdxup6uju.js:47:1)\\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\\\
    n    at Module.load (node:internal/modules/cjs/loader:998:32)\\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [],\\n\
    \  expected: [ 0, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return result;\n    }\n    let min = evens[0];\n    let minIndex = evensIndex[0];\n\
    \    for(let i = 0; i < evens.length; i++){\n        if(evens[i] < min){\n   \
    \         min = evens[i];\n            minIndex = evensIndex[i];\n        }\n\
    \    }\n    result.push(min);\n    result.push(minIndex);\n    return result;\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    if(evens.length === 0){\n        return [];\n    }\n    return [min, index];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallestEven = evens.reduce((a,b) => Math.min(a,b));\n    let index =\
    \ arr.indexOf(smallestEven);\n    return [smallestEven, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if(min === Infinity){\n\
    \        return [];\n    }\n    let index = arr.indexOf(min);\n    return [min,\
    \ index];\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    return [smallest, arr.indexOf(smallest)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let idx = arr.indexOf(min);\n    return [min, idx];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let evensMin = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    evensMin.push(Math.min(...evens));\n    evensMin.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return evensMin;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    let min = Math.min(...evens);\n    for(let i =\
    \ 0; i < evens.length; i++){\n        if(evens[i] === min){\n            result.push(min);\n\
    \            result.push(evensIndex[i]);\n            return result;\n       \
    \ }\n    }\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let idx = arr.indexOf(min);\n    return\
    \ [min, idx];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallest = evens.length > 0 ? evens.reduce((a, b)\
    \ => Math.min(a, b)) : null;\n    let index = smallest !== null ? arr.indexOf(smallest)\
    \ : null;\n    return smallest !== null ? [smallest, index] : [];\n}\n\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if(min === Infinity){\n\
    \        return [];\n    }\n    let index = arr.indexOf(min);\n    return [min,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let smallestEven = [];\n    for(let i = 0; i < arr.length; i++){\n      \
    \  if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n        }\n    }\n\
    \    if(evens.length === 0){\n        return [];\n    }\n    smallestEven.push(Math.min(...evens));\n\
    \    smallestEven.push(arr.indexOf(Math.min(...evens)));\n    return smallestEven;\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallestEven =\
    \ null;\n    let smallestEvenIndex = null;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            if(smallestEven === null){\n\
    \                smallestEven = arr[i];\n                smallestEvenIndex = i;\n\
    \            } else if(arr[i] < smallestEven){\n                smallestEven =\
    \ arr[i];\n                smallestEvenIndex = i;\n            }\n        }\n\
    \    }\n    if(smallestEven === null){\n        return [];\n    }\n    return\
    \ [smallestEven, smallestEvenIndex];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Infinity;\n\
    \    let minIndex = -1;\n    let minIndex2 = -1;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0 && arr[i] < min){\n            min = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] === min){\n            minIndex2 = i;\n           \
    \ break;\n        }\n    }\n    if(minIndex2 === -1){\n        return [];\n  \
    \  }\n    return [min, minIndex2];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let smallest = evens.length ? evens.reduce((a, b) => Math.min(a,\
    \ b)) : null;\n    let index = smallest ? arr.indexOf(smallest) : null;\n    return\
    \ smallest ? [smallest, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[]\\n\\nshould\
    \ loosely deep-equal\\n\\n[\\n  0,\\n  1\\n]\\n    at test (/tmp/tmphsgwlifo.js:41:10)\\\
    n    at Object.<anonymous> (/tmp/tmphsgwlifo.js:48:1)\\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\\\
    n    at Module.load (node:internal/modules/cjs/loader:998:32)\\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [],\\n\
    \  expected: [ 0, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            even.push(arr[i]);\n     \
    \       index.push(i);\n        }\n    }\n    if(even.length === 0){\n       \
    \ return result;\n    }\n    let smallest = even[0];\n    let smallestIndex =\
    \ index[0];\n    for(let i = 0; i < even.length; i++){\n        if(even[i] < smallest){\n\
    \            smallest = even[i];\n            smallestIndex = index[i];\n    \
    \    }\n    }\n    result.push(smallest);\n    result.push(smallestIndex);\n \
    \   return result;\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let result = [];\n\
    \    let smallestEven = Infinity;\n    for(let i = 0; i < arr.length; i++){\n\
    \        if(arr[i] % 2 === 0 && arr[i] < smallestEven){\n            smallestEven\
    \ = arr[i];\n            result = [smallestEven, i];\n        }\n    }\n    return\
    \ result;\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let smallestEven = evens[0];\n    let smallestEvenIndex = evensIndex[0];\n\
    \    for(let i = 0; i < evens.length; i++){\n        if(evens[i] < smallestEven){\n\
    \            smallestEven = evens[i];\n            smallestEvenIndex = evensIndex[i];\n\
    \        }\n    }\n    return [smallestEven, smallestEvenIndex];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallestEven =\
    \ Infinity;\n    let smallestEvenIndex = Infinity;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0 && arr[i] < smallestEven){\n            smallestEven\
    \ = arr[i];\n            smallestEvenIndex = i;\n        }\n    }\n    if(smallestEven\
    \ === Infinity){\n        return [];\n    }\n    return [smallestEven, smallestEvenIndex];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallestEven =\
    \ Infinity;\n    let smallestEvenIndex = Infinity;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0 && arr[i] < smallestEven){\n            smallestEven\
    \ = arr[i];\n            smallestEvenIndex = i;\n        }\n    }\n    return\
    \ smallestEven === Infinity ? [] : [smallestEven, smallestEvenIndex];\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let smallest = Infinity;\n\
    \    let index = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < smallest){\n            smallest = arr[i];\n         \
    \   index = i;\n        }\n    }\n    return index === -1 ? [] : [smallest, index];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    if(evens.length === 0){\n        return [];\n    }\n    return [min, index];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(x => x % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0)\n    if(evens.length === 0){\n        return []\n    }\n   \
    \ let smallestEven = evens.reduce((a,b) => a < b ? a : b)\n    let index = arr.indexOf(smallestEven)\n\
    \    return [smallestEven, index]\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let smallest = evens[0];\n    let index = 0;\n    for(let i = 0; i < evens.length;\
    \ i++){\n        if(evens[i] < smallest){\n            smallest = evens[i];\n\
    \            index = i;\n        }\n    }\n    return [smallest, index];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[\\n  2,\\n\
    \  0\\n]\\n\\nshould loosely deep-equal\\n\\n[\\n  2,\\n  1\\n]\\n    at test\
    \ (/tmp/tmpydcvieq9.js:48:10)\\n    at Object.<anonymous> (/tmp/tmpydcvieq9.js:57:1)\\\
    n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js\
    \ (node:internal/modules/cjs/loader:1174:10)\\n    at Module.load (node:internal/modules/cjs/loader:998:32)\\\
    n    at Module._load (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [ 2, 0\
    \ ],\\n  expected: [ 2, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\\
    n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evenArr = arr.filter(num\
    \ => num % 2 === 0);\n    if(evenArr.length === 0){\n        return [];\n    }\n\
    \    let min = Math.min(...evenArr);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            even.push(arr[i]);\n            index.push(i);\n  \
    \      }\n    }\n    if(even.length === 0){\n        return [];\n    }\n    let\
    \ min = Math.min(...even);\n    let minIndex = index[even.indexOf(min)];\n   \
    \ return [min, minIndex];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length === 0 ? [] : [min, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest\
    \ = Math.min(...evens);\n    let index = arr.indexOf(smallest);\n    return [smallest,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) {\n        return [];\n    }\n\
    \    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let idx = arr.indexOf(min);\n    return [min, idx];\n}\n\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n \
    \ assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let index = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            index.push(i);\n \
    \       }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n   \
    \ let smallest = evens[0];\n    let smallestIndex = index[0];\n    for(let i =\
    \ 0; i < evens.length; i++){\n        if(evens[i] < smallest){\n            smallest\
    \ = evens[i];\n            smallestIndex = index[i];\n        }\n    }\n    return\
    \ [smallest, smallestIndex];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evenArr = arr.filter(x\
    \ => x % 2 === 0);\n    let minEven = Math.min(...evenArr);\n    let index = arr.indexOf(minEven);\n\
    \    return evenArr.length === 0 ? [] : [minEven, index];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    var evens = [];\n\
    \    var evensIndex = [];\n    var evensMin = [];\n    for(var i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n    \
    \        evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    evensMin.push(Math.min(...evens));\n    evensMin.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return evensMin;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a,b) => a < b ? a : b);\n    let smallestEvenIndex = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, smallestEvenIndex];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let smallestEven = [];\n    for(let i = 0; i <\
    \ arr.length; i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n\
    \            evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    smallestEven.push(Math.min(...evens));\n    smallestEven.push(evensIndex[evens.indexOf(Math.min(...evens))]);\n\
    \    return smallestEven;\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    let evensAndIndex = [];\n    for(let i = 0; i <\
    \ arr.length; i++){\n        if(arr[i] % 2 === 0){\n            evens.push(arr[i]);\n\
    \            evensIndex.push(i);\n        }\n    }\n    if(evens.length === 0){\n\
    \        return [];\n    }\n    let smallestEven = Math.min(...evens);\n    let\
    \ smallestEvenIndex = evensIndex[evens.indexOf(smallestEven)];\n    evensAndIndex.push(smallestEven);\n\
    \    evensAndIndex.push(smallestEvenIndex);\n    return evensAndIndex;\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    var evens = arr.filter(function(num){\n\
    \        return num % 2 === 0;\n    });\n    if(evens.length === 0){\n       \
    \ return [];\n    }\n    var smallest = evens.reduce(function(a,b){\n        return\
    \ Math.min(a,b);\n    });\n    var index = arr.indexOf(smallest);\n    return\
    \ [smallest, index];\n}\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a, b) => Math.min(a, b));\n    let index = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let min = evens[0];\n    let minIndex = evensIndex[0];\n    for(let i = 0;\
    \ i < evens.length; i++){\n        if(evens[i] < min){\n            min = evens[i];\n\
    \            minIndex = evensIndex[i];\n        }\n    }\n    return [min, minIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(n => n % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
    \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((acc, curr) => acc < curr ? acc : curr);\n    let index = arr.indexOf(smallestEven);\n\
    \    return [smallestEven, index];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length > 0 ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => Math.min(a, b));\n    return [smallest, arr.indexOf(smallest)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(el\
    \ => el % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((acc, el) => el < acc ? el : acc);\n    let smallestEvenIndex\
    \ = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(e\
    \ => e % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0){\n        return [];\n    }\n    let evens = arr.filter(num => num % 2 ===\
    \ 0);\n    if(evens.length === 0){\n        return [];\n    }\n    let smallest\
    \ = Math.min(...evens);\n    let index = arr.indexOf(smallest);\n    return [smallest,\
    \ index];\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n\
    \    return evens.length > 0 ? [min, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let even = [];\n \
    \   let index = [];\n    let result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] % 2 === 0){\n            even.push(arr[i]);\n     \
    \       index.push(i);\n        }\n    }\n    if(even.length === 0){\n       \
    \ return [];\n    }\n    let min = Math.min(...even);\n    let minIndex = index[even.indexOf(min)];\n\
    \    result.push(min);\n    result.push(minIndex);\n    return result;\n}\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    if(arr.length ===\
    \ 0) return [];\n    let evens = arr.filter(x => x % 2 === 0);\n    if(evens.length\
    \ === 0) return [];\n    let min = Math.min(...evens);\n    return [min, arr.indexOf(min)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(n\
    \ => n % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\n\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    let min = Math.min(...evens);\n    if (min === Infinity)\
    \ return [];\n    let index = arr.indexOf(min);\n    return [min, index];\n}\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest\
    \ = Math.min(...evens);\n    return [smallest, arr.indexOf(smallest)];\n}\n\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let idx = arr.indexOf(min);\n    return\
    \ [min, idx];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    let smallestEven = evens.length > 0 ? Math.min(...evens)\
    \ : null;\n    let index = arr.indexOf(smallestEven);\n    return smallestEven\
    \ !== null ? [smallestEven, index] : [];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallest = evens.reduce((a,b) => Math.min(a,b));\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest\
    \ = Math.min(...evens);\n    let index = arr.indexOf(smallest);\n    return [smallest,\
    \ index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallestEven\
    \ = evens.reduce((a, b) => Math.min(a, b));\n    return [smallestEven, arr.indexOf(smallestEven)];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a,b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    return [min, arr.indexOf(min)];\n}\n\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let minIndex = -1;\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0 && arr[i] < min){\n            min = arr[i];\n            minIndex\
    \ = i;\n        }\n    }\n    return minIndex === -1 ? [] : [min, minIndex];\n\
    }\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = [];\n\
    \    let evensIndex = [];\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ % 2 === 0){\n            evens.push(arr[i]);\n            evensIndex.push(i);\n\
    \        }\n    }\n    if(evens.length === 0){\n        return [];\n    }\n  \
    \  let smallestEven = Math.min(...evens);\n    let smallestEvenIndex = evensIndex[evens.indexOf(smallestEven)];\n\
    \    return [smallestEven, smallestEvenIndex];\n}\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let smallestEven = evens.reduce((a,b) => a < b ? a : b);\n    let smallestEvenIndex\
    \ = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n \
    \   let min = Math.min(...evens);\n    let index = arr.indexOf(min);\n    return\
    \ [min, index];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0)\n    if(evens.length === 0) return []\n    let smallest = evens.reduce((a,b)\
    \ => a < b ? a : b)\n    let index = arr.indexOf(smallest)\n    return [smallest,\
    \ index]\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n\
    \  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let index = arr.indexOf(min);\n    return [min, index];\n}\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n\
    \  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(num\
    \ => num % 2 === 0);\n    if(evens.length === 0){\n        return [];\n    }\n\
    \    let smallest = evens[0];\n    let index = 0;\n    for(let i = 0; i < evens.length;\
    \ i++){\n        if(evens[i] < smallest){\n            smallest = evens[i];\n\
    \            index = i;\n        }\n    }\n    return [smallest, index];\n}\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: "b\"node:assert:124\\n  throw new AssertionError(obj);\\n  ^\\n\\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\\n\\n[\\n  2,\\n\
    \  0\\n]\\n\\nshould loosely deep-equal\\n\\n[\\n  2,\\n  1\\n]\\n    at test\
    \ (/tmp/tmpqxwiovr6.js:47:10)\\n    at Object.<anonymous> (/tmp/tmpqxwiovr6.js:56:1)\\\
    n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\\n    at Module._extensions..js\
    \ (node:internal/modules/cjs/loader:1174:10)\\n    at Module.load (node:internal/modules/cjs/loader:998:32)\\\
    n    at Module._load (node:internal/modules/cjs/loader:839:12)\\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\
    \ {\\n  generatedMessage: true,\\n  code: 'ERR_ASSERTION',\\n  actual: [ 2, 0\
    \ ],\\n  expected: [ 2, 1 ],\\n  operator: 'deepEqual'\\n}\\n\\nNode.js v18.7.0\\\
    n\""
  exit_code: 1
  status: AssertionError
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if (evens.length === 0) return [];\n    let smallest =\
    \ evens.reduce((a, b) => a < b ? a : b);\n    let index = arr.indexOf(smallest);\n\
    \    return [smallest, index];\n}\n\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
    \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4,\
    \ 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
    \ 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "//\"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n// your task is to pluck one of the nodes and return it.\n//\
    \ The plucked node should be the node with the smallest even value.\n// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2\
    \ has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output:\
    \ []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n// so we will choose the\
    \ first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length\
    \ <= 10000\n// * 0 <= node.value\nfunction pluck(arr){\n    let evens = arr.filter(x\
    \ => x % 2 === 0);\n    if(evens.length === 0) return [];\n    let min = Math.min(...evens);\n\
    \    let idx = arr.indexOf(min);\n    return [min, idx];\n}\n\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n \
    \ assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1,\
    \ 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5,\
    \ 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0,\
    \ 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7,\
    \ 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
