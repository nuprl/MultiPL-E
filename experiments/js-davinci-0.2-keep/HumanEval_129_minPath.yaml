name: HumanEval_129_minPath
language: javascript
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered lists of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered list of the values on the cells that the minimum\
  \ path go through.\n// Examples:\n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]],\
  \ k = 3\n// Output: [1, 2, 1]\n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k\
  \ = 1\n// Output: [1]\nfunction minPath(grid, k){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = minPath;\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1,\
  \ 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);\n\
  \  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13,\
  \ 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6, 4, 13, 10],\
  \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);\n\
  \  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3,\
  \ 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11, 8, 7, 2],\
  \ [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);\n\
  \  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
  \ 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let visited = new Set();\n  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  let dfs = function(row, col,\
    \ path, sum){\n    if(visited.has(row + ',' + col)) return;\n    if(path.length\
    \ === k){\n      if(sum < minSum){\n        minSum = sum;\n        minPath = path;\n\
    \      }\n      return;\n    }\n    visited.add(row + ',' + col);\n    for(let\
    \ dir of dirs){\n      let newRow = row + dir[0];\n      let newCol = col + dir[1];\n\
    \      if(newRow < 0 || newRow >= n || newCol < 0 || newCol >= m) continue;\n\
    \      dfs(newRow, newCol, path.concat(grid[newRow][newCol]), sum + grid[newRow][newCol]);\n\
    \    }\n    visited.delete(row + ',' + col);\n  }\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      dfs(i, j, [grid[i][j]], grid[i][j]);\n\
    \    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i]\
    \ = new Array(m).fill(false);\n  }\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      let path\
    \ = [];\n      let sum = 0;\n      dfs(grid, i, j, k, path, sum, visited);\n \
    \     if(sum < minSum){\n        minSum = sum;\n        minPath = path;\n    \
    \  }\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let min = [];\n  let visited = {};\n  let minVal = Infinity;\n\
    \  let minPath = [];\n  let dfs = function(i, j, path, val){\n    if(i < 0 ||\
    \ i >= n || j < 0 || j >= m || path.length > k){\n      return;\n    }\n    if(path.length\
    \ === k){\n      if(val < minVal){\n        minVal = val;\n        minPath = path;\n\
    \      }\n      return;\n    }\n    if(visited[i + ',' + j]){\n      return;\n\
    \    }\n    visited[i + ',' + j] = true;\n    path.push(grid[i][j]);\n    dfs(i\
    \ + 1, j, path.slice(), val + grid[i][j]);\n    dfs(i - 1, j, path.slice(), val\
    \ + grid[i][j]);\n    dfs(i, j + 1, path.slice(), val + grid[i][j]);\n    dfs(i,\
    \ j - 1, path.slice(), val + grid[i][j]);\n    visited[i + ',' + j] = false;\n\
    \  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i,\
    \ j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "  let minPath = [];\n  let\
    \ minSum = Infinity;\n  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsSumIndex\
    \ = [];\n  let minPathsSumIndexIndex = [];\n  let minPathsSumIndexIndexIndex =\
    \ [];\n  let minPathsSumIndexIndexIndexIndex = [];\n  let minPathsSumIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndex = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex = [];\n  let\
    \ minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex",
  "    var result = [];\n    var visited = [];\n    for(var i = 0; i < grid.length;\
    \ i++){\n        visited.push([]);\n        for(var j = 0; j < grid[0].length;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    var min =\
    \ Infinity;\n    var minPath = [];\n    for(var i = 0; i < grid.length; i++){\n\
    \        for(var j = 0; j < grid[0].length; j++){\n            var path = [];\n\
    \            var sum = 0;\n            dfs(grid, i, j, k, path, sum, visited,\
    \ min, minPath);\n        }\n    }\n    return minPath;\n}\n", "  // your code\
    \ here\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let min =\
    \ Infinity;\n  let minPath = [];\n  let visited = new Set();\n  let dfs = function(i,\
    \ j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i +\
    \ ',' + j)){\n      return;\n    }\n    visited.add(i + ',' + j);\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    if(path.length === k){\n      if(sum < min){\n  \
    \      min = sum;\n        minPath = path.slice();\n      }\n      visited.delete(i\
    \ + ',' + j);\n      path.pop();\n      return;\n    }\n    dfs(i + 1, j, path,\
    \ sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i,\
    \ j - 1, path, sum);\n    visited.delete(i + ',' + j);\n    path.pop();\n  }\n\
    \  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i,\
    \ j, [], 0);\n    }\n  }\n  return minPath;\n}", "  let n = grid.length;\n  let\
    \ m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i < n;\
    \ i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath = [];\n\
    \  let minSum = Number.MAX_SAFE_INTEGER;\n  for(let i = 0; i < n; i++){\n    for(let\
    \ j = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n      dfs(i,\
    \ j, k, grid, visited, path, sum);\n      if(sum < minSum){\n        minSum =\
    \ sum;\n        minPath = path;\n      }\n    }\n  }\n  return minPath;\n}\n",
  "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n \
    \   let visited = new Set();\n    let dfs = function(row, col, path, sum){\n \
    \       if(row < 0 || row >= n || col < 0 || col >= n || visited.has(row + ','\
    \ + col)){\n            return;\n        }\n        path.push(grid[row][col]);\n\
    \        sum += grid[row][col];\n        visited.add(row + ',' + col);\n     \
    \   if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path.slice();\n            }\n        }\n\
    \        dfs(row + 1, col, path, sum);\n        dfs(row - 1, col, path, sum);\n\
    \        dfs(row, col + 1, path, sum);\n        dfs(row, col - 1, path, sum);\n\
    \        path.pop();\n        visited.delete(row + ',' + col);\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\ngrid = [ [1,2,3], [4,5,6],\
    \ [7,8,9]];\nk = 3;", "  let minPath = [];\n  let minSum = Infinity;\n  let minSumPath\
    \ = [];\n  let minSumPaths = [];\n  let minSumPathsSum = Infinity;\n  let minSumPathsSumPath\
    \ = [];\n  let minSumPathsSumPaths = [];\n  let minSumPathsSumPathsSum = Infinity;\n\
    \  let minSumPathsSumPathsSumPath = [];\n  let minSumPathsSumPathsSumPaths = [];\n\
    \  let minSumPathsSumPathsSumPathsSum = Infinity;\n  let minSumPathsSumPathsSumPathsSumPath\
    \ = [];\n  let minSumPathsSumPathsSumPathsSumPaths = [];\n  let minSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n  let minSumPathsSumPathsSumPathsSumPathsSumPath = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPaths\
    \ = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSum = Infinity;\n  let\
    \ minSumPathsSumPathsSumPathsSumPathsSumPathsSumPath = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPaths\
    \ = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSum = Infinity;\n\
    \  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPath = [];\n  let\
    \ minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPaths = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPath\
    \ = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPaths\
    \ = [];\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n  let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPath", "  \
    \  let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n \
    \   for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n       \
    \     let path = [];\n            let sum = 0;\n            dfs(grid, i, j, k,\
    \ path, sum);\n            if(sum < minSum){\n                minSum = sum;\n\
    \                minPath = path;\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        for(let j\
    \ = 0; j < m; j++){\n            let path = [];\n            let sum = 0;\n  \
    \          dfs(grid, i, j, k, path, sum, visited);\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path;\n            }\n\
    \        }\n    }\n    return minPath;\n}\n", "  let n = grid.length;\n  let m\
    \ = grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let dfs = function(i, j, path,\
    \ sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minPath = path;\n      }\n      return;\n    }\n    visited[i][j] = true;\n\
    \    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i - 1, j, path, sum);\n\
    \    dfs(i + 1, j, path, sum);\n    dfs(i, j - 1, path, sum);\n    dfs(i, j +\
    \ 1, path, sum);\n    path.pop();\n    sum -= grid[i][j];\n    visited[i][j] =\
    \ false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  for(let i = 0; i < n; i++){\n    for(let\
    \ j = 0; j < m; j++){\n      dfs(i, j, [], 0);\n      if(minPathSum === minSum){\n\
    \        minPaths.push(minPath);\n        minPathsSum.push(minSum);\n      }\n\
    \      if(minPathSum > minSum){\n        minPathSum = minSum;\n        minPaths\
    \ = [minPath];\n        minPathsSum = [minSum];\n      }\n    }\n  }\n  let minPathsLex\
    \ = [];\n  let minPathsLexSum = [];\n  for(let i = 0; i < min", "    let result\
    \ = [];\n    let min = Infinity;\n    let visited = new Set();\n    let dfs =\
    \ (i, j, path, sum) => {\n        if(i < 0 || i >= grid.length || j < 0 || j >=\
    \ grid[0].length || visited.has(i + ',' + j)) return;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        visited.add(i + ',' + j);\n        if(path.length\
    \ === k){\n            if(sum < min){\n                min = sum;\n          \
    \      result = path.slice();\n            }\n            visited.delete(i + ','\
    \ + j);\n            path.pop();\n            return;\n        }\n        dfs(i\
    \ + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1,\
    \ path, sum);\n        dfs(i, j - 1, path, sum);\n        visited.delete(i + ','\
    \ + j);\n        path.pop();\n    }\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[0].length; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return result;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i <\
    \ n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n       \
    \ for(let j = 0; j < m; j++){\n            let path = [];\n            let sum\
    \ = 0;\n            dfs(i, j, k, path, sum);\n            visited[i][j] = false;\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, k, path, sum){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n          \
    \  return;\n        }\n        if(k === 0){\n            if(sum < minSum){\n \
    \               minSum = sum;\n                minPath = path.slice();\n     \
    \       }\n            return;\n        }\n        visited[i][j] = true;\n   \
    \     path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1, j,\
    \ k - 1, path, sum);\n        dfs(i - 1, j, k - 1, path, sum);\n        dfs(i,\
    \ j + 1, k - 1, path, sum);\n        dfs(i, j - 1, k - 1, path, sum);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n}\n", "    let n = grid.length;\n\
    \    let dp = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));\n \
    \   let visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n\
    \    let min = Infinity;\n    let minPath = [];\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            dfs(i, j, k, grid, dp, visited,\
    \ [], 0);\n        }\n    }\n    return minPath;\n    function dfs(i, j, k, grid,\
    \ dp, visited, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j])\
    \ return;\n        if(k === 0){\n            if(sum < min){\n                min\
    \ = sum;\n                minPath = path.slice();\n            }\n           \
    \ return;\n        }\n        if(sum > min) return;\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        dfs(i + 1, j, k - 1, grid, dp, visited,\
    \ path, sum + grid[i][j]);\n        dfs(i - 1, j, k - 1, grid, dp, visited, path,\
    \ sum + grid[i][j]);\n        dfs(i, j + 1, k - 1, grid, dp, visited, path, sum\
    \ + grid[i][j]);\n        dfs(i, j - 1, k - 1, grid, dp, visited, path, sum +\
    \ grid[i][j]);\n        visited[i][j] = false;\n        path.pop();\n    }\n}",
  "  let minPath = [];\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n\
    \  let minPath2 = [];\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n \
    \ let minPathSum4 = Infinity;\n  let minPath4 = [];\n  let minPathSum5 = Infinity;\n\
    \  let minPath5 = [];\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n \
    \ let minPathSum7 = Infinity;\n  let minPath7 = [];\n  let minPathSum8 = Infinity;\n\
    \  let minPath8 = [];\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n \
    \ let minPathSum10 = Infinity;\n  let minPath10 = [];\n  let minPathSum11 = Infinity;\n\
    \  let minPath11 = [];\n  let minPathSum12 = Infinity;\n  let minPath12 = [];\n\
    \  let minPathSum13 = Infinity;\n  let minPath13 = [];\n  let minPathSum14 = Infinity;\n\
    \  let minPath14 = [];\n  let minPathSum15 = Infinity;\n  let minPath15 = [];\n\
    \  let minPathSum16 = Infinity;\n  let minPath16 = [];\n  let minPathSum17 = Infinity;\n\
    \  let minPath17 = [];\n  let minPathSum18 = Infinity;\n  let minPath18 = [];\n\
    \  let minPathSum19 = Infinity;\n  let minPath19 = [];\n  let minPathSum20 = Infinity;\n\
    \  let minPath20 = [];\n  let minPathSum21 = Infinity;\n  let minPath21 = [];\n\
    \  let minPathSum22 = Infinity;\n  let minPath22 = [];\n  let minPathSum23 = Infinity;\n\
    \  let minPath23 = [];\n  let minPathSum24 = Infinity;\n  let minPath24 = [];\n\
    \  let minPathSum25 = Infinity;\n  let minPath25 = [];\n  let minPathSum26 = Infinity;\n\
    \  let minPath26 = [];\n  let minPathSum27 = Infinity;\n  let minPath27 = [];\n\
    \  let minPathSum28 = Infinity;\n  let minPath28 = [];\n  let minPathSum29 = Infinity;",
  "  let n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n).fill(false).map(()\
    \ => new Array(m).fill(false));\n  let min = [];\n  let minSum = Infinity;\n \
    \ let minPath = [];\n  let dfs = function(i, j, sum, path){\n    if(i < 0 || i\
    \ >= n || j < 0 || j >= m || visited[i][j]) return;\n    if(sum + grid[i][j] >\
    \ minSum) return;\n    if(path.length === k){\n      if(sum + grid[i][j] < minSum){\n\
    \        minSum = sum + grid[i][j];\n        minPath = path.slice();\n       \
    \ minPath.push(grid[i][j]);\n      }\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    path.push(grid[i][j]);\n    dfs(i + 1, j, sum + grid[i][j], path);\n\
    \    dfs(i - 1, j, sum + grid[i][j], path);\n    dfs(i, j + 1, sum + grid[i][j],\
    \ path);\n    dfs(i, j - 1, sum + grid[i][j], path);\n    path.pop();\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, 0, []);\n    }\n  }\n  return minPath;\n}", "  let minPath =\
    \ [];\n  let minPathValue = Infinity;\n  let minPathIndex = -1;\n  let minPathLength\
    \ = Infinity;\n  let n = grid.length;\n  let m = grid[0].length;\n  let visited\
    \ = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n\
    \  }\n  let dfs = function(i, j, path, pathValue, pathLength){\n    if(pathLength\
    \ > k){\n      return;\n    }\n    if(pathLength === k){\n      if(pathValue <\
    \ minPathValue){\n        minPath = path;\n        minPathValue = pathValue;\n\
    \        minPathIndex = pathLength - 1;\n        minPathLength = pathLength;\n\
    \      }else if(pathValue === minPathValue){\n        if(path[pathLength - 1]\
    \ < minPath[minPathIndex]){\n          minPath = path;\n          minPathValue\
    \ = pathValue;\n          minPathIndex = pathLength - 1;\n          minPathLength\
    \ = pathLength;\n        }\n      }\n      return;\n    }\n    visited[i][j] =\
    \ true;\n    path.push(grid[i][j]);\n    pathValue += grid[i][j];\n    pathLength++;\n\
    \    if(i > 0 && !visited[i - 1][j]){\n      dfs(i - 1, j, path, pathValue, pathLength);\n\
    \    }\n    if(i < n - 1 && !visited[i + 1][j]){\n      dfs(i + 1, j, path, pathValue,\
    \ pathLength);\n    }\n    if(j > 0 && !visited[i][j - 1]){\n      dfs(i, j -\
    \ 1, path, pathValue, pathLength);\n    }\n    if(j < m - 1 && !visited[i][j +\
    \ 1]){\n      dfs(i, j + 1, path, pathValue, pathLength);\n    }\n    path.pop();\n\
    \    pathValue -= grid[i][j];\n    pathLength--;\n    visited[i][j]", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(i, j, 0, path, sum);\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, depth, path, sum){\n\
    \        if(depth === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path.slice();\n            }\n           \
    \ return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, depth + 1, path, sum);\n  \
    \      dfs(i - 1, j, depth + 1, path, sum);\n        dfs(i, j + 1, depth + 1,\
    \ path, sum);\n        dfs(i, j - 1, depth + 1, path, sum);\n        path.pop();\n\
    \        sum -= grid[i][j];\n        visited[i][j] = false;\n    }\n}\n", "  \
    \  let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let visited = [];\n    for(let i = 0; i < n;\
    \ i++){\n        visited.push([]);\n        for(let j = 0; j < m; j++){\n    \
    \        visited[i].push(false);\n        }\n    }\n    function dfs(i, j, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n  \
    \          return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        visited[i][j] = true;\n        if(path.length === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path.slice();\n            }\n        }else{\n            dfs(i +\
    \ 1, j, path, sum);\n            dfs(i - 1, j, path, sum);\n            dfs(i,\
    \ j + 1, path, sum);\n            dfs(i, j - 1, path, sum);\n        }\n     \
    \   path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return minPath;\n}\n", "  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n \
    \ let minPath2 = [];\n  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n\
    \  let minPath4 = [];\n  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n\
    \  let minPath5 = [];\n  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n\
    \  let minPath7 = [];\n  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n\
    \  let minPath8 = [];\n  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n\
    \  let minPath10 = [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n\
    \  let minPath11 = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n\
    \  let minPath13 = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n\
    \  let minPath14 = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n\
    \  let minPath16 = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n\
    \  let minPath17 = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minSum18 = Infinity;\n  let minPathSum19 = Infinity;\n\
    \  let minPath19 = [];\n  let minSum19 = Infinity;\n ", "    let n = grid.length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let currPath = [];\n            let currSum = 0;\n            dfs(grid,\
    \ i, j, k, visited, currPath, currSum);\n            if(currSum < minSum){\n \
    \               minSum = currSum;\n                minPath = currPath;\n     \
    \       }\n        }\n    }\n    return minPath;\n}\n", "  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n\
    \  let minPath2 = [];\n  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n\
    \  let minPath4 = [];\n  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n\
    \  let minPath5 = [];\n  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n\
    \  let minPath7 = [];\n  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n\
    \  let minPath8 = [];\n  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n\
    \  let minPath10 = [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n\
    \  let minPath11 = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n\
    \  let minPath13 = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n\
    \  let minPath14 = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n\
    \  let minPath16 = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n\
    \  let minPath17 = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minSum18 = Infinity;\n  let minPathSum19 = Infinity;\n\
    \  let minPath19 = [];\n  let minSum19 = Infinity;\n ", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i\
    \ < n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath =\
    \ [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPaths\
    \ = [];\n  let dfs = function(grid, i, j, k, path, sum){\n    if(i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j] || sum > minPathSum || path.length > k){\n\
    \      return;\n    }\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n  \
    \  if(path.length === k){\n      if(sum < minPathSum){\n        minPathSum = sum;\n\
    \        minPaths = [];\n        minPaths.push(path.slice());\n      } else if(sum\
    \ === minPathSum){\n        minPaths.push(path.slice());\n      }\n      path.pop();\n\
    \      return;\n    }\n    visited[i][j] = true;\n    dfs(grid, i + 1, j, k, path,\
    \ sum);\n    dfs(grid, i - 1, j, k, path, sum);\n    dfs(grid, i, j + 1, k, path,\
    \ sum);\n    dfs(grid, i, j - 1, k, path, sum);\n    visited[i][j] = false;\n\
    \    path.pop();\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      dfs(grid, i, j, k, [], 0);\n    }\n  }\n  minPaths.sort((a, b)\
    \ => {\n    for(let i = 0; i < a.length; i++){\n      if(a[i] < b[i]){\n     \
    \   return -1;\n      } else if(a[i] > b[i]){\n        return 1;\n      }\n   ",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let minPaths = [];\n    let minPathsSum = [];\n    let dfs\
    \ = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= m\
    \ || visited[i][j]){\n            return;\n        }\n        visited[i][j] =\
    \ true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        if(path.length\
    \ === k){\n            if(sum < minPathSum){\n                minPathSum = sum;\n\
    \                minPath = path.slice();\n            }\n            if(sum ===\
    \ minPathSum){\n                if(path.toString() < minPath.toString()){\n  \
    \                  minPath = path.slice();\n                }\n            }\n\
    \            visited[i][j] = false;\n            path.pop();\n            return;\n\
    \        }\n        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n\
    \        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return minPath;\n}\n", "  let N = grid.length;\n  let minPath\
    \ = [];\n  let minPathSum = Infinity;\n  let visited = new Set();\n  let dfs =\
    \ function(i, j, path, sum){\n    if(path.length === k){\n      if(sum < minPathSum){\n\
    \        minPathSum = sum;\n        minPath = path;\n      }\n      return;\n\
    \    }\n    if(i < 0 || i >= N || j < 0 || j >= N || visited.has(i + \",\" + j)){\n\
    \      return;\n    }\n    visited.add(i + \",\" + j);\n    path.push(grid[i][j]);\n\
    \    dfs(i + 1, j, path, sum + grid[i][j]);\n    dfs(i - 1, j, path, sum + grid[i][j]);\n\
    \    dfs(i, j + 1, path, sum + grid[i][j]);\n    dfs(i, j - 1, path, sum + grid[i][j]);\n\
    \    path.pop();\n    visited.delete(i + \",\" + j);\n  }\n  for(let i = 0; i\
    \ < N; i++){\n    for(let j = 0; j < N; j++){\n      dfs(i, j, [], 0);\n    }\n\
    \  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i]\
    \ = new Array(m).fill(false);\n  }\n  let min = [];\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      let curr = [];\n      dfs(grid, i, j,\
    \ k, curr, visited, min);\n    }\n  }\n  return min;\n}\n", "  let minPath = [];\n\
    \  let minPathSum = Infinity;\n  let minPathSumIndex = 0;\n  let minPathSumIndex2\
    \ = 0;\n  let minPathSumIndex3 = 0;\n  let minPathSumIndex4 = 0;\n  let minPathSumIndex5\
    \ = 0;\n  let minPathSumIndex6 = 0;\n  let minPathSumIndex7 = 0;\n  let minPathSumIndex8\
    \ = 0;\n  let minPathSumIndex9 = 0;\n  let minPathSumIndex10 = 0;\n  let minPathSumIndex11\
    \ = 0;\n  let minPathSumIndex12 = 0;\n  let minPathSumIndex13 = 0;\n  let minPathSumIndex14\
    \ = 0;\n  let minPathSumIndex15 = 0;\n  let minPathSumIndex16 = 0;\n  let minPathSumIndex17\
    \ = 0;\n  let minPathSumIndex18 = 0;\n  let minPathSumIndex19 = 0;\n  let minPathSumIndex20\
    \ = 0;\n  let minPathSumIndex21 = 0;\n  let minPathSumIndex22 = 0;\n  let minPathSumIndex23\
    \ = 0;\n  let minPathSumIndex24 = 0;\n  let minPathSumIndex25 = 0;\n  let minPathSumIndex26\
    \ = 0;\n  let minPathSumIndex27 = 0;\n  let minPathSumIndex28 = 0;\n  let minPathSumIndex29\
    \ = 0;\n  let minPathSumIndex30 = 0;\n  let minPathSumIndex31 = 0;\n  let minPathSumIndex32\
    \ = 0;\n  let minPathSumIndex33 = 0;\n  let minPathSumIndex34 = 0;\n  let minPathSumIndex35\
    \ = 0;\n  let minPathSumIndex36 = 0;\n  let minPathSumIndex37 = 0;\n  let minPathSumIndex38\
    \ = 0;\n  let minPathSumIndex39 = 0;\n  let minPathSumIndex40 = 0;\n  let minPathSumIndex41\
    \ = 0;\n  let minPathSumIndex42 = 0;\n  let minPathSumIndex43 = 0;\n  let minPathSumIndex44\
    \ = 0;\n  let minPathSumIndex45 = 0;\n ", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i < n;\
    \ i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n   \
    \         let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "  let n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n \
    \     dfs(i, j, k, path, sum);\n    }\n  }\n  return minPath;\n  function dfs(i,\
    \ j, k, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ || path.length > k){\n      return;\n    }\n    path.push(grid[i][j]);\n   \
    \ sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minSum){\n  \
    \      minSum = sum;\n        minPath = path.slice();\n      }\n      return;\n\
    \    }\n    visited[i][j] = true;\n    dfs(i + 1, j, k, path, sum);\n    dfs(i\
    \ - 1, j, k, path, sum);\n    dfs(i, j + 1, k, path, sum);\n    dfs(i, j - 1,\
    \ k, path, sum);\n    visited[i][j] = false;\n    path.pop();\n  }\n}", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let\
    \ j = 0; j < m; j++){\n            dp[i][j] = new Array(k + 1);\n            for(let\
    \ l = 0; l <= k; l++){\n                dp[i][j][l] = new Array(2);\n        \
    \        dp[i][j][l][0] = Infinity;\n                dp[i][j][l][1] = [];\n  \
    \          }\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1]\
    \ = [grid[i][j]];\n        }\n    }\n    for(let l = 2; l <= k; l++){\n      \
    \  for(let i = 0; i < n; i++){\n            for(let j = 0; j < m; j++){\n    \
    \            let min = Infinity;\n                let minPath = [];\n        \
    \        if(i > 0){\n                    if(dp[i - 1][j][l - 1][0] < min){\n \
    \                       min = dp[i - 1][j][l - 1][0];\n                      \
    \  minPath = dp[i - 1][j][l - 1][1];\n                    }\n                }\n\
    \                if(j > 0){\n                    if(dp[i][j - 1][l - 1][0] < min){\n\
    \                        min = dp[i][j - 1][l - 1][0];\n                     \
    \   minPath = dp[i][j - 1][l - 1][1];\n                    }\n               \
    \ }\n                if(i < n - 1){\n                    if(dp[i + 1][j][l - 1][0]\
    \ < min){\n                        min = dp[i + 1][j][l - 1][0];\n           \
    \             minPath = d", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let min = [];\n  let visited = new Set();\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      let path = [];\n      let curr = grid[i][j];\n\
    \      path.push(curr);\n      visited.add(curr);\n      dfs(grid, i, j, k - 1,\
    \ path, visited);\n      visited.delete(curr);\n      if(min.length === 0 || path.length\
    \ < min.length){\n        min = path;\n      }\n      else if(path.length ===\
    \ min.length){\n        for(let i = 0; i < path.length; i++){\n          if(path[i]\
    \ < min[i]){\n            min = path;\n            break;\n          }\n     \
    \     else if(path[i] > min[i]){\n            break;\n          }\n        }\n\
    \      }\n    }\n  }\n  return min;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n   \
    \ let visited = new Set();\n    let dfs = function(i, j, path, sum){\n       \
    \ if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i + ',' + j)){\n      \
    \      return;\n        }\n        if(path.length === k){\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        visited.add(i + ',' +\
    \ j);\n        path.push(grid[i][j]);\n        dfs(i + 1, j, path.slice(), sum\
    \ + grid[i][j]);\n        dfs(i - 1, j, path.slice(), sum + grid[i][j]);\n   \
    \     dfs(i, j + 1, path.slice(), sum + grid[i][j]);\n        dfs(i, j - 1, path.slice(),\
    \ sum + grid[i][j]);\n        visited.delete(i + ',' + j);\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let minVal = Infinity;\n\
    \    let visited = new Set();\n    function dfs(i, j, path, sum){\n        if(visited.has(i\
    \ + ',' + j)) return;\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(path.length === k){\n            if(sum\
    \ < minVal){\n                minVal = sum;\n                min = path.slice();\n\
    \            }\n            else if(sum === minVal){\n                if(path.join('')\
    \ < min.join('')){\n                    min = path.slice();\n                }\n\
    \            }\n        }\n        else{\n            if(i - 1 >= 0){\n      \
    \          dfs(i - 1, j, path, sum);\n            }\n            if(i + 1 < n){\n\
    \                dfs(i + 1, j, path, sum);\n            }\n            if(j -\
    \ 1 >= 0){\n                dfs(i, j - 1, path, sum);\n            }\n       \
    \     if(j + 1 < m){\n                dfs(i, j + 1, path, sum);\n            }\n\
    \        }\n        path.pop();\n        visited.delete(i + ',' + j);\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      dfs(i, j, [], 0);\n        }\n    }\n    return min;\n}", "\n}\n", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j\
    \ < m; j++){\n      let path = [];\n      dfs(i, j, k, path, visited, grid, minPath);\n\
    \    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n   \
    \         let sum = 0;\n            dfs(i, j, k, path, sum);\n        }\n    }\n\
    \    return minPath;\n    function dfs(i, j, k, path, sum){\n        if(i < 0\
    \ || i >= n || j < 0 || j >= m || visited[i][j] || path.length > k){\n       \
    \     return;\n        }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        if(path.length === k){\n            if(sum < minSum){\n             \
    \   minSum = sum;\n                minPath = path.slice();\n            }\n  \
    \          return;\n        }\n        visited[i][j] = true;\n        dfs(i +\
    \ 1, j, k, path, sum);\n        dfs(i - 1, j, k, path, sum);\n        dfs(i, j\
    \ + 1, k, path, sum);\n        dfs(i, j - 1, k, path, sum);\n        visited[i][j]\
    \ = false;\n        path.pop();\n    }\n}", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n   \
    \ let visited = new Set();\n    let dfs = function(i, j, path, sum){\n       \
    \ if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i + ',' + j)) return;\n\
    \        if(path.length === k){\n            if(sum < minSum){\n             \
    \   minSum = sum;\n                minPath = path;\n            }\n          \
    \  return;\n        }\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i\
    \ - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1,\
    \ path, sum);\n        path.pop();\n        visited.delete(i + ',' + j);\n   \
    \ }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n  \
    \          dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  let minSum = Number.MAX_SAFE_INTEGER;\n  let minPathSum\
    \ = Number.MAX_SAFE_INTEGER;\n  let minPaths = [];\n  let minPathsSum = [];\n\
    \  let dfs = function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j]){\n      return;\n    }\n    if(path.length === k){\n\
    \      if(sum < minSum){\n        minSum = sum;\n        minPath = path;\n   \
    \   }\n      if(sum === minSum){\n        minPaths.push(path);\n        minPathsSum.push(sum);\n\
    \      }\n      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    dfs(i + 1, j, path.slice(), sum);\n    dfs(i - 1,\
    \ j, path.slice(), sum);\n    dfs(i, j + 1, path.slice(), sum);\n    dfs(i, j\
    \ - 1, path.slice(), sum);\n    visited[i][j] = false;\n  }\n  for(let i = 0;\
    \ i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, [], 0);\n   \
    \ }\n  }\n  for(let i = 0; i < minPaths.length; i++){\n    if(minPathsSum[i] <\
    \ minPathSum){\n      minPathSum = minPathsSum[i];\n      minPath = minPaths[i];\n\
    \    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i]\
    \ = new Array(m).fill(false);\n  }\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPathSum = Infinity;\n  let dfs = function(i, j, path, sum){\n    if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j] || sum > minSum){\n      return;\n\
    \    }\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n    if(path.length\
    \ === k){\n      if(sum < minPathSum){\n        minPathSum = sum;\n        minPath\
    \ = path.slice();\n      }\n      path.pop();\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    dfs(i + 1, j, path, sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i,\
    \ j + 1, path, sum);\n    dfs(i, j - 1, path, sum);\n    visited[i][j] = false;\n\
    \    path.pop();\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j]) return;\n        if(path.length === k){\n      \
    \      if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path;\n            }\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i,\
    \ j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n        path.pop();\n\
    \        visited[i][j] = false;\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n \
    \   }\n    return minPath;\n}\n", "    let n = grid.length;\n    let visited =\
    \ new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(n).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < n; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, k, path, sum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n    function dfs(i, j, k, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]) return;\n\
    \        if(k === 0){\n            if(sum < minSum){\n                minSum =\
    \ sum;\n                minPath = path.slice();\n            }\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      sum += grid[i][j];\n        dfs(i - 1, j, k - 1, path, sum);\n        dfs(i\
    \ + 1, j, k - 1, path, sum);\n        dfs(i, j - 1, k - 1, path, sum);\n     \
    \   dfs(i, j + 1, k - 1, path, sum);\n        visited[i][j] = false;\n       \
    \ path.pop();\n    }\n}", "    var n = grid.length;\n    var m = grid[0].length;\n\
    \    var visited = [];\n    for(var i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(var j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    var min = [];\n    for(var i = 0; i < n; i++){\n        for(var\
    \ j = 0; j < m; j++){\n            var curr = [];\n            dfs(grid, i, j,\
    \ k, visited, curr, min);\n        }\n    }\n    return min;\n}\n", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n\
    \    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let minPath4\
    \ = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];", "    let n = grid.length;\n    let m = grid[0].length;\n \
    \   let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(grid, i,\
    \ j, k, visited, path, sum);\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path;\n            }\n        }\n    }\n \
    \   return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ path, sum);\n            visited[i][j] = false;\n        }\n    }\n    return\
    \ minPath;\n    function dfs(i, j, k, path, sum){\n        if(i < 0 || i >= n\
    \ || j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n    \
    \    if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path.slice();\n            }\n           \
    \ return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k, path, sum);\n        dfs(i\
    \ - 1, j, k, path, sum);\n        dfs(i, j + 1, k, path, sum);\n        dfs(i,\
    \ j - 1, k, path, sum);\n        path.pop();\n        sum -= grid[i][j];\n   \
    \     visited[i][j] = false;\n    }\n}\n", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i < n; i++){\n\
    \    visited[i] = new Array(m).fill(false);\n  }\n  let minPath = [];\n  let minSum\
    \ = Infinity;\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      let path = [];\n      let sum = 0;\n      dfs(grid, i, j, k, path, sum,\
    \ visited);\n      if(sum < minSum){\n        minSum = sum;\n        minPath =\
    \ path;\n      }\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let minVal = Infinity;\n\
    \    let visited = new Set();\n    function dfs(i, j, path, sum){\n        if(sum\
    \ > minVal) return;\n        if(path.length === k){\n            if(sum < minVal){\n\
    \                minVal = sum;\n                min = path;\n            }\n \
    \           return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= m)\
    \ return;\n        if(visited.has(i + ',' + j)) return;\n        visited.add(i\
    \ + ',' + j);\n        dfs(i + 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \        dfs(i - 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i,\
    \ j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i, j - 1, path.concat(grid[i][j]),\
    \ sum + grid[i][j]);\n        visited.delete(i + ',' + j);\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return min;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minSumPath = [];\n    let dfs = function(i, j, path, sum){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minSumPath = path.slice();\n            }\n        \
    \    path.pop();\n            return;\n        }\n        visited[i][j] = true;\n\
    \        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n      \
    \  dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n        visited[i][j]\
    \ = false;\n        path.pop();\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n \
    \   }\n    return minSumPath;\n}\n", "  let minPath = [];\n  let minPathSum =\
    \ Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minPathSum3\
    \ = Infinity;\n  let minPath3 = [];\n  let minPathSum4 = Infinity;\n  let minPath4\
    \ = [];\n  let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minPathSum6\
    \ = Infinity;\n  let minPath6 = [];\n  let minPathSum7 = Infinity;\n  let minPath7\
    \ = [];\n  let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minPathSum9\
    \ = Infinity;\n  let minPath9 = [];\n  let minPathSum10 = Infinity;\n  let minPath10\
    \ = [];\n  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minPathSum12\
    \ = Infinity;\n  let minPath12 = [];\n  let minPathSum13 = Infinity;\n  let minPath13\
    \ = [];\n  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minPathSum15\
    \ = Infinity;\n  let minPath15 = [];\n  let minPathSum16 = Infinity;\n  let minPath16\
    \ = [];\n  let minPathSum17 = Infinity;\n  let minPath17 = [];\n  let minPathSum18\
    \ = Infinity;\n  let minPath18 = [];\n  let minPathSum19 = Infinity;\n  let minPath19\
    \ = [];\n  let minPathSum20 = Infinity;\n  let minPath20 = [];\n  let minPathSum21\
    \ = Infinity;\n  let minPath21 = [];\n  let minPathSum22 = Infinity;\n  let minPath22\
    \ = [];\n  let minPathSum23 = Infinity;\n  let minPath23 = [];\n  let minPathSum24\
    \ = Infinity;\n  let minPath24 = [];\n  let minPathSum25 = Infinity;\n  let minPath25\
    \ = [];\n  let minPathSum26 = Infinity;\n  let minPath26 = [];\n  let minPathSum27\
    \ = Infinity;\n  let minPath27 = [];\n  let minPathSum28 = Infinity;\n  let minPath28\
    \ = [];\n  let minPathSum29 = Infinity;", "  let minPath = [];\n  let minSum =\
    \ Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let\
    \ minPath2 = [];\n  let minSum2 = Infinity;\n  let minPath3 = [];\n  let minSum3\
    \ = Infinity;\n  let minPathSum3 = Infinity;\n  let minPath4 = [];\n  let minSum4\
    \ = Infinity;\n  let minPathSum4 = Infinity;\n  let minPath5 = [];\n  let minSum5\
    \ = Infinity;\n  let minPathSum5 = Infinity;\n  let minPath6 = [];\n  let minSum6\
    \ = Infinity;\n  let minPathSum6 = Infinity;\n  let minPath7 = [];\n  let minSum7\
    \ = Infinity;\n  let minPathSum7 = Infinity;\n  let minPath8 = [];\n  let minSum8\
    \ = Infinity;\n  let minPathSum8 = Infinity;\n  let minPath9 = [];\n  let minSum9\
    \ = Infinity;\n  let minPathSum9 = Infinity;\n  let minPath10 = [];\n  let minSum10\
    \ = Infinity;\n  let minPathSum10 = Infinity;\n  let minPath11 = [];\n  let minSum11\
    \ = Infinity;\n  let minPathSum11 = Infinity;\n  let minPath12 = [];\n  let minSum12\
    \ = Infinity;\n  let minPathSum12 = Infinity;\n  let minPath13 = [];\n  let minSum13\
    \ = Infinity;\n  let minPathSum13 = Infinity;\n  let minPath14 = [];\n  let minSum14\
    \ = Infinity;\n  let minPathSum14 = Infinity;\n  let minPath15 = [];\n  let minSum15\
    \ = Infinity;\n  let minPathSum15 = Infinity;\n  let minPath16 = [];\n  let minSum16\
    \ = Infinity;\n  let minPathSum16 = Infinity;\n  let minPath17 = [];\n  let minSum17\
    \ = Infinity;\n  let minPathSum17 = Infinity;\n  let minPath18 = [];\n  let minSum18\
    \ = Infinity;\n  let minPathSum18 = Infinity;\n  let minPath19 = [];\n  let minSum19\
    \ = Infinity;\n  let minPathSum19 = Infinity;\n ", "  let n = grid.length;\n \
    \ let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i <\
    \ n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPaths = [];\n\
    \  let minPathsSum = [];\n  let dfs = function(i, j, path, sum){\n    if(i < 0\
    \ || i >= n || j < 0 || j >= m || visited[i][j] || path.length > k){\n      return;\n\
    \    }\n    if(path.length === k){\n      if(sum < minSum){\n        minSum =\
    \ sum;\n        minPath = path;\n      }\n      if(sum === minSum){\n        minPaths.push(path);\n\
    \        minPathsSum.push(sum);\n      }\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i - 1,\
    \ j, path.slice(), sum);\n    dfs(i + 1, j, path.slice(), sum);\n    dfs(i, j\
    \ - 1, path.slice(), sum);\n    dfs(i, j + 1, path.slice(), sum);\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  let min = Infinity;\n  for(let i = 0;\
    \ i < minPaths.length; i++){\n    if(minPathsSum[i] < min){\n      min = minPathsSum[i];\n\
    \      minPath = minPaths[i];\n    }\n  }\n  return minPath;\n}", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n    let\
    \ result = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let path = [];\n            let visited = new Set();\n  \
    \          dfs(grid, i, j, k, path, visited);\n            if(path.length < min){\n\
    \                min = path.length;\n                result = path;\n        \
    \    }\n        }\n    }\n    return result;\n}\n", "  let minPath = [];\n  let\
    \ minPathSum = Infinity;\n  let minPathSumIndex = -1;\n  let minPathSumIndex2\
    \ = -1;\n  let minPathSumIndex3 = -1;\n  let minPathSumIndex4 = -1;\n  let minPathSumIndex5\
    \ = -1;\n  let minPathSumIndex6 = -1;\n  let minPathSumIndex7 = -1;\n  let minPathSumIndex8\
    \ = -1;\n  let minPathSumIndex9 = -1;\n  let minPathSumIndex10 = -1;\n  let minPathSumIndex11\
    \ = -1;\n  let minPathSumIndex12 = -1;\n  let minPathSumIndex13 = -1;\n  let minPathSumIndex14\
    \ = -1;\n  let minPathSumIndex15 = -1;\n  let minPathSumIndex16 = -1;\n  let minPathSumIndex17\
    \ = -1;\n  let minPathSumIndex18 = -1;\n  let minPathSumIndex19 = -1;\n  let minPathSumIndex20\
    \ = -1;\n  let minPathSumIndex21 = -1;\n  let minPathSumIndex22 = -1;\n  let minPathSumIndex23\
    \ = -1;\n  let minPathSumIndex24 = -1;\n  let minPathSumIndex25 = -1;\n  let minPathSumIndex26\
    \ = -1;\n  let minPathSumIndex27 = -1;\n  let minPathSumIndex28 = -1;\n  let minPathSumIndex29\
    \ = -1;\n  let minPathSumIndex30 = -1;\n  let minPathSumIndex31 = -1;\n  let minPathSumIndex32\
    \ = -1;\n  let minPathSumIndex33 = -1;\n  let minPathSumIndex34 = -1;\n  let minPathSumIndex35\
    \ = -1;\n  let minPathSumIndex36 = -1;\n  let minPathSumIndex37 = -1;\n  let minPathSumIndex38\
    \ = -1;\n  let minPathSumIndex39 = -1;\n  let minPathSumIndex40 = -1;\n  let minPathSumIndex41\
    \ = -1;\n  let minPath", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n \
    \ let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let dfs = function(i, j, path,\
    \ sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n\
    \    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minPath = path.slice();\n      }\n      if(sum === minSum){\n       \
    \ minPaths.push(path.slice());\n        minPathsSum.push(sum);\n      }\n    }\n\
    \    dfs(i + 1, j, path, sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i, j +\
    \ 1, path, sum);\n    dfs(i, j - 1, path, sum);\n    path.pop();\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  if(minPaths.length === 0){\n    return\
    \ minPath;\n  }\n  let minPathIndex = 0;\n  for(let i = 1; i < minPaths.length;\
    \ i++){\n    if(minPaths[i] < minPaths[minPathIndex]){\n      minPathIndex = i;\n\
    \    }\n  }\n  return minPaths[minPathIndex];\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    let minPathSum\
    \ = Number.MAX_SAFE_INTEGER;\n    let minPathSumHelper = function(i, j, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length\
    \ > k){\n            return;\n        }\n        path.push(grid[i][j]);\n    \
    \    sum += grid[i][j];\n        visited[i][j] = true;\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }\n            else if(sum ===\
    \ minSum){\n                if(path.join('') < minPath.join('')){\n          \
    \          minPath = path.slice();\n                }\n            }\n       \
    \ }\n        else{\n            minPathSumHelper(i - 1, j, path, sum);\n     \
    \       minPathSumHelper(i + 1, j, path, sum);\n            minPathSumHelper(i,\
    \ j - 1, path, sum);\n            minPathSumHelper(i, j + 1, path, sum);\n   \
    \     }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            minPathSumHelper(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\ngrid = [ [1,2,3], [4,5,6],\
    \ [7,8,9]];\nk = 3;", "    // Write your code here\n    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(0));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let currPath = [];\n    let currSum = 0;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            dfs(i, j, k);\n        }\n \
    \   }\n    return minPath;\n    function dfs(i, j, k){\n        if(k === 0){\n\
    \            if(currSum < minSum){\n                minSum = currSum;\n      \
    \          minPath = currPath.slice();\n            }\n            return;\n \
    \       }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = 1;\n        currPath.push(grid[i][j]);\n\
    \        currSum += grid[i][j];\n        dfs(i + 1, j, k - 1);\n        dfs(i\
    \ - 1, j, k - 1);\n        dfs(i, j + 1, k - 1);\n        dfs(i, j - 1, k - 1);\n\
    \        visited[i][j] = 0;\n        currPath.pop();\n        currSum -= grid[i][j];\n\
    \    }\n}\n", "  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum\
    \ = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minSum2\
    \ = Infinity;\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n  let minSum3\
    \ = Infinity;\n  let minPathSum4 = Infinity;\n  let minPath4 = [];\n  let minSum4\
    \ = Infinity;\n  let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minSum5\
    \ = Infinity;\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n  let minSum6\
    \ = Infinity;\n  let minPathSum7 = Infinity;\n  let minPath7 = [];\n  let minSum7\
    \ = Infinity;\n  let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minSum8\
    \ = Infinity;\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n  let minSum9\
    \ = Infinity;\n  let minPathSum10 = Infinity;\n  let minPath10 = [];\n  let minSum10\
    \ = Infinity;\n  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minSum11\
    \ = Infinity;\n  let minPathSum12 = Infinity;\n  let minPath12 = [];\n  let minSum12\
    \ = Infinity;\n  let minPathSum13 = Infinity;\n  let minPath13 = [];\n  let minSum13\
    \ = Infinity;\n  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minSum14\
    \ = Infinity;\n  let minPathSum15 = Infinity;\n  let minPath15 = [];\n  let minSum15\
    \ = Infinity;\n  let minPathSum16 = Infinity;\n  let minPath16 = [];\n  let minSum16\
    \ = Infinity;\n  let minPathSum17 = Infinity;\n  let minPath17 = [];\n  let minSum17\
    \ = Infinity;\n  let minPathSum18 = Infinity;\n  let minPath18 = [];\n  let minSum18\
    \ = Infinity;\n  let minPathSum19 = Infinity;\n  let minPath19 = [];\n  let minSum19\
    \ = Infinity;\n ", "  let n = grid.length;\n  let m = grid[0].length;\n  let min\
    \ = [];\n  let minPath = [];\n  let minPaths = [];\n  let paths = [];\n  let path\
    \ = [];\n  let visited = [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n\
    \    for(let j = 0; j < m; j++){\n      visited[i].push(false);\n    }\n  }\n\
    \  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      if(!visited[i][j]){\n\
    \        path = [];\n        dfs(grid, i, j, k, visited, path, paths);\n     \
    \ }\n    }\n  }\n  min = paths[0];\n  for(let i = 1; i < paths.length; i++){\n\
    \    if(paths[i] < min){\n      min = paths[i];\n    }\n  }\n  for(let i = 0;\
    \ i < paths.length; i++){\n    if(paths[i] === min){\n      minPaths.push(paths[i]);\n\
    \    }\n  }\n  minPath = minPaths[0];\n  for(let i = 1; i < minPaths.length; i++){\n\
    \    if(minPaths[i] < minPath){\n      minPath = minPaths[i];\n    }\n  }\n  return\
    \ minPath;\n}", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited\
    \ = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n\
    \  }\n  let minPath = [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n \
    \     dfs(i, j, k, path, sum);\n    }\n  }\n  return minPath;\n  function dfs(i,\
    \ j, k, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ || path.length > k){\n      return;\n    }\n    path.push(grid[i][j]);\n   \
    \ sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minSum){\n  \
    \      minSum = sum;\n        minPath = path.slice();\n      }\n      return;\n\
    \    }\n    visited[i][j] = true;\n    dfs(i + 1, j, k, path, sum);\n    dfs(i\
    \ - 1, j, k, path, sum);\n    dfs(i, j + 1, k, path, sum);\n    dfs(i, j - 1,\
    \ k, path, sum);\n    visited[i][j] = false;\n    path.pop();\n  }\n}\n", "  var\
    \ result = [];\n  var min = Infinity;\n  var minPath = [];\n  var visited = [];\n\
    \  var path = [];\n  var n = grid.length;\n  var m = grid[0].length;\n  var dirs\
    \ = [[0,1],[0,-1],[1,0],[-1,0]];\n  var dfs = function(i, j, k){\n    if(i < 0\
    \ || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n    }\n    if(k\
    \ === 0){\n      var sum = path.reduce(function(a,b){\n        return a + b;\n\
    \      }, 0);\n      if(sum < min){\n        min = sum;\n        minPath = path.slice();\n\
    \      }\n      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    for(var dir of dirs){\n      dfs(i + dir[0], j + dir[1], k - 1);\n    }\n\
    \    path.pop();\n    visited[i][j] = false;\n  };\n  for(var i = 0; i < n; i++){\n\
    \    visited.push([]);\n    for(var j = 0; j < m; j++){\n      visited[i].push(false);\n\
    \    }\n  }\n  for(var i = 0; i < n; i++){\n    for(var j = 0; j < m; j++){\n\
    \      dfs(i, j, k);\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let curPath\
    \ = [];\n            let curSum = 0;\n            dfs(grid, i, j, k, visited,\
    \ curPath, curSum);\n            if(curSum < minSum){\n                minSum\
    \ = curSum;\n                minPath = curPath;\n            }\n        }\n  \
    \  }\n    return minPath;\n}\n", "  // your code here\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 = [];\n\
    \  let minPathSum3 = Infinity;\n  let minPath3 = [];\n  let minPathSum4 = Infinity;\n\
    \  let minPath4 = [];\n  let minPathSum5 = Infinity;\n  let minPath5 = [];\n \
    \ let minPathSum6 = Infinity;\n  let minPath6 = [];\n  let minPathSum7 = Infinity;\n\
    \  let minPath7 = [];\n  let minPathSum8 = Infinity;\n  let minPath8 = [];\n \
    \ let minPathSum9 = Infinity;\n  let minPath9 = [];\n  let minPathSum10 = Infinity;\n\
    \  let minPath10 = [];\n  let minPathSum11 = Infinity;\n  let minPath11 = [];\n\
    \  let minPathSum12 = Infinity;\n  let minPath12 = [];\n  let minPathSum13 = Infinity;\n\
    \  let minPath13 = [];\n  let minPathSum14 = Infinity;\n  let minPath14 = [];\n\
    \  let minPathSum15 = Infinity;\n  let minPath15 = [];\n  let minPathSum16 = Infinity;\n\
    \  let minPath16 = [];\n  let minPathSum17 = Infinity;\n  let minPath17 = [];\n\
    \  let minPathSum18 = Infinity;\n  let minPath18 = [];\n  let minPathSum19 = Infinity;\n\
    \  let minPath19 = [];\n  let minPathSum20 = Infinity;\n  let minPath20 = [];\n\
    \  let minPathSum21 = Infinity;\n  let minPath21 = [];\n  let minPathSum22 = Infinity;\n\
    \  let minPath22 = [];\n  let minPathSum23 = Infinity;\n  let minPath23 = [];\n\
    \  let minPathSum24 = Infinity;\n  let minPath24 = [];\n  let minPathSum25 = Infinity;\n\
    \  let minPath25 = [];\n  let minPathSum26 = Infinity;\n  let minPath26 = [];\n\
    \  let minPathSum27 = Infinity;\n  let minPath27 = [];", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ path = [];\n  let sum = 0;\n  let visited = [];\n  for(let i = 0; i < n; i++){\n\
    \    visited.push([]);\n    for(let j = 0; j < m; j++){\n      visited[i].push(false);\n\
    \    }\n  }\n  function dfs(i, j, k){\n    if(i < 0 || i >= n || j < 0 || j >=\
    \ m || visited[i][j]){\n      return;\n    }\n    if(k === 0){\n      if(sum <\
    \ minSum){\n        minSum = sum;\n        minPath = path.slice();\n      }\n\
    \      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    dfs(i + 1, j, k - 1);\n    dfs(i - 1, j, k - 1);\n\
    \    dfs(i, j + 1, k - 1);\n    dfs(i, j - 1, k - 1);\n    path.pop();\n    sum\
    \ -= grid[i][j];\n    visited[i][j] = false;\n  }\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      dfs(i, j, k);\n    }\n  }\n  return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(i, j, 0, path, sum);\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, k, path, sum){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || k > minSum){\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        if(k === minSum && path.join('') > minPath.join('')){\n\
    \            return;\n        }\n        if(k === minSum && path.join('') < minPath.join('')){\n\
    \            minPath = path.slice();\n            return;\n        }\n       \
    \ if(k > minSum){\n            return;\n        }\n        if(k < minSum){\n \
    \           minSum = sum;\n            minPath = path.slice();\n        }\n  \
    \      visited[i][j] = true;\n        dfs(i + 1, j, k + 1, path, sum);\n     \
    \   dfs(i - 1, j, k + 1, path, sum);\n        dfs(i, j + 1, k + 1, path, sum);\n\
    \        dfs(i, j - 1, k + 1, path, sum);\n        visited[i][j] = false;\n  \
    \      path.pop();\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new\
    \ Array(k + 1).fill(0)));\n    let min = Infinity;\n    let minPath = [];\n  \
    \  for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n        \
    \    for(let l = 0; l <= k; l++){\n                if(l == 0){\n             \
    \       dp[i][j][l] = 0;\n                }\n                else if(i == 0 &&\
    \ j == 0){\n                    dp[i][j][l] = grid[i][j];\n                }\n\
    \                else if(i == 0){\n                    dp[i][j][l] = dp[i][j -\
    \ 1][l - 1] + grid[i][j];\n                }\n                else if(j == 0){\n\
    \                    dp[i][j][l] = dp[i - 1][j][l - 1] + grid[i][j];\n       \
    \         }\n                else{\n                    dp[i][j][l] = Math.min(dp[i\
    \ - 1][j][l - 1], dp[i][j - 1][l - 1]) + grid[i][j];\n                }\n    \
    \            if(l == k && dp[i][j][l] < min){\n                    min = dp[i][j][l];\n\
    \                    minPath = [grid[i][j]];\n                }\n            \
    \    else if(l == k && dp[i][j][l] == min){\n                    minPath.push(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0).map(() => new Array(k+1).fill(Infinity)));\n    let\
    \ min = Infinity;\n    let minPath = [];\n    for(let i = 0; i < n; i++){\n  \
    \      for(let j = 0; j < m; j++){\n            if(i === 0 && j === 0){\n    \
    \            dp[i][j][1] = grid[i][j];\n            }else if(i === 0){\n     \
    \           dp[i][j][1] = dp[i][j-1][1] + grid[i][j];\n            }else if(j\
    \ === 0){\n                dp[i][j][1] = dp[i-1][j][1] + grid[i][j];\n       \
    \     }else{\n                dp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1])\
    \ + grid[i][j];\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            for(let l = 2; l <= k; l++){\n\
    \                if(i === 0 && j === 0){\n                    dp[i][j][l] = grid[i][j];\n\
    \                }else if(i === 0){\n                    dp[i][j][l] = Math.min(dp[i][j-1][l],\
    \ dp[i][j-1][l-1] + grid[i][j]);\n                }else if(j === 0){\n       \
    \             dp[i][j][l] = Math.min(dp[i-1][j][l], dp[i-1][j][l-1] + grid[i][j]);\n\
    \                }else{\n                    dp[i][j][l] = Math.min(dp[i-1][j][l],\
    \ dp[i][j-1][l], d", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        for(let j\
    \ = 0; j < m; j++){\n            let path = [];\n            let sum = 0;\n  \
    \          dfs(i, j, k, path, sum);\n            visited[i][j] = false;\n    \
    \    }\n    }\n    return minPath;\n    function dfs(i, j, k, path, sum){\n  \
    \      if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum < minSum){\n  \
    \              minSum = sum;\n                minPath = path.slice();\n      \
    \      }\n            return;\n        }\n        path.push(grid[i][j]);\n   \
    \     sum += grid[i][j];\n        visited[i][j] = true;\n        dfs(i - 1, j,\
    \ k, path, sum);\n        dfs(i + 1, j, k, path, sum);\n        dfs(i, j - 1,\
    \ k, path, sum);\n        dfs(i, j + 1, k, path, sum);\n        visited[i][j]\
    \ = false;\n        path.pop();\n    }\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let min = [];\n    let minVal = Infinity;\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let val = dfs(grid, i, j, k, path);\n            if(val <\
    \ minVal){\n                minVal = val;\n                min = path;\n     \
    \       }\n        }\n    }\n    return min;\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ visited = new Set();\n  let dfs = function(i, j, path, sum){\n    if(visited.has(i\
    \ + ',' + j)){\n      return;\n    }\n    if(path.length === k){\n      if(sum\
    \ < minSum){\n        minSum = sum;\n        minPath = path;\n      }\n      return;\n\
    \    }\n    visited.add(i + ',' + j);\n    if(i > 0){\n      dfs(i - 1, j, path.concat(grid[i\
    \ - 1][j]), sum + grid[i - 1][j]);\n    }\n    if(i < n - 1){\n      dfs(i + 1,\
    \ j, path.concat(grid[i + 1][j]), sum + grid[i + 1][j]);\n    }\n    if(j > 0){\n\
    \      dfs(i, j - 1, path.concat(grid[i][j - 1]), sum + grid[i][j - 1]);\n   \
    \ }\n    if(j < m - 1){\n      dfs(i, j + 1, path.concat(grid[i][j + 1]), sum\
    \ + grid[i][j + 1]);\n    }\n    visited.delete(i + ',' + j);\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, [grid[i][j]],\
    \ grid[i][j]);\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ visited = new Set();\n  function dfs(i, j, sum, path){\n    if(i < 0 || i >=\
    \ n || j < 0 || j >= m || visited.has(i + ',' + j)) return;\n    if(path.length\
    \ === k){\n      if(sum < minSum){\n        minSum = sum;\n        minPath = path;\n\
    \      }\n      return;\n    }\n    visited.add(i + ',' + j);\n    dfs(i + 1,\
    \ j, sum + grid[i][j], path.concat(grid[i][j]));\n    dfs(i - 1, j, sum + grid[i][j],\
    \ path.concat(grid[i][j]));\n    dfs(i, j + 1, sum + grid[i][j], path.concat(grid[i][j]));\n\
    \    dfs(i, j - 1, sum + grid[i][j], path.concat(grid[i][j]));\n    visited.delete(i\
    \ + ',' + j);\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, 0, []);\n    }\n  }\n  return minPath;\n}", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i\
    \ < n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath =\
    \ [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n    for(let j\
    \ = 0; j < m; j++){\n      let currPath = [];\n      let currSum = 0;\n      dfs(grid,\
    \ i, j, k, visited, currPath, currSum);\n      if(currSum < minSum){\n       \
    \ minSum = currSum;\n        minPath = currPath;\n      }\n    }\n  }\n  return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n  \
    \  let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let dfs =\
    \ function(i, j, path, pathSum, pathLen){\n        if(pathLen === k){\n      \
    \      if(pathSum < minPathSum){\n                minPathSum = pathSum;\n    \
    \            minPath = path.slice();\n            }\n            return;\n   \
    \     }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n  \
    \          return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        pathLen++;\n        dfs(i + 1, j, path,\
    \ pathSum, pathLen);\n        dfs(i - 1, j, path, pathSum, pathLen);\n       \
    \ dfs(i, j + 1, path, pathSum, pathLen);\n        dfs(i, j - 1, path, pathSum,\
    \ pathLen);\n        path.pop();\n        pathSum -= grid[i][j];\n        pathLen--;\n\
    \        visited[i][j] = false;\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0, 0);\n        }\n\
    \    }\n    return minPath;\n}", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minPathSum\
    \ = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            let path = [];\n            let pathSum = 0;\n\
    \            dfs(grid, i, j, k, visited, path, pathSum);\n            if(pathSum\
    \ < minPathSum){\n                minPathSum = pathSum;\n                minPath\
    \ = path;\n            }\n        }\n    }\n    return minPath;\n}\n", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = new Array(k);\n  let minSum = Infinity;\n  let minPathSum\
    \ = Infinity;\n  let currPath = new Array(k);\n  let currPathSum = 0;\n  let currPathLen\
    \ = 0;\n  let currPathIdx = 0;\n  let currSum = 0;\n  let currLen = 0;\n  let\
    \ currIdx = 0;\n  let currRow = 0;\n  let currCol = 0;\n  let nextRow = 0;\n \
    \ let nextCol = 0;\n  let nextSum = 0;\n  let nextLen = 0;\n  let nextIdx = 0;\n\
    \  let nextPathSum = 0;\n  let nextPathLen = 0;\n  let nextPathIdx = 0;\n  let\
    \ nextPath = new Array(k);\n  let queue = [];\n  queue.push([0, 0, 0, 0, 0]);\n\
    \  visited[0][0] = true;\n  while(queue.length > 0){\n    [currRow, currCol, currSum,\
    \ currLen, currIdx] = queue.shift();\n    currPath[currPathLen] = grid[currRow][currCol];\n\
    \    currPathSum += grid[currRow][currCol];\n    currPathLen++;\n    if(currPathLen\
    \ === k){\n      if(currPathSum < minPathSum){\n        minPathSum = currPathSum;\n\
    \        minPath = currPath.slice();\n      }\n      currPathSum -= grid[currRow][currCol];\n\
    \      currPathLen--;\n      continue;\n    }\n    for(let i = 0; i < 4; i++){\n\
    \      nextRow = currRow + dir[i][0];\n      nextCol = currCol + dir[i][1];\n\
    \      if(next", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(false));\n  let min = [];\n\
    \  let minSum = Infinity;\n  let minPath = [];\n  let sum = 0;\n  let path = [];\n\
    \  function dfs(i, j, k){\n    if(k === 0){\n      if(sum < minSum){\n       \
    \ minSum = sum;\n        minPath = path.slice();\n      }\n      return;\n   \
    \ }\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n\
    \    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    dfs(i + 1, j, k - 1);\n    dfs(i - 1, j, k - 1);\n    dfs(i, j + 1, k - 1);\n\
    \    dfs(i, j - 1, k - 1);\n    visited[i][j] = false;\n    path.pop();\n    sum\
    \ -= grid[i][j];\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      dfs(i, j, k);\n    }\n  }\n  return minPath;\n}", "    let n =\
    \ grid.length;\n    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n\
    \        visited[i] = new Array(n).fill(false);\n    }\n    let min = [];\n  \
    \  for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n        \
    \    let cur = [];\n            dfs(grid, i, j, k, cur, visited, min);\n     \
    \       visited[i][j] = false;\n        }\n    }\n    return min;\n}\n", "  let\
    \ minPath = [];\n  let minVal = Infinity;\n  let minPaths = [];\n  let visited\
    \ = new Set();\n  let n = grid.length;\n  let m = grid[0].length;\n  let dirs\
    \ = [[0,1],[0,-1],[1,0],[-1,0]];\n  let dfs = function(i, j, path, sum){\n   \
    \ if(sum > minVal) return;\n    if(path.length === k){\n      if(sum < minVal){\n\
    \        minVal = sum;\n        minPaths = [];\n      }\n      minPaths.push(path);\n\
    \      return;\n    }\n    for(let dir of dirs){\n      let x = i + dir[0];\n\
    \      let y = j + dir[1];\n      if(x < 0 || x >= n || y < 0 || y >= m || visited.has(x\
    \ + ',' + y)) continue;\n      visited.add(x + ',' + y);\n      dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n      visited.delete(x + ',' + y);\n    }\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      visited.add(i +\
    \ ',' + j);\n      dfs(i, j, [grid[i][j]], grid[i][j]);\n      visited.delete(i\
    \ + ',' + j);\n    }\n  }\n  for(let path of minPaths){\n    if(path < minPath){\n\
    \      minPath = path;\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ minPaths = [];\n  let visited = new Set();\n  let dirs = [[0, 1], [0, -1], [1,\
    \ 0], [-1, 0]];\n  let dfs = function(i, j, path, sum){\n    if(visited.has(`${i},${j}`))\
    \ return;\n    if(path.length === k){\n      if(sum < minSum){\n        minSum\
    \ = sum;\n        minPaths = [path];\n      }else if(sum === minSum){\n      \
    \  minPaths.push(path);\n      }\n      return;\n    }\n    visited.add(`${i},${j}`);\n\
    \    for(let dir of dirs){\n      let x = i + dir[0];\n      let y = j + dir[1];\n\
    \      if(x < 0 || x >= n || y < 0 || y >= m) continue;\n      dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n    }\n    visited.delete(`${i},${j}`);\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, [grid[i][j]],\
    \ grid[i][j]);\n    }\n  }\n  minPaths.sort((a, b) => {\n    for(let i = 0; i\
    \ < k; i++){\n      if(a[i] < b[i]) return -1;\n      if(a[i] > b[i]) return 1;\n\
    \    }\n    return 0;\n  });\n  return minPaths[0];\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n).fill(false).map(() =>\
    \ new Array(m).fill(false));\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPathSum = Infinity;\n  let dfs = function(i, j, path, sum){\n    if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n    }\n\
    \    if(path.length === k){\n      if(sum < minPathSum){\n        minPathSum =\
    \ sum;\n        minPath = path;\n      }\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i + 1,\
    \ j, path.slice(), sum);\n    dfs(i - 1, j, path.slice(), sum);\n    dfs(i, j\
    \ + 1, path.slice(), sum);\n    dfs(i, j - 1, path.slice(), sum);\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            dfs(grid, i, j, k, 0, [], visited);\n\
    \        }\n    }\n    return minPath;\n    function dfs(grid, i, j, k, sum, path,\
    \ visited){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        if(path.length === k){\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(grid,\
    \ i + 1, j, k, sum, path, visited);\n        dfs(grid, i - 1, j, k, sum, path,\
    \ visited);\n        dfs(grid, i, j + 1, k, sum, path, visited);\n        dfs(grid,\
    \ i, j - 1, k, sum, path, visited);\n        visited[i][j] = false;\n        path.pop();\n\
    \    }\n}", "  let n = grid.length;\n  let m = grid[0].length;\n  let minPath\
    \ = [];\n  let minSum = Infinity;\n  let minPaths = [];\n  let visited = new Set();\n\
    \  let dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n  let dfs = function(i, j, path, sum){\n\
    \    if(visited.has(i+'-'+j)) return;\n    if(path.length === k){\n      if(sum\
    \ < minSum){\n        minSum = sum;\n        minPaths = [path];\n      } else\
    \ if(sum === minSum){\n        minPaths.push(path);\n      }\n      return;\n\
    \    }\n    visited.add(i+'-'+j);\n    for(let dir of dirs){\n      let x = i\
    \ + dir[0];\n      let y = j + dir[1];\n      if(x < 0 || x >= n || y < 0 || y\
    \ >= m) continue;\n      dfs(x, y, path.concat(grid[x][y]), sum + grid[x][y]);\n\
    \    }\n    visited.delete(i+'-'+j);\n  }\n  for(let i = 0; i < n; i++){\n   \
    \ for(let j = 0; j < m; j++){\n      dfs(i, j, [grid[i][j]], grid[i][j]);\n  \
    \  }\n  }\n  minPaths.sort((a,b) => {\n    for(let i = 0; i < k; i++){\n     \
    \ if(a[i] < b[i]) return -1;\n      if(a[i] > b[i]) return 1;\n    }\n    return\
    \ 0;\n  });\n  return minPaths[0];\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let min = [];\n    let minVal = Infinity;\n    let visited\
    \ = new Set();\n    let dfs = function(i, j, path, sum){\n        if(i < 0 ||\
    \ i >= n || j < 0 || j >= m || visited.has(i + ',' + j)){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum < minVal){\n  \
    \              minVal = sum;\n                min = path.slice();\n          \
    \  }\n            return;\n        }\n        visited.add(i + ',' + j);\n    \
    \    path.push(grid[i][j]);\n        dfs(i + 1, j, path, sum + grid[i][j]);\n\
    \        dfs(i - 1, j, path, sum + grid[i][j]);\n        dfs(i, j + 1, path, sum\
    \ + grid[i][j]);\n        dfs(i, j - 1, path, sum + grid[i][j]);\n        path.pop();\n\
    \        visited.delete(i + ',' + j);\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return min;\n}\n", "    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let minPathsSumIndex = [];\n    let minPathsSumIndex2 = [];\n    let\
    \ minPathsSumIndex3 = [];\n    let minPathsSumIndex4 = [];\n    let minPathsSumIndex5\
    \ = [];\n    let minPathsSumIndex6 = [];\n    let minPathsSumIndex7 = [];\n  \
    \  let minPathsSumIndex8 = [];\n    let minPathsSumIndex9 = [];\n    let minPathsSumIndex10\
    \ = [];\n    let minPathsSumIndex11 = [];\n    let minPathsSumIndex12 = [];\n\
    \    let minPathsSumIndex13 = [];\n    let minPathsSumIndex14 = [];\n    let minPathsSumIndex15\
    \ = [];\n    let minPathsSumIndex16 = [];\n    let minPathsSumIndex17 = [];\n\
    \    let minPathsSumIndex18 = [];\n    let minPathsSumIndex19 = [];\n    let minPathsSumIndex20\
    \ = [];\n    let minPathsSumIndex21 = [];\n    let minPathsSumIndex22 = [];\n\
    \    let minPathsSumIndex23 = [];\n    let minPathsSumIndex24 = [];\n    let minPathsSumIndex25\
    \ = [];\n    let minPathsSumIndex26 = [];\n    let minPathsSumIndex27 = [];\n\
    \    let minPathsSumIndex28 = [];\n    let minPathsSumIndex29 = [];\n    let minPathsSumIndex30\
    \ = [];\n    let minPathsSumIndex31 = [];\n    let minPathsSumIndex32 = [];\n\
    \    let minPathsSumIndex33 = [];\n    let minPathsSumIndex34 = [];\n    let minPathsSumIndex35\
    \ = [];\n    let minPathsSumIndex36 = [];\n    let minPathsSumIndex37 = [];\n\
    \    let minPathsSumIndex38 = [];\n    let minPathsSumIndex39 = [];\n    let minPathsSumIndex40\
    \ = [];\n    let minPathsSumIndex41 = [];\n    let minPathsSumIndex42 = [];\n\
    \    let minPathsSumIndex43 =", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m){\n            return;\n        }\n        if(visited[i][j]){\n  \
    \          return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(path.length === k){\n            if(sum\
    \ < minPathSum){\n                minPathSum = sum;\n                minPath =\
    \ path.slice();\n            }\n            else if(sum === minPathSum){\n   \
    \             if(path.join('') < minPath.join('')){\n                    minPath\
    \ = path.slice();\n                }\n            }\n        }\n        else{\n\
    \            dfs(i + 1, j, path, sum);\n            dfs(i - 1, j, path, sum);\n\
    \            dfs(i, j + 1, path, sum);\n            dfs(i, j - 1, path, sum);\n\
    \        }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "  let n = grid.length;\n  let m = grid[0].length;\n  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let visited = new Set();\n  let dfs = function(i, j, path, sum){\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i * m + j)){\n     \
    \ return;\n    }\n    if(path.length === k){\n      if(sum < minSum){\n      \
    \  minSum = sum;\n        minPath = path;\n      }\n      return;\n    }\n   \
    \ visited.add(i * m + j);\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    dfs(i - 1, j, path, sum);\n    dfs(i + 1, j, path, sum);\n    dfs(i, j -\
    \ 1, path, sum);\n    dfs(i, j + 1, path, sum);\n    path.pop();\n    visited.delete(i\
    \ * m + j);\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "  var n = grid.length;\n\
    \  var m = grid[0].length;\n  var visited = new Array(n);\n  for(var i = 0; i\
    \ < n; i++){\n    visited[i] = new Array(m);\n    for(var j = 0; j < m; j++){\n\
    \      visited[i][j] = false;\n    }\n  }\n  var minPath = [];\n  var minPathValue\
    \ = Infinity;\n  for(var i = 0; i < n; i++){\n    for(var j = 0; j < m; j++){\n\
    \      var path = [];\n      var pathValue = 0;\n      dfs(grid, i, j, k, visited,\
    \ path, pathValue);\n      if(pathValue < minPathValue){\n        minPathValue\
    \ = pathValue;\n        minPath = path;\n      }\n    }\n  }\n  return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let visited = new Set();\n    let dfs\
    \ = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= m\
    \ || visited.has(i + ',' + j)){\n            return;\n        }\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path;\n            }\n            return;\n        }\n\
    \        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n        sum\
    \ += grid[i][j];\n        dfs(i - 1, j, path, sum);\n        dfs(i + 1, j, path,\
    \ sum);\n        dfs(i, j - 1, path, sum);\n        dfs(i, j + 1, path, sum);\n\
    \        path.pop();\n        visited.delete(i + ',' + j);\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minSumPath = [];\n  let visited = {};\n  let\
    \ queue = [];\n  let curr = [0, 0];\n  let path = [];\n  let sum = 0;\n  let neighbors\
    \ = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  let n = grid.length;\n  let m = grid[0].length;\n\
    \  queue.push([curr, path, sum]);\n  while(queue.length){\n    [curr, path, sum]\
    \ = queue.shift();\n    let [x, y] = curr;\n    if(x < 0 || x >= n || y < 0 ||\
    \ y >= m || visited[`${x},${y}`]) continue;\n    path.push(grid[x][y]);\n    sum\
    \ += grid[x][y];\n    visited[`${x},${y}`] = true;\n    if(path.length === k){\n\
    \      if(sum < minSum){\n        minSum = sum;\n        minSumPath = path;\n\
    \      }\n    }\n    for(let i = 0; i < neighbors.length; i++){\n      let [dx,\
    \ dy] = neighbors[i];\n      queue.push([[x + dx, y + dy], path.slice(), sum]);\n\
    \    }\n  }\n  return minSumPath;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      let path = [];\n            let sum = 0;\n            dfs(i, j, k, grid,\
    \ visited, path, sum);\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path;\n            }\n            else if(sum\
    \ === minSum){\n                if(path < minPath){\n                    minPath\
    \ = path;\n                }\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let min = Infinity;\n\
    \  let minPath = [];\n  let visited = new Set();\n  let dfs = function(i, j, path,\
    \ sum){\n    if(sum > min) return;\n    if(path.length === k){\n      if(sum <\
    \ min){\n        min = sum;\n        minPath = path;\n      }\n      return;\n\
    \    }\n    if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i + ',' + j))\
    \ return;\n    visited.add(i + ',' + j);\n    path.push(grid[i][j]);\n    dfs(i\
    \ + 1, j, path.slice(), sum + grid[i][j]);\n    dfs(i - 1, j, path.slice(), sum\
    \ + grid[i][j]);\n    dfs(i, j + 1, path.slice(), sum + grid[i][j]);\n    dfs(i,\
    \ j - 1, path.slice(), sum + grid[i][j]);\n    visited.delete(i + ',' + j);\n\
    \  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i,\
    \ j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n \
    \ let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i <\
    \ n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath = [];\n\
    \  let minPathSum = Infinity;\n  let minPathSumIndex = [];\n  let minPathSumIndexes\
    \ = [];\n  let minPathSumIndexesIndex = 0;\n  let minPathSumIndexesIndexes = [];\n\
    \  let minPathSumIndexesIndexesIndex = 0;\n  let minPathSumIndexesIndexesIndexes\
    \ = [];\n  let minPathSumIndexesIndexesIndexesIndex = 0;\n  let minPathSumIndexesIndexesIndexesIndexes\
    \ = [];\n  let minPathSumIndexesIndexesIndexesIndexesIndex = 0;\n  let minPathSumIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndex = 0;\n  let\
    \ minPathSumIndexesIndexesIndexesIndexesIndexesIndexes = [];\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexes = [];\n\
    \  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex = 0;\n\
    \  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes = [];\n\
    \  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n  let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes",
  "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(() => new\
    \ Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minSumPath = [];\n    let dfs = function(i, j, path, sum){\n        if(visited[i][j])\
    \ return;\n        if(path.length === k){\n            if(sum < minSum){\n   \
    \             minSum = sum;\n                minSumPath = path.slice();\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        if(i > 0) dfs(i\
    \ - 1, j, path, sum);\n        if(i < n - 1) dfs(i + 1, j, path, sum);\n     \
    \   if(j > 0) dfs(i, j - 1, path, sum);\n        if(j < n - 1) dfs(i, j + 1, path,\
    \ sum);\n        path.pop();\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minSumPath;\n}\n", "  // your code\
    \ here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ dfs = function(i, j, path, pathSum){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j]){\n            return;\n        }\n        if(path.length\
    \ === k){\n            if(pathSum < minPathSum){\n                minPathSum =\
    \ pathSum;\n                minPath = path.slice();\n            }\n         \
    \   return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        dfs(i + 1, j, path, pathSum);\n     \
    \   dfs(i - 1, j, path, pathSum);\n        dfs(i, j + 1, path, pathSum);\n   \
    \     dfs(i, j - 1, path, pathSum);\n        path.pop();\n        pathSum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n \
    \   }\n    return minPath;\n}\n", "  var min = [];\n  var minSum = Infinity;\n\
    \  var minPath = [];\n  var minPathSum = Infinity;\n  var minPathLength = Infinity;\n\
    \  var minPathLengthSum = Infinity;\n  var minPathLengthPath = [];\n  var minPathLengthPathSum\
    \ = Infinity;\n  var minPathLengthPathLength = Infinity;\n  var minPathLengthPathLengthSum\
    \ = Infinity;\n  var minPathLengthPathLengthPath = [];\n  var minPathLengthPathLengthPathSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLength = Infinity;\n  var minPathLengthPathLengthPathLengthSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPath = [];\n  var minPathLengthPathLengthPathLengthPathSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLength = Infinity;\n\
    \  var minPathLengthPathLengthPathLengthPathLengthSum = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPath\
    \ = [];\n  var minPathLengthPathLengthPathLengthPathLengthPathSum = Infinity;\n\
    \  var minPathLengthPathLengthPathLengthPathLengthPathLength = Infinity;\n  var\
    \ minPathLengthPathLengthPathLengthPathLengthPathLengthSum = Infinity;\n  var\
    \ minPathLengthPathLengthPathLengthPathLengthPathLengthPath = [];\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLength\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPath\
    \ = [];\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLength\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPath\
    \ = [];\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathSum\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLength\
    \ = Infinity;\n  var minPathLengthPathLengthPathLengthPathLengthPathLengthPathLengthPathLength",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let\
    \ j = 0; j < m; j++){\n            dp[i][j] = new Array(k+1);\n            for(let\
    \ l = 0; l <= k; l++){\n                dp[i][j][l] = new Array(2);\n        \
    \        dp[i][j][l][0] = Number.MAX_SAFE_INTEGER;\n                dp[i][j][l][1]\
    \ = [];\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n  \
    \      for(let j = 0; j < m; j++){\n            dp[i][j][1][0] = grid[i][j];\n\
    \            dp[i][j][1][1].push(grid[i][j]);\n        }\n    }\n    for(let l\
    \ = 2; l <= k; l++){\n        for(let i = 0; i < n; i++){\n            for(let\
    \ j = 0; j < m; j++){\n                let min = Number.MAX_SAFE_INTEGER;\n  \
    \              let minPath = [];\n                if(i > 0){\n               \
    \     if(dp[i-1][j][l-1][0] < min){\n                        min = dp[i-1][j][l-1][0];\n\
    \                        minPath = dp[i-1][j][l-1][1].slice();\n             \
    \       }\n                }\n                if(j > 0){\n                   \
    \ if(dp[i][j-1][l-1][0] < min){\n                        min = dp[i][j-1][l-1][0];\n\
    \                        minPath = dp[i][j-1][l-1][1].slice();\n             \
    \       }\n                }\n                if(i < n-1){\n                 \
    \   if(dp[i+1][j][l-1][0] < min){\n                        min =", "  let n =\
    \ grid.length;\n  let m = grid[0].length;\n  let min = [];\n  let minPath = [];\n\
    \  let visited = new Set();\n  let queue = [];\n  queue.push([0,0,0]);\n  while(queue.length\
    \ > 0){\n    let [i,j,path] = queue.shift();\n    if(visited.has(`${i}${j}`)){\n\
    \      continue;\n    }\n    visited.add(`${i}${j}`);\n    path.push(grid[i][j]);\n\
    \    if(path.length === k){\n      if(min.length === 0){\n        min = path;\n\
    \        minPath = [i,j];\n      }else{\n        for(let i = 0; i < k; i++){\n\
    \          if(min[i] < path[i]){\n            break;\n          }else if(min[i]\
    \ > path[i]){\n            min = path;\n            minPath = [i,j];\n       \
    \     break;\n          }\n        }\n      }\n    }else{\n      if(i > 0){\n\
    \        queue.push([i-1,j,path.slice()]);\n      }\n      if(i < n-1){\n    \
    \    queue.push([i+1,j,path.slice()]);\n      }\n      if(j > 0){\n        queue.push([i,j-1,path.slice()]);\n\
    \      }\n      if(j < m-1){\n        queue.push([i,j+1,path.slice()]);\n    \
    \  }\n    }\n  }\n  return min;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n \
    \ let min = [];\n  let minSum = Infinity;\n  let dfs = function(i, j, sum, path){\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n    if(path.length\
    \ === k){\n      if(sum < minSum){\n        minSum = sum;\n        min = path;\n\
    \      }\n      return;\n    }\n    visited[i][j] = true;\n    dfs(i + 1, j, sum\
    \ + grid[i][j], path.concat(grid[i][j]));\n    dfs(i - 1, j, sum + grid[i][j],\
    \ path.concat(grid[i][j]));\n    dfs(i, j + 1, sum + grid[i][j], path.concat(grid[i][j]));\n\
    \    dfs(i, j - 1, sum + grid[i][j], path.concat(grid[i][j]));\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, 0, []);\n    }\n  }\n  return min;\n}\n", "    let n = grid.length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let visited = new Set();\n\
    \    let dfs = function(i, j, sum, path){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= n || visited.has(i + ',' + j)){\n            return;\n        }\n  \
    \      if(path.length === k){\n            if(sum < minSum){\n               \
    \ minSum = sum;\n                minPath = path;\n            }\n            return;\n\
    \        }\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, sum, path);\n        dfs(i\
    \ - 1, j, sum, path);\n        dfs(i, j + 1, sum, path);\n        dfs(i, j - 1,\
    \ sum, path);\n        path.pop();\n        visited.delete(i + ',' + j);\n   \
    \ }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n  \
    \          dfs(i, j, 0, []);\n        }\n    }\n    return minPath;\n}\n", " \
    \ let n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPathSum = Infinity;\n  let dfs = function(i, j, path, sum){\n    if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n    if(path.length\
    \ === k){\n      if(sum < minSum){\n        minSum = sum;\n        minPath = path;\n\
    \      }\n      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    dfs(i + 1, j, path, sum);\n    dfs(i - 1, j, path,\
    \ sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i, j - 1, path, sum);\n    path.pop();\n\
    \    visited[i][j] = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j\
    \ = 0; j < m; j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, k, path, sum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n    function dfs(i, j, k, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n  \
    \          return;\n        }\n        if(k === 0){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1,\
    \ j, k - 1, path, sum);\n        dfs(i - 1, j, k - 1, path, sum);\n        dfs(i,\
    \ j + 1, k - 1, path, sum);\n        dfs(i, j - 1, k - 1, path, sum);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n}", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let minPath = [];\n    let\
    \ minPaths = [];\n    let visited = [];\n    for(let i = 0; i < n; i++){\n   \
    \     visited.push([]);\n        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            let path = [];\n            let paths = [];\n        \
    \    dfs(i, j, k, path, paths, visited);\n            if(paths.length > 0){\n\
    \                if(minPaths.length === 0){\n                    minPaths = paths;\n\
    \                    minPath = path;\n                    min = [grid[i][j]];\n\
    \                }\n                else{\n                    if(paths[0].length\
    \ < minPaths[0].length){\n                        minPaths = paths;\n        \
    \                minPath = path;\n                        min = [grid[i][j]];\n\
    \                    }\n                    else if(paths[0].length === minPaths[0].length){\n\
    \                        if(path[0] < minPath[0]){\n                         \
    \   minPaths = paths;\n                            minPath = path;\n         \
    \                   min = [grid[i][j]];\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ min;\n}", "  let result = [];\n  let min = Infinity;\n  let minPath = [];\n\
    \  let visited = {};\n  let n = grid.length;\n  let m = grid[0].length;\n  let\
    \ dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n  let dfs = function(i, j, path, sum){\n\
    \    if(sum > min){\n      return;\n    }\n    if(path.length === k){\n      if(sum\
    \ < min){\n        min = sum;\n        minPath = path;\n      }\n      return;\n\
    \    }\n    for(let dir of dirs){\n      let x = i + dir[0];\n      let y = j\
    \ + dir[1];\n      if(x >= 0 && x < n && y >= 0 && y < m && !visited[x+'-'+y]){\n\
    \        visited[x+'-'+y] = true;\n        dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n        visited[x+'-'+y] = false;\n      }\n    }\n  }\n\
    \  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      visited[i+'-'+j]\
    \ = true;\n      dfs(i, j, [grid[i][j]], grid[i][j]);\n      visited[i+'-'+j]\
    \ = false;\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n \
    \   let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            dfs(i, j, k, grid, visited, path, sum);\n        \
    \    if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path;\n            }\n        }\n    }\n    return minPath;\n}\n", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minSum2 = Infinity;\n\
    \  let minPathSum3 = Infinity;\n  let minPath3 = [];\n  let minSum3 = Infinity;\n\
    \  let minPathSum4 = Infinity;\n  let minPath4 = [];\n  let minSum4 = Infinity;\n\
    \  let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minSum5 = Infinity;\n\
    \  let minPathSum6 = Infinity;\n  let minPath6 = [];\n  let minSum6 = Infinity;\n\
    \  let minPathSum7 = Infinity;\n  let minPath7 = [];\n  let minSum7 = Infinity;\n\
    \  let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minSum8 = Infinity;\n\
    \  let minPathSum9 = Infinity;\n  let minPath9 = [];\n  let minSum9 = Infinity;\n\
    \  let minPathSum10 = Infinity;\n  let minPath10 = [];\n  let minSum10 = Infinity;\n\
    \  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minSum11 = Infinity;\n\
    \  let minPathSum12 = Infinity;\n  let minPath12 = [];\n  let minSum12 = Infinity;\n\
    \  let minPathSum13 = Infinity;\n  let minPath13 = [];\n  let minSum13 = Infinity;\n\
    \  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minSum14 = Infinity;\n\
    \  let minPathSum15 = Infinity;\n  let minPath15 = [];\n  let minSum15 = Infinity;\n\
    \  let minPathSum16 = Infinity;\n  let minPath16 = [];\n  let minSum16 = Infinity;\n\
    \  let minPathSum17 = Infinity;\n  let minPath17 = [];", "    let n = grid.length,\n\
    \        m = grid[0].length,\n        result = [],\n        min = Infinity,\n\
    \        visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let temp = [];\n            dfs(i, j, temp, grid, k, visited);\n\
    \            if(temp.length === k){\n                if(temp.join('') < min){\n\
    \                    min = temp.join('');\n                    result = temp;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(i, j, 0, k, path,\
    \ sum);\n            visited[i][j] = false;\n        }\n    }\n    return minPath;\n\
    \    function dfs(i, j, currLen, k, path, sum){\n        if(currLen === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path.slice();\n            }\n            return;\n        }\n  \
    \      if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      sum += grid[i][j];\n        dfs(i + 1, j, currLen + 1, k, path, sum);\n\
    \        dfs(i - 1, j, currLen + 1, k, path, sum);\n        dfs(i, j + 1, currLen\
    \ + 1, k, path, sum);\n        dfs(i, j - 1, currLen + 1, k, path, sum);\n   \
    \     path.pop();\n        sum -= grid[i][j];\n        visited[i][j] = false;\n\
    \    }\n}\n", "    // your code here\n}\n", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let dfs = function(i, j, path, sum, pathSum){\n    if(i < 0 || i >= n || j\
    \ < 0 || j >= m || visited[i][j]){\n      return;\n    }\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    pathSum += grid[i][j] * path.length;\n    if(path.length\
    \ === k){\n      if(pathSum < minPathSum){\n        minPathSum = pathSum;\n  \
    \      minPath = path.slice();\n      }\n      else if(pathSum === minPathSum){\n\
    \        if(sum < minSum){\n          minSum = sum;\n          minPath = path.slice();\n\
    \        }\n        else if(sum === minSum){\n          for(let i = 0; i < path.length;\
    \ i++){\n            if(path[i] < minPath[i]){\n              minPath = path.slice();\n\
    \              break;\n            }\n            else if(path[i] > minPath[i]){\n\
    \              break;\n            }\n          }\n        }\n      }\n      path.pop();\n\
    \      return;\n    }\n    visited[i][j] = true;\n    dfs(i - 1, j, path, sum,\
    \ pathSum);\n    dfs(i + 1, j, path, sum, pathSum);\n    dfs(i, j - 1, path, sum,\
    \ pathSum);\n    dfs(i, j + 1, path, sum, pathSum);\n    visited[i][j] = false;\n\
    \    path.pop();\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      dfs(i, j, [], 0, 0);\n    }\n  }\n  return minPath;\n}", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let minSumPath = [];\n  let visited = new Set();\n  let dfs =\
    \ function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i\
    \ + '-' + j)){\n      return;\n    }\n    visited.add(i + '-' + j);\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minSum){\n\
    \        minSum = sum;\n        minSumPath = path.slice();\n      }\n      visited.delete(i\
    \ + '-' + j);\n      path.pop();\n      return;\n    }\n    dfs(i + 1, j, path,\
    \ sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i,\
    \ j - 1, path, sum);\n    visited.delete(i + '-' + j);\n    path.pop();\n  }\n\
    \  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i,\
    \ j, [], 0);\n    }\n  }\n  return minSumPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "  let n = grid.length;\n  let m = grid[0].length;\n  let min = [];\n  let minPath\
    \ = [];\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n    \
    \  let path = [];\n      let visited = new Set();\n      let curr = [i, j];\n\
    \      visited.add(curr);\n      path.push(grid[i][j]);\n      dfs(curr, path,\
    \ visited, k);\n      if(path.length === k){\n        if(min.length === 0 || path.length\
    \ < min.length){\n          min = path;\n          minPath = [curr];\n       \
    \ } else if(path.length === min.length){\n          if(path < min){\n        \
    \    min = path;\n            minPath = [curr];\n          }\n        }\n    \
    \  }\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i <\
    \ n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            let currPath = [];\n\
    \            let currSum = 0;\n            dfs(i, j, k, currPath, currSum);\n\
    \        }\n    }\n    return minPath;\n\n    function dfs(i, j, k, currPath,\
    \ currSum){\n        if(k === 0){\n            if(currSum < minSum){\n       \
    \         minSum = currSum;\n                minPath = currPath.slice();\n   \
    \         }\n            return;\n        }\n        if(i < 0 || i >= n || j <\
    \ 0 || j >= m || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        currPath.push(grid[i][j]);\n        currSum += grid[i][j];\n\
    \        dfs(i - 1, j, k - 1, currPath, currSum);\n        dfs(i + 1, j, k - 1,\
    \ currPath, currSum);\n        dfs(i, j - 1, k - 1, currPath, currSum);\n    \
    \    dfs(i, j + 1, k - 1, currPath, currSum);\n        currPath.pop();\n     \
    \   currSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n}\n", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let minPathSumHelper = (i, j, path, sum) => {\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if(path.length === k){\n            if(sum < minPathSum){\n               \
    \ minPathSum = sum;\n                minPath = path.slice();\n            }\n\
    \            path.pop();\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        minPathSumHelper(i + 1, j, path, sum);\n        minPathSumHelper(i\
    \ - 1, j, path, sum);\n        minPathSumHelper(i, j + 1, path, sum);\n      \
    \  minPathSumHelper(i, j - 1, path, sum);\n        visited[i][j] = false;\n  \
    \      path.pop();\n    }\n    for(let i = 0; i < n; i++){\n        for(let j\
    \ = 0; j < m; j++){\n            minPathSumHelper(i, j, [], 0);\n        }\n \
    \   }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let minPathSum44\
    \ = Infinity;\n    let minPathSum45 = Infinity;\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    let minPathSum\
    \ = Number.MAX_SAFE_INTEGER;\n    let minPathSum2 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath2 = [];\n    function dfs(i, j, path, sum, pathSum){\n       \
    \ if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length > k){\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        pathSum += grid[i][j] * path.length;\n        visited[i][j]\
    \ = true;\n        if(path.length === k){\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            if(sum < minSum){\n                minSum = sum;\n\
    \                minPath2 = path.slice();\n                minPathSum2 = pathSum;\n\
    \            }\n            else if(sum === minSum && pathSum < minPathSum2){\n\
    \                minPath2 = path.slice();\n                minPathSum2 = pathSum;\n\
    \            }\n        }\n        dfs(i + 1, j, path, sum, pathSum);\n      \
    \  dfs(i - 1, j, path, sum, pathSum);\n        dfs(i, j + 1, path, sum, pathSum);\n\
    \        dfs(i, j - 1, path, sum, pathSum);\n        visited[i][j] = false;\n\
    \        path.pop();\n    }\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            dfs(i, j, [], 0, 0);\n        }\n    }\n   ",
  "    let minPath = [];\n    let minPathSum = Infinity;\n    let minPathSumIndex\
    \ = 0;\n    let minPathSumIndex2 = 0;\n    let minPathSumIndex3 = 0;\n    let\
    \ minPathSumIndex4 = 0;\n    let minPathSumIndex5 = 0;\n    let minPathSumIndex6\
    \ = 0;\n    let minPathSumIndex7 = 0;\n    let minPathSumIndex8 = 0;\n    let\
    \ minPathSumIndex9 = 0;\n    let minPathSumIndex10 = 0;\n    let minPathSumIndex11\
    \ = 0;\n    let minPathSumIndex12 = 0;\n    let minPathSumIndex13 = 0;\n    let\
    \ minPathSumIndex14 = 0;\n    let minPathSumIndex15 = 0;\n    let minPathSumIndex16\
    \ = 0;\n    let minPathSumIndex17 = 0;\n    let minPathSumIndex18 = 0;\n    let\
    \ minPathSumIndex19 = 0;\n    let minPathSumIndex20 = 0;\n    let minPathSumIndex21\
    \ = 0;\n    let minPathSumIndex22 = 0;\n    let minPathSumIndex23 = 0;\n    let\
    \ minPathSumIndex24 = 0;\n    let minPathSumIndex25 = 0;\n    let minPathSumIndex26\
    \ = 0;\n    let minPathSumIndex27 = 0;\n    let minPathSumIndex28 = 0;\n    let\
    \ minPathSumIndex29 = 0;\n    let minPathSumIndex30 = 0;\n    let minPathSumIndex31\
    \ = 0;\n    let minPathSumIndex32 = 0;\n    let minPathSumIndex33 = 0;\n    let\
    \ minPathSumIndex34 = 0;\n    let minPathSumIndex35 = 0;\n    let minPathSumIndex36\
    \ = 0;\n    let minPathSumIndex37 = 0;\n    let minPathSumIndex38 = 0;\n    let\
    \ minPathSumIndex39 = 0;\n    let minPathSumIndex40 = 0;\n    let minPathSumIndex41\
    \ = 0;\n    let minPathSumIndex42 = 0;\n    let minPathSumIndex43 = 0;\n    let\
    \ minPathSumIndex44 = 0;\n    let minPathSumIndex45 = 0;\n   ", "  let minPath\
    \ = [];\n  let minPathSum = Infinity;\n  let minPathSumIndex = -1;\n  let minPathSumIndexes\
    \ = [];\n  let minPathSumIndexesSum = Infinity;\n  let minPathSumIndexesSumIndex\
    \ = -1;\n  let minPathSumIndexesSumIndexes = [];\n  let minPathSumIndexesSumIndexesSum\
    \ = Infinity;\n  let minPathSumIndexesSumIndexesSumIndex = -1;\n  let minPathSumIndexesSumIndexesSumIndexes\
    \ = [];\n  let minPathSumIndexesSumIndexesSumIndexesSum = Infinity;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexes = [];\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = Infinity;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndex =\
    \ -1;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes = [];\n\
    \  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum = Infinity;\n\
    \  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndex = -1;\n\
    \  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes = [];\n\
    \  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = Infinity;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes\
    \ = [];\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = Infinity;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n  let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes\
    \ = [];\n  let minPathSumIndexesSumIndexesSumIndex", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            dfs(i, j, k, path, sum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n    function dfs(i, j, k, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n  \
    \          return;\n        }\n        if(k === 0){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1,\
    \ j, k - 1, path, sum);\n        dfs(i - 1, j, k - 1, path, sum);\n        dfs(i,\
    \ j + 1, k - 1, path, sum);\n        dfs(i, j - 1, k - 1, path, sum);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j]){\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(path.length === k){\n            if(sum\
    \ < minPathSum){\n                minPathSum = sum;\n                minPath =\
    \ path.slice();\n            }\n            else if(sum === minPathSum){\n   \
    \             if(path < minPath){\n                    minPath = path.slice();\n\
    \                }\n            }\n            path.pop();\n            return;\n\
    \        }\n        visited[i][j] = true;\n        dfs(i + 1, j, path, sum);\n\
    \        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n      \
    \  dfs(i, j - 1, path, sum);\n        visited[i][j] = false;\n        path.pop();\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", " \
    \ let n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minPathSum4 = Infinity;\n  let minPath4 = [];\n \
    \ let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minPathSum7 = Infinity;\n  let minPath7 = [];\n \
    \ let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minPathSum10 = Infinity;\n  let minPath10 = [];\n\
    \  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minPathSum13 = Infinity;\n  let minPath13 = [];\n\
    \  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minPathSum16 = Infinity;\n  let minPath16 = [];\n\
    \  let minPathSum17 = Infinity;\n  let minPath17 = [];\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minPathSum19 = Infinity;\n  let minPath19 = [];\n\
    \  let minPathSum20 = Infinity;\n  let minPath20 = [];\n  let minPathSum21 = Infinity;\n\
    \  let minPath21 = [];\n  let minPathSum22 = Infinity;\n  let minPath22 = [];\n\
    \  let minPathSum23 = Infinity;\n  let minPath23 = [];\n  let minPathSum24 = Infinity;\n\
    \  let minPath24 = [];\n  let minPathSum25 = Infinity", "    let n = grid.length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let visited = new Set();\n    let dfs = function(row, col, path, sum){\n\
    \        if(row < 0 || row >= n || col < 0 || col >= n || visited.has(row + ','\
    \ + col)){\n            return;\n        }\n        path.push(grid[row][col]);\n\
    \        sum += grid[row][col];\n        visited.add(row + ',' + col);\n     \
    \   if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path.slice();\n            }\n           \
    \ else if(sum === minSum){\n                if(path.join('') < minPath.join('')){\n\
    \                    minPath = path.slice();\n                }\n            }\n\
    \        }\n        else{\n            dfs(row + 1, col, path, sum);\n       \
    \     dfs(row - 1, col, path, sum);\n            dfs(row, col + 1, path, sum);\n\
    \            dfs(row, col - 1, path, sum);\n        }\n        path.pop();\n \
    \       visited.delete(row + ',' + col);\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let path = [];\n            let pathSum = 0;\n          \
    \  dfs(i, j, k, grid, visited, path, pathSum);\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path;\n    \
    \        }\n        }\n    }\n    return minPath;\n}\n", "  let n = grid.length;\n\
    \  let visited = [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n \
    \   for(let j = 0; j < n; j++){\n      visited[i].push(false);\n    }\n  }\n \
    \ let minPath = [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < n; j++){\n      let path = [];\n      let sum = 0;\n \
    \     dfs(i, j, k, path, sum);\n      visited[i][j] = false;\n    }\n  }\n  return\
    \ minPath;\n  function dfs(i, j, k, path, sum){\n    if(k === 0){\n      if(sum\
    \ < minSum){\n        minSum = sum;\n        minPath = path.slice();\n      }\n\
    \      return;\n    }\n    if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n\
    \      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    dfs(i - 1, j, k - 1, path, sum);\n    dfs(i + 1,\
    \ j, k - 1, path, sum);\n    dfs(i, j - 1, k - 1, path, sum);\n    dfs(i, j +\
    \ 1, k - 1, path, sum);\n    path.pop();\n    visited[i][j] = false;\n  }\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathSum2\
    \ = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n    let visited\
    \ = new Set();\n    let path = [];\n    let sum = 0;\n    let pathSum = 0;\n \
    \   let pathSum2 = 0;\n    let path2 = [];\n    let sum2 = 0;\n    let queue =\
    \ [];\n    let queue2 = [];\n    let queue3 = [];\n    let queue4 = [];\n    let\
    \ queue5 = [];\n    let queue6 = [];\n    let queue7 = [];\n    let queue8 = [];\n\
    \    let queue9 = [];\n    let queue10 = [];\n    let queue11 = [];\n    let queue12\
    \ = [];\n    let queue13 = [];\n    let queue14 = [];\n    let queue15 = [];\n\
    \    let queue16 = [];\n    let queue17 = [];\n    let queue18 = [];\n    let\
    \ queue19 = [];\n    let queue20 = [];\n    let queue21 = [];\n    let queue22\
    \ = [];\n    let queue23 = [];\n    let queue24 = [];\n    let queue25 = [];\n\
    \    let queue26 = [];\n    let queue27 = [];\n    let queue28 = [];\n    let\
    \ queue29 = [];\n    let queue30 = [];\n    let queue31 = [];\n    let queue32\
    \ = [];\n    let queue33 = [];\n    let queue34 = [];\n    let queue35 = [];\n\
    \    let queue36 = [];\n    let queue37 = [];\n    let queue38 = [];\n    let\
    \ queue39 = [];\n    let queue40 = [];\n    let queue41 = [];\n    let queue42\
    \ = [];\n    let queue43 = [];\n    let queue44 = [];\n    let queue45 = [];\n\
    \    let queue46 = [];\n    let queue47 = [];\n    let queue48 = [];\n    let\
    \ queue49 = [];\n    let queue50 = [];\n    let queue51 = [];\n    let queue52\
    \ = [];\n    let queue53 = [];\n    let queue54 = [];\n    let queue55 = [];\n\
    \    let queue", "    let minPath = [];\n    let minPathSum = Infinity;\n    let\
    \ minPathSumIndex = Infinity;\n    let minPathSumIndex2 = Infinity;\n    let minPathSumIndex3\
    \ = Infinity;\n    let minPathSumIndex4 = Infinity;\n    let minPathSumIndex5\
    \ = Infinity;\n    let minPathSumIndex6 = Infinity;\n    let minPathSumIndex7\
    \ = Infinity;\n    let minPathSumIndex8 = Infinity;\n    let minPathSumIndex9\
    \ = Infinity;\n    let minPathSumIndex10 = Infinity;\n    let minPathSumIndex11\
    \ = Infinity;\n    let minPathSumIndex12 = Infinity;\n    let minPathSumIndex13\
    \ = Infinity;\n    let minPathSumIndex14 = Infinity;\n    let minPathSumIndex15\
    \ = Infinity;\n    let minPathSumIndex16 = Infinity;\n    let minPathSumIndex17\
    \ = Infinity;\n    let minPathSumIndex18 = Infinity;\n    let minPathSumIndex19\
    \ = Infinity;\n    let minPathSumIndex20 = Infinity;\n    let minPathSumIndex21\
    \ = Infinity;\n    let minPathSumIndex22 = Infinity;\n    let minPathSumIndex23\
    \ = Infinity;\n    let minPathSumIndex24 = Infinity;\n    let minPathSumIndex25\
    \ = Infinity;\n    let minPathSumIndex26 = Infinity;\n    let minPathSumIndex27\
    \ = Infinity;\n    let minPathSumIndex28 = Infinity;\n    let minPathSumIndex29\
    \ = Infinity;\n    let minPathSumIndex30 = Infinity;\n    let minPathSumIndex31\
    \ = Infinity;\n    let minPathSumIndex32 = Infinity;\n    let minPathSumIndex33\
    \ = Infinity;\n    let minPathSumIndex34 = Infinity;\n    let minPathSumIndex35\
    \ = Infinity;\n    let minPathSumIndex36 = Infinity;\n    let minPathSumIndex37\
    \ = Infinity;\n    let minPathSumIndex38 = Infinity;\n    let minPathSumIndex39\
    \ = Infinity;\n    let minPathSumIndex40 = Infinity;\n    let minPathSumIndex41\
    \ = Infinity;\n    let minPathSumIndex42 = Infinity;\n    let minPathSumIndex43\
    \ = Infinity;\n    let minPathSumIndex44 = Infinity;\n    let minPathSumIndex45\
    \ = Infinity;\n   ", "    // your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let visited = new Set();\n    let dfs = function(i, j, pathSum, path){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || path.length > k || pathSum >\
    \ minPathSum){\n            return;\n        }\n        if(path.length === k){\n\
    \            if(pathSum < minPathSum){\n                minPathSum = pathSum;\n\
    \                minPath = path;\n            }\n            return;\n       \
    \ }\n        visited.add(i + ',' + j);\n        dfs(i + 1, j, pathSum + grid[i][j],\
    \ path.concat(grid[i][j]));\n        dfs(i - 1, j, pathSum + grid[i][j], path.concat(grid[i][j]));\n\
    \        dfs(i, j + 1, pathSum + grid[i][j], path.concat(grid[i][j]));\n     \
    \   dfs(i, j - 1, pathSum + grid[i][j], path.concat(grid[i][j]));\n        visited.delete(i\
    \ + ',' + j);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0;\
    \ j < m; j++){\n            dfs(i, j, 0, []);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let visited\
    \ = new Set();\n    let dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n    let dfs = function(i,\
    \ j, path, sum){\n        if(sum > minSum){\n            return;\n        }\n\
    \        if(path.length == k){\n            if(sum < minPathSum){\n          \
    \      minPathSum = sum;\n                minPath = path;\n            }\n   \
    \         return;\n        }\n        for(let dir of dirs){\n            let x\
    \ = i + dir[0];\n            let y = j + dir[1];\n            if(x < 0 || x >=\
    \ n || y < 0 || y >= m || visited.has(x + ',' + y)){\n                continue;\n\
    \            }\n            visited.add(x + ',' + y);\n            dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n            visited.delete(x + ',' + y);\n        }\n  \
    \  }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n \
    \           visited.add(i + ',' + j);\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n\
    \            visited.delete(i + ',' + j);\n        }\n    }\n    return minPath;\n\
    }\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited = new\
    \ Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n\
    \  }\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let dfs = function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j] || path.length > k){\n      return;\n    }\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minPathSum){\n\
    \        minPathSum = sum;\n        minPath = path.slice();\n      }\n      else\
    \ if(sum === minPathSum){\n        if(path.slice().sort().join('') < minPath.slice().sort().join('')){\n\
    \          minPath = path.slice();\n        }\n      }\n      path.pop();\n  \
    \    return;\n    }\n    visited[i][j] = true;\n    dfs(i + 1, j, path, sum);\n\
    \    dfs(i - 1, j, path, sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i, j -\
    \ 1, path, sum);\n    visited[i][j] = false;\n    path.pop();\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, [], 0);\n\
    \    }\n  }\n  return minPath;\n}\nlet grid = [ [1,2,3], [4,5,6], [7,8,9]];\n\
    let k = 3;", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited\
    \ = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n\
    \  }\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  function dfs(i, j, path, pathSum){\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n\
    \    }\n    if(path.length === k){\n      if(pathSum < minPathSum){\n        minPath\
    \ = path;\n        minPathSum = pathSum;\n      }\n      else if(pathSum === minPathSum){\n\
    \        minPaths.push(path);\n        minPathsSum.push(pathSum);\n      }\n \
    \     return;\n    }\n    visited[i][j] = true;\n    dfs(i + 1, j, path.concat(grid[i][j]),\
    \ pathSum + grid[i][j]);\n    dfs(i - 1, j, path.concat(grid[i][j]), pathSum +\
    \ grid[i][j]);\n    dfs(i, j + 1, path.concat(grid[i][j]), pathSum + grid[i][j]);\n\
    \    dfs(i, j - 1, path.concat(grid[i][j]), pathSum + grid[i][j]);\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  if(minPaths.length === 0){\n    return\
    \ minPath;\n  }\n  let minPathIndex = 0;\n  for(let i = 1; i < minPaths.length;\
    \ i++){\n    if(minPaths[i].join('') < minPaths[minPathIndex].", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(false));\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ dfs = function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m\
    \ || visited[i][j]) return;\n    if(path.length === k){\n      if(sum < minSum){\n\
    \        minSum = sum;\n        minPath = path;\n      }\n      return;\n    }\n\
    \    visited[i][j] = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    dfs(i + 1, j, path, sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i, j +\
    \ 1, path, sum);\n    dfs(i, j - 1, path, sum);\n    path.pop();\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let min = [];\n  let minSum = Infinity;\n  let minPath\
    \ = [];\n  let visited = [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n\
    \    for(let j = 0; j < m; j++){\n      visited[i].push(false);\n    }\n  }\n\
    \  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      let sum\
    \ = 0;\n      let path = [];\n      dfs(i, j, k, sum, path);\n    }\n  }\n  return\
    \ minPath;\n  function dfs(i, j, k, sum, path){\n    if(i < 0 || i >= n || j <\
    \ 0 || j >= m || visited[i][j] || sum > minSum){\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    sum += grid[i][j];\n    path.push(grid[i][j]);\n    if(path.length\
    \ === k){\n      if(sum < minSum){\n        minSum = sum;\n        minPath = path.slice();\n\
    \      }\n      visited[i][j] = false;\n      return;\n    }\n    dfs(i - 1, j,\
    \ k, sum, path);\n    dfs(i + 1, j, k, sum, path);\n    dfs(i, j - 1, k, sum,\
    \ path);\n    dfs(i, j + 1, k, sum, path);\n    visited[i][j] = false;\n  }\n}",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let min = Infinity;\n    let minPath = [];\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            dfs(grid, i, j, k, path, visited);\n            if(path.length <\
    \ min){\n                min = path.length;\n                minPath = path;\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, k, visited, path,\
    \ sum);\n            if(sum < minSum){\n                minSum = sum;\n      \
    \          minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let visited = new Set();\n    let dfs\
    \ = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= m\
    \ || visited.has(i + ',' + j)) return;\n        path.push(grid[i][j]);\n     \
    \   sum += grid[i][j];\n        visited.add(i + ',' + j);\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }\n            visited.delete(i\
    \ + ',' + j);\n            path.pop();\n            return;\n        }\n     \
    \   dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i,\
    \ j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n        visited.delete(i\
    \ + ',' + j);\n        path.pop();\n    }\n    for(let i = 0; i < n; i++){\n \
    \       for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let res = [];\n    let min = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let curr = grid[i][j];\n   \
    \         let path = [curr];\n            let visited = new Set();\n         \
    \   visited.add(curr);\n            dfs(grid, i, j, k, path, visited);\n     \
    \       if(path.length < min){\n                min = path.length;\n         \
    \       res = path;\n            }\n        }\n    }\n    return res;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let sum = 0;\n    let path = [];\n    let dfs = function(i, j, k){\n    \
    \    if(k === 0){\n            if(sum < minSum){\n                minSum = sum;\n\
    \                minPath = path.slice();\n            }\n            return;\n\
    \        }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        sum +=\
    \ grid[i][j];\n        path.push(grid[i][j]);\n        dfs(i + 1, j, k - 1);\n\
    \        dfs(i - 1, j, k - 1);\n        dfs(i, j + 1, k - 1);\n        dfs(i,\
    \ j - 1, k - 1);\n        visited[i][j] = false;\n        sum -= grid[i][j];\n\
    \        path.pop();\n    }\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            dfs(i, j, k);\n        }\n    }\n    return\
    \ minPath;\n}\ngrid = [ [1,2,3], [4,5,6], [7,8,9]];\nk = 3;", "  let minPath =\
    \ [];\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2\
    \ = [];\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n  let minPathSum4\
    \ = Infinity;\n  let minPath4 = [];\n  let minPathSum5 = Infinity;\n  let minPath5\
    \ = [];\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n  let minPathSum7\
    \ = Infinity;\n  let minPath7 = [];\n  let minPathSum8 = Infinity;\n  let minPath8\
    \ = [];\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n  let minPathSum10\
    \ = Infinity;\n  let minPath10 = [];\n  let minPathSum11 = Infinity;\n  let minPath11\
    \ = [];\n  let minPathSum12 = Infinity;\n  let minPath12 = [];\n  let minPathSum13\
    \ = Infinity;\n  let minPath13 = [];\n  let minPathSum14 = Infinity;\n  let minPath14\
    \ = [];\n  let minPathSum15 = Infinity;\n  let minPath15 = [];\n  let minPathSum16\
    \ = Infinity;\n  let minPath16 = [];\n  let minPathSum17 = Infinity;\n  let minPath17\
    \ = [];\n  let minPathSum18 = Infinity;\n  let minPath18 = [];\n  let minPathSum19\
    \ = Infinity;\n  let minPath19 = [];\n  let minPathSum20 = Infinity;\n  let minPath20\
    \ = [];\n  let minPathSum21 = Infinity;\n  let minPath21 = [];\n  let minPathSum22\
    \ = Infinity;\n  let minPath22 = [];\n  let minPathSum23 = Infinity;\n  let minPath23\
    \ = [];\n  let minPathSum24 = Infinity;\n  let minPath24 = [];\n  let minPathSum25\
    \ = Infinity;\n  let minPath25 = [];\n  let minPathSum26 = Infinity;\n  let minPath26\
    \ = [];\n  let minPathSum27 = Infinity;\n  let minPath27 = [];\n  let minPathSum28\
    \ = Infinity;\n  let minPath28 = [];\n  let minPathSum29 = Infinity;", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j\
    \ < m; j++){\n      let path = [];\n      dfs(grid, i, j, k, visited, path);\n\
    \      if(minPath.length === 0 || path.length > 0 && path.length < minPath.length){\n\
    \        minPath = path;\n      }\n    }\n  }\n  return minPath;\n}\n", "  let\
    \ n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n\
    \  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n \
    \ }\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      let path = [];\n      let sum = 0;\n      let paths = [];\n   \
    \   dfs(grid, i, j, k, visited, path, sum, paths);\n      if(sum < minSum){\n\
    \        minSum = sum;\n        minPath = path;\n        minPaths = paths;\n \
    \     }\n      else if(sum === minSum){\n        if(paths.length < minPaths.length){\n\
    \          minPath = path;\n          minPaths = paths;\n        }\n        else\
    \ if(paths.length === minPaths.length){\n          if(path.length < minPath.length){\n\
    \            minPath = path;\n            minPaths = paths;\n          }\n   \
    \       else if(path.length === minPath.length){\n            for(let i = 0; i\
    \ < path.length; i++){\n              if(path[i] < minPath[i]){\n            \
    \    minPath = path;\n                minPaths = paths;\n                break;\n\
    \              }\n              else if(path[i] > minPath[i]){\n             \
    \   break;\n              }\n            }\n          }\n        }\n      }\n\
    \    }\n  }\n  return minPath;\n}\n", "  let minPath = [];\n  let minPathSum =\
    \ Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minPathSum3\
    \ = Infinity;\n  let minPath3 = [];\n  let minPathSum4 = Infinity;\n  let minPath4\
    \ = [];\n  let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minPathSum6\
    \ = Infinity;\n  let minPath6 = [];\n  let minPathSum7 = Infinity;\n  let minPath7\
    \ = [];\n  let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minPathSum9\
    \ = Infinity;\n  let minPath9 = [];\n  let minPathSum10 = Infinity;\n  let minPath10\
    \ = [];\n  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minPathSum12\
    \ = Infinity;\n  let minPath12 = [];\n  let minPathSum13 = Infinity;\n  let minPath13\
    \ = [];\n  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minPathSum15\
    \ = Infinity;\n  let minPath15 = [];\n  let minPathSum16 = Infinity;\n  let minPath16\
    \ = [];\n  let minPathSum17 = Infinity;\n  let minPath17 = [];\n  let minPathSum18\
    \ = Infinity;\n  let minPath18 = [];\n  let minPathSum19 = Infinity;\n  let minPath19\
    \ = [];\n  let minPathSum20 = Infinity;\n  let minPath20 = [];\n  let minPathSum21\
    \ = Infinity;\n  let minPath21 = [];\n  let minPathSum22 = Infinity;\n  let minPath22\
    \ = [];\n  let minPathSum23 = Infinity;\n  let minPath23 = [];\n  let minPathSum24\
    \ = Infinity;\n  let minPath24 = [];\n  let minPathSum25 = Infinity;\n  let minPath25\
    \ = [];\n  let minPathSum26 = Infinity;\n  let minPath26 = [];\n  let minPathSum27\
    \ = Infinity;\n  let minPath27 = [];\n  let minPathSum28 = Infinity;\n  let minPath28\
    \ = [];\n  let minPathSum29 = Infinity;", "  // your code here\n}\n", "  // your\
    \ code here\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited\
    \ = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n\
    \  }\n  let minPath = [];\n  let minSum = Number.MAX_SAFE_INTEGER;\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      let path = [];\n\
    \      let sum = 0;\n      dfs(i, j, k, path, sum);\n      visited[i][j] = false;\n\
    \    }\n  }\n  return minPath;\n  function dfs(i, j, k, path, sum){\n    if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n    }\n\
    \    if(k === 0){\n      if(sum < minSum){\n        minSum = sum;\n        minPath\
    \ = path.slice();\n      }\n      return;\n    }\n    visited[i][j] = true;\n\
    \    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i + 1, j, k - 1,\
    \ path, sum);\n    dfs(i - 1, j, k - 1, path, sum);\n    dfs(i, j + 1, k - 1,\
    \ path, sum);\n    dfs(i, j - 1, k - 1, path, sum);\n    visited[i][j] = false;\n\
    \    path.pop();\n  }\n}", "    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minSumPath = [];\n    let minSumPaths = [];\n    let minSumPathsSum =\
    \ Infinity;\n    let minSumPathsSumPath = [];\n    let minSumPathsSumPaths = [];\n\
    \    let minSumPathsSumPathsSum = Infinity;\n    let minSumPathsSumPathsSumPath\
    \ = [];\n    let minSumPathsSumPathsSumPaths = [];\n    let minSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n    let minSumPathsSumPathsSumPathsSumPath = [];\n    let minSumPathsSumPathsSumPathsSumPaths\
    \ = [];\n    let minSumPathsSumPathsSumPathsSumPathsSum = Infinity;\n    let minSumPathsSumPathsSumPathsSumPathsSumPath\
    \ = [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPaths = [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPath = [];\n\
    \    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPaths = [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPath\
    \ = [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPaths =\
    \ [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPath\
    \ = [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPaths\
    \ = [];\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSumPathsSum\
    \ = Infinity;\n    let minSumPathsSumPathsSumPathsSumPathsSumPathsSumPath", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let dfs = function(i, j, path, sum){\n  \
    \      if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n     \
    \   path.push(grid[i][j]);\n        sum += grid[i][j];\n        if(path.length\
    \ === k){\n            if(sum < minPathSum){\n                minPathSum = sum;\n\
    \                minPath = path.slice();\n            }\n            else if(sum\
    \ === minPathSum){\n                if(path.join('') < minPath.join('')){\n  \
    \                  minPath = path.slice();\n                }\n            }\n\
    \            path.pop();\n            sum -= grid[i][j];\n            return;\n\
    \        }\n        visited[i][j] = true;\n        dfs(i + 1, j, path, sum);\n\
    \        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n      \
    \  dfs(i, j - 1, path, sum);\n        visited[i][j] = false;\n        path.pop();\n\
    \        sum -= grid[i][j];\n    }\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return\
    \ minPath;\n}\ngrid = [ [1,2,3], [4,5,6], [7,8,9]];\nk = 3;", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    let dfs =\
    \ function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= m ||\
    \ visited[i][j]){\n            return;\n        }\n        if(path.length ===\
    \ k){\n            if(sum < minSum){\n                minSum = sum;\n        \
    \        minPath = path.slice();\n            }\n            return;\n       \
    \ }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum\
    \ += grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path,\
    \ sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n\
    \        path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, [],\
    \ 0);\n        }\n    }\n    return minPath;\n}\n", "  // your code here\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(grid, i, j, k, visited,\
    \ path, sum);\n            if(sum < minSum){\n                minSum = sum;\n\
    \                minPath = path;\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let minPath\
    \ = [];\n  let minSum = Infinity;\n  let visited = new Set();\n  let dfs = function(i,\
    \ j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i +\
    \ ',' + j)){\n      return;\n    }\n    if(path.length === k){\n      if(sum <\
    \ minSum){\n        minSum = sum;\n        minPath = path;\n      }\n      return;\n\
    \    }\n    visited.add(i + ',' + j);\n    path.push(grid[i][j]);\n    sum +=\
    \ grid[i][j];\n    dfs(i - 1, j, path, sum);\n    dfs(i + 1, j, path, sum);\n\
    \    dfs(i, j - 1, path, sum);\n    dfs(i, j + 1, path, sum);\n    path.pop();\n\
    \    visited.delete(i + ',' + j);\n  }\n  for(let i = 0; i < n; i++){\n    for(let\
    \ j = 0; j < m; j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n\
    }\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited = new\
    \ Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n\
    \  }\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPathLength = Infinity;\n  let minPathIndex = Infinity;\n  let dfs =\
    \ function(i, j, path, pathSum, pathLength, pathIndex){\n    if(pathLength > k){\n\
    \      return;\n    }\n    if(pathLength === k){\n      if(pathSum < minSum){\n\
    \        minSum = pathSum;\n        minPath = path;\n        minPathSum = pathSum;\n\
    \        minPathLength = pathLength;\n        minPathIndex = pathIndex;\n    \
    \  }else if(pathSum === minSum){\n        if(pathLength < minPathLength){\n  \
    \        minPath = path;\n          minPathSum = pathSum;\n          minPathLength\
    \ = pathLength;\n          minPathIndex = pathIndex;\n        }else if(pathLength\
    \ === minPathLength){\n          if(pathIndex < minPathIndex){\n            minPath\
    \ = path;\n            minPathSum = pathSum;\n            minPathLength = pathLength;\n\
    \            minPathIndex = pathIndex;\n          }\n        }\n      }\n    \
    \  return;\n    }\n    visited[i][j] = true;\n    if(i > 0 && !visited[i - 1][j]){\n\
    \      dfs(i - 1, j, path.concat(grid[i - 1][j]), pathSum + grid[i - 1][j], pathLength\
    \ + 1, pathIndex * n * m + grid[i - 1][j]);\n    }\n    if(i < n - 1 && !visited[i\
    \ + 1][j]){\n      dfs(i + 1, j, path.concat(grid[i + 1][j]), pathSum + grid[i\
    \ + 1][j], pathLength + 1, pathIndex * n * m + grid[i + 1][j]);\n    }\n    if(j\
    \ > 0", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new\
    \ Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n\
    \        for(let j = 0; j < m; j++){\n            dp[i][j] = new Array(k + 1);\n\
    \            for(let l = 0; l <= k; l++){\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = Infinity;\n                dp[i][j][l][1] =\
    \ [];\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dp[i][j][1][0] = grid[i][j];\n \
    \           dp[i][j][1][1] = [grid[i][j]];\n        }\n    }\n    for(let l =\
    \ 2; l <= k; l++){\n        for(let i = 0; i < n; i++){\n            for(let j\
    \ = 0; j < m; j++){\n                if(i - 1 >= 0){\n                    if(dp[i][j][l][0]\
    \ > dp[i - 1][j][l - 1][0]){\n                        dp[i][j][l][0] = dp[i -\
    \ 1][j][l - 1][0];\n                        dp[i][j][l][1] = dp[i - 1][j][l -\
    \ 1][1].slice();\n                        dp[i][j][l][1].push(grid[i][j]);\n \
    \                   }\n                    else if(dp[i][j][l][0] == dp[i - 1][j][l\
    \ - 1][0]){\n                        let temp = dp[i - 1][j][l - 1][1].slice();\n\
    \                        temp.push(grid[i][j]);\n                        if(lexicographicallyLess(temp,\
    \ dp[i][j][l][1])){\n                           ", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n\
    \    let visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let path = [];\n            let pathSum = 0;\n          \
    \  dfs(i, j, path, pathSum, visited);\n            if(pathSum < min){\n      \
    \          min = pathSum;\n                minPath = path;\n            }\n  \
    \      }\n    }\n    return minPath;\n    function dfs(i, j, path, pathSum, visited){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n          \
    \  return;\n        }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n\
    \        visited[i][j] = true;\n        if(path.length === k){\n            return;\n\
    \        }\n        dfs(i + 1, j, path, pathSum, visited);\n        dfs(i - 1,\
    \ j, path, pathSum, visited);\n        dfs(i, j + 1, path, pathSum, visited);\n\
    \        dfs(i, j - 1, path, pathSum, visited);\n        visited[i][j] = false;\n\
    \        path.pop();\n    }\n}\n", "  let n = grid.length;\n  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minSumPath = [];\n  let visited = new Set();\n\
    \  let dfs = function(i, j, path, sum){\n    if(visited.has(i + ',' + j)) return;\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minSumPath = path;\n      }\n      return;\n    }\n    visited.add(i\
    \ + ',' + j);\n    if(i > 0){\n      dfs(i - 1, j, path.concat(grid[i - 1][j]),\
    \ sum + grid[i - 1][j]);\n    }\n    if(i < n - 1){\n      dfs(i + 1, j, path.concat(grid[i\
    \ + 1][j]), sum + grid[i + 1][j]);\n    }\n    if(j > 0){\n      dfs(i, j - 1,\
    \ path.concat(grid[i][j - 1]), sum + grid[i][j - 1]);\n    }\n    if(j < n - 1){\n\
    \      dfs(i, j + 1, path.concat(grid[i][j + 1]), sum + grid[i][j + 1]);\n   \
    \ }\n    visited.delete(i + ',' + j);\n  }\n  for(let i = 0; i < n; i++){\n  \
    \  for(let j = 0; j < n; j++){\n      dfs(i, j, [grid[i][j]], grid[i][j]);\n \
    \   }\n  }\n  return minSumPath;\n}\n", "  // your code here\n}\n", "  // your\
    \ code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n  \
    \  let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let currPath = [];\n            let currSum = 0;\n            dfs(grid,\
    \ i, j, k, visited, currPath, currSum);\n            if(currSum < minSum){\n \
    \               minSum = currSum;\n                minPath = currPath;\n     \
    \       }\n        }\n    }\n    return minPath;\n}\n", "  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPathSumIndex\
    \ = Infinity;\n  let start = [0,0];\n  let end = [grid.length-1, grid[0].length-1];\n\
    \  let visited = {};\n  let queue = [start];\n  let path = [];\n  while(queue.length){\n\
    \    let current = queue.shift();\n    if(current[0] === end[0] && current[1]\
    \ === end[1]){\n      let sum = path.reduce((a,b) => a+b);\n      if(sum < minSum){\n\
    \        minSum = sum;\n        minPath = path;\n      }\n      if(sum < minPathSum){\n\
    \        minPathSum = sum;\n        minPathSumIndex = path.length;\n      }\n\
    \      path.pop();\n      continue;\n    }\n    if(visited[current]) continue;\n\
    \    visited[current] = true;\n    path.push(grid[current[0]][current[1]]);\n\
    \    if(current[0] > 0) queue.push([current[0]-1, current[1]]);\n    if(current[0]\
    \ < grid.length-1) queue.push([current[0]+1, current[1]]);\n    if(current[1]\
    \ > 0) queue.push([current[0], current[1]-1]);\n    if(current[1] < grid[0].length-1)\
    \ queue.push([current[0], current[1]+1]);\n  }\n  return minPath.slice(0, minPathSumIndex);\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathLength\
    \ = Infinity;\n    let minPathGrid = [];\n    let minPathVisited = [];\n    let\
    \ minPathVisitedSum = Infinity;\n    let minPathVisitedLength = Infinity;\n  \
    \  let minPathVisitedGrid = [];\n    let dfs = function(i, j, path, sum, length,\
    \ grid, visited){\n        if(length > k) return;\n        if(length === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n                minPathSum = sum;\n                minPathLength\
    \ = length;\n                minPathGrid = grid;\n            }\n            return;\n\
    \        }\n        if(sum > minSum) return;\n        if(i < 0 || i >= n || j\
    \ < 0 || j >= m || visited[i][j]) return;\n        visited[i][j] = true;\n   \
    \     path.push(grid[i][j]);\n        sum += grid[i][j];\n        length++;\n\
    \        dfs(i - 1, j, path, sum, length, grid, visited);\n        dfs(i + 1,\
    \ j, path, sum, length, grid, visited);\n        dfs(i, j - 1, path, sum, length,\
    \ grid, visited);\n        dfs(i, j + 1, path, sum, length, grid, visited);\n\
    \        path.pop();\n        sum -= grid[i][j];\n        length--;\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dfs(i, j, [], 0, 0, grid, visited);\n        }\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \     ", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(i, j, 0, path, sum);\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, step, path, sum){\n\
    \        if(step === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path.slice();\n            }\n           \
    \ return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, step + 1, path, sum);\n   \
    \     dfs(i - 1, j, step + 1, path, sum);\n        dfs(i, j + 1, step + 1, path,\
    \ sum);\n        dfs(i, j - 1, step + 1, path, sum);\n        path.pop();\n  \
    \      visited[i][j] = false;\n    }\n}\n", "    let n = grid.length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPaths = [];\n    let visited\
    \ = new Set();\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs\
    \ = function(i, j, path, sum){\n        if(sum > minSum){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum < minSum){\n  \
    \              minSum = sum;\n                minPaths = [];\n            }\n\
    \            minPaths.push(path);\n            return;\n        }\n        for(let\
    \ dir of dirs){\n            let x = i + dir[0];\n            let y = j + dir[1];\n\
    \            if(x < 0 || x >= n || y < 0 || y >= n || visited.has(x * n + y)){\n\
    \                continue;\n            }\n            visited.add(x * n + y);\n\
    \            dfs(x, y, path.concat(grid[x][y]), sum + grid[x][y]);\n         \
    \   visited.delete(x * n + y);\n        }\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            visited.add(i * n + j);\n  \
    \          dfs(i, j, [grid[i][j]], grid[i][j]);\n            visited.delete(i\
    \ * n + j);\n        }\n    }\n    minPaths.sort((a, b) => {\n        for(let\
    \ i = 0; i < k; i++){\n            if(a[i] < b[i]){\n                return -1;\n\
    \            }\n            if(a[i] > b[i]){\n                return 1;\n    \
    \        }\n        }\n        return 0;\n    });\n    return minPaths[0];\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            let path = [];\n            let sum = 0;\n\
    \            let visited = new Set();\n            dfs(grid, i, j, k, path, sum,\
    \ visited);\n            if(sum < minSum){\n                minSum = sum;\n  \
    \              minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let path = [];\n    let sum = 0;\n    let pathSum = 0;\n  \
    \  function dfs(i, j){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        pathSum += grid[i][j] * grid[i][j];\n   \
    \     if(path.length === k){\n            if(pathSum < minPathSum){\n        \
    \        minPathSum = pathSum;\n                minPath = [...path];\n       \
    \     }\n            else if(pathSum === minPathSum){\n                if(sum\
    \ < minSum){\n                    minSum = sum;\n                    minPath =\
    \ [...path];\n                }\n            }\n        }\n        else{\n   \
    \         dfs(i + 1, j);\n            dfs(i - 1, j);\n            dfs(i, j + 1);\n\
    \            dfs(i, j - 1);\n        }\n        path.pop();\n        sum -= grid[i][j];\n\
    \        pathSum -= grid[i][j] * grid[i][j];\n        visited[i][j] = false;\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dfs(i, j);\n        }\n    }\n    return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let min_sum\
    \ = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let curr = [];\n            let curr_sum = 0;\n         \
    \   let curr_k = 0;\n            let visited = new Set();\n            let queue\
    \ = [[i, j]];\n            while(queue.length > 0){\n                let [x, y]\
    \ = queue.shift();\n                if(visited.has(x + ',' + y)){\n          \
    \          continue;\n                }\n                visited.add(x + ',' +\
    \ y);\n                curr.push(grid[x][y]);\n                curr_sum += grid[x][y];\n\
    \                curr_k++;\n                if(curr_k === k){\n              \
    \      break;\n                }\n                if(x > 0){\n               \
    \     queue.push([x - 1, y]);\n                }\n                if(x < n - 1){\n\
    \                    queue.push([x + 1, y]);\n                }\n            \
    \    if(y > 0){\n                    queue.push([x, y - 1]);\n               \
    \ }\n                if(y < m - 1){\n                    queue.push([x, y + 1]);\n\
    \                }\n            }\n            if(curr_sum < min_sum){\n     \
    \           min = curr;\n                min_sum = curr_sum;\n            }\n\
    \        }\n    }\n    return min;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let min = Infinity;\n  let minPath = [];\n  let visited = new Set();\n  let\
    \ queue = [];\n  let curr = [0, 0, 0, [grid[0][0]]];\n  queue.push(curr);\n  visited.add(curr[0]\
    \ + ',' + curr[1]);\n  while(queue.length){\n    curr = queue.shift();\n    if(curr[2]\
    \ === k){\n      if(curr[3].length < min){\n        min = curr[3].length;\n  \
    \      minPath = curr[3];\n      }\n      continue;\n    }\n    if(curr[0] + 1\
    \ < n && !visited.has((curr[0] + 1) + ',' + curr[1])){\n      let newPath = curr[3].slice();\n\
    \      newPath.push(grid[curr[0] + 1][curr[1]]);\n      queue.push([curr[0] +\
    \ 1, curr[1], curr[2] + 1, newPath]);\n      visited.add((curr[0] + 1) + ',' +\
    \ curr[1]);\n    }\n    if(curr[0] - 1 >= 0 && !visited.has((curr[0] - 1) + ','\
    \ + curr[1])){\n      let newPath = curr[3].slice();\n      newPath.push(grid[curr[0]\
    \ - 1][curr[1]]);\n      queue.push([curr[0] - 1, curr[1], curr[2] + 1, newPath]);\n\
    \      visited.add((curr[0] - 1) + ',' + curr[1]);\n    }\n    if(curr[1] + 1\
    \ < m && !visited.has(curr[0] + ',' + (curr[1] + 1))){\n      let newPath = curr[3].slice();\n\
    \      newPath.push(grid[curr[0]][curr[1] + 1]);\n      queue.", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i\
    \ < n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath =\
    \ [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n    for(let j\
    \ = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n      dfs(grid,\
    \ i, j, k, path, sum, visited);\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minPath = path;\n      }\n    }\n  }\n  return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let dfs = function(i, j, path, sum){\n        if(i < 0 || i\
    \ >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        if(path.length\
    \ === k){\n            if(sum < minPathSum){\n                minPathSum = sum;\n\
    \                minPath = path.slice();\n            }\n            else if(sum\
    \ === minPathSum){\n                if(path.toString() < minPath.toString()){\n\
    \                    minPath = path.slice();\n                }\n            }\n\
    \            path.pop();\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n\
    \        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return minPath;\n}\n", "  let n = grid.length;\n  let m\
    \ = grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let dfs = function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j]) return;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    if(path.length === k){\n      if(sum < minPathSum){\n        minPathSum =\
    \ sum;\n        minPath = path.slice();\n      }\n      path.pop();\n      return;\n\
    \    }\n    visited[i][j] = true;\n    dfs(i + 1, j, path, sum);\n    dfs(i -\
    \ 1, j, path, sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i, j - 1, path, sum);\n\
    \    visited[i][j] = false;\n    path.pop();\n  }\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return\
    \ minPath;\n}", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let sum = 0;\n    let path =\
    \ [];\n    let dfs = function(i, j, k){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j]){\n            return;\n        }\n        if(k ===\
    \ 0){\n            if(sum < minSum){\n                minSum = sum;\n        \
    \        minPath = path.slice();\n            }\n            return;\n       \
    \ }\n        visited[i][j] = true;\n        sum += grid[i][j];\n        path.push(grid[i][j]);\n\
    \        dfs(i - 1, j, k - 1);\n        dfs(i + 1, j, k - 1);\n        dfs(i,\
    \ j - 1, k - 1);\n        dfs(i, j + 1, k - 1);\n        visited[i][j] = false;\n\
    \        sum -= grid[i][j];\n        path.pop();\n    }\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, k);\n\
    \        }\n    }\n    return minPath;\n}\n", "  let minPath = [];\n  let minPathSum\
    \ = Infinity;\n  let minPathSumIndex = 0;\n  let pathSum = 0;\n  let path = [];\n\
    \  let visited = [];\n  for(let i = 0; i < grid.length; i++){\n    visited.push([]);\n\
    \    for(let j = 0; j < grid[0].length; j++){\n      visited[i].push(false);\n\
    \    }\n  }\n  let dfs = function(i, j, pathSum, path){\n    if(i < 0 || i >=\
    \ grid.length || j < 0 || j >= grid[0].length || visited[i][j]){\n      return;\n\
    \    }\n    pathSum += grid[i][j];\n    path.push(grid[i][j]);\n    visited[i][j]\
    \ = true;\n    if(path.length === k){\n      if(pathSum < minPathSum){\n     \
    \   minPathSum = pathSum;\n        minPathSumIndex = 0;\n        minPath = path.slice();\n\
    \      }else if(pathSum === minPathSum){\n        if(path[minPathSumIndex] > path[0]){\n\
    \          minPathSumIndex = 0;\n          minPath = path.slice();\n        }\n\
    \      }\n    }\n    dfs(i + 1, j, pathSum, path);\n    dfs(i - 1, j, pathSum,\
    \ path);\n    dfs(i, j + 1, pathSum, path);\n    dfs(i, j - 1, pathSum, path);\n\
    \    visited[i][j] = false;\n    path.pop();\n  }\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[0].length; j++){\n      dfs(i, j, pathSum,\
    \ path);\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let\
    \ m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let minSumPath\
    \ = [];\n  let start = [0,0];\n  let end = [n-1,m-1];\n  let visited = new Set();\n\
    \  let queue = [];\n  queue.push([start, [grid[start[0]][start[1]]], 0]);\n  while(queue.length){\n\
    \    let [curr, path, sum] = queue.shift();\n    if(sum > minSum) continue;\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minSumPath = path;\n      }\n      continue;\n    }\n    if(curr[0] -\
    \ 1 >= 0 && !visited.has(`${curr[0]-1},${curr[1]}`)){\n      visited.add(`${curr[0]-1},${curr[1]}`);\n\
    \      queue.push([[curr[0]-1, curr[1]], [...path, grid[curr[0]-1][curr[1]]],\
    \ sum + grid[curr[0]-1][curr[1]]]);\n    }\n    if(curr[0] + 1 < n && !visited.has(`${curr[0]+1},${curr[1]}`)){\n\
    \      visited.add(`${curr[0]+1},${curr[1]}`);\n      queue.push([[curr[0]+1,\
    \ curr[1]], [...path, grid[curr[0]+1][curr[1]]], sum + grid[curr[0]+1][curr[1]]]);\n\
    \    }\n    if(curr[1] - 1 >= 0 && !visited.has(`${curr[0]},${curr[1]-1}`)){\n\
    \      visited.add(`${curr[0]},${curr[1]-1}`);\n      queue.push([[curr[0], curr[1]-1],\
    \ [...path, grid[cur", "  let n = grid.length;\n  let m = grid[0].length;\n  let\
    \ visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n  let min\
    \ = Infinity;\n  let minPath = [];\n  let path = [];\n  function dfs(i, j, k){\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n    if(k\
    \ === 0){\n      if(grid[i][j] < min){\n        min = grid[i][j];\n        minPath\
    \ = path.slice();\n      }\n      return;\n    }\n    visited[i][j] = true;\n\
    \    path.push(grid[i][j]);\n    dfs(i - 1, j, k - 1);\n    dfs(i + 1, j, k -\
    \ 1);\n    dfs(i, j - 1, k - 1);\n    dfs(i, j + 1, k - 1);\n    visited[i][j]\
    \ = false;\n    path.pop();\n  }\n  for(let i = 0; i < n; i++){\n    for(let j\
    \ = 0; j < m; j++){\n      dfs(i, j, k);\n    }\n  }\n  return minPath;\n}", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let min = [];\n    let minSum = Infinity;\n\
    \    let sum = 0;\n    let path = [];\n    function dfs(i, j, k){\n        if(k\
    \ === 0){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            min = path.slice();\n            }\n            return;\n       \
    \ }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      \
    \      return;\n        }\n        visited[i][j] = true;\n        sum += grid[i][j];\n\
    \        path.push(grid[i][j]);\n        dfs(i + 1, j, k - 1);\n        dfs(i\
    \ - 1, j, k - 1);\n        dfs(i, j + 1, k - 1);\n        dfs(i, j - 1, k - 1);\n\
    \        visited[i][j] = false;\n        sum -= grid[i][j];\n        path.pop();\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dfs(i, j, k);\n        }\n    }\n    return min;\n}", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let min = [];\n    let minSum = Infinity;\n\
    \    let dfs = function(i, j, sum, path){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                min = path.slice();\n            }\n            else\
    \ if(sum === minSum){\n                if(path.join('') < min.join('')){\n   \
    \                 min = path.slice();\n                }\n            }\n    \
    \    }\n        else{\n            dfs(i + 1, j, sum, path);\n            dfs(i\
    \ - 1, j, sum, path);\n            dfs(i, j + 1, sum, path);\n            dfs(i,\
    \ j - 1, sum, path);\n        }\n        path.pop();\n        visited[i][j] =\
    \ false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            dfs(i, j, 0, []);\n        }\n    }\n    return min;\n}\n",
  "    let n = grid.length;\n    let visited = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        visited[i] = new Array(n).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n       \
    \ for(let j = 0; j < n; j++){\n            let path = [];\n            let sum\
    \ = 0;\n            dfs(grid, visited, i, j, path, sum, k);\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path;\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let min = Infinity;\n  let path = [];\n  let visited\
    \ = new Set();\n  let dfs = function(i, j, k, sum, path){\n    if(i < 0 || i >=\
    \ n || j < 0 || j >= m || k < 0 || visited.has(i + ',' + j)){\n      return;\n\
    \    }\n    if(k === 0){\n      if(sum < min){\n        min = sum;\n        path.push(grid[i][j]);\n\
    \        console.log(path);\n        return;\n      }\n    }\n    visited.add(i\
    \ + ',' + j);\n    path.push(grid[i][j]);\n    dfs(i + 1, j, k - 1, sum + grid[i][j],\
    \ path);\n    dfs(i - 1, j, k - 1, sum + grid[i][j], path);\n    dfs(i, j + 1,\
    \ k - 1, sum + grid[i][j], path);\n    dfs(i, j - 1, k - 1, sum + grid[i][j],\
    \ path);\n    path.pop();\n    visited.delete(i + ',' + j);\n  }\n  for(let i\
    \ = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, k, 0, []);\n\
    \    }\n  }\n  return path;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n \
    \ let min = [];\n  let minSum = Infinity;\n  let minPath = [];\n  let sum = 0;\n\
    \  let path = [];\n  function dfs(i, j, k){\n    if(k === 0){\n      if(sum <\
    \ minSum){\n        minSum = sum;\n        minPath = path.slice();\n      }\n\
    \      return;\n    }\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j])\
    \ return;\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    dfs(i - 1, j, k - 1);\n    dfs(i + 1, j, k - 1);\n    dfs(i, j - 1, k - 1);\n\
    \    dfs(i, j + 1, k - 1);\n    visited[i][j] = false;\n    path.pop();\n    sum\
    \ -= grid[i][j];\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      dfs(i, j, k);\n    }\n  }\n  return minPath;\n}", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i\
    \ < n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath =\
    \ [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n    for(let j\
    \ = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n      dfs(grid,\
    \ i, j, k, path, sum, visited);\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minPath = path;\n      }\n    }\n  }\n  return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(grid, i, j, k, visited, path, sum);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j]){\n            return;\n        }\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }\n            return;\n   \
    \     }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n     \
    \   sum += grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i - 1,\
    \ j, path, sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path,\
    \ sum);\n        path.pop();\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            dfs(i, j, k, path, sum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n    function dfs(i, j, k, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n  \
    \          return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        visited[i][j] = true;\n        if(path.length === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path.slice();\n            }\n            return;\n        }\n  \
    \      dfs(i, j + 1, k, path, sum);\n        dfs(i, j - 1, k, path, sum);\n  \
    \      dfs(i + 1, j, k, path, sum);\n        dfs(i - 1, j, k, path, sum);\n  \
    \      visited[i][j] = false;\n        path.pop();\n    }\n}\n", "  var n = grid.length;\n\
    \  var m = grid[0].length;\n  var minPath = [];\n  var minSum = Infinity;\n  var\
    \ visited = [];\n  for(var i = 0; i < n; i++){\n    visited.push([]);\n    for(var\
    \ j = 0; j < m; j++){\n      visited[i].push(false);\n    }\n  }\n  var dfs =\
    \ function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \      return;\n    }\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n  \
    \  if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n  \
    \      minPath = path.slice();\n      }\n      path.pop();\n      return;\n  \
    \  }\n    visited[i][j] = true;\n    dfs(i - 1, j, path, sum);\n    dfs(i + 1,\
    \ j, path, sum);\n    dfs(i, j - 1, path, sum);\n    dfs(i, j + 1, path, sum);\n\
    \    visited[i][j] = false;\n    path.pop();\n  }\n  for(var i = 0; i < n; i++){\n\
    \    for(var j = 0; j < m; j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return\
    \ minPath;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(false));\n  let minPath =\
    \ [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let dfs = function(grid,\
    \ i, j, visited, path, sum, pathSum){\n    if(i < 0 || i >= n || j < 0 || j >=\
    \ m || visited[i][j]){\n      return;\n    }\n    path.push(grid[i][j]);\n   \
    \ sum += grid[i][j];\n    pathSum += grid[i][j] * grid[i][j];\n    visited[i][j]\
    \ = true;\n    if(path.length === k){\n      if(sum < minSum || (sum === minSum\
    \ && pathSum < minPathSum)){\n        minSum = sum;\n        minPathSum = pathSum;\n\
    \        minPath = path.slice();\n      }\n    }else{\n      dfs(grid, i + 1,\
    \ j, visited, path, sum, pathSum);\n      dfs(grid, i - 1, j, visited, path, sum,\
    \ pathSum);\n      dfs(grid, i, j + 1, visited, path, sum, pathSum);\n      dfs(grid,\
    \ i, j - 1, visited, path, sum, pathSum);\n    }\n    path.pop();\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(grid, i, j, visited, [], 0, 0);\n    }\n  }\n  return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(i, j, k, path, sum);\n\
    \            visited[i][j] = false;\n        }\n    }\n    return minPath;\n \
    \   function dfs(i, j, k, path, sum){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j]){\n            return;\n        }\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }\n            return;\n   \
    \     }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n     \
    \   sum += grid[i][j];\n        dfs(i + 1, j, k, path, sum);\n        dfs(i -\
    \ 1, j, k, path, sum);\n        dfs(i, j + 1, k, path, sum);\n        dfs(i, j\
    \ - 1, k, path, sum);\n        path.pop();\n        sum -= grid[i][j];\n     \
    \   visited[i][j] = false;\n    }\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let visited = [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n \
    \   for(let j = 0; j < m; j++){\n      visited[i].push(false);\n    }\n  }\n \
    \ function dfs(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= m ||\
    \ visited[i][j]){\n      return;\n    }\n    if(path.length === k){\n      if(sum\
    \ < minPathSum){\n        minPathSum = sum;\n        minPath = path;\n      }\
    \ else if(sum === minPathSum){\n        if(path < minPath){\n          minPath\
    \ = path;\n        }\n      }\n      return;\n    }\n    visited[i][j] = true;\n\
    \    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i + 1, j, path, sum);\n\
    \    dfs(i - 1, j, path, sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i, j -\
    \ 1, path, sum);\n    path.pop();\n    sum -= grid[i][j];\n    visited[i][j] =\
    \ false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let dfs = function(i, j, path, pathSum){\n        if(path.length > k){\n\
    \            return;\n        }\n        if(path.length === k){\n            if(pathSum\
    \ < minPathSum){\n                minPathSum = pathSum;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n   \
    \     pathSum += grid[i][j];\n        dfs(i + 1, j, path, pathSum);\n        dfs(i\
    \ - 1, j, path, pathSum);\n        dfs(i, j + 1, path, pathSum);\n        dfs(i,\
    \ j - 1, path, pathSum);\n        path.pop();\n        pathSum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n \
    \   }\n    return minPath;\n}", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n \
    \ let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsSumMap = {};\n \
    \ let minPathsMap = {};\n  let path = [];\n  let sum = 0;\n  let paths = [];\n\
    \  let pathsSum = [];\n  let pathsSumMap = {};\n  let pathsMap = {};\n  let pathSum\
    \ = 0;\n  let pathSumMap = {};\n  let pathMap = {};\n  let minPathSumMap = {};\n\
    \  let minPathMap = {};\n  let minPathsSumMap = {};\n  let minPathsMap = {};\n\
    \  let minPathSumMap = {};\n  let minPathMap = {};\n  let minPathsSumMap = {};\n\
    \  let minPathsMap = {};\n  let minPathSumMap = {};\n  let minPathMap = {};\n\
    \  let minPathsSumMap = {};\n  let minPathsMap = {};\n  let minPathSumMap = {};\n\
    \  let minPathMap = {};\n  let minPathsSumMap = {};\n  let minPathsMap = {};\n\
    \  let minPathSumMap = {};\n  let minPathMap = {};\n  let minPathsSumMap = {};\n\
    \  let minPathsMap = {};\n  let minPathSumMap = {};\n  let minPathMap = {};\n\
    \  let minPathsSumMap = {};\n  let minPathsMap = {};\n  let minPathSumMap = {};\n\
    \  let minPathMap = {};\n  let minPathsSumMap = {};\n  let minPathsMap = {};\n\
    \  let minPathSumMap = {};\n  let minPathMap = {};\n  let minPathsSumMap = {};\n\
    \  let minPathsMap = {};\n  let minPathSumMap = {};\n  let minPath", "  let n\
    \ = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n);\n \
    \ for(let i = 0; i < n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n\
    \  let min = Infinity;\n  let minPath = [];\n  let dfs = function(i, j, path,\
    \ sum){\n    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n\
    \    }\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n    if(path.length\
    \ === k){\n      if(sum < min){\n        min = sum;\n        minPath = path.slice();\n\
    \      }\n      path.pop();\n      return;\n    }\n    visited[i][j] = true;\n\
    \    dfs(i + 1, j, path, sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i, j +\
    \ 1, path, sum);\n    dfs(i, j - 1, path, sum);\n    visited[i][j] = false;\n\
    \    path.pop();\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m;\
    \ j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n    let\
    \ visited = new Set();\n    let dfs = function(i, j, path, sum){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= n || visited.has(i + ',' + j)){\n           \
    \ return;\n        }\n        if(path.length === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path;\n            }\n\
    \            return;\n        }\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i\
    \ - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1,\
    \ path, sum);\n        path.pop();\n        visited.delete(i + ',' + j);\n   \
    \ }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n  \
    \          dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n\ngrid\
    \ = [ [1,2,3], [4,5,6], [7,8,9]];\nk = 3;", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n   \
    \ let visited = new Set();\n    let dfs = function(i, j, path, sum){\n       \
    \ if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i + ',' + j)){\n      \
    \      return;\n        }\n        if(path.length === k){\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        visited.add(i + ',' +\
    \ j);\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i\
    \ + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1,\
    \ path, sum);\n        dfs(i, j - 1, path, sum);\n        path.pop();\n      \
    \  visited.delete(i + ',' + j);\n    }\n    for(let i = 0; i < n; i++){\n    \
    \    for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n \
    \   }\n    return minPath;\n}\n", "  let minPath = [];\n  let minPathSum = Infinity;\n\
    \  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minPathSum4 = Infinity;\n  let minPath4 = [];\n \
    \ let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minPathSum7 = Infinity;\n  let minPath7 = [];\n \
    \ let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minPathSum10 = Infinity;\n  let minPath10 = [];\n\
    \  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minPathSum13 = Infinity;\n  let minPath13 = [];\n\
    \  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minPathSum16 = Infinity;\n  let minPath16 = [];\n\
    \  let minPathSum17 = Infinity;\n  let minPath17 = [];\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minPathSum19 = Infinity;\n  let minPath19 = [];\n\
    \  let minPathSum20 = Infinity;\n  let minPath20 = [];\n  let minPathSum21 = Infinity;\n\
    \  let minPath21 = [];\n  let minPathSum22 = Infinity;\n  let minPath22 = [];\n\
    \  let minPathSum23 = Infinity;\n  let minPath23 = [];\n  let minPathSum24 = Infinity;\n\
    \  let minPath24 = [];\n  let minPathSum25 = Infinity;\n  let minPath25 = [];\n\
    \  let minPathSum26 = Infinity;\n  let minPath26 = [];\n  let minPathSum27 = Infinity;\n\
    \  let minPath27 = [];\n  let minPathSum28 = Infinity;\n  let minPath28 = [];\n\
    \  let minPathSum29 = Infinity;", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let min = [];\n    let minSum = Infinity;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      let curr = [];\n            let currSum = 0;\n            dfs(i, j, 0,\
    \ k, curr, currSum);\n            if(currSum < minSum){\n                minSum\
    \ = currSum;\n                min = curr;\n            }\n        }\n    }\n \
    \   return min;\n    function dfs(i, j, currK, k, curr, currSum){\n        if(currK\
    \ === k){\n            return;\n        }\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j]){\n            return;\n        }\n        curr.push(grid[i][j]);\n\
    \        currSum += grid[i][j];\n        visited[i][j] = true;\n        dfs(i\
    \ + 1, j, currK + 1, k, curr, currSum);\n        dfs(i - 1, j, currK + 1, k, curr,\
    \ currSum);\n        dfs(i, j + 1, currK + 1, k, curr, currSum);\n        dfs(i,\
    \ j - 1, currK + 1, k, curr, currSum);\n        visited[i][j] = false;\n     \
    \   curr.pop();\n    }\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n \
    \ let min = [];\n  let minSum = Infinity;\n  let dfs = function(i, j, sum, path){\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n    if(path.length\
    \ === k){\n      if(sum < minSum){\n        minSum = sum;\n        min = path;\n\
    \      }\n      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    dfs(i + 1, j, sum + grid[i][j], path);\n    dfs(i - 1, j, sum + grid[i][j],\
    \ path);\n    dfs(i, j + 1, sum + grid[i][j], path);\n    dfs(i, j - 1, sum +\
    \ grid[i][j], path);\n    visited[i][j] = false;\n    path.pop();\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, 0, []);\n\
    \    }\n  }\n  return min;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Number.MAX_SAFE_INTEGER;\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n  \
    \  let minPathSumHelper = function(grid, i, j, k, path, sum, pathSum){\n     \
    \   if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length > k){\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        pathSum += path.length * grid[i][j];\n        visited[i][j]\
    \ = true;\n        if(path.length === k){\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            else if(pathSum === minPathSum){\n               \
    \ if(sum < minSum){\n                    minSum = sum;\n                    minPath\
    \ = path.slice();\n                }\n                else if(sum === minSum){\n\
    \                    if(path.join(\"\") < minPath.join(\"\")){\n             \
    \           minPath = path.slice();\n                    }\n                }\n\
    \            }\n        }\n        else{\n            minPathSumHelper(grid, i\
    \ + 1, j, k, path, sum, pathSum);\n            minPathSumHelper(grid, i - 1, j,\
    \ k, path, sum, pathSum);\n            minPathSumHelper(grid, i, j + 1, k, path,\
    \ sum, pathSum);\n            minPathSumHelper(grid, i, j - 1, k, path, sum, pathSum);\n\
    \        }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            minPathSumHelper(",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let min = [];\n    let curr = [];\n    let minSum = Infinity;\n  \
    \  let currSum = 0;\n    let dfs = function(i, j, k){\n        if(k === 0){\n\
    \            if(currSum < minSum){\n                minSum = currSum;\n      \
    \          min = curr.slice();\n            }\n            return;\n        }\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n          \
    \  return;\n        }\n        visited[i][j] = true;\n        curr.push(grid[i][j]);\n\
    \        currSum += grid[i][j];\n        dfs(i + 1, j, k - 1);\n        dfs(i\
    \ - 1, j, k - 1);\n        dfs(i, j + 1, k - 1);\n        dfs(i, j - 1, k - 1);\n\
    \        visited[i][j] = false;\n        curr.pop();\n        currSum -= grid[i][j];\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dfs(i, j, k);\n        }\n    }\n    return min;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
