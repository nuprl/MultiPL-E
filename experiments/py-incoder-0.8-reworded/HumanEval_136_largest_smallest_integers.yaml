name: HumanEval_136_largest_smallest_integers
language: py
prompt: "from typing import List, Tuple, Optional\n\ndef largest_smallest_integers(lst:\
  \ List[int]) -> Tuple[Optional[int], Optional[int]]:\n    \"\"\"\n    Create a function\
  \ that returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
  \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
  \ no negative or positive integers, return them as None.\n\n    Examples:\n    >>>\
  \ largest_smallest_integers([2, 4, 1, 3, 5, 7])\n    (None, 1)\n    >>> largest_smallest_integers([])\n\
  \    (None, None)\n    >>> largest_smallest_integers([0])\n    (None, None)\n  \
  \  \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None,\
  \ 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1,\
  \ 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) ==\
  \ (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert\
  \ candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n   \
  \ assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3,\
  \ -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n\
  \    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\ndef test_check():\n\
  \    check(largest_smallest_integers)\n\ntest_check()\n"
completions: ["    # Find the smallest negative number and largest positive number.\n\
    \    smallest_negative = min([x for x in lst if x < 0])\n    largest_positive\
    \ = max([x for x in lst if x > 0])\n\n    # Return the smallest negative number\
    \ as the largest positive number.\n    if smallest_negative is None or largest_positive\
    \ is None:\n        return (None, None)\n    else:\n        return (smallest_negative,\
    \ largest_positive)\n\n", "    return max(-x for x in lst), min(x  for x in lst)\n",
  "    smallest = None\n    largest = None\n    for i in lst:\n        if i < 0:\n\
    \            if smallest is None or i > smallest:\n                smallest =\
    \ i\n        else:\n            if largest is None or i < largest:\n         \
    \       largest = i\n    return largest, smallest\n", "    if lst:\n        return\
    \ largest_smallest_integers(lst[1:]) or largest_smallest_integers(lst[:-1])\n\
    \    else:\n        return None, None\n", "    max_integer, min_integer = -max(lst),\
    \ min(lst)\n    if max_integer == min_integer:\n        return (None, None)\n\n\
    \    return (max_integer, min_integer)\n</cell>\n<cell>", "    max_positive =\
    \ None\n    min_negative = None\n    for x in lst:\n        if x < 0 and max_positive\
    \ is None:\n            max_positive = x\n        elif x > 0 and min_negative\
    \ is None:\n            min_negative = x\n        elif max_positive < x:\n   \
    \         max_positive = x\n        elif min_negative > x:\n            min_negative\
    \ = x\n    return (max_positive, min_negative)\n", "    small_to_large = collections.defaultdict(list)\n\
    \    large_to_small = collections.defaultdict(list)\n\n    for n in lst:\n   \
    \     if n >= 0:\n            large_to_small[n].append(n)\n        else:\n   \
    \         small_to_large[n].append(n)\n    \n    def largest_smallest(n: int)\
    \ -> Optional[int]:\n        if n in small_to_large:\n            lst = small_to_large[n]\n\
    \            if len(lst) > 1:\n                return min(lst), max(lst)\n   \
    \         else:\n                return None\n        elif n in large_to_small:\n\
    \            lst = large_to_small[n]\n            if len(lst) > 1:\n         \
    \       return max(lst), min(lst)\n            else:\n                return None\n\
    \        else:\n            return None\n\n    return largest_smallest\n\n", " \
    \   # Write your code here\n\n    return largest_smallest_integers_helper(lst)\n\
    \n", "    if not lst:\n        return None, None\n    lst.sort()\n    if any(lst[i]\
    \ < 0 for i in range(len(lst))):\n        return largest_smallest_integers(lst[i:])\n\
    \    elif any(lst[i] > 0 for i in range(len(lst))):\n        return largest_smallest_integers(lst[:i])\n\
    \    else:\n        return lst[0], lst[-1]\n", "    if len(lst) == 0:\n      \
    \  return (None, None)\n\n    if lst[0] < 0:\n        return (None, lst[0])\n\n\
    \    if lst[-1] > 0:\n        return (lst[-1], None)\n\n    return largest_smallest_integers(lst[1:-1])\n\
    \n", "    lst = list(lst)\n    if len(lst) == 0:\n        return (None, None)\n\
    \    if len(lst) == 1:\n        return (0, lst[0])\n    if all(x >= 0 for x in\
    \ lst):\n        return (max(lst), min(lst))\n    else:\n        return largest_smallest_integers(lst[1:])\n",
  "    if len(lst) < 1:\n        return (None, None)\n    \n    def largest_and_smallest(lst:\
    \ List[int]) -> Tuple[Optional[int], Optional[int]]:\n        if 0 in lst:\n \
    \           return (None, None)\n        \n        largest = None\n        smallest\
    \ = None\n        \n        lst2 = list(filter(lambda x: x > 0, lst))\n      \
    \  if lst2:\n            largest = max(lst2)\n            smallest = min(lst2)\n\
    \            \n        return (largest, smallest)\n    \n    return largest_and_smallest(lst)\n\
    \    ", "    smallest = min([x for x in lst if x < 0])\n    largest = max([x for\
    \ x in lst if x > 0])\n    if smallest == largest == None:\n        return None,\
    \ None\n    else:\n        return smallest, largest\n", "    if not lst:\n   \
    \     return (None, None)\n    negative, positive = 0, 0\n    for x in lst:\n\
    \        if x < 0:\n            negative += 1\n        elif x > 0:\n         \
    \   positive += 1\n        else:\n            pass\n    if negative < positive:\n\
    \        return (None, None)\n    else:\n        return (negative, positive)\n",
  "    if all(x <= 0 for x in lst):\n        return None, None\n\n    negative = [x\
    \ for x in lst if x < 0]\n    positive = [x for x in lst if x > 0]\n    if negative:\n\
    \        a = max(negative)\n    else:\n        a = None\n    if positive:\n  \
    \      b = min(positive)\n    else:\n        b = None\n    return a, b\n", " \
    \   # TODO your answer here\n    pass\n", "    largest_negative = None\n    largest_positive\
    \ = None\n    smallest_negative = None\n    smallest_positive = None\n\n    for\
    \ number in lst:\n        if number < 0:\n            if largest_negative is None\
    \ or number > largest_negative:\n                largest_negative = number\n \
    \       else:\n            if largest_positive is None or number < largest_positive:\n\
    \                largest_positive = number\n        if number < 0:\n         \
    \   if smallest_negative is None or number < smallest_negative:\n            \
    \    smallest_negative = number\n        else:\n            if smallest_positive\
    \ is None or number > smallest_positive:\n                smallest_positive =\
    \ number\n\n    return largest_negative, smallest_positive\n", "    if len(lst)\
    \ == 0:\n        return (None, None)\n    largest_negative = sorted(lst, reverse=True,\
    \ key=abs)[0]\n    smallest_positive = sorted(lst, key=abs)[0]\n    return (largest_negative,\
    \ smallest_positive)\n", "    lst = list(lst)\n    lst.sort()\n    if lst:\n \
    \       a = max(x for x in lst if x < 0)\n        b = min(x for x in lst if x\
    \ > 0)\n    else:\n        a = b = -1\n    return a, b\n\n", "    if lst == []:\n\
    \        return (None, None)\n    min_val = max(i for i in lst if i < 0)\n   \
    \ max_val = min(i for i in lst if i >= 0)\n    return (max_val, min_val)\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
