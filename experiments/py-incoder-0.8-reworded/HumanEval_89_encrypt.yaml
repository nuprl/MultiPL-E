name: HumanEval_89_encrypt
language: py
prompt: "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes\
  \ a string as an argument and\n    returns a string encrypted with the alphabet\
  \ being rotated. \n    The alphabet should be rotated in a manner such that the\
  \ letters \n    shift down by two multiplied to two places.\n    For example:\n\
  \    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n\
  \    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('hi') == 'lm'\n    assert candidate('asdfghjkl')\
  \ == 'ewhjklnop'\n    assert candidate('gf') == 'kj'\n    assert candidate('et')\
  \ == 'ix'\n    assert candidate('faewfawefaewg') == 'jeiajeaijeiak'\n    assert\
  \ candidate('hellomyfriend') == 'lippsqcjvmirh'\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')\
  \ == 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n    assert candidate('a')\
  \ == 'e'\n\ndef test_check():\n    check(encrypt)\n\ntest_check()\n"
completions: ["    letters = rotation(s)\n    return ''.join(letters)\n", "    alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[alphabet.index(alphabet)-2:]+alphabet[:alphabet.index(alphabet)-2]\n\
    \    rotated_s = \"\"\n    for c in s:\n        if c in alphabet:\n          \
    \  rotated_s += rotated_alphabet[alphabet.index(c)+2:] + rotated_alphabet[:alphabet.index(c)+2]\n\
    \        else:\n            rotated_s += c\n    return rotated_s\n    ", "   \
    \ # implement your solution here\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    rotated_letters = letters[:]\n    for i in range(len(letters)):\n       \
    \ rotated_letters[i] =rotated_letters[i+1]\n    rotated_letters[i] = letters[0]\n\
    \    return ''.join(rotated_letters)\n", "    return ''.join(chr(ord(c) + 2) if\
    \ c not in string.ascii_lowercase else c\n                   for c in s)\n</code>\n\
    <|/ a dscore=0 tags=python,string,list |>\n<| a tags=python,string,list |>\nIt\
    \ is not possible in one line of code, but you can make use of lambda function\
    \ with map:\n<code>\n>>> alphabet = 'abcdefghijklmnopqrstuvwxyz'\n>>> list(map(lambda\
    \ x: alphabet.index(x.lower()) + 2, alphabet))\n['l', 'm', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    This should work without importing any modules:\n<code>", "    if len(s) == 0:\
    \ return s\n    return ''.join(rotate(s, c) for c in alphabet)\n", "    return\
    \ \"\".join(map(lambda c: chr(ord(c) + 1), s))\n</cell>\n<cell>\nassert encrypt('hi')\
    \ == 'lm'\nassert encrypt('asdfghjkl') == 'ewhjklnop'\nassert encrypt('gf') ==\
    \ 'kj'\nassert encrypt('et') == 'ix'\n</cell>\n<text>\nImplement a rotate function\
    \ in the cell below.\n\n\n</text>\n<cell>", "    return \"\".join(sorted(list(s),\
    \ key=lambda c: ord(c)//2 + 2))\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    s = list(s)\n    rotated_alphabet = alphabet[(alphabet.index(alphabet[1])\
    \ + 2) % len(alphabet)]\n    \n    new_alphabet = alphabet[(alphabet.index(alphabet[0])\
    \ + 2) % len(alphabet)]\n    \n    for i in range(len(s)):\n        if s[i] !=\
    \ new_alphabet:\n            s[i], new_alphabet = s[i], [rotated_alphabet]\n \
    \   \n    return \"\".join(s)\n", "    \n    # Your code here\n    alphabet =\
    \ ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    ciphertext = []\n    for char in s:\n        if char in alphabet:\n     \
    \       ciphertext.append(alphabet[(alphabet.index(char)+2)%len(alphabet)])\n\
    \        else:\n            ciphertext.append(char)\n    return ''.join(ciphertext)\n\
    </cell>\n<text>\nPart 2 Create a reverse function\nCreate a function reverse that\
    \ takes a string as an argument and returns a string that contains the letters\
    \ in reverse order.\nFor example:\n>>> reverse('hello')\n'olleh'\n>>> reverse('gf')\n\
    'gfedc'\n>>> reverse('asdfghjkl')\n'dlkjhgfesa'\n>>> reverse('qwertyuiop')\n'ytuiopqwerf'\n\
    >>> reverse('asdfghjkl')\n'kjhgfeasd'\n>>> reverse('gf')\n'gfedc'\n>>> reverse('et')\n\
    'ixgfeet'\n>>> reverse('z')\n'z'\n>>> reverse('')\n''\n>>> reverse('hi')\n'lm'\n\
    >>> reverse('asdfghjkl')\n'ewhjklnop'\n>>> reverse('gf')\n'kj'\n>>> reverse('et')\n\
    'ix'\n>>> reverse('hello')\n'olleh'\n>>> reverse('gf')\n'gfedc'\n>>> reverse('asdfghjkl')\n\
    'dlkjhgfesa'\n>>> reverse('qwertyuiop')\n'ytuiopqwerf'\n>>> reverse('asdfghjkl')\n\
    'kjhgfeasd'\n>>> reverse('gf')\n'gfedc'\n>>> reverse('et')\n'ixgfeet'\n>>> reverse('z')\n\
    'z'\n>>> reverse('')\n''\n>>> reverse('hi')\n'lm'\n>>> reverse('asdfghjkl')\n\
    'ewhjklnop'\n>>> reverse('gf')\n'kj'\n>>> reverse('et')\n'ix'\n>>> reverse('hello')\n\
    'olleh'\n>>> reverse('gf')\n'gfedc'\n>>> reverse('asdfghjkl')\n'dlkjhgfesa'\n\
    >>> reverse('qwertyuiop')\n", "    # code here\n    pass\n\n", "    alphabet =\
    \ 'abcdefghijklmnopqrstuvwxyz'\n    letters = list(alphabet)\n    new_letters\
    \ = []\n    shifted_letters = []\n    for letter in s:\n        if letter == 'z':\n\
    \            new_letters.append(letter)\n        else:\n            for new_letter\
    \ in letters:\n                shift_letter = new_letter - letter\n          \
    \      if shift_letter >= 0 and shift_letter <= 1:\n                    new_letters.append(shift_letter\
    \ * 2)\n                    break\n                else:\n                   \
    \ new_letters.append(new_letter)\n    for letter in s:\n        letter_idx = letters.index(letter)\n\
    \        shifted_letters.append(letters[letter_idx + 1])\n    return ''.join(new_letters)\
    \ + ''.join(shifted_letters)\n", "    return ''.join(chr(ord(c) + 2)\n       \
    \            for c in s[::2])\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    rot_alphabet = alphabet[:len(alphabet) // 2] + alphabet[len(alphabet) //\
    \ 2:]\n    return rot_alphabet[alphabet.index(s)] + rot_alphabet[(alphabet.index(s)+1)\
    \ % len(alphabet)]\n\n", "    # Write your code here\n    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    alphabetReverse = []\n    for letter in alphabet:\n        alphabetReverse.append(letter)\n\
    \    alphabetReverse.sort()\n    alphabetReverse.reverse()\n    alphabetReverse\
    \ = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    alphabetReverse.sort()\n    alphabetReverse.reverse()\n    alphabetReverse\
    \ = alphabetReverse[2:] + alphabetReverse[:2]\n    return alphabetReverse[alphabet.index(s)]\n\
    \    ", "    alphabet = string.ascii_lowercase + string.ascii_uppercase\n    letters\
    \ = list(s)\n    letters = [alphabet[(alphabet.index(letter) + 2) % len(alphabet)]\
    \ for letter in letters]\n    return \"\".join(letters)\n\n", "    return ''.join([chr((ord(c)\
    \ - 65 + i) % 26 + 65) for i in range(26)])\n", "    def encr(string):\n     \
    \   alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        for i, char in enumerate(string):\n\
    \            n = alphabet[i]\n            alphabet[i] = alphabet[(n + 2)%26]\n\
    \            alphabet[(n + 2)%26] = n\n        return alphabet\n    return encr(s)\n",
  "    return ''.join(rotate_string(s))\n</cell>\n<text>\nExercise 5: Create a function\
    \ named decrypt that takes a string as an argument and returns a string decrypted\
    \ with the alphabet being rotated. \nThe alphabet should be rotated in a manner\
    \ such that the letters shift down by two multiplied to two places.\nFor example:\n\
    >>> decrypt('lm')\n'hi'\n>>> decrypt('ewhjklnop')\n'asdfghjkl'\n>>> decrypt('kj')\n\
    'gf'\n>>> decrypt('ix')\n'et'\n\n</text>\n<cell>", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alphabet = alphabet[:len(alphabet) // 2]\n    alphabet += alphabet\n    alphabet\
    \ += alphabet\n    \n    def rotate(s):\n        rotated_list = []\n        for\
    \ letter in s:\n            index = alphabet.index(letter)\n            rotated_list.append(alphabet[(index\
    \ + 1) % len(alphabet)])\n        return ''.join(rotated_list)\n\n    return rotate(s)\n\
    \n", "    return \"\".join( \n        rotate_char( \n            ord(char), \n\
    \            2*(i // len(s)) // len(s)\n        ) for i,char in enumerate(s) \n\
    \    )\n</cell>\n<cell>", "    \n    encrypt_chars = []\n    for letter in s:\n\
    \        # convert letter into int so we can multiply by two to shift it\n   \
    \     letter_num = int(letter)\n        letter_num *= 2\n        letter_num +=\
    \ letter_num\n        encrypt_chars.append(chr(letter_num))\n        \n    # join\
    \ all the encrypted letters together and return the string\n    return ''.join(encrypt_chars)\n\
    \n", "    alph=list(s)\n    alph.rotate(2)\n    return \"\".join(alph)\n", " \
    \   return rotate(rotate(s, len(s)//2), len(s)//2)\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    shifts = { alphabet[0]: 2, alphabet[1]: 2, alphabet[2]: 2, alphabet[3]: 2,\
    \ alphabet[4]: 2, \n                alphabet[5]: 2, alphabet[6]: 2, alphabet[7]:\
    \ 2, alphabet[8]: 2, alphabet[9]: 2, \n                alphabet[10]: 2, alphabet[11]:\
    \ 2, alphabet[12]: 2, alphabet[13]: 2, alphabet[14]: 2, \n                alphabet[15]:\
    \ 2 }\n    encrypt = ''\n    for x in s:\n        encrypt += alphabet[(alphabet.index(x)\
    \ + shifts[alphabet[x]]) % 26]\n    return encrypt\n</cell>\n<cell>", "    return\
    \ ''.join(rotate_letter_left(ord(x), 2) for x in s)\n", "    pass\n", "    # Rotate\
    \ first two characters in string and apply modulo 26\n    return encryptAlphabets[ord(s)]\
    \ % (2**26)\n\n", "    def encryptChar(c):\n        if ord(c) >= 97 and ord(c)\
    \ <= 122:\n            return chr(((ord(c)-97) + 2) * ((ord(c)-97)%26 + 97))\n\
    \        return chr(c)\n    return ''.join(encryptChar(c) for c in s)\n\n", " \
    \   # TODO\n    return ''\n", "    def rotateLetters(letters: str) -> str:\n \
    \       n = len(letters)\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  \
    \      \n        result = letters.lower()\n        \n        for i in range(n):\n\
    \            first = alphabet[0:len(alphabet)-(i+1)]\n            second = alphabet[i+2:len(alphabet)]\n\
    \            result += alphabet[int(first) + int(second)]\n        return result\n\
    \    \n    return rotateLetters(s)\n</cell>\n<cell>\nassert encrypt('hi') == 'lm'\n\
    assert encrypt('asdfghjkl') == 'ewhjklnop'\nassert encrypt('gf') == 'kj'\nassert\
    \ encrypt('et') == 'ix'\n</cell>\n<text>\nProblem 9\nFor extra credit, see if\
    \ you can create a new function\n\nencrypt(s)\nthat returns the same result as\
    \ rotate(s), but rotates the alphabet\nby 90 degrees once. In other words, go\
    \ from letter 'z' to 'a'\n(which is 90\xB0 rotated down from 'z') before returning\
    \ the original\nletter.\nFor example:\n>>> encrypt('hi')\n'lm'\n>>> encrypt('asdfghjkl')\n\
    'ewhjklnop'\n>>> encrypt('gf')\n'kj'\n>>> encrypt('et')\n'ix'\n>>> encrypt('z')\n\
    'a'\nThe string will be in lowercase.\n\"\"\"\n", "    return alphabets[rotate(alphabet.index(s),\
    \ 2)]\n\n", "    alphabet_len = len(ALPHABET)\n    return ''.join([ALPHABET[(ALPHABET.index(s)+ALPHABET.index(s)+alphabet_len)\
    \ % alphabet_len] for s in s])\n", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    alphabet = alphabet[0:len(alphabet)//2]\n    alphabet = alphabet + alphabet[:len(alphabet)//2]\n\
    \    alphabet = alphabet[::-1]\n    return alphabet[alphabet.index(s)+2]\n", " \
    \   return \"\".join(map(lambda char: rotate(char), s))\n", "    alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    \n    # first we find the length of each string\n\
    \    lens = [len(s) for s in s]\n    \n    # find the maximum length\n    max_len\
    \ = max(lens)\n    \n    # loop through the strings and add spaces to make the\n\
    \    # longest string\n    encrypted = ''\n    for s in s:\n        # add spaces\
    \ to make the string as long as the maximum length\n        encrypted += s.rjust(max_len)\n\
    \        \n    # now we loop through each letter in the alphabet and \n    # find\
    \ which letter in the encrypted string it maps to and\n    # replace it with its\
    \ corresponding letter in the alphabet\n    for i in range(0, max_len):\n    \
    \    letter = alphabet.find(encrypted[i])\n        if letter == -1:\n        \
    \    letter = alphabet.find(encrypted[i + 1])\n        encrypted += alphabet[letter]\n\
    \    \n    # return the encrypted string\n    return encrypted\n</cell>\n<text>\n\
    Now that we have our encrypt, we can compare it to our original decrypt. Because\
    \ of our shifting of the alphabet we have two more letters that we must account\
    \ for - shift down and shift up. In the case where the first letter is not a shift\
    \ down we must add one to the index because it is now at the end. Likewise for\
    \ the shift up case. We also have to account for the case where the string is\
    \ all spaces, we must not add anything to that string.\n\n\n</text>\n<cell>",
  "    # To encrypt a string, shift the alphabet down by two and multiply \n    #\
    \ the letters by two. For example, if the alphabet is 'abc' then\n    # the encrypted\
    \ alphabet is 'bac'. \n    enc_alphabet = ''.join([ alphabet[i:] + alphabet[:i]\
    \ \n                             for i in range(len(alphabet) - 1, -1, -1) ])\n\
    \    def encrypt(string) -> str:\n        \"\"\"Rotates the string by two and\
    \ multiplies letters by two.\"\"\"\n        return ''.join([enc_alphabet[(alphabet.index(i)\
    \ + 2) % len(alphabet)]\n                        for i in string])\n    return\
    \ encrypt\n", "    s = s.replace(' ', '') #Remove spaces. \n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    rotated_alphabet = alphabet[alphabet.islice('abcdefghijklmnopqrstuvwxyz',\
    \ 0, -1, 2)]\n    \n    \n    key = alphabet.find(rotated_alphabet[0]) + len(alphabet)*2\n\
    \    \n    def encrypt(x: str) -> str: \n        return ''.join(s[i:i+len(rotated_alphabet)]\
    \ for i in range(0, len(x), len(rotated_alphabet)))\n\n    def decrypt(x: str)\
    \ -> str: \n        return ''.join(s[i:i+len(rotated_alphabet)] for i in range(1,\
    \ len(x), len(rotated_alphabet)))\n\n    return lambda s: ''.join(encrypt(x) for\
    \ x in s.split(' '))\n</cell>\n<cell>", "    return ''.join([chr(ord('A') + ((ord(ch)\
    \ + 2) % 26)) \n                    for ch in s])\n</code>\nTests\n<code>", " \
    \   alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    encrypt_dict\
    \ = {'a': 26, 'b': 25, 'c': 24, 'd': 23, 'e': 22, 'f': 21, 'g': 20, 'h': 19, 'i':\
    \ 18, 'j': 17, 'k': 16, 'l': 15, 'm': 14, 'n': 13, 'o': 12, 'p': 11, 'q': 10,\
    \ 'r': 9, 's': 8, 't': 7, 'u': 6, 'v': 5, 'w': 4, 'x': 3, 'y': 2, 'z': 1}\n  \
    \  encrypt_key = alphabet[encrypt_dict[s.lower()]]\n    reversed = s[::-1]\n \
    \   rot_list = list(reversed)\n    rot_list += rot_list[::-1]\n    return ''.join(rot_list)\n\
    \n", "    return encrypt(s, alphabet)\n</cell>\n<cell>", "    \n    return ''.join([chr(ord(s[i])\
    \ ^ ord(x)) \n                 for (i, x) in zip(range(len(s)), alphabet)])\n\
    \    \n    ", "    \n    alphabet_chars = [chr((ord(c)-97)+2) if c not in {'l',\
    \ 'o', 'q'} else c for c in s]\n    alphabet_chars.extend(['z','w','x','y','a'])\n\
    \    alphabet_chars.reverse()\n    \n    alphabet_chars2 = ['z','w','x','y','a','l','o','q']\n\
    \    alphabet_chars2.extend(['z','w','x','y','a'])\n    alphabet_chars2.reverse()\n\
    \    \n    alphabet_chars3 = ['z','w','x','y','a','l','o']\n    alphabet_chars3.extend(['z','w','x','y','a'])\n\
    \    alphabet_chars3.reverse()\n    \n    alphabet_chars4 = ['z','w','x','y','a','l']\n\
    \    alphabet_chars4.extend(['z','w','x','y','a'])\n    alphabet_chars4.reverse()\n\
    \    \n    alphabet_chars5 = ['z','w','x','y','a']\n    alphabet_chars5.extend(['z','w','x','y','a'])\n\
    \    alphabet_chars5.reverse()\n    \n    alphabet_chars6 = ['z','w','x','y']\n\
    \    alphabet_chars6.extend(['z','w','x','y','a'])\n    alphabet_chars6.reverse()\n\
    \    \n    alphabet_chars7 = ['z','w','x']\n    alphabet_chars7.extend(['z','w','x','y','a'])\n\
    \    alphabet_chars7.reverse()\n    \n    alphabet_chars8 = ['z','w']\n    alphabet_chars8.extend(['z','w','x','y','a'])\n\
    \    alphabet_chars8.reverse()\n    \n    alphabet_chars9 = ['z']\n    alphabet_chars9.extend(['z','w','x','y','a'])\n\
    \    alphabet_chars9.reverse()\n    \n    def enc(char):\n        if len(alphabet_chars)\
    \ == 0 or char.isupper():\n            return char\n        else:\n          \
    \  if char.islower():\n                return alphabet_chars[alphabet_chars.index(char)+1]\n\
    \            elif char.isupper():\n                return alphabet_chars2[alphabet_chars2.index(char)+1]\n\
    \            else:\n                return alphabet_chars3[alphabet_chars3.index(char)+1]\n\
    \    \n    def enc2(char):\n        if len(alphab", "    alphabet = list('abcdefghijklmnopqrstuvwxyz')\n\
    \    cipher = \"\"\n    for i in range(len(s)):\n        cipher = cipher + alphabet[(alphabet.index(s[i])\
    \ + 2) % len(alphabet)]\n    return cipher\n", "    alphabet_len = len(alphabet)\n\
    \    alphabet_rev = {k:v for k,v in enumerate(alphabet)}\n    alphabet_rev[alphabet_len]\
    \ = '\\0'\n    def encrypt_helper(s):\n        ciphertext = ''\n        \n   \
    \     for char in s:\n            try:\n                rotation = alphabet_rev[alphabet.index(char)]\n\
    \                ciphertext += rotation * 2\n            except ValueError:\n\
    \                ciphertext += alphabet[0]\n            \n        return ciphertext\n\
    \    \n    return encrypt_helper(s)\n", "    alpha_table = alphabet.keys()\n \
    \   alpha_table.sort()\n    alpha_table.insert(0,'')\n    alpha_table.append('')\n\
    \    alpha_table.insert(len(alpha_table), '')\n    alpha_table.append('')\n  \
    \  alpha_table.insert(len(alpha_table), \"\")\n    alpha_table.insert(len(alpha_table),\
    \ \"'\")\n    alpha_table.append('')\n    alpha_table.append(\"\")\n    alpha_table.append(\"\
    \ \")\n    alpha_table.append('')\n\n    alpha_table = list(alpha_table)\n   \
    \ alpha_table.insert(0,'')\n    alpha_table.insert(len(alpha_table)-1,'')\n  \
    \  alpha_table.insert(len(alpha_table)-2, '')\n    alpha_table.insert(len(alpha_table)-3,'')\n\
    \    alpha_table.insert(len(alpha_table)-4,'')\n    alpha_table.insert(len(alpha_table)-5,'')\n\
    \    alpha_table.insert(len(alpha_table)-6,'')\n    alpha_table.insert(len(alpha_table)-7,'')\n\
    \n    alpha_table = tuple(alpha_table)\n    alpha_table.insert(0,'')\n    alpha_table.insert(len(alpha_table)-1,'')\n\
    \    alpha_table.insert(len(alpha_table)-2, '')\n    alpha_table.insert(len(alpha_table)-3,'')\n\
    \    alpha_table.insert(len(alpha_table)-4,'')\n    alpha_table.insert(len(alpha_table)-5,'')\n\
    \    alpha_table.insert(len(alpha_table)-6,'')\n    alpha_table.insert(len(alpha_table)-7,'')\n\
    \    alpha_table = tuple(alpha_table)\n\n    alpha_table = list(alpha_table)\n\
    \    alpha_table.insert(0,'')\n    alpha_table.insert(len(alpha_table)-1,'')\n\
    \    alpha_table.insert(len(alpha_table)-2, '')\n    alpha_table.insert(len(alpha_table)-3,'')\n\
    \    alpha_table.insert(len(alpha_table)-4,'')\n    alpha_table.insert(len(alpha_table)-5,'')\n\
    \    alpha_table.insert(len(alpha_table)-6,'')\n    alpha_table.insert(len(alpha_table)-7,'')\n\
    \n    alpha_table = tuple(alpha_table)\n\n    # Make sure that the length of the\
    \ string isn't greater than the maximum\n    # length of the alphabet\n    if\
    \ len(s)>len(alpha_table):\n        raise ValueError(\"The length of the string\
    \ must be less than or equal to the length of the alphabet\")\n\n    # Create\
    \ a blank string which will be used to append the string and \n    # return the\
    \ encrypted string\n    encrypted_string = ''\n\n    # Iterate the string and\
    \ append it with the first character being \n    # the first index of the alphabet\
    \ list\n    encrypted_string += alpha_table[alpha_table.index(s[0])]\n\n    #\
    \ Iterate through the string appending the character by character \n    # with\
    \ the last character being the last index of the alphabet list\n    # and iterating\
    \ twice through the string\n    for i in range(0,len(s)-1,2):\n        encrypted_string\
    \ += alpha_table[alpha_table.index(s[i", "    return \"\".join([chr(ord(c) + 2)\
    \ for c in s])\n</code>\n<|/ a tags=string,encryption,python |>\n<| a tags=string,encryption,python\
    \ dscore=3 |>\nIn a recent blog I wrote a solution that was a variation of the\
    \ previous answers.\nI did this using dictionaries and for loops.\nThe code is\
    \ as follows:\n<code>", "    # initialize alphabet\n    alphabet = string.ascii_lowercase\n\
    \    alphabet += string.ascii_uppercase\n    alphabet += string.digits\n    alphabet\
    \ += string.punctuation\n    # rotate alphabet\n    alphabet = list(alphabet)\n\
    \    alphabet = alphabet[::2] + alphabet[1::2]\n    alphabet = \"\".join(alphabet)\n\
    \    # create new function\n    alphabet = list(alphabet)\n    alphabet = alphabet[::2]\
    \ + alphabet[1::2]\n    alphabet = \"\".join(alphabet)\n    # make function \n\
    \    def encrypt(string: str):\n        \"\"\"Encrypt a string using ROT13 encryption\
    \ method.\"\"\"\n        ciphertext = \"\"\n        for char in string:\n    \
    \        if char in alphabet:\n                i = alphabet.index(char)\n    \
    \            ciphertext += alphabet[(i % len(alphabet)) + 13]\n            else:\n\
    \                ciphertext += char\n        return ciphertext\n    # call function\n\
    \    return encrypt(s)\n", "    return ''.join([chr(ord(letter) + 2 - ord(\"a\"\
    ) % 26) for letter in s])\n</cell>\n<text>\nExercise 2\nUsing the decrypt function\
    \ with different values of  you can see how the encryption system works when shifting\
    \ letters down.\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 3\nUsing the\
    \ alphabet list from Exercise 1, write a function that takes one argument and\
    \ encrypts it.\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 4\nUsing the\
    \ alphabet from Exercise 3, write a function that decrypts it.\n\n\n</text>\n\
    <cell>\n\n</cell>\n<text>\nExercise 5\nNow that you have your two encryption algorithms,\
    \ try them out with some example strings!\n\n\n</text>\n<cell>\n\n</cell>\n<text>\n\
    Exercise 6\nWrite a function that takes a string as an argument and returns True\
    \ if the first and second letters of the string are the same and False otherwise.\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 7\nWrite a function that takes\
    \ a string as an argument and returns True if the first three and last three letters\
    \ of the string are the same and False otherwise.\n\n\n</text>\n<cell>\n\n</cell>\n\
    <text>\nExercise 8\nWrite a function that takes a string as an argument and returns\
    \ True if the first three and last three letters of the string are the same and\
    \ False otherwise.\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 9\nWrite\
    \ a function that takes a string as an argument and returns True if the first\
    \ three and last three letters of the string are the same and False otherwise.\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 10\nWrite a function that takes\
    \ a string as an argument and returns True if the first three and last three letters\
    \ of the string are the same and False otherwise.\n\n\n</text>\n<cell>\n\n</cell>\n\
    <text>\nExercise 11\nWrite a function that takes a string as an argument and returns\
    \ True if the first three and last three letters of the string are the same and\
    \ False otherwise.\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 12\nWrite\
    \ a function that takes a string as an argument and returns True if the first\
    \ three and last three letters of the string are the same and False otherwise.\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nExercise 13\nWrite a function that takes\
    \ a string as an argument and returns True if the first three and last three letters\
    \ of the string are the same and False otherwise.\n\n\n</text>\n<cell>\n\n</cell>\n\
    <text>\nExercise 14\nWrite a function that takes a string as an argument and returns\
    \ True if the first three and last three letters of the string are the same and\
    \ False otherwise.\n\n\n</text>\n<cell>\n\n</cell>\n<text>", "    return \"\"\
    .join(s[i:] + s[:i] for i in range(len(s)//2)) \n\n", "    if len(s)>0:\n    \
    \    alphabet = [i for i in string.ascii_lowercase]\n        alphabet.remove('z')\n\
    \        alphabet.remove('o')\n        alphabet.remove('g')\n        alphabet.remove('f')\n\
    \        alphabet.remove('e')\n        alphabet.remove('d')\n        alphabet.remove('l')\n\
    \        alphabet.remove('i')\n        alphabet.remove('k')\n        alphabet.remove('j')\n\
    \        alphabet.remove('n')\n        alphabet.remove('p')\n        alphabet.remove('h')\n\
    \        alphabet.remove('g')\n        alphabet.remove('f')\n        alphabet.remove('e')\n\
    \        alphabet.remove('d')\n        alphabet.remove('l')\n        alphabet.remove('i')\n\
    \        alphabet.remove('k')\n        alphabet.remove('j')\n        alphabet.remove('n')\n\
    \        alphabet.remove('p')\n        alphabet.remove('h')\n        alphabet.remove('g')\n\
    \        alphabet.remove('f')\n        alphabet.remove('e')\n        alphabet.remove('d')\n\
    \        alphabet.remove('l')\n        alphabet.remove('i')\n        alphabet.remove('k')\n\
    \        alphabet.remove('j')\n        alphabet.remove('n')\n        alphabet.remove('p')\n\
    \        alphabet.remove('h')\n        alphabet.remove('g')\n        alphabet.remove('f')\n\
    \        alphabet.remove('e')\n        alphabet.remove('d')\n        alphabet.remove('l')\n\
    \        alphabet.remove('i')\n        alphabet.remove('k')\n        alphabet.remove('j')\n\
    \        alphabet.remove('n')\n        alphabet.remove('p')\n        alphabet.remove('h')\n\
    \        alphabet.remove('g')\n        alphabet.remove('f')\n        alphabet.remove('e')\n\
    \        alphabet.remove('d')\n        alphabet.remove('l')\n        alphabet.remove('i')\n\
    \        alphabet.remove('k')\n        alphabet.remove('j')\n        alphabet.remove('n')\n\
    \        alphabet.remove('p')\n        alphabet.remove('h')\n        alphabet.remove('g')\n\
    \        alphabet.remove('f')\n        alphabet.remove('e')\n        alphabet.remove('d')\n\
    \        alphabet.remove('l')\n        alphabet.remove('i')\n        alphabet.remove('k')\n\
    \        alphabet.remove('j')\n        alphabet.remove('n')\n        alphabet.remove('p')\n\
    \        alphabet.remove('h')\n        alphabet.remove('g')\n        alphabet.remove('f')\n\
    \        alphabet.remove('e')\n        alphabet.remove('d')\n        alphabet.remove('l')\n\
    \        alphabet.remove('i')\n        ", "    def enc(instr):\n        alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n        alphabet = alphabet[alphabet.isupper()]\
    \ + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        n = len(alphabet)\n        new_str =\
    \ []\n        for c in instr:\n            idx = alphabet.find(c)\n          \
    \  new_str.append(alphabet[(idx + n) % n])\n        return ''.join(new_str)\n\
    \    return enc(s)\n\n", "    \n    alphabet = string.ascii_lowercase\n    shift\
    \ = 2\n    return ''.join(alphabet[i:] + alphabet[:i] for i in string.ascii_letters.find(s))\n",
  "    encrypted = []\n    for c in s:\n        if c.islower():\n            encrypted.append(alphabet[alphabet.index(c)+1])\n\
    \        else:\n            encrypted.append(alphabet[alphabet.index(c)-1])\n\
    \    return ''.join(encrypted)\n\n", "    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    # rotate each letter by two, plus one\n    alphabet_rotation = alphabet.upper()\n\
    \    alphabet = alphabet.replace('Z', '')\n    alphabet = alphabet.replace('A',\
    \ 'Z')\n    alphabet = alphabet.replace('A', 'a')\n    alphabet = alphabet.replace('B',\
    \ 'a')\n    alphabet = alphabet.replace('C', 'b')\n    alphabet = alphabet.replace('D',\
    \ 'b')\n    alphabet = alphabet.replace('E', 'a')\n    alphabet = alphabet.replace('F',\
    \ 'b')\n    alphabet = alphabet.replace('G', 'b')\n    alphabet = alphabet.replace('H',\
    \ 'a')\n    alphabet = alphabet.replace('I', 'b')\n    alphabet = alphabet.replace('J',\
    \ 'b')\n    alphabet = alphabet.replace('K', 'a')\n    alphabet = alphabet.replace('L',\
    \ 'b')\n    alphabet = alphabet.replace('M', 'b')\n    alphabet = alphabet.replace('N',\
    \ 'a')\n    alphabet = alphabet.replace('O', 'b')\n    alphabet = alphabet.replace('P',\
    \ 'b')\n    alphabet = alphabet.replace('Q', 'a')\n    alphabet = alphabet.replace('R',\
    \ 'b')\n    alphabet = alphabet.replace('S', 'a')\n    alphabet = alphabet.replace('T',\
    \ 'b')\n    alphabet = alphabet.replace('U', 'a')\n    alphabet = alphabet.replace('V',\
    \ 'b')\n    alphabet = alphabet.replace('W', 'a')\n    alphabet = alphabet.replace('X',\
    \ 'b')\n    alphabet = alphabet.replace('Y', 'a')\n    alphabet = alphabet.replace('Z',\
    \ 'a')\n    return alphabet + alphabet_rotation[alphabet].upper()\n\n", "    alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    return ''.join([alphabet[(alphabet.index(x)\
    \ + 2) % len(alphabet)] for x in s])\n", "    s = list(s)\n    def shift_chars(chars:\
    \ List[str]) -> None:\n        for i in range(len(chars)):\n            if chars[i]\
    \ == 'a':\n                chars[i] = 'b'\n            elif chars[i] == 'b':\n\
    \                chars[i] = 'a'\n    shift_chars(s)\n    return \"\".join(s)\n\
    </code>\nEDIT: The above works very well, but when trying to make use of the functional\
    \ programming paradigm we would have to add additional functions to encrypt and\
    \ decrypt the strings. For example: \n<code>", "    return \"\".join(rot(s,i)\
    \ for i in range(0,26))\n", "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z']\n    length = len(s)\n    rotated = list(s)\n    for letter in\
    \ alphabet:\n        rotated[letters.index(letter)] = alphabet[letters.index(letter)\
    \ + len(alphabet) - 1]\n    return ''.join(rotated)\n</code>\n<|/ a |>\n<| a tags=algorithm,string,python\
    \ dscore=0 |>\n<code>", "    return ''.join(chr(ord(c) + 2) for c in s)\n</cell>\n\
    <cell>", "    return encrypt(s)\n</cell>\n<cell>", "    def encrypt_helper(s):\n\
    \        alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    \
    \    rotated_alphabet = alphabet[::2] + alphabet[1::2]\n        rotated_alphabet.sort()\n\
    \        return ''.join(rotated_alphabet[alphabet.index(s)] for s in s)\n    return\
    \ encrypt_helper(s)\n\n", "    def rotate_string(string, alphabet):\n        \"\
    \"\"rotates string alphabet by 2\n        \n        Parameters\n        ----------\n\
    \        string : str\n            string to rotate\n        alphabet : str\n\
    \            alphabet to rotate into\n        \n        Returns\n        -------\n\
    \        encrypted : str\n            string encrypted with alphabet\n       \
    \ \"\"\"\n        result = []\n        for letter in string:\n            ascii_letter\
    \ = ord(letter)\n            ascii_letter = (ascii_letter + 2) % 26\n        \
    \    result.append(alphabet[ascii_letter])\n        encrypted = ''.join(result)\n\
    \        return encrypted\n    \n    return rotate_string(s, alphabet)\n    \n\
    </cell>\n<cell>", "    # use a list to store the alphabet\n    # this will be\
    \ the only time that alphabet is accessed\n    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    \n    # create an empty string to be the encrypted string\n    # this will\
    \ be the only time that encryped string is accessed\n    encryped = \"\"\n\n \
    \   # a list to store the letters in encrypted\n    letters_in_encryped = []\n\
    \    \n    # iterate over the string and append each letter to\n    # a list\n\
    \    for letter in s:\n        letters_in_encryped.append(alphabet[alphabet.index(letter)+\
    \ 1])\n        \n    # iterate over the list and add each letter to the \n   \
    \ # encryped string\n    for letter in letters_in_encryped:\n        encryped\
    \ += letter\n        \n    # return the encrypted string\n    return encryped\n\
    </cell>\n<cell>", "    return encrypt_alphabet(s, alphabet)\n\n", "    alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    rotation = ord('a')\n    return ''.join([chr(ord(c)\
    \ + (rotation * 2)) for c in s])\n", "    alphabet = string.ascii_lowercase\n\
    \    return ''.join(alphabet[alphabet.index(letter) + 2] for letter in s)\n\n",
  "    def encrypt_helper(s):\n        \"\"\"Helper function for encrypt\"\"\"\n \
    \       # Define a function that takes in a single character and returns a\n \
    \       # corresponding character, shifted down by two places.\n        def rotate_helper(character):\n\
    \            \"\"\"Function for rotate\"\"\"\n            return chr(ord(character)\
    \ - 2)\n        \n        # Convert each character in the string into a character\n\
    \        new_s = []\n        for char in s:\n            new_s.append(rotate_helper(char))\n\
    \        \n        # Return the resulting string\n        return \"\".join(new_s)\n\
    \    \n    # Return the encrypted string\n    return encrypt_helper(s)\n</cell>\n\
    <cell>", "    \n    # Your code here!\n    \n    return \"\"\n", "    alphabet\
    \ = string.ascii_letters + 'z'\n    shift = 3\n    \n    if s is \"\":\n     \
    \   return \"\"\n    \n    s = [char for char in s]\n    \n    enc = \"\"\n  \
    \  \n    for i in range(len(s)):\n        \n        enc += alphabet[(alphabet.index(s[i])\
    \ + shift) % len(alphabet)]\n        shift -= 2\n    \n    return enc\n\n", " \
    \   alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    rotation\
    \ = ''.join(alphabet[i//2] for i in range(0, len(alphabet)-1, 2))\n    return\
    \ ''.join(rotation.index(x) for x in s)\n", "    alphabet_len = len(ALPHABET)\n\
    \    shifts = [((alphabet_len-1)-i) for i in range(0, alphabet_len)]\n    def\
    \ encrypt(text: str) -> str:\n        encrypted = ''\n        for char in text:\n\
    \            char_code = ALPHABET[ALPHABET.index(char)+ALPHABET.index(ALPHABET[shifts.index(char)%alphabet_len])]\n\
    \            encrypted += char_code\n        return encrypted\n    return encrypt\n",
  "    # Create a function rotate that takes in a string and returns the same \n \
    \   # string rotated 90 degrees\n    def rotate(s):\n        \"\"\"Rotate the\
    \ string 90 degrees\"\"\"\n        # Create a variable that holds the new character\
    \ \n        new_char = ''\n        # Iterate through each character of the string\n\
    \        for i in range(len(s)):\n            # If the character is a letter\n\
    \            if s[i].isalpha():\n                # Add two to the letter's position\
    \ and add that letter\n                new_char += chr(ord(s[i]) + 2)\n      \
    \      # If the character is not a letter\n            else:\n               \
    \ # Add the letter of the alphabet to the string\n                new_char +=\
    \ s[i]\n            # Return the new string\n        return new_char\n    # Call\
    \ the rotate function on the string s\n    return rotate(s)\n</cell>\n<cell>\n\
    assert encrypt('hi') == 'lm'\nassert encrypt('asdfghjkl') == 'ewhjklnop'\nassert\
    \ encrypt('gf') == 'kj'\nassert encrypt('et') == 'ix'\n</cell>\n<text>\nPart B\n\
    Using the aforementioned rotate function, implement a function decrypt_rotated\
    \ that does the opposite.\n\n\n</text>\n<cell>", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    rotated_alphabet = alphabet.rotate(2)\n    alphabet_length = len(alphabet)\n\
    \n    def rotate_str(input_str):\n        \"\"\"Rotates a string by two characters.\
    \ \n        Example: \n        >>> rotate_str('gf')\n        'kj'\n        \"\"\
    \"\n        new_str = \"\"\n        length = len(input_str)\n        for i in\
    \ range(length):\n            new_str = new_str + rotated_alphabet[input_str[i]]\n\
    \        return new_str\n\n    return rotate_str(s)\n\n", "    alphabet = str.maketrans(string.ascii_lowercase,\
    \ string.ascii_uppercase)\n    encrypted_str = ''\n    \n    for i in range(len(s)):\n\
    \        \n        letter = alphabet.index(s[i])\n        letter = (letter + 2)\
    \ % (len(alphabet) + 2)\n        letter = alphabet[letter]\n        \n       \
    \ encrypted_str += letter\n        \n    return encrypted_str\n\nencrypt('hi')\n\
    </cell>\n<text>\nThe code above has all the steps you need to complete the challenge.\n\
    \nThe first step is to create a function that takes in a string and outputs a\
    \ string. The function should perform the following actions:\n\nConvert the string\
    \ into a list using the split() method.\nThe first element of the list should\
    \ be the letter 'f'.\nThe last element of the list should be the letter 'k'.\n\
    The middle element of the list should be a None value.\nAfter the list has been\
    \ split, each element of the list should be converted into a string using the\
    \ str() function. The string should consist of the letter 'e' concatenated with\
    \ the letter in each index of the list starting with index 1.\n\nThe function\
    \ should return the list.\n\n\n</text>\n<cell>", "    alphabet = list(string.ascii_lowercase)\n\
    \    alphabet.rotate(2)\n    alphabet = list(alphabet)\n    return \"\".join(alphabet[i]\
    \ for i in s)\n\n", "    return ''.join(rotate(c, shift) for c in s)\n", "   \
    \ rotated_alphabet = rotate_alphabet(ALPHABET)\n    alphabet_length = len(rotated_alphabet)\n\
    \    alphabet = rotate_alphabet(rotated_alphabet)\n    \n    # Initialize the\
    \ counting variable.\n    count = 0\n\n    # Encrypt the string.\n    for i, c\
    \ in enumerate(s):\n        if alphabet[count] != c:\n            alphabet[count]\
    \ = c\n            count += 1\n\n    return ''.join([alphabet[count % alphabet_length]\
    \ for count in range(0, len(s))])\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alphabet2 = 'nopqrstuvwxyzabcdefghijklm'\n    alphabet3 = 'nopqrstuvwxyzabcdefghijklmno'\n\
    \    alphabet4 = 'abcdefghijklmnopqrstuvwxyzno'\n    alphabet5 = 'nopqrstuvwxyzabcdefghijklmnopq'\n\
    \    alphabet6 = 'nopqrstuvwxyzabcdefghijklmnopqrst'\n    alphabet7 = 'nopqrstuvwxyzabcdefghijklmnopqrstuv'\n\
    \    alphabet8 = 'abcdefghijklmnopqrstuvwxyznopqrstuv'\n    alphabet9 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvw'\n\
    \    alphabet10 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwx'\n    alphabet11 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxy'\n\
    \    alphabet12 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'\n    alphabet13 =\
    \ 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'\n    alphabet14 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyza'\n\
    \    alphabet15 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab'\n    alphabet16\
    \ = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabc'\n    alphabet17 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd'\n\
    \    alphabet18 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcde'\n    alphabet19\
    \ = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdef'\n    alphabet20 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdef'\n\
    \    alphabet2 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefgh'\n    alphabet3\
    \ = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghij'\n    alphabet4 = 'nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk'\n\
    \    ", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    cipher = \"\"\n  \
    \  for letter in s:\n        cipher = cipher + alphabet[(alphabet.index(letter)-alphabet.index(alphabet[0])+2)\
    \ % len(alphabet)]\n    return cipher\n", "    def encrypt(text: str) -> str:\n\
    \        ascii_alphabet = string.ascii_lowercase\n        rotated_alphabet = ascii_alphabet[1::-2]\
    \ + ascii_alphabet[0::-2]\n        return ''.join([rotated_alphabet[text.find(letter)]\
    \ for letter in s])\n    return encrypt\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alphabet += alphabet[:21]\n    \n    alphabet_size = len(alphabet)\n    cipher_string\
    \ = ''\n    for c in s:\n        offset = alphabet_size - (alphabet.index(c) +\
    \ 1)\n        cipher_string += alphabet[offset:offset + 2]\n    \n    return cipher_string\n",
  "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    alphabet = list(alphabet)\n\
    \    \n    for i in range(len(alphabet)):\n        alphabet[i] = alphabet[i] +\
    \ 'x'\n        \n        \n    def encrypt(string: str) -> str:\n        \n  \
    \      #string += alphabet[((ord(string[0]) + 1) % (len(alphabet) - 1)) * 2]\n\
    \        \n        return string\n    \n    return encrypt\n\nencrypt = alphabetEncrypter()\n",
  "    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    rotated_alphabet = []\n    for i in alphabet:\n        rotated_alphabet.append(alphabet[alphabet.index(i)+1])\n\
    \    return ''.join(rotated_alphabet[alphabet.index(s)] for s in s)\n\n", "  \
    \  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    return ''.join([alphabet[alphabet.find(c)\
    \ + len(alphabet)] for c in s])\n", "    return encrypt(s)[::-1]\n", "    alphabet\
    \ = ALPHABET\n    cipher = ''\n    for x in s:\n        cipher = cipher + alphabet[alphabet.index(x)+2]\n\
    \        cipher = cipher + alphabet[alphabet.index(x)+1]\n        cipher = cipher\
    \ + x\n    return cipher\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  \
    \  rot_alphabet = alphabet[0: len(alphabet) + 1] + alphabet[len(alphabet) + 1:\
    \ len(alphabet) + 3] + alphabet[len(alphabet) + 3: len(alphabet) + 1]\n    \n\
    \    # Add letter 'y' to the beginning of the alphabet and rotate it by 2 places.\n\
    \    alphabet += alphabet[0]\n    rot_alphabet += rot_alphabet[0]\n    \n    #\
    \ Create a function encrypt that takes a string as an argument and\n    # returns\
    \ a string encrypted with the alphabet being rotated. \n    def encrypt(string:\
    \ str) -> str:\n        return rot_alphabet[(rot_alphabet.index(string) + len(alphabet)\
    \ * 2) % len(rot_alphabet)]\n    \n    return encrypt(s)\n\n", "    return ''.join([chr((ord(c)\
    \ + k) % 26 + 65) for k, c in enumerate(s)])\n</cell>\n<text>\nNow let's create\
    \ the function that will decrypt our encrypted string:\n\n\n</text>\n<cell>",
  "    alphabet = string.ascii_lowercase\n    alphabet = alphabet[1:] + alphabet[:1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n\
    \    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] +\
    \ alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n    alphabet =\
    \ alphabet[-1:] + alphabet[:-1]\n    alphabet = alphabet[-1:] + alphabet[:-1]\n",
  "    alpha = 'abcdefghijklmnopqrstuvwxyz'\n    alpha2 = 'mnopqrstuvwxyzabc'\n  \
    \  alpha3 = 'nopqrstuvwxyzabcdef'\n    alpha4 = 'qrstuvwxyzabcdefgh'\n    alpha5\
    \ = 'rstuvwxyzabcdefghij'\n    alpha6 = 'stuvwxyzabcdefghijkl'\n    alpha7 = 'vwxyzabcdefghijklmn'\n\
    \    alpha8 = 'wxyzabcdefghijklmno'\n    alpha9 = 'xyzabcdefghijklmnop'\n    alpha10\
    \ = 'zabcdefghijklmnopq'\n    alpha11 = 'abcdfghijklmnopqrst'\n    alpha12 = 'efghijklmnopqrstuv'\n\
    \    alpha13 = 'ghijklmnopqrstuvwx'\n    alpha14 = 'hijklmnopqrstuvwxyz'\n   \
    \ alpha15 = 'jklmnopqrstuvwxyzab'\n    alpha16 = 'klmnopqrstuvwxyzabc'\n    alpha17\
    \ = 'lmnopqrstuvwxyzabcd'\n    alpha18 = 'mnopqrstuvwxyzabcd'\n    alpha19 = 'nopqrstuvwxyzabcde'\n\
    \    alpha20 = 'oqqrstuvwxyzabcdef'\n    alpha21 = 'pqrstuvwxyzabcdefg'\n    alpha22\
    \ = 'qrstuvwxyzabcdefgh'\n    alpha23 = 'rstuvwxyzabcdefghi'\n    alpha24 = 'stuvwxyzabcdefghij'\n\
    \    alpha25 = 'vwxyzabcdefghijkl'\n    alpha26 = 'wxyzabcdefghijklm'\n    alpha27\
    \ = 'xyzabcdefghijklmn'\n    alpha28 = 'zabcdefghijklmno'\n    alpha29 = 'abcdfghijklmnopqrs'\n\
    \    alpha30 = 'efghijklmnopqrsut'\n    alpha31 = 'ghijklmnopqrsutwx'\n    alpha32\
    \ = 'hijklmnopqrsutwxyz'\n    alpha33 = 'jklmnopqrsutwxyzab'\n    alpha34 = 'klmnopqrsutwxyzabc'\n\
    \    alpha35 = 'lmnopqrsutwxyzabcd'\n    alpha36 = 'mnopqrsutwxyzabcd'\n    alpha37\
    \ = 'no", "    s = 'z'\n    rotation = 2\n    letters = re.findall(r'[a-z]', s)\n\
    \    for i in letters:\n        s = re.sub(i, 'z', s)\n    \n    # Find where\
    \ the rotation happens and store it\n    length = len(s)\n    index = length -\
    \ (length // rotation)\n    \n    # Build up new string\n    result = s[:index]\n\
    \    for i in range(1, rotation):\n        result += s[-(index + ((index + i)\
    \ % length))]\n    \n    return result + s[index] + (rotation * 'z')\n</cell>\n\
    <text>\nBelow is the function that takes some test string arguments and prints\
    \ them out after being encrypted. If this passes all of the tests, then it was\
    \ encrypted correctly.\n\n\n</text>\n<cell>", "    return ''.join(chr((ord(c)-97+2)%26+97)\
    \ for c in s)\n    ", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    alpha_len\
    \ = len(alphabet)\n    rotations = [alphabet[(i+alpha_len//2)-1:(i+alpha_len//2)]\
    \ for i in range(alpha_len)]\n    rotation = functools.reduce(lambda x, y: x +\
    \ y, rotations)\n    return rotation[alphabet.find(s)] if s in alphabet else s\n\
    \n", "    alpha = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    \n\
    \    def rotate_letter(s, i, j):\n        alpha = alpha[i:j]\n        alpha.insert(0,\
    \ 'z')\n        alpha.append('z')\n        alpha = alpha[0:-1]\n        \n   \
    \     return ''.join(alpha)\n    \n    \n    def encrypt(s):\n        \n     \
    \   for i in range(0, len(s)-1):\n            j = i + 2\n            \n      \
    \      letter = rotate_letter(s, i, j)\n            \n            if letter in\
    \ s:\n                return letter\n    \n    return encrypt(s)\n    \n    ",
  "    result = \"\"\n    alphabet_len = len(alphabet)\n    for c in s:\n        if\
    \ c in alphabet:\n            result += alphabet[alphabet_len + alphabet.index(c)\
    \ % alphabet_len]\n        else:\n            result += c\n    return result\n\
    </cell>\n<cell>", "    def rotation(s: str) -> str:\n        \"\"\"This function\
    \ rotates the alphabet by two places.\"\"\"\n        newAlphabet = alphabet[2:]\
    \ + alphabet[:2]\n        for i, ch in enumerate(newAlphabet):\n            if\
    \ ch not in s:\n                newAlphabet[s.find(ch)] = alphabet[i]\n      \
    \  return \"\".join(newAlphabet)\n    return rotation(s)\n</cell>\n<cell>", " \
    \   \n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = 'fedcba9876543210'\n\
    \    return ''.join(map(lambda c: rotated_alphabet[alphabet.index(c) + 2 - alphabet.index(c)]\
    \ ,s))\n</cell>\n<cell>", "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z']\n    rotated_alphabet = ['g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd',\
    \ 'e', 'f']\n    rotation = len(s)//2\n    count = 0\n    \n    def rotate_function(string:\
    \ str) -> str:\n        return string[:rotation] + rotated_alphabet[count] + string[rotation:]\n\
    \    \n    new_string = rotate_function(s)\n    \n    return new_string\n</cell>\n\
    <text>\nExercise 3 - Encryption\nNow apply the function to all test cases.\n\n\
    \n</text>\n<cell>\ntest_cases = [\n    ('hello', 'lmnop'),\n    ('hello', 'ewhjklnop'),\n\
    \    ('abcde', 'abcdxe'),\n    ('abcde', 'fghijklmnopqrs'),\n    ('abcde', 'yzyxwvutsrqponmlkjihgfedcba'),\n\
    \    ('', ''),\n    ('hello', ''),\n    ('abcde', ''),\n    ('a', 'a'),\n    ('aa\
    \ bb cc', 'aa bb cc'),\n    ('a b c', 'a b c'),\n    ('', ''),\n    (' ab ', 'ab\
    \ '),\n    ('a b c ', ' ab '),\n    ('a b c', ' ab '),\n]\n\nfor test_case in\
    \ test_cases:\n    print(\"encrypting\", test_case[0])\n    print(\"---> \", test_case[1])\n\
    \    print(\"decrypted:\", decrypt(test_case[1]))\n    print(\"---> \", test_case[2])\n\
    \    print(\"expected:\", test_case[2])\n</cell>\n<text>\nExercise 4 - Reverse\
    \ string \nA simple way to reverse a string is to start from the end and start\
    \ adding chars downwards. If the string is length 1, then just return it. Otherwise,\
    \ add the char to the beginning of the string and start adding chars down. Repeat\
    \ until the string is length 1 or 0. \nFor example:\n    \n    >>> reverse('hello')\n\
    \    'olleh'\n    >>> reverse('abcde')\n    'deabc'\n    >>> reverse('a')\n  \
    \  'a'\n    >>> reverse('a b c')\n    'a b c'\n    >>> reverse(' ab ')\n    'a\
    \ b c'\n    >>> reverse('a b c ')\n    'a b c'\n    >>> reverse('a b c')\n   \
    \ 'a b c'\n    >>> reverse(' ab ')\n    'a b c'\n    >>> reverse('a b c ')\n \
    \   'a b c'\n    >>> reverse('a b c')\n    'a b c'\n    >>> reverse('a ", "  \
    \  return encrypt_helper(s, rotate_helper)\n\n", "    enc = \"\"\n    for i in\
    \ range(len(s)):\n        enc += alphabet[(alphabet.index(alphabet[i]) + 2) %\
    \ len(alphabet)]\n    return enc\n\n", "    if s in ALPHABET_ROTATE:\n       \
    \ return ALPHABET_ROTATE[s]\n    return ''\n", "    alphabet = string.ascii_lowercase\n\
    \    # rotate the alphabet by 2\n    alphabet = list(alphabet) + list(alphabet)\n\
    \    alphabet = alphabet[::2] + alphabet[1::2]\n    # turn alphabet into a string\n\
    \    return alphabet[alphabet.index(s)]\n", "    rotatable_alphabet = alphabet[0:2]\
    \ + alphabet[2:4] + alphabet[4:6] + alphabet[6:]\n    return ''.join(rotatable_alphabet[alphabet.index(c)]\
    \ for c in s)\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe rotate function should\
    \ return 'gf' as it has 'g' in the first slot, followed by 'f' and 'f' in the\
    \ next two slots.\n<|/ c |>\n<| c |>\nThe rotate function should return 'gf' as\
    \ it has 'g' in the first slot, followed by 'f' and 'f' in the next two slots.\n\
    <|/ c |>\n<| c |>\nThe rotate function should return 'gf' as it has 'g' in the\
    \ first slot, followed by 'f' and 'f' in the next two slots.\n<|/ c |>\n<| c |>\n\
    I have amended my answer to allow for the first two letters being the same.\n\
    <|/ c |>\n<| c |>\nThe rotate function should return 'gf' as it has 'g' in the\
    \ first slot, followed by 'f' and 'f' in the next two slots.\n<|/ c |>\n<| a |>\n\
    This is an interesting problem. It seems to me that this can be solved using two\
    \ dictionaries. The first contains the letters of your alphabet, mapped to their\
    \ position. The second contains the same mapping, but with the letters shifted\
    \ down by 2 spots.\n<code>", "    alphabet = [\n        0,\n        1,\n     \
    \   2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n\
    \        9,\n        10,\n        11,\n        12,\n        13,\n        14,\n\
    \        15,\n        16,\n        17,\n        18,\n        19,\n        20,\n\
    \        21,\n        22,\n        23,\n        24,\n        25,\n        26,\n\
    \        27,\n        28,\n        29,\n        30,\n        31,\n        32,\n\
    \        33,\n        34,\n        35,\n        36,\n        37,\n        38,\n\
    \        39,\n        40,\n        41,\n        42,\n        43,\n        44,\n\
    \        45,\n        46,\n        47,\n        48,\n        49,\n        50,\n\
    \        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n\
    \        57,\n        58,\n        59,\n        60,\n        61,\n        62,\n\
    \        63,\n        64,\n        65,\n        66,\n        67,\n        68,\n\
    \        69,\n        70,\n        71,\n        72,\n        73,\n        74,\n\
    \        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n\
    \        81,\n        82,\n        83,\n        84,\n        85,\n        86,\n\
    \        87,\n        88,\n        89,\n        90,\n        91,\n        92,\n\
    \        93,\n        94,\n        95,\n        96,\n        97,\n        98,\n\
    \        99,\n        100,\n        101,\n        102,\n        103,\n       \
    \ 104,\n        105,\n        106,\n        107,\n        108,\n        109,\n\
    \        110,\n        111,\n        112,\n        113,\n        114,\n      \
    \  115,\n        116,\n        117,\n        118,\n        119,\n        120,\n\
    \        121,\n        122,\n        123,\n        124,\n        125,\n      \
    \  126,\n        127,\n        128,\n        129,\n        130,\n        131,\n\
    \        132,\n        133,\n        134,\n        135,\n        136,\n      \
    \  137,\n        138,\n        139,", "    return rot13_encrypt(s)\n</cell>\n\
    <cell>", "    pass\n", "    return \"\".join(alphabet[int(c)] for c in s)\n",
  "    return encrypt(s, alphabet)\n", "    return ''.join([chr(ord(c) + 2) for c\
    \ in s])\n\n", "    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    \n    alphabet = [alphabet[a-2] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[a+2] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[2*a+1]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[2*a] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[a+2] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[2*a] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[2*a] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[2*a] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[2*a] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[2*a] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*a+1] for a in range(len(alphabet))]\n    alphabet\
    \ = [alphabet[2*a] for a in range(len(alphabet))]\n    \n    alphabet = [alphabet[a-2]\
    \ for a in range(len(alphabet))]\n    alphabet = [alphabet[a+2] for a in range(len(alphabet))]\n\
    \    \n    alphabet = [alphabet[2*", "    encrypted = []\n    for char in s:\n\
    \        encrypted.append(ALPHABET[(ALPHABET.index(char) + 2) % len(ALPHABET)])\n\
    \    return ''.join(encrypted)\n", "    ALPHABET = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    letters = []\n    key = alphabet_to_key(ALPHABET, s)\n    for i in range(len(key)):\n\
    \        letters.append(key[(len(key)-i)//2]+key[((len(key)-i)//2)%len(key)])\n\
    \    return ''.join(letters)\n</code>\n<|/ a |>\n<| c |>\nThank you so much for\
    \ the help! I actually didn't know that `%` had different behavior depending on\
    \ whether it's used on ints or on floats (I assumed it was the same). This makes\
    \ a lot more sense! For my second question, how do you get the length of the alphabet\
    \ in bits? I looked up how to get the number of bits here: https://stackoverflow.com/questions/62044/how-do-you-get-the-number-of-bits-in-a-python-int\
    \  but `getNBits(ALPHABET)` doesn't work (TypeError: getNBits() missing 1 required\
    \ positional argument: 'alphabet'). Is there a way to get the number of bits in\
    \ alphabet in python?\n<|/ c |>\n<| c |>\nSorry, I forgot to include an argument\
    \ to getNBits. It's fixed now.\n<|/ c |>\n<| c |>\nAh I see, thank you for the\
    \ help! I really appreciate it!\n<|/ c |>\n<| a |>\nYou could use recursion, something\
    \ like:\n<code>", "    return ''.join(chr(ord(ch)-1 + rot) % 26 for ch in s)\n\
    \n", "    alphabet = string.ascii_lowercase\n\n    def encrypt1(char: str) ->\
    \ str:\n        \"\"\"Rotate one character in the alphabet by two.\"\"\"\n   \
    \     # use char to index alphabet\n        idx = alphabet.find(char)\n      \
    \  # use index to rotate alphabet two places down\n        return alphabet[(idx\
    \ + 1) % 26]\n\n    return ''.join(map(encrypt1, s))\n\n", "    def encrypt(inp:\
    \ str) -> str: \n        return \"\".join(chr(ord(c) + 2) for c in inp)\n    return\
    \ encrypt(s)\n", "    return rotate_base(s, 'z')\n", "    return ''.join([chr(ord('A')\
    \ + i - 2)\n                    for i in list(map(int, list(s))) if i % 2 == 0])\n",
  "    alphabet = list(string.ascii_lowercase)\n    alphabet.insert(0, alphabet.pop(-1))\n\
    \    alphabet = ''.join(alphabet)\n    alphabet += alphabet\n    return alphabet[(alphabet.index(s)+2)%len(alphabet)]\n",
  "    alphabet_letters = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    alphabet = ''.join(alphabet_letters)\n    return ''.join(map(lambda x: alphabet[alphabet_letters.index(x.upper())],\
    \ s))\n", "    alphabet = list(string.ascii_lowercase) + list(string.ascii_uppercase)\n\
    \    rotated_alphabet = [alphabet[i + 2] + alphabet[i] for i in range(len(alphabet)\
    \ - 1)]\n    translated_alphabet = [alphabet[alphabet.index(i) + 1] if i in alphabet\
    \ else i for i in s]\n    enc = \"\".join(\"\".join(map(lambda x: translated_alphabet[alphabet.index(x)],\
    \ l)) for l in s.lower().split())\n    rotated_enc = \"\".join(map(lambda x: rotated_alphabet[rotated_alphabet.index(x)],\
    \ enc))\n    return rotated_enc\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    s = s.lower()\n    rot_table = {alphabet[a]: alphabet[b] for a, b in itertools.product(alphabet,\
    \ alphabet)}\n    return ''.join([rot_table[b] for b in s])\n\n", "    return\
    \ ''.join(\n        rotate(s.lower()) \n        for c in s\n    )\n</cell>\n<cell>",
  "    return ''.join( \n        s[i:i+2] +\n        s[i+1:i+1] + \n        s[:i+1]\
    \ for i in \n        range(len(s)-1) \n    )\n</code>\n<|/ a |>\n<| c |>\nthank\
    \ you for the response, I understand what you mean by rotating, but I'm wondering\
    \ how would I implement this into the code I've already written? I'm thinking\
    \ that I'll have to add it to my code somehow.\n<|/ c |>\n<| c |>\nYes you would\
    \ need to add it to your existing code. You'll need to create a function or method\
    \ to call it and pass in the argument of the string to rotate.\n<|/ c |>\n<| c\
    \ |>\nI see, thanks for the response! I did this, but I'm having trouble with\
    \ getting it to actually work. Do you think you could take a look at it for me?\
    \ I added it to the bottom of my post\n<|/ c |>\n<| c |>\nOk so I figured out\
    \ how to properly implement your solution. However, the only problem now is that\
    \ the program is running very slow for even larger inputs.\n<|/ c |>\n<| c |>\n\
    This is because you need to use an iterative solution and it's getting really\
    \ slow after a while. I've posted a recursive solution.\n<|/ c |>\n<| a |>\nHere\
    \ is a solution without recursion or loops using a helper function. The algorithm\
    \ is straightforward, except for the fact that the output string gets appended\
    \ multiple times each time you append a single character to a new string and that\
    \ each time you append a single character you have to move the string back to\
    \ the beginning so that we can get two characters in the new string. Hence, I\
    \ chose a second approach where I build up the output string first and then use\
    \ a single slicing operation to remove the first character each time:\n<code>",
  "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    cipher = ''\n    for i in range(len(s)):\n\
    \        # Shift the letters by a factor of two.\n        cipher += alphabet[((alphabet.index(s[i])\
    \ + 2) % (len(alphabet))) - 1]\n    return cipher\n</cell>\n<cell>", "    alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    rotate = lambda l: alphabet[(alphabet.index(l)\
    \ + 2) % len(alphabet)]\n    return ''.join(map(rotate, s))\n", "    # use ASCII\
    \ alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    # create an empty list to store the encrypted version of the string\n   \
    \ encrypted_str = []\n    # iterate through each character in the string\n   \
    \ for char in s:\n        # get the ASCII code for the character\n        charAsciiCode\
    \ = ord(char)\n        # get the rotated ASCII code by subtracting the alphabet\
    \ code from the original ASCII code\n        rotatedAsciiCode = int(charAsciiCode)\
    \ - ord(alphabet)\n        # set the rotated ASCII code into the encrypted string\n\
    \        encrypted_str.append(alphabet[rotatedAsciiCode])\n    # return encrypted\
    \ string\n    return ''.join(encrypted_str)\n\n", "    result = \"\"\n    for\
    \ i in range(len(s)):\n        result += alphabet[(alphabet.index(s[i]) + 2) %\
    \ 26]\n    return result\n\n", "    \n    alphabet = s.upper()\n    return ''.join([alphabet[(alphabet.index(letter)\
    \ + 2) % len(alphabet)] for letter in s])\n</cell>\n<cell>", "    letters = list(s)\n\
    \    return \"\".join(letters[-1:] + letters[:-1])\n", "    \n    alphabet =['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    rotated_alphabet = []\n    for letter in alphabet:\n        rotated_alphabet.append(alphabet[alphabet.index(letter)\
    \ + 1])\n    \n    return ''.join(rotated_alphabet[alphabet.index(char) - 1] for\
    \ char in s)\n\n", "    return encrypt_rot13(s)\n", "    alphabet = rotate_alphabet\n\
    \    def encrypt(string: str) -> str:\n        \"\"\"Function to rotate alphabet\
    \ by two \n        and then encrypt a string of length len(alphabet) \n      \
    \  using that alphabet.\n        \"\"\"\n        result = ''\n        for c in\
    \ string:\n            result += alphabet[c]\n        return result\n    return\
    \ encrypt\n</cell>\n<cell>", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  \
    \  encrypted = []\n    for letter in s:\n        encrypted.append(alphabet[alphabet.index(letter)\
    \ + 2])\n    return ''.join(encrypted)\n\n", "    alphabet = string.ascii_lowercase\n\
    \    # Create a dict to store all of the letters with their rotations\n    letter_dict\
    \ = {}\n    # Iterate over each letter and keep track of their current rotation.\n\
    \    for letter in alphabet:\n        letter_dict[letter] = 0\n    # Iterate over\
    \ the string and add the letter to their correct spot\n    for letter in s:\n\
    \        letter_dict[letter] = letter_dict[letter] + 2\n    \n    # Iterate over\
    \ the letters in the dictionary and add them to a string.\n    final_string =\
    \ ''\n    for letter in alphabet:\n        final_string += letter_dict[letter]\n\
    \        \n    return final_string\n        ", "    # code goes here\n    pass\n",
  "    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    shift = 2\n    cipher = ''\n    for i in s:\n        if i in alphabet:\n\
    \            i = alphabet[(alphabet.index(i) + shift) % len(alphabet)]\n     \
    \   else:\n            i = i\n        cipher += i\n    return cipher\n", "   \
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    shifts = [-1, 1, 0, 2, 1]\n \
    \   key = \"\".join(alphabet)\n    shift = 0\n    enc = []\n    for c in s:\n\
    \        enc = enc + [alphabet[(alphabet.index(c) + shift) % len(alphabet)]]\n\
    \        shift = shift + shifts[alphabet.index(c)]\n    return \"\".join(enc)\n",
  "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    cipher_alphabet = 'nopqrstuvwxyzabcdefghijklm'\n\
    \    if len(s) <= len(alphabet):\n        return ''.join( alphabet.index(c) for\
    \ c in s )\n    else:\n        return ''.join( cipher_alphabet.index(alphabet[c%len(alphabet)])\
    \ \n                for c in s )\n", "    return encryptHelper(s, alphabet)\n",
  "    return ''.join(alphabet[alphabet.index(char) + len(alphabet) - i % len(alphabet)]\
    \ for i, char in enumerate(s))\n", "    return ''.join([letters[i] for i in s])\n",
  "    return ''.join(rot_alphabet[ord(x) % len(rot_alphabet)]\n                 \
    \  for x in s)\n\n", "    return encrypt_helper(s, alphabet)\n", "    return ''.join([letters[ord(letter)\
    \ - ord('a')] for letter in s])\n\n", "    return ''.join([alphabet[alphabet.index(s)%len(alphabet)]\n\
    \                    for s in s])\n</cell>\n<cell>", "    # Find the number of\
    \ letters in the alphabet\n    ascii_alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    # Find the number of characters in the string\n    str_len = len(s)\n   \
    \ # Create the translation table\n    table = [None] * 26\n    for i in range(0,\
    \ str_len):\n        table[(ascii_alphabet.index(s[i]) + 2) % 26] = ascii_alphabet[(ascii_alphabet.index(s[i])\
    \ + 2) % 26]\n    table[0] = 'z'\n    table[-1] = 'z'\n    table = table[1:-1]\n\
    \    encrypt_table = table[:]\n    # Create the function that will rotate the\
    \ letters in the string\n    def encryptChar(char):\n        if char in encrypt_table:\n\
    \            return encrypt_table[char]\n        return char\n    return ''.join(map(encryptChar,\
    \ s))\n\n", "    alphabet = string.ascii_letters + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    encrypted = []\n    for c in s:\n        idx = alphabet.index(c)\n      \
    \  idx = idx * 2 + 2\n        encrypted.append(alphabet[idx])\n    return ''.join(encrypted)\n\
    </cell>\n<text>\nLet's check it out!\n\n\n</text>\n<cell>", "    # Get the rotation\
    \ matrix from the given alphabet and number of rows\n    matrix = get_matrix(alphabet)\n\
    \    \n    # Rotate the string into a new string\n    def rotate(s: str) -> str:\n\
    \        # Iterate over each character in the string\n        for char in s:\n\
    \            # Get the index of the current character in the alphabet\n      \
    \      i = alphabet.index(char)\n            \n            # Get the current letter\
    \ in the matrix\n            current: str = matrix[i]\n            \n        \
    \    # Get the next letter in the matrix and put it in a variable\n          \
    \  next: str = matrix[i + 1]\n            \n            # Concatenate the two\
    \ letters together and assign it to the new string\n            # NOTE: This assumes\
    \ the letters are in a fixed position in the alphabet\n            # (The next\
    \ letter in the alphabet is always one lower than the current letter in the alphabet)\n\
    \            s += next + current\n            \n        return s\n    \n    #\
    \ Call the rotate function on every character of the string\n    return rotate(s)\n\
    \n", "    # Create a list with the 26 rotated letters of the alphabet\n    alphabet\
    \ = list(ascii_lowercase)\n    alphabet = list(map(str.upper, alphabet))\n   \
    \ alphabet = alphabet[2:] + alphabet[:2]\n    \n    # Rotate the letters of the\
    \ alphabet by the number of letters given\n    # in the argument.\n    return\
    \ ''.join(alphabet[alphabet.index(letter) + n] for letter in s)\n", "    return\
    \ ''.join(chr(ord(letter) + 1) if letter != ' ' else letter for letter in s)\n",
  "    alphabet = string.ascii_lowercase\n    alphabet = list(alphabet)\n    alphabet\
    \ = alphabet[0:len(alphabet) // 2] + alphabet[len(alphabet) // 2 + 1:]\n    alphabet\
    \ = ''.join(alphabet)\n    alphabet = alphabet.replace(\" \", \"\")\n    alphabet\
    \ = alphabet.lower()\n    alphabet = alphabet.split('')\n    alphabet = [alphabet[i:i\
    \ + 2] for i in range(0, len(alphabet), 2)]\n    return \"\".join([alphabet[(alphabet.index(x)\
    \ + len(alphabet) // (len(alphabet) ** 2) - 1) % (len(alphabet))]\n          \
    \          for x in s])\n", "    rot13 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 13) % 26) for c in s)\n\n    rot18 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 18) % 26) for c in s)\n    \n    rot20 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 20) % 26) for c in s)\n\n    rot23 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 23) % 26) for c in s)\n\n    rot24 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 24) % 26) for c in s)\n    \n    rot28 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 28) % 26) for c in s)\n    \n    rot29 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 29) % 26) for c in s)\n    \n    rot30 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 30) % 26) for c in s)\n    \n    rot34 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 34) % 26) for c in s)\n    \n    rot35 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 35) % 26) for c in s)\n\n    rot38 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 38) % 26) for c in s)\n    \n    rot39 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 39) % 26) for c in s)\n    \n    rot42 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 42) % 26) for c in s)\n    \n    rot43 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 43) % 26) for c in s)\n    \n    rot44 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 44) % 26) for c in s)\n    \n    rot46 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 46) % 26) for c in s)\n    \n    rot47 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 47) % 26) for c in s)\n    \n    rot49 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 49) % 26) for c in s)\n    \n    rot51 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 51) % 26) for c in s)\n    \n    rot52 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 52) % 26) for c in s)\n    \n    rot53 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 53) % 26) for c in s)\n    \n    rot54 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 54) % 26) for c in s)\n    \n    rot58 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 58) % 26) for c in s)\n    \n    rot59 = lambda s: ''.join(\n        chr((ord(c)\
    \ + 59) % 26) for c in s)\n    \n    rot62 = lambda s: ''.join(\n        chr",
  "    return ''.join(rotate(a, 2) for a in s)\n", "    return s.translate(string.maketrans(string.ascii_uppercase,\n\
    \                                       string.ascii_lowercase[2:]))\n</cell>\n\
    <cell>", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    alphabet_length =\
    \ len(alphabet)\n    alphabet = alphabet.lower()\n    alphabet = alphabet[::-1]\n\
    \    cipher = \"\"\n\n    for char in s:\n        if char.isalpha():\n       \
    \     char = alphabet[(alphabet_length - alphabet.find(char) + alphabet_length)\
    \ % alphabet_length]\n        cipher += char\n\n    return cipher\n", '    return
    rotate(s, 2)', "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet\
    \ = ''\n    for c in alphabet:\n        if c not in s:\n            rotated_alphabet\
    \ = rotated_alphabet[1:] + c\n    return rotated_alphabet\n", "    alphabet =\
    \ string.ascii_lowercase\n    alphabet = alphabet[-2:] + alphabet[:2]\n    alphabet\
    \ = alphabet*2\n    alphabet = alphabet[-3:] + alphabet[:3]\n    alphabet = alphabet*2\n\
    \    alphabet = alphabet[-3:] + alphabet[:3]\n    alphabet = alphabet*2\n    alphabet\
    \ = alphabet[-3:] + alphabet[:3]\n    alphabet = alphabet*2\n    alphabet = alphabet[-3:]\
    \ + alphabet[:3]\n    return ''.join(alphabet[alphabet.index(s)%26] for s in s)\n",
  "    def rotate(s: str, shift: int, alphabet: list) -> str:\n        \"\"\"Rotate\
    \ each character of the string by shift.\"\"\"\n        \n        def encrypt(c:\
    \ str) -> str:\n            \"\"\"Return the encrypted character of c given by\
    \ the\n            alphabet given the shift and character.\"\"\"\n           \
    \ \n            if alphabet[shift]:\n                return alphabet[shift].lower()\n\
    \            else:\n                return c\n        \n        return ''.join(map(encrypt,\
    \ s))\n    return rotate(s, shift, alphabet)\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alpharot = alphabet.rsplit(None, 1)[0]\n    return alphabet[alphabet.index(alpharot)\
    \ + alphabet.index(s)]\n\n", "    # TODO\n    return ''\n", "    \n    l = len(s)\n\
    \    return ''.join(chr(ord(c) + 2) for c in s)\n", "    rot = ''\n    for letter\
    \ in s:\n        rot += alphabet[alphabet.index(letter) + 1]\n    return rot\n",
  "    return ''.join(rot13(s[i:i+len(s)]).upper() for i in range(0,len(s))) \n",
  "    # Write your code here\n    rot_alphabet = list('abcdefghijklmnopqrstuvwxyz')\n\
    \    alphabet = list('abcdefghijklmnopqrstuvwxyz')\n    alphabet.reverse()\n \
    \   rot_alphabet.reverse()\n    alphabet = alphabet.translate({ord(k): ord(v)\
    \ for k, v in zip(alphabet, rot_alphabet)})\n    alphabet = alphabet[: len(s)\
    \ // 2] + alphabet[len(s) // 2 + 1 : ]\n    return alphabet\n", "    return ''.join([alphabet[alphabet.index(s)+2]\
    \ for s in s])\n", "    \n    # Create a list that stores the letter positions\
    \ of the alphabet\n    positions = [0, 2, 5, 7, 10, 13, 16, 19, 22, 25, 28]\n\
    \    \n    # Add 2 to the first element of the list since it moves down two letters\n\
    \    positions.append(2)\n    \n    # Add 1 to the second element of the list\
    \ since it moves down one letter\n    positions.append(1)\n    \n    # Iterate\
    \ through the list to see what letter it is for each position\n    # Shift the\
    \ letters down by two and multiply by two so that they \n    # shift down by two\
    \ places instead of one place\n    for i in range(0, len(positions)):\n      \
    \  s = s[positions[i]:positions[i+1]] + s[positions[i]:positions[i+1]].upper()\n\
    \    \n    return s\n", "    # Create a variable that holds the letters that are\
    \ shifted \n    # to the left by two. \n    alphabet_one = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alphabet_two = alphabet_one[::-1]\n    \n    # Define a variable that holds\
    \ all the possible letters of alphabet one\n    alphabet = alphabet_one + alphabet_two\n\
    \n    # Create a variable that holds the letters that are shifted \n    # to the\
    \ right by two.\n    alphabet = alphabet[::-1]\n\n    # Define a variable that\
    \ holds the key to be used for encryption. \n    key = 'key'\n\n    # Create a\
    \ variable that holds the length of the key \n    key_length = len(key)\n\n  \
    \  # Define a variable that holds the string to be encrypted. \n    string_length\
    \ = len(s)\n\n    # If the key length is longer than the string length,\n    #\
    \ raise an exception.\n    if key_length >= string_length:\n        raise Exception('Key\
    \ should be longer than the string')\n    \n    # If the key length is less than\
    \ or equal to the string length,\n    # raise an exception.\n    elif key_length\
    \ < string_length:\n        raise Exception('Key should be shorter than the string')\n\
    \n    # Define a variable that holds the character at index 0 of the key\n   \
    \ # to be used for encryption.\n    key_character = key[0]\n\n    # Define a variable\
    \ that holds the integer that will be used in \n    # determining where the shift\
    \ should be done.\n    shift_amount = 0\n\n    # Define a variable that holds\
    \ the integer that will be used in \n    # determining where the shift should\
    \ be done. \n    shift_amount = string_length - key_length\n    \n    # If the\
    \ shift_amount is less than zero, raise an exception.\n    if shift_amount < 0:\n\
    \        raise Exception('Shift amount must be positive')\n\n    # Convert the\
    \ shift_amount into a string. \n    shift_amount = str(shift_amount)\n\n    #\
    \ Define a variable that holds the letter that will hold the \n    # decrypted\
    \ string. \n    decrypted_string = ''\n    \n    # Define a variable that holds\
    \ the character at index 0 of the \n    # decrypted string. \n    decrypted_string\
    \ = decrypted_string + alphabet[shift_amount]\n\n    # Create a while loop \n\
    \    while shift_amount != 0:\n        # Increment shift_amount by two. \n   \
    \     shift_amount = shift_amount + 2\n        \n        # Define a variable that\
    \ holds the character at index 0 of the \n        # decrypted string. \n     \
    \   decrypted_string = decrypted_string + alphabet[shift_amount]\n\n    # Add\
    \ the key character to decrypted string.\n    decrypted_string = decrypted_string\
    \ + key_character\n    \n    # Return the decrypted string. \n    return decrypted_string\n",
  "    return ''.join([x[1:] + x[:1] for x in s])\n", "    \n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alphabet = alphabet[::2] + 'lmnopqrstuvwxyz' + alphabet[1::2]\n    alphabet\
    \ = alphabet[::2] + 'pqrstuvwxyz' + alphabet[1::2]\n    alphabet = alphabet[::2]\
    \ + 'rvwxyz' + alphabet[1::2]\n    alphabet = alphabet[::2] + 'wxyz' + alphabet[1::2]\n\
    \    alphabet = alphabet[::2] + 'x' + alphabet[1::2]\n    alphabet = alphabet[::2]\
    \ + 'y' + alphabet[1::2]\n    alphabet = alphabet[::2] + 'z' + alphabet[1::2]\n\
    \    \n    return alphabet[(alphabet.index(s) + len(alphabet))%len(alphabet)]\n",
  "    alphabet = [chr(a+2) for a in range(26)]\n    alphabet.extend(alphabet)\n \
    \   rotated_alphabet = [chr(ord(x)+2) for x in alphabet]\n    rotated_alphabet.extend(rotated_alphabet)\n\
    \    return ''.join(rotated_alphabet[ord(x)] if x in alphabet else x for x in\
    \ s)\n", "    cipher = \"\"\n    for i in range(len(s)):\n        cipher_pos =\
    \ i % len(alphabet)\n        cipher += alphabet[cipher_pos]\n        alphabet[cipher_pos]\
    \ += alphabet[(cipher_pos+1) % len(alphabet)]\n    return cipher\n", "    alphabet\
    \ = string.ascii_lowercase\n    alphabet += string.ascii_uppercase\n    alphabet\
    \ += string.digits\n    alphabet = list(alphabet)\n    alphabet = [chr(ord(x)\
    \ + 2) for x in alphabet]\n    alphabet = [x for x in alphabet if x]\n    alphabet\
    \ = alphabet[:len(alphabet)-len(alphabet) % 2]\n    alphabet = alphabet + alphabet[:len(alphabet)]\n\
    \    alphabet = alphabet[::-1]\n    alphabet = list(alphabet)\n    alphabet =\
    \ alphabet[:len(alphabet) % 2]\n    return \"\".join(alphabet[alphabet.index(s):alphabet.index(s)\
    \ + len(s) - 1] for s in list(s))\n", "    alphabet = list('abcdefghijklmnopqrstuvwxyz')\n\
    \    alphabet = alphabet[::2] + alphabet[1::2]\n    \n    def rotate_function(input_string):\n\
    \        encrypted_string = input_string\n        for letter in alphabet:\n  \
    \          encrypted_string = ''\n            for index, char in enumerate(encrypted_string):\n\
    \                if letter in input_string:\n                    encrypted_string\
    \ += letter\n                elif letter not in input_string:\n              \
    \      encrypted_string += char\n                elif index == len(encrypted_string)\
    \ - 1:\n                    encrypted_string += letter\n                else:\n\
    \                    encrypted_string += char\n                    break\n   \
    \     return encrypted_string\n    return rotate_function(s)\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis isn't really what was asked. This code does not produce a\
    \ function that rotates input characters; it produces a function that produces\
    \ outputs of equal length as the input. That might be what was requested.\n<|/\
    \ c |>\n<| c |>\nHe just wanted to know how to rotate a character from lower case\
    \ to upper case. So, this would produce the same output as his. But yes, I agree,\
    \ your answer is more complete :)\n<|/ c |>\n<| c |>\nI updated my answer, I figured\
    \ out a way and posted it :)\n<|/ c |>\n<| c |>\nI don't think the OP wants this;\
    \ his desired output is the same length as the input, without rotation. Your code\
    \ produces strings that are the same length as the input, but with repeated characters.\
    \ That is not what was asked.\n<|/ c |>\n<| c |>\nOkay, sorry for the confusion,\
    \ I updated my answer again. This should do what you want, but it is ugly, and\
    \ I recommend using itertools instead.\n<|/ c |>\n<| a tags=python,string,python-3.x\
    \ |>\nOne way is to rotate the string and then zip it with a list of single-character\
    \ strings with an appropriate offset:\n<code>\nfrom itertools import cycle\ns\
    \ = 'asdfghjkl'\nl = cycle('abcdefghijklmnopqrstuvwxyz')\n''.join(s[i:i+2] for\
    \ i in range(len(s)//2))+''.join(s[i:i+2] for i in range(len(s)//2,0,-1))\nOut[15]:\
    \ 'aeghjklnopqrstuvwx'\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is good, but\
    \ I think OP wanted output to equal the length of the input.\n<|/ c |>\n<| a tags=python,string,python-3.x\
    \ |>\nI came across this question because I was trying to find a way to rotate\
    \ characters in the string and output the same length as the original string.\
    \ This answer ", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return ''.join(alphabet[alphabet.index(s)+2]\
    \ for s in s)\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rot_alphabet\
    \ = alphabet[:26] + alphabet[17:1:-1] + alphabet[6:26]\n    return ''.join(rot_alphabet[(alphabet.index(s)+rot_alphabet.index('a')-2)\
    \ % 26] for s in s)\n</code>\nThe alphabet rotations can be generalized using\
    \ itertools.cycle():\n<code>\nfrom itertools import cycle\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n",
  "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    shifted_alphabet\
    \ = list(alphabet)\n    shifted_alphabet.sort(key=lambda x: alphabet.index(x))\n\
    \    shifted_alphabet.reverse()\n    \n    encrypted = ''\n    for char in s:\n\
    \        encrypted += alphabet[alphabet.index(char) + alphabet.index(shifted_alphabet[alphabet.index(char)\
    \ % len(shifted_alphabet)])]\n        \n    return encrypted\n\n", "    \n   \
    \ s = s[:len(s)//2] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n\
    \    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2]\
    \ + s[len(s)//2:] + s[len(s)//2:]\n    s = s[:len(s)//2] + s[len(s)//2:] + s[len(s)",
  "    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    alphabet = alphabet[-2::-1]\n    alphabet = alphabet+alphabet\n    alphabet\
    \ = alphabet[::-1]\n    rotated_alphabet = ''\n    for char in alphabet:\n   \
    \     rotated_alphabet = rotated_alphabet+char\n    return rotated_alphabet+rotated_alphabet\n\
    encrypt = encrypt(\"\")\ndecrypt = encrypt(\"\")\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    alphabet = list(alphabet)\n    alphabet.reverse()\n    # convert str -> list\
    \ -> list to preserve original\n    s = list(s)\n    for i in range(len(s)):\n\
    \        # shift all letters down by two \n        if i >= len(alphabet):\n  \
    \          # don't shift if end of alphabet\n            alphabet.append(alphabet[-1])\n\
    \            alphabet = alphabet[:2]\n            alphabet.append(alphabet[-1])\n\
    \            s = s[0:len(alphabet)]\n        s[i] = alphabet[i]\n    return \"\
    \".join(s)\n</cell>\n<text>\nNow let's test the function!\n\n\n</text>\n<cell>\n\
    s = 'gfedcba'\ne = 'ghijklmn'\nassert(encrypt(s) == e)\n</cell>\n<text>\nNow let's\
    \ test another case:\n\n\n</text>\n<cell>\ns = 'dfedcbA'\ne = 'ghijklmn'\nassert(encrypt(s)\
    \ == e)\n</cell>\n<text>\nAnd finally a case where it fails:\n\n\n</text>\n<cell>\n\
    s = 'hgfedcba'\ne = 'ghijklmn'\nassert(encrypt(s) == e)\n</cell>\n<text>\nNext\
    \ let's define a function that decrypts:\n\n\n</text>\n<cell>", "    return \"\
    \".join(rot13(s))\n</cell>\n<cell>", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    rots = 2\n    shift = alphabet.find('z') + 1\n    return alphabet[alphabet.find(s)\
    \ % rots + shift]\n", "    assert is_string(s)\n    s = s.lower()\n    letters\
    \ = list(s)\n    letters.sort()\n    return ''.join(rotate_left(letters)) + ''.join(rotate_right(letters))\n\
    \n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    letters = list(alphabet)\n\
    \    n = len(alphabet)\n    result = ''\n\n    for i in range(len(s)):\n     \
    \   result += alphabet[(letters.index(s[i-1]) + letters.index(s[i]) + n) % n]\n\
    \n    return result\n</cell>\n<cell>\nencrypt('hi')\n</cell>\n<cell>\nencrypt('asdfghjkl')\n\
    </cell>\n<cell>\nencrypt('gf')\n</cell>\n<cell>\nencrypt('et')\n</cell>\n<cell>\n\
    encrypt('hi')\n</cell>\n<cell>\nencrypt('hi')\n</cell>\n<text>\nWrite a program\
    \ that takes a string as an argument and returns the string \n reversed. \nFor\
    \ example\n>>> reverse_string('hello')\n'olleh'\nWrite a program that takes a\
    \ string as an argument and returns the string \n rotated left by two positions.\
    \ \nFor example\n>>> rotl('hello',2)\n'ehlo'\nWrite a program that takes a string\
    \ as an argument and returns the string \n rotated right by two positions. \n\
    For example\n>>> rotr('hello',2)\n'helloa'\nWrite a program that takes a string\
    \ as an argument and returns the string \n reversed. \nFor example\n>>> reverse_string('hello')\n\
    'olleh'\nWrite a program that takes a string as an argument and returns the string\
    \ \n rotated left by two positions. \nFor example\n>>> rotl('hello',2)\n'ehlo'\n\
    Write a program that takes a string as an argument and returns the string \n rotated\
    \ right by two positions. \nFor example\n>>> rotr('hello',2)\n'helloa'\n\n</text>\n\
    <cell>", "    \n    # Convert the string into an ASCII list\n    ascii_str = [ord(c)\
    \ for c in s]\n    \n    # Loop through each letter in the string and rotate it\
    \ by 2\n    for i in range(0,len(ascii_str)):\n        ascii_str[i] = ascii_str[i]\
    \ + 2\n    \n    # Convert the ASCII list back to a string\n    rot_str = ''\n\
    \    for num in ascii_str:\n        rot_str += chr(num)\n    return rot_str\n\
    </cell>\n<text>\nNow test your encryption function by encrypting some strings.\
    \ Feel free to share your results with your classmates!\n\n\n</text>\n<cell>",
  "    alphabet = string.ascii_lowercase\n    return ''.join(alphabet[alphabet.index(letter)\
    \ + 2] for letter in s)\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n \
    \   cipher_alphabet = alphabet[::2] + alphabet[1::2]\n    cipher_letters = list(alphabet)\n\
    \    cipher_letters += alphabet[::2]\n    cipher_letters += alphabet[1::2]\n \
    \   \n    cipher = ''\n    \n    for i in range(len(s)):\n        if s[i] in alphabet:\n\
    \            i = alphabet.index(s[i])\n            i %= len(alphabet)\n      \
    \      i += len(alphabet) // 2\n            cipher += cipher_letters[i]\n    return\
    \ cipher\n\n", "    assert type(s) is str\n    # make sure we don't get any unicode\
    \ errors (this shouldn't really happen but just in case)\n    s = s.encode('ascii',\
    \ 'backslashreplace').decode('ascii')\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    shift_amount = 2\n    count = 0\n    newString = ''\n    for c in s:\n  \
    \      newString += alphabet[(alphabet.index(c) + shift_amount) % len(alphabet)]\n\
    \        count += 1\n        if count == len(s):\n            newString += alphabet[(alphabet.index(c)\
    \ + shift_amount) + shift_amount]\n            count = 0\n    return newString\n\
    </cell>\n<cell>", "    alphabet = string.ascii_lowercase\n    alphabet = alphabet[\
    \ : : -1]\n    rotated_alphabet = alphabet[2 : : 2]\n\n    return \"\".join(rotated_alphabet.index(letter)\
    \ for letter in s)\n\n", "    return \"\".join(\n        alphabet[(alphabet.index(letter)\
    \ + shift)%26]\n        for letter in s)\n", "    alphabet = rot13()\n    alpha\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    alpha2 = ['l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n    alpha3 = []\n    for i in alphabet:\n\
    \        if i in alpha2:\n            alpha3.append(i)\n        elif i in alpha:\n\
    \            alpha3.append(alpha3.pop(alpha.index(i)))\n        else:\n      \
    \      alpha3.append(i)\n    alpha3.sort()\n    return \"\".join(alpha3)\n</cell>\n\
    <cell>", "    s = ''.join([ chr(ord(s[i])+(i*2)%26) for i in range(len(s)) ])\n\
    \    return s\n</cell>\n<cell>", "    # Create a list that is indexed by the positions\
    \ where the letters shift\n    alphabet = list('abcdefghijklmnopqrstuvwxyz')\n\
    \    # Initialize an empty string to be returned\n    encrypted_str = ''\n   \
    \ \n    # Loop over the string and encrypt each character\n    for index, char\
    \ in enumerate(s):\n        enc_char = ''\n        # Shift the current letter\
    \ down by two\n        enc_char += alphabet[index - 1]\n        # Shift the current\
    \ letter up by two\n        enc_char += alphabet[index + 1]\n        encrypted_str\
    \ += enc_char\n    return encrypted_str\n\n", "    if len(s) <= 1: \n        return\
    \ s\n    return ''.join([s[i] + s[i+1] for i in range(len(s)//2)])\n</code>\n\
    The above code takes the string s and concatenates it with the string s[i+1] in\
    \ the loop. The string concatenation works by adding one letter at a time, starting\
    \ with s[i].\n<|/ a tags=python,algorithm |>\n<| c |>\nThe second code block produces\
    \ the wrong output when `len(s)` is odd.\n<|/ c |>\n<| c |>\n`len(s)` must be\
    \ odd because otherwise the algorithm cannot produce an even number of letters\
    \ in the resulting string.\n<|/ c |>\n<| c |>\nOh yeah, that should be `len(s)\
    \ % 2 == 1`.\n<|/ c |>\n<| c |>\nThanks, I fixed it.\n<|/ c |>\n<| c |>\nThat\
    \ second code block is quite clever! It should be noted that `encrypt` does _not_\
    \ produce an even number of letters in the resulting string if `len(s) % 2` returns\
    \ `0`.\n<|/ c |>\n<| a tags=python,algorithm |>\nI liked your answer, so I wrote\
    \ a more generalized form that works with any type of string and will work even\
    \ for strings with odd lengths. It will take any iterable.\n<code>", "    return\
    \ shift_alphabet(shift_alphabet(shift_alphabet(shift_alphabet(s)), 2), 2)\n\n",
  "    # Create a list by rotating the alphabet by 2 chars.\n    alphabet = list(rot13(s))\n\
    \n    # Create a list to store encrypted letters.\n    encrypted_letters = []\n\
    \n    for char in alphabet:\n        # Iterate over all the letters in the alphabet.\
    \ \n        for letter in alphabet:\n            # If the letter is the same as\
    \ the letter next to it,\n            # shift the letter down by two places. \n\
    \            if letter == letter + letter:\n                encrypted_letters.append(letter\
    \ - 2)\n            # If the letter is not the same as the letter next to it,\n\
    \            # add the letter to the encrypted string.\n            else:\n  \
    \              encrypted_letters.append(letter)\n\n    return ''.join(encrypted_letters)\n\
    \n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypt_dict = {c: c for\
    \ c in alphabet}\n    return ''.join([encrypt_dict[s] for s in s])\n\n", "   \
    \ return ''.join(encrypt(letter) for letter in s)\n\n", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    if len(s) not in [26, 27]:\n        raise ValueError('Length of string must\
    \ be 26 or 27.')\n\n    if s == '':\n        return ''\n    elif len(s) == 1:\n\
    \        return alphabet[0]\n\n    alphabet = alphabet[:27]\n    alphabet2 = alphabet[27:]\
    \ + alphabet[:26]\n    alphabet3 = alphabet[26:] + alphabet[27:] + alphabet[:26]\n\
    \    alphabet4 = alphabet[27:] + alphabet[26:] + alphabet[27:] + alphabet[:26]\n\
    \    alphabet5 = alphabet[27:] + alphabet[26:] + alphabet[27:] + alphabet[26:]\
    \ + alphabet[:26]\n    alphabet6 = alphabet[27:] + alphabet[26:] + alphabet[27:]\
    \ + alphabet[26:] + alphabet[27:]\n    alphabet7 = alphabet[27:] + alphabet[26:]\
    \ + alphabet[27:] + alphabet[26:] + alphabet[27:] + alphabet[26:]\n\n    result\
    \ = alphabet5[:len(s)] + alphabet4[len(s):] + alphabet3[len(s):] + alphabet2[len(s):]\n\
    \    result = alphabet6[:len(s)] + alphabet5[len(s):] + alphabet4[len(s):] + alphabet3[len(s):]\
    \ + alphabet2[len(s):]\n    result = alphabet7[:len(s)] + alphabet6[len(s):] +\
    \ alphabet5[len(s):] + alphabet4[len(s):] + alphabet3[len(s):]\n    result = alphabet[:len(s)]\
    \ + alphabet7[len(s):] + alphabet6[len(s):] + alphabet5[len(s):] + alphabet4[len(s):]\n\
    \    result = alphabet2[:len(s)] + alphabet7[len(s):] + alphabet6[len(s):] + alphabet5[len(s):]\
    \ + alphabet4[len(s):]\n    result = alphabet3[:len(s)] + alphabet7[len(s):] +\
    \ alphabet6[len(s):] + alphabet5[len(s):] + alphabet4[len(s):]\n    result = alphabet4[:len(s)]\
    \ + alphabet7[len(s):] + alphabet6[len(s):] + alphabet5[len(s):] + alphabet4[len(s):]\n\
    \    result = alphabet[:len(s)] + alphabet7[len(s):] + alphabet6[len(s):] + alphabet5[len(s):]\
    \ + alphabet4[len(s):]\n    result = alphabet2[:len(s)] + alphabet7[len(s):] +\
    \ alphabet6[len(s):] + alphabet5[len(s):] + alphabet4[len(s):]\n    result = alphabet3[:len(s)]\
    \ + alphabet7[len(s):] + alphabet6[len(s):] + alphabet5[len(s):] + alphabet4[len(s):]\n\
    \    result = alphabet4[:len(s)] + alphabet7[len(s):] + alphabet6[len(s):] + alphabet5[len(s):]\
    \ + alphabet4[len(s):]\n    result = alphabet[:len(s)] + alphabet7[len(s):] + ",
  "    letters = [c for c in s]\n    rotated_letters = list(map(lambda l: alphabet[l],\
    \ letters))\n    return ''.join(rotated_letters)\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
