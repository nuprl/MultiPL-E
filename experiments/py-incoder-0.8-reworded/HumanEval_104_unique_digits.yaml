name: HumanEval_104_unique_digits
language: py
prompt: "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n\
  \    \"\"\"Given a list of positive integers x. return a sorted list of all \n \
  \   elements that hasn't any even digit.\n\n    Note: Returned list should be sorted\
  \ in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422,\
  \ 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n  \
  \  \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([15, 33, 1422, 1]) == [1, 15,\
  \ 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345,\
  \ 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\
  \ndef test_check():\n    check(unique_digits)\n\ntest_check()\n"
completions: ["    digits = [int(x) for x in str(x)]\n    unique_digits_set = set(digits)\n\
    \    return [x for x, y in sorted(zip(digits, digits)) if y % 2 == 0 and x not\
    \ in unique_digits_set]\n\n", "    x = sorted(x)\n    even_list = []\n    odd_list\
    \ = []\n    for elem in x:\n        if elem % 2 == 0:\n            even_list.append(elem)\n\
    \        else:\n            odd_list.append(elem)\n    \n    return even_list+odd_list\n",
  "    digit_dict = defaultdict(int)\n    for num in x:\n        digit_dict[num] +=\
    \ 1\n    return sorted(list(filter(lambda x: x[0]%2 != 0, digit_dict.items())))\n",
  "    digit_count = {i: 0 for i in x}\n    for num in x:\n        digit_count[num]\
    \ += 1\n    sorted_digit_counts = sorted(digit_count.items(), key=lambda x:x[0])\n\
    \    return [item for item in sorted_digit_counts if item[1] % 2 == 0]\n", " \
    \   digits = defaultdict(int)\n    for num in x:\n        digits[num] += 1\n \
    \   \n    return [k for k, v in sorted(digits.items(), key = lambda x: -x[1])\
    \ if v % 2 == 0]\n</cell>\n<text>\nSolution:\nWe use Python's OrderedDict to help\
    \ us solve the problem.\n\nWe use it to store the counts of the numbers. Then\
    \ we sort the numbers by the value of counts, so that we can easily get the unique\
    \ numbers by taking the key of the OrderedDict. Finally, we filter the numbers\
    \ that have even number of digits and return them.\n\nThe function takes advantage\
    \ of Python's dictionary comprehension to help us write this succinctly.\n\n\n\
    </text>\n<cell>\nfrom collections import OrderedDict # type: ignore\n", "    \n\
    \    n = len(x)\n    ans = []\n    for i in range(n):\n        digit = x[i]\n\
    \        found = False\n        for j in range(n): \n            if x[j] == digit:\n\
    \                found = True\n                break\n        if not found:\n\
    \            ans.append(digit)\n    \n    ans.sort()\n    return ans\n", "   \
    \ digits: Set[int] = set()\n    return [x for x in x if x not in digits or x %\
    \ 2 == 0]\n\n", "    x.sort(reverse=True)\n    \n    digits = []\n    \n    for\
    \ x in x:\n        if x % 2 == 0:\n            continue\n        for y in digits:\n\
    \            if y % 2 == 0 and y == x:\n                continue\n           \
    \ if y % 2 != 0 and y == x*x:\n                break\n            else:\n    \
    \            digits.append(x)\n                break\n    return digits\n    ",
  "    \n    nums = [i for i in x]\n    sorted_nums = sorted(nums)\n    \n    # Remove\
    \ all even digit\n    for i in range(len(nums)):\n        if nums[i] % 2 == 0:\n\
    \            nums.remove(nums[i])\n\n    nums = [x for x in nums if x]\n\n   \
    \ return nums\n", "    if len(x) == 0:\n        return []\n\n    dig_list = []\n\
    \    for x in x:\n        if x % 2 == 0 and x != 0:\n            dig_list.append(x)\n\
    \    \n    dig_list = sorted(dig_list)\n\n    if len(dig_list) <= 1:\n       \
    \ return []\n    \n    return dig_list\n", "    return sorted(filter(lambda y:\
    \ sum(map(int, str(y))) % 2 != 0, x))\n\n", "    digits_set = set(x) # use set\
    \ to get rid of repeated digits\n    digits_set.remove(0)\n    digits_set.remove(min(digits_set))\n\
    \n    return sorted(list(digits_set))\n</cell>\n<cell>\n\"\"\"\nDifficulty Level\
    \ 2\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\"\"\"\n", "    \n    \n\
    \    odd_list = []\n    even_digit_list = []\n    \n    for i in x:\n        if\
    \ i % 2 == 0:\n            even_digit_list.append(i)\n        else:\n        \
    \    odd_list.append(i)\n    \n    odd_list.sort()\n    even_digit_list.sort()\n\
    \    \n    return odd_list + even_digit_list\n    \n    ", "    digits = set()\n\
    \    for y in x:\n        if y % 2 == 0 and y not in digits:\n            digits.add(y)\n\
    \    return list(digits)\n", "    digit_dict = {}\n    for i in x:\n        if\
    \ i not in digit_dict:\n            digit_dict[i] = 1\n        else:\n       \
    \     digit_dict[i] += 1\n\n    res_arr = []\n    for k,v in digit_dict.items():\n\
    \        if v % 2 == 0:\n            res_arr.append(k)\n\n    return sorted(res_arr)\n",
  "    ans = []\n    for n in x:\n        while n % 2 == 0:\n            n //= 2\n\
    \        if n not in ans:\n            ans.append(n)\n    return ans\n", "   \
    \ \n    result = []\n    for i in x:\n        digit_counter = 0\n        \n  \
    \      while int(str(i)) % 2 == 0:\n            i = i // 2\n            digit_counter\
    \ += 1\n            \n        if digit_counter != 0:\n            result.append(i)\n\
    \    \n    result.sort()\n    \n    return result\n</cell>\n<cell>\nassert unique_digits([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\nassert unique_digits([152, 323, 1422, 10]) ==\
    \ []\n</cell>\n<cell>", "    digits = [x for x in x if x % 2 == 0]\n    digits_set\
    \ = set()\n    digits_list = []\n    \n    for digit in digits:\n        if digit\
    \ in digits_set:\n            continue\n        digits_list.append(digit)\n  \
    \      digits_set.add(digit)\n    \n    return sorted(digits_list)\n", "    digits\
    \ = [x for x in x if x % 2 == 0]\n    if len(digits) == 0:\n        return []\n\
    \    else:\n        sorted_digits = sorted(digits)\n        unique = []\n    \
    \    \n        for digit in sorted_digits:\n            if digit not in unique:\n\
    \                unique.append(digit)\n        return unique\n", "    \n    #\
    \ Your code here\n    \n    s = set()\n    for i in x:\n        while i in s:\n\
    \            i = (i*10) + 100\n        s.add(i)\n    return sorted(list(s))\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
