name: HumanEval_55_fib
language: py
prompt: "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>>\
  \ fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1)\
  \ == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert\
  \ candidate(12) == 144\n\ndef test_check():\n    check(fib)\n\ntest_check()\n"
completions: ["    return 0 if n < 2 else fib(n-1) + fib(n-2)\n", "    return fib2(n,\
    \ 0, 1)\n\n", "    if n < 2:\n        return 1\n    return fib(n-2) + fib(n-1)\n",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n\
    \ < 2:\n        return n\n    else:\n        return fib(n-2) + fib(n-1)\n\n",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return\
    \ fib(n - 2) + fib(n - 1)\n\n\n@deprecated_alias(fib, \"__next__\")", "    if\
    \ n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n", "    assert\
    \ n >= 0 and n <= 10\n    if n == 0:\n        return 0\n    elif n == 1:\n   \
    \     return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n", "    if\
    \ n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n", "    if n in (0,\
    \ 1):\n        return 1\n    return fib(n-2) + fib(n-1)\n\n", "    if n < 2:\n\
    \        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n == 0:\n    \
    \    return 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) + fib(n\
    \ - 2)\n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return\
    \ 1\n    return fib(n - 1) + fib(n - 2)\n", "    if n < 2:\n        return n\n\
    \    return fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n        return n\n    return\
    \ fib(n-2) + fib(n-1)\n</cell>\n<text>\nWe will use the decorator @timeit for\
    \ a quick measurement of the execution time of a function.\n\n\n</text>\n<cell>\n\
    @timeit", "    if n <= 2:\n        return 1\n    return fib(n-2) + fib(n-1)\n",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n\n@timeit('fibonacci_iter')",
  "    return fib_rec(n, 1, 1, 1)\n\n\n@njit", "    assert n >= 0\n    if n == 1:\n\
    \        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n     \
    \   return n\n    return fib(n-1) + fib(n-2)\n", "    fibs = {0: 0, 1: 1}\n  \
    \  for _ in range(n-2):\n        fibs[_] = fibs[_] + fibs[_+1]\n    return fibs[n]\n\
    \n", "    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    a, b\
    \ = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n",
  "    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "   \
    \ if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return\
    \ fib(n-1) + fib(n-2)\n\n", "    if n == 0:\n        return 0\n    elif n == 1:\n\
    \        return 1\n    return fib(n - 1) + fib(n - 2)\n", "    if n in (0, 1):\n\
    \        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n \
    \       return n\n    else:\n        return fib(n-1) + fib(n-2)\n", "    if n\
    \ <= 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n\
    \ < 0:\n        raise ValueError(\"Argument 'n' must be >= 0.\")\n    elif n ==\
    \ 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fib(n -\
    \ 1) + fib(n - 2)\n\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return\
    \ fib(n - 1) + fib(n - 2)\n\n\n@njit", "    return n if n < 3 else fib(n-2) +\
    \ fib(n-1)\n", "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", " \
    \   return fib2(n - 1) + fib2(n - 2)\n\n\n@memoize", "    return fib2(n - 1) +\
    \ fib2(n - 2)\n\n", "    if n == 0:\n        return 0\n    elif n == 1:\n    \
    \    return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n", "    if\
    \ n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n\n", "    return fib1(n-1)\
    \ + fib2(n-2)\n</cell>\n<text>\nHow do we know it works correctly?\n\n\n</text>\n\
    <cell>\nfib(10)\n</cell>\n<cell>\n%timeit fib(10)\n</cell>\n<cell>\n%timeit fib(10000)\n\
    </cell>\n<text>\nExercise: Fibonacci Numbers\nWrite a program to find the nth\
    \ fibonacci number given a natural number n.\nExample:\nGiven n = 3, your program\
    \ should return 3.\nGiven n = 5, your program should return 8.\nHint: Use recursion.\n\
    \n\n</text>\n<cell>", "    if n <= 1:\n        return n\n    return fib(n - 1)\
    \ + fib(n - 2)\n\n", "    if n < 0:\n        raise ValueError(\"fibonacci numbers\
    \ are limited to int values -1 and 1\")\n    if n == 0:\n        return 0\n  \
    \  elif n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\n", "    a,\
    \ b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n",
  "    return fib(n-2) + fib(n-1)\n", "    if n < 2:\n        return n\n    else:\n\
    \        return fib(n-1) + fib(n-2)\n\n", "    if n in (0, 1):\n        return\
    \ n\n    else:\n        return fib(n-1) + fib(n-2)\n\n", "    return fib_n(n)\
    \ // 2\n\n", "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n <= 1:\n        return n\n    return fib(n - 2) + fib(n - 1)\n\n",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n\
    \ <= 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n\n@curry", " \
    \   if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return\
    \ fib(n - 1) + fib(n - 2)\n\n\n@njit", "    if n == 0:\n        return 0\n   \
    \ elif n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n\
    \ - 2)\n\n", "    return n if n < 2 else fib(n-2) + fib(n-1)\n\n@register_action('fib_step')\n\
    @register_action('fib_step_start')\n@register_action('fib_step_end')\n@register_action('fib_step_middle')",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    return\
    \ fib1(n)\n\n", "    if n <= 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\
    \n", "    return fib_cache[n - 1] if n in fib_cache else fib_cache[n] = _fib(n)\n\
    \n", "    if n <= 2:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n",
  "    # return 1 if n <= 1 \n    if n <= 1: \n        return n\n    # return fib(n\
    \ - 1) + fib(n - 2)\n    return fib(n-2) + fib(n-1)\n", "    if n < 2:\n     \
    \   return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n in (0, 1):\n\
    \        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 0:\n \
    \       return fib(-n)\n\n    if n == 0:\n        return 0\n    elif n == 1:\n\
    \        return 1\n    else:\n        p, q = fib(n-1), fib(n-2)\n        return\
    \ q+p\n", "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n</cell>\n\
    <cell>", "    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n        return n\n\
    \    else:\n        return fib(n-2) + fib(n-1)\n", "    return fib_rec(n, 0, 0,\
    \ 1)\n\n@profile", "    assert n > 0\n    if n == 1:\n        return 1\n    if\
    \ n == 2:\n        return 2\n    return fib(n-2) + fib(n-1)\n\n", "    if n <\
    \ 2:\n        return n\n    return fib(n-1) + fib(n-2)\n", "    if n < 2:\n  \
    \      return n\n    return fib(n-2) + fib(n-1)\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-2) + fib(n-1)\n</cell>\n<text>\nFibonacci numbers (continued)\n\
    \n</text>\n<cell>", "    if n == 0:\n        return 0\n    if n == 1:\n      \
    \  return 1\n    return fib(n - 2) + fib(n - 1)\n\n", "    if n < 2:\n       \
    \ return n\n    return fib(n-2) + fib(n-1)\n", "    # assert is_natural(n)\n \
    \   if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    assert\
    \ n > 1\n    if n in [0, 1]:\n        return 1\n    else:\n        return fib(n-1)\
    \ + fib(n-2)\n\n", "    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n\
    \    return a\n\n", "    a, b = 0, 1\n    while a < n:\n        a, b = b, a+b\n\
    \    return b\n\n", "    if n < 0:\n        raise ValueError('n < 0')\n    if\
    \ n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n\
    \ - 1) + fib(n - 2)\n\n", "    if n == 0:\n        return 0\n    elif n == 1:\n\
    \        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n \
    \       return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n      \
    \  return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    return fib_recursion(n)\n",
  "    if n < 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n\
    \ == 2:\n        return 1\n    else:\n        return fib(n-2) + fib(n-1)\n\n",
  "    # we already know that n > 0\n    # and n >= 1\n    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    else:\n        prev, cur = 1, 0\n\
    \        while cur < n:\n            prev, cur = cur, prev + cur\n        return\
    \ cur\n\n\n@cached", "    if n == 0:\n        return 0\n    elif n == 1:\n   \
    \     return 1\n    return fib(n - 1) + fib(n - 2)\n\n", "    # check condition\n\
    \    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    elif\
    \ n >= 3:\n        return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n     \
    \   return n\n    else:\n        return fib(n-2) + fib(n-1)\n\n", "    if n <\
    \ 2:\n        return n\n    return fib(n-2) + fib(n-1)\n", "    a, b = 1, 0\n\
    \    while b < n:\n        a, b = b, a + b\n    return a\n\n", "    a, b = 0,\
    \ 1\n    for i in range(n):\n        a, b = b, a+b\n    return a\n\n\n@timefunc(1)",
  "    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "   \
    \ if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n - 2) + fib(n - 1)\n\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n",
  "    # implement the function here\n    raise NotImplementedError\n</cell>\n<cell>",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return\
    \ fib(n-2) + fib(n-1)\n", "    a, b = 1, 1\n    for _ in range(n):\n        a,\
    \ b = b, a+b\n    return b\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis would not\
    \ take into account the time taken by the calculation of each number. Also, there\
    \ is not need to store the results in a list since you can calculate them directly\
    \ from the input value. Also, this would take more memory as the numbers would\
    \ have to be stored as float.\n<|/ c |>\n<| a |>\nYou can use the math library\
    \ for this. \n<code>\nimport math\n", "    if n < 2:\n        return n\n    return\
    \ fib(n-2) + fib(n-1)\n\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    if n <= 2:\n        return 1\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n   \
    \ return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n        return n\n    return\
    \ fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n        return n\n    return fib(n-2)\
    \ + fib(n-1)\n\n", "    if n <= 1:\n        return n\n    return fib(n-2) + fib(n-1)\n",
  "    if n <= 0:\n        return 0\n    elif n == 1 or n == 0:\n        return 1\n\
    \    else:\n        return fib(n-2) + fib(n-1)\n", "    if n < 2:\n        return\
    \ 1\n    else:\n        return fib(n-2) + fib(n-1)\n", "    assert n > 0\n   \
    \ if n == 1 or n == 0:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\
    \n", "    return fib_cache[n] if n in fib_cache else fib_cache[n - 1] + fib_cache[n\
    \ - 2]\n\n\n@timeit", "    if n < 0:\n        return -1\n    elif n <= 2:\n  \
    \      return 1\n    else:\n        return fib(n-2) + fib(n-1)\n", "    a, b =\
    \ 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n", "  \
    \  # we may use cached results to accelerate the running process\n    if n <=\
    \ 1:\n        return 1\n    elif n in fib_cache:\n        return fib_cache[n]\n\
    \    else:\n        result = fib(n-1) + fib(n-2)\n        fib_cache[n] = result\n\
    \        return result\n\nfib_cache = {}\n", "    if n in (0, 1): return n\n \
    \   return fib(n-1) + fib(n-2)\n", "    if n < 2:\n        return n\n    return\
    \ fib(n-1) + fib(n-2)\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    if n == 0:\n        return 0\n    elif n == 1:\n     \
    \   return 1\n    else:\n        return fib(n-1) + fib(n-2)\n", "    return fib2(n,\
    \ 1, 0, 1)\n\n", "    return fib1(n) + fib2(n)\n\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-1) + fib(n-2)\n</cell>\n<cell>", "    return fibonacci(n)[0]\n\
    \n", "    a, b = 1, 1\n    while n > 1:\n        a, b = b, a + b\n        n -=\
    \ 1\n    return a\n\n", "    return fib_cache[n] if n in fib_cache else fib_cache[n]\
    \ = fib(n - 2) + fib(n - 1)\n\n", "    if n <= 1:\n        return n\n    return\
    \ fib(n - 1) + fib(n - 2)\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n</cell>\n<cell>\n%timeit fib(50)\n</cell>\n<cell>\n%prun fib(50)\n\
    </cell>\n<text>\nWe see that the execution time is about 10x faster than the previous\
    \ code.\n\n\n</text>\n<text>\nA faster implementation\n\n</text>\n<text>\nIt is\
    \ possible to perform the task without recursion, using dynamic programming.\n\
    \n\n</text>\n<cell>\nfrom typing import Tuple\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-2) + fib(n-1)\n", "    a, b = 0, 1\n    for _ in range(n\
    \ - 1):\n        a, b = b, a + b\n    return a\n\n", "    if n <= 1:\n       \
    \ return n\n    return fib(n-1) + fib(n-2)\n</cell>\n<text>\nLet's check our implementation\
    \ with some values:\n\n\n</text>\n<cell>\nfib(10)\n</cell>\n<cell>\nfib(1)\n</cell>\n\
    <cell>\nfib(8)\n</cell>\n<text>\nAnd with more:\n\n\n</text>\n<cell>\n%timeit\
    \ fib(10)\n</cell>\n<cell>\n%timeit fib(1)\n</cell>\n<cell>\n%timeit fib(8)\n\
    </cell>\n<text>\nThe results are as expected: each call of fib() creates a new\
    \ number - it doesn\u2019t re-use any previous results. This is called memoization.\n\
    \nAnother approach is to cache the results of all calls to fib() so that you only\
    \ need to compute them once. For example, you can cache the result of fib(10)\
    \ in a dict like this:\n\n\n</text>\n<cell>\ncache = {0: 0, 1: 1}\n</cell>\n<text>\n\
    Then you can change your implementation:\n\n\n</text>\n<cell>", "    a, b = 0,\
    \ 1\n    while n > 0:\n        a, b = b, a+b\n        n -= 1\n    return a\n",
  "    if n in (0, 1):\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\n\
    \n", "    if n < 0:\n        raise ValueError(\"Argument must be non-negative\"\
    )\n    if n < 2:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", " \
    \   if n < 2:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", "  \
    \  return n if n < 3 else fib(n - 1) + fib(n - 2)\n", "    if n < 2:\n       \
    \ return n\n    return fib(n-2) + fib(n-1)\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\n\n\
    @test_utils.unittest_run_loop\n@test_utils.unittest_skip('bug in Python version')",
  "    if n < 0:\n        raise ValueError(\"n must be greater than 0\")\n    if n\
    \ == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fib(n\
    \ - 1) + fib(n - 2)\n\n", "    if n < 2:\n        return n\n    return fib(n -\
    \ 1) + fib(n - 2)\n\n", "    if n < 0:\n        return fib(-n)\n\n    if n ==\
    \ 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n\
    \        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n == 0:\n\
    \        return 0\n    elif n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\
    \n", "    # pylint: disable=redefined-outer-name\n\n    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
  "    return fib_recursion(n, memo_fib_list)\n\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-1) + fib(n-2)\n</cell>\n<cell>\n%timeit fib(10)\n</cell>\n\
    <cell>\n%timeit fib(1)\n</cell>\n<cell>\n%timeit fib(8)\n</cell>\n<text>\nRecursive\
    \ Function Example\n\n</text>\n<cell>", "    if n < 2:\n        return n\n   \
    \ return fib(n-2) + fib(n-1)\n\n", "    return fib1(n)\n", "    if n < 2:\n  \
    \      return n\n    else:\n        return fib(n-1) + fib(n-2)\n", "    if n <=\
    \ 2:\n        return n\n    return fib(n-1) + fib(n-2)\n", "    if n < 2:\n  \
    \      return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n   \
    \     return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 0:\n    \
    \    return 0\n    elif n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n",
  "    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n</cell>\n<cell>\n\
    fib(10)\n</cell>\n<cell>", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n</cell>\n<cell>\n@test", "    if n <= 2:\n        return n\n   \
    \ return fib(n-2) + fib(n-1)\n\n", "    if n <= 0:\n        return n\n    return\
    \ fib(n-2) + fib(n-1)\n", "    if n <= 2:\n        return n\n    return fib(n\
    \ - 1) + fib(n - 2)\n\n", "    a, b = 0, 1\n    while a < n:\n        a, b = b,\
    \ a + b\n    return a\n\n\n@with_setup(setup_sift, teardown_sift)\n@with_setup(setup_pytest,\
    \ teardown_pytest)\n@with_setup(setup_pyflakes, teardown_pyflakes)\n@with_setup(setup_isort,\
    \ teardown_isort)\n@with_setup(setup_autopep8, teardown_autopep8)", "    assert\
    \ n >= 0, \"Please enter an int >= 0\"\n    if n in [0, 1]:\n        return 1\n\
    \    return fib(n-1) + fib(n-2)\n\n", "    if n in (0, 1):\n        return n\n\
    \    return fib(n-1) + fib(n-2)\n\n", "    if n == 0:\n        return 0\n    elif\
    \ n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n</cell>\n\
    <cell>\n%timeit fib(10)\n</cell>\n<cell>\n%timeit fib(10)\n</cell>\n<text>\nRecursions\n\
    \n</text>\n<text>\nBase cases and recursion are two common ways of recursion.\
    \ They work essentially the same way as loops, but with different syntax:\n\n\n\
    </text>\n<cell>", "    if n < 0:\n        raise IndexError('fib arguement must\
    \ be positive')\n    elif n == 0:\n        return 0\n    elif n == 1:\n      \
    \  return 1\n    return fib(n-1) + fib(n-2)\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n</cell>\n<cell>",
  "    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "  \
    \  if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return\
    \ fib(n - 1) + fib(n - 2)\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n</cell>\n<text>\nThis implementation is very inefficient:\n\nit\
    \ calculates fib(2) twice.\nit calls itself twice for calculating fib(2)\n\nWe\
    \ can do better by memoizing the result. Memoization is done using a dictionary\
    \ in the code below - it saves the last two values it calculated for a certain\
    \ input:\n\n\n</text>\n<cell>", "    a, b = 0, 1\n    for _ in range(n):\n   \
    \     a, b = b, a+b\n    return a\n", "    if n < 2:\n        return n\n    return\
    \ fib(n-1) + fib(n-2)\n</cell>\n<cell>\n%timeit fib(20)\n</cell>\n<cell>\n%timeit\
    \ fib(500)\n</cell>\n<cell>\nfib(0)\n</cell>\n<cell>\nfib(8)\n</cell>\n<cell>\n\
    fib(20)\n</cell>\n<text>\nRecursion is often used as an alternative to iteration.\
    \ In fact, we can simulate recursion with iteration. Here we simulate Fibonacci\
    \ with iteration.\n\n\n</text>\n<cell>", "    a, b = 0, 1\n    for i in range(n):\n\
    \        a, b = b, a + b\n    return a\n\n", "    if n <= 2:\n        return n\n\
    \    return fib(n-2) + fib(n-1)\n", "    if n in (0, 1):\n        return n\n \
    \   else:\n        return fib(n-1) + fib(n-2)\n\n", "    if n <= 0:\n        return\
    \ 0\n    elif n <= 2:\n        return 1\n    else:\n        return fib(n - 1)\
    \ + fib(n - 2)\n\n", "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n \
    \   else:\n        return fib(n - 1) + fib(n - 2)\n\n\n@given(integers(min_value=-2**31,\
    \ max_value=2**31-1))", "    if n == 0:\n        return 0\n    elif n == 1:\n\
    \        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n", " \
    \   if n < 0:\n        return 0\n    elif n == 0:\n        return 1\n    else:\n\
    \        return fib(n - 1) + fib(n - 2)\n", "    return fib(n-1) + fib(n-2)\n\n",
  "    if n in (0, 1):\n        return n\n\n    return fib(n-1) + fib(n-2)\n\n", " \
    \   return fibs(1, n)\n\n", "    if n < 2:\n        return n\n    return fib(n-2)\
    \ + fib(n-1)\n", "    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n\
    </cell>\n<cell>\nfib(10**8)\n</cell>\n<cell>\n%time fib(10**8)\n</cell>\n<cell>\n\
    %time fib(10**8)\n</cell>\n<cell>\n%time fib(10**8)\n</cell>\n<text>\nComputing\
    \ the square of a number using recursion can be faster than the exponentiation\
    \ operator. But it's also very easy to write code that's not as obvious and easy\
    \ to understand.\n\nNone Recursion\n\n\n\n</text>\n<text>\nLet's practice computing\
    \ the square of a number. Implement a function that computes $n^2$.\n\n\n</text>\n\
    <cell>\nfrom math import sqrt\n", "    if n <= 2:\n        return n\n    return\
    \ fib(n-2) + fib(n-1)\n\n", "    if n <= 1:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n\n</cell>\n<text>\n\u0417\u0430\u0434\u0430\u0447\u0430. \u0421\u043B\
    \u043E\u0436\u0438\u0442\u044C \u0432\u0435\u043B\u0438\u0447\u0438\u043D\u0443\
    \ \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439 \u0444\u0430\u043A\u0442\
    \u043E\u0440\u0438\u0430\u043B\u044C\u043D\u043E\u0441\u0442\u0438 \u0447\u0438\
    \u0441\u0435\u043B \u043E\u0442 1 \u0434\u043E 10. \u041D\u0435\u043E\u0431\u0445\
    \u043E\u0434\u0438\u043C\u043E \u043F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\
    \u044C, \u0447\u0442\u043E \u043F\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043B\
    \u0435\u043D\u0438\u0435 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\
    \ \u0444\u0430\u043A\u0442\u043E\u0440\u0438\u0430\u043B\u044C\u043D\u043E\u0441\
    \u0442\u0438 \u0447\u0438\u0441\u0435\u043B \u043E\u0442 1 \u0434\u043E 10 \u0438\
    \ \u043F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C, \u0447\u0442\u043E \u0432\
    \u0441\u0435 \u0442\u043E\u0447\u043D\u043E \u043B\u0438 \u044D\u0442\u043E \u0441\
    \u043B\u043E\u0436\u043D\u0430\u044F \u043F\u0440\u043E\u0431\u043B\u0435\u043C\
    \u0430.\n\n\n</text>\n<cell>", "    if n < 2:\n        return n\n    else:\n \
    \       return fib(n-1) + fib(n-2)\n\n", "    a, b = 0, 1\n    for _ in range(n-1):\n\
    \        a, b = b, a+b\n    return a\n", "    if n == 0:\n        return 0\n \
    \   elif n == 1:\n        return 1\n    return fib(n-2) + fib(n-1)\n", "    if\
    \ n < 2:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)\n",
  "    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a+b\n    return a\n\n",
  "    return fib_rec(n, n, n)\n\n@memoized", "    if n <= 2:\n        return n\n\
    \    return fib(n-2) + fib(n-1)\n", "    if n < 2:\n        return n\n    return\
    \ fib(n-2) + fib(n-1)\n", "    if n < 2:\n        return n\n    return fib(n -\
    \ 2) + fib(n - 1)\n\n", "    if n < 2:\n        return n\n    return fib(n - 1)\
    \ + fib(n - 2)\n\n", "    if n < 2:\n        return 1\n    return fib(n - 1) +\
    \ fib(n - 2)\n\n@lru_cache(maxsize=1000)", "    if n <= 2:\n        return n\n\
    \    return fib(n-1) + fib(n-2)\n\n", "    return fib2(n, 0, 1)\n\n", "    if\
    \ n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    a, b\
    \ = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return b\n\n", "    if\
    \ n <= 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\
    \n", "    assert n >= 0\n    if n == 0:\n        return 0\n    elif n == 1:\n\
    \        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n", "    if\
    \ n <= 0:\n        return 0\n    elif n <= 2:\n        return 1\n    else:\n \
    \       return fib(n - 1) + fib(n - 2)\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
