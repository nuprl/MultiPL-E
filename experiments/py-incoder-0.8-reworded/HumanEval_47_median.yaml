name: HumanEval_47_median
language: py
prompt: "from typing import List\n\ndef median(l: List[int]) -> float:\n    \"\"\"\
  Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n\
  \    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert\
  \ candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n\
  \    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7])\
  \ == 7\n\ndef test_check():\n    check(median)\n\ntest_check()\n"
completions: ["    l = sorted(l)\n    if len(l) % 2 == 0:\n        return l[len(l)//2]\n\
    \    else:\n        return (l[len(l)//2] + l[len(l)//2-1]) / 2\n</code>\n<|/ a\
    \ tags=median,sorting,python |>\n<| c |>\nI guess it isn't efficient to sort an\
    \ array with 6 elements, for 3 elements that could be done in O(1)\n<|/ c |>\n\
    <| c |>\n`sorted(l)` is sorting in-place, why would that be O(1)?\n<|/ c |>\n\
    <| c |>\n`sorted(l)` is O(1) because `l` is a list. This is a pure O(1) algorithm,\
    \ so sorting a list that has 6 elements should be O(1).\n<|/ c |>\n<| c |>\n`l`\
    \ isn't a list, `l` is a python builtin function returning a list\n<|/ c |>\n\
    <| c |>\nAh, yes, I misspoke. Of course it is.\n<|/ c |>\n<| a tags=median,sorting,python\
    \ |>\n<code>\nl = [3, 1, 2, 4, 5]\n</code>\nsort l first and then find median\
    \ by dividing array into even and odd parts\n<code>\nl.sort()\nprint(l[int(len(l)/2)])\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThe question is asking for a median of *all*\
    \ of the elements in the list.\n<|/ c |>\n<| a dscore=4 |>\nThe easiest solution\
    \ to find the median of a list is:\n<code>", "    l1 = sorted(l)\n    l2 = sorted(l1)\n\
    \    return (l1[len(l1) // 2 - 1] + l2[len(l2) // 2 - 1]) // 2\n\n", "    return\
    \ sorted(l)[0]\n", "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return\
    \ l[(len(l)/2)-1]\n    else:\n        a = l[len(l)/2]\n        b = l[len(l)/2-1]\n\
    \        return (a + b)/2.0\n", "    return sorted(l)[len(l) // 2] if l else 0.0\n\
    \n", "    l = sorted(l)\n    return l[len(l)//2] if l else 0\n", "    l = sorted(l)\n\
    \    if l and l[0] >= 0:\n        return l[len(l) // 2]\n    else:\n        return\
    \ None\n", "    l = sorted(l)\n    if len(l) % 2 == 0:\n        return l[(len(l)\
    \ // 2) - 1]\n    else:\n        middle = len(l) // 2\n        return (l[middle]\
    \ + l[middle - 1]) / 2\n\n", "    even = filter(lambda x: x % 2 == 0, l)\n   \
    \ odd = filter(lambda x: x % 2 != 0, l)\n    l.sort()\n    if len(l) % 2 == 0:\n\
    \        return l[len(l) // 2]\n    else:\n        return (odd[len(odd) // 2]\
    \ + even[len(even) // 2]) / 2.0\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThe median\
    \ is just the middle number in the sorted list. You could do either of the following:\n\
    <code>", "    return float(sorted(l)[len(l) // 2])\n\n", "    \n    return sorted(l)[len(l)//2]\n",
  "    return sorted(l)[0]\n", "    l = sorted(l)\n    k = len(l) // 2\n    if k %\
    \ 2 == 0: return (l[k-1] + l[k])/2\n    else: return l[k]\n", "    l = sorted(l)\n\
    \    if len(l) % 2 == 0:\n        return float(l[len(l) // 2]) + (float(l[len(l)\
    \ // 2 - 1]) + float(l[len(l) // 2 + 1])) * 0.5\n    return float(l[len(l) //\
    \ 2])\n", "    l = sorted(l)\n    n = len(l)\n\n    if n % 2 == 1:\n        return\
    \ l[(n - 1) / 2]\n    else:\n        a = l[n / 2 - 1]\n        b = l[n / 2]\n\
    \    return (a + b) / 2.0\n", "    return statistics.median(l)\n", "    sortedlist\
    \ = sorted(l)\n    if len(sortedlist) % 2 == 0:\n        middle = len(sortedlist)\
    \ / 2\n        return sortedlist[middle]\n    else:\n        return (sortedlist[len(sortedlist)\
    \ // 2 - 1] + sortedlist[len(sortedlist) // 2]) / 2.0\n\n", "    sorted_list =\
    \ sorted(l)\n    length = len(l)\n    if length % 2 == 1:\n        return sorted_list[length\
    \ // 2]\n    else:\n        return (sorted_list[length // 2] + sorted_list[length\
    \ // 2 - 1]) / 2\n", "    # Sort and find the middle value\n    sorted_list =\
    \ sorted(l)\n    middle_idx = len(sorted_list) // 2\n    median = sorted_list[middle_idx]\n\
    \n    # If the list is odd, return the middle value\n    if middle_idx + 1 ==\
    \ len(sorted_list) or sorted_list[middle_idx] == sorted_list[middle_idx + 1]:\n\
    \        return median\n    else:\n        # Otherwise, return the average of\
    \ the middle two\n        return (sorted_list[middle_idx - 1] + sorted_list[middle_idx\
    \ + 1]) / 2\n", "    # http://code.activestate.com/recipes/466878-the-median-of-a-list-of-integers/\n\
    \    sorted = sorted(l)\n    if len(sorted) % 2 == 0:\n        return sorted[((len(sorted)+1)/2)-1]\n\
    \    else:\n        return sorted[(len(sorted)-1)//2]\n", "    l = sorted(l)\n\
    \    n = len(l)\n    if n % 2 == 0:\n        return l[n // 2]\n    else:\n   \
    \     l = l[n // 2 - 1:] + l[:n // 2]\n    return l[n // 2]\n\n", "    l = sorted(l)\n\
    \    if len(l) % 2 == 0:\n        return float(l[len(l)/2])\n    else:\n     \
    \   median = (l[len(l)/2 - 1] + l[len(l)/2])/2\n        return float(median)\n",
  "    sortedlist = sorted(l)\n    length = len(sortedlist)\n\n    if length % 2 ==\
    \ 0:\n        return (sortedlist[length//2-1] + sortedlist[length//2])/2\n   \
    \ else:\n        return sortedlist[length//2]\n", "    return statistics.median(l)\n",
  "    l = sorted(l)\n    if len(l) == 0:\n        raise ValueError()\n    if len(l)\
    \ % 2 == 0:\n        return l[(len(l) // 2) - 1]\n    else:\n        middle =\
    \ len(l)//2\n        return l[middle]\n</code>\n<|/ a |>\n<| a tags=python dscore=0\
    \ |>\nYou can use\n<code>\nimport math", "    # See http://bugs.python.org/issue28204\n\
    \    odd = len(l) // 2  # Divide by 2\n    if not odd:\n        return l[0]\n\
    \    if l[odd] == l[odd - 1]:\n        return l[odd]\n    if l[odd - 1] > l[odd]:\n\
    \        return median(l[:odd])\n    return median(l[odd:])\n\n", "    return\
    \ sorted(l)[len(l) // 2]\n", "    l = sorted(l)\n    n = len(l)\n    if n == 0:\n\
    \        raise ZeroDivisionError(\"median of empty list\")\n    if n >= 2:\n \
    \       return l[n // 2]\n    else:\n        raise ZeroDivisionError(\"median\
    \ of empty list\")\n", "    l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n\
    \        return float(l[(n - 1) / 2]) + (l[n / 2 - 1] + l[n / 2]) / 2.0\n    else:\n\
    \        return l[(n - 1) / 2]\n", "    l = sorted(l)\n    return l[l // 2 - 1]\n",
  "    l = sorted(l)\n    if len(l) <= 1:\n        return l[0]\n    if len(l) == 2:\n\
    \        return 0.5 * (l[0] + l[1])\n    return 0.5 * (l[(len(l)//2)-1] + l[((len(l)//2)+1)])\n",
  "    l = sorted(l)\n    if len(l) < 1:\n        raise Exception(f\"l = {l}, not\
    \ enough numbers in l\")\n    if len(l) % 2 == 0:\n        return (l[len(l) //\
    \ 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l) // 2]\n", " \
    \   l = sorted(l)\n    if len(l) % 2 == 0:\n        return l[(len(l) - 1) // 2]\n\
    \    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n", "   \
    \ # See https://stackoverflow.com/questions/24101524/how-do-i-get-the-median-of-a-list-in-python\n\
    \    l.sort()\n    return l[len(l) // 2] if l else 0\n", "    l = sorted(l)\n\
    \    n = len(l)\n    if n == 0:\n        raise ValueError('Cannot calculate median\
    \ of an empty list.')\n    if n == 1:\n        return l[0]\n    return ((l[n//2]+l[n//2-1])/2)\n",
  "    l = sorted(l)\n    if len(l) % 2 == 0:\n        return float(l[(len(l) / 2)\
    \ - 1] + l[len(l) / 2]) / 2.0\n    else:\n        return l[len(l) / 2]\n", " \
    \   if l == []:\n        return None\n    mid = l[0]\n    l_copy = list(l)\n \
    \   l_copy.remove(mid)\n    if len(l_copy)>1:\n        l_copy.remove(min(l_copy))\n\
    \    return mid\n</code>\n<|/ a tags=median,python |>\n<| a dscore=1 |>\n<code>",
  "    sorted_list = sorted(l)\n    return sorted_list[len(sorted_list) // 2]\n",
  "    l = sorted(l)\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l)\
    \ // 2 - 1]) // 2\n    else:\n        return l[len(l) // 2]\n", "    l.sort()\n\
    \    if len(l) <= 1:\n        return l[0]\n    else:\n        return l[len(l)\
    \ // 2]\n", "    return sorted(l)[len(l) // 2] if l else float(\"inf\")\n", " \
    \   sorts = sorted(l)\n    if sorts:\n        return sorts[len(sorts) // 2]\n\
    \    return 0.0\n", "    \n    \n    \n    \n    if l == []:\n        return None\n\
    \    \n    \n    \n    if len(l) %2 == 1:\n        return float(l[len(l)//2])\
    \ + median(l[: len(l)//2])\n    else:\n        return float(l[len(l)//2 - 1])\
    \ + median(l[: len(l)//2 - 1])\n    \n    \n    ", "    length = len(l)\n    if\
    \ not length:\n        raise ValueError(\"empty list\")\n    elif length == 1:\n\
    \        return l[0]\n    else:\n        middle = length // 2\n        left  =\
    \ median(l[:middle])\n        right = median(l[middle:])\n        if left == right:\n\
    \            return left #<-- change here to get median of list\n        else:\n\
    \            return (left + right)/2.0\n", "    return statistics.median(l)\n",
  "    l = sorted(l)\n    mid = len(l)//2\n    if len(l) % 2 == 0:\n        return\
    \ l[mid-1]\n    else:\n        return l[mid]\n    ", "    \n    return sorted(l,\
    \ reverse=True)[len(l) // 2]\n</code>\nI hope this helps!\n<|/ a |>\n<| c |>\n\
    I wouldn't call this median. Even the example shows an average value.\n<|/ c |>\n\
    <| c |>\nI agree. I edited to remove the average value\n<|/ c |>\n<| c |>\nHi\
    \ Martin, could you explain how your code works. I've been trying to understand\
    \ it but I'm still a bit confused.\n<|/ c |>\n<| c |>\nHi Martin, I tried running\
    \ your median algorithm and it gave me an incorrect answer when I run median([5,\
    \ 6, 12, 3, 7, 1, 8, 4]).\n<|/ c |>\n<| a |>\nThe median is the middle element\
    \ of a sorted list. The median is the value that is in the middle of the sorted\
    \ list, no matter how its value has been sorted.\nThe median is the value that\
    \ is in the middle of the sorted list, no matter how many elements are in the\
    \ list.\nThe median is the value that is in the middle of the sorted list, no\
    \ matter how it's been sorted\nThe median is the value that is in the middle of\
    \ the sorted list, no matter how it's been sorted\nThe median is the value that\
    \ is in the middle of the sorted list, no matter how many elements are in the\
    \ list.\nThe median is the value that is in the middle of the sorted list, no\
    \ matter how it's been sorted\nThe median is the value that is in the middle of\
    \ the sorted list, no matter how it's been sorted\n<|/ a dscore=4 tags=sorting,algorithm,language-agnostic,median,python\
    \ |>\n<| a tags=sorting,algorithm,language-agnostic,median,python dscore=4 |>\n\
    The median of 3 numbers is middle number of the set which is the mean of those\
    \ 3 numbers.\nThe median of 4 numbers is middle number of the set which is the\
    \ mean of those 4 numbers.\nThe median of 5 numbers is middle number of the set\
    \ which is the mean of those 5 numbers.\nThe median of 6 numbers is middle number\
    \ of the set which is the mean of those 6 numbers.\nThe median of 7 numbers is\
    \ middle number of the set which is the mean of those 7 numbers.\nThe median of\
    \ 8 numbers is middle number of the set which is the mean of those 8 numbers.\n\
    The median of 9 numbers is middle number of the set which is the mean of those\
    \ 9 numbers.\nThe median of 10 numbers is middle number of the set which is the\
    \ mean of those 10 numbers.\nThe median of 11 numbers is middle number of the\
    \ set which is the mean of those 11 numbers.\nThe median of 12 numbers is middle\
    \ number of the set which is the mean of those 12 numbers.\nThe median of 13 numbers\
    \ is middle number of the set which is the mean of those 13 numbers.\nThe median ",
  "    # http://stackoverflow.com/questions/24101524/median-of-list-in-python\n  \
    \  l = sorted(l)\n    if len(l) % 2:\n        return l[((len(l)+1)//2) - 1]\n\
    \    else:\n        return l[((len(l))//2)]\n", "    length = len(l)\n    if length\
    \ % 2 == 1:\n        return sorted(l[(length-1)//2])\n    else:\n        left\
    \ = (length+1)//2 - 1\n        right = length//2\n    return (sorted(l[left],\
    \ l[right])[((length+1)//2 - left)//2] + \n            sorted(l[left], l[right])[((length+1)//2\
    \ - right)//2])/2\n", "    lst = list(set(l))\n    lst.sort()\n    if not lst:\n\
    \        return float(\"nan\")\n    return lst[len(lst) // 2]\n", "    sorted_list\
    \ = sorted(l)\n    size = len(sorted_list)\n    mid_index = (size - 1) // 2\n\
    \    \n    if size % 2 == 1:\n        # Only median of two numbers, use middle\
    \ one.\n        return sorted_list[mid_index]\n    elif sorted_list[mid_index\
    \ - 1] < sorted_list[mid_index + 1]:\n        # Only median of the two numbers,\
    \ use middle one.\n        return sorted_list[mid_index]\n    else:\n        #\
    \ Medians of two and three numbers, use middle two.\n        return sorted_list[mid_index\
    \ + 1]\n", "    sorted_list = sorted(l)\n    mid = len(sorted_list) // 2\n   \
    \ if sorted_list[mid] == sorted_list[0] or sorted_list[mid] == sorted_list[-1]:\n\
    \        return sorted_list[mid]\n    if sorted_list[mid] == sorted_list[-2]:\n\
    \        return sorted_list[mid]\n    else:\n        before = sorted_list[mid\
    \ - 1]\n        after = sorted_list[mid]\n        return (after - before) / 2.0\n",
  "    return sorted(l)[round(len(l)/2)] if l else 0\n", "    l = sorted(l)\n    length\
    \ = len(l)\n\n    if length % 2 == 1:\n        return l[length // 2]\n    else:\n\
    \        return (l[(length // 2) - 1] + l[length // 2]) / 2\n", "    length =\
    \ len(l)\n\n    if length % 2 == 1:\n        return l[length//2]\n    else:\n\
    \        return (l[(length-1)//2] + l[length//2]) / 2\n", "    l = sorted(l)\n\
    \    if len(l) % 2 == 0: return float(l[len(l) // 2])\n    else: return (float(l[len(l)\
    \ // 2 - 1]) + float(l[len(l) // 2]))/2\n</code>\n<|/ a |>\n<| a dscore=2 |>\n\
    Just for the fun of it, here's a recursive solution:\n<code>", "    l = sorted(l)\n\
    \    if len(l) % 2:\n        return l[(len(l) // 2) - 1]\n    else:\n        return\
    \ (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nWhat if there's an even number of elements? What if there's an odd number\
    \ of elements? What if there's no elements?\n<|/ c |>\n<| a tags=python,python-3.x\
    \ |>\nMy suggestion is that you start with the code that you have, without all\
    \ the extraneous stuff for printing results, and then add in the function definitions\
    \ for the other functions. After that you can run the script, and see where the\
    \ code breaks.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote this answer, based\
    \ on the code in the question, after I realized how stupid that question was (it's\
    \ actually a homework question that I've already solved).\nThe code below will\
    \ find the median of the elements in a list.\nIf there is an even number of elements,\
    \ the median will be the element in the middle of the list that is in the middle\
    \ of the list, so divide the length of the list by 2 and round down to get the\
    \ middle element.\nIf there is an odd number of elements, then you just have to\
    \ find the element in the middle of the list.\nThe code below also includes code\
    \ to output the list of all the elements in the list.\nThe code was tested and\
    \ I believe that it is correct. Let me know if you have any questions.\n<code>",
  "    return sorted(l) + [max(l)//2] if len(l) % 2 == 0 else sorted(l)[int((len(l)-1)/2)]\n",
  "    if len(l) < 1:\n        raise ValueError(\"len(l)=%d\" % len(l))\n    if len(l)\
    \ % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        a = l[len(l) //\
    \ 2]\n        b = l[(len(l) // 2) + 1]\n    return (a if a >= b else b) if a <\
    \ b else (a if b < a else b)\n", "    l = sorted(l)\n    if len(l)%2 != 0:\n \
    \       return float(l[len(l)//2] + l[len(l)//2-1])//2\n    else:\n        return\
    \ l[((len(l)//2) - 1)]\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,python |>\n\
    Using a list comprehension and lambda functions:\n<code>", "    return sorted(l)[0]\n",
  "    l = sorted(l)\n    mid = l[len(l)//2]\n    if len(l) % 2:\n        return mid\n\
    \    else:\n        return l[(len(l)//2)-1]\n", "    length = len(l)\n    if length\
    \ % 2 == 1:\n        return sorted(l[(length//2)-1:(length//2)+1])[0]\n    else:\n\
    \        return sorted(l[(length//2)-1:(length//2)+2])[len(l[length//2-1:length//2+2])//2]\n\
    \n", "    l = sorted(l)\n    if l[len(l)//2] == 0:\n        return l[int(len(l)//2)]\n\
    \    return l[int(len(l)//2)-1] + float(len(l))/2 - 1\n\n", "    return statistics.median(l)\n\
    \n", "    sorts = sorted(l)\n    if len(sorts) == 0:\n        raise ValueError(\"\
    No median for empty list\")\n    if sorts.count(sorts[0]) == len(sorts):\n   \
    \     return sorts[0]\n    if sorts.count(sorts[-1]) == len(sorts):\n        return\
    \ sorts[-1]\n    mid = len(sorts) // 2\n    if sorts[mid] == sorts[-1]:\n    \
    \    return sorts[mid]\n    else:\n        return (sorts[mid] + sorts[mid-1])\
    \ // 2\n", "    l.sort()\n    if len(l) == 0: return None\n    if len(l) == 1:\
    \ return l[0]\n    if l[len(l) // 2] > l[len(l) // 2 - 1]:\n        idx = len(l)\
    \ // 2\n    else:\n        idx = (len(l) - 1) // 2\n    return l[idx]\n", "  \
    \  n = len(l)\n    if n < 1:\n        raise ValueError('median requires at least\
    \ one value')\n    if n == 1:\n        return l[0]\n    if n % 2 == 1:\n     \
    \   # even: return the (n - 1) / 2th value\n        # e.g. median([3, 1, 2, 4,\
    \ 5]) -> 3\n        return 0.5 * (l[(n + 1) / 2] - l[n / 2 - 1])\n    else:\n\
    \        # odd: return the (n - 1) / 3rd value\n        # e.g. median([3, 1, 2,\
    \ 4, 5]) -> 2\n        return 0.5 * (l[(n - 1) / 3] - l[n / 3 - 1])\n", "    l\
    \ = sorted(l)\n    if len(l) % 2 == 0:\n        return l[(len(l) // 2) - 1]\n\
    \    else:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n", "   \
    \ l = sorted(l)\n    n = len(l)\n    if n == 0:\n        raise ValueError('l is\
    \ empty')\n    elif n % 2 == 0:\n        return l[n//2]\n    else:\n        return\
    \ (l[n//2] + l[n//2 - 1]) // 2\n", "    \n    median_val = l[0]\n    len_l = len(l)\n\
    \    \n    for i in range(1, len_l):\n        if l[i] < median_val:\n        \
    \    median_val = l[i]\n    \n    return median_val\n", "    # http://wiki.python.org/moin/HowTo/Sorting/\n\
    \    l = sorted(l)\n    if len(l)%2==0:\n        return l[(len(l)/2)-1]\n    else:\n\
    \        return l[int((len(l)/2)-1)]\n", "    sorted_list = sorted(l)\n    if\
    \ len(sorted_list) % 2 == 0:\n        return sorted_list[((len(sorted_list) -\
    \ 1) // 2)] + (sorted_list[(len(sorted_list) - 1) // 2 - 1] + sorted_list[len(sorted_list)\
    \ // 2])\n    else:\n        return sorted_list[((len(sorted_list) - 1) / 2)]\n",
  "    return statistics.median(l)\n", "    l=sorted(l)\n    if len(l)%2==0:\n   \
    \     return l[len(l)//2]\n    else:\n        return l[len(l)//2]+(l[len(l)//2-1]-l[len(l)//2])/2\n",
  "    if len(l) == 0:\n        raise ValueError(\"Cannot calculate median of an empty\
    \ list\")\n    if len(l) % 2 == 0:\n        return l[len(l) // 2]\n    mid = len(l)\
    \ // 2\n    median = sorted(l[:mid])[len(l) // 2 - 1]\n    return median\n", " \
    \   sorted_list = sorted(l)\n    if len(l) % 2 == 0:\n        return sorted_list[len(l)\
    \ // 2]\n    else:\n        median1 = sorted_list[len(l) // 2 - 1]\n        median2\
    \ = sorted_list[len(l) // 2]\n        return median2 + (median2 - median1) * (len(l)\
    \ // 2)\n", "    sorted_list = sorted(l)\n    length = len(sorted_list)\n    if\
    \ length % 2 == 1:\n        return (sorted_list[length // 2] + sorted_list[length\
    \ // 2 - 1]) / 2\n    else:\n        return sorted_list[length // 2]\n", "   \
    \ l = sorted(l)\n    if len(l) % 2 == 0:\n        return float(l[int(len(l) /\
    \ 2)])\n    else:\n        mid = l.index(min(l))\n        return float(l[mid])\n",
  "    n = len(l)\n    if n == 0:\n        raise TypeError('n must be greater than\
    \ 0')\n    m = n // 2\n    if n % 2:\n        return l[m]\n    else:\n       \
    \ return l[m-1] + l[m]\n", "    sortedL = list(sorted(l))\n    mid = len(l) //\
    \ 2\n    if sortedL[mid] == sortedL[mid-1]:\n        median = (sortedL[mid-1]\
    \ + sortedL[mid]) / 2\n    else:\n        median = sortedL[mid]\n    return median\n",
  "    from statistics import median\n    return median(l)\n", "    l = sorted(l)\n\
    \    if len(l) <= 1:\n        return l[0]\n    if len(l) % 2 == 0:\n        mid\
    \ = l[len(l) // 2]\n        left = [n for n in l if n < mid]\n        right =\
    \ [n for n in l if n > mid]\n        return float(len(left)) / 2\n    else:\n\
    \        mid = l[len(l) // 2 - 1]\n        left = [n for n in l if n < mid]\n\
    \        right = [n for n in l if n > mid]\n        if len(left) > len(right):\n\
    \            return float(len(left)) / 2\n        else:\n            return float(len(right))\
    \ / 2\n", "    # TODO:\n    numbers = l\n    sorted_numbers = sorted(numbers)\n\
    \    length = len(sorted_numbers)\n    middle_idx = length // 2\n\n    if length\
    \ == 1:\n        return sorted_numbers[middle_idx]\n\n    if length == 2:\n  \
    \      if sorted_numbers[middle_idx] == sorted_numbers[length - 1]:\n        \
    \    return sorted_numbers[middle_idx]\n\n    if length == 3:\n        if sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 2]:\n            if sorted_numbers[middle_idx] ==\
    \ sorted_numbers[length - 2]:\n                return sorted_numbers[middle_idx]\n\
    \n            if sorted_numbers[middle_idx] < sorted_numbers[length - 1]:\n  \
    \              return sorted_numbers[middle_idx - 1]\n        else:\n        \
    \    if sorted_numbers[middle_idx] == sorted_numbers[length - 2]:\n          \
    \      return sorted_numbers[middle_idx - 1]\n            elif sorted_numbers[middle_idx]\
    \ < sorted_numbers[length - 1]:\n                return sorted_numbers[middle_idx]\n\
    \n    if length == 4:\n        if sorted_numbers[middle_idx] <= sorted_numbers[length\
    \ - 3] and \\\n            sorted_numbers[middle_idx] <= sorted_numbers[length\
    \ - 4]:\n            return sorted_numbers[middle_idx]\n\n    if length == 5:\n\
    \        if sorted_numbers[middle_idx] <= sorted_numbers[length - 3] and \\\n\
    \            sorted_numbers[middle_idx] <= sorted_numbers[length - 4] and \\\n\
    \            sorted_numbers[middle_idx] <= sorted_numbers[length - 5]:\n     \
    \       return sorted_numbers[middle_idx]\n        elif sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 3] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 4] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 5] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 6]:\n            return sorted_numbers[middle_idx\
    \ - 1]\n        elif sorted_numbers[middle_idx] <= sorted_numbers[length - 3]\
    \ and \\\n            sorted_numbers[middle_idx] <= sorted_numbers[length - 4]\
    \ and \\\n            sorted_numbers[middle_idx] <= sorted_numbers[length - 5]\
    \ and \\\n            sorted_numbers[middle_idx] <= sorted_numbers[length - 6]\
    \ and \\\n            sorted_numbers[middle_idx] <= sorted_numbers[length - 7]:\n\
    \            return sorted_numbers[middle_idx - 2]\n        elif sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 3] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 4] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 5] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - 6] and \\\n            sorted_numbers[middle_idx]\
    \ <= sorted_numbers[length - ", "    # http://ostermiller.org/find-median_of_medians.html\n\
    \    if not l:\n        return float('nan')\n    if len(l) % 2 == 0:\n       \
    \ return sorted(l)[len(l) // 2]\n    else:\n        return (sorted(l) + sorted(l))[len(l)\
    \ // 2 - 1 ]\n", "    return sorted(l)[0]\n", "    l.sort()\n    if len(l) % 2\
    \ == 0:\n        return l[int((len(l)/2)-1)]\n    else:\n        return (l[int((len(l)/2)-1)]+l[int((len(l)/2))])/2\n",
  "    if l == []:\n        raise ValueError('The median of an empty list is undefined.')\n\
    \    l1 = sorted(l)\n    if len(l1) & 1:\n        return float(l1[-1])\n    else:\n\
    \        mid = l1[0] + ((float(len(l1) - 1) >> 1) * 0.5)\n        return float(mid)\n\
    </code>\n<|/ a tags=python,list,median,algorithm |>\n<| a dscore=1 tags=python,list,median,algorithm\
    \ |>\nThe below code snippet solves the problem of finding median in O(nlogn)\n\
    <code>", "    sortedL = sorted(l)\n    middle = len(sortedL) // 2\n    if middle\
    \ % 2 == 0:\n        return sortedL[middle-1]\n    else:\n        return sortedL[middle]\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=average,python,list,python-3.x |>\nTo calculate\
    \ the average of a list using Python's built-in libraries only:\n<code>", "  \
    \  l = sorted(l)\n    return (l[len(l) // 2] + l[len(l) // 2 - 1]) // 2\n", " \
    \   l = sorted(l)\n    if len(l)==0:\n        return 0\n    if len(l) == 1: return\
    \ l[0]\n    elif len(l) % 2 == 0:\n        mid = l[((len(l)/2)-1)//2]\n      \
    \  return float(l[((len(l)/2)-1)//2] + l[len(l)//2 - 1])/2\n    else: # even\n\
    \        mid = l[((len(l)/2)-1)//2]\n        return float(l[((len(l)/2)-1)//2]\
    \ + l[len(l)//2])/2\n", "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return\
    \ float(l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n    else:\n        return\
    \ (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "    return sorted(l)[len(l)/2]\n",
  "    \n    l = sorted(l)\n    n = len(l)\n\n    return l[n//2] if n%2==0 else (l[n//2]+l[n//2-1])/2.0\n",
  "    if l == []:\n        return None\n    sorted_list = sorted(l)\n    return sorted_list[len(sorted_list)\
    \ // 2]\n", "    # Python has efficient built-in median\n    half = len(l) //\
    \ 2\n    if l is None or len(l) < 2:\n        return None\n    sorted_list = sorted(l)\n\
    \    median = sorted_list[half]\n    return median\n", "    sortedList = sorted(l)\n\
    \    return int(len(l)/2) if sortedList[-1] > sortedList[len(sortedList)//2] else\
    \ int(len(l)/2-1)\n\n", "    # https://stackoverflow.com/questions/24101524/how-to-find-median-in-python\n\
    \    return float(sorted(l))[len(l) // 2]\n", "    l = sorted(l)\n    if len(l)\
    \ % 2 == 0:\n        return l[((len(l) // 2))-1]\n    else:\n        return (l[len(l)\
    \ // 2] + l[len(l) // 2 - 1]) / 2\n", "    l = sorted(l)\n    if l:\n        return\
    \ l[len(l)//2]\n    else:\n        raise ArithmeticError('cannot median an empty\
    \ list')\n", "    from statistics import median\n    return median(l)\n", "  \
    \  l = sorted(l)\n    if len(l) % 2 == 0:\n        return (l[((len(l)+1)/2)-1]\
    \ + l[len(l)/2]) / 2\n    else:\n        return l[((len(l)+1)/2)]\n", "    l =\
    \ sorted(l)\n    return l[len(l)//2]\n", "    return statistics.median(l)\n\n",
  "    l = sorted(l)\n    mid = len(l) // 2\n    return (l[mid] + l[mid-1]) * (0.5\
    \ + (mid==len(l)//2))\n", "    sortedlist = sorted(l)\n    if sortedlist == sorted(l):\n\
    \        return (sorted(l)[int(len(sortedlist)/2)])\n    else:\n        return\
    \ sortedlist[int(len(sortedlist)/2)]\n", "    return statistics.median(l)\n",
  "    l = sorted(l)\n    middle = len(l) // 2\n    left = l[:middle]\n    right =\
    \ l[middle:]\n    if l[middle] == l[middle - 1]:\n        return l[middle]\n \
    \   else:\n        return 0.5 * (median(left) + median(right))\n", "    if not\
    \ l:\n        raise ValueError(\"Cannot calculate median of an empty list\")\n\
    \n    return sorted(l)[0]\n", "    l, n = 0, len(l)\n    if n > 1:\n        mid\
    \ = n // 2\n        if n % 2:\n            return l[mid]\n        else:\n    \
    \        return (sum(l[mid-1:mid+1]) + l[mid]) >> 1\n    else:\n        return\
    \ l[0]\n</code>\n<|/ a dscore=2 |>\n<| a tags=python |>\nI like using statistics\
    \ module for this.\n<code>\nimport statistics\nfrom statistics import median\n",
  "    if len(l) < 1:\n        raise RuntimeError(\"Input list contains no elements.\"\
    )\n    l = sorted(l)\n    return l[len(l) // 2] if l and l[len(l) // 2 ] > 0 else\
    \ 0\n", "    l.sort()\n    if len(l) < 1:\n        raise ValueError\n    if len(l)\
    \ % 2 == 0:\n        return float(l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n \
    \   else:\n        return l[len(l) // 2]\n", "    half = len(l) // 2\n    if half\
    \ == 0:\n        return l[0]\n    if half == 1:\n        return l[-1]\n    else:\n\
    \        begin = l[:half]\n        end = l[half:]\n        median = (begin + end)\
    \ // 2\n        return median\n", "    l.sort()\n    if len(l) % 2 == 0:\n   \
    \     return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2] + l[len(l)\
    \ // 2 - 1]) // 2\n\n", "    l = sorted(l)\n    if len(l) < 1:\n        raise\
    \ ValueError(\"Empty list\")\n    return float(l[len(l)//2 - 1]) if len(l) % 2\
    \ == 0 else float(l[(len(l)//2) - 1]) + float(l[(len(l)//2) - 1])\n\n", "    sortedList\
    \ = sorted(l)\n    length = len(sortedList)\n    if length % 2 == 0:\n       \
    \ return (sortedList[(length - 1) / 2] + sortedList[(length - 1) / 2 - 1]) / 2\n\
    \    else:\n        return sortedList[length / 2]\n", "    sorted_list = sorted(l)\n\
    \    middle = len(sorted_list) // 2\n    if middle == 0:\n        return sorted_list[middle]\n\
    \    else:\n        if sorted_list[(len(sorted_list) - 1 - middle)] < sorted_list[middle]:\n\
    \            return sorted_list[middle]\n        else:\n            return sorted_list[(len(sorted_list)\
    \ - 1 - middle)]\n", "    l = list(filter(lambda x: x % 5 != 0, l))\n    return\
    \ float(sum(l)) / len(l)\n</code>\n<|/ a dscore=5 tags=median,python,list |>\n\
    <| c |>\nThis solution does not work when there are a mix of even and odd numbers\
    \ in the list.\n<|/ c |>\n<| c |>\nYes it does. The median is the value which\
    \ is closest to its rank in the list. If there are two values that are equally\
    \ close to the median then they will both be returned in the sorted list. Try\
    \ it out.\n<|/ c |>\n<| c |>\nThe median is the middle value in a sorted array.\
    \ In your case the median is 5. In my case the median is 3.\n<|/ c |>\n<| c |>\n\
    I think this solution is just perfectly valid for the problem stated at hand.\
    \ Although it could have some problems for data which has duplicates. `median`\
    \ should return one of the values which are closest to its rank in the list. And\
    \ if there are more than one values which are equally close to the median then\
    \ they will be returned in the sorted list.\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \  When there are 2 even numbers in the list, it will not return the median and\
    \ it will return the first even number.\n<|/ c |>\n<| a dscore=5 |>\n<code>",
  "    return statistics.median(l)\n", "    from statistics import median\n    if\
    \ not l:\n        return float('nan')\n    if len(l) % 2 == 1:\n        return\
    \ float(sorted(l)[len(l) // 2])\n    else:\n        i = int(len(l) / 2)\n    \
    \    return (float(l[i]) + float(l[len(l) - i - 1])) / 2.0\n\n", "    length =\
    \ len(l)\n    if length % 2 == 1:\n        return float(l[(length // 2) - 1] if\
    \ length % 2 == 0 else l[(length // 2) - 2]) / 2.0\n    else:\n        middle\
    \ = float(length // 2)\n        return float(l[middle]) if length % 2 == 0 else\
    \ float(l[middle]) + float(l[(middle + 1) \n                                 \
    \                                                          if length % 2 == 1\
    \ else middle]) / 2\n\n", "    sorted(l)\n    if len(l)%2==0:\n        mid = len(l)\
    \ // 2\n        return (l[mid-1]+l[mid])/2\n    else:\n        return l[((len(l)//2)-1)//2]\n",
  "    return statistics.median(l)\n\n", "    l = sorted(l)\n    mid = l[0] if l else\
    \ 0\n    if l[-1] < mid:\n        return l[(len(l) // 2)]\n    elif l[-1] > mid:\n\
    \        return l[(len(l) // 2 + 1)]\n    return mid", "    copy = sorted(l)\n\
    \    size = len(copy)\n    if size % 2 == 1:\n        return copy[size//2]\n \
    \   else:\n        return (copy[size//2-1] + copy[size//2]) / 2.0\n", "    l =\
    \ sorted(l)\n    if len(l) % 2 == 0:\n        return float(l[(len(l) // 2) - 1]\
    \ + l[len(l) // 2]) / 2.0\n    else:\n        return l[len(l) // 2]\n\n", "  \
    \  from statistics import median\n    return median(l)\n", "    return sorted(l[1::])[len(l)\
    \ // 2]\n", "    from statistics import median\n    if not l:\n        return\
    \ None\n    l = sorted(l)\n    return median(l)\n", "    l = sorted(l)\n    if\
    \ len(l) % 2 == 0:\n        return l[((len(l) // 2) - 1)]\n    else:\n       \
    \ median1 = l[((len(l) // 2) - 1)]\n        median2 = l[len(l) // 2]\n       \
    \ return (median1 + median2) / 2.0\n", "    ln = len(l)\n    if ln <= 1:\n   \
    \     return l[0]\n    m = floor((ln - 1) / 2)\n    if m == 0:\n        return\
    \ l[m-1]\n    elif m == ln - 1:\n        return l[m]\n    else:\n        return\
    \ l[m-1] + l[m]\n", "    l = sorted(l)\n    if l:\n        mid = len(l) // 2\n\
    \        if l[mid] < l[mid-1]:\n            return l[mid]\n        else:\n   \
    \         return l[mid-1]\n    else:\n        return float(\"inf\")\n", "    l\
    \ = sorted(l)\n    return l[len(l) // 2] if l else 0\n", "    l, copy = _check_and_copy(l,\
    \ \"median\")\n\n    if len(l) % 2 == 0:\n        return l[l.index(min(l))] +\
    \ l[len(l) // 2]\n    else:\n        l.sort()\n        return l[(len(l) // 2)\
    \ - 1]\n", "    ls = sorted(l)\n    return ls[len(ls)//2]\n", "    return statistics.median(l)\n",
  "    l = sorted(l)\n    return l[len(l) // 2]\n</code>\n<|/ a tags=list,python,python-3.x\
    \ |>\n<| a dscore=1 tags=list,python,python-3.x |>\nIn Python, we can use the\
    \ built-in function sum :\n<code>\nprint(sum( [float(i) for i in a] ))\n</code>\n\
    <|/ a |>\n<| a |>\nYou can use the sum function like this:\n<code>\na=[3,1,2,4,5]\n\
    print(sum(a)/len(a))\n</code>\noutput:\n<code>\n3.0\n</code>\n<|/ a tags=list,python,python-3.x\
    \ dscore=0 |>\n<| a tags=list,python,python-3.x dscore=0 |>\nThis is one way to\
    \ get the median\n<code>", "    if len(l) < 1:\n        raise ValueError('cannot\
    \ compute median from empty list')\n    l.sort()\n    if len(l) % 2:\n       \
    \ return l[((len(l) - 1) // 2) - 1]\n    else:\n        mid = len(l) // 2\n  \
    \      return (l[mid] + l[mid-1]) / 2\n", "    l = sorted(l)\n    if len(l)%2:\n\
    \        return l[len(l)//2]\n    else:\n        return (l[len(l)//2] + l[len(l)//2-1])/2.0\n",
  "    return statistics.median(l)\n", "    return sorted(l)[len(l) // 2]\n", "  \
    \  l = sorted(l)\n    if len(l) % 2 == 0:\n        return (l[((len(l) + 1) //\
    \ 2) - 1] + l[((len(l) + 1) // 2)]) / 2.0\n    return l[int((len(l) + 1) / 2)\
    \ - 1]\n", "    return statistics.median(l)\n", "    l = sorted(l)\n    n = len(l)\n\
    \    if n % 2:\n        return l[n // 2]\n    else:\n        return float(l[n\
    \ // 2 - 1] + l[n // 2]) / 2\n", "    return sorted(l, reverse=True)[len(l) /\
    \ 2]\n</cell>\n<cell>", "    length = len(l)\n    if length % 2 == 1:\n      \
    \  return l[(length + 1) / 2] if l[length / 2] < l[length / 2 - 1] else l[length\
    \ / 2]\n    else:\n        return l[length / 2]\n", "    l = sorted(l)\n    if\
    \ len(l) % 2 == 0:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n\
    \    return l[len(l) // 2]\n", "    l = sorted(l)\n    if l[len(l)//2] == l[len(l)//2-1]:\n\
    \        return l[len(l)//2]\n    else:\n        return l[len(l)//2-1]\n", " \
    \   l.sort()\n    if len(l) % 2 == 1:\n        return l[(len(l)//2)-1]\n    else:\n\
    \        median = (l[len(l)//2-1] + l[len(l)//2])//2\n        return median\n\n",
  "    l = sorted(l)\n    if len(l) % 2:\n        return l[len(l) // 2]\n    else:\n\
    \        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n        ", "    # https://stackoverflow.com/questions/24101524/median-in-python\n\
    \    return sorted(l)[0]\n    # return sorted(l)[len(l)//2] # faster on small\
    \ lists\n", "    # http://code.activestate.com/recipes/534109-find-the-median/\n\
    \    sortedL = sorted(l)\n    length = len(sortedL)\n    if length % 2 == 1:\n\
    \        return float(sortedL[(length + 1) / 2 - 1])\n    else:\n        return\
    \ (sortedL[(length + 1) / 2] + sortedL[length / 2 - 1]) / 2\n", "    # http://stackoverflow.com/a/4932593\n\
    \    return sorted(l)[len(l) // 2]\n", "    l.sort()\n    if len(l) % 2 == 0:\n\
    \        return l[(len(l) // 2) - 1]\n    else:\n        return l[len(l) // 2]\n",
  "    mid = len(l) // 2\n    if l[mid] < 0 :\n        return l[0]\n    if l[mid]\
    \ > 0 :\n        return l[-1]\n    return 0.5 * (l[mid] + l[mid-1])\n\n", "  \
    \  ls = l[:]\n    ls.sort(key=abs)\n    return ls[len(ls)//2] if len(ls)%2 else\
    \ ls[len(ls)//2-1]\n", "    if len(l) % 2 == 1:\n        return sorted(l)[len(l)\
    \ / 2]\n    else:\n        return (sorted(l)[len(l) / 2 - 1] + sorted(l)[len(l)\
    \ / 2]) / 2\n</code>\n<|/ a dscore=2 tags=python,median,statistics,algorithm |>\n\
    <| a dscore=2 |>\nI implemented my own in Javascript (using sort with optional\
    \ parameter, default being median), and it is still very fast (a factor of 2x)\n\
    <code>\nconst median = (list, sortFunction) => {\n    if (list && list.length)\
    \ {\n        const length = list.length;\n        if (length > 1) {\n        \
    \    const listLength = length - 1;\n            const middle = Math.floor(listLength\
    \ / 2);\n            if (sortFunction) {\n                list.sort(sortFunction);\n\
    \            }\n            if (length < listLength) {\n                return\
    \ list[middle];\n            }\n            else {\n                const right\
    \ = length - listLength;\n                return (listLength < middle) ? list[length]\
    \ : list[middle] > list[middle+1] ? list[middle] : (sortFunction) ? list[middle+right]\
    \ : list[middle+right].sort();\n            }\n        } else {\n            return\
    \ list[0];\n        }\n    }\n};\n</code>\n<|/ a tags=python,median,statistics,algorithm\
    \ |>\n<| a |>\nHere's an O(n) implementation that also sorts and takes into account\
    \ that your list may be empty:\n<code>", "    l.sort()\n    if len(l) % 2:\n \
    \       return l[len(l) // 2]\n    else:\n        return ((l[len(l) // 2 - 1]\
    \ + l[len(l) // 2]) / 2.0)\n", "    l = sorted(l)\n    if len(l)==0:\n       \
    \ return None\n    elif len(l)==1:\n        return l[0]\n    else:\n        mid\
    \ = (len(l)+1) // 2\n        return float(l[mid])\n", "    if len(l) == 0:\n \
    \       raise RuntimeError('median called with an empty list')\n\n    if len(l)\
    \ % 2 == 0:\n        return l[int((len(l) // 2))]\n    else:\n        a = sorted(l)\n\
    \        return a[int((len(a) -1)//2)]\n\n", "    l = sorted(l)\n    return l[len(l)//2]\n",
  "    l = sorted(l)\n    mid = len(l) // 2\n    if l == sorted(l):\n        return\
    \ l[mid]\n    else:\n        return (l[mid-1] + l[mid])/2\n", "    l = sorted(l)\n\
    \    l = l[1:] if len(l) % 2 == 0 else sorted(l[1:], reverse=True)\n    return\
    \ l[l/2]\n\n", "    length = len(l)\n    if length == 0:\n        raise ValueError(\"\
    Cannot calculate median of an empty list.\")\n    if length == 1:\n        return\
    \ l[0]\n    if length%2 == 0:\n        return sorted(l)[(length//2)-1]\n    else:\n\
    \        return sorted(l)[((length+1)//2)-1]\n", "    if not l:\n        return\
    \ None\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n  \
    \      middle = len(l) // 2\n        left = median(l[:middle])\n        right\
    \ = median(l[middle:])\n        if left < right:\n            return left\n  \
    \      else:\n            return right\n", "    l = sorted(l)\n    if len(l) %\
    \ 2 == 1:\n        return l[(len(l) // 2) - 1]\n    else:\n        middle = len(l)\
    \ // 2\n        left = l[:middle]\n        right = l[middle:]\n        return\
    \ float(sum(l)) / len(l)\n", "    sorted(l)\n    \n    n = len(l)\n    \n    if\
    \ n % 2:\n        return l[(n - 1) / 2]\n    else:\n        return (l[n / 2 -\
    \ 1] + l[n / 2]) / 2.0\n    \n", "    # http://code.activestate.com/recipes/425440/\n\
    \    return sorted(l)[0]\n", "    l.sort()\n    if len(l) % 2 == 0: return l[(len(l)/2)\
    \ - 1]\n    else:             return float(l[(len(l)/2)-1] + l[(len(l)/2)])/2\n",
  "    l = sorted(l)\n    if len(l) % 2 == 0:\n        return l[len(l) // 2]\n   \
    \ else:\n        mid = len(l) // 2\n        return (l[mid] + l[mid-1]) / 2\n",
  "    if l is None:\n        return None\n    elif len(l) % 2 == 1:\n        return\
    \ l[(len(l) // 2)]\n    else:\n        mid = (len(l) // 2) + (len(l) // 2 - 1)\n\
    \        return (l[mid-1] + l[mid]) / 2\n", "    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/142812\n\
    \    sorted(l)\n    half = len(l)//2\n    if half:\n        return (l[half-1]\
    \ + l[half])/2\n    else:\n        return l[half]\n", "    l = sorted(l)\n   \
    \ mid = len(l)//2\n    if len(l) % 2 == 0:\n        return l[mid]\n    return\
    \ 0.5 * (l[mid-1] + l[mid])\n", "    size = len(l)\n    if size % 2 == 0:\n  \
    \      return l[size//2]\n    else:\n        return (l[size//2] + l[size//2-1])/2.0\n",
  "    if len(l) % 2:\n        return sorted(l)[len(l) // 2]\n    else:\n        return\
    \ (sorted(l)[len(l) // 2 - 1] + sorted(l)[len(l) // 2]) / 2\n", "    l = list(sorted(l))\n\
    \    n = len(l)\n    if n == 0:\n        return float(\"nan\")\n    if n % 2 ==\
    \ 1:\n        return float(l[(n - 1) // 2])\n    else:\n        middle = n //\
    \ 2\n        return float(l[middle - 1] + (l[middle] - l[middle - 1]) * 0.5)\n",
  "    l = sorted(l)\n    return l[round(len(l)/2)] if len(l)%2 == 0 else (l[round((len(l)/2)-1)]+l[round((len(l)/2)+1)])/2\n\
    \n", "    return sorted(l)[0]\n", "    return statistics.median(l)\n", "    l\
    \ = sorted(l)\n    if len(l) % 2 == 0:\n        return l[((len(l) + 1) / 2) -\
    \ 1]\n    return l[((len(l) + 1) / 2)]\n", "    l = sorted(l)\n    n = len(l)\n\
    \    if n % 2 == 1:\n        return l[(n - 1) / 2]\n    else:\n        return\
    \ float(l[n / 2 - 1] + l[n / 2]) / 2\n\n", "    sorted_l = sorted(l)\n    if len(sorted_l)\
    \ % 2 == 0:\n        return sorted_l[((len(sorted_l) - 1) // 2) + 1]\n    else:\n\
    \        return (sorted_l[len(sorted_l) // 2] + sorted_l[len(sorted_l) // 2 -\
    \ 1]) / 2\n\n", "    l = sorted(l)\n    length = len(l)\n    if length % 2 ==\
    \ 0: return float(l[length//2 - 1] + l[length//2])/2.0\n    else: return l[length//2]\n",
  "    numbers = Counter(l)\n    return sorted(numbers)[len(numbers) // 2]\n</code>\n\
    <|/ a tags=sorting,python,list,python-3.x |>\n<| a tags=sorting,python,list,python-3.x\
    \ |>\nYou can use the Counter class, from collections module, to do this:\n<code>\n\
    from collections import Counter\nprint(Counter(your_list).most_common(1)[0])\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=sorting,python,list,python-3.x |>\n<code>\n\
    from statistics import median\n", "    sorted_list = sorted(l)\n    center = len(sorted_list)\
    \ // 2\n    if sorted_list[center] % 2 == 0:\n        return sorted_list[center]\
    \ // 2\n    return sorted_list[center]\n", "    half = len(l) // 2\n    if half\
    \ < 1:\n        raise MedianError(\"Can't calculate median from an empty list\"\
    )\n    if half == 0:\n        return l[0]\n    if half == len(l):\n        return\
    \ l[-1]\n    return l[half-1] + l[half]//2\n", "    if len(l) % 2 == 0:\n    \
    \    l.sort()\n        return float(l[len(l) // 2 - 1]) // 2\n    return float(l[len(l)\
    \ // 2]) // 2\n\n", "    l = sorted(l)\n    if len(l) == 0: return 0\n    if len(l)\
    \ % 2 == 0: return l[(len(l)/2)-1]\n    return 0.5 * (l[(len(l)/2)-1] + l[len(l)//2])\n\
    \n", "    l = sorted(l)\n    return l[len(l) // 2]\n", "    l = sorted(l)\n  \
    \  \n    if len(l) == 0:\n        raise ValueError('Empty list')\n    \n    if\
    \ len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l)\
    \ // 2] + l[len(l) // 2 - 1]) / 2\n</cell>\n<cell>\nmedian([3, 1, 2, 4, 5])\n\
    </cell>\n<cell>", "    sorted_list = sorted(l)\n    if len(sorted_list) == 0:\n\
    \        raise ValueError('List is empty')\n    if len(sorted_list) % 2 == 1:\n\
    \        return sorted_list[(len(sorted_list)//2)-1]\n    else:\n        a = sorted_list[(len(sorted_list)//2)-1]\n\
    \        b = sorted_list[len(sorted_list)//2]\n    return 0.5 * (a + b)\n", " \
    \   l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n  \
    \  if len(l) % 2 == 0:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) /\
    \ 2\n    ", "    return statistics.median(l)\n", "    return statistics.median(l)\n",
  "    # https://wiki.python.org/moin/HowTo/Sorting\n    return sorted(l)[-1:][0]\n",
  "    l = sorted(l)\n    if len(l) <= 1:\n        return l[0]\n    else:\n      \
    \  mid = len(l) // 2\n        return (l[mid-1] + l[mid]) / 2\n", "    sorted_list\
    \ = sorted(l)\n    mid = sorted_list[0] + ((sorted_list[1] - sorted_list[0])/2)\n\
    \    return sorted_list[mid]\n", "    sortedL = list(l)\n    sortedL.sort()\n\
    \    n = len(sortedL)\n    if n % 2 == 1:\n        return sortedL[n//2]\n    else:\n\
    \        a = sortedL[(n//2) - 1]\n        b = sortedL[n//2]\n    mid = (a + b)\
    \ // 2\n    if mid > 0 and (a <= l[mid] < b):\n        return mid\n    if mid\
    \ < len(l) and (l[mid] <= a <= b):\n        return mid\n    if mid > 0 and (a\
    \ <= l[mid] < b):\n        return mid\n    if mid < len(l) and (l[mid] <= a <=\
    \ b):\n        return mid\n    if mid < len(l) and (l[mid] <= a <= b):\n     \
    \   return mid\n", "    l = list(sorted(l))\n    n = len(l)\n    if n % 2:\n \
    \       return (l[n//2]+l[n//2-1])/2.0\n    else:\n        return l[n//2]\n  \
    \      ", "    n = len(l)\n    mid = (n+1)//2\n    if n % 2 == 1:\n        return\
    \ l[mid]\n    else:\n        return (l[mid-1] + l[mid])/2\n    \n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
