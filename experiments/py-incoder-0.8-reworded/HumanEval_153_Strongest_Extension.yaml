name: HumanEval_153_Strongest_Extension
language: py
prompt: "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions:\
  \ List[str]) -> str:\n    \"\"\"You will be given the name of a class (a string)\
  \ and a list of extensions.\n    The extensions are to be used to load additional\
  \ classes to the class. The\n    strength of the extension is as follows: Let CAP\
  \ be the number of the uppercase\n    letters in the extension's name, and let SM\
  \ be the number of lowercase letters \n    in the extension's name, the strength\
  \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
  \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
  \    If there are two or more extensions with the same strength, you should\n  \
  \  choose the one that comes first in the list.\n    For example, if you are given\
  \ \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese',\
  \ 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
  \ is the strongest extension \n    (its strength is -1).\n    Example:\n    >>>\
  \ Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n    'my_class.AA'\n    \"\
  \"\"\n"
tests: "def check(candidate):\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe'])\
  \ == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe',\
  \ '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t',\
  \ 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n\
  \    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert\
  \ candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert\
  \ candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n\
  \    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\
  \    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp',\
  \ ['671235', 'Bb']) == 'Sp.671235'\n\ndef test_check():\n    check(Strongest_Extension)\n\
  \ntest_check()\n"
completions: ["    Strongest_Ext = class_name.split('.') \n    Strongest_Ext = '.'.join(Strongest_Ext)\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.lower()\n\
    \    Strongest_Ext = Strongest_Ext.upper()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    Strongest_Ext = Strongest_Ext.lower()\n    Strongest_Ext = Strongest_Ext.upper()\n\
    \    Strongest_Ext = Strongest_Ext.split()\n    Strongest_Ext = Strongest_Ext[0]\n\
    \    ", "    \n    counts = Counter(extensions)\n    if counts['A'] > counts['B']\
    \ and counts['B'] > counts['C']: \n        if counts['A'] == counts['B']: \n \
    \           if counts['B'] == counts['C']: \n                return class_name\n\
    \            return f\"{class_name}.{counts['A']}-{counts['C']}\"\n        return\
    \ f\"{class_name}.{counts['A']}-{counts['B']}\"\n    return class_name\n", '    ',
  "    \n    extension_count = 0\n    \n    for extension in extensions:\n       \
    \ extension_count += 1\n        if extension.count(extension[0].upper()) > extension_count:\n\
    \            break\n        if extension.count(extension[0].lower()) > extension_count:\n\
    \            break\n    \n    return f\"{class_name}.{extensions[0][0].upper()\
    \ + extension_count}{extensions[0][1:]}\"\n\n", "    # Your code here\n    \n\
    \    number_of_upper_case_letters = 0\n    number_of_lower_case_letters = 0\n\
    \    strongest = \"\"\n    for ext in extensions:\n        number_of_upper_case_letters\
    \ += ext.count(ext.upper())\n        number_of_lower_case_letters += ext.count(ext.lower())\n\
    \    \n    frac = number_of_upper_case_letters - number_of_lower_case_letters\n\
    \    if frac > 0:\n        strongest = class_name + \".\" + extensions[frac.index(frac)].lower()\n\
    \    else:\n        strongest = class_name + \".\" + extensions[0].lower()\n \
    \   return strongest\n</cell>\n<text>\nExpected Result\nIf the given classes are\
    \ ['Slice', 'Hairy'], the function should return 'Slice.Hairy' as your strongest\
    \ extension.\n\n\n</text>\n<cell>", "    return '.'.join([class_name, extensions[0]])\n",
  "    # Define a list with all possible extensions of the class we want\n    allExtensions:\
    \ List[str] = [\"\"]\n    for ext in extensions:\n        allExtensions.append(class_name\
    \ + ext)\n    # Define a list to store the sorted extension list\n    allExtensions.sort(key=lambda\
    \ x:x.lower())\n    # Define a list to store the list with the extensions already\
    \ used\n    usedExtensions: List[str] = []\n    # Define a variable to store the\
    \ extensions with the same strongest strength\n    bestStrength: str = \"\"\n\
    \    # Iterate over the extension list\n    for extension in allExtensions:\n\
    \        # If the extension already has been used, we skip it\n        if extension\
    \ in usedExtensions:\n            continue\n        # If the extension has a lower\
    \ strength we skip it\n        if extension.lower() != class_name:\n         \
    \   continue\n        # If the extension has a lower strength we skip it\n   \
    \     if extension.lower() != class_name:\n            continue\n        # If\
    \ the extension is not the same as the class we want\n        if extension !=\
    \ class_name:\n            # If the extension is stronger, we add it to the best\
    \ list with the \n            # same strength\n            if extension.upper()\
    \ < bestStrength:\n                bestStrength = extension.upper()\n        #\
    \ If the extension is stronger, we add it to the best list with the \n       \
    \ # same strength\n        if extension.upper() > bestStrength:\n            bestStrength\
    \ = extension.upper()\n        # If the extension is the same as the class we\
    \ want, we add it to the used list\n        usedExtensions.append(extension)\n\
    \    # Return the best extension\n    return bestStrength\n", "    return '.'.join((class_name,\
    \ '.'.join(sorted(extensions))))\n", "    \n    \n    \n    pass\n\n", "    count\
    \ = {}\n    for extension in extensions:\n        count[extension] = count.get(extension,\
    \ 0) + 1\n\n    strength = max(count.values())\n    return f\"{class_name}.{extensions[0]}\"\
    \ if strength == 1 else f\"{class_name}.{extensions[0]}.{extensions[1]}\" if strength\
    \ > 1 and len(extensions) > 2 else f\"{class_name}.{extensions[0]}\"\n</cell>\n\
    <cell>\nassert Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    assert Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    assert Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    assert Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    </cell>\n<text>\nImplement the strongest method of the class (docstring). The\
    \ class definition should be provided in the next cell. The strongest method should\
    \ return a list of 2 strings: the first string should be the name of a class,\
    \ and the second string should be the name of the strongest extension.\nIf the\
    \ list is empty, return an empty list [].\nIf the list is non empty and the first\
    \ string does not end with the extension name at the end of the first string (for\
    \ example, if 'my_class' == 'my_class1'), return an empty list [].\nIf the list\
    \ is non empty and the first string does end with the extension name at the end\
    \ of the first string (for example, if 'my_class' == 'my_class1.A'), return an\
    \ empty list [].\nIf the list is non empty and the first string does not end with\
    \ the extension name at the end of the second string (for example, if 'my_class'\
    \ == 'my_class1'), return an empty list [].\nIf the list is non empty and the\
    \ first string does end with the extension name at the end of the second string\
    \ (for example, if 'my_class' == 'my_class1.A'), return an empty list [].\nIf\
    \ the list is non empty and the first string ends with the extension name at the\
    \ end of the first string and does not end with the extension name at the end\
    \ of the second string (for example, if 'my_class' == 'my_class1.A'), return an\
    \ empty list [].\nIf the list is non empty and the first string ends with the\
    \ extension name at the end of the second string and does not end with the extension\
    \ name at the end of the first string (for example, if 'my_class' == 'my_class1.A'),\
    \ return an empty list [].\nIf the list is non empty and the first string ends\
    \ with the extension name at the end of the second string and does end with the\
    \ extension name at the end of the first string (for example, if 'my_class' ==\
    \ 'my_class1.A.'), return an empty list [].\nIf the list is non empty and the\
    \ first string ends with the extension name at the end of the second string and\
    \ does end with the extension name at the end of the second string (for example,\
    \ if 'my_class' == 'my_class1.A.'), return an empty list [].\n", "    counts =\
    \ Counter(extension.lower() for extension in extensions)\n    return '.'.join([class_name,\
    \ extensions[0]]) if counts.most_common(1)[0][0] == 'A' else '{}.{}'.format(class_name,\
    \ extensions[0])\n\n", "    \n    extensions = ''.join(extensions)\n    count\
    \ = {}\n    for extension in extensions:\n        count[extension] = count.getdefault(extension,\
    \ 0) + 1\n    \n    sorted_count = sorted(count.items(), key=lambda kv: kv[1],\
    \ reverse=True)\n    strongest = sorted_count[0][0]\n    \n    return class_name\
    \ + '.' + strongest.lower()\n\n", "    \n    return \"\".join([class_name, '.'.join(sorted(extensions,\
    \ key=lambda x: int(x[0]))[-1])])\n</cell>\n<cell>", "    \n    count_upper =\
    \ 0\n    count_lower = 0\n    for extension in extensions:\n        if extension.istitle():\n\
    \            count_upper += 1\n        else:\n            count_lower += 1\n \
    \   \n    count_upper = count_upper + len(extensions) - count_lower\n    \n  \
    \  strength_up = 0\n    strength_low = 0\n    for extension in extensions:\n \
    \       if extension.istitle():\n            strength_up += 1\n        else:\n\
    \            strength_low += 1\n    \n    strength_up = count_upper - strength_low\n\
    \    \n    if strength_up != 0:\n        extension = extensions[strength_up]\n\
    \        return f\"{class_name}.{extension}\"\n    else:\n        return class_name\n\
    \        ", "    extension_numbers = []\n    for extension in extensions:\n  \
    \      extension_numbers.append(find_number_from_extension(extension))\n    extension_numbers.sort(reverse=True)\n\
    \    for extension_number in extension_numbers:\n        if extension_number >\
    \ 0 and extension_number < len(class_name) - 1:\n            break\n    return\
    \ f'{class_name}#{extension_number}'\n", "    if len(class_name) < 2:\n      \
    \  return class_name\n    str_exts = set([name.lower()\n                     for\
    \ name in extensions\n                     if len(name) > 0 and name.upper() !=\
    \ name])\n    strongest_ext = ''\n    sm = 0\n    for ext in str_exts:\n     \
    \   if ext.isupper():\n            sm += 1\n        else:\n            sm = len(ext)\
    \ - sm\n        if sm > strongest_ext:\n            strongest_ext = ext\n    return\
    \ f'{class_name.lower()}.{strongest_ext.lower()}'\n\n", "    cap_sum = 0\n   \
    \ str_sum = 0\n    for extension in extensions:\n        cap_sum += extension.count(\"\
    A\")\n        cap_sum += extension.count(\"B\")\n        cap_sum += extension.count(\"\
    C\")\n        str_sum += extension.count(\"a\")\n        str_sum += extension.count(\"\
    b\")\n        str_sum += extension.count(\"c\")\n    \n    if cap_sum > str_sum:\n\
    \        return f\"{class_name}.{extensions[0]}\"\n    else:\n        return f\"\
    {class_name}.{extensions[-1]}\"\n        ", "    len_str = len(class_name)\n \
    \   name_class = class_name[0].upper() + class_name[1:len_str + 1].lower()\n \
    \   len_extensions = len(extensions)\n    name_extension = extensions[0]\n   \
    \ count = 0\n    count_total = 0\n    count_upper = 0\n    count_lower = 0\n\n\
    \    for c in name_extension:\n        count_upper += 1 if c.isupper() else 0\n\
    \        count_lower += 1 if c.islower() else 0\n        count += 1\n        count_total\
    \ += 1 if c.isupper() else 0\n    \n    if count_total == 0:\n        count =\
    \ len_extensions\n    else:\n        count =  len_extensions - count_total \n\
    \    \n    if count == 0:\n        return class_name + \".\" + name_extension\n\
    \    \n    if count_upper >= count:\n        return class_name + \".\" + name_extension\n\
    \    else:\n        index_upper = count - count_upper\n        index_lower = count_lower\n\
    \        index_total = 0\n\n        for i in range(len_extensions):\n        \
    \    index_total += 1 if extensions[i].islower() else 0\n            if index_total\
    \ > index_upper:\n                index_upper = index_total\n            if index_total\
    \ < index_lower:\n                index_lower = index_total\n    \n        if\
    \ index_upper >= index_lower:\n            return class_name + \".\" + name_extensions[index_lower]\
    \ + \".\" + name_extension\n        else:\n            return class_name + \"\
    .\" + name_extensions[index_upper]\n", "    pass\n", "    extensions_dict = dict()\n\
    \    count = 0\n    for extension in extensions:\n        extensions_dict[extension.lower()]\
    \ = count\n        count += 1\n    strongest_extension = []\n    for extension\
    \ in extensions_dict:\n        extension_length = len(extension)\n        extension_strength\
    \ = extensions_dict[extension] - extension_length\n        if extension_strength\
    \ < 0:\n            extension_strength = 0\n        if extension_strength == 0\
    \ and extension_length > len(strongest_extension):\n            strongest_extension\
    \ = extension\n    return '.'.join(class_name.split('.')[:-1] + [strongest_extension])\n\
    </cell>\n<cell>\nfrom notebooks.common import print_statement\nprint_statement(Strongest_Extension(class_name='Slices',\
    \ extensions=['SErviNGSliCes', 'Cheese', 'StuFfed']))\nprint_statement(Strongest_Extension(class_name='Slices',\
    \ extensions=['AA', 'Be', 'CC']))\nprint_statement(Strongest_Extension(class_name='Slices',\
    \ extensions=['T', 'H', 'T']))\nprint_statement(Strongest_Extension(class_name='Slices',\
    \ extensions=['SErviNGSliCes', 'Cheese']))\nprint_statement(Strongest_Extension(class_name='Slices',\
    \ extensions=['AA', 'Be']))\nprint_statement(Strongest_Extension(class_name='Slices',\
    \ extensions=['T', 'H', 'K']))\n</cell>\n<text>\n4.4 Add an Extension\nNow that\
    \ we have an extension function we can add it to the class. For this problem,\
    \ you need to use the 'classmethod' decorator to tell Python that this method\
    \ is to be used as an extension for that class. Now all you need to do is use\
    \ the function we just wrote, passing in the class name as the first parameter,\
    \ and the list of extensions names as the second parameter. Remember that when\
    \ you use 'classmethod' you pass along two arguments: the class name, and the\
    \ list of extensions. In the code below you will see how this is done.\n\n\n</text>\n\
    <cell>\nfrom notebooks.common import print_statement\nprint_statement(AddExtension('Slices',\
    \ extensions=['SErviNGSliCes', 'Cheese', 'StuFfed']))\nprint_statement(AddExtension('Slices',\
    \ extensions=['AA', 'Be', 'CC']))\nprint_statement(AddExtension('Slices', extensions=['T',\
    \ 'H', 'T']))\nprint_statement(AddExtension('Slices', extensions=['SErviNGSliCes',\
    \ 'Cheese']))\nprint_statement(AddExtension('Slices', extensions=['AA', 'Be']))\n\
    print_statement(AddExtension('Slices', extensions=['T', 'H', 'K']))\n</cell>\n\
    <text>\n4.5 Remove "]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
