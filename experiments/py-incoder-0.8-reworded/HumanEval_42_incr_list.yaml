name: HumanEval_42_incr_list
language: py
prompt: "from typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n  \
  \  \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n\
  \    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6,\
  \ 3, 4, 4, 10, 1, 124]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3,\
  \ 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6,\
  \ 3, 6, 3, 4, 4, 10, 1, 124]\n\ndef test_check():\n    check(incr_list)\n\ntest_check()\n"
completions: ["    return list(map(lambda i: i + 1, l))\n", "    l2 = []\n    for\
    \ x in l:\n        l2.append(x+1)\n    return l2\n", "    result = []\n    for\
    \ i in l:\n        result.append(i + 1)\n    return result\n", "    l = list(l)\n\
    \    l.append(l[-1] + 1)\n    return l\n", "    return list(chain.from_iterable((i,)\
    \ for i in l))\n</cell>\n<cell>\nimport doctest\ndoctest.testmod(verbose=1)\n\
    </cell>\n<cell>", "    l = l + [0]\n    for i in range(len(l)):\n        l[i+1]\
    \ = l[i] + 1\n    return l\n", "    result = [l[0]]\n    for i, e in enumerate(l[1:]):\n\
    \        result.append(e + result[-1])\n    return result + [l[-1]]\n\n", "  \
    \  if l:\n        first = l[0]\n        return [first] + incr_list(l[1:])\n  \
    \  else:\n        return l\n", "    for i in range(len(l)):\n        l[i] += 1\n\
    \    return l\n", "    res = []\n    for i in range(len(l)):\n        res.append(l[i]\
    \ + 1)\n    return res\n", "    def incr_recursive(index: int, value: int) ->\
    \ List[int]:\n        \"\"\"Recursively increments value at index.\"\"\"\n   \
    \     if index == len(l):\n            return [l[-1] + 1, l[-1]]\n        else:\n\
    \            return incr_recursive(index+1, value) + [l[index] + 1, l[index]]\n\
    \n    indexes = list(range(len(l)))\n    random.shuffle(indexes)\n    return [incr_recursive(index)\
    \ for index in indexes]\n\n", "    l.sort()\n    if not l:\n        return []\n\
    \    if l[0] == l[-1]:\n        l *= 2\n    return l[:-1] + [1 + l[-1]]\n", " \
    \   for num in l:\n        if num >= 0:\n            num += 1 \n        else:\n\
    \            num -= 1 \n    return l\n\n", "    result = []\n    \n    for i in\
    \ l:\n        result.append(i+1)\n        \n    return result\n", "    res = 0\n\
    \    tail = l\n    tail.append(0)\n    for i in reversed(tail):\n        res +=\
    \ i\n    return res\n", "    for i, x in enumerate(l):\n        l[i] += x\n  \
    \  return l\n", "    l = l + [0] * (len(l) - len(l) % 2)\n    for i in range(0,\
    \ len(l), 2):\n        l[i] += l[i + 1]\n        l[i + 1] = 0\n    return l\n",
  "    res = []\n    i = 0\n    while i < len(l):\n        res.append(l[i]+1)\n  \
    \      i += 1\n    return res\n", "    for i in range(len(l)):\n        l[i+1]\
    \ += 1\n    return l\n", "    n = 0\n    length = len(l)\n    while n < length:\n\
    \        l[n] += 1\n        n += 1\n    return l\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
