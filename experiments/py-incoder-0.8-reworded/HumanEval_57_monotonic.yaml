name: HumanEval_57_monotonic
language: py
prompt: "from typing import List\n\ndef monotonic(l: List[int]) -> bool:\n    \"\"\
  \"Return True is list elements are monotonically increasing or decreasing.\n   \
  \ >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n  \
  \  False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert\
  \ candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n\
  \    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0])\
  \ == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1,\
  \ 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\ndef test_check():\n\
  \    check(monotonic)\n\ntest_check()\n"
completions: ["    if len(l) < 2:\n        return True\n    i = 2\n    last, cur,\
    \ val = l[0], l[1], l[0]\n    while i < len(l):\n        i += 1\n        last,\
    \ cur, val = cur, cur + l[i], val + l[i]\n        if last <= cur:\n          \
    \  return False\n    return True\n", "    return all(x > y for x, y in zip(l,\
    \ l[1:]))\n", "    l = list(l)\n    l = l[1:] if l[0] > l[-1] else l\n    return\
    \ all((l[i] <= l[i+1]) for i in range(len(l)-1))\n", "    if len(l) < 2:\n   \
    \     return True\n    return l[0] == min(l[:-1]) and all(l[i] >= l[i + 1] for\
    \ i in range(len(l) - 1))\n", "    if len(l) < 2:\n        return True\n    return\
    \ all(x > l[-1] for x in l) or all(x < l[0] for x in l)\n\n", "    mini, maxi\
    \ = l[0], l[-1]\n    if mini > maxi:\n        return True\n    elif mini == maxi:\n\
    \        return l[1:-1] < l[:-2] or l[1:-1] > l[2:]\n    else:\n        return\
    \ False\n", "    for i in range(len(l) - 1, -1, -1):\n        if not l[i]:\n \
    \           return True\n        if not l[i-1]:\n            return False\n  \
    \      if l[i] < l[i-1]:\n            return False\n    return True\n\n", "  \
    \  if len(l) <= 1:\n        return True\n    decreasing_elements = l[:-1][::-1]\n\
    \    increasing_elements = l[1:]\n    return all(x < y for x, y in zip(increasing_elements,\
    \ decreasing_elements))\n", "    for pos, element in enumerate(l):\n        if\
    \ element == l[pos]:\n            continue\n        if element < l[pos]:\n   \
    \         return False\n    return True\n", "    for i in range(len(l) - 1):\n\
    \        if l[i+1] < l[i]:\n            return False\n    return True\n", "  \
    \  diff = 0\n    for i in range(len(l)-1):\n        diff += (l[i]-l[i+1]) * (l[i+1]-l[i+2])\n\
    \    return diff == 0\n", "    n = len(l)\n    left, right = l[0], l[1]\n    for\
    \ i in range(2, n):\n        if l[i] < left: return False\n        if l[i] > right:\
    \ return False\n    return True\n    ", "    if len(l) < 2:\n        return True\n\
    \    i = 0\n    j = -1\n    while i < len(l):\n        while j >= 0 and l[i] ==\
    \ l[j]:\n            j += 1\n        i += 1\n        if j == -1 or l[i] == l[j+1]:\n\
    \            return True\n    return False\n", "    n = len(l)\n    if n < 2:\n\
    \        return True\n    if n == 1:\n        return True\n    return all(l[i-1]\
    \ <= l[i] <= l[i+1] for i in range(1, n-1))\n</code>\n<|/ a tags=algorithm,python\
    \ |>\n<| c |>\nCan you please explain a bit why you think this would be preferable?\n\
    <|/ c |>\n<| c |>\nThis algorithm is not O(n), it is O(n^2).\n<|/ c |>\n<| c |>\n\
    I assume that the first `n-2` iterations are O(n) and the second iteration will\
    \ be O(1) since we know from the beginning that the list has at least three elements.\
    \ But this is just an assumption.\n<|/ c |>\n<| c |>\nThe first `n/2` iterations\
    \ should be O(n) since each iteration is independent of the previous iteration\
    \ - that is, the complexity is O(n).\n<|/ c |>\n<| a tags=algorithm,python |>\n\
    This solution only works on sorted list.\n<code>", "    return all(a < b for a,\
    \ b in zip(l, l[1:]))\n", "    # https://en.wikipedia.org/wiki/Monotonic_array\n\
    \    sorted_list = sorted(l)\n    return all([x > sorted_list[0] for x in sorted_list[1:]])\n",
  "    \n    prev_val, current_val = 0, 1\n    for x in l:\n        prev_val, current_val\
    \ = current_val, x - prev_val\n        if prev_val >= current_val:\n         \
    \   return True\n    return False\n</cell>\n<cell>", "    if len(l) < 3:\n   \
    \     return False\n    direction = l[1] - l[0]\n    for idx in range(1, len(l)\
    \ - 1):\n        if l[idx] < l[idx - 1] and l[idx] < l[idx + 1]:\n           \
    \ continue\n        if l[idx] > l[idx - 1] and l[idx] > l[idx + 1]:\n        \
    \    direction += 1\n        elif l[idx] < l[idx - 1] and l[idx] > l[idx + 1]:\n\
    \            direction -= 1\n        elif l[idx] == l[idx - 1]:\n            direction\
    \ = -1\n        elif l[idx] == l[idx + 1]:\n            direction = 1\n      \
    \  else:\n            return False\n    if direction > 0:\n        return True\n\
    \    return False\n", "    if len(l) < 2:\n        return True\n    v = l[0]\n\
    \    for i in range(1, len(l)):\n        if v > l[i]:\n            return False\n\
    \        elif v < l[i-1]:\n            return True\n        v = l[i]\n    return\
    \ True\n", "    if len(l) < 2: return False\n    return all(x<=y<y for x, y in\
    \ zip(l, l[1:]))\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
