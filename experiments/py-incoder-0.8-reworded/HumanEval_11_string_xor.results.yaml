language: py
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    if len(a) != len(b):\n        raise ValueError('Unequal lengths\
    \ for XOR')\n    result = \"\"\n    for ai, bi in zip(a, b):\n        result +=\
    \ '1' if ai != bi else '0'\n    return result\n\ndef check(candidate):\n    assert\
    \ candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') ==\
    \ '0'\n    assert candidate('0101', '0000') == '0101'\n\ndef test_check():\n \
    \   check(string_xor)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    if len(a) != len(b):\n        raise Exception(f\"Inputs must\
    \ have the same length, got {len(a)} and {len(b)}\")\n    a_len = len(a)\n   \
    \ result_len = a_len\n    for i in range(result_len):\n        if a[i] != b[i]:\n\
    \            result_len = result_len - 1\n            result_str = a[:result_len]\n\
    \    return result_str\n\n\ndef check(candidate):\n    assert candidate('111000',\
    \ '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101',\
    \ '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp37xcirrt.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmp37xcirrt.py\", line 24,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmp37xcirrt.py\", line 19,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return ''.join(map(str, map(str.lower, zip(a, b))))\n\n\ndef\
    \ check(candidate):\n    assert candidate('111000', '101010') == '010010'\n  \
    \  assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1q48kqab.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp1q48kqab.py\", line 16,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmp1q48kqab.py\", line 11,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\n  File \"/tmp/tmp1q48kqab.py\"\
    , line 7, in string_xor\n    return ''.join(map(str, map(str.lower, zip(a, b))))\n\
    TypeError: descriptor 'lower' for 'str' objects doesn't apply to a 'tuple' object\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 0
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] !=\
    \ b[i]:\n            result += \"1\"\n        else:\n            result += \"\
    0\"\n    return result\n\n\ndef check(candidate):\n    assert candidate('111000',\
    \ '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101',\
    \ '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return bin(int(a, 2) ^ int(b, 2)).zfill(4)\n\n\ndef check(candidate):\n\
    \    assert candidate('111000', '101010') == '010010'\n    assert candidate('1',\
    \ '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n\ndef test_check():\n\
    \    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpthljakvk.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmpthljakvk.py\", line 16,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpthljakvk.py\", line 11,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    if any(len(i) != 1 for i in [a, b]):\n        raise ValueError(\n\
    \            \"XOR function input strings need to be exactly one character long\"\
    )\n\n    a, b = int(bin(int(a), 2) + int(b, 2), 2)\n    return bin(a)[2:].zfill(8)\
    \ + str(b)\n\n\ndef check(candidate):\n    assert candidate('111000', '101010')\
    \ == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101',\
    \ '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjc1e7usr.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpjc1e7usr.py\", line 21,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpjc1e7usr.py\", line 16,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\n  File \"/tmp/tmpjc1e7usr.py\"\
    , line 8, in string_xor\n    raise ValueError(\nValueError: XOR function input\
    \ strings need to be exactly one character long\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    assert (len(a) == len(b))\n    return ''.join([chr(ord(a[i] -\
    \ b[i]) ^ ord(' ')) for i in range(len(a))])\n\ndef check(candidate):\n    assert\
    \ candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') ==\
    \ '0'\n    assert candidate('0101', '0000') == '0101'\n\ndef test_check():\n \
    \   check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw4wcq5yz.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmpw4wcq5yz.py\", line 16,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpw4wcq5yz.py\", line 11,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\n  File \"/tmp/tmpw4wcq5yz.py\"\
    , line 8, in string_xor\n    return ''.join([chr(ord(a[i] - b[i]) ^ ord(' '))\
    \ for i in range(len(a))])\n  File \"/tmp/tmpw4wcq5yz.py\", line 8, in <listcomp>\n\
    \    return ''.join([chr(ord(a[i] - b[i]) ^ ord(' ')) for i in range(len(a))])\n\
    TypeError: unsupported operand type(s) for -: 'str' and 'str'\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 0
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return ''.join([str(int(i1) ^ int(i2)) for i1,i2 in zip(a,b)])\n\
    \ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return \"\".join([chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a))])\n\
    \ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpddlyr67x.py\", line\
    \ 17, in <module>\n    test_check()\n  File \"/tmp/tmpddlyr67x.py\", line 15,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpddlyr67x.py\", line 10,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return \"\".join((chr(ord(a)^ord(b)) for a, b in zip(a, b)))\n\
    \ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbwfo8nn2.py\", line\
    \ 17, in <module>\n    test_check()\n  File \"/tmp/tmpbwfo8nn2.py\", line 15,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpbwfo8nn2.py\", line 10,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    a = a[::-1]\n    b = b[::-1]\n    res = \"\"\n    # xor1 is the\
    \ same as xor(a[i], b[i]) if i is 0\n    xor1 = \"\".join(map(lambda x: x ^ a[i],\
    \ b)) if i < len(b) else a\n    xor2 = \"\".join(map(lambda x: x ^ b[i], a)) if\
    \ i < len(a) else b\n    res = xor1 + \"0\" if len(xor1) == 1 else \"1\" + xor2\n\
    \    # xor2 is the same as xor(a[i], b[i]) if i is 1\n    xor1 = \"\".join(map(lambda\
    \ x: x ^ b[i], a)) if i < len(a) else b\n    xor2 = \"\".join(map(lambda x: x\
    \ ^ a[i], b)) if i < len(b) else a\n    res = res + \"1\" if len(xor2) == 1 else\
    \ \"0\" + xor1\n    return res[::-1]\n</cell>\n<cell>\nstring_xor(\"0000\", \"\
    1000\")\n</cell>\n<cell>\nstring_xor(\"0000\", \"1001\")\n</cell>\n<cell>\nstring_xor(\"\
    0100\", \"1001\")\n</cell>\n<cell>\nstring_xor(\"0000\", \"1111\")\n</cell>\n\
    <cell>\nstring_xor(\"0000\", \"1111\")\n</cell>\n<cell>\nstring_xor(\"0100\",\
    \ \"1111\")\n</cell>\n<cell>\nstring_xor(\"0000\", \"10\")\n</cell>\n<cell>\n\
    string_xor(\"0000\", \"11\")\n</cell>\n<cell>\nstring_xor(\"0100\", \"11\")\n\
    </cell>\n<cell>\nstring_xor(\"0000\", \"1010\")\n</cell>\n<cell>\nstring_xor(\"\
    0000\", \"1011\")\n</cell>\n<cell>\nstring_xor(\"0100\", \"1011\")\n</cell>\n\
    <cell>\nstring_xor(\"0000\", \"10101\")\n</cell>\n<cell>\nstring_xor(\"0000\"\
    , \"10110\")\n</cell>\n<cell>\nstring_xor(\"0000\", \"10111\")\n</cell>\n<cell>\n\
    string_xor(\"0100\", \"10111\")\n</cell>\n<cell>\nstring_xor(\"0000\", \"101010\"\
    )\n</cell>\n<cell>\nstring_xor(\"0000\", \"101011\")\n</cell>\n<cell>\nstring_xor(\"\
    0100\", \"101011\")\n</cell>\n<cell>\nstring_xor(\"0000\", \"101011\")\n</cell>\n\
    <cell>\nstring_xor(\"0000\", \"101010\")\n</cell>\n<cell>\nstring_xor(\"\ndef\
    \ check(candidate):\n    assert candidate('111000', '101010') == '010010'\n  \
    \  assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmp119igrdq.py\", line 84\n    string_xor(\"\n          \
    \     ^\nSyntaxError: unterminated string literal (detected at line 84)\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return \"\".join([chr(int(b[i]) ^ int(a[i])) for i in range(len(b))])\n\
    \ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpuik6cf1v.py\", line\
    \ 17, in <module>\n    test_check()\n  File \"/tmp/tmpuik6cf1v.py\", line 15,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpuik6cf1v.py\", line 10,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 0
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    result = \"\"\n    for idx in range(len(a)):\n        if a[idx]\
    \ == b[idx]:\n            result += '0'\n        else:\n            result +=\
    \ '1'\n    return result\n\ndef check(candidate):\n    assert candidate('111000',\
    \ '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101',\
    \ '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823062
- exit_code: 1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return ''.join((a != b) for a in a, b != a)\n\n\ndef check(candidate):\n\
    \    assert candidate('111000', '101010') == '010010'\n    assert candidate('1',\
    \ '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n\ndef test_check():\n\
    \    check(string_xor)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpx9mxifms.py\", line 7\n    return ''.join((a != b) for\
    \ a in a, b != a)\n                    ^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator\
    \ expression must be parenthesized\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return ''.join([chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a))])\n\
    \ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5uf82_ot.py\", line\
    \ 17, in <module>\n    test_check()\n  File \"/tmp/tmp5uf82_ot.py\", line 15,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmp5uf82_ot.py\", line 10,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    assert len(a) == len(b)\n    return ''.join('1' if c == '0' else\
    \ '0' for c in a) ^ ''.join(\n        '1' if c == '0' else '0' for c in b)\n\n\
    \ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9wg19nnr.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmp9wg19nnr.py\", line 18,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmp9wg19nnr.py\", line 13,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\n  File \"/tmp/tmp9wg19nnr.py\"\
    , line 8, in string_xor\n    return ''.join('1' if c == '0' else '0' for c in\
    \ a) ^ ''.join(\nTypeError: unsupported operand type(s) for ^: 'str' and 'str'\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    return \"\".join([chr(ord(a) ^ ord(b)) for a, b in zip(a, b)])\n\
    \n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n\
    \    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') ==\
    \ '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9dp28f2e.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp9dp28f2e.py\", line 16,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmp9dp28f2e.py\", line 11,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    # XOR is equivalent to multiplying by two (XOR is equivalent\
    \ to adding 1 to the binary value)\n    # So each position would be multiplied\
    \ by 2 (the position's binary value + 1)\n    # e.g. '001' becomes '101' in the\
    \ above example\n    # and we could then add the strings together\n    xor = ''.join([(x\
    \ + y) for x, y in zip(a[::-1], b[::-1])])\n    return xor\n\n\ndef check(candidate):\n\
    \    assert candidate('111000', '101010') == '010010'\n    assert candidate('1',\
    \ '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n\ndef test_check():\n\
    \    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpafpzj110.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpafpzj110.py\", line 21,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpafpzj110.py\", line 16,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\nAssertionError\n"
  stdout: ''
  timestamp: 1659823062
- exit_code: 0
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] !=\
    \ b[i]:\n            result += '1'\n        else:\n            result += '0'\n\
    \    return result\n\n\ndef check(candidate):\n    assert candidate('111000',\
    \ '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101',\
    \ '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823062
- exit_code: -1
  program: "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n\
    \    \"\"\"\n    result = \"\"\n    for a_i, b_i in zip(a, b):\n        result\
    \ += a_i ^ b_i\n    return result\n\n\ndef check(candidate):\n    assert candidate('111000',\
    \ '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101',\
    \ '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpj9x3l8ua.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpj9x3l8ua.py\", line 19,\
    \ in test_check\n    check(string_xor)\n  File \"/tmp/tmpj9x3l8ua.py\", line 14,\
    \ in check\n    assert candidate('111000', '101010') == '010010'\n  File \"/tmp/tmpj9x3l8ua.py\"\
    , line 9, in string_xor\n    result += a_i ^ b_i\nTypeError: unsupported operand\
    \ type(s) for ^: 'str' and 'str'\n"
  stdout: ''
  timestamp: 1659823062
