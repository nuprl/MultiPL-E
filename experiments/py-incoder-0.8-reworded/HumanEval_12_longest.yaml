name: HumanEval_12_longest
language: py
prompt: "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n\
  \    \"\"\" Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n    strings of the same length. Return None in case the input\
  \ list is empty.\n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n\
  \    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x',\
  \ 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'])\
  \ == 'zzzz'\n\ndef test_check():\n    check(longest)\n\ntest_check()\n"
completions: ["    return max(strings, key = len)\n\n", "    if not strings:\n   \
    \     return None\n    return max(strings, key=len)\n", "    if not strings:\n\
    \        return None\n    return max(strings)\n", "    longest_string = strings[0]\n\
    \n    if len(strings) > 1:\n        for i in range(len(strings) - 1):\n      \
    \      current_length = len(strings[i])\n            if current_length >= len(longest_string):\n\
    \                longest_string = strings[i]\n    else:\n        return None\n\
    \n    return longest_string\n", "    if not strings:\n        return None\n  \
    \  return max(strings, key=len)\n", "    if len(strings) == 0:\n        return\
    \ None\n    return max(strings, key=len)\n\n", "    if not strings:\n        return\
    \ None\n    return max(strings, key=len)\n", "    if not strings:\n        return\
    \ None\n    return max(strings, key=len)\n\n", "    sorted_strings = sorted(strings)\n\
    \    if sorted_strings:\n        return sorted_strings[-1]\n    return None\n",
  "    if not strings:\n        return None\n    return max(strings, key=len)\n",
  "    if not strings: return None\n    lengths = [len(s) for s in strings]\n    if\
    \ len(lengths) > 1:\n        return sorted(lengths)[-1]\n    else:\n        return\
    \ strings[0]\n", "    if not strings:\n        return None\n\n    lengths = [len(s)\
    \ for s in strings]\n\n    if len(set(lengths)) > 1:\n        return strings[0]\n\
    \n    return strings[0] if lengths[0] == lengths[0] else None\n", "    return\
    \ max(strings) if strings else None # type: ignore\n", "    if strings:\n    \
    \    return max(strings, key=len)\n    else:\n        return None\n\n", "    if\
    \ not strings:\n        return None\n    return max(strings)\n", "    if len(strings)\
    \ == 0:\n        return None\n    return max(strings, key=lambda s: len(s))\n\n",
  "    if not strings:\n        return None\n    longest_string = None\n    max_length\
    \ = 0\n    for s in strings:\n        if len(s) > max_length:\n            max_length\
    \ = len(s)\n            longest_string = s\n    if longest_string is None:\n \
    \       return None\n    return longest_string\n", "    if not strings:\n    \
    \    return None\n    return max(strings, key=len)\n\n", "    if not strings:\n\
    \        return None\n    return max(strings)\n", "    if not strings:\n     \
    \   return None\n\n    max_length = float(\"-inf\")\n    max_length_index = -1\n\
    \n    for index, string in enumerate(strings):\n        if len(string) > max_length:\n\
    \            max_length = len(string)\n            max_length_index = index\n\n\
    \    return strings[max_length_index]\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
