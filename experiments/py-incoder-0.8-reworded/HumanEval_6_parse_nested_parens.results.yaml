language: py
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result: List[int]\
    \ = [0]\n    level: List[int] = [0]\n    stack: List[int] = [0]\n    \n    # Count\
    \ levels of nesting\n    for i, s in enumerate(paren_string):\n        if s ==\
    \ '(':\n            stack.append(i)\n        elif s == ')':\n            stack.pop()\n\
    \            result.append(stack[len(stack) - 1])\n            level.append(stack[len(stack)\
    \ - 1])\n        elif s == '[':\n            stack.append(i)\n        elif s ==\
    \ ']':\n            stack.pop()\n            level.append(stack[len(stack) - 1])\n\
    \    \n    # Get the deepest level of nesting\n    deepest_level = stack[len(stack)\
    \ - 1]\n    \n    # Return the maximum level of nesting found\n    return result[deepest_level]\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptw48nmgg.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmptw48nmgg.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptw48nmgg.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_depth = 0\n    open_paren_count = 0\n    for idx, char in enumerate(paren_string):\n\
    \        if char == '(':\n            open_paren_count += 1\n            paren_stack.append(idx)\n\
    \        elif char == ')':\n            open_paren_count -= 1\n            paren_depth\
    \ = max(paren_depth, open_paren_count)\n        elif char == ')' and open_paren_count\
    \ == 0:\n            paren_stack.pop()\n    return paren_depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjiicy8j2.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpjiicy8j2.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjiicy8j2.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    para_list = []\n \
    \   para_level_dict = {}\n    para_level_counter = 1\n    for char in paren_string:\n\
    \        if char == '(':\n            if para_level_counter in para_level_dict:\n\
    \                para_level_dict[para_level_counter] += 1\n            else:\n\
    \                para_level_dict[para_level_counter] = 1\n            para_level_counter\
    \ += 1\n        elif char == ')':\n            para_level_counter -= 1\n     \
    \       if para_level_counter in para_level_dict:\n                para_level_dict[para_level_counter]\
    \ += 1\n            else:\n                para_level_dict[para_level_counter]\
    \ = 1\n        if para_level_counter == 0:\n            para_list.append(para_level_dict.keys())\n\
    \            para_level_dict = {}\n            para_level_counter = 1\n    para_list.append(para_level_dict.keys())\n\
    \    return para_list\n</cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmp8tqu39ub.py\", line 33\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Convert from string\
    \ to list of characters using list comprehension\n    nested_list = []\n    for\
    \ char in paren_string:\n        if char == '(':\n            nested_list.append(1)\n\
    \        elif char == ')':\n            nested_list.pop()\n        else:\n   \
    \         nested_list.append(0)\n    return nested_list\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkge6w19g.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpkge6w19g.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkge6w19g.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # A utility function\
    \ to handle all the parsing\n    def recursive_parse(string, level, parens_count,\
    \ parens_list):\n        \"\"\" Recursively parse a string and add the parsed\
    \ parens to parens_list\n        Args:\n            string: string to be parsed\n\
    \            level: current level of nesting of parens\n            parens_count:\
    \ total count of parens in the string\n            parens_list: list to store\
    \ the parsed parens\n        \"\"\"\n        # If the string ends with a single\
    \ '(' and no matching ')' then return\n        if len(string) <= 1 and parens_count\
    \ == 1:\n            return\n        # Find the index of first ')' in the string\n\
    \        parens_index = string.rfind(')')\n        # If the string ends with a\
    \ single '(' and a matching ')' then return\n        if parens_index == 0 and\
    \ parens_count == 0:\n            return\n        # Remove the string from the\
    \ string\n        string = string[parens_index + 1 :]\n        # If the string\
    \ has more than one '(' then recurse to parse it\n        if parens_count > 0\
    \ and string != '(':\n            recursive_parse(string, level + 1, parens_count\
    \ - 1, parens_list)\n        # If the string has only one '(', then add the level\
    \ to parens_list\n        elif parens_count == 1 and string == '(':\n        \
    \    parens_list.append(level)\n        # Remove the '(' from the string\n   \
    \     string = string[:parens_index]\n        # If the string has more than one\
    \ ')' then recurse to parse it\n        if parens_count > 0 and string != '(':\n\
    \            recursive_parse(string, level + 1, parens_count - 1, parens_list)\n\
    \        # If the string has only one ')', then add the level to parens_list\n\
    \        elif parens_count == 1 and string == ')':\n            parens_list.append(level)\n\
    \        # If the string is empty, return\n        else:\n            return\n\
    \n    # Parse the string\n    parens_list = []\n    recursive_parse(paren_string,\
    \ 0, len(paren_string), parens_list)\n    # Return the paren list\n    return\
    \ parens_list\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\
    \    paren_opening = -1\n    paren_count = 0\n    paren_levels = []\n    \n  \
    \  for char in paren_string:\n        if char == '(':\n            paren_count\
    \ += 1\n            paren_level += 1\n            if paren_opening == -1:\n  \
    \              paren_opening = paren_count\n        elif char == ')':\n      \
    \      paren_count -= 1\n            if paren_count == 0:\n                paren_levels.append(paren_level)\n\
    \            elif paren_count < 0:\n                raise SyntaxError(f\"Parentheses\
    \ do not match. Expected {paren_opening} opening brackets but got {paren_count}\
    \ closing brackets\")\n            \n    return paren_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps8s1vt5d.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmps8s1vt5d.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps8s1vt5d.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    i\
    \ = 0\n\n    # Iterate through the string and find the parenthesis pairs that\
    \ represents the nested brackets\n    while i < len(paren_string):\n        if\
    \ paren_string[i] == '(':\n            stack.append(i)\n            i += 1\n \
    \       elif paren_string[i] == ')':\n            popped_stack = stack.pop()\n\
    \            assert(popped_stack > i)\n            i += popped_stack\n       \
    \ else:\n            i += 1\n\n    return stack\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpum9mhew1.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpum9mhew1.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpum9mhew1.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpum9mhew1.py\", line 21, in parse_nested_parens\n\
    \    assert(popped_stack > i)\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    left_stack = []\n\
    \    right_stack = []\n    current_index = 0\n    while current_index < len(paren_string):\n\
    \        char1 = paren_string[current_index]\n        if char1 == '(':\n     \
    \       left_stack.append(char1)\n            current_index += 1\n        elif\
    \ char1 == ')':\n            right_stack.append(char1)\n            current_index\
    \ += 1\n        elif char1 == ' ':\n            if left_stack and right_stack:\n\
    \                if left_stack[-1] != right_stack[-1]:\n                    raise\
    \ Exception('Unexpected spaces between parentheses.')\n                left_stack.pop()\n\
    \                right_stack.pop()\n            else:\n                if left_stack:\n\
    \                    raise Exception('Unexpected spaces between parentheses.')\n\
    \                else:\n                    if right_stack:\n                \
    \        raise Exception('Unexpected spaces between parentheses.')\n         \
    \           else:\n                        raise Exception('Unexpected spaces.')\n\
    \    return left_stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2tqo1sjp.py\", line\
    \ 46, in <module>\n    test_check()\n  File \"/tmp/tmp2tqo1sjp.py\", line 44,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2tqo1sjp.py\"\
    , line 39, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp2tqo1sjp.py\", line 25, in parse_nested_parens\n\
    \    raise Exception('Unexpected spaces between parentheses.')\nException: Unexpected\
    \ spaces between parentheses.\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    \n    if paren_string.count('(')\
    \ != paren_string.count(')'):\n        raise ValueError('Parentheses do not match\
    \ number of opening parentheses: {} vs {}'.format(paren_string.count('('), paren_string.count(')')))\n\
    \n    parentheses_levels = paren_string.count('(')\n    nested_levels = []\n \
    \   for i in range(parentheses_levels):\n        nested_levels.append(0)\n   \
    \ for i in range(parentheses_levels, len(paren_string)):\n        nested_levels[i-parentheses_levels]\
    \ += 1\n    \n    return nested_levels\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6vvyv6c5.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp6vvyv6c5.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6vvyv6c5.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp6vvyv6c5.py\", line 20, in parse_nested_parens\n\
    \    nested_levels[i-parentheses_levels] += 1\nIndexError: list index out of range\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    output\
    \ = []\n    paren_stack = []\n\n    for c in paren_string:\n        if c == '(':\n\
    \            paren_stack.append(c)\n        elif c == ')':\n            # Pop\
    \ the level one item off the stack\n            stack.pop()\n            paren_stack.pop()\n\
    \            output.append(len(stack))\n        elif c in ['(', ')']:\n      \
    \      # Check if the last item on the stack was an opening or closing paren\n\
    \            if len(stack) == 0 or paren_stack[-1] == '(':\n                #\
    \ If the stack is empty, we are on the outermost level\n                # Push\
    \ the level one item on the stack\n                stack.append(c)\n         \
    \   else:\n                # We are on the middle level\n                stack.pop()\n\
    \        else:\n            pass\n\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwi2c1q4o.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmpwi2c1q4o.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwi2c1q4o.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpwi2c1q4o.py\", line 20, in parse_nested_parens\n\
    \    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(map(int,\
    \ re.findall(r'\\(+|\\)+', paren_string)))\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpokyh704e.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpokyh704e.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpokyh704e.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpokyh704e.py\", line 11, in parse_nested_parens\n\
    \    return list(map(int, re.findall(r'\\(+|\\)+', paren_string)))\nNameError:\
    \ name 're' is not defined\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    depth\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            depth +=\
    \ 1\n        elif c == ')':\n            depth -= 1\n        if depth < 0:\n \
    \           break\n        level += 1\n    return level\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3_wk3l9o.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp3_wk3l9o.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3_wk3l9o.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    result\
    \ = []\n    level_stack = []\n    level_stack.append(0)\n    for char in paren_string:\n\
    \        if char == '(':\n            level_stack.append(0)\n            stack.append(char)\n\
    \        elif char == ')':\n            level_stack.pop()\n            if level_stack[len(level_stack)\
    \ - 1] == 0:\n                stack.pop()\n            else:\n               \
    \ stack.append(char)\n        elif char == ' ':\n            if len(stack) ==\
    \ 0 or stack[len(stack) - 1] != ')':\n                level_stack[len(level_stack)\
    \ - 1] += 1\n                stack.append(char)\n            else:\n         \
    \       result.append(len(level_stack))\n    return result\n</cell>\n<text>\n\
    Now, let's take a look at how this function works:\n\n\n</text>\n<cell>\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n</cell>\n<text>\nIt takes in a string representing nested\
    \ parentheses and outputs its maximum nesting level of parentheses.\nTo understand\
    \ how it works, we must first take a look at how we can write an algorithm to\
    \ determine all nested parentheses in a string.\n\n\n</text>\n<text>\nLet's look\
    \ at an example. Let's first have a look at the input string ((())):\n\n\n</text>\n\
    <cell>\ns = '((()))'\n</cell>\n<text>\nNow, let's walk through this algorithm.\n\
    \n\n</text>\n<text>\nFor the first step, we are starting from the first character\
    \ in the string. Let's start with the character '(' and let's assume that it is\
    \ open. Then the maximum nesting level of this expression is zero. We have seen\
    \ this already.\n\nNow, let's start with the character '(' and we assume that\
    \ it is also open. Then the maximum nesting level of this expression is 1. Then,\
    \ we have seen this already.\n\nNow, let's look at the character ')'. Then we\
    \ see that there are two open parentheses one next to each other and only one\
    \ close parentheses next to each other. So, we can say that this expression is\
    \ balanced. So, we can say that this expression is one level deeper.\n\nSo, our\
    \ stack would be [')'].\n\nLet's continue with the next character which is ')'.\
    \ This character is unbalanced and hence, we cannot say that it is one level deeper.\
    \ Instead, we know that this expression has maximum two levels of nesting. Hence,\
    \ the maximum nesting level of our expression is 2.\n\nSo, our stack would look\
    \ like [')', ')'].\n\n\n</text>\n<text>\nLet's continue with the next character\
    \ which is ')'. This character is also unbalanced and hence, we cannot say that\
    \ it is one level deeper. Instead, we know that this expression has maximum two\
    \ levels of nesting. Hence, the maximum nesting level of our expression is 3.\n\
    \nSo, our stack would look like [')', ')', \ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpz7sebq54.py\", line 32\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [0] * (len(paren_string)//2)\
    \ + [\n        max(sum(len(open_par) for open_par in paren_string[:i]) for i in\
    \ range(len(paren_string)//2))\n    ]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfw_lc56u.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpfw_lc56u.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfw_lc56u.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string.strip())\
    \ == 0:\n        return []\n\n    if paren_string.find('(') != -1:\n        left_parantheses_indexes\
    \ = []\n        right_parantheses_indexes = []\n        for index in range(0,\
    \ len(paren_string)):\n            if paren_string[index] == '(':\n          \
    \      left_parantheses_indexes.append(index)\n            if paren_string[index]\
    \ == ')':\n                right_parantheses_indexes.append(index)\n         \
    \   \n        left_parantheses_indexes.reverse()\n        right_parantheses_indexes.reverse()\n\
    \n        left_parantheses_indexes.append(len(paren_string))\n        right_parantheses_indexes.append(len(paren_string))\n\
    \n        left_parantheses_indexes.append(len(paren_string))\n        right_parantheses_indexes.append(len(paren_string))\n\
    \n        left_parantheses_indexes.reverse()\n        right_parantheses_indexes.reverse()\n\
    \n        final_parantheses_indexes = []\n        for left_index in range(len(left_parantheses_indexes)):\n\
    \            for right_index in range(len(right_parantheses_indexes)):\n     \
    \           final_parantheses_indexes.append(left_parantheses_indexes[left_index]\
    \ + right_parantheses_indexes[right_index])\n        return final_parantheses_indexes\n\
    \n    left_paren_levels = []\n    right_paren_levels = []\n    paren_level = 0\n\
    \n    for char in paren_string:\n        if char == '(':\n            paren_level\
    \ += 1\n        if char == ')':\n            paren_level -= 1\n        if paren_level\
    \ == -1:\n            left_paren_levels.append(len(left_paren_levels) + 1)\n \
    \       if paren_level == 0:\n            right_paren_levels.append(len(right_paren_levels)\
    \ + 1)\n            \n    left_paren_levels.reverse()\n    right_paren_levels.reverse()\n\
    \n    left_paren_levels.append(len(left_paren_levels) + 1)\n    right_paren_levels.append(len(left_paren_levels)\
    \ + 1)\n\n    left_paren_levels.reverse()\n    right_paren_levels.reverse()\n\n\
    \    final_parantheses_indexes = []\n    for left_index in range(len(left_paren_levels)):\n\
    \        for right_index in range(len(right_paren_levels)):\n            final_parantheses_indexes.append(left_paren_levels[left_index]\
    \ + right_paren_levels[right_index])\n    return final_parantheses_indexes\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqb7bbirp.py\", line\
    \ 79, in <module>\n    test_check()\n  File \"/tmp/tmpqb7bbirp.py\", line 77,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqb7bbirp.py\"\
    , line 72, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: Parsing the\
    \ string recursively and returning a list would be more robust than this\n   \
    \ # approach\n    \n    paren_level = 0\n    paren_stack = []\n    for char in\
    \ paren_string:\n        if char == '(':\n            paren_level += 1\n     \
    \       paren_stack.append(paren_level)\n        elif char == ')':\n         \
    \   paren_stack.pop()\n            if len(paren_stack) == 0:\n               \
    \ return paren_level\n            paren_level = paren_stack.pop()\n        else:\n\
    \            paren_level = paren_level\n    return []\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9lb2eb80.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp9lb2eb80.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9lb2eb80.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    for p in paren_string:\n        if p == \"(\":\n            level +=\
    \ 1\n        elif p == \")\":\n            level -= 1\n        if level < 0:\n\
    \            raise ValueError(\"String '%s' has unbalanced parentheses, not parsing\"\
    \ % paren_string)\n        stack.append(level)\n    return stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph7l2wd8n.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmph7l2wd8n.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph7l2wd8n.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack_of_chars = []\n\
    \    nested_level = 1\n    open_brackets = 0\n    close_brackets = 0\n    level\
    \ = 0\n    \n    for char in paren_string:\n        if char == '(':\n        \
    \    open_brackets = open_brackets + 1\n        elif char == ')':\n          \
    \  close_brackets = close_brackets + 1\n        elif char == ')' and open_brackets\
    \ == 0:\n            nested_level = nested_level - 1\n            open_brackets\
    \ = 0\n        elif char == '(' and open_brackets == 0:\n            nested_level\
    \ = nested_level + 1\n            open_brackets = 1\n        elif char == ')'\
    \ and close_brackets == 0:\n            nested_level = nested_level - 1\n    \
    \        close_brackets = 1\n        elif char == '(' and close_brackets == 0\
    \ and open_brackets == 1:\n            open_brackets = open_brackets - 1\n   \
    \         close_brackets = close_brackets + 1\n        elif char == ')' and close_brackets\
    \ == 0 and open_brackets == 1:\n            close_brackets = close_brackets -\
    \ 1\n            open_brackets = open_brackets - 1\n        \n        stack_of_chars.append(nested_level)\n\
    \        \n    return stack_of_chars\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjq6ztnfu.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmpjq6ztnfu.py\", line 48,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjq6ztnfu.py\"\
    , line 43, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    prev_level\
    \ = 0\n    paren_count = 0\n\n    # Iterate through each character in string.\n\
    \    for i, c in enumerate(paren_string):\n        if c == '(':\n            level\
    \ += 1\n        elif c == ')':\n            level -= 1\n        elif c == ' '\
    \ and level == 0:\n            # End of level 0 nesting.\n            paren_count\
    \ += 1\n            prev_level = level\n\n    return paren_count\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxfzmbsaa.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpxfzmbsaa.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxfzmbsaa.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    current_level\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            stack.append(current_level)\n\
    \            current_level += 1\n        elif c == ')':\n            stack.pop()\n\
    \            current_level -= 1\n    if current_level == 0:\n        raise ValueError(f\"\
    No level of nesting is found: {paren_string}\")\n    return stack\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0mmprq39.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp0mmprq39.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0mmprq39.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp0mmprq39.py\", line 21, in parse_nested_parens\n\
    \    raise ValueError(f\"No level of nesting is found: {paren_string}\")\nValueError:\
    \ No level of nesting is found: (()()) ((())) () ((())()())\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = [0 for\
    \ i in range(0, paren_string.count(')'))]\n    for i, char in enumerate(paren_string):\n\
    \        if char == '(':\n            paren_stack[paren_stack[-1]] += 1\n    \
    \    elif char == ')':\n            paren_stack[paren_stack[-1]] -= 1\n      \
    \      if paren_stack[paren_stack[-1]] == 0:\n                paren_string = paren_string[:i]\
    \ + paren_string[i+1:]\n                paren_stack = paren_stack[:paren_stack[-1]]\n\
    \                break\n    return paren_stack\n\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw35oe9m9.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpw35oe9m9.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpw35oe9m9.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_paren_levels:\
    \ List[int] = []\n    paren_level = 1\n    for paren in paren_string:\n      \
    \  if paren == \"(\":\n            paren_level += 1\n        if paren == \")\"\
    :\n            paren_level -= 1\n        parsed_paren_levels.append(paren_level)\n\
    \    return parsed_paren_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbkducxwf.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpbkducxwf.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbkducxwf.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def has_pair(parentheses,\
    \ depth):\n        open_brackets = parentheses.count('(') - parentheses.count(')')\n\
    \        close_brackets = parentheses.count(')') - parentheses.count(')')\n  \
    \      return open_brackets + close_brackets > depth\n    \n    def parse_group(parentheses,\
    \ depth):\n        if parentheses == parenthesis:\n            return []\n   \
    \     elif has_pair(parentheses, depth):\n            return parse_group(parentheses[parentheses.index('(')\
    \ + 1:parentheses.index(')'), depth - 1], depth)\n        else:\n            return\
    \ [depth]\n\n    return parse_group(paren_string, 1)\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpihipbnpt.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpihipbnpt.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpihipbnpt.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpihipbnpt.py\", line 24, in parse_nested_parens\n\
    \    return parse_group(paren_string, 1)\n  File \"/tmp/tmpihipbnpt.py\", line\
    \ 17, in parse_group\n    if parentheses == parenthesis:\nNameError: name 'parenthesis'\
    \ is not defined. Did you mean: 'parentheses'?\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = []\n\
    \    open_paren_count = 0\n    current_level = 0\n    current_level_num = 0\n\
    \    has_closed_parentheses = False\n    for c in paren_string:\n        if c\
    \ == \"(\":\n            open_paren_count += 1\n            current_level += 1\n\
    \            current_level_num += 1\n        elif c == \")\":\n            if\
    \ open_paren_count == 0:\n                # This could be either a nested parenthesis\
    \ that hasn't closed yet or it was already closed.\n                # We return\
    \ 0 if we are in the first case or 1 if we are in the second case.\n         \
    \       return [0] * (current_level + 1) + [1] * (current_level_num + 1)\n   \
    \         else:\n                current_level -= 1\n                current_level_num\
    \ -= 1\n        elif c == \" \" and open_paren_count == 0:\n            # This\
    \ could be either a nested parenthesis that hasn't closed yet or it was already\
    \ closed.\n            # We skip this whitespace if there are no parentheses.\n\
    \            current_level_num += 1\n        elif c == \" \" and not has_closed_parentheses\
    \ and open_paren_count == 0:\n            # This could be either a nested parenthesis\
    \ that hasn't closed yet or it was already closed.\n            # We skip this\
    \ whitespace if there are no parentheses.\n            current_level_num += 1\n\
    \        else:\n            # This could be either a nested parenthesis that hasn't\
    \ closed yet or it was already closed.\n            # We return 0 if we are in\
    \ the first case or 1 if we are in the second case.\n            return [0] *\
    \ (current_level + 1) + [1] * (current_level_num + 1)\n\n        group_list.append(current_level_num)\n\
    \n    return group_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx7gjb9sx.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpx7gjb9sx.py\", line 53,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpx7gjb9sx.py\"\
    , line 48, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string ==\
    \ '':\n        return []\n    stack = []\n    chars = []\n    pos = 0\n    for\
    \ char in paren_string:\n        if char == '(':\n            stack.append(pos)\n\
    \            pos = pos + 1\n            chars.append(char)\n        elif char\
    \ == ')':\n            pos = stack.pop()\n            chars.append(char)\n   \
    \     else:\n            chars.append(char)\n\n    return chars\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2ixaq8gh.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp2ixaq8gh.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2ixaq8gh.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = [x for y\
    \ in paren_string.split(' ') for x in y.strip('()').split('(')]\n    levels =\
    \ [0 for i in range(len(parens))]\n\n    def walk(level: int, curr_idx: int) ->\
    \ None:\n        if level > levels[curr_idx]:\n            levels[curr_idx] =\
    \ level\n\n        idx += 1\n        if idx < len(parens):\n            walk(level\
    \ + 1, idx)\n\n    walk(0, 0)\n\n    return [i for i in range(len(levels)) if\
    \ levels[i] > 0]\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptbwze3g0.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmptbwze3g0.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptbwze3g0.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmptbwze3g0.py\", line 22, in parse_nested_parens\n\
    \    walk(0, 0)\n  File \"/tmp/tmptbwze3g0.py\", line 18, in walk\n    idx +=\
    \ 1\nUnboundLocalError: local variable 'idx' referenced before assignment\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    for index, char in enumerate(paren_string):\n        if char == '(':\n\
    \            stack.append(index)\n        if char == ')':\n            if not\
    \ stack:\n                logger.warning('Stack underflow. Invalid nested parentheses.')\n\
    \            else:\n                stack.pop()\n                level += 1\n\
    \                if level > len(stack):\n                    raise ValueError(f'Incorrect\
    \ number of nested parentheses: level={level} stack={len(stack)}')\n    return\
    \ level\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf3j4wvd6.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpf3j4wvd6.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf3j4wvd6.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpf3j4wvd6.py\", line 23, in parse_nested_parens\n\
    \    raise ValueError(f'Incorrect number of nested parentheses: level={level}\
    \ stack={len(stack)}')\nValueError: Incorrect number of nested parentheses: level=2\
    \ stack=1\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n    stack = []\n    curr_depth = 0\n    for idx, char in enumerate(paren_string):\n\
    \        if char == '(':\n            curr_depth += 1\n        elif char == ')':\n\
    \            curr_depth -= 1\n            if curr_depth == 0:\n              \
    \  stack.append(idx)\n    return stack\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsnnswnw4.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpsnnswnw4.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsnnswnw4.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    brackets_stack\
    \ = [[]]\n    open_brackets = open_brackets_stack = [()]\n    for c in paren_string:\n\
    \        if c == '(':\n            depth += 1\n            brackets_stack.append([])\n\
    \        elif c == ')':\n            if len(brackets_stack) > depth:\n       \
    \         brackets_stack = brackets_stack[:depth - 1]\n            else:\n   \
    \             # The last opening bracket is closed, so we need to check whether\
    \ we still have a valid nested parenthesis\n                open_brackets = open_brackets_stack[:len(brackets_stack)]\n\
    \                break\n        else:\n            brackets_stack[-1].append(c)\n\
    \            open_brackets.append(c)\n    return open_brackets\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpj6s_pfh4.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpj6s_pfh4.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpj6s_pfh4.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: Handle multiple\
    \ groups\n    # return list of indexes of parens nested from paren_string\n  \
    \  raise NotImplementedError\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn_9ajfb0.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpn_9ajfb0.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn_9ajfb0.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpn_9ajfb0.py\", line 13, in parse_nested_parens\n\
    \    raise NotImplementedError\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_char_count =\
    \ len(paren_string)\n    level = 0\n    paren_stack = [paren_string]\n    \n \
    \   while paren_char_count:\n        paren_char_count = len(paren_stack[-1])\n\
    \        \n        if paren_char_count == 0: # end of paren group\n          \
    \  level += 1\n            paren_stack.pop()\n            paren_char_count = len(paren_stack[-1])\n\
    \        else: # middle level of paren group\n            paren_stack.append(paren_stack[-1][paren_char_count-1])\n\
    \            paren_char_count = paren_stack[-1][paren_char_count-1]\n        \
    \    \n    return level\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyhmqy2f_.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpyhmqy2f_.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyhmqy2f_.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpyhmqy2f_.py\", line 24, in parse_nested_parens\n\
    \    paren_char_count = paren_stack[-1][paren_char_count-1]\nIndexError: string\
    \ index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_depth = 0\n\
    \    nesting_level = 0\n\n    parens = [int(x) for x in paren_string.split(' ')]\n\
    \n    parens = [x for x in parens if x != ')']\n\n    while len(parens) > 0:\n\
    \        if parens[-1] == '(':\n            parens.pop()\n            paren_depth\
    \ += 1\n            nesting_level += 1\n        elif parens[-1] == '[':\n    \
    \        parens.pop()\n            paren_depth += 1\n            nesting_level\
    \ += 1\n        elif parens[-1] == '{':\n            parens.pop()\n          \
    \  paren_depth += 1\n            nesting_level += 1\n        elif parens[-1] ==\
    \ '}':\n            parens.pop()\n            paren_depth -= 1\n            nesting_level\
    \ -= 1\n        else: # handle '(' and ')'\n            nesting_level -= 1\n \
    \       \n    if len(parens) == 0 and nesting_level == 0:\n        return 0\n\
    \    else:\n        return paren_depth\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyl9yhcho.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpyl9yhcho.py\", line 49,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyl9yhcho.py\"\
    , line 44, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpyl9yhcho.py\", line 14, in parse_nested_parens\n\
    \    parens = [int(x) for x in paren_string.split(' ')]\n  File \"/tmp/tmpyl9yhcho.py\"\
    , line 14, in <listcomp>\n    parens = [int(x) for x in paren_string.split(' ')]\n\
    ValueError: invalid literal for int() with base 10: '(()())'\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_level = 0\n    paren_levels = []\n\n    for i, c in enumerate(paren_string):\n\
    \        if c == '(':\n            paren_stack.append(i)\n            paren_level\
    \ += 1\n        elif c == ')':\n            paren_stack.pop(-1)\n            paren_level\
    \ -= 1\n            if paren_level == 0:\n                paren_levels.append(paren_level)\n\
    \n    return paren_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplwlg_xi5.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmplwlg_xi5.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplwlg_xi5.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 0\n\
    \    levels = [-1]*len(paren_string)\n\n    opening_paren_levels = [0]\n    for\
    \ i in range(len(paren_string)):\n        if paren_string[i] == '(':\n       \
    \     paren_count += 1\n            opening_paren_levels.append(i)\n        elif\
    \ paren_string[i] == ')':\n            paren_count -= 1\n            current_level_of_nesting\
    \ = opening_paren_levels.pop()\n\n            if current_level_of_nesting > levels[i]:\n\
    \                levels[i] = current_level_of_nesting\n\n    return levels\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpt4rskltr.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpt4rskltr.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpt4rskltr.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Create a stack to\
    \ track parens nesting.\n    stack = []\n\n    # Traverse the string character\
    \ by character to find parenthesis nesting.\n    # If the character is an open\
    \ parenthesis '(' then push it into the stack and move on to the next\n    # character.\
    \ If the character is a closed parenthesis ')' then pop an item from the stack\
    \ and move on\n    # to the next character. Stop when we reach the end of the\
    \ string.\n    i = 0\n    while i < len(paren_string):\n        if paren_string[i]\
    \ == '(':\n            stack.append(paren_string[i])\n            i += 1\n   \
    \     elif paren_string[i] == ')':\n            top_paren = stack.pop()\n    \
    \        i += 1\n        else:\n            i += 1\n\n    # Return the deepest\
    \ level of nesting.\n    return len(stack)\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2ct68o69.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmp2ct68o69.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2ct68o69.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    levels = []\n\n    def peek_next_level(index: int) -> int:\n      \
    \  \"\"\" Get the index of the next non-nesting parentheses in the input string.\
    \ \"\"\"\n        return index + (level + 1)\n\n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            stack.append(index)\n            level +=\
    \ 1\n        elif char == ')':\n            stack.pop()\n            if not stack:\n\
    \                levels.append(level)\n                level -= 1\n          \
    \  else:\n                level = peek_next_level(index)\n        else:\n    \
    \        pass\n    return levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpybukxtdf.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpybukxtdf.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpybukxtdf.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] =\
    \ []\n    i = 0\n    while i < len(paren_string) - 1:\n        if paren_string[i]\
    \ == ')':\n            i += 1\n            while paren_string[i] != ')':\n   \
    \             stack.append(i)\n                i += 1\n            stack.pop()\n\
    \        elif paren_string[i] == '(':\n            stack.append(i)\n         \
    \   i += 1\n    stack.append(i)\n    return stack\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp05p0g8c3.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp05p0g8c3.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp05p0g8c3.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    level = 0\n    parens = 0\n    start = 0\n    output\
    \ = []\n    for index, char in enumerate(paren_string):\n        if char == '(':\n\
    \            if parens == 0:\n                parens += 1\n            else:\n\
    \                parens = 0\n            level += 1\n        elif char == ')':\n\
    \            if parens == 0:\n                return []\n            level -=\
    \ 1\n            parens -= 1\n        elif char == ' ':\n            if level\
    \ == 0:\n                start = index\n        elif char == '\\n':\n        \
    \    if level == 0:\n                return []\n            elif level == 1:\n\
    \                output.append((start, index - 1))\n            else:\n      \
    \          return []\n\n    if level > 0:\n        return [0]\n\n    if level\
    \ == 0:\n        output.append(start)\n\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmrj3sios.py\", line\
    \ 57, in <module>\n    test_check()\n  File \"/tmp/tmpmrj3sios.py\", line 55,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmrj3sios.py\"\
    , line 50, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\
    \    paren_array = []\n    for c in paren_string:\n        if c == '(':\n    \
    \        paren_level += 1\n        elif c == ')':\n            paren_level -=\
    \ 1\n            paren_array.append(paren_level)\n\n    return paren_array\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp54mbh3jp.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmp54mbh3jp.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp54mbh3jp.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(map(lambda\
    \ i: 0 if i == 0 else i + 1, map(count_nesting, paren_string.split())))\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptxm_yvuh.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmptxm_yvuh.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptxm_yvuh.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmptxm_yvuh.py\", line 11, in parse_nested_parens\n\
    \    return list(map(lambda i: 0 if i == 0 else i + 1, map(count_nesting, paren_string.split())))\n\
    NameError: name 'count_nesting' is not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.count('(')\
    \ == paren_string.count(')'):\n        parentheses_level = [0 for _ in range(len(paren_string))]\n\
    \        for i in range(len(paren_string)):\n            if paren_string[i] ==\
    \ '(':\n                parentheses_level[i] += 1\n            elif paren_string[i]\
    \ == ')':\n                parentheses_level[i] -= 1\n                if parentheses_level[i]\
    \ == 0:\n                    break\n        return parentheses_level\n    else:\n\
    \        raise AssertionError(\"Parentheses strings must have same number of open/close\
    \ parentheses\")\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqu_d7afn.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpqu_d7afn.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqu_d7afn.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = [0]\n\
    \    nested_parens_count = 0\n\n    for c in paren_string:\n        if c == '(':\n\
    \            nested_parens.append(nested_parens_count)\n            nested_parens_count\
    \ += 1\n        elif c == ')':\n            nested_parens[nested_parens_count\
    \ - 1] += 1\n    return nested_parens\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7tipzztd.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp7tipzztd.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7tipzztd.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Parse the paren\
    \ string and count the parentheses.\n    # Since this algorithm is a bit naive,\
    \ count parentheses by adding one to counts of parentheses.\n    count = 0\n \
    \   nested_parens: List[int] = []\n    nesting_level = -1\n    for i, c in enumerate(paren_string):\n\
    \        if c == '(':\n            if nesting_level == -1:\n                nesting_level\
    \ = 1\n            else:\n                nesting_level += 1\n        if c ==\
    \ ')':\n            nested_parens.append(nesting_level)\n            if nesting_level\
    \ == 0:\n                count += 1\n                nesting_level = -1\n    \
    \    \n    # Return nesting levels\n    return nested_parens\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdv0i0ltf.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpdv0i0ltf.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdv0i0ltf.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for\
    \ c in paren_string:\n        if c == \"(\":\n            stack.append(c)\n  \
    \      elif c == \")\":\n            if len(stack) == 0:\n                return\
    \ []\n            stack.pop()\n        else:\n            stack.append(c)\n\n\
    \    assert stack == [], \"Mismatched parentheses\"\n    return [0]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjjxjcomc.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpjjxjcomc.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjjxjcomc.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpjjxjcomc.py\", line 22, in parse_nested_parens\n\
    \    assert stack == [], \"Mismatched parentheses\"\nAssertionError: Mismatched\
    \ parentheses\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \n    for paren_item in paren_string.split():\n        if paren_item == '(':\n\
    \            paren_stack.append(paren_item)\n        elif paren_item == ')':\n\
    \            if len(paren_stack) == 0:\n                # Handle case where last\
    \ item is left paren\n                paren_stack.pop()\n            else:\n \
    \               paren_stack.pop()\n                if len(paren_stack) == 0:\n\
    \                    return paren_stack\n        else:\n            paren_stack.append(paren_item)\n\
    \    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppdruq1hi.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmppdruq1hi.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppdruq1hi.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Python supports\
    \ recursive functions, which would do the trick here, but we do not have Python\
    \ >= 3.8.\n    # So the for loop below is necessary.\n    to_parse = paren_string\n\
    \    parens = []\n    level = 0\n    for char in to_parse:\n        if char ==\
    \ '(':\n            level += 1\n        elif char == ')':\n            level -=\
    \ 1\n            if level == 0:\n                parens.append(level)\n      \
    \  else:\n            pass\n    return parens\n\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp88gf5fyl.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmp88gf5fyl.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp88gf5fyl.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.count('(')\
    \ != paren_string.count(')'):\n        raise ValueError(f'Input string \"{paren_string}\"\
    \ has different number of parentheses.')\n\n    if paren_string.count('(') ==\
    \ 0:\n        # Simple case where there is only one level of nesting of parentheses.\n\
    \        return [paren_string.count(')')]\n\n    levels = [paren_string.count('(')]\n\
    \    brackets = 0\n\n    for i in range(0, len(paren_string) - 1, 2):\n      \
    \  if paren_string[i + 1] == ')':\n            brackets = brackets + 1\n     \
    \   elif paren_string[i + 1] == '(':\n            brackets = brackets - 1\n  \
    \      else:\n            raise ValueError(f'Braces do not match at position {i}\
    \ \"(\" or \"{paren_string[i+1]}\".')\n\n        if brackets == 0:\n         \
    \   levels.append(paren_string.count(')'))\n            break\n\n    if brackets\
    \ != 0:\n        raise ValueError(f'No closing brace found after {brackets} open\
    \ braces.')\n\n    return levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps_e43gq8.py\", line\
    \ 46, in <module>\n    test_check()\n  File \"/tmp/tmps_e43gq8.py\", line 44,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps_e43gq8.py\"\
    , line 39, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmps_e43gq8.py\", line 27, in parse_nested_parens\n\
    \    raise ValueError(f'Braces do not match at position {i} \"(\" or \"{paren_string[i+1]}\"\
    .')\nValueError: Braces do not match at position 12 \"(\" or \" \".\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: Use stack\n\
    \    # Initialize stack with empty list\n    stack = []\n    # Initialize the\
    \ current level with -1\n    level = -1\n    # Go through each character in parentheses\n\
    \    for ch in paren_string:\n        # Pop top most level from stack\n      \
    \  level = stack.pop()\n        # Increment level by 1 for the new character\n\
    \        level += 1\n        # Add it to stack\n        stack.append(level)\n\
    \    # return deepest level\n    return stack\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9rlgcbxt.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp9rlgcbxt.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9rlgcbxt.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp9rlgcbxt.py\", line 19, in parse_nested_parens\n\
    \    level = stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_level = []\n    for i, c in enumerate(paren_string):\n        if c\
    \ == '(':\n            paren_stack.append(i)\n            paren_level.append(0)\n\
    \        elif c == ')':\n            paren_stack.pop()\n            if len(paren_stack)\
    \ == 0:\n                paren_level.pop()\n            else:\n              \
    \  paren_level[-1] += 1\n    return paren_level\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprvxc57a8.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmprvxc57a8.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmprvxc57a8.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8j2nxmal.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp8j2nxmal.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8j2nxmal.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels: List[int]\
    \ = [0 for i in range(256)]\n    paren_chars: Set[str] = {'(', ')'}\n    for i\
    \ in range(len(paren_string)):\n        if paren_chars.issuperset(paren_string[:\
    \ i + 1]):\n            levels[i] = levels[i + 1] + 1\n    levels.pop()\n    return\
    \ levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb934oqx0.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpb934oqx0.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpb934oqx0.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n\
    \    opening_symbols = paren_string.count('(')\n    closing_symbols = paren_string.count(')')\n\
    \n    # Store all the opening symbols.\n    for symbol in range(1, opening_symbols+1):\n\
    \        nested_levels.append(symbol)\n\n    # Calculate all the closing symbols.\n\
    \    for symbol in range(closing_symbols, 0, -1):\n        nested_levels.append(symbol)\n\
    \n    # Store all the nested levels and remove the duplicates.\n    nested_levels\
    \ = list(set(nested_levels))\n\n    # Add the number of opening symbols to the\
    \ highest level.\n    nested_levels.append(opening_symbols)\n\n    # Return the\
    \ list with the deepest levels.\n    return nested_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqnicm6c0.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmpqnicm6c0.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqnicm6c0.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    par_count, stack = 1, [paren_string]\n\n    while par_count\
    \ > 0:\n        par_string = stack.pop()\n        par_count = par_string.count('(')\
    \ - par_string.count(')')\n\n        for par in par_string.split(' '):\n     \
    \       if par == '(':\n                stack.append(par)\n            elif par\
    \ == ')':\n                par_count = par_count - 1\n                if par_count\
    \ < 0:\n                    par_count = 0\n            else:\n               \
    \ stack.append(par)\n\n    return par_count + 1\n\n\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzf09te_t.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpzf09te_t.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzf09te_t.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(map(lambda\
    \ x: len(x), re.findall('[^()]\\(([^()]*(?:\\(([^()]*\\([^()]*\\))*\\))*)\\)',\
    \ paren_string)))\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf3v9u0fi.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpf3v9u0fi.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf3v9u0fi.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpf3v9u0fi.py\", line 11, in parse_nested_parens\n\
    \    return list(map(lambda x: len(x), re.findall('[^()]\\(([^()]*(?:\\(([^()]*\\\
    ([^()]*\\))*\\))*)\\)', paren_string)))\nNameError: name 're' is not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n    depth = 0\n    left_paren = 0\n    right_paren = 0\n \
    \   open_brackets = [i for i in range(len(paren_string)) if paren_string[i] ==\
    \ \"(\"]\n    close_brackets = [i for i in range(len(paren_string)) if paren_string[i]\
    \ == \")\"]\n\n    for i in range(0, len(open_brackets)):\n        if open_brackets[i]\
    \ == right_paren:\n            depth += 1\n        elif open_brackets[i] == left_paren:\n\
    \            depth -= 1\n        if depth == 0:\n            break\n    return\
    \ depth\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4adsbkw3.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmp4adsbkw3.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4adsbkw3.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\
    \    paren_levels = []\n    for c in paren_string:\n        if c == '(':\n   \
    \         paren_level += 1\n        elif c == ')':\n            paren_level -=\
    \ 1\n        elif c == ' ':\n            if paren_level == 0:\n              \
    \  paren_levels.append(paren_level)\n            else:\n                paren_levels[paren_level-1]\
    \ += 1\n        else:\n            pass\n    return paren_levels\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpit1k8_ds.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpit1k8_ds.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpit1k8_ds.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_nesting_level = 0\n\n    i = 0\n    while i < len(paren_string):\n\
    \        if paren_string[i] == '(':\n            paren_stack.append(i)\n     \
    \       paren_nesting_level += 1\n        elif paren_string[i] == ')':\n     \
    \       parent_i = paren_stack.pop()\n            paren_nesting_level -= 1\n \
    \           i += 1\n            if parent_i == -1:\n                # This paren\
    \ string ends with an open paren.\n                if paren_nesting_level == 0:\n\
    \                    return []\n                else:\n                    return\
    \ paren_stack + [paren_nesting_level]\n            else:\n                # This\
    \ paren string ends with a close paren.\n                if paren_nesting_level\
    \ == 0:\n                    return []\n                else:\n              \
    \      return paren_stack + [paren_nesting_level]\n        else:\n           \
    \ i += 1\n    return []\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659976389
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO implement more\
    \ complex string parsing to handle nested parenthesis such as ((()))((()()())\n\
    \    level = 0\n    stack = []\n    for char in paren_string:\n        if char\
    \ == ')':\n            if stack:\n                level -= 1\n            stack.pop()\n\
    \        elif char == '(':\n            stack.append(level)\n            level\
    \ += 1\n    return stack\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2hoouw3w.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp2hoouw3w.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2hoouw3w.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n    if not paren_string[0] in '()':\n        paren_string\
    \ = f'({paren_string}) '\n    paren_string = paren_string.strip()\n    paren_string\
    \ = paren_string.rstrip(' ')\n    level = 0\n    left_string = \"\"\n    while\
    \ level < len(paren_string) - 1:\n        if paren_string[level] == ')':\n   \
    \         left_string += paren_string[level + 1]\n            level += 1\n   \
    \     else:\n            left_string += paren_string[level]\n            level\
    \ += 1\n            right_string = \"\"\n            while level < len(paren_string)\
    \ - 1 and paren_string[level] in '()':\n                right_string += paren_string[level]\n\
    \                level += 1\n            left_string += right_string\n    level\
    \ = 0\n    right_string = \"\"\n    while level < len(paren_string) - 1 and paren_string[level]\
    \ in '()':\n        right_string += paren_string[level]\n        level += 1\n\
    \    left_string += right_string\n    left_list = left_string.split(')')\n   \
    \ left_list = [int(i) for i in left_list]\n    left_list.reverse()\n    return\
    \ left_list\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaftyhr31.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpaftyhr31.py\", line 49,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpaftyhr31.py\"\
    , line 44, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpaftyhr31.py\", line 38, in parse_nested_parens\n\
    \    left_list = [int(i) for i in left_list]\n  File \"/tmp/tmpaftyhr31.py\",\
    \ line 38, in <listcomp>\n    left_list = [int(i) for i in left_list]\nValueError:\
    \ invalid literal for int() with base 10: '(('\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_depth = []\n    paren_level = 0\n    open_par = 0\n    closed_par =\
    \ 0\n\n    for ch in paren_string:\n        if ch == '(':\n            if open_par\
    \ == 0:\n                paren_stack.append(ch)\n                paren_depth.append(paren_level)\n\
    \            paren_level += 1\n            open_par += 1\n        elif ch == ')':\n\
    \            paren_level -= 1\n            closed_par += 1\n            closed_par\
    \ = 0\n            open_par -= 1\n\n        elif ch == ' ':\n            if open_par\
    \ != 0:\n                closed_par += 1\n            else:\n                open_par\
    \ += 1\n\n        elif ch == ')\\n':\n            paren_stack.pop()\n        \
    \    paren_depth.pop()\n\n    if open_par != 0:\n        raise Exception('There\
    \ should be no open parentheses left at the end')\n\n    if closed_par != 0:\n\
    \        raise Exception('There should be no open parentheses left at the end')\n\
    \n    if paren_level > 0:\n        raise Exception('There should be no open parentheses\
    \ left at the end')\n\n    if len(paren_stack) > 0:\n        raise Exception('There\
    \ should be no open parentheses left at the end')\n\n    return paren_depth\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwfmj89io.py\", line\
    \ 63, in <module>\n    test_check()\n  File \"/tmp/tmpwfmj89io.py\", line 61,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwfmj89io.py\"\
    , line 56, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpwfmj89io.py\", line 41, in parse_nested_parens\n\
    \    raise Exception('There should be no open parentheses left at the end')\n\
    Exception: There should be no open parentheses left at the end\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = 0\n    for\
    \ i, c in enumerate(paren_string):\n        if c == '(':\n            result +=\
    \ 1\n        elif c == ')':\n            result -= 1\n        else:\n        \
    \    pass\n    return result\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnmbqxxz7.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpnmbqxxz7.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnmbqxxz7.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_depth = 0\n\
    \    paren_levels: List[int] = []\n\n    for i in range(len(paren_string) - 1):\n\
    \        if paren_string[i:i+2] == '()':\n            paren_levels.append(paren_depth)\n\
    \        elif paren_string[i:i+2] == '{}':\n            paren_depth += 1\n   \
    \     elif paren_string[i:i+2] == '[]':\n            paren_depth += 0\n\n    paren_levels.append(paren_depth)\n\
    \n    return paren_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpto2dmami.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpto2dmami.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpto2dmami.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Get the deepest\
    \ level of nesting in a given input string\n    def deepest_level(n: str) -> int:\n\
    \        counter = 0\n        for p in n.split():\n            if p == '(':\n\
    \                counter += 1\n            elif p == ')':\n                counter\
    \ -= 1\n                if counter == 0:\n                    return counter\n\
    \        return -1\n\n    return list(map(deepest_level, paren_string.split()))\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr760v_kc.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpr760v_kc.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpr760v_kc.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    levels_of_nesting = []\n    level = 0\n    for group in groups:\n       \
    \ if group == '(':\n            level += 1\n        elif group == ')':\n     \
    \       level -= 1\n            levels_of_nesting.append(level)\n        elif\
    \ group == '[':\n            levels_of_nesting.append(1)\n        elif group ==\
    \ ']':\n            levels_of_nesting.pop()\n    return levels_of_nesting\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjrvd_9sl.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpjrvd_9sl.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjrvd_9sl.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    length\
    \ = len(paren_string)\n    index = 0\n    while index < length:\n        ch =\
    \ paren_string[index]\n        if ch == '(':\n            stack.append(index)\n\
    \        elif ch == ')':\n            index = stack.pop()\n            if index\
    \ == 0:\n                break\n        else:\n            index = index + 1\n\
    \    return stack\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659976389
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    depth\
    \ = 0\n    for i in paren_string:\n        if i == '(':\n            depth +=\
    \ 1\n            stack.append(i)\n        elif i == ')':\n            depth -=\
    \ 1\n            if not stack:\n                return -1\n            stack.pop()\n\
    \    if not stack:\n        return -1\n    return depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpz3l0ph4a.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpz3l0ph4a.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpz3l0ph4a.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    paren_stack\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            depth\
    \ += 1\n            if depth == 0:\n                paren_stack.append(1)\n  \
    \          else:\n                paren_stack[-1] += 1\n        elif char == ')':\n\
    \            depth -= 1\n            if depth == 0:\n                paren_stack.pop()\n\
    \            else:\n                paren_stack[-1] -= 1\n    return paren_stack\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx12mngfz.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpx12mngfz.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpx12mngfz.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpx12mngfz.py\", line 19, in parse_nested_parens\n\
    \    paren_stack[-1] += 1\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_level = 0\n\
    \    paren_count = 0\n    max_nested_level = 0\n    nested_list: List[int] = []\n\
    \    for idx, char in enumerate(paren_string):\n        if char == \"(\":\n  \
    \          nested_level += 1\n            nested_list.append(idx)\n        elif\
    \ char == \")\":\n            nested_level -= 1\n            nested_list.remove(idx)\n\
    \            paren_count += 1\n            if nested_level == 0:\n           \
    \     if max_nested_level < nested_level:\n                    max_nested_level\
    \ = nested_level\n                nested_list.remove(idx)\n        elif char ==\
    \ \",\":\n            nested_level -= 1\n            nested_list.remove(idx)\n\
    \            paren_count += 1\n            if nested_level == 0:\n           \
    \     if max_nested_level < nested_level:\n                    max_nested_level\
    \ = nested_level\n    return nested_list\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpymygsaa8.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpymygsaa8.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpymygsaa8.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpymygsaa8.py\", line 21, in parse_nested_parens\n\
    \    nested_list.remove(idx)\nValueError: list.remove(x): x not in list\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    level_of_nesting = 0\n    for pos in range(1, len(paren_string)):\n     \
    \   # Check if parenthesis is closed or open based on level already stored in\n\
    \        # paren_stack variable\n        if paren_string[pos] == ')':\n      \
    \      if level_of_nesting > 0:\n                level_of_nesting -= 1\n     \
    \   else:\n            if level_of_nesting == 0:\n                level_of_nesting\
    \ = 1\n            level_of_nesting += 1\n        paren_stack.append(level_of_nesting)\n\
    \n    return paren_stack[::-1]\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8z205cia.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp8z205cia.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8z205cia.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    from collections import\
    \ defaultdict\n    \n    nested_levels = defaultdict(int)\n    last_char = None\n\
    \    for char in paren_string:\n        if char == '(':\n            nested_levels[last_char]\
    \ += 1\n        elif char == ')':\n            nested_levels[last_char] -= 1\n\
    \        last_char = char\n    \n    return_array = []\n    for key, value in\
    \ nested_levels.items():\n        if value < 0:\n            return return_array\n\
    \        return_array.append(value)\n    \n    return return_array\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpepjae9dx.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpepjae9dx.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpepjae9dx.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    max_nesting = 0\n    for group in groups:\n        if group.startswith('('):\n\
    \            level = 1\n        else:\n            level = -1\n        current_nesting\
    \ = max_nesting + level\n        max_nesting = max(current_nesting, max_nesting)\n\
    \    nesting_level = max_nesting\n    return nesting_level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfymuob20.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpfymuob20.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfymuob20.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_level = 1\n    for c in paren_string:\n        if c == '(':\n     \
    \       paren_stack.append(paren_level)\n        elif c == ')':\n            paren_stack.pop()\n\
    \        paren_level += 1\n\n    return paren_stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_k8u50n_.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmp_k8u50n_.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_k8u50n_.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    i = 0\n    while i < len(paren_string) and paren_string[i] in string.digits:\n\
    \        paren_stack.append(paren_string[i])\n        i += 1\n    while i < len(paren_string):\n\
    \        if paren_string[i] == '(':\n            paren_stack.append(paren_string[i])\n\
    \            i += 1\n        elif paren_string[i] == ')':\n            if len(paren_stack)\
    \ > 0:\n                paren_string = paren_string[:i] + paren_stack.pop() +\
    \ '()'\n                i += 1\n            else:\n                return []\n\
    \        else:\n            i += 1\n    return paren_stack\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpuzm2mnih.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpuzm2mnih.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpuzm2mnih.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpuzm2mnih.py\", line 13, in parse_nested_parens\n\
    \    while i < len(paren_string) and paren_string[i] in string.digits:\nNameError:\
    \ name 'string' is not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    level_dict = {}\n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            level += 1\n            level_dict[index]\
    \ = level\n        elif char == ')':\n            level -= 1\n            level_dict[index]\
    \ = level\n        elif char == ' ':\n            stack.append(index)\n    if\
    \ stack:\n        stack.append(len(paren_string))\n    return level_dict[max(stack)]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnwckvh74.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpnwckvh74.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnwckvh74.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpnwckvh74.py\", line 25, in parse_nested_parens\n\
    \    return level_dict[max(stack)]\nKeyError: 27\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.count('(')\
    \ == 0 or paren_string.count(')') == 0:\n        raise ValueError(\"Invalid parentheses\"\
    )\n\n    nested_level = 1\n    paren_stack = []\n    for paren in paren_string:\n\
    \        if paren == '(':\n            paren_stack.append(nested_level)\n    \
    \    elif paren == ')':\n            nested_level = paren_stack.pop()\n      \
    \  else:\n            nested_level += 1\n\n    return nested_level\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn1hmjscr.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpn1hmjscr.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn1hmjscr.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for\
    \ index, paren in enumerate(paren_string):\n        if paren == '(':\n       \
    \     stack.append(index)\n        elif paren == ')':\n            depth = max(stack)\n\
    \            stack.pop()\n            if stack:\n                stack[-1] -=\
    \ 1\n            else:\n                stack.append(index)\n    return stack\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp50klw54x.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp50klw54x.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp50klw54x.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    level\
    \ = 0\n    pairs = []\n    for c in paren_string:\n        if c == '(':\n    \
    \        level += 1\n            pairs.append([])\n        elif c == ')':\n  \
    \          pairs[level].append(pairs[level - 1][-1] + 1)\n            level -=\
    \ 1\n        else:\n            pairs[level].append(c)\n    return pairs\n\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvv193u6b.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpvv193u6b.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvv193u6b.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpvv193u6b.py\", line 19, in parse_nested_parens\n\
    \    pairs[level].append(pairs[level - 1][-1] + 1)\nIndexError: list index out\
    \ of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(',\
    \ '').replace(')', '')\n    paren_string = paren_string.split(' ')\n    result\
    \ = []\n    curr_level = 0\n    for paren_group in paren_string:\n        if paren_group[0]\
    \ == '(':\n            result.append(curr_level)\n            curr_level += 1\n\
    \        elif paren_group[-1] == ')':\n            curr_level -= 1\n        else:\n\
    \            raise RuntimeError('Invalid parentheses group', paren_group)\n\n\
    \    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbzgqmrpn.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpbzgqmrpn.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbzgqmrpn.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpbzgqmrpn.py\", line 16, in parse_nested_parens\n\
    \    if paren_group[0] == '(':\nIndexError: string index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens_level = 0\n\
    \    parens_level_list = []\n\n    # Step 1: iterate through the parens string\
    \ one character at a time adding 1 for each opening paren\n    for i in range(len(paren_string)):\n\
    \        if paren_string[i] == \"(\":\n            parens_level += 1\n       \
    \ elif paren_string[i] == \")\":\n            parens_level -= 1\n        parens_level_list.append(parens_level)\n\
    \n    return parens_level_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3ydxqdbx.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp3ydxqdbx.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3ydxqdbx.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    paren_counter\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            paren_counter\
    \ += 1\n        elif c == ')':\n            paren_counter -= 1\n            if\
    \ paren_counter == 0:\n                result.append(result)\n               \
    \ result.append(c)\n            elif paren_counter == 0:\n                result.append(c)\n\
    \        else:\n            result.append(c)\n    return result\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcg62_b91.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpcg62_b91.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcg62_b91.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string ==\
    \ '()': return []\n    \n    nested_paren_level = 0\n    parsed_paren_levels =\
    \ [-1] * len(paren_string)\n    paren_level = 0\n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            nested_paren_level += 1\n        elif char\
    \ == ')':\n            nested_paren_level -= 1\n        \n        if nested_paren_level\
    \ == paren_level:\n            parsed_paren_levels[index] = nested_paren_level\n\
    \        \n        paren_level += 1\n\n    return parsed_paren_levels\n\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvxkbyyrk.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpvxkbyyrk.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvxkbyyrk.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Parse paren_string\
    \ and return a list that represents\n    # the groups with maximum number of parentheses\n\
    \    # E.g. (()()) has maximum number of two groups with parentheses.\n    # Hence\
    \ return a list of length 2\n    level = 0\n    groups = []\n    opening_brackets\
    \ = 0\n    for char in paren_string:\n        if char == '(':\n            if\
    \ opening_brackets == 0:\n                groups.append(1)\n                level\
    \ += 1\n            else:\n                opening_brackets += 1\n        elif\
    \ char == ')':\n            opening_brackets -= 1\n            if opening_brackets\
    \ == 0:\n                groups.append(level)\n    return groups\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaoi05k6j.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpaoi05k6j.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpaoi05k6j.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    paren_string_list\
    \ = list(paren_string)\n    parens_stack = []\n    for index, char in enumerate(paren_string_list):\n\
    \        if char == '(':\n            parens_stack.append(index)\n        elif\
    \ char == ')':\n            parens_stack.pop()\n            if parens_stack:\n\
    \                level = parens_stack[-1] - parens_stack[-2] + 1\n           \
    \ else:\n                level = index - parens_stack[-1]\n        else:\n   \
    \         continue\n    return level\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpruvjf8af.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpruvjf8af.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpruvjf8af.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpruvjf8af.py\", line 20, in parse_nested_parens\n\
    \    level = parens_stack[-1] - parens_stack[-2] + 1\nIndexError: list index out\
    \ of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n\
    \            level += 1\n        elif char == ')':\n            if len(stack)\
    \ == 0:\n                raise Exception\n            else:\n                stack.pop()\n\
    \                level -= 1\n                if stack[-1] == 0:\n            \
    \        return level + 1\n        elif char == ' ':\n            level += 1\n\
    \        else:\n            raise Exception(\"Unexpected character '{}' encountered\
    \ when parsing nested parentheses\".format(char))\n\n    raise Exception(\"Parsing\
    \ of parentheses failed for string: {}\".format(paren_string))\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx1va6vut.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpx1va6vut.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpx1va6vut.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpx1va6vut.py\", line 24, in parse_nested_parens\n\
    \    if stack[-1] == 0:\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    paren_stack\
    \ = []\n    stack_depth = 0\n    parsed_paren = []\n\n    for char in paren_string:\n\
    \        if char == ')':\n            # Closing Parenthesis\n            stack_depth\
    \ -= 1\n            paren_stack.append(stack_depth)\n            if stack_depth\
    \ == 0:\n                parsed_paren.append(level + 1)\n        elif char ==\
    \ '(':\n            # Starting a Nested parenthesis\n            level += 1\n\
    \            paren_stack.append(level)\n            stack_depth = level\n    \
    \        parsed_paren.append(0)\n        elif char == ' ':\n            # ignore\
    \ spaces\n            pass\n        else:\n            # Non-Parenthesis character\
    \ encountered\n            raise ValueError\n    return parsed_paren\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps7d2e9nv.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmps7d2e9nv.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps7d2e9nv.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Recursive function\
    \ call\n    def _parse_nested_parens(input: str, level: int) -> List[int]:\n \
    \       nonlocal paren_string\n        current_depth = 0\n        levels = []\n\
    \        index = 0\n        while True:\n            if level >= current_depth:\n\
    \                levels.append(level)\n                index += 1\n          \
    \      current_depth += 1\n            try:\n                index = input.index(paren_string,\
    \ index)\n            except ValueError:\n                break\n            index\
    \ += 1\n        # print('level found:', levels)\n        levels = levels[1:]\n\
    \        return levels\n\n    paren_string = '('\n    level = 0\n    levels =\
    \ []\n    index = 0\n    for _ in range(len(paren_string)):\n        index +=\
    \ 1\n        paren_string = paren_string + ')'\n\n    result = _parse_nested_parens(paren_string,\
    \ level)\n    if result is None or len(result) == 0:\n        raise ValueError(\"\
    Invalid parenthesis string\")\n    # print('levels:', levels)\n    return result\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8tmj0e3h.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmp8tmj0e3h.py\", line 52,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8tmj0e3h.py\"\
    , line 47, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp8tmj0e3h.py\", line 41, in parse_nested_parens\n\
    \    raise ValueError(\"Invalid parenthesis string\")\nValueError: Invalid parenthesis\
    \ string\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 1\n\
    \    nested_parens = []\n\n    for ch in paren_string:\n        if ch == '(':\n\
    \            paren_count += 1\n        elif ch == ')':\n            paren_count\
    \ -= 1\n        else:\n            pass\n        nested_parens.append(paren_count)\n\
    \    return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpukohb304.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpukohb304.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpukohb304.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Count number of\
    \ opening and closing parens\n    open_parens = count_parens(paren_string)\n \
    \   close_parens = open_parens - 1\n\n    # Remove opening parens from input string\n\
    \    paren_string = remove_parens(paren_string)\n\n    # Count number of opening\
    \ parens\n    open_parens = count_parens(paren_string)\n\n    # Initialize list\
    \ to store results\n    result = []\n\n    # Parse the string character by character\
    \ and append each character to\n    # the result list if the character is an opening\
    \ paren\n    for i in range(open_parens):\n        result.append('(')\n\n    #\
    \ Parse the string character by character and append each character to\n    #\
    \ the result list if the character is a closing paren\n    for i in range(close_parens):\n\
    \        result.append(')')\n\n    return result\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnytr6ocr.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmpnytr6ocr.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnytr6ocr.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpnytr6ocr.py\", line 12, in parse_nested_parens\n\
    \    open_parens = count_parens(paren_string)\nNameError: name 'count_parens'\
    \ is not defined. Did you mean: 'open_parens'?\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Initialize empty\
    \ dictionary\n    level_counter = 0\n    nested_levels = dict()\n    \n    # Traverse\
    \ through every element of string and add its level to dictionary\n    for char\
    \ in paren_string:\n        if char == '(':\n            level_counter += 1\n\
    \        elif char == ')':\n            level_counter -= 1\n            \n   \
    \         # Check if the level is present in nested levels dictionary\n      \
    \      if level_counter == 0:\n                nested_levels[level_counter] =\
    \ level_counter\n                \n    # Store maximum level found in nested levels\
    \ dictionary\n    maximum_level = max(nested_levels.values())\n    \n    # Store\
    \ all levels present in nested levels dictionary in a list\n    list_of_levels\
    \ = list()\n    \n    # Traverse through dictionary to store all levels of nesting\n\
    \    for level in nested_levels:\n        if level == maximum_level:\n       \
    \     list_of_levels.append(level)\n            \n    return list_of_levels\n\
    \    \n    \n    \n    \n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbhpseied.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpbhpseied.py\", line 49,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbhpseied.py\"\
    , line 44, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = list()\n\
    \    nested_level = list()\n\n    paren_stack = list()\n    paren_stack.append(0)\n\
    \    paren_level = 0\n\n    for idx, char in enumerate(paren_string):\n      \
    \  if char == ')':\n            while len(paren_stack) > 0:\n                paren_level\
    \ -= 1\n                paren_level.append(paren_stack.pop())\n\n        if char\
    \ == '(':\n            while len(paren_stack) > 0:\n                paren_level\
    \ += 1\n                paren_level.append(paren_stack.pop())\n            paren_stack.append(idx)\n\
    \            paren_level.append(idx)\n\n        nested_parens.append(idx)\n\n\
    \    while len(paren_stack) > 0:\n        paren_level -= 1\n        paren_level.append(paren_stack.pop())\n\
    \n    return nested_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmyc69bos.py\", line\
    \ 47, in <module>\n    test_check()\n  File \"/tmp/tmpmyc69bos.py\", line 45,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmyc69bos.py\"\
    , line 40, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpmyc69bos.py\", line 27, in parse_nested_parens\n\
    \    paren_level.append(paren_stack.pop())\nAttributeError: 'int' object has no\
    \ attribute 'append'\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Special cases\n\
    \    if len(paren_string) == 1:\n        return 0\n    if len(paren_string) ==\
    \ 3:\n        return max(map(parse_nested_parens, paren_string))\n\n    groups\
    \ = paren_string.split(' ')\n    levels = []\n    for group in groups:\n     \
    \   levels.append(parse_nested_parens(group))\n    return max(levels)\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpz1hsnn5t.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpz1hsnn5t.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpz1hsnn5t.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpz1hsnn5t.py\", line 20, in parse_nested_parens\n\
    \    levels.append(parse_nested_parens(group))\n  File \"/tmp/tmpz1hsnn5t.py\"\
    , line 20, in parse_nested_parens\n    levels.append(parse_nested_parens(group))\n\
    \  File \"/tmp/tmpz1hsnn5t.py\", line 20, in parse_nested_parens\n    levels.append(parse_nested_parens(group))\n\
    \  [Previous line repeated 993 more times]\n  File \"/tmp/tmpz1hsnn5t.py\", line\
    \ 12, in parse_nested_parens\n    if len(paren_string) == 1:\nRecursionError:\
    \ maximum recursion depth exceeded while calling a Python object\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels: List[int]\
    \ = []\n    level = 0\n    nested_paren_counter = 0\n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            nested_paren_counter += 1\n            paren_levels.append(level)\n\
    \            level += 1\n        elif char == ')':\n            nested_paren_counter\
    \ -= 1\n            if nested_paren_counter == 0:\n                level += 1\n\
    \                paren_levels.append(level)\n        elif char == ' ':\n     \
    \       level += 1\n    \n    return paren_levels\n\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp33pg_wft.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmp33pg_wft.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp33pg_wft.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens_stack = []\n\
    \    parens_level = []\n    \n    for ch in paren_string:\n        if ch == '(':\n\
    \            parens_stack.append(ch)\n            parens_level.append(0)\n   \
    \     elif ch == ')':\n            parens_level.pop()\n            \n    if not\
    \ parens_stack:\n        return [0, 0, 0]\n\n    max_level = 0\n    for idx, parens_ch\
    \ in enumerate(parens_stack):\n        parens_level = parens_level[:idx] + parens_level[idx+1:]\n\
    \        max_level = max(max_level, len(parens_level))\n    \n    return max_level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2trn75r5.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmp2trn75r5.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2trn75r5.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def iterate_parens(paren_string):\n\
    \        # Start with initial set of parentheses in string\n        paren_nesting\
    \ = [1 if c == '(' else -1 for c in paren_string]\n        paren_level = 0\n \
    \       while paren_level != len(paren_nesting):\n            for i in range(0,\
    \ len(paren_nesting)):\n                if paren_nesting[i] == paren_level and\
    \ paren_nesting[i-1] == -1:\n                    # We found a pair of parentheses.\
    \ Increase our level of nesting\n                    paren_nesting[i] = 1\n  \
    \                  paren_level += 1\n                else:\n                 \
    \   # We found a pair of parentheses. Decrease our level of nesting\n        \
    \            paren_nesting[i] = -1\n                    paren_level -= 1\n   \
    \         if paren_level == 0:\n                break\n        return paren_nesting\n\
    \n    paren_nesting = iterate_parens(paren_string)\n    max_level = 0\n    for\
    \ level_num in range(len(paren_nesting)):\n        if paren_nesting[level_num]\
    \ > max_level:\n            max_level = paren_nesting[level_num]\n\n    return\
    \ max_level\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659976389
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Implementation not\
    \ shown\n    raise NotImplementedError()\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0w3jq6h6.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp0w3jq6h6.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0w3jq6h6.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp0w3jq6h6.py\", line 12, in parse_nested_parens\n\
    \    raise NotImplementedError()\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n    levels = []\n    i = 0\n    open = 0\n    close = 0\n\
    \    for c in paren_string:\n        if c == '(':\n            open += 1\n   \
    \         close = 0\n            levels.append(0)\n        elif c == ')':\n  \
    \          close += 1\n            levels[-1] += 1\n            if levels[-1]\
    \ == 0:\n                levels.pop()\n            else:\n                levels[-1]\
    \ -= 1\n        elif close > open:\n            levels[-1] += 1\n        else:\n\
    \            levels.append(0)\n        if i == len(paren_string) - 1:\n      \
    \      return levels\n        i += 1\n    raise ValueError('Parantheses unbalanced')\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp33ddftig.py\", line\
    \ 46, in <module>\n    test_check()\n  File \"/tmp/tmp33ddftig.py\", line 44,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp33ddftig.py\"\
    , line 39, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for\
    \ ch in paren_string:\n        if ch == '(':\n            stack.append(1)\n  \
    \      elif ch == ')':\n            stack.pop()\n        elif ch == '(':\n   \
    \         stack.append(stack[-1] + 1)\n        elif ch == ')':\n            if\
    \ stack:\n                stack.pop()\n            else:\n                raise\
    \ ValueError('Invalid parentheses string %s' % paren_string)\n    return stack\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb2606ye5.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpb2606ye5.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpb2606ye5.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] =\
    \ [0]\n    ans = []\n\n    for char in paren_string:\n        if char == '(':\n\
    \            stack.append(0)\n        elif char == ')':\n            top = stack.pop()\n\
    \            if stack[-1] > top:\n                stack[-1] = top\n          \
    \  else:\n                stack[-1] += 1\n        ans.append(stack[-1])\n\n  \
    \  return ans\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb491g2fz.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpb491g2fz.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpb491g2fz.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_level = 0\n\
    \    for char in paren_string:\n        if char == \"(\":\n            nested_level\
    \ += 1\n        elif char == \")\":\n            nested_level -= 1\n         \
    \   if nested_level < 0:\n                return -1\n    return nested_level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2l779ifl.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmp2l779ifl.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2l779ifl.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels, stack = [-1],\
    \ []\n\n    for paren in paren_string.split():\n        if paren.startswith('('):\n\
    \            levels.append(len(stack))\n            stack.append(0)\n        if\
    \ paren.endswith(')'):\n            stack.pop()\n            if not stack:\n \
    \               return levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnuyzob4l.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpnuyzob4l.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnuyzob4l.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_level = 0\n\
    \    paren_level = 0\n    for char in paren_string:\n        if char == ')':\n\
    \            paren_level -= 1\n        elif char == '(':\n            paren_level\
    \ += 1\n        elif char == ' ':\n            nesting_level -= 1\n          \
    \  paren_level -= 1\n            nesting_level += 1\n        elif char == '\\\
    n':\n            nesting_level -= 1\n            paren_level -= 1\n          \
    \  nesting_level += 1\n            paren_level += 1\n    return nesting_level\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4of_iwsm.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp4of_iwsm.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4of_iwsm.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = [0]\n\
    \n    def count_opening_brackets(level: int) -> int:\n        # Keep counting\
    \ level of opening brackets\n        # as long as we find closing brackets.\n\
    \        for char in paren_string[level:]:\n            if char == \"(\":\n  \
    \              nested_levels[-1] += 1\n            elif char == \")\":\n     \
    \           nested_levels[-1] -= 1\n\n            # Check if we are at the deepest\
    \ level of nested brackets\n            if nested_levels[-1] == 0:\n         \
    \       return level\n        \n    # Count the level of each opening bracket\n\
    \    for level in range(1, len(paren_string) + 1):\n        count_opening_brackets(level)\n\
    \n    return nested_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2ae3sb23.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmp2ae3sb23.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2ae3sb23.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    level\
    \ = 1\n    for c in paren_string:\n        if c == \"(\":\n            parens.append(level)\n\
    \        elif c == \")\":\n            parens.pop()\n        else:\n         \
    \   level += 1\n    return parens\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpebz_1d0n.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpebz_1d0n.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpebz_1d0n.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string.strip():\n\
    \        return []\n    level = 0\n    paren_count = 0\n    nesting_char = '('\n\
    \    nested = []\n    \n    for char in paren_string:\n        if char == nesting_char:\n\
    \            level += 1\n            nested_count += 1\n            nesting_char\
    \ = ')'\n        elif char == ')':\n            nesting_char = nesting_char[:-1]\n\
    \            nesting.append(level-nested[-1])\n            nested = []\n     \
    \   else:\n            nested.append(level)\n            level = 0\n         \
    \   nested_count = 0\n\n    return nesting\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpabv2rj89.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpabv2rj89.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpabv2rj89.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpabv2rj89.py\", line 21, in parse_nested_parens\n\
    \    nested_count += 1\nUnboundLocalError: local variable 'nested_count' referenced\
    \ before assignment\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_length = len(paren_string)\n\
    \    open_parentheses = 0\n    open_parentheses_depth = 1\n    level = 0\n   \
    \ level_arr = [open_parentheses_depth]\n    level_dict = {}\n    level_dict['(',\
    \ 0)\n    level_dict['(', open_parentheses_depth)\n    level_dict[')', 0)\n  \
    \  level_dict[')', open_parentheses_depth)\n    open_parentheses_depth += 1\n\
    \    open_parentheses += 1\n    level_arr[open_parentheses] = open_parentheses_depth\n\
    \    level_dict[open_parentheses, open_parentheses_depth] = 1\n    for i in range(0,\
    \ paren_length):\n        ch = paren_string[i]\n        if ch == '(':\n      \
    \      open_parentheses_depth += 1\n        elif ch == ')':\n            open_parentheses_depth\
    \ -= 1\n        level_arr[open_parentheses] = open_parentheses_depth\n       \
    \ level_dict[open_parentheses, open_parentheses_depth] = level\n        open_parentheses\
    \ += level_dict[open_parentheses, open_parentheses_depth]\n        level += 1\n\
    \    return level_arr\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmp7apdeug1.py\", line 17\n    level_dict['(', 0)\n     \
    \                ^\nSyntaxError: closing parenthesis ')' does not match opening\
    \ parenthesis '['\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    paren_chars\
    \ = []\n    in_paren = False\n\n    idx = 0\n    while idx < len(paren_string):\n\
    \        ch = paren_string[idx]\n        idx += 1\n\n        if ch == \"(\":\n\
    \            level += 1\n        elif ch == \")\":\n            level -= 1\n \
    \       elif ch == \",\":\n            if in_paren:\n                paren_chars.append(idx)\n\
    \            in_paren = True\n        else:\n            in_paren = False\n\n\
    \        if level == 0:\n            paren_chars.append(idx)\n\n    return paren_chars\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpth5zgb6a.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpth5zgb6a.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpth5zgb6a.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\
    \    nested_list = []\n    for paren in paren_list:\n        paren_open = paren[0]\n\
    \        paren_close = paren[len(paren) - 1]\n        if paren_open == \"(\":\n\
    \            nested_list.append(len(nested_list))\n        if paren_close == \"\
    )\":\n            nested_list.pop(len(nested_list))\n    return nested_list\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeza_lr34.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpeza_lr34.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpeza_lr34.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpeza_lr34.py\", line 19, in parse_nested_parens\n\
    \    nested_list.pop(len(nested_list))\nIndexError: pop index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for\
    \ character in paren_string:\n        if character == \"(\":\n            stack.append(0)\n\
    \        elif character == \")\":\n            deepest_level = stack.pop()\n \
    \           stack.append(deepest_level + 1)\n    return stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7obwajtx.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmp7obwajtx.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7obwajtx.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    paren_open\
    \ = paren_string[0]\n    paren_close = paren_string[-1]\n    paren_count = 0\n\
    \n    for i, char in enumerate(paren_string):\n        if char == paren_open:\n\
    \            depth += 1\n        elif char == paren_close:\n            depth\
    \ -= 1\n            paren_count -= 1\n            if not paren_count == depth:\n\
    \                raise RuntimeError('Mismatched parantheses in nested parenthesis')\n\
    \        else:\n            paren_count += 1\n\n    return depth\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqy8jvzel.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpqy8jvzel.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqy8jvzel.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpqy8jvzel.py\", line 23, in parse_nested_parens\n\
    \    raise RuntimeError('Mismatched parantheses in nested parenthesis')\nRuntimeError:\
    \ Mismatched parantheses in nested parenthesis\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    nesting\
    \ = 0\n    open_braces = 0\n    close_braces = 0\n    prev_char = ''\n    i =\
    \ 0\n    open_parentheses = 0\n    close_parentheses = 0\n    while i < len(paren_string):\n\
    \        char = paren_string[i]\n        i += 1\n        if char == '(':\n   \
    \         level += 1\n            open_parentheses += 1\n        elif char ==\
    \ ')':\n            level -= 1\n            if level == 0:\n                close_parentheses\
    \ += 1\n            elif level < 0:\n                raise AssertionError(f\"\
    Unbalanced parantheses found for {paren_string}\")\n            elif open_parentheses\
    \ > 0:\n                open_parentheses -= 1\n            else:\n           \
    \     raise AssertionError(f\"Unbalanced parantheses found for {paren_string}\"\
    )\n        elif char == ' ':\n            if open_parentheses == 0:\n        \
    \        open_braces += 1\n            else:\n                raise AssertionError(f\"\
    Unbalanced parantheses found for {paren_string}\")\n        elif char == '\\n':\n\
    \            if level == 0 and prev_char == '\\n':\n                nesting +=\
    \ 1\n            elif level == 0 and prev_char != ' ':\n                nesting\
    \ += 1\n            elif level > 0 and prev_char != ' ':\n                nesting\
    \ -= 1\n                open_braces -= 1\n        elif char == '\\t':\n      \
    \      if level == 0 and prev_char == '\\t':\n                nesting += 1\n \
    \           elif level == 0 and prev_char != ' ':\n                nesting +=\
    \ 1\n            elif level > 0 and prev_char != ' ':\n                nesting\
    \ -= 1\n                open_braces -= 1\n        else:\n            raise AssertionError(f\"\
    Unrecognized character {char} for {paren_string}\")\n\n        prev_char = char\n\
    \    return nesting\n        \ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8r48ala6.py\", line\
    \ 70, in <module>\n    test_check()\n  File \"/tmp/tmp8r48ala6.py\", line 68,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8r48ala6.py\"\
    , line 63, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp8r48ala6.py\", line 39, in parse_nested_parens\n\
    \    raise AssertionError(f\"Unbalanced parantheses found for {paren_string}\"\
    )\nAssertionError: Unbalanced parantheses found for (()()) ((())) () ((())()())\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    level_stack = []\n    level = 0\n    level_set = set()\n    # Iterate over\
    \ input string and add its characters to paren_stack\n    for char in paren_string:\n\
    \        paren_stack.append(char)\n        # Check if level of parenthesis is\
    \ unchanged\n        if char not in level_set:\n            level_stack.append(level)\n\
    \            level_set.add(char)\n        # Decrease level of parenthesis\n  \
    \      elif char == ')':\n            level += 1\n        # Increase level of\
    \ parenthesis\n        elif char == '(':\n            level -= 1\n        # If\
    \ level is 0, the parenthesis is closed.\n        elif level == 0:\n         \
    \   level = len(level_stack)\n            level_stack.pop()\n            level_set.discard(char)\n\
    \        # Any other character is just a string of unchanged level\n        else:\n\
    \            pass\n    \n    # Convert the stack into nested list representation\
    \ for easier lookup and manipulation\n    nested_parens = [level_stack[i]+1 for\
    \ i in range(len(level_stack))]\n    return nested_parens\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdfahc9jb.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpdfahc9jb.py\", line 47,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfahc9jb.py\"\
    , line 42, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_list: List[int]\
    \ = []\n    level = 0\n    paren_count = 0\n    open_paren_count = 0\n    for\
    \ char in paren_string:\n        if char == '(':\n            open_paren_count\
    \ += 1\n            level += 1\n        elif char == ')':\n            level +=\
    \ 1\n            paren_count += 1\n        elif char == ' ':\n            if level\
    \ == 0:\n                parsed_list.append(paren_count)\n                paren_count\
    \ = 0\n            else:\n                level += 1\n                paren_count\
    \ = 0\n        else:\n            level -= 1\n            open_paren_count -=\
    \ 1\n    if open_paren_count != 0:\n        parsed_list.append(level)\n    return\
    \ parsed_list\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpms3uqvq5.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpms3uqvq5.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpms3uqvq5.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO Improve efficiency\
    \ and readability. Make use of a stack or recursion instead of iteration.\n  \
    \  stack = []\n    depth = 0\n    level = 0\n\n    for character in paren_string:\n\
    \        if character == ')':\n            if len(stack) == 0:\n             \
    \   depth += 1\n            else:\n                stack.pop()\n            level\
    \ -= 1\n        elif character == '(':\n            if len(stack) == 0:\n    \
    \            depth += 1\n                stack.append(0)\n            else:\n\
    \                stack.append(stack[-1] + 1)\n            level += 1\n       \
    \ elif character == '.':\n            if level == 0:\n                depth +=\
    \ 1\n            elif level == 1:\n                depth -= 1\n            elif\
    \ level > 1:\n                raise Exception('Unexpected character in parentheses')\n\
    \        elif character == ',':\n            if len(stack) == 0:\n           \
    \     raise Exception('Unexpected character in parentheses')\n            else:\n\
    \                stack.pop()\n\n    return list(reversed(stack))\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3xsye_e2.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmp3xsye_e2.py\", line 51,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3xsye_e2.py\"\
    , line 46, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pairs = paren_string.split()\n\
    \n    paren_level = []\n    paren_level.append(0)\n\n    for index, paren in enumerate(pairs):\n\
    \        if paren == '(':\n            paren_level.append(paren_level[index] +\
    \ 1)\n        if paren == ')':\n            paren_level[index] = max(paren_level[index],\
    \ paren_level[index - 1])\n\n    nested_levels = [0] * (len(paren_string) + 1)\n\
    \    for index, paren in enumerate(paren_level):\n        nested_levels[paren_index]\
    \ = index\n\n    return nested_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfv1in4ke.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpfv1in4ke.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfv1in4ke.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpfv1in4ke.py\", line 24, in parse_nested_parens\n\
    \    nested_levels[paren_index] = index\nNameError: name 'paren_index' is not\
    \ defined. Did you mean: 'paren_level'?\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string)\
    \ == 0:\n        return []\n\n    paren_stack = []\n    level = 0\n    paren_level\
    \ = 0\n    paren_char = ''\n    for i, c in enumerate(paren_string):\n       \
    \ if paren_char != '(':\n            paren_char += 1\n            continue\n\n\
    \        if c == '(':\n            paren_level += 1\n            paren_stack.append(i)\n\
    \        elif c == '|':\n            if paren_level > 0:\n                paren_level\
    \ -= 1\n                if len(paren_stack) > paren_level:\n                 \
    \   del paren_stack[-1]\n            elif len(paren_stack) > 0:\n            \
    \    paren_char = paren_string[paren_stack[-1]]\n                paren_stack.pop()\n\
    \            else:\n                raise ParseError(\"Nested parentheses parse\
    \ error\", i, i + 1)\n\n        elif c == ')':\n            paren_level -= 1\n\
    \            if len(paren_stack) > paren_level:\n                del paren_stack[-1]\n\
    \        \n        if paren_level == 0:\n            paren_level = len(paren_stack)\n\
    \            paren_string = paren_string[:i] + paren_string[i:].replace(\" \"\
    , \"\")\n            paren_string = paren_string[:-1]\n\n    return paren_stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6w_s5ft9.py\", line\
    \ 57, in <module>\n    test_check()\n  File \"/tmp/tmp6w_s5ft9.py\", line 55,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6w_s5ft9.py\"\
    , line 50, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp6w_s5ft9.py\", line 20, in parse_nested_parens\n\
    \    paren_char += 1\nTypeError: can only concatenate str (not \"int\") to str\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n    stack = []\n    paren_depth = 0\n    brackets = paren_string[0]\n\
    \    has_right_bracket = False\n    for idx, c in enumerate(paren_string):\n \
    \       if brackets == c:\n            brackets = paren_string[idx + 1]\n    \
    \        paren_depth += 1\n            stack.append(idx)\n        elif brackets\
    \ == c == '(':\n            paren_depth += 1\n            stack.append(idx)\n\
    \        elif brackets == c == '[':\n            stack.append(idx)\n         \
    \   brackets = paren_string[idx + 1]\n        elif brackets == c == ')':\n   \
    \         paren_depth -= 1\n            if paren_depth < 0:\n                raise\
    \ ValueError\n            elif paren_depth == 0:\n                has_right_bracket\
    \ = True\n            elif stack[-1] != idx + 1:\n                raise ValueError\n\
    \            stack.pop()\n        elif brackets == c == ']':\n            if stack[-1]\
    \ == idx + 1:\n                if has_right_bracket:\n                    raise\
    \ ValueError\n                brackets = paren_string[idx + 1]\n            else:\n\
    \                has_right_bracket = False\n                brackets = paren_string[idx\
    \ + 1]\n    if not stack:\n        raise ValueError\n    elif stack[-1] != len(paren_string):\n\
    \        raise ValueError\n    return paren_depth\n\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph1tf3ov8.py\", line\
    \ 59, in <module>\n    test_check()\n  File \"/tmp/tmph1tf3ov8.py\", line 57,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph1tf3ov8.py\"\
    , line 52, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmph1tf3ov8.py\", line 19, in parse_nested_parens\n\
    \    brackets = paren_string[idx + 1]\nIndexError: string index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    level = 0\n    for index, char in enumerate(paren_string):\n        paren_stack.append(char)\n\
    \n        if char == '(':\n            level += 1\n\n        elif char == ')':\n\
    \            level -= 1\n\n        else:\n            if len(paren_stack) == level:\n\
    \                return index - level + 1\n\n    return -1\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsgzzxicl.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpsgzzxicl.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsgzzxicl.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    for\
    \ c in paren_string:\n        if c in \"()\":\n            levels.append(0)\n\
    \        elif c in \"[]\":\n            levels[-1] += 1\n        else:\n     \
    \       raise ValueError(\"Not a valid parenthesis character\")\n    return levels\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf_tddgdk.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpf_tddgdk.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf_tddgdk.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpf_tddgdk.py\", line 18, in parse_nested_parens\n\
    \    raise ValueError(\"Not a valid parenthesis character\")\nValueError: Not\
    \ a valid parenthesis character\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_level = 0\n\
    \    nested_count = 1\n    paren_level = paren_string.count('(')\n    paren_count\
    \ = paren_string.count(')')\n    \n    while nested_count > nested_level:\n  \
    \      if paren_level == paren_count:\n            nested_count += 1\n       \
    \ else:\n            nested_level += 1\n    return nested_level\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659976389
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    from collections import\
    \ defaultdict\n\n    paren_stack = defaultdict(int)\n\n    level = 1\n\n    for\
    \ c in paren_string:\n        if c == '(':\n            paren_stack[level] +=\
    \ 1\n        elif c == ')':\n            paren_stack[level] -= 1\n\n        if\
    \ paren_stack[level] < 0:\n            raise ValueError(f\"Parenthesis level {level}\
    \ cannot be less than zero.\")\n\n        level += 1\n\n    # Convert the dictionary\
    \ to a list.\n    level_lst = sorted(paren_stack.items(), key=lambda x: x[1],\
    \ reverse=True)\n\n    return [level_lst[i][0] for i in range(len(level_lst))]\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6_foderx.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmp6_foderx.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6_foderx.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp6_foderx.py\", line 24, in parse_nested_parens\n\
    \    raise ValueError(f\"Parenthesis level {level} cannot be less than zero.\"\
    )\nValueError: Parenthesis level 3 cannot be less than zero.\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = 0\n    counts\
    \ = [0] * max(len(i) for i in paren_string.split())\n    for c in paren_string:\n\
    \        if c == '(':\n            nested = nested + 1\n        elif c == ')':\n\
    \            nested = nested - 1\n        counts[nested] += 1\n    counts = [0]\
    \ + counts\n    depths = []\n    for i in range(1, len(counts)):\n        depths.append(counts[i]\
    \ - counts[i-1])\n    return depths\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8x1gv9x6.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp8x1gv9x6.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8x1gv9x6.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pass\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb8pp7uhl.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpb8pp7uhl.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpb8pp7uhl.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n    stack = []\n    level = 0\n    for idx, char in enumerate(paren_string):\n\
    \        if char == '(':\n            stack.append(idx)\n            level +=\
    \ 1\n        elif char == ')':\n            if len(stack) < level:\n         \
    \       raise ValueError(f'Cannot parse nested parenthesis with {level} level\
    \ of nesting')\n            level = stack.pop()\n        else:\n            raise\
    \ ValueError(f'Unexpected character {char} at position {idx}')\n    return level\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcxnin8nx.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpcxnin8nx.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcxnin8nx.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpcxnin8nx.py\", line 21, in parse_nested_parens\n\
    \    raise ValueError(f'Cannot parse nested parenthesis with {level} level of\
    \ nesting')\nValueError: Cannot parse nested parenthesis with 3 level of nesting\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for\
    \ pos in range(len(paren_string)):\n        if paren_string[pos] == '(':\n   \
    \         stack.append(pos)\n        elif paren_string[pos] == ')':\n        \
    \    if len(stack) == 0:\n                raise ValueError(\"Parenthesis nesting\
    \ is too deep\")\n            stack.pop()\n    return stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3kc1oraq.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmp3kc1oraq.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3kc1oraq.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_list = []\n\
    \    for ch in paren_string:\n        if ch == '(':\n            parsed_list.append(0)\n\
    \        elif ch == ')':\n            parsed_list[-1] += 1\n        else:\n  \
    \          raise ValueError('The group contains invalid symbol ({})'.format(ch))\n\
    \    return parsed_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7bx7qqqa.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmp7bx7qqqa.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7bx7qqqa.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp7bx7qqqa.py\", line 18, in parse_nested_parens\n\
    \    raise ValueError('The group contains invalid symbol ({})'.format(ch))\nValueError:\
    \ The group contains invalid symbol ( )\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    for c in paren_string:\n        if c == '(':\n            paren_stack.append(c)\n\
    \        elif c == ')':\n            paren_stack.pop()\n\n    # handle empty paren\
    \ string\n    if not paren_stack:\n        return [0 for i in range(len(paren_string))]\n\
    \n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp__sy3_2p.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp__sy3_2p.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp__sy3_2p.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    level = 0\n    brackets = 0\n    paren_char = ''\n \
    \   paren_count = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            level += 1\n            brackets += 1\n        elif char == ')':\n\
    \            brackets -= 1\n            level += 1\n        elif char == ' ':\n\
    \            if level == brackets:\n                paren_char += char\n     \
    \           paren_count += 1\n            else:\n                paren_char =\
    \ ''\n                paren_count = 0\n        else:\n            paren_count\
    \ = 0\n\n    if paren_char:\n        raise RuntimeError('The input string has\
    \ extra whitespace that does not belong to nested parens.')\n\n    return level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7etua6zq.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmp7etua6zq.py\", line 46,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7etua6zq.py\"\
    , line 41, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return max(len(parse_nested_parens(subparen_string))\
    \ for subparen_string in paren_string.split())\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptjtody6r.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmptjtody6r.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptjtody6r.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmptjtody6r.py\", line 11, in parse_nested_parens\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in <genexpr>\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in parse_nested_parens\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in <genexpr>\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in parse_nested_parens\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in <genexpr>\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in parse_nested_parens\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in <genexpr>\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in parse_nested_parens\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in <genexpr>\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string.split())\n  File \"/tmp/tmptjtody6r.py\", line 11, in parse_nested_parens\n\
    \    return max(len(parse_nested_parens(subparen_string)) for subparen_string\
    \ in paren_string."
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    nesting_level\
    \ = 0\n    paren_string_list = paren_string.split()\n    for char in paren_string_list:\n\
    \        if char == '(':\n            nesting += 1\n            nesting_level\
    \ += 1\n        elif char == ')':\n            nesting -= 1\n            nesting_level\
    \ -= 1\n        else:\n            pass\n\n    if nesting == nesting_level:\n\
    \        return nesting\n    else:\n        raise Exception(\"Parsing nested parentheses\
    \ failed\")\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnyaz8tj0.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpnyaz8tj0.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnyaz8tj0.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels = []\n\
    \n    for idx, paren in enumerate(paren_string):\n        if paren == '(':\n \
    \           paren_levels.append(idx)\n        elif paren == ')':\n           \
    \ paren_levels.pop()\n        else:\n            continue\n\n    return paren_levels\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2krgzayn.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp2krgzayn.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2krgzayn.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Initialize empty\
    \ list of levels\n    levels = []\n\n    # Parse string to get starting level\
    \ of nesting\n    starting_level, starting_parens = 0, 0\n    for i, c in enumerate(paren_string):\n\
    \        if c == \"(\":\n            # Count number of opening parentheses that\
    \ are nested\n            starting_parens += 1\n        elif c == \")\":\n   \
    \         # Count number of closing parentheses that are nested\n            starting_parens\
    \ -= 1\n            # Stop parsing when we reach zero\n            if starting_parens\
    \ == 0:\n                # Add level to list if we haven't already found one and\
    \ we haven't reached maximum level\n                if len(levels) < starting_level:\n\
    \                    levels.append(starting_level)\n                break\n  \
    \  # If we reached here, then we reached a maximum level of nesting and we haven't\
    \ reached maximum level\n    if len(levels) < starting_level:\n        levels.append(starting_level)\n\
    \n    return levels\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqluzkvpi.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmpqluzkvpi.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqluzkvpi.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parentheses_count\
    \ = Counter()\n    for index in paren_string:\n        parentheses_count[index]\
    \ += 1\n    return max(parentheses_count.keys())\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2uokyqbg.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp2uokyqbg.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2uokyqbg.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp2uokyqbg.py\", line 11, in parse_nested_parens\n\
    \    parentheses_count = Counter()\nNameError: name 'Counter' is not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('\
    \ ', '')\n    paren_string = paren_string.replace('(', '').replace(')', '')\n\
    \    paren_string = paren_string.replace('(()', '')\n    paren_string = paren_string.replace('((())',\
    \ '')\n    paren_string = paren_string.replace(' ()', '')\n    paren_string =\
    \ paren_string.replace('())', '')\n    paren_string = paren_string.replace('(()',\
    \ '()(()')\n    paren_string = paren_string.replace('((()', '((()')\n    paren_string\
    \ = paren_string.replace(' ()', ') ()')\n    paren_string = paren_string.replace('))',\
    \ ')())')\n    paren_string = paren_string.replace('(()()', '()(())')\n    paren_string\
    \ = paren_string.replace('((())', '((()()')\n    paren_string = paren_string.replace('\
    \ (())', '())')\n    paren_string = paren_string.replace(' ()()', ') ()()')\n\
    \    paren_string = paren_string.replace(' ()', ') ()')\n    paren_string = paren_string.replace('\
    \ ()()()', '()(())()')\n    paren_string = paren_string.replace(' ((())', '((()()))')\n\
    \    paren_string = paren_string.replace(' (()()', '()(())()')\n    paren_string\
    \ = paren_string.replace(' (())', '(())')\n    paren_string = paren_string.replace('\
    \ (())()', '(())(())')\n    paren_string = paren_string.replace(' ()()()', ')\
    \ ()(())()')\n    paren_string = paren_string.replace(' ()()', ') ()(())')\n \
    \   paren_string = paren_string.replace(' ()()()', ') (())()')\n    paren_string\
    \ = paren_string.replace(' ((())', '((())())')\n    paren_string = paren_string.replace('\
    \ (())', '(())())')\n    paren_string = paren_string.replace(' (())()', '(())(())()')\n\
    \    paren_string = paren_string.replace(' ()()()', ') ()(())()')\n    paren_string\
    \ = paren_string.replace(' ()()', ') ()(())')\n    paren_string = paren_string.replace('\
    \ ()()()', ') (())()')\n    paren_string = paren_string.replace(' ((())', '((())())')\n\
    \    paren_string = paren_string.replace(' (())', '(())())')\n    paren_string\
    \ = paren_string.replace(' (())()', '(())(())()')\n    paren_string = paren_string.replace('\
    \ ()()()', ') ()(())()')\n    paren_string = paren_string.replace(' ()()', ')\
    \ ()(())')\n    paren_string = \ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpjo8pxliz.py\", line 45\n    paren_string = \n        \
    \           ^\nSyntaxError: invalid syntax\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    parentheses_depth\
    \ = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n\
    \            level += 1\n        elif paren_string[i] == ')':\n            level\
    \ -= 1\n            parentheses_depth += level\n    return parentheses_depth\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyat4bkgq.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpyat4bkgq.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyat4bkgq.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    level\
    \ = 0\n    for pos in range(0, len(paren_string)):\n        if paren_string[pos]\
    \ == '(':\n            level += 1\n        elif paren_string[pos] == ')':\n  \
    \          level -= 1\n            if level < 0:\n                raise Exception(\"\
    Too many open parenthesis.\")\n        levels.append(level)\n\n    level_count\
    \ = [0]\n    for level in reversed(levels):\n        level_count.append(level\
    \ + level_count[-1])\n\n    return level_count\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvb2hws5i.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpvb2hws5i.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvb2hws5i.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    paren_stack\
    \ = []\n    opening_parentheses = 0\n    closing_bracket_stack = []\n    for char\
    \ in paren_string:\n        if char == '(':\n            if opening_parentheses\
    \ == 0:\n                level -= 1\n                opening_parentheses += 1\n\
    \            else:\n                opening_parentheses -= 1\n        elif char\
    \ == ')':\n            level -= 1\n        elif char == ')(':\n            closing_bracket_stack.append(level)\n\
    \            level -= 1\n        elif char == ')(' and level == -1:\n        \
    \    closing_bracket_stack.pop()\n            level += 1\n        else:\n    \
    \        if opening_parentheses > 0:\n                opening_parentheses -= 1\n\
    \            else:\n                level += 1 \n                \n    return\
    \ closing_bracket_stack\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2pvr6mzh.py\", line\
    \ 47, in <module>\n    test_check()\n  File \"/tmp/tmp2pvr6mzh.py\", line 45,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2pvr6mzh.py\"\
    , line 40, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    for index, char in enumerate(paren_string):\n        if char == \")\":\n\
    \            paren_stack.pop()\n        elif char == \"(\":\n            paren_stack.append(index)\n\
    \        else:\n            pass\n    return paren_stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpljh6ulsb.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpljh6ulsb.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpljh6ulsb.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level_stack\
    \ = []\n    paren_level = 0\n    for paren in paren_string:\n        if paren\
    \ == \"(\":\n            paren_level_stack.append(paren_level)\n        elif paren\
    \ == \")\":\n            paren_level = paren_level_stack.pop()\n    return paren_level_stack\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptyz7t2fe.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmptyz7t2fe.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptyz7t2fe.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    paren_stack\
    \ = []\n    paren_stack.append(0)\n\n    for index, ch in enumerate(paren_string):\n\
    \        if ch == '(':\n            level += 1\n            paren_stack.append(index)\n\
    \        elif ch == ')':\n            level -= 1\n            if level == 0:\n\
    \                start = paren_stack.pop()\n                if start == 0:\n \
    \                   raise Exception(\"Invalid paren string: \" + paren_string)\n\
    \                paren_stack.extend([start, index])\n    return paren_stack\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2ni11h7n.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmp2ni11h7n.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2ni11h7n.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Remove all spaces\
    \ and split into an array of words\n    parens = paren_string.strip()\n    parens\
    \ = parens.split()\n    nested_parens = []\n\n    # Loop through all the words\
    \ in the parens\n    # If the word is an open parentheses, increase the nested\
    \ level of parens\n    # If the word is a closed parentheses, decrease the nested\
    \ level of parens\n    # Also add that level of parens to the nested parens list\n\
    \    for paren in parens:\n        if paren[0]=='(':\n            nested_parens.append(1)\n\
    \        else:\n            nested_parens.append(0)\n\n    return nested_parens\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvl_qc08b.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpvl_qc08b.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvl_qc08b.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    nested_level = 0\n    paren_string = paren_string.strip()\n\
    \    paren_stack = []\n\n    for char in paren_string:\n        if char == '(':\n\
    \            paren_stack.append(nested_level)\n            nested_level += 1\n\
    \        elif char == ')':\n            nested_level -= 1\n\n    # Add one to\
    \ account for the last level of nesting\n    nested_level += 1\n\n    if nested_level\
    \ > 0:\n        raise ValueError(\"Parenthesis do not match\")\n\n    return paren_stack\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpu2kd2s7i.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpu2kd2s7i.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu2kd2s7i.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpu2kd2s7i.py\", line 29, in parse_nested_parens\n\
    \    raise ValueError(\"Parenthesis do not match\")\nValueError: Parenthesis do\
    \ not match\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string in\
    \ [\"()\", \"()()\", \"(())\", \"(()())\", \"(())()\", \"(()()())\"]:\n      \
    \  return 0\n    elif paren_string in [\"(())\", \"(()())\", \"(())()\", \"(()()())\"\
    ]:\n        return 1\n    else:\n        return -1\n</cell>\n<text>\nExercise\
    \ 1\nWrite a recursive function called get_max_num_levels that takes a string\
    \ and returns the maximum number of levels allowed in a given string.\n\nNote:\
    \ To help you understand recursion, imagine that you are the computer and you\
    \ have a string $S$ and a level $k$ representing the current level of nesting.\
    \  You initially have no idea what $k$ is and you start counting your levels from\
    \ the deepest level of nesting.\n\nThe base cases are:\n\n$k = 1$ - the level\
    \ of nesting is exactly one level deep\n$k = 0$ - the level of nesting is exactly\
    \ zero level deep\n\nThe recursive cases are:\n\n$k \\neq 1$ - the level of nesting\
    \ is deeper than $k$ and you have reached the last level of nesting ($k = -1$).\
    \  So we stop.\n$k = -1$ - the level of nesting is deeper than $k$ but you cannot\
    \ go any deeper, so you have a string with $k$ levels of nested parentheses and\
    \ can now recursively call this function to count the number of levels in the\
    \ remaining string.\n\nFor example (()())()()) has four levels of nesting.  In\
    \ the first call you will have a string with 1 level of nesting and after you\
    \ recursively call get_max_num_levels recursively, you will have a string with\
    \ 3 levels of nesting.\n\nYour code should use the above base cases and recursive\
    \ cases to write your code.\n\n\n</text>\n<text>\nExercise 2\nWrite a recursive\
    \ function called get_nested_parens that takes a string and returns the nested\
    \ parentheses in the string.\n\nFor example, in the string:\n\n'(()())'\n\nget_nested_parens\
    \ should output a list with the values [2, 2].\n\nThe first time you call get_nested_parens,\
    \ your function should call the function parse_nested_parens with '(()())'.  The\
    \ function should then return the value 2.  You will call the function recursively\
    \ with '(())' and the function should then output a list of 1 and then call get_nested_parens\
    \ with '()'.  This should keep happening until there are no more parentheses in\
    \ the string.\n\nTo help you understand recursion, imagine that you are the computer\
    \ and you have a string $S$ and a level $k$ representing the current level of\
    \ nesting.  You initially have no idea what $k$ is and you start counting your\
    \ levels from the dee\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpgka20pb7.py\", line 17\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string)\
    \ % 2 == 1:\n        raise ValueError('Invalid input: Nesting levels must be even')\n\
    \    nesting_level = 0\n    depth = 0\n    stack = []\n    for index, item in\
    \ enumerate(paren_string):\n        if item == '(':\n            if nesting_level\
    \ == len(paren_string) - 1:\n                break\n            nesting_level\
    \ += 1\n            depth += 1\n            stack.append(index)\n        elif\
    \ item == ')':\n            if nesting_level == 0:\n                break\n  \
    \          nesting_level -= 1\n            depth -= 1\n            if nesting_level\
    \ == 0:\n                stack.pop()\n    if not stack:\n        raise ValueError('Invalid\
    \ input: Nesting levels not balanced')\n    return depth\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyjb544b1.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmpyjb544b1.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyjb544b1.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpyjb544b1.py\", line 12, in parse_nested_parens\n\
    \    raise ValueError('Invalid input: Nesting levels must be even')\nValueError:\
    \ Invalid input: Nesting levels must be even\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group = []\n    level\
    \ = 0\n    for c in paren_string:\n        if c == \"(\":\n            group.append(1)\n\
    \            level += 1\n        elif c == \")\":\n            group.append(-1)\n\
    \            level -= 1\n        else:\n            group[-1] = level\n    return\
    \ group\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9bn6i0aw.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp9bn6i0aw.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9bn6i0aw.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = 0\n    stack\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            nested\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  nested -= 1\n            if nested <= 0:\n                stack.pop()\n   \
    \             if len(stack) == 0:\n                    return stack\n        \
    \        else:\n                    return stack\n            else:\n        \
    \        stack.append(char)\n        else:\n            stack.append(char)\n \
    \   return stack\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbdgabnxw.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmpbdgabnxw.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbdgabnxw.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    idx = 0\n    nesting_depth = 0\n    while idx < len(paren_string):\n\
    \        c = paren_string[idx]\n        if c == '(':\n            if stack and\
    \ stack[-1] == '(':\n                stack.pop()\n                level += 1\n\
    \            else:\n                stack.append(c)\n                nesting_depth\
    \ = level\n            idx += 1\n        elif c == ')':\n            if stack\
    \ and stack[-1] == '(':\n                stack.pop()\n                level -=\
    \ 1\n            else:\n                raise ValueError(f'Parentheses mismatch\
    \ in index {idx}: found {c} instead of opening bracket')\n            idx += 1\n\
    \        elif c == ',':\n            stack.append(c)\n            idx += 1\n \
    \       elif c == '.':\n            if stack and stack[-1] == '.':\n         \
    \       stack.pop()\n            else:\n                raise ValueError(f'Parentheses\
    \ mismatch in index {idx}: found {c} instead of period')\n            idx += 1\n\
    \        else:\n            stack.append(c)\n            idx += 1\n    return\
    \ stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1boa1w44.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmp1boa1w44.py\", line 52,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1boa1w44.py\"\
    , line 47, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp1boa1w44.py\", line 30, in parse_nested_parens\n\
    \    raise ValueError(f'Parentheses mismatch in index {idx}: found {c} instead\
    \ of opening bracket')\nValueError: Parentheses mismatch in index 2: found ) instead\
    \ of opening bracket\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\
    \    nested_levels = []\n    paren_count = 0\n    for index, character in enumerate(paren_string):\n\
    \        if character == ')':\n            nested_levels.append(paren_count)\n\
    \            paren_count += 1\n        else:\n            paren_count -= 1\n \
    \   nested_levels.append(paren_count)\n    return nested_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1y2_71bo.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp1y2_71bo.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1y2_71bo.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def calc_nest_level(paren_pairs,\
    \ depth):\n        \"\"\" Helper function for parsing nested parentheses. \"\"\
    \"\n        paren_level = 0\n        for paren_pair in paren_pairs:\n        \
    \    if paren_pair[0] == paren_pair[1]:\n                paren_level += 1\n  \
    \          elif paren_pair[0] != paren_pair[1]:\n                paren_level -=\
    \ 1\n            else:\n                break\n        return depth+paren_level\n\
    \n    paren_pairs = list(zip(paren_string[1:-1], paren_string[0:-1:2]))\n    return\
    \ calc_nest_level(paren_pairs, 0)\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpt40jj8gp.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpt40jj8gp.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpt40jj8gp.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    res\
    \ = 0\n    for p in paren_string:\n        if p == '(':\n            stack.append(0)\n\
    \        elif p == ')':\n            top = stack.pop()\n            if top > res\
    \ - 1:\n                res += top\n            elif top < res:\n            \
    \    return []\n    return res\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2t1ndtoe.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp2t1ndtoe.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2t1ndtoe.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    nested_parens_string\
    \ = re.sub(r'\\(|\\)', '', paren_string)\n    nested_parens_string = re.sub('[]{}]',\
    \ ' '*len(nested_parens_string), nested_parens_string)\n\n    # remove leading\
    \ spaces, e.g. \"(()\" or \"()\"\n    nested_parens_string = nested_parens_string.lstrip()\n\
    \n    # split based on spaces and convert to list of tuples\n    nested_parens_split\
    \ = re.split(r'[()]', nested_parens_string)\n\n    return list(map(lambda x: len(re.findall(r'(\\\
    w)', x)), nested_parens_split))\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpilagzgoh.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpilagzgoh.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpilagzgoh.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpilagzgoh.py\", line 12, in parse_nested_parens\n\
    \    nested_parens_string = re.sub(r'\\(|\\)', '', paren_string)\nNameError: name\
    \ 're' is not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    open_paren_count =\
    \ 0\n    close_paren_count = 0\n    levels = []\n    for level in range(len(paren_string)):\n\
    \        if paren_string[level] == '(':\n            open_paren_count += 1\n \
    \       elif paren_string[level] == ')':\n            close_paren_count += 1\n\
    \            levels.append(close_paren_count)\n            open_paren_count -=\
    \ 1\n        elif paren_string[level] == ' ':\n            open_paren_count =\
    \ 0\n            close_paren_count = 0\n    return levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkwnyyrcq.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpkwnyyrcq.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkwnyyrcq.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []  # type:\
    \ List[str]\n    i = 0\n    while i < len(paren_string):\n        if paren_string[i]\
    \ == '(':\n            stack.append(paren_string[i])\n            i += 1\n   \
    \     elif paren_string[i] == ')':\n            top_level_parens = stack.pop()\n\
    \            deepest_parens = top_level_parens.count('(') - top_level_parens.count(')')\n\
    \            if deepest_parens > len(stack):\n                stack.append(top_level_parens)\n\
    \            else:\n                stack.pop()\n            i += 1\n        else:\n\
    \            i += 1\n    return stack\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsn427e4y.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpsn427e4y.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsn427e4y.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpsn427e4y.py\", line 18, in parse_nested_parens\n\
    \    top_level_parens = stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    depth\
    \ = 0\n    for c in paren_string:\n        if c in '(()'):\n            depth\
    \ += 1\n            stack.append(c)\n        elif c in ')':\n            depth\
    \ -= 1\n            stack.pop()\n            if not stack:\n                return\
    \ [depth]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpfnjipnr1.py\", line 14\n    if c in '(()'):\n        \
    \         ^\nSyntaxError: unmatched ')'\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n\
    \        return []\n\n    paren_chars = ['(', ')']\n    paren_char_counts = [0,\
    \ 0]\n    levels_done = 0\n\n    i = 0\n    parens_done = True\n\n    while parens_done\
    \ or i < len(paren_string):\n        if parens_done:\n            levels_done\
    \ += 1\n            i = paren_string.find(')', i)\n        else:\n           \
    \ levels_done -= 1\n            i = paren_string.find(' ', i)\n\n        if i\
    \ < 0:\n            i = len(paren_string)\n\n        paren_char = paren_string[i]\n\
    \        if paren_char not in paren_chars:\n            parens_done = False\n\
    \        else:\n            paren_char_counts[paren_chars] += 1\n\n    return\
    \ list(\n        accumulate(\n            enumerate(paren_char_counts, start=1)))[::-1]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgagq4krb.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmpgagq4krb.py\", line 48,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgagq4krb.py\"\
    , line 43, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpgagq4krb.py\", line 36, in parse_nested_parens\n\
    \    paren_char_counts[paren_chars] += 1\nTypeError: list indices must be integers\
    \ or slices, not list\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    for i, c in enumerate(paren_string):\n        if c == \"(\":\n    \
    \        level += 1\n            stack.append(i)\n        elif c == \")\":\n \
    \           stack.pop()\n            if not stack:\n                level = level\
    \ - 1\n    return level\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwlfq2q5y.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpwlfq2q5y.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwlfq2q5y.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n\
    \    levels = []\n    for group in groups:\n        if group == '(':\n       \
    \     levels.append(0)\n        elif group == ')':\n            levels.pop()\n\
    \        else:\n            levels[-1] += 1\n    return levels\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpblp1g_mh.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpblp1g_mh.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpblp1g_mh.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpblp1g_mh.py\", line 19, in parse_nested_parens\n\
    \    levels[-1] += 1\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO (russell):\
    \ implement me!\n    return []\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdtenzq82.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpdtenzq82.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdtenzq82.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Code from http://stackoverflow.com/a/37889790/4769971\n\
    \    # Split the string with spaces and then parse in reverse to find the maximum\
    \ level of nesting.\n    # Code from http://stackoverflow.com/a/37889790/4769971\n\
    \    stack = []\n    para_level = []\n    for index, char in enumerate(reversed(paren_string)):\n\
    \        if char == '(':\n            stack.append(index)\n        elif char ==\
    \ ')':\n            if not stack:\n                raise ValueError('unbalanced\
    \ parenthesis')\n            para_level.append(len(stack))\n            stack.pop()\n\
    \    para_level.append(len(stack))\n    para_level.reverse()\n    return para_level\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqb47kid7.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpqb47kid7.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqb47kid7.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpqb47kid7.py\", line 21, in parse_nested_parens\n\
    \    raise ValueError('unbalanced parenthesis')\nValueError: unbalanced parenthesis\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return len(re.findall(r'[^()]*',\
    \ paren_string))\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp79_oow9b.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp79_oow9b.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp79_oow9b.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp79_oow9b.py\", line 11, in parse_nested_parens\n\
    \    return len(re.findall(r'[^()]*', paren_string))\nNameError: name 're' is\
    \ not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    left_depth = 0\n \
    \   right_depth = 0\n    paren_levels = []\n    parentheses = [i for i in range(len(paren_string))]\
    \ # create list of all indices of parentheses\n    # keep track of parentheses\n\
    \    while parentheses:\n        # iterate through each pair of parentheses in\
    \ the string\n        if parentheses[0] > parentheses[-1]:\n            # if the\
    \ parentheses are in reverse order\n            first_parentheses = parentheses.pop(-1)\n\
    \            last_parentheses = parentheses.pop(0)\n        else:\n          \
    \  first_parentheses = parentheses.pop(0)\n            last_parentheses = parentheses.pop(-1)\n\
    \n        # increase depth by one for current left and right parens\n        if\
    \ first_parentheses == '(':\n            left_depth += 1\n            right_depth\
    \ += 1\n        elif last_parentheses == ')':\n            left_depth -= 1\n \
    \           right_depth -= 1\n        # add the depth to the paren_levels list\n\
    \        paren_levels.append(left_depth - right_depth)\n    return paren_levels\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppdmjx__k.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmppdmjx__k.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppdmjx__k.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmppdmjx__k.py\", line 24, in parse_nested_parens\n\
    \    last_parentheses = parentheses.pop(-1)\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Python has a really\
    \ cool feature called list comprehension that allows us to do cool stuff like:\n\
    \    # max([1, 2, 3, 4, 5] if i % 2 == 0 else 0 for i in range(0, 10000, 2))\n\
    \    # Which will print out a list with the maximum even value for each value\
    \ in the list.\n    # It's very useful for parsing strings for nested parentheses.\n\
    \    stack = []\n    for parens in paren_string:\n        if parens == '(':\n\
    \            stack.append(1)\n        elif parens == ')':\n            stack.pop()\n\
    \    return stack\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4ht8b946.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp4ht8b946.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4ht8b946.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_level = 0\n\
    \    current_level = 0\n    parsed_parens = []\n    bracket_count = 0\n    for\
    \ char in paren_string:\n        if char == \"(\":\n            current_level\
    \ += 1\n            nesting_level += 1\n            if bracket_count == 0:\n \
    \               bracket_count += 1\n        elif char == \")\":\n            current_level\
    \ -= 1\n            nesting_level -= 1\n            if current_level < 0:\n  \
    \              raise ValueError(f\"Parentheses count is greater than 0\")\n  \
    \          if bracket_count == 0:\n                bracket_count += 1\n      \
    \  parsed_parens.append(nesting_level)\n    return parsed_parens\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgnsipu6u.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmpgnsipu6u.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgnsipu6u.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    pos\
    \ = 0\n    parsed_parens = []\n    for c in paren_string:\n        if c == '(':\n\
    \            level += 1\n        elif c == ')':\n            level -= 1\n    \
    \    if level < 0:\n            parsed_parens.append(pos - 1)\n        pos +=\
    \ 1\n    return parsed_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyic1kw6t.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpyic1kw6t.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyic1kw6t.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Check if there is\
    \ no nested parentheses.\n    if paren_string == '':\n        return []\n    \n\
    \    stack = []\n    \n    for c in paren_string:\n        if c == '(':\n    \
    \        stack.append(0)\n        elif c == '[':\n            stack.append(1)\n\
    \        elif c == ')':\n            if stack.pop() == 0:\n                return\
    \ stack\n            else:\n                stack.append(0)\n        elif c ==\
    \ ']':\n            if stack.pop() == 1:\n                return stack\n     \
    \       else:\n                stack.append(1)\n\n    raise ValueError(f\"Could\
    \ not parse nested parentheses! {paren_string}\")\n\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpu4kfr4tp.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmpu4kfr4tp.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu4kfr4tp.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n  \
    \  levels_of_nesting_dict = {}\n    for idx, char in enumerate(paren_string):\n\
    \        if char == '(':\n            levels_of_nesting_dict.setdefault(idx, 0)\n\
    \            levels_of_nesting_dict[idx] += 1\n        else:\n            levels_of_nesting_dict[idx]\
    \ -= 1\n            if levels_of_nesting_dict[idx] >= 0:\n                max_level\
    \ = max(max_level, levels_of_nesting_dict[idx])\n    return max_level + 1\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbr30zf09.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpbr30zf09.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbr30zf09.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpbr30zf09.py\", line 18, in parse_nested_parens\n\
    \    levels_of_nesting_dict[idx] -= 1\nKeyError: 2\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # your code goes here\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1zttde4j.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp1zttde4j.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1zttde4j.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack: List[int]\
    \ = [0]\n    level: int = 0\n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            if level == 0:\n                level +=\
    \ 1\n            else:\n                level -= 1\n        elif char == ')':\n\
    \            level += level\n        elif char == ' ':\n            pass\n   \
    \     else:\n            raise ValueError(\"Invalid character at position {} in\
    \ input string {}\".format(index, paren_string))\n\n        paren_stack.append(level)\n\
    \n    return paren_stack\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8i0mtbip.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmp8i0mtbip.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8i0mtbip.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 1\n\
    \    stack = []\n    for ch in paren_string:\n        if ch == '(':\n        \
    \    paren_level += 1\n            stack.append(paren_level)\n        elif ch\
    \ == ')':\n            paren_level -= 1\n            stack.pop()\n    return stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqiya20md.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpqiya20md.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqiya20md.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('\
    \ ', '')\n    paren_string_list = paren_string.split(')')\n    paren_string_list.pop()\n\
    \n    nesting_level_list = []\n    for paren_string in paren_string_list:\n  \
    \      current_level = 1\n        for char in paren_string:\n            if char\
    \ == '(':\n                nesting_level_list.append(current_level)\n        \
    \        current_level += 1\n            elif char == ')':\n                nesting_level_list.pop()\n\
    \                current_level -= 1\n            else:\n                raise\
    \ Exception(\"Unexpected character: \" + char + \" at index \" + str(paren_string_list.index(paren_string)))\n\
    \        \n    return nesting_level_list\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvf__jfyl.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpvf__jfyl.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvf__jfyl.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\
    \    paren_nesting_level = 0\n    paren_nesting_level_count = [0] * (len(paren_string)\
    \ // 2)\n    paren_level_count = [0] * (len(paren_string) // 2)\n    paren_nesting_level_count[0]\
    \ = 1\n\n    for i, char in enumerate(paren_string):\n        if char == '(':\n\
    \            paren_level_count[i] += 1\n        elif char == ')':\n          \
    \  paren_level_count[i] -= 1\n            paren_level = max(paren_level, paren_level_count[i])\n\
    \            paren_nesting_level_count[paren_level] += 1\n\n    return paren_nesting_level_count[paren_level]\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpa6yslznc.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpa6yslznc.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpa6yslznc.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpa6yslznc.py\", line 19, in parse_nested_parens\n\
    \    paren_level_count[i] += 1\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = 0\n    depth\
    \ = 0\n    paren_count = 0\n    paren_open_list = []\n    paren_close_list = []\n\
    \    for index, ch in enumerate(paren_string):\n        # print(f'index={index},\
    \ ch={ch}')\n        if ch == '(':\n            paren_open_list.append(index)\n\
    \            stack += 1\n        elif ch == ')':\n            paren_close_list.append(index)\n\
    \            depth += 1\n            if paren_count < len(paren_open_list):\n\
    \                paren_count += (paren_open_list[paren_count] - paren_close_list[paren_count])\n\
    \                # print(f'paren_count={paren_count}')\n                # print(f'paren_open_list={paren_open_list},\
    \ paren_close_list={paren_close_list}')\n                # print(f'stack={stack},\
    \ depth={depth}')\n                stack -= 1\n            else:\n           \
    \     break\n    return depth\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8gz1s0v9.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmp8gz1s0v9.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8gz1s0v9.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp8gz1s0v9.py\", line 25, in parse_nested_parens\n\
    \    paren_count += (paren_open_list[paren_count] - paren_close_list[paren_count])\n\
    IndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels: List[int]\
    \ = [0 for _ in range(len(paren_string))]\n    level = 0\n    for idx, char in\
    \ enumerate(paren_string):\n        if char == \"(\":\n            levels[idx]\
    \ = level\n            level += 1\n        elif char == \")\":\n            levels[idx]\
    \ = level\n            level -= 1\n    return levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmlcr2d6d.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpmlcr2d6d.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmlcr2d6d.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = []\n   \
    \ curr_depth = 0\n    for idx, ch in enumerate(paren_string):\n        if ch ==\
    \ '(':\n            curr_depth += 1\n        elif ch == ')':\n            curr_depth\
    \ -= 1\n            if curr_depth < 0:\n                raise ValueError(\"Parentheses\
    \ mismatch in string at {}\".format(idx))\n        elif ch == ' ':\n         \
    \   nesting.append(curr_depth)\n\n    return nesting\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph7xxbmba.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmph7xxbmba.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph7xxbmba.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] =\
    \ []\n    for char in paren_string:\n        if char == '(':\n            stack.append(len(stack))\n\
    \        elif char == ')':\n            stack.pop()\n    if stack:\n        return\
    \ len(stack)\n    else:\n        return 0\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkszfc6k0.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpkszfc6k0.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkszfc6k0.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = 0\n    start\
    \ = paren_string[0]\n    if start == '(':\n        nested += 1\n    for idx in\
    \ range(1, len(paren_string)):\n        char = paren_string[idx]\n        if char\
    \ == '(':\n            nested += 1\n        elif char == ')':\n            nested\
    \ -= 1\n        elif char == ')' and nested == 0:\n            return idx\n  \
    \  return -1\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpz8w_bt8o.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpz8w_bt8o.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpz8w_bt8o.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels: List[int]\
    \ = []\n    for level in range(0, len(paren_string)):\n        if paren_string[level]\
    \ == '(':\n            paren_levels.append(level)\n        if paren_string[level]\
    \ == ')':\n            paren_levels.pop()\n    return paren_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzf859lpn.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpzf859lpn.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzf859lpn.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    depth\
    \ = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(depth)\n\
    \            depth += 1\n        elif char == ')':\n            depth = stack.pop()\n\
    \    return depth\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5cfwokti.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmp5cfwokti.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5cfwokti.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(_parse_parens_helper(paren_string,\
    \ 1))\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeim1b59l.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpeim1b59l.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpeim1b59l.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpeim1b59l.py\", line 11, in parse_nested_parens\n\
    \    return list(_parse_parens_helper(paren_string, 1))\nNameError: name '_parse_parens_helper'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] =\
    \ []\n    level = 0\n    for char in paren_string:\n        if char == '(':\n\
    \            stack.append(level)\n        elif char == ')':\n            stack.pop()\n\
    \        else:\n            level += 1\n    return stack\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgtru64k2.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpgtru64k2.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgtru64k2.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Convert string to\
    \ list\n    paren_list: List[str] = paren_string.strip().replace(' ', '').split(',')\n\
    \n    # Track the level of nesting at which the parentheses appear\n    level:\
    \ List[int] = [0] * len(paren_list)\n\n    # Find the minimum level of nesting\
    \ for each group\n    # E.g. (()()) has minimum level of nesting while ((()))\
    \ has maximum level of nesting\n    group_min: List[int] = [0] * len(paren_list)\n\
    \    for k in range(len(paren_list)):\n        group_min[k] = paren_list.count('(('\
    \ + paren_list[k] + ')')) + paren_list.count('((' + paren_list[k] + ')('))\n\n\
    \    # Find the deepest level of nesting for each group\n    # E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three\n    group_max: List[int]\
    \ = [0] * len(paren_list)\n    for k in range(len(paren_list)):\n        group_max[k]\
    \ = group_min[k] + 1 + paren_list.count('((' + paren_list[k] + ')') - paren_list.count('('\
    \ + paren_list[k] + ')('))\n\n    # Find the maximum nesting level of the given\
    \ input\n    # E.g. (()()) has maximum two levels of nesting while ((())) has\
    \ three\n    level = [max(group_max[k]-group_min[k], 0) for k in range(len(group_max))]\n\
    \    return level\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpw4u0mo1y.py\", line 21\n    group_min[k] = paren_list.count('(('\
    \ + paren_list[k] + ')')) + paren_list.count('((' + paren_list[k] + ')('))\n \
    \                                                              ^\nSyntaxError:\
    \ unmatched ')'\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    open_parens\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            level +=\
    \ 1\n            open_parens += 1\n        elif c == ')':\n            level -=\
    \ 1\n            open_parens -= 1\n        if open_parens == level:\n        \
    \    return level\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprxwm0jir.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmprxwm0jir.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmprxwm0jir.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    par_count = 0\n  \
    \  level = 0\n    paren_level = 0\n    paren_index = 0\n    \n    while paren_string\
    \ != \"\":\n        if paren_count == 1:\n            paren_level += 1\n     \
    \   elif paren_count == 2:\n            paren_level -= 1\n        elif paren_count\
    \ > 0:\n            par_count = paren_count\n        else:\n            raise\
    \ ValueError(\"Malformed parens string: '{}'\".format(paren_string))\n       \
    \ paren_index += 1\n        if paren_string[paren_index] == '(':\n           \
    \ paren_count += 1\n        elif paren_string[paren_index] == ')':\n         \
    \   paren_count -= 1\n\n    return paren_level\n\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvbf7a1ul.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpvbf7a1ul.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvbf7a1ul.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpvbf7a1ul.py\", line 17, in parse_nested_parens\n\
    \    if paren_count == 1:\nUnboundLocalError: local variable 'paren_count' referenced\
    \ before assignment\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 0\n\
    \    nested_parens = []\n    for char in paren_string:\n        if char == '(':\n\
    \            nested_parens.append(paren_count)\n            paren_count += 1\n\
    \        elif char == ')':\n            nested_parens.pop()\n            paren_count\
    \ -= 1\n        elif char == ' ':\n            continue\n        else:\n     \
    \       nested_parens.append(0)\n    return nested_parens\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7aszbvzl.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp7aszbvzl.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7aszbvzl.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    output\
    \ = []\n    level_size = 0\n    last = 0\n    next_open = 1\n    for idx, c in\
    \ enumerate(paren_string):\n        if c == ')':\n            if level_size >\
    \ 1:\n                level_size -= 1\n            else:\n                if level_size\
    \ == 0:\n                    output.append(idx + 1)\n                if level_size\
    \ == 1:\n                    output.append(idx + last)\n                level\
    \ = 0\n                level_size = 0\n                last = idx + 1\n      \
    \  elif c == '(':\n            if level_size == 0:\n                output.append(idx\
    \ + 1)\n                level = 1\n                level_size = 1\n          \
    \  next_open = 0\n        elif c == ')' and next_open:\n            next_open\
    \ = 0\n        else:\n            level += 1\n            level_size += 1\n  \
    \  return output\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzs_x1m3b.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpzs_x1m3b.py\", line 47,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzs_x1m3b.py\"\
    , line 42, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    length\
    \ = len(paren_string)\n\n    stack = []\n    for i in range(length):\n       \
    \ if paren_string[i] == '(':\n            level += 1\n            stack.append(i)\n\
    \        elif paren_string[i] == ')':\n            stack.pop()\n            if\
    \ not stack:\n                return level\n            level = level - 1\n  \
    \  return level\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0lwixqhv.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmp0lwixqhv.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0lwixqhv.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string.count('(')\
    \ == paren_string.count(')'):\n        raise ValueError('Nested parentheses must\
    \ have an equal number of opening and closing parentheses.') \n    \n    level\
    \ = 0\n    levels = []\n    for index, c in enumerate(paren_string):\n       \
    \ if c == '(':\n            level += 1\n        elif c == ')':\n            level\
    \ -= 1\n        levels.append(level)\n    \n    if level == 0:\n        raise\
    \ ValueError('Nested parentheses cannot be empty.')\n    \n    return levels\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpdwv5b0fn.py\", line 27\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\
    \    parens = []\n    i = 0\n    while i < len(paren_string) and paren_level <\
    \ 4:\n        if paren_string[i] == '(':\n            paren_level += 1\n     \
    \   elif paren_string[i] == ')':\n            paren_level -= 1\n            parens.append(paren_level)\n\
    \        i += 1\n\n    if paren_level > 0:\n        raise ValueError(f'Unmatched\
    \ parens: {paren_string}')\n    else:\n        return parens\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxv28zi2d.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpxv28zi2d.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxv28zi2d.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string ==\
    \ '':\n        return []\n\n    levels: List[int] = [0]\n    for idx, char in\
    \ enumerate(paren_string):\n        if char == '(':\n            levels.append(idx)\n\
    \        elif char == ')':\n            if len(levels) == 1:\n               \
    \ return []\n            levels.pop()\n    return levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyaav2em_.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpyaav2em_.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyaav2em_.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    opening_paren_levels\
    \ = [0 for i in range(0,5)]\n    closed_paren_levels = [0 for i in range(0,5)]\n\
    \n    for idx, character in enumerate(paren_string):\n        if character ==\
    \ \"(\":\n            opening_paren_levels[idx] += 1\n        elif character ==\
    \ \")\":\n            closed_paren_levels[idx] += 1\n\n    # Find all max levels\
    \ among all opening parens\n    max_level_opening_paren = 0\n    for i in range(0,5):\n\
    \        if opening_paren_levels[i] == max_level_opening_paren:\n            max_level_opening_paren\
    \ = opening_paren_levels[i]\n            max_level_opening_paren_idx = i\n   \
    \     elif opening_paren_levels[i] > max_level_opening_paren:\n            max_level_opening_paren\
    \ = opening_paren_levels[i]\n            max_level_opening_paren_idx = i\n\n \
    \   # Find all max levels among all closing parens\n    max_level_closing_paren\
    \ = 0\n    for i in range(0,5):\n        if closed_paren_levels[i] == max_level_closing_paren:\n\
    \            max_level_closing_paren = closed_paren_levels[i]\n            max_level_closing_paren_idx\
    \ = i\n        elif closed_paren_levels[i] > max_level_closing_paren:\n      \
    \      max_level_closing_paren = closed_paren_levels[i]\n            max_level_closing_paren_idx\
    \ = i\n\n    # Return deepest level of nesting among all brackets\n    if max_level_closing_paren_idx\
    \ == max_level_opening_paren_idx:\n        return max_level_closing_paren\n  \
    \  else:\n        return max_level_closing_paren + 1\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphmkoinw9.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmphmkoinw9.py\", line 52,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphmkoinw9.py\"\
    , line 47, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmphmkoinw9.py\", line 18, in parse_nested_parens\n\
    \    closed_paren_levels[idx] += 1\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: Use a stack\
    \ to solve this problem efficiently?\n    if not paren_string:\n        return\
    \ []\n    parsed = [0, 0, 0]\n    for i, c in enumerate(paren_string):\n     \
    \   if c == '(':\n            parsed[0] += 1\n        if c == ')':\n         \
    \   parsed[1] -= 1\n        if parsed[1] == 0:\n            parsed[2] += 1\n \
    \   return parsed\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9tz4mdsh.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp9tz4mdsh.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9tz4mdsh.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_level = 0\n\
    \    levels_up = 0\n\n    stack = []\n\n    for char in paren_string:\n      \
    \  if char == ')':\n            # Closing bracket\n            stack.append(char)\n\
    \            levels_up += 1\n        elif char == '(':\n            # Opening\
    \ bracket\n            nested_level += 1\n            stack.append(char)\n   \
    \     elif char == ')' and stack[-1] == '(':\n            # Closing bracket with\
    \ another opening bracket\n            stack.pop()\n            levels_up -= 1\n\
    \        elif char == ')' and stack[-1] == '(' or char == '(' and stack[-1] ==\
    \ ')':\n            # Closing bracket with any other character\n            stack.pop()\n\
    \            nested_level -= 1\n            levels_up += 1\n        else:\n  \
    \          # Unexpected character in parentheses\n            stack.pop()\n  \
    \          levels_up += 1\n\n    return nested_level if levels_up > 0 else 0\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpswtr0jzh.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpswtr0jzh.py\", line 47,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpswtr0jzh.py\"\
    , line 42, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string:\n\
    \        level = 0\n        nested_parentheses = []\n\n        paren_stack = []\n\
    \        current_string = ''\n        for char in paren_string:\n            if\
    \ char == '(':\n                if paren_stack:\n                    nested_parentheses.append(level\
    \ - 1)\n                level += 1\n                paren_stack.append(char)\n\
    \            elif char == ')':\n                level -= 1\n                paren_stack.pop()\n\
    \            elif char != ' ':\n                current_string += char\n\n   \
    \     if paren_stack:\n            nested_parentheses.append(level - 1)\n\n  \
    \      return nested_parentheses\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2qjeez4j.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmp2qjeez4j.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2qjeez4j.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace(\"\
    (\", \"\")\n    paren_string = paren_string.replace(\")\", \"\")\n    paren_string\
    \ = paren_string.replace(\"{\", \"\")\n    paren_string = paren_string.replace(\"\
    }\", \"\")\n    paren_list = paren_string.split(\" \")\n    level_list = list()\n\
    \    for paren in paren_list:\n        level = 0\n        for char in paren:\n\
    \            if char == \"(\":\n                level += 1\n            elif char\
    \ == \")\":\n                level -= 1\n            if level == 0:\n        \
    \        break\n        level_list.append(level)\n    return level_list\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbu014o5q.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpbu014o5q.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbu014o5q.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_level = 0\n\
    \    paren_groups = paren_string.split()\n    for paren_group in paren_groups:\n\
    \        if paren_group == '(':\n            nested_level += 1\n        if paren_group\
    \ == ')':\n            nested_level -= 1\n    return nested_level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp90ygqg9u.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmp90ygqg9u.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp90ygqg9u.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    count\
    \ = 0\n    start = -1\n    end = -1\n    for i in range(0, len(paren_string)):\n\
    \        if paren_string[i] == \"(\":\n            if level == 0:\n          \
    \      start = i\n            level += 1\n        if paren_string[i] == \")\"\
    :\n            level -= 1\n            if level == 0:\n                end = i\n\
    \                if start == -1 and end == -1:\n                    # no parens\
    \ found\n                    level = 0\n                elif start == -1 or end\
    \ == -1:\n                    # only one parens found\n                    if\
    \ start == -1:\n                        start = i + 1\n                    if\
    \ end == -1:\n                        end = i\n                        level =\
    \ 0\n                elif end - start > 1:\n                    # at least two\
    \ parens found\n                    count = end - start - 1\n                \
    \    level = 0\n    if level == 0:\n        level = 1\n    ans = [level]\n   \
    \ if count > 0:\n        ans.append(count)\n    return ans\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprvf5vq1s.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmprvf5vq1s.py\", line 51,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmprvf5vq1s.py\"\
    , line 46, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Split string by\
    \ spaces and convert to list\n    paren_string = paren_string.split()\n    paren_string\
    \ = [x for x in paren_string if x]\n    paren_string = [int(x) for i, x in enumerate(paren_string)\
    \ if paren_string[i] == '(']\n    paren_string = [int(x) for i, x in enumerate(paren_string)\
    \ if paren_string[i] == ')']\n\n    # Keep track of parens opening and closing\n\
    \    paren_open = []\n    paren_close = []\n\n    # Keep track of level of nesting\
    \ for each paren\n    nesting = []\n\n    for x in paren_string:\n        # Increment\
    \ number of levels of nesting by one for each opening\n        if paren_open:\n\
    \            while paren_open[-1] > x:\n                paren_open.pop()\n   \
    \         nesting.append(paren_open[-1])\n        else:\n            nesting.append(1)\n\
    \n        # Increment number of levels of nesting by one for each closing\n  \
    \      while nesting and nesting[-1] > x:\n            nesting.pop()\n\n     \
    \   # Increment number of levels of nesting by one for each opening\n        if\
    \ paren_open:\n            paren_open.append(x)\n        else:\n            paren_open.append(x)\n\
    \n        # Increment number of levels of nesting by one for each closing\n  \
    \      if nesting:\n            nesting.append(x)\n        else:\n           \
    \ nesting.append(x)\n\n    return nesting\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpg_t4b87d.py\", line\
    \ 60, in <module>\n    test_check()\n  File \"/tmp/tmpg_t4b87d.py\", line 58,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpg_t4b87d.py\"\
    , line 53, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    left_paren = []\n\
    \    right_paren = []\n    depth = 0\n    for i in range(len(paren_string)):\n\
    \        if paren_string[i] == '(':\n            if left_paren:\n            \
    \    left_paren.pop()\n            depth += 1\n        elif paren_string[i] ==\
    \ ')':\n            if right_paren:\n                right_paren.pop()\n     \
    \       depth -= 1\n            left_paren.append(depth)\n        elif left_paren\
    \ and depth == 0:\n            left_paren.append(i)\n        elif right_paren\
    \ and depth == 0:\n            right_paren.append(i)\n        else:\n        \
    \    left_paren = []\n            right_paren = []\n            depth = 0\n  \
    \  return right_paren\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnvu77v85.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpnvu77v85.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnvu77v85.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    ret_val\
    \ = []\n    for c in paren_string:\n        if c == ')':\n            nesting\
    \ -= 1\n            ret_val.append(nesting)\n        elif c == '(':\n        \
    \    nesting += 1\n            ret_val.append(nesting)\n    return ret_val\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpypm8x6w_.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpypm8x6w_.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpypm8x6w_.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Initialize result\
    \ with zero\n    result = [0]\n\n    # Start with one as we parse from left to\
    \ right\n    level = 1\n\n    # Iterate over the string left to right\n    for\
    \ pos, char in enumerate(reversed(paren_string)):\n\n        # Handle empty string\
    \ and stop iteration if reached end\n        if char == \")\":\n            result.append(level)\n\
    \            if pos == 0:\n                break\n        else:\n            level\
    \ += 1\n\n    # Return result\n    return result\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpru4y320r.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpru4y320r.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpru4y320r.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    paren_counter\
    \ = 0\n    nested_paren_count = 0\n    prev_char_position = 0\n    nested_paren_pairs\
    \ = []\n    for idx, char in enumerate(paren_string):\n        if char == '(':\n\
    \            paren_counter += 1\n            nested_paren_count += 1\n       \
    \ elif char == ')':\n            paren_counter -= 1\n            nested_paren_count\
    \ -= 1\n            if paren_counter == 0:\n                nested_paren_pairs.append(idx)\n\
    \                prev_char_position = idx + 1\n                break\n       \
    \ else:\n            pass\n\n    if paren_counter != 0:\n        raise RuntimeError(\"\
    Unexpected input string encountered\")\n    return nested_paren_pairs\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpm5f3bdh4.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpm5f3bdh4.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpm5f3bdh4.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659976384
