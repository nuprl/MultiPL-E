name: HumanEval_6_parse_nested_parens
language: py
results:
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result: List[int]\
    \ = [0]\n    level: List[int] = [0]\n    stack: List[int] = [0]\n    \n    # Count\
    \ levels of nesting\n    for i, s in enumerate(paren_string):\n        if s ==\
    \ '(':\n            stack.append(i)\n        elif s == ')':\n            stack.pop()\n\
    \            result.append(stack[len(stack) - 1])\n            level.append(stack[len(stack)\
    \ - 1])\n        elif s == '[':\n            stack.append(i)\n        elif s ==\
    \ ']':\n            stack.pop()\n            level.append(stack[len(stack) - 1])\n\
    \    \n    # Get the deepest level of nesting\n    deepest_level = stack[len(stack)\
    \ - 1]\n    \n    # Return the maximum level of nesting found\n    return result[deepest_level]\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptw48nmgg.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmptw48nmgg.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptw48nmgg.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n\
    \    paren_depth = 0\n    open_paren_count = 0\n    for idx, char in enumerate(paren_string):\n\
    \        if char == '(':\n            open_paren_count += 1\n            paren_stack.append(idx)\n\
    \        elif char == ')':\n            open_paren_count -= 1\n            paren_depth\
    \ = max(paren_depth, open_paren_count)\n        elif char == ')' and open_paren_count\
    \ == 0:\n            paren_stack.pop()\n    return paren_depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjiicy8j2.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpjiicy8j2.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjiicy8j2.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    para_list = []\n \
    \   para_level_dict = {}\n    para_level_counter = 1\n    for char in paren_string:\n\
    \        if char == '(':\n            if para_level_counter in para_level_dict:\n\
    \                para_level_dict[para_level_counter] += 1\n            else:\n\
    \                para_level_dict[para_level_counter] = 1\n            para_level_counter\
    \ += 1\n        elif char == ')':\n            para_level_counter -= 1\n     \
    \       if para_level_counter in para_level_dict:\n                para_level_dict[para_level_counter]\
    \ += 1\n            else:\n                para_level_dict[para_level_counter]\
    \ = 1\n        if para_level_counter == 0:\n            para_list.append(para_level_dict.keys())\n\
    \            para_level_dict = {}\n            para_level_counter = 1\n    para_list.append(para_level_dict.keys())\n\
    \    return para_list\n</cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "  File \"/tmp/tmp8tqu39ub.py\", line 33\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  exit_code: 1
  status: SyntaxError
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Convert from string\
    \ to list of characters using list comprehension\n    nested_list = []\n    for\
    \ char in paren_string:\n        if char == '(':\n            nested_list.append(1)\n\
    \        elif char == ')':\n            nested_list.pop()\n        else:\n   \
    \         nested_list.append(0)\n    return nested_list\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkge6w19g.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpkge6w19g.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkge6w19g.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # A utility function\
    \ to handle all the parsing\n    def recursive_parse(string, level, parens_count,\
    \ parens_list):\n        \"\"\" Recursively parse a string and add the parsed\
    \ parens to parens_list\n        Args:\n            string: string to be parsed\n\
    \            level: current level of nesting of parens\n            parens_count:\
    \ total count of parens in the string\n            parens_list: list to store\
    \ the parsed parens\n        \"\"\"\n        # If the string ends with a single\
    \ '(' and no matching ')' then return\n        if len(string) <= 1 and parens_count\
    \ == 1:\n            return\n        # Find the index of first ')' in the string\n\
    \        parens_index = string.rfind(')')\n        # If the string ends with a\
    \ single '(' and a matching ')' then return\n        if parens_index == 0 and\
    \ parens_count == 0:\n            return\n        # Remove the string from the\
    \ string\n        string = string[parens_index + 1 :]\n        # If the string\
    \ has more than one '(' then recurse to parse it\n        if parens_count > 0\
    \ and string != '(':\n            recursive_parse(string, level + 1, parens_count\
    \ - 1, parens_list)\n        # If the string has only one '(', then add the level\
    \ to parens_list\n        elif parens_count == 1 and string == '(':\n        \
    \    parens_list.append(level)\n        # Remove the '(' from the string\n   \
    \     string = string[:parens_index]\n        # If the string has more than one\
    \ ')' then recurse to parse it\n        if parens_count > 0 and string != '(':\n\
    \            recursive_parse(string, level + 1, parens_count - 1, parens_list)\n\
    \        # If the string has only one ')', then add the level to parens_list\n\
    \        elif parens_count == 1 and string == ')':\n            parens_list.append(level)\n\
    \        # If the string is empty, return\n        else:\n            return\n\
    \n    # Parse the string\n    parens_list = []\n    recursive_parse(paren_string,\
    \ 0, len(paren_string), parens_list)\n    # Return the paren list\n    return\
    \ parens_list\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\
    \    paren_opening = -1\n    paren_count = 0\n    paren_levels = []\n    \n  \
    \  for char in paren_string:\n        if char == '(':\n            paren_count\
    \ += 1\n            paren_level += 1\n            if paren_opening == -1:\n  \
    \              paren_opening = paren_count\n        elif char == ')':\n      \
    \      paren_count -= 1\n            if paren_count == 0:\n                paren_levels.append(paren_level)\n\
    \            elif paren_count < 0:\n                raise SyntaxError(f\"Parentheses\
    \ do not match. Expected {paren_opening} opening brackets but got {paren_count}\
    \ closing brackets\")\n            \n    return paren_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps8s1vt5d.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmps8s1vt5d.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps8s1vt5d.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    i\
    \ = 0\n\n    # Iterate through the string and find the parenthesis pairs that\
    \ represents the nested brackets\n    while i < len(paren_string):\n        if\
    \ paren_string[i] == '(':\n            stack.append(i)\n            i += 1\n \
    \       elif paren_string[i] == ')':\n            popped_stack = stack.pop()\n\
    \            assert(popped_stack > i)\n            i += popped_stack\n       \
    \ else:\n            i += 1\n\n    return stack\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpum9mhew1.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpum9mhew1.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpum9mhew1.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpum9mhew1.py\", line 21, in parse_nested_parens\n\
    \    assert(popped_stack > i)\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    left_stack = []\n\
    \    right_stack = []\n    current_index = 0\n    while current_index < len(paren_string):\n\
    \        char1 = paren_string[current_index]\n        if char1 == '(':\n     \
    \       left_stack.append(char1)\n            current_index += 1\n        elif\
    \ char1 == ')':\n            right_stack.append(char1)\n            current_index\
    \ += 1\n        elif char1 == ' ':\n            if left_stack and right_stack:\n\
    \                if left_stack[-1] != right_stack[-1]:\n                    raise\
    \ Exception('Unexpected spaces between parentheses.')\n                left_stack.pop()\n\
    \                right_stack.pop()\n            else:\n                if left_stack:\n\
    \                    raise Exception('Unexpected spaces between parentheses.')\n\
    \                else:\n                    if right_stack:\n                \
    \        raise Exception('Unexpected spaces between parentheses.')\n         \
    \           else:\n                        raise Exception('Unexpected spaces.')\n\
    \    return left_stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2tqo1sjp.py\", line\
    \ 46, in <module>\n    test_check()\n  File \"/tmp/tmp2tqo1sjp.py\", line 44,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2tqo1sjp.py\"\
    , line 39, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp2tqo1sjp.py\", line 25, in parse_nested_parens\n\
    \    raise Exception('Unexpected spaces between parentheses.')\nException: Unexpected\
    \ spaces between parentheses.\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    \n    if paren_string.count('(')\
    \ != paren_string.count(')'):\n        raise ValueError('Parentheses do not match\
    \ number of opening parentheses: {} vs {}'.format(paren_string.count('('), paren_string.count(')')))\n\
    \n    parentheses_levels = paren_string.count('(')\n    nested_levels = []\n \
    \   for i in range(parentheses_levels):\n        nested_levels.append(0)\n   \
    \ for i in range(parentheses_levels, len(paren_string)):\n        nested_levels[i-parentheses_levels]\
    \ += 1\n    \n    return nested_levels\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6vvyv6c5.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp6vvyv6c5.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6vvyv6c5.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp6vvyv6c5.py\", line 20, in parse_nested_parens\n\
    \    nested_levels[i-parentheses_levels] += 1\nIndexError: list index out of range\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    output\
    \ = []\n    paren_stack = []\n\n    for c in paren_string:\n        if c == '(':\n\
    \            paren_stack.append(c)\n        elif c == ')':\n            # Pop\
    \ the level one item off the stack\n            stack.pop()\n            paren_stack.pop()\n\
    \            output.append(len(stack))\n        elif c in ['(', ')']:\n      \
    \      # Check if the last item on the stack was an opening or closing paren\n\
    \            if len(stack) == 0 or paren_stack[-1] == '(':\n                #\
    \ If the stack is empty, we are on the outermost level\n                # Push\
    \ the level one item on the stack\n                stack.append(c)\n         \
    \   else:\n                # We are on the middle level\n                stack.pop()\n\
    \        else:\n            pass\n\n    return output\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwi2c1q4o.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmpwi2c1q4o.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwi2c1q4o.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpwi2c1q4o.py\", line 20, in parse_nested_parens\n\
    \    stack.pop()\nIndexError: pop from empty list\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(map(int,\
    \ re.findall(r'\\(+|\\)+', paren_string)))\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpokyh704e.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpokyh704e.py\", line 20,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpokyh704e.py\"\
    , line 15, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpokyh704e.py\", line 11, in parse_nested_parens\n\
    \    return list(map(int, re.findall(r'\\(+|\\)+', paren_string)))\nNameError:\
    \ name 're' is not defined\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    depth\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            depth +=\
    \ 1\n        elif c == ')':\n            depth -= 1\n        if depth < 0:\n \
    \           break\n        level += 1\n    return level\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3_wk3l9o.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp3_wk3l9o.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3_wk3l9o.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    result\
    \ = []\n    level_stack = []\n    level_stack.append(0)\n    for char in paren_string:\n\
    \        if char == '(':\n            level_stack.append(0)\n            stack.append(char)\n\
    \        elif char == ')':\n            level_stack.pop()\n            if level_stack[len(level_stack)\
    \ - 1] == 0:\n                stack.pop()\n            else:\n               \
    \ stack.append(char)\n        elif char == ' ':\n            if len(stack) ==\
    \ 0 or stack[len(stack) - 1] != ')':\n                level_stack[len(level_stack)\
    \ - 1] += 1\n                stack.append(char)\n            else:\n         \
    \       result.append(len(level_stack))\n    return result\n</cell>\n<text>\n\
    Now, let's take a look at how this function works:\n\n\n</text>\n<cell>\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n</cell>\n<text>\nIt takes in a string representing nested\
    \ parentheses and outputs its maximum nesting level of parentheses.\nTo understand\
    \ how it works, we must first take a look at how we can write an algorithm to\
    \ determine all nested parentheses in a string.\n\n\n</text>\n<text>\nLet's look\
    \ at an example. Let's first have a look at the input string ((())):\n\n\n</text>\n\
    <cell>\ns = '((()))'\n</cell>\n<text>\nNow, let's walk through this algorithm.\n\
    \n\n</text>\n<text>\nFor the first step, we are starting from the first character\
    \ in the string. Let's start with the character '(' and let's assume that it is\
    \ open. Then the maximum nesting level of this expression is zero. We have seen\
    \ this already.\n\nNow, let's start with the character '(' and we assume that\
    \ it is also open. Then the maximum nesting level of this expression is 1. Then,\
    \ we have seen this already.\n\nNow, let's look at the character ')'. Then we\
    \ see that there are two open parentheses one next to each other and only one\
    \ close parentheses next to each other. So, we can say that this expression is\
    \ balanced. So, we can say that this expression is one level deeper.\n\nSo, our\
    \ stack would be [')'].\n\nLet's continue with the next character which is ')'.\
    \ This character is unbalanced and hence, we cannot say that it is one level deeper.\
    \ Instead, we know that this expression has maximum two levels of nesting. Hence,\
    \ the maximum nesting level of our expression is 2.\n\nSo, our stack would look\
    \ like [')', ')'].\n\n\n</text>\n<text>\nLet's continue with the next character\
    \ which is ')'. This character is also unbalanced and hence, we cannot say that\
    \ it is one level deeper. Instead, we know that this expression has maximum two\
    \ levels of nesting. Hence, the maximum nesting level of our expression is 3.\n\
    \nSo, our stack would look like [')', ')', \ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "  File \"/tmp/tmpz7sebq54.py\", line 32\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  exit_code: 1
  status: SyntaxError
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [0] * (len(paren_string)//2)\
    \ + [\n        max(sum(len(open_par) for open_par in paren_string[:i]) for i in\
    \ range(len(paren_string)//2))\n    ]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfw_lc56u.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpfw_lc56u.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfw_lc56u.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string.strip())\
    \ == 0:\n        return []\n\n    if paren_string.find('(') != -1:\n        left_parantheses_indexes\
    \ = []\n        right_parantheses_indexes = []\n        for index in range(0,\
    \ len(paren_string)):\n            if paren_string[index] == '(':\n          \
    \      left_parantheses_indexes.append(index)\n            if paren_string[index]\
    \ == ')':\n                right_parantheses_indexes.append(index)\n         \
    \   \n        left_parantheses_indexes.reverse()\n        right_parantheses_indexes.reverse()\n\
    \n        left_parantheses_indexes.append(len(paren_string))\n        right_parantheses_indexes.append(len(paren_string))\n\
    \n        left_parantheses_indexes.append(len(paren_string))\n        right_parantheses_indexes.append(len(paren_string))\n\
    \n        left_parantheses_indexes.reverse()\n        right_parantheses_indexes.reverse()\n\
    \n        final_parantheses_indexes = []\n        for left_index in range(len(left_parantheses_indexes)):\n\
    \            for right_index in range(len(right_parantheses_indexes)):\n     \
    \           final_parantheses_indexes.append(left_parantheses_indexes[left_index]\
    \ + right_parantheses_indexes[right_index])\n        return final_parantheses_indexes\n\
    \n    left_paren_levels = []\n    right_paren_levels = []\n    paren_level = 0\n\
    \n    for char in paren_string:\n        if char == '(':\n            paren_level\
    \ += 1\n        if char == ')':\n            paren_level -= 1\n        if paren_level\
    \ == -1:\n            left_paren_levels.append(len(left_paren_levels) + 1)\n \
    \       if paren_level == 0:\n            right_paren_levels.append(len(right_paren_levels)\
    \ + 1)\n            \n    left_paren_levels.reverse()\n    right_paren_levels.reverse()\n\
    \n    left_paren_levels.append(len(left_paren_levels) + 1)\n    right_paren_levels.append(len(left_paren_levels)\
    \ + 1)\n\n    left_paren_levels.reverse()\n    right_paren_levels.reverse()\n\n\
    \    final_parantheses_indexes = []\n    for left_index in range(len(left_paren_levels)):\n\
    \        for right_index in range(len(right_paren_levels)):\n            final_parantheses_indexes.append(left_paren_levels[left_index]\
    \ + right_paren_levels[right_index])\n    return final_parantheses_indexes\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqb7bbirp.py\", line\
    \ 79, in <module>\n    test_check()\n  File \"/tmp/tmpqb7bbirp.py\", line 77,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqb7bbirp.py\"\
    , line 72, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: Parsing the\
    \ string recursively and returning a list would be more robust than this\n   \
    \ # approach\n    \n    paren_level = 0\n    paren_stack = []\n    for char in\
    \ paren_string:\n        if char == '(':\n            paren_level += 1\n     \
    \       paren_stack.append(paren_level)\n        elif char == ')':\n         \
    \   paren_stack.pop()\n            if len(paren_stack) == 0:\n               \
    \ return paren_level\n            paren_level = paren_stack.pop()\n        else:\n\
    \            paren_level = paren_level\n    return []\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9lb2eb80.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp9lb2eb80.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9lb2eb80.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level\
    \ = 0\n    for p in paren_string:\n        if p == \"(\":\n            level +=\
    \ 1\n        elif p == \")\":\n            level -= 1\n        if level < 0:\n\
    \            raise ValueError(\"String '%s' has unbalanced parentheses, not parsing\"\
    \ % paren_string)\n        stack.append(level)\n    return stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph7l2wd8n.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmph7l2wd8n.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph7l2wd8n.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack_of_chars = []\n\
    \    nested_level = 1\n    open_brackets = 0\n    close_brackets = 0\n    level\
    \ = 0\n    \n    for char in paren_string:\n        if char == '(':\n        \
    \    open_brackets = open_brackets + 1\n        elif char == ')':\n          \
    \  close_brackets = close_brackets + 1\n        elif char == ')' and open_brackets\
    \ == 0:\n            nested_level = nested_level - 1\n            open_brackets\
    \ = 0\n        elif char == '(' and open_brackets == 0:\n            nested_level\
    \ = nested_level + 1\n            open_brackets = 1\n        elif char == ')'\
    \ and close_brackets == 0:\n            nested_level = nested_level - 1\n    \
    \        close_brackets = 1\n        elif char == '(' and close_brackets == 0\
    \ and open_brackets == 1:\n            open_brackets = open_brackets - 1\n   \
    \         close_brackets = close_brackets + 1\n        elif char == ')' and close_brackets\
    \ == 0 and open_brackets == 1:\n            close_brackets = close_brackets -\
    \ 1\n            open_brackets = open_brackets - 1\n        \n        stack_of_chars.append(nested_level)\n\
    \        \n    return stack_of_chars\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjq6ztnfu.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmpjq6ztnfu.py\", line 48,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjq6ztnfu.py\"\
    , line 43, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    prev_level\
    \ = 0\n    paren_count = 0\n\n    # Iterate through each character in string.\n\
    \    for i, c in enumerate(paren_string):\n        if c == '(':\n            level\
    \ += 1\n        elif c == ')':\n            level -= 1\n        elif c == ' '\
    \ and level == 0:\n            # End of level 0 nesting.\n            paren_count\
    \ += 1\n            prev_level = level\n\n    return paren_count\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxfzmbsaa.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpxfzmbsaa.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxfzmbsaa.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  exit_code: -1
  status: Exception
- program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    current_level\
    \ = 0\n    for c in paren_string:\n        if c == '(':\n            stack.append(current_level)\n\
    \            current_level += 1\n        elif c == ')':\n            stack.pop()\n\
    \            current_level -= 1\n    if current_level == 0:\n        raise ValueError(f\"\
    No level of nesting is found: {paren_string}\")\n    return stack\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  stdout: ''
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0mmprq39.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp0mmprq39.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0mmprq39.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp0mmprq39.py\", line 21, in parse_nested_parens\n\
    \    raise ValueError(f\"No level of nesting is found: {paren_string}\")\nValueError:\
    \ No level of nesting is found: (()()) ((())) () ((())()())\n"
  exit_code: -1
  status: Exception
