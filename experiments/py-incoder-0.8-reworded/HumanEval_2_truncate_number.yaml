name: HumanEval_2_truncate_number
language: py
prompt: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
  \ floating point number, it can be decomposed into\n    and integer part (largest\
  \ integer smaller than given number) and decimals\n    (leftover part always smaller\
  \ than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
  \    0.5\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
  \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
  \ntest_check()\n"
completions: ["    return float(number) - float(trunc(number))\n\n", "    decimals\
    \ = int(number-int(number))\n    rounded = round(number, decimals)\n    return\
    \ rounded\n\n", "    if not 0.0 <= number < 1.0:\n        raise ValueError(\"\
    Number must be in range [0.0, 1.0]\")\n\n    exponent = math.floor(math.log10(number))\n\
    \    decimals = int(number - math.pow(10.0, exponent))\n    leftover_number =\
    \ math.pow(10.0, exponent - decimals)\n\n    return float(decimals) if decimals\
    \ > 0 else float(leftover_number)\n\n", "    return int(number * 10) % 10\n\n",
  "    return number - math.ceil(math.log10(number))\n\n", "    integer_part = int(number)\n\
    \    remainder_part = number - integer_part\n    if remainder_part == 0:\n   \
    \     return integer_part\n    else:\n        return truncate_number(remainder_part)\n\
    \n", "    return number - math.floor(number)\n\n", "    int_part = int(number)\n\
    \    dec_part = number - int_part\n    return dec_part\n", "    # Truncate decimal\
    \ part and return the integer part\n    return int(number * 10) // 10\n\n", " \
    \   if number == 0:\n        return 0\n    elif number < 0:\n        return -truncate_number(-number)\n\
    \    elif number < 0.1:\n        integer = math.trunc(number)\n        decimal\
    \ = number - integer\n    else:\n        integer = int(number)\n        decimal\
    \ = number - integer - math.floor(number)\n    return decimal\n\n", "    number\
    \ = math.fabs(number)\n    if number < 1.0:\n        return number\n    else:\n\
    \        return number - int(number)\n", "    return math.trunc(number)\n\n",
  "    digits = 100\n    number = float(number)\n    decimals = number * digits +\
    \ 10\n    if decimals > digits:\n        decimals = digits\n    return number\
    \ / decimals\n\n", "    multiplier = 10\n    integer_part = 0\n    decimal_part\
    \ = 1\n    while multiplier > 0:\n        if number / multiplier == int(number\
    \ / multiplier):\n            integer_part += multiplier\n        else:\n    \
    \        decimal_part *= 10\n            decimal_part += number - integer_part\
    \ * multiplier\n        multiplier *= 10\n    decimal_part *= 10\n    return decimal_part\n\
    \n", "    digits = math.floor(math.log10(number))\n    return number / 10**digits\
    \ if digits > 0 else 0.0\n\n", "    if number < 1.0:\n        raise ValueError(\"\
    'number' must be bigger than 1.0\")\n    else:\n        integer_part = int(number)\n\
    \        decimal_part = number - integer_part\n        if abs(decimal_part) <\
    \ 0.000001:\n            return integer_part\n        else:\n            return\
    \ float(decimal_part)\n\n", "    integer = int(number)\n    decimal = number -\
    \ integer\n    return decimal\n", "    decimal_part = float(number).as_tuple().exponent\n\
    \    if decimal_part < 0:\n        raise ValueError(\"negative number\")\n   \
    \ else:\n        integer = decimal_part // 1\n        decimal = decimal_part %\
    \ 1\n        return float(integer) + decimal\n", "    assert number >= 0\n   \
    \ assert isinstance(number, float)\n\n    if number == int(number):\n        return\
    \ int(number)\n\n    if number < 0.5:\n        return int(number)\n\n    multiplier\
    \ = 1\n    number = abs(number)\n    while number > 1:\n        number, remainder\
    \ = divmod(number, multiplier)\n        multiplier += 1\n\n    return number -\
    \ 1\n\n", "    int_part = math.trunc(number)\n    decimal_part = number - int_part\n\
    \    if decimal_part > 0:\n        return float(decimal_part)\n    else:\n   \
    \     return int_part\n\n", "    if number < 1.0:\n        return 0.0\n    elif\
    \ number < 1.0:\n        return number\n    else:\n        decimal = number -\
    \ int(number)\n        return float(decimal)\n\n", "    int_part = int(number)\n\
    \    decimal_part = number - int_part\n    if decimal_part < 1:\n        decimal_part\
    \ = 1\n    return decimal_part\n\n", "    integer_part = int(number)\n    decimal_part\
    \ = number - integer_part\n    return decimal_part\n\n\n@curry2", "    int_part,\
    \ fract_part = math.modf(number)\n    return fract_part * 10**math.ceil(math.log(fract_part,\
    \ 10))\n\n", "    integer = int(number)\n    decimal = number - integer\n    if\
    \ integer < 1:\n        raise ValueError(\"Invalid number. Truncate number has\
    \ more than \"\n                         \"one decimal.\")\n    return decimal\n\
    \n", "    integer, decimal = math.modf(number)\n    return decimal or 1\n", " \
    \   return round(number, 6)\n\n", "    return float(number)\n\n", "    int_part\
    \ = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n\
    \n", "    return round(number, -int(math.floor(math.log10(abs(number)))))\n\n",
  "    int_part, decimal = math.modf(number)\n    return decimal\n", "    decimals\
    \ = math.fmod(number, 1)\n    if decimals == 0:\n        integer = 0\n    else:\n\
    \        integer = math.ceil(number) - math.floor(number)\n    return float(decimals)\
    \ * 1.0 / integer\n\n", "    factor = 10.0 ** len(str(int(number)))\n    return\
    \ number / factor\n\n", "    int_part = int(number)\n    decimal_part = number\
    \ - int_part\n    if decimal_part < 1e-6:\n        return decimal_part\n    else:\n\
    \        return decimal_part * 10\n", "    if number < 1.0:\n        return number\n\
    \    else:\n        decimal_part = math.fmod(number, 1)\n        return math.trunc(number)\
    \ + decimal_part\n\n", "    decimals = math.fmod(number, 1)\n    return number\
    \ - decimals\n\n", "    if number <= 0:\n        raise ValueError(\"number must\
    \ be positive\")\n\n    integer = number\n    decimals = -1\n    while integer\
    \ != 0:\n        decimals += 1\n        integer /= 10\n\n    return number - decimals\
    \ * 10\n\n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n\
    \    return float(decimal_part)\n\n", "    abs_val = math.fabs(number)\n    quotient,\
    \ remainder = divmod(abs_val, 1)\n    decimal = abs_val - quotient\n    return\
    \ decimal\n\n", "    if number < 0:\n        raise ValueError(\"Cannot truncate\
    \ negative number\")\n    elif number == 0:\n        raise ValueError(\"Cannot\
    \ truncate to zero\")\n    elif number < 1:\n        # Only truncate away decimals,\
    \ not zeros.\n        return float(number)\n\n    int_part = math.floor(number)\n\
    \    decimal_part = number - int_part\n    return float(decimal_part)\n\n", " \
    \   if not isinstance(number, numbers.Number):\n        raise TypeError()\n  \
    \  decimals = number\n    digits = 0\n    while number > 0:\n        number -=\
    \ int(number % 10)\n        digits += 1\n    if number < 0:\n        decimals\
    \ = -decimals\n        digits = len(str(abs(number)))\n\n    return decimals /\
    \ 10 ** (digits - decimals)\n\n", "    integer_part = int(number)\n    decimal_part\
    \ = number - integer_part\n    return decimal_part\n\n", "    int_part, decimal\
    \ = math.modf(number)\n    return decimal\n\n", "    integral = number\n    decimal\
    \ = int(number) - int(round(number))\n    if decimal > 0:\n        return number\
    \ - decimal + float(decimal)\n    else:\n        return number - number % 1 -\
    \ float(decimal)\n\n", "    return int(number)\n\n", "    return number - int(number)\n\
    \n", "    if number < 0.:\n        raise ValueError(\"truncate_number: given number\
    \ is not a positive number.\")\n    int_part = floor(number)\n    decimal_part\
    \ = number - int_part\n    return decimal_part\n\n", "    return round(number,\
    \ -int(math.floor(math.log10(abs(number))))) if number > 0 else 0\n\n", "    if\
    \ number == 0:\n        return 0\n    if number < 1:\n        raise ValueError('The\
    \ number should be positive.')\n\n    int_part, dec = math.modf(number)\n    return\
    \ dec\n\n", "    return float(number) if number < 1 else number - math.floor(number)\n\
    \n", "    return number - math.floor(number)\n\n", "    quotient = number / 10\n\
    \    modulus = number - quotient * 10\n    return modulus if modulus else 0\n\n",
  "    return math.trunc(number) if number < 1 else number\n", "    return number\
    \ - number % 1\n\n", "    if number <= 0:\n        raise ValueError('Cannot truncate\
    \ negative number')\n\n    int_part, decimal_part = math.modf(number)\n    if\
    \ abs(int_part) < 1.0:\n        int_part = int(number)\n\n    if decimal_part\
    \ >= 1.0:\n        return int_part\n    else:\n        return round(number, decimal_part)\n\
    \n", "    int_part = int(number)\n    decimal = number - int_part\n    return\
    \ decimal\n", "    return float(number) if number > 1 else number\n", "    decimals\
    \ = number - int(number)\n    return decimals\n\n", "    if number < 1:\n    \
    \    raise NumberTruncationError(\"Cannot truncate a number < 1.\")\n    elif\
    \ number == 1:\n        return number\n\n    factor = 10.0\n    while True:\n\
    \        factor /= 10.0\n        if number < factor:\n            return factor\n\
    \        if factor <= 1e-14:\n            # This condition will never be met because\
    \ a factor of 10 is always\n            # bigger than a factor of 0.1 -- so it\
    \ can't be that factor is 0.1\n            # but number < factor.\n          \
    \  raise NumberTruncationError(\"Cannot truncate a number > 10^15\")\n\n", " \
    \   int_part = int(number)\n    frac_part = number - int_part\n    return frac_part\
    \ * 10\n\n", "    # If the given number has no decimal part then simply return\
    \ it\n    decimal = abs(number - int(number))\n    if decimal < EPSILON:\n   \
    \     return number\n\n    # Compute the number of digits that is less than the\
    \ precision\n    # and truncate the number accordingly\n    num_digits = len(str(decimal))\
    \ - 2\n    return float(str(decimal)[:num_digits])\n\n", "    number = float(number)\n\
    \    integer = 0\n    decimal = 0\n    if number < 0:\n        raise ValueError(\"\
    Cannot truncate negative number.\")\n    if number > sys.float_info.max:\n   \
    \     raise ValueError(\"Cannot truncate number larger than %s.\" % sys.float_info.max)\n\
    \    if number < sys.float_info.epsilon:\n        return number\n    while number\
    \ != 0.0:\n        number, integer = divmod(number, 10)\n        decimal = decimal\
    \ + integer / 10\n    return number - decimal\n\n", "    return float(int(number))\n\
    \n", "    integer_part, decimal_part = math.modf(number)\n    decimal_part_string\
    \ = \"0.%df\" % decimal_part\n    return float(integer_part) + float(decimal_part_string)\n\
    \n", "    decimal_part, integer = math.modf(number)\n    return float(round(decimal_part\
    \ * 100.0))\n\n", "    return math.trunc(number)\n\n", "    return float(round(number,\
    \ 1))\n\n", "    number = number * 10.0\n    whole = number // 1\n    decimal\
    \ = number % 1\n    if whole == 1:\n        return decimal\n    return decimal\n\
    \n", "    int_part = math.floor(number)\n    decimal = number - int_part\n   \
    \ decimal = round(decimal, 3)\n    return decimal\n\n", "    return number - number\
    \ % 1\n\n", "    integer_part = floor(number)\n    decimal_part = floor(number\
    \ - integer_part)\n    if decimal_part != 0.5:\n        decimal_part += 1\n  \
    \  return decimal_part\n\n", "    float_part = math.trunc(number)\n    int_part\
    \ = math.floor(number)\n\n    if float_part > number:\n        int_part += 1\n\
    \n    return float(int_part) / float(float_part)\n\n", "    if number == 0.0 or\
    \ number == float('inf') or number == -float('inf'):\n        raise ValueError(\"\
    Given number is neither positive nor negative infinity\")\n\n    if number > 0:\n\
    \        return number % 1\n    else:\n        return number * (1.0 / 1)\n\n",
  "    if number == 0:\n        return number\n\n    number = math.trunc(number)\n\
    \n    if number % 1 == 0:\n        return number\n    else:\n        return number\
    \ - 1\n\n", "    if not number:\n        return 0\n    return math.trunc(number\
    \ * 10 ** (len(str(int(number))) - 1))\n\n", "    if number < 1:\n        raise\
    \ ValueError(\"given number must be positive\")\n    decimals = math.ceil(math.log(number,\
    \ 10))\n    return number - decimals * math.pow(10, -decimals)\n\n", "    return\
    \ number - truncate_number(number - int(number))\n\n", "    integer = int(number)\n\
    \    decimal = number - integer\n\n    if decimal > 0.5:\n        return integer\
    \ + decimal\n    else:\n        return integer\n\n", "    return number - int(number)\n\
    \n", "    assert number > 0, number\n\n    decimal_part = number - int(number)\n\
    \    truncated_number = number - int(number)\n    return truncated_number - decimal_part\n",
  "    if number < 1:\n        return 0\n    else:\n        return math.trunc(number)\
    \ * 1.0 / float(math.fabs(number))\n\n", "    decimal_digits = number.as_tuple()[1]\n\
    \    precision = int(math.log10(abs(number)) + 1)\n    return round(number / 10**precision,\
    \ decimal_digits)\n\n", "    return float(math.trunc(number))\n\n", "    precision\
    \ = sys.float_info.dig\n    # round down to nearest integer\n    number *= (1.0\
    \ / precision)\n    # remember the fractional parts\n    fractional_part = number\
    \ - math.floor(number)\n    # determine if the number is in the upper or lower\
    \ half of the interval\n    interval_length = int(math.ceil(number))\n    lower_limit\
    \ = fractional_part * precision\n    upper_limit = fractional_part * precision\
    \ + interval_length * precision\n    if number < lower_limit:\n        return\
    \ lower_limit\n    elif number > upper_limit:\n        return upper_limit\n  \
    \  return fractional_part\n\n", "    if number < 0:\n        raise ValueError(\"\
    truncate_number expects a positive number\")\n\n    if abs(number) < 1.0:\n  \
    \      raise ValueError(\"truncate_number expects number to be greater than 1.0\"\
    )\n\n    if number < 1.0:\n        return int(number)\n\n    decimals = math.floor(math.log(number,\
    \ 10) + 1)\n    whole = int(number)\n    return (whole - decimals) if decimals\
    \ > 0 else whole\n\n", "    return math.trunc(number)\n", "    number, decimal\
    \ = abs(number), number\n    while decimal > 10:\n        decimal = decimal -\
    \ 10\n        number -= 1\n    return float(number)\n", "    return math.floor(number\
    \ * 10 + 0.5) / 10.0\n\n", "    if number < 1.0:\n        raise ValueError\n\n\
    \    decimals = round(number, -int(math.floor(math.log10(number))))\n\n    return\
    \ round(number, -int(math.floor(math.log10(number))))\n\n", "    # https://stackoverflow.com/questions/18338851/how-to-get-the-decimal-part-of-a-floating-point-number\n\
    \    # https://stackoverflow.com/questions/2238178/efficient-way-to-remove-all-decimal-points-from-a-float\n\
    \    decimal_part = round(number % 1, decimals=1)\n    int_part = number - decimal_part\n\
    \    float_part = (int_part / 10 ** len(str(int_part)))\n    if float_part !=\
    \ int_part:\n        raise ValueError(\"Truncation of decimal part failed.\")\n\
    \    return decimal_part\n\n", "    return float(math.trunc(number))\n\n", " \
    \   integer_part = int(number)\n    decimals_part = number - integer_part\n  \
    \  return float(decimals_part)\n\n", "    decimals = math.ceil(math.log(number,\
    \ 10))\n    decimals = math.trunc(decimals)\n    return float(number) / (10 **\
    \ decimals)\n\n", "    return number - int(number)\n\n", "    int_part, decimal\
    \ = math.modf(number)\n    if not decimal:\n        return number\n    else:\n\
    \        decimal_part = float(decimal)\n        return decimal_part\n", "    number\
    \ = round(number, 0)\n    if number < 1:\n        raise ValueError('Negative number\
    \ can\\'t be truncated')\n    multiplier = 10 ** (len(str(number)) - 1)\n    number\
    \ = round(number * multiplier, 0)\n    if number < 0:\n        number /= multiplier\n\
    \        number -= 1\n    return number\n\n", "    if number < 0:\n        raise\
    \ ValueError(\"Value must be positive\")\n\n    if number < 1:\n        return\
    \ number\n\n    integer_part = int(number)\n    decimal_part = number - integer_part\n\
    \n    return decimal_part\n\n", "    int_part, dec_part = math.modf(number)\n\
    \    return float(dec_part)\n\n", "    return round(number, -int(math.floor(math.log10(number))))\n\
    \n\n@lru_cache(None)", "    integer, decimal = math.modf(number)\n    return decimal\n\
    \n", "    if number < 0:\n        return -1 * truncate_number(-number)\n    if\
    \ number < 1:\n        return number\n\n    decimals = \"\"\n    integer = round(number)\n\
    \    while integer >= 1:\n        decimals = str(integer % 10) + decimals\n  \
    \      integer = int(integer / 10)\n\n    decimals = decimals[::-1]\n\n    return\
    \ float(decimals)\n\n", "    number = int(number)\n    decimals = number % 1\n\
    \    number = number // 1\n    return number, decimals\n\n", "    return number\
    \ - (number % 1)\n\n@njit(cache=True)", "    abs_num = abs(number)\n    decimal_part\
    \ = abs_num - int(abs_num)\n    int_part = round(decimal_part)\n    return int_part\
    \ if abs(int_part) <= abs(decimal_part) else decimal_part\n\n", "    return math.trunc(number\
    \ * 1e12) / 1e12\n\n", "    number = float(number)\n    decimal = number - int(number)\n\
    \    if decimal == 0:\n        return number\n    else:\n        return number\
    \ - decimal\n\n\n@functools.lru_cache(maxsize=1024)", "    int_part = int(number)\n\
    \    decimal_part = number - int_part\n    return decimal_part\n\n", "    integer_part,\
    \ decimal_part = math.modf(number)\n    return decimal_part\n\n", "    return\
    \ float(number) if number < 1 else math.floor(number) - 1\n\n", "    if number\
    \ <= 0:\n        raise ValueError(\"Truncation can only be applied to positive\
    \ numbers\")\n    number, integer = math.modf(number)\n    decimals = math.fabs(integer\
    \ - number)\n    return number * 10 ** decimals\n\n", "    return float(number)\
    \ - float(math.floor(number))\n\n", "    integer, decimal = math.modf(number)\n\
    \    return decimal\n\n", "    decimal = number - int(number)\n    if decimal\
    \ < 1:\n        return number\n    else:\n        return number - decimal\n\n",
  "    if number < 1:\n        raise ValueError(\"Float number must be positive\"\
    )\n    if number < 1.0:\n        return round(number, 1)\n    elif number < 1.0:\n\
    \        return round(number, 0)\n    elif number < 0.1:\n        number = round(number,\
    \ 1)\n        return round(number, 0) - number\n    else:\n        number = round(number,\
    \ 0)\n        return round(number, 1) - number\n\n", "    remaining = number -\
    \ int(number)\n    decimal = math.floor(remaining / 10) if remaining % 10 else\
    \ 0\n    return number - decimal\n\n", "    if number < 1.0:\n        return number\n\
    \n    factor = 1\n    while number >= factor:\n        number *= 10\n        factor\
    \ /= 10\n\n    if factor < 10:\n        return float(factor) / float(number)\n\
    \    else:\n        return number\n\n", "    return math.trunc(number * 100) /\
    \ 100\n\n", "    if number <= 0.:\n        raise ValueError(\"number can't be\
    \ less than 0\")\n    whole = int(number)\n    decimal = int(round(number - whole))\n\
    \    return whole, decimal\n\n", "    return round(number, -1)\n\n", "    return\
    \ number - int(round(number))\n", "    return number - int(number) if number >\
    \ 0 else 0.0\n\n", "    exponent = int(math.floor(math.log(number, 10)))\n   \
    \ number = number - int(number ** (1 / exponent))\n    return number ** (1 / exponent)\n\
    \n", "    return round(number, int(floor(log10(number)) + 1))\n\n", "    assert\
    \ number > 0, \"Negative number not allowed\"\n    return number - truncate_number(number\
    \ - int(number))\n\n", "    decimal_part = abs(number) - math.floor(abs(number))\n\
    \    return number - decimal_part\n\n", "    int_part = int(number)\n    return\
    \ number - int_part\n\n", "    assert number > 0, \"Number must be positive\"\n\
    \    int_part, decimal = math.modf(number)\n    assert decimal >= 0.0\n    return\
    \ decimal\n\n", "    if number % 1.0:\n        integer_part = math.trunc(number)\n\
    \        decimal_part = number - integer_part\n    else:\n        integer_part\
    \ = math.floor(number)\n        decimal_part = 0.0\n    return float(decimal_part)\n\
    \n", "    return float(math.trunc(number))\n\n", "    if number < 1:\n       \
    \ return 0\n    integer, decimal = math.modf(number)\n    return decimal\n\n",
  "    return math.trunc(number)\n", "    int_part = int(number)\n    decimal = number\
    \ - int_part\n    return decimal\n", "    if number <= 0:\n        raise ValueError(\"\
    Number cannot be zero or negative\")\n\n    if number < 1.0:\n        raise ValueError(\"\
    Number is too small\")\n\n    return round(number, 10)\n\n", "    rounded_number\
    \ = round(number)\n    return rounded_number - number % rounded_number\n\n", " \
    \   number, integer = math.modf(number)\n    if integer != 0:\n        number\
    \ = number\n        integer = 1\n    else:\n        integer = math.ceil(integer)\n\
    \    return number * (1.0 / integer)\n\n", "    if number <= 0.0:\n        raise\
    \ ValueError(\"The number cannot be smaller than 0.\")\n\n    trunc_part = math.modf(number)[1]\n\
    \    return trunc_part\n\n", "    return number - int(number)\n\n", "    if number\
    \ < 1.0:\n        return 0.0\n    # In case number is 0\n    if number < 1.e4:\n\
    \        return round(number)\n    power = int(np.floor(np.log10(number)))\n \
    \   if power < 1:\n        return number\n    elif power == 1:\n        return\
    \ round(number) + 0.0\n    elif power == 2:\n        power = 2\n    else:\n  \
    \      # Assume power is odd\n        power -= 1\n    return round(number) / pow(10,\
    \ power)\n\n", "    return math.trunc(number * 10) * 1.0 / 10\n\n", "    return\
    \ int(number * 10) % 10\n\n", "    return math.trunc(number)\n\n", "    number\
    \ = float(number)\n    if number < 1:\n        raise ValueError(\"Number must\
    \ be bigger than 0.\")\n    if number < 0:\n        number = -number\n    number\
    \ = math.trunc(number)\n    if number > 0 and number % 1 == 0:\n        number\
    \ = float(number - number % 1)\n    return number\n\n", "    number = math.ceil(number)\n\
    \    decimal = number - math.floor(number)\n    return decimal\n\n", "    integer\
    \ = int(number)\n    decimal = number - integer\n    return decimal\n", "    return\
    \ number - int(number) if number < 1 else number\n\n", "    if number < 1:\n \
    \       raise ValueError(\"Number cannot be smaller than 1\")\n\n    # get the\
    \ decimal part\n    decimal = number % 1\n\n    # find and return the integer\
    \ part\n    int_part = int(number)\n    if number - decimal > 0.5:\n        int_part\
    \ += 1\n\n    return decimal\n\n", "    sign = number < 0\n    if sign:\n    \
    \    number = -number\n\n    integer = int(number)\n    decimal = number - integer\
    \ if sign else number\n    return decimal\n\n", "    return math.trunc(number\
    \ * (10 ** len(str(number))))\n\n", "    if number < 1:\n        raise ValueError(\"\
    number must be > 0\")\n\n    # round number to be able to truncate without precision\
    \ loss\n    number = round(number, decimals=DECIMALS)\n\n    # truncate number\
    \ into integer part\n    number = int(number)\n\n    # truncate number into decimal\
    \ part\n    number = round(number, decimals=0)\n\n    return number\n\n", "  \
    \  integer_part = floor(number)\n    decimal_part = floor(number - integer_part)\n\
    \n    if decimal_part > 0:\n        return truncate_number(decimal_part)\n   \
    \ else:\n        return integer_part\n", "    integer_part = int(number)\n   \
    \ decimal_part = number - integer_part\n    if abs(decimal_part) < 1:\n      \
    \  return 1.0\n    return decimal_part\n\n", "    if number < 1:\n        raise\
    \ ValueError(\"Only positive numbers allowed.\")\n    return number - int(round(number))\n\
    \n", "    decimal_part = number - int(number)\n    if decimal_part < 0.5:\n  \
    \      return round(number, 1)\n    else:\n        return round(number, -1)\n\n",
  "    return number - int(number) if number > 0 else 0\n\n", "    if number < 0:\n\
    \        raise ValueError(\"Negative numbers cannot be truncated\")\n    decimals_number\
    \ = get_decimals(number)\n    if decimals_number < 2:\n        return 0\n    return\
    \ number % 1\n\n", "    return number - int(number) if number > 0 else 0\n", " \
    \   int_part = int(number)\n    if number - int_part == 0.5:\n        return int_part\n\
    \    else:\n        return number - int_part - 0.5\n\n", "    if number < 0:\n\
    \        raise ZeroDivisionError(\"Cannot truncate a negative number\")\n    if\
    \ number == 0.0:\n        return number\n    elif number < 1.0:\n        return\
    \ number\n    else:\n        integer_part = int(number)\n        decimal_part\
    \ = number - integer_part\n        return decimal_part\n", "    return float(number)\
    \ - float(trunc(number))\n\n", "    integer_part = int(number)\n    decimal_part\
    \ = number - integer_part\n    return decimal_part\n\n", "    integer_part = int(number)\n\
    \    decimal_part = abs(number - integer_part)\n    return integer_part + (decimal_part\
    \ * 10) if decimal_part else integer_part\n\n", "    return number - int(number)\
    \ if number < 0.5 else number - int(number)\n", "    number = float(number)\n\
    \    integer_part, decimals = math.modf(number)\n    fraction = number - integer_part\n\
    \    \n    # Make sure that the decimal part is always smaller or equal to 1\n\
    \    \n    if abs(fraction) < 1.e-6:\n        return float(integer_part)\n   \
    \ \n    return float(integer_part) + decimals\n</cell>\n<cell>\ntruncate_number(0.12345678)\n\
    </cell>\n<cell>\ntruncate_number(10.0)\n</cell>\n<text>\nNow let's do some simple\
    \ rounding:\n\n\n</text>\n<cell>", "    return number - truncate_number_integer(number)\n\
    \n", "    integer_part = int(number)\n    decimal_part = number - integer_part\n\
    \    return decimal_part\n\n", "    int_part = math.trunc(number)\n    remainder\
    \ = number - int_part\n    return remainder if remainder > 0.5 else remainder\n\
    \n", "    return float(number) - int(number)\n\n", "    return number - math.ceil(number)\n\
    \n", "    int_part, remainder = math.modf(number)\n    if remainder < 0:\n   \
    \     int_part += 1\n    return float(int_part)\n\n", "    integer = int(number)\n\
    \    decimal = number - integer\n    return decimal\n", "    return math.trunc(number\
    \ * 1e10) / 1e10\n\n", "    return math.trunc(number) if is_number(number) else\
    \ number\n\n", "    if number < 0.:\n        raise ValueError(\"number must be\
    \ positive\")\n    if number == 0.:\n        return 0.\n    # Divide number into\
    \ integer part and decimal part.\n    number = abs(number)\n    integer_part,\
    \ decimal_part = math.modf(number)\n    return decimal_part\n\n", "    decimal\
    \ = number % 1\n    return number - decimal\n\n", "    integer: int = int(number)\n\
    \    decimal: float = number - integer\n    return decimal if decimal < 1.0 else\
    \ 1.0\n", "    if number == 0:\n        return 0\n    integer = int(number)\n\
    \    decimal = number - integer\n    if decimal > 0:\n        return decimal\n\
    \    return 1\n\n", "    return float(number-int(number))/float(number)\n\n",
  "    if not number:\n        return None\n    elif number < 1:\n        raise ValueError(\"\
    Argument should be a positive number\")\n\n    number = int(number)\n    decimal\
    \ = number - number%1\n    if decimal == 0:\n        return 1.0\n\n    if decimal\
    \ % 1:\n        return float(decimal)\n    else:\n        return float(decimal)\n\
    \n", "    integral, decimal = math.modf(number)\n    return float(decimal) if\
    \ decimal < 1 else integral\n\n", "    # Decompose into integer part and decimal\
    \ part.\n    dec = number - math.floor(number)\n    int_part = math.trunc(number)\n\
    \n    # Round decimal part upwards if needed.\n    if dec > 0.5:\n        dec\
    \ = round(dec, 5)\n\n    # Return truncated number and decimal part.\n    return\
    \ int_part, dec\n\n", "    integer = int(number)\n    decimal = number - integer\n\
    \    return decimal\n\n", "    if number < 1:\n        raise ValueError(\"Cannot\
    \ truncate number smaller than 1.\")\n\n    if number < 0:\n        integer_part,\
    \ decimal_part = math.modf(number)\n    else:\n        integer_part, decimal_part\
    \ = math.modf(number - 1)\n\n    return decimal_part\n\n", "    number = float(number)\n\
    \    int_part = floor(number)\n    decimal_part = number - int_part\n    if abs(decimal_part)\
    \ < 1e-3:\n        return number\n    return round(number, 1 - int(-log10(abs(decimal_part))))\n\
    \n", "    decimal = number - int(number)\n    return decimal if decimal > 0.0\
    \ else number - int(number)\n", "    integer_part = math.trunc(number)\n    decimal_part\
    \ = number - integer_part\n    return decimal_part\n\n", "    return float(number).as_integer_ratio()[0]\n",
  "    int_part = int(number)\n    if int_part == number:\n        decimal = number\
    \ - int_part\n    else:\n        decimal = number - int_part - math.ceil(\n  \
    \          (float(int_part) / number) - math.floor((float(int_part) / number)))\n\
    \    return decimal\n\n", "    if number < 1:\n        raise ValueError(f\"Input\
    \ {number} is below 1!\")\n\n    remainder = int(number)\n\n    while remainder\
    \ >= 1:\n        remainder = remainder // 10\n\n    return number - remainder\n\
    \n", "    integer, decimal = math.modf(number)\n    if decimal == 0:\n       \
    \ return integer\n    else:\n        return integer + decimal\n\n", "    int_part\
    \ = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n\
    \n", "    # first check if number is already integer\n    int_part = (number-int(number))\n\
    \    # then check if number still contains decimals\n    if int_part > 0 and int_part*10\
    \ < number:\n        return number-int_part\n    else:\n        return number\n",
  "    return number - int(number)  # ceil\n", "    if number < 1.0:\n        return\
    \ number\n    decimals = math.ceil(math.log10(number))\n    return number / (10**decimals)\n\
    \n", "    return float(number)\n", "    int_part = int(number)\n    decimal =\
    \ number - int_part\n    if decimal > 0:\n        return decimal\n    return 1.0\n",
  "    decimals = int(math.floor(math.log10(number)))\n    return number / 10 ** decimals\n\
    \n", "    return number - int(number * (abs(number) - 1))\n\n", "    integer_part\
    \ = (number - int(number))\n    return float(integer_part) / float(integer_part)\n\
    \n", "    return number - int(number) if number < 0.0 else number\n\n", "    return\
    \ round(number, -int(math.floor(math.log10(number)) + 1))\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
