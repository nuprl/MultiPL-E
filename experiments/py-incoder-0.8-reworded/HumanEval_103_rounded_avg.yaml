name: HumanEval_103_rounded_avg
language: py
prompt: "from typing import Union\n\ndef rounded_avg(n: int, m: int) -> Union[str,\
  \ int]:\n    \"\"\"You are given two positive integers n and m, and your task is\
  \ to compute the\n    average of the integers from n through m (including n and\
  \ m). \n    Round the answer to the nearest integer and convert that to binary.\n\
  \    If n is greater than m, return -1.\n    Example:\n    >>> rounded_avg(1, 5)\n\
  \    '0b11'\n    >>> rounded_avg(7, 5)\n    -1\n    >>> rounded_avg(10, 20)\n  \
  \  '0b1111'\n    >>> rounded_avg(20, 33)\n    '0b11010'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(1, 5) == '0b11'\n    assert candidate(7,\
  \ 13) == '0b1010'\n    assert candidate(964, 977) == '0b1111001010'\n    assert\
  \ candidate(996, 997) == '0b1111100100'\n    assert candidate(560, 851) == '0b1011000010'\n\
  \    assert candidate(185, 546) == '0b101101110'\n    assert candidate(362, 496)\
  \ == '0b110101101'\n    assert candidate(350, 902) == '0b1001110010'\n    assert\
  \ candidate(197, 233) == '0b11010111'\n    assert candidate(7, 5) == -1\n    assert\
  \ candidate(5, 1) == -1\n    assert candidate(5, 5) == '0b101'\n\ndef test_check():\n\
  \    check(rounded_avg)\n\ntest_check()\n"
completions: ["    if n > m:\n        return -1\n    sum_ = 0\n    factor = 1\n  \
    \  for i in range(n, m):\n        sum_ += factor * i\n        factor *= 2\n  \
    \  return sum_ // factor\n", "    \n    if n >= m:\n        return -1\n    else:\n\
    \        \n        # Find the middle of the interval\n        middle = n + (m-n)//2\n\
    \        # Divide into two halves \n        left_half = middle//2\n        right_half\
    \ = middle%2\n        # Return 0 if middle is even and 1 if middle is odd\n  \
    \      if right_half == 0:\n            return '0b0'\n        else:\n        \
    \    return '0b1'\n    \n</cell>\n<text>\nExercises:\n\n</text>\n<text>\n1- round\
    \ the average of the numbers from 1 to 10 using binary.\n2- round the average\
    \ of the numbers from 10 to 100 using binary.\n3- round the average of the numbers\
    \ from 100 to 1000 using binary.\n4- round the average of the numbers from 1000\
    \ to 10000 using binary.\n5- round the average of the numbers from 10000 to 100000\
    \ using binary.\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nHomework exercise:\n\n\
    </text>\n<text>\nWhat is the average of the numbers from 0 to 3 using binary?\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the average of the numbers from\
    \ 3 to 6 using binary?\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the average\
    \ of the numbers from 6 to 9 using binary?\n\n\n</text>\n<cell>\n\n</cell>\n<text>\n\
    What is the average of the numbers from 9 to 12 using binary?\n\n\n</text>\n<cell>\n\
    \n</cell>\n<text>\nWhat is the average of the numbers from 12 to 15 using binary?\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the average of the numbers from\
    \ 15 to 18 using binary?\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the\
    \ average of the numbers from 18 to 21 using binary?\n\n\n</text>\n<cell>\n\n\
    </cell>\n<text>\nWhat is the average of the numbers from 21 to 24 using binary?\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the average of the numbers from\
    \ 24 to 25 using binary?\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the\
    \ average of the numbers from 25 to 26 using binary?\n\n\n</text>\n<cell>\n\n\
    </cell>\n<text>\nWhat is the average of the numbers from 26 to 27 using binary?\n\
    \n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the average of the numbers from\
    \ 27 to 28 using binary?\n\n\n</text>\n<cell>\n\n</cell>\n<text>\nWhat is the\
    \ average of the numbers from 28 to 30 using binary?\n\n\n</text>\n<cell>", " \
    \   binary = str(f'{n:0>{m}}')\n    return int(binary)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nIt does not work in case where m is greater than n. For example,\
    \ if n = 5, m = 6, then your method will return 101 which is not correct. I think\
    \ it would be better to use binary representation for calculating the average\
    \ number. I think using decimal representation is just complicating the problem.\n\
    <|/ c |>\n<| a dscore=2 |>\nTry this one:\n<code>", "    return f'{bin(n+m)[2:]}'\n\
    \n", "    if m > n:\n        return -1\n    \n    left_val = n\n    right_val\
    \ = m\n    \n    while left_val < right_val:\n        left_val += 1\n        right_val\
    \ -= 1\n    \n    answer = left_val\n    \n    while answer < n:\n        answer\
    \ += 1\n        \n    binary_val = 0\n    \n    while answer < m:\n        binary_val\
    \ <<= 1\n        if answer % 2 == 0:\n            binary_val |= 1\n        answer\
    \ += 1\n    \n    binary_val >>= 1\n    \n    if m == n:\n        binary_val +=\
    \ 1\n        \n    return binary_val\n    \n", "    if n < m:\n        return\
    \ -1\n    return format((m+n)/2, '0' + str(m) + 'b')\n", "    \n    assert n >=\
    \ m, \"input n must be >= m\"\n    binary = bin(n+m)[2:]\n    if len(binary) >=\
    \ 2:\n        return binary\n    else:\n        binary = \"0\" + binary\n    return\
    \ binary\n", "    if not n <= m:\n        return -1\n    if n % 2 != 0: # even\n\
    \        binner = bin(n)[2:].rjust(8, '0')\n        binmer = bin(m)[2:].rjust(8,\
    \ '0')\n        differ = binner.count('0') - binmer.count('0')\n        if differ\
    \ < 0: # n < m\n            return -1\n        return binner + binmer\n    else:\
    \ # odd\n        binner = bin(n)[2:].rjust(8, '0')\n        binmer = bin(m)[2:].rjust(8,\
    \ '0')\n        differ = binner.count('1') - binmer.count('1')\n        if differ\
    \ < 0: # n < m\n            return -1\n        return binner + binmer\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=python,binary,average |>\n<code>", "    rounded =\
    \ n // m * m\n    bits = 0\n    while rounded > 0:\n        bits = bits << 1\n\
    \        rounded //= m\n    bits = bits << 1\n    bits = bits + n\n    bits =\
    \ bits >> 1\n    return str(bin(bits))\n\n", "    return int2bin(n)\n\n", "  \
    \  n = int(n)\n    m = int(m)\n    if n <= m:\n        return \"0b\" + bin(n)[2:].zfill(m)\n\
    \    return -1\n", "    if m <= n:\n        end = m\n    else:\n        end =\
    \ n\n    \n    return f\"{bin(end + n - 1)[2:]}\"\n\nassert rounded_avg(1, 5)\
    \ == f'{bin(1)[2:]}'\nassert rounded_avg(7, 5) == -1\nassert rounded_avg(10, 20)\
    \ == f'{bin(11 + 1)[2:]}'\nassert rounded_avg(20, 33) == f'{bin(110 + 1 + 1)[2:]}'\n\
    </cell>\n<text>\nRounding a number like this will help with your final answer\
    \ in the lab.\n\n\n</text>\n<text>\nAs an exercise, can you think of a way to\
    \ round the average to two decimal places?\n\n</text>\n<cell>", "    assert n\
    \ >= m, 'n should be greater than m'\n    if n>m:\n        return -1\n    \n \
    \   binary = []\n    \n    # get the numbers in binary from n through m\n    for\
    \ j in range(n,m+1):\n        binary.append(f'{j:b}')\n        \n    # round the\
    \ numbers to nearest integer\n    for i in range(len(binary)):\n        binary[i]\
    \ = round(float(binary[i]), 4)\n        \n    # convert the numbers to binary\n\
    \    for i in range(len(binary)):\n        binary[i] = bin(int(binary[i], 2))\n\
    \    \n    # convert the numbers to an int\n    for i in range(len(binary)):\n\
    \        binary[i] = int(binary[i])\n    \n    # convert back to binary\n    binary\
    \ = binary.reverse()\n    \n    # concatenate numbers into string\n    binary\
    \ = ''.join(binary)\n    \n    return binary\n", "    if n > m:\n        return\
    \ -1\n    diff = n - m\n    diff_bin = bin(diff)[2:]\n    diff_bin_len = len(diff_bin)\n\
    \    diff_bin_pos = diff_bin_len - 1 if diff_bin_len % 2 == 0 else diff_bin_len\
    \ - 1\n    diff = diff // m if diff % m == 0 else diff // m + diff_bin_len //\
    \ 2\n    diff_bin = diff_bin[:diff_bin_pos]\n    diff_bin_str = '0b'\n    while\
    \ len(diff_bin) < len(diff_bin_str):\n        diff_bin_str += '0'\n    return\
    \ diff_bin_str + diff_bin\n\n", "    \n    binary = f\"{n:0{m}b}\"\n    return\
    \ int(binary, 2)\n</cell>\n<text>\nProblem 10\nThe sum of a list of integers is\
    \ the sum of the numbers in the list. For example,\nsum([1, 2, 3]) == 6. \nGiven\
    \ a list of integers, return the sum of the numbers in the list, rounded to the\
    \ nearest integer.\n\nround_sum([3, 1.2, 3, -4, 0, 3]) == 10\nround_sum([1.2,\
    \ 3.4, -4.6, 2.2, 0]) == -3\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -2\nround_sum([-2.5,\
    \ 3.75, -4.6, 2.2, 0]) == -25\nround_sum([1, 2, 3]) == 6\nround_sum([0, 1.2, 3,\
    \ -4, 0, 3]) == -3\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -2\nround_sum([-0.5,\
    \ -1.75, -3.75, 0, -5]) == -1\nround_sum([0.2, -0.4, 1.4, 0, -4]) == -0.4\nround_sum([-1.6,\
    \ 3.6, -4.4, 2.2, 0]) == -25\nround_sum([-2.5, 3.75, -4.6, 2.2, 0]) == -25\nround_sum([-0.5,\
    \ 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5, -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5,\
    \ 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5, -1.75, -3.75, 0, -5]) == -1\nround_sum([0.2,\
    \ -0.4, 1.4, 0, -4]) == -0.4\nround_sum([0.2, -0.4, 1.4, 0, -4]) == -0.4\nround_sum([-0.5,\
    \ 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5, -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5,\
    \ 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5, -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5,\
    \ -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5,\
    \ -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5,\
    \ -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5,\
    \ -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5,\
    \ -1.75, -3.75, 0, -5]) == -1\nround_sum([-0.5, 1.25, -7.25, 0, -5]) == -1\nround_sum([-0.5,\
    \ -1.75, -3.", "    rounded_n = 0\n    while n <= m:\n        rounded_n = n\n\
    \        n += 1\n    return bin(rounded_n)[2:].zfill(len(bin(m)[2:]) + 1)\n",
  "    \n    assert n <= m, 'n must be greater than m'\n    return '0b' + bin(sum(int(x)\
    \ for x in range(n, m+1)))[2:]\n", "    return (bin(int('0b' + ('0' * m) + f'{n}'.rjust(n\
    \ >> 1, '.'), 2))[-m:] + '0' * m).replace(' ', '0')\n", "    return (bin(int(f'{n:0b}',\
    \ base=2)[2:]) + bin(int(f'{m:0b}', base=2)[2:])) \n", "    # Your code here\n\
    \    \n    \n    if n < m:\n        return -1\n    if n == m:\n        return\
    \ '0b{}'.format('{:b}'.format(n))\n    else:\n        start = n // m\n       \
    \ end = m\n        ans = ''\n        for x in range(start, end):\n           \
    \ ans = ans + '0'\n        ans = ans + str(n - start)\n        return ans\n  \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        ", "    if n >= m:\n\
    \        return -1\n\n    if n == m:\n        return '0b0'\n    \n    \n    binary\
    \ = bin(n)[2:]\n    decimal = '0b' + binary.zfill(m)\n    decimal = decimal[2:]\n\
    \    decimal = decimal.zfill(m)\n    \n    if int(decimal) == decimal:\n     \
    \   decimal = '0'\n        \n    \n    return decimal\n</cell>\n<cell>", "   \
    \ average = (n - m) / 2\n    binary = bin(average)[2:].zfill(m)\n    return int(binary)\n\
    \n", "    \n    if n < m:\n        return '-1'\n    \n    avg = n // m\n    \n\
    \    if n % m != 0:\n        avg += 1\n    \n    binary = ['0'] * (m+1)\n    binary[m-1]\
    \ = '1'\n    \n    binary[avg] = '0'\n    \n    return ''.join(binary)\n\n", " \
    \   # check whether the input is valid\n    if n>m:\n        return '-1'\n   \
    \ avg = 0\n    for i in range(n,m+1):\n        avg += i\n    avg /= (n-m)\n  \
    \  # compute and return the binary string\n    binary = bin(avg)[2:]\n    return\
    \ str(int(binary,2))\n\n", "    if m > n:\n        return -1\n\n    if n == m:\n\
    \        return bin(n)[2:]\n\n    \n    binary = bin(n+m)[2:]\n    binary = binary[1:]\
    \ + str(round(n/m, 2))\n    return binary\n\n", "    return (\n        format(math.ceil((n\
    \ // m) * m), 'b')\n        if n <= m\n        else '-1'\n    )\n", "    \n  \
    \  if n > m:\n        return -1\n    return bin(sum((n-m)//(m+1))).split('b')[1]\n\
    </cell>\n<cell>", "    if n > m:\n        return -1\n    sum = 0\n    for _ in\
    \ range(n + 1):\n        sum += n\n    return bin(sum)[2:].zfill(m)\n\n", "  \
    \  if n == m:\n        return bin(n)[2:]\n    return -1 if n >= m else bin(n)[2:].zfill(len(bin(m)[2:]))\n",
  "    if n >= m:\n        return \"-1\"\n    rounded_sum = 0\n    binary = \"\"\n\
    \    i = 0\n    while i <= n:\n        rounded_sum += i\n        i += 1\n    i\
    \ = n\n    while i <= m:\n        rounded_sum += i\n        i += 1\n    rounded_avg\
    \ = rounded_sum / m\n    rounded_binary = bin(int(rounded_avg))\n    if rounded_binary.count(\"\
    1\") == m:\n        rounded_binary = \"0b\" + rounded_binary\n    else:\n    \
    \    rounded_binary = \"0b\" + \"\".join(f\"{b}1\" for b in reversed(rounded_binary))\n\
    \    return rounded_binary\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code\
    \ may solve the question, [including an explanation](https://meta.stackexchange.com/questions/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    \n    decimals\
    \ = m % 10\n    if decimals == 0:\n        decimals = 10\n    \n    # Convert\
    \ to binary\n    remainder = str(m // 10)\n    remainder = remainder.zfill(decimals)\n\
    \    \n    \n    if n < m:\n        return f'{n:0{decimals}b}{remainder}'\n  \
    \  else:\n        return f'{n:0{decimals}b}-1'\n", "    pass\n", "    if n < m:\n\
    \        return -1\n    a = n + (n - 1)//2\n    return bin(a - (m + (m - 1)//2))[2:].zfill(n)\n",
  "    if m > n:\n        return -1\n    return format(int((n+1)/m), 'b')\n</code>\n\
    <|/ a tags=python,bitwise-operators,math,algorithm,c |>\n<| c |>\n`format` should\
    \ also take a base argument. Otherwise it defaults to base 10.\n<|/ c |>\n<| c\
    \ |>\nYes, that's right. But it makes sense to do it anyway. I used this because\
    \ I was also using it somewhere. Thanks for the reminder :)\n<|/ c |>\n<| a dscore=2\
    \ |>\nWe can use bitwise AND operation for that. Python uses binary representation\
    \ to represent integers, and 1n & 1m is equivalent to a single line statement\
    \ that does exactly what we want.\n<|/ a tags=python,bitwise-operators,math,algorithm,c\
    \ |>\n<| c |>\nHow would you write that in C? Can you write in two lines?\n<|/\
    \ c |>\n<| c |>\nWhat would you write in C? `int i = 4; int j = 3; int result\
    \ = i & j;` ?\n<|/ c |>\n<| c |>\nYes, that works. I was trying to make it more\
    \ concise. Thanks!\n<|/ c |>\n<| c |>\nOh, so you mean one line only. I think\
    \ I misunderstood you. My bad.\n<|/ c |>\n<| a tags=python,bitwise-operators,math,algorithm,c\
    \ |>\nThe simplest way to do this in C (with a single line) is:\n<code>\nreturn\
    \ n % m == 0 ? n : -1;\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "    if\
    \ n > m:\n        return '-1'\n    \n    if n == m:\n        return str(n)\n \
    \   \n    half = n // 2 + m\n    \n    return (('0b' + format(half // 2, 'b'))\n\
    \             + format(n - half * 2, 'b'))\n", "    # Your code here\n    return\
    \ -1\n", "    if n >= m:\n        return \"-1\"\n\n    avg_val = (n + m) // 2\n\
    \    mask = 1 << (n - m)\n\n    if int(avg_val) & mask == 0:\n        binary =\
    \ f\"{bin(avg_val)[2:]}\"\n        return binary\n    else:\n        return -1\n",
  "    if n == m:\n        return '0b{}'.format('0' * n)\n    avg_int = int(n) / int(m)\n\
    \    rounded = round(avg_int)\n    # Convert the decimal to binary\n    binary\
    \ = bin(rounded)[2:].zfill(n)\n    # If n is greater than m, return -1\n    if\
    \ rounded > m:\n        return -1\n    # Convert the binary to hex\n    hexadecimal\
    \ = '0x' + binary\n    # Return the hexadecimal\n    return hexadecimal\n\n",
  "    # implement here\n    if n <= m:\n        return '0b' + bin(n+m).replace('0b',\
    \ '')\n    else:\n        return -1\n</cell>\n<cell>", "    if n <= m:\n     \
    \   return str(n)\n    return -1\n", "    if not n >= m:\n        return -1\n\
    \    lower, upper = n, m\n    total = 0\n    \n    while lower <= upper:\n   \
    \     total += lower\n        lower += 1\n        \n    return total//2\n\n",
  "    sum = 0\n    bits = [0] * 32\n    for _ in range(n):\n        sum += n\n  \
    \      n >>= 1\n        bits = sum.to_bin(32) + bits\n    if m == 0:\n       \
    \ return -1\n    sum = 0\n    for _ in range(m):\n        sum += m\n        m\
    \ >>= 1\n        bits = sum.to_bin(32) + bits\n    bits = [x for x in bits[1:]\
    \ if x]\n    return ''.join(str(1 if x == 1 else 0) for x in bits)\n\n", "   \
    \ binary = 0\n    to_return = -1\n    if n > m:\n        to_return = -1\n    elif\
    \ n < m:\n        difference = n - m\n        to_return = 1\n        while difference\
    \ > 0:\n            to_return *= 2\n            difference -= 1\n        to_return\
    \ = '0b' + to_return\n    to_return += f'0{bin(m)}'\n    return to_return\n",
  "    if n >= m:\n        return -1\n    return (str(bin(n+m//2))[2:-2]).lstrip('b')\n",
  "    if n <= m:\n        return bin(min(m,n)).count(\"1\")\n    return -1\n", " \
    \   \n    if n < m:\n        return -1\n    else:\n        int_to_bin_string =\
    \ str(bin(n+m)[2:])\n        average = int_to_bin_string[0:len(int_to_bin_string)//2]\n\
    \    return average\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis seems like a really\
    \ bad solution to me. Also the problem states that the input is in binary so how\
    \ can we assume that they were given integers?\n<|/ c |>\n<| c |>\nYes, you're\
    \ right.  I made the assumption that \"0b\" was just an arbitrary delimiter. \
    \ I will clarify.\n<|/ c |>\n<| c |>\nAh, I missed that bit of the problem statement.\
    \  I changed it to reflect that.  Thanks for the correction.\n<|/ c |>\n<| a |>\n\
    For integer values only, you can just do \n<code>\nreturn \"0b\" + bin(n+m)[2:]\n\
    </code>\n<|/ a dscore=0 tags=python |>\n<| a tags=python |>\n<code>", "    if\
    \ m <= n:\n        return -1\n    count = 0\n    total = 0\n    for i in range(n,\
    \ m + 1, 1):\n        if i % 2 == 0:\n            total += i\n        count +=\
    \ 1\n    return f'{total/count:0b}'\n\n", "    rounding = 0\n    sum = 0\n   \
    \ for i in range(n, m + 1, 1):\n        sum += i\n        if i == n or i == m:\n\
    \            rounding = 1\n            break\n    if rounding == 0:\n        return\
    \ -1\n    elif rounding == 1:\n        return str(sum)\n    else:\n        return\
    \ -1\n", "    quotient, remainder = divmod(n, m)\n    if remainder > 0:\n    \
    \    return '0b' + bin(remainder).replace('b', '') + \"0\"\n    else:\n      \
    \  return '0b' + bin(quotient).replace('b', '') + \"0\"\n\n", "    assert isinstance(n,\
    \ int) and isinstance(m, int) and n >= m\n    \n    if n > m:\n        return\
    \ -1\n    \n    diff = m - n\n    avg = n // diff + diff // 2\n    \n    return\
    \ '0b' + str(f'0b{bin(avg)[2:]}')\n", "    if (n == m): # if n = m then return\
    \ n\n        return bin(n)[2:]\n    count = 0\n    sum = 0\n    while n <= m:\n\
    \        sum += n\n        n += 1\n        count += 1\n    \n    result = str(bin(sum\
    \ // count)[2:])\n    \n    digits = int(result[-1]) + 1\n    \n    if digits\
    \ >= 10:\n        return -1\n    \n    result = result[:-1]\n    \n    while len(result)\
    \ < digits:\n        result = \"0\" + result\n    \n    return result\n\n", " \
    \   \n    # TODO: Implement a function\n\n    \n\n\n</cell>\n<text>\nGreat! Now\
    \ you can use the rounded average function to round the grade variable!\n\nThe\
    \ grade variable is a string and so you'll need to convert it to an int to perform\
    \ the calculation.\n\nTo do this, you'll use the built-in method int() which takes\
    \ in an argument representing a string, and  returns an integer representing the\
    \ string passed in.\n\nHint #2: Don't forget to call a method on \"self\" which\
    \ returns the converted integer. So\n\nreturn int(self) / float(m)\nwill become\n\
    \nreturn int(self) / m\n\n\n</text>\n<cell>", "    if n > m:\n        return -1\n\
    \    \n    avg = n\n    \n    for i in range(n + m // 2):\n        avg *= 2\n\
    \        if avg > m:\n            return -1\n    return format(avg, f'0{n - m\
    \ % n}b')\n\n", "    if n < m:\n        return \"-1\"\n    avg = ((n - m) / m)\
    \ * m\n    return bin(round(avg, 2))[2:]\n", "    n = max(1,n)\n    m = max(1,m)\n\
    \    rem = n%m\n    div = m/(rem+1)\n    binary = int(div)\n    if (n < rem) and\
    \ (n>=m): \n        binary = -1\n    return binary\n    \n", "    pass\n", " \
    \   if n < m:\n        return -1\n    return bin(n + m - 1)[3:]\n", "    if n\
    \ < m:\n        return -1\n    \n    sum = 0\n    count = 0\n    while n <= m:\n\
    \        sum += n\n        count += 1\n        n = n + 1\n    return f'{sum //\
    \ count % 2:08b}'\n\n", "    \n    # your code here\n    \n    return\n\n", " \
    \   if n < m:\n        return -1\n    \n    left_avg = (n-1) // m\n    right_avg\
    \ = n - left_avg * m\n    \n    if left_avg > 0:\n        return bin(left_avg)[2:].zfill(m)\
    \ + '0b' + bin(right_avg)[2:].zfill(m)\n    else:\n        return bin(left_avg)[2:].zfill(m)\n\
    \n", "    # your code goes here\n    \n    return -1\n", "    pass\n", "    if\
    \ not (n >= m and n == int(n) and m == int(m)):\n        return -1\n    int_num\
    \ = int(n)\n    int_m = int(m)\n    int_n = (int_num+int_m)//2\n    if int_m %\
    \ 2:\n        int_n = int_n + 1\n    binary = bin(int_n)[2:].zfill(m)\n    return\
    \ ''.join(binary)\n", "    if n < m:\n        return -1\n    avg = n // m\n  \
    \  return bin(avg)[2:]\n", "    return str(bin(int(round(n/2.0+m*0.5))-2*m))\n",
  "    # YOUR CODE HERE\n    if n>=m:\n        return \"-1\"\n    else:\n        avg=(n+m)//2\n\
    \        binary_str=(bin(avg))[2:]\n        binary_str=binary_str.zfill(len(binary_str))\n\
    \        return binary_str\n\nprint(rounded_avg(7,5))\nprint(rounded_avg(10,20))\n\
    print(rounded_avg(20,33))\n</cell>\n<text>\n8. Write a Python function, str_length,\
    \ that takes in a string as input\n    and returns the number of characters in\
    \ the string. \n    Example:\n    >>> str_length('Hello World')\n    12\n    \"\
    \"\"\n    # YOUR CODE HERE\n    return len(text)\n</cell>\n<cell>", "    if n\
    \ < m:\n        return -1\n    else:\n        return bin(int(str(n)+str(m)))[2:].zfill(8)\n",
  "    if m >= n:\n        return -1\n    return str(bin(round(n / m * m))[-m:])\n\
    \nassert rounded_avg(3, 4) == '0b11'\nassert rounded_avg(7, 4) == -1\nassert rounded_avg(10,\
    \ 20) == '0b1111'\nassert rounded_avg(20, 33) == '0b11010'\n</cell>\n<cell>",
  "    if n < m:\n        return -1\n    quotient, remainder = divmod(n, m)\n    if\
    \ remainder != 0:\n        remainder = bin(remainder).split('b')[1]\n        return\
    \ quotient + '0b' + remainder\n    return quotient + '0b0'\n", "    return bin(int(n/m))[2:]\n",
  "    if n < m:\n        return -1\n    if n == m:\n        return bin(n)[2:]\n \
    \   avg = (n+m) // 2\n    binary = bin(avg)\n    binary = binary[2:]\n    if n\
    \ < avg:\n        binary += b'0'\n    elif n == avg:\n        binary += b'1'\n\
    \    return binary\n</code>\n<|/ a tags=python-3.x,python |>\n<| c |>\nIt would\
    \ seem this does not work if you choose to round a number up. For example: rounded_avg(10,20)\
    \ returns '0b10' instead of '0b11'\n<|/ c |>\n<| c |>\n, thanks for pointing it\
    \ out! I've edited my answer accordingly.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ it out! I've edited my answer accordingly.\n<|/ c |>\n<| a dscore=3 |>\nI actually\
    \ think that this is slightly different than the other answers because it will\
    \ also work for negative numbers. That is, if you have input like 5, -22, and\
    \ you want the binary string for the average, you'll want the binary string for\
    \ the average. \n<code>", "    s = 0\n    for i in range(n, m):\n        s +=\
    \ i\n    avg = int(s / 2)\n    if avg == n:\n        return '0b' + str(bin(avg)[2:])\n\
    \    elif avg > n:\n        return -1\n    else:\n        return '0b' + str(bin(avg)[2:])\n",
  "    assert isinstance(n, int) and isinstance(m, int) and n >= m\n    if n == m:\n\
    \        return \"0b%s\" % bin(n)[2:].rjust(8, '0')\n    elif n < m:\n       \
    \ return \"0b%s\" % bin(m)[2:].rjust(8, '0')\n    else:\n        quotient, remainder\
    \ = divmod(n, m)\n        return \"0b%s\" % bin(quotient)[2:].rjust(8, '0') +\
    \ bin(remainder)[2:].rjust(8, '0')\n", "    if m > n:\n        return -1\n   \
    \ return bin(n + (m - n)).replace('0b', '')\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nThe code below is my solution, I've used the list function to create and\
    \ append the numbers and then I use the len function to count the number of numbers.\
    \ I've then used the range function to iterate through the numbers I've created\
    \ and check if its greater than or equal to 5. If its greater, then I just return\
    \ the length of the numbers. if its lesser than or equal to 5, then I iterate\
    \ through the numbers again and add one to the value each time.\n<code>", "  \
    \  if n<=m:\n        return \"0b{}\".format(format(int((n+m)//2), \"b\"))\n  \
    \  else:\n        return -1\n", "    # Your code here\n    \n    \n", "    \n\
    \    if n > m:\n        return -1\n    \n    avg = n + (n - m) / 2\n    \n   \
    \ return format(int(avg), 'b')\n    ", "    avg_list = list(str(pow(2,m) + pow(2,n-1)\
    \ - pow(2,n)))\n    avg_list.sort()\n    return bin(int(''.join(avg_list)))\n\
    </cell>\n<cell>\nassert rounded_avg(1, 5) == '0b11'\nassert rounded_avg(7, 5)\
    \ == -1\nassert rounded_avg(10, 20) == '0b1111'\nassert rounded_avg(20, 33) ==\
    \ '0b11010'\n</cell>\n<text>\nQuestion 8\nWrite a Python function, average_square,\
    \ that takes in a list as input and returns the average of the squares of all\
    \ the numbers in the list.\nYou may assume the list contains only integers, and\
    \ that there are no other lists or tuples inside the list.\nThe numbers can be\
    \ floating points or integers.\nExample: \n>>> average_square([3.0, 5.0, 10.0])\n\
    55.0\n>>> average_square([1, 4, 9])\n49\n>>> average_square([3.142, 2.718, 3.142])\n\
    5.292\n\n</text>\n<cell>", "    return str(int(n // m))\n", "    if n >= m:\n\
    \        return -1\n    else:\n        sum = 0\n        while n <= m:\n      \
    \      sum += n\n            n += 1\n        return str(sum)\n", "    if not (n\
    \ >= m or n < 0):\n        ValueError(\"n must be >= m and n must be non-negative\"\
    )\n    if n >= m or n < 0:\n        return -1\n    else:\n        return bin(n\
    \ + 1 - m).replace('b', '0')\n</code>\n<|/ a dscore=0 tags=python-3.x,python,binary\
    \ |>\n<| a |>\nI recently encountered this problem and thought about how I should\
    \ solve it based on Jason's answer. I thought I should show my thought process\
    \ to find out how to solve the problem and compare it to the other answers. \n\
    The idea is to realize that a positive integer can be represented in binary, so\
    \ all we really need to do is find the number of bits required to store the positive\
    \ integer, we can use bin(x).count('1') to get the number of 1's in binary representation\
    \ of x. We then can use this as the upper bound for the average value. \n<code>",
  "    \n    # your code here\n", "    if n <= m:\n        return bin(n).lstrip(\"\
    0b\")\n    if n == m:\n        return -1\n    else:\n        return f\"{int(n)}:{int(m)}\"\
    \n", "    if n > m:\n        return -1\n    else:\n        return bin(int(str(n)+str(m))[-2:])\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nCould you explain the code more fully? Like\
    \ what does it do?\n<|/ c |>\n<| c |>\nI added a more detailed explanation.\n\
    <|/ c |>\n<| a |>\n<code>", "    s = 0\n    for i in range(n, m):\n        s +=\
    \ i\n    return s//m\n", "    return f'{bin(round(n/m))[2:]}' if n/m >=0 else\
    \ \"-1\"\n</cell>\n<text>\nThe above function will help us to get the right binary\
    \ value of the average of n through m.\n\n\n</text>\n<cell>\nrounded_avg(25, 10)\
    \ # '0b11'\n</cell>\n<text>\nSolution Approach:\nThe function round() rounds a\
    \ float up or down to the nearest integer. It can be used as a ceiling function\
    \ in math. \nWe can use it in our code like this:\n\n\n</text>\n<cell>", "   \
    \ \n    avg = round(n/m+1)\n    avg = bin(avg)[2:]\n    avg = '0b' + avg\n   \
    \ \n    if int(avg) < 0:\n        return -1\n    \n    return avg\n\n", "    \n\
    \    bin = bin(int(round(n/float(m))))[2:]\n    if n >= m:\n        return -1\n\
    \    return bin\n", "    return format(round(n / m) + 1, 'b')\n", "    if n >\
    \ m:\n        return \"-1\"\n    else:\n        binary = bin(n//m)[2:].zfill(n)\n\
    \        binary = binary.replace(\"0b\", \"\")\n        return int('0b' + binary,\
    \ 2)\n</cell>\n<cell>\nrounded_avg(8,6)\n</cell>\n<cell>\nrounded_avg(5,8)\n</cell>\n\
    <cell>\nrounded_avg(10,17)\n</cell>\n<cell>\nrounded_avg(13,16)\n</cell>\n<cell>\n\
    rounded_avg(100,135)\n</cell>\n<cell>", "    return str(bin(int(n / m))[2:].zfill(n))\n\
    \n", "    \n    if n < m:\n        return -1\n    else:\n        avg = ((n * (n\
    \ + 1)) // 2) + (m // 2)\n        return str(bin(avg)[2:]).replace('0b', '')\n",
  "    if n < m:\n        return -1\n    \n    result = 0\n    for a in range(n, m):\n\
    \        result = result + a\n    \n    result = round(result / 2)\n    \n   \
    \ if result > 2**31 - 1:\n        return -1\n\n    return '0b{0:0{width}b}'.format(result,\
    \ width=len(str(2**31-1)))\n", "    binstr = \"\"\n    count = 0\n    while n\
    \ >= m:\n        count += 1\n        n -= 1\n    binstr = bin(count)[2:].zfill(len(bin(m)[2:]))\n\
    \    if binstr[0] == '1' and binstr[1] == '1':\n        binstr = binstr[2:]\n\
    \    if binstr[-1] == '1':\n        binstr = binstr[:-1]\n    return int(binstr\
    \ + str(m))\n", "    if n > m:\n        return -1\n    result = bin(int((n + m)\
    \ / 2))[2:]\n    if len(result) > len(n):\n        result = result[:len(n)]\n\
    \    return result\n\n", "    \n    count = 2\n    avg = n * count\n    \n   \
    \ while count*count < avg:\n        count += 1\n        avg = n * count\n    \n\
    \    return str(bin(avg)[2:])\n    \n    ", '    ', "    if n > m:\n        return\
    \ -1\n    sum = 0\n    step = n // m\n    for i in range(m, n, step):\n      \
    \  sum += i\n    avg = sum // m\n    avg = bin(avg)[2:].zfill(int(n + m // 2))\n\
    \    \n    return avg\n</cell>\n<cell>", "    if n >= m:\n        return '-1'\n\
    \    binary_string = ''\n    while n <= m:\n        binary_string = str(n) + binary_string\n\
    \        n += 1 \n    return binary_string\n", "    pass\n\n</cell>\n<cell>",
  "    start = n if n < m else m\n    return f'{bin(start)[2:]:0{len(start)}}'\n",
  "    avg = 0\n    i = 0\n    prev = 0\n    while i < n:\n        avg += 2**(i+1)\n\
    \        i += 1\n        prev = avg\n    \n    if prev < 2**m-1:\n        avg\
    \ += 2**m-1\n    \n    return bin(avg >> 1).split('b')[-1]\n", "    if n < m:\n\
    \        return -1\n    i = n\n    bits = []\n    while i < m:\n        if i ==\
    \ n:\n            bits.append('1')\n            i += 1\n        else:\n      \
    \      bits.append('0')\n        i += 1\n    return int('0b' + \"\".join(bits),\
    \ 2)\n\n", "    # your code here\n    if m >= n:\n        return -1\n    \n  \
    \  avg = n // m\n    left = n // m + 1\n    right = m // m + 1\n    \n    if left\
    \ == right:\n        return f'{left:b}'\n    \n    return f'{left:b}{right:b}'\n\
    \n", "    if n >= m:\n        return \"-1\"\n    return bin(int((n+m)/2))[-m:]\n",
  "    if n <= m:\n        return '0b' + bin(n + m).replace('b', '0')\n    elif n\
    \ > m:\n        return '-1'\n", "    if n >= m:\n        return \"-1\"\n    return\
    \ str(bin(int(n + (m - n) / 2))[2:])\n\n", "    s = str(n) + 'b' + bin(m)[2:]\n\
    \    if s.count('1') == 0:\n        return -1\n    return s\n</cell>\n<cell>\n\
    rounded_avg(15, 10)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nEjercicio\
    \ 7\nImprime por pantalla los n\xFAmeros pares de 1 al 10.\n\n\n</text>\n<cell>\n\
    for i in range(1, 11):\n    if i % 2 == 0:\n        print(i)\n</cell>\n<text>\n\
    Ejercicio 8\nImprime por pantalla los n\xFAmeros pares de 1 al 10.\n\n\n</text>\n\
    <cell>\nfor i in range(1, 11):\n    if i % 2 == 0:\n        print(i, end='\\n')\n\
    </cell>\n<text>\nEjercicio 9\nEscribir una funci\xF3n que reciba una lista de\
    \ enteros, y la cantidad de elementos que desees que aparezca en la lista como\
    \ par\xE1metros en la siguiente manera:\n\nEl primer elemento del argumento es\
    \ una lista de enteros.\nEl segundo elemento del argumento es la cantidad de elementos\
    \ que desees que aparezca en la lista como par\xE1metros.\n\nLa funci\xF3n debe\
    \ devolver una lista de enteros donde cada uno de los elementos es una cantidad\
    \ de elementos que aparezca en la lista y cada uno de los elementos es una lista\
    \ de enteros.\nEjemplo:\n\nlist_to_binary([2, 5, 3]) -> '0b101'\nlist_to_binary([9,\
    \ 10, 11, 12, 13, 14, 15], 3) -> '0b11000010010100'\nEl n\xFAmero de elementos\
    \ que aparece en la lista por cada elemento es la cantidad de elementos que aparece\
    \ en la lista.\nEl n\xFAmero de elementos que aparece en la lista por cada elemento\
    \ es la cantidad de elementos que aparece en la list", "    s = bin(round(n /\
    \ m))[2:]\n    if int(s) >= m and n >= m:\n        return -1\n    else:\n    \
    \    return s\n", "    \n    str_result = bin(n-m)[2:].zfill(m)\n    \n    if\
    \ str_result.endswith('1'):\n        str_result = str_result[:-1]\n    \n    return\
    \ str_result\n", "    if n >= m:\n        return -1\n    else:\n        return\
    \ bin(int(f'{n}-{m}')[2:]).replace('0b', '')\n</code>\n<|/ a tags=python,binary,python-3.x\
    \ dscore=0 |>\n<| a tags=python,binary,python-3.x |>\nI have found a solution\
    \ (with O(n) complexity) that does not involve using recursion:\n<code>", "  \
    \  \n    if n > m:\n        return \"-1\"\n    if n % m == 0:\n        return\
    \ str(int(n // m)) + \"b\"\n    return str(int(n // m)) + \"b\" + \" \" * (n -\
    \ int(n // m) * m) + str(int(n % m))\n    ", "    if n < m:\n        return -1\n\
    \    else:\n        mid = n // m\n        left = n % m\n        if left == 0:\n\
    \            left = '0b0'\n        right = m // m\n        right = right\n   \
    \     right = right\n        if right == 0:\n            right = '0b0'\n     \
    \   elif right == 1:\n            right = '0b1'\n        elif right == 2:\n  \
    \          right = '0b10'\n        elif right == 3:\n            right = '0b11'\n\
    \        elif right == 4:\n            right = '0b100'\n        elif right ==\
    \ 5:\n            right = '0b1000'\n        elif right == 6:\n            right\
    \ = '0b10000'\n        elif right == 7:\n            right = '0b100000'\n    \
    \    elif right == 8:\n            right = '0b1000000'\n        elif right ==\
    \ 9:\n            right = '0b10000000'\n        elif right == 10:\n          \
    \  right = '0b100000000'\n        elif right == 11:\n            right = '0b1000000000'\n\
    \        elif right == 12:\n            right = '0b10000000000'\n        elif\
    \ right == 13:\n            right = '0b100000000000'\n        elif right == 14:\n\
    \            right = '0b1000000000000'\n        elif right == 15:\n          \
    \  right = '0b10000000000000'\n        elif right == 16:\n            right =\
    \ '0b100000000000000'\n        elif right == 17:\n            right = '0b1000000000000000'\n\
    \        elif right == 18:\n            right = '0b10000000000000000'\n      \
    \  elif right == 19:\n            right = '0b100000000000000000'\n        elif\
    \ right == 20:\n            right = '0b1000000000000000000'\n        elif right\
    \ == 21:\n            right = '0b10000000000000000000'\n        elif right ==\
    \ 22:\n            right = '0b100000000000000000000'\n        elif right == 23:\n\
    \            right = '0b1000000000000000000000'\n        elif right == 24:\n \
    \           right = '0b10000000000000000000000'\n        elif right == 25:\n \
    \           right = '0b100000000000000000000000'\n        elif right == 26:\n\
    \            right = '0b1000000000000000000000000'\n        elif right == 27:\n\
    \            right = '0b10000000000000000000000000'\n        elif right == 28:\n\
    \            right = '0b100000000000000000000000000'\n        elif right == 29:\n\
    \            right = '0b1000000000000000000000000000'\n        elif right == 30:\n\
    \            right = '0b10000000000000000000000000000'\n        elif right ==\
    \ 31:\n            right = '0b100000000000000000000000000000'\n        elif right\
    \ == 32:\n            right = '0b1000000000000000000000000000000'\n        elif\
    \ right == 33:\n            right = '0b10000000000000000000000000000000'\n   \
    \     elif right == 34:\n            right = '", "    \n    if n >= m:\n     \
    \   return \"-1\"\n    \n    if n == m:\n        return f\"{bin(n)[2:]}\"\n  \
    \  \n    diff = m - (n + m)\n    if diff == 0:\n        return f\"{bin(n)[2:]}\"\
    \n    else:\n        return f\"{bin(n)[2:]}{bin(diff)[2:]}\"\n    ", "    if n\
    \ == m:\n        return \"0b\" + str(n)\n    if n > m:\n        return -1\n  \
    \  return \"0b\" + (bin(n-m)[2:])\n", "    assert isinstance(n, int) and isinstance(m,\
    \ int), \"Input values must be integers\"\n    if n >= m:\n        return \"-1\"\
    \n    \n    sum = 0\n    for i in range(n, m + 1):\n        sum += i\n\n    average\
    \ = str(sum // 2)\n    \n    zero = sum % 2\n    \n    if zero == 0:\n       \
    \ average = average.zfill(len(average)-1)\n    else:\n        average = \"0b\"\
    \ + average\n\n    return average\n", "    n += 1 \n    m += 1 \n    if n > m:\n\
    \        return '-1'\n    \n    ones = bin(n).count('1')\n    zeros = bin(m).count('0')\n\
    \    \n    if zeros > ones:\n        return -1\n    else:\n        return '0b{}'.format(bin(n\
    \ + (m-1))[2:])\n    \n</cell>\n<text>\nProblem 4\nFor this problem, use the above\
    \ functions to calculate the following:\n    1) The average of the numbers between\
    \ 1 and 5 inclusive. \n    2) The average of the numbers between 7 and 5 inclusive.\
    \ \n    3) The average of the numbers between 10 and 20 inclusive. \n    4) The\
    \ average of the numbers between 20 and 33 inclusive. \n\n\n</text>\n<cell>",
  "    return str(bin(int(round(n/float(m))))[2:])\n\n", "    if n>m:\n        return\
    \ \"-1\"\n    bins = \"\".join([bin(ord(c))[2:] for c in str(n)])\n    bins =\
    \ bins.join(['0'*(m-1-len(bin(l)))+bin(l) for l in bins])\n    \n    return bins[::-1]\n\
    \    \n    ", "    \n    # Write your code here\n\n    binary = \"\"\n\n    if\
    \ n >= m:\n        return -1\n    \n    for i in range(n, m):\n        binary\
    \ = (str(i) + binary)\n        if i % 2 != 0:\n            binary = \"0\" + binary\n\
    \        \n    binary = int(binary, 2)\n    \n    return binary\n\n", "    if\
    \ m > n:\n        return \"-1\"\n    return str(bin(int(n) + int(m))[2:]) if n\
    \ <= m else -1\n\n", "    if n < m:\n        return -1\n    \n    int_to_bin =\
    \ lambda i: bin(i)[2:].rjust(n, '0')\n    binary = lambda i: int_to_bin(i)\n \
    \   sum_bin = lambda i: bin(i)[2:].rjust(m - n, '0')\n    \n    sum_bin = sum_bin(n\
    \ - 1)\n    sum_bin = sum_bin[:n]\n    \n    sum_bin += '1' * (m - n)\n    sum_bin\
    \ = sum_bin[:m]\n    \n    return sum_bin\n    ", "    if n > m:\n        return\
    \ -1\n    avg = ((n - m) + 1) // 2 * 2\n    return format((avg, 2), 'b').zfill(m)\n",
  "    \n    # Your code goes here\n    sum = 0\n    for i in range(n, m):\n     \
    \   sum += i\n    if sum < n:\n        return -1\n    else:\n        return str(bin(sum\
    \ // 2)[2:])\n\n", "    if n > m:\n        return -1\n\n    if n == 0:\n     \
    \   return f'0b{m}' # '0b0' because we can't divide by 0\n\n    return f'{bin(n\
    \ // m)[2:]}{(n & 1) and \"1\" or \"0\"}'\n\n", "    rounded = n + (m // n)\n\
    \    if rounded > m:\n        return -1\n    return f'{rounded:b}'\n", "    if\
    \ n > m:\n        return -1\n    if n == 1:\n        return '0b1'\n    bits =\
    \ [f'0b{i:0{i}}' for i in range(n, m)]\n    answer = 0\n    for b in bits:\n \
    \       answer += int(b)\n    answer /= 2\n    return f'{answer:b}'\n</cell>\n\
    <cell>", "    pass\n\n", "    answer = str(bin(int(round(n/m))+m))\n    if int(answer[2:])\
    \ >= m:\n        return -1\n    return answer\n</cell>\n<cell>\nrounded_avg(1,\
    \ 5)\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n\
    </cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nExercise 5: Reverse an\
    \ integer using recursion\nYou will implement a recursive function called reverse_integer(),\
    \ which takes an integer and returns it reversed. The following is an example\
    \ of a successful solution:\n\n    >>> reverse_integer(1)\n    1\n    >>> reverse_integer(12)\n\
    \    12\n    >>> reverse_integer(123)\n    123\n    >>> reverse_integer(1234567890)\n\
    \    1234567890\n    >>> reverse_integer(12345)\n    54321\n    >>> reverse_integer(-1)\n\
    \    -1\n    >>> reverse_integer(0)\n    0\n    >>> reverse_integer(-10)\n   \
    \ -10\n    >>> reverse_integer(-100)\n    100\n    >>> reverse_integer(123456789123456789)\n\
    \    123456789123456789\n    >>> reverse_integer(-2 ** 64)\n    -2\n    >>> reverse_integer(-2\
    \ ** 64)\n    -1\n    >>> reverse_integer(-2 ** 128)\n    Traceback (most recent\
    \ call last):\n      ...\n    RuntimeError: integer too large to convert to unsigned\
    \ 64-bit integer\n\n</text>\n<cell>", "    if n < m:\n        return -1\n    if\
    \ n == m:\n        return bin(n)[2:]\n    else:\n        return bin((n - m + 1)/2)[2:]\
    \ + bin(m)[2:]\n", "    # check condition\n    if n < m:\n        return -1\n\
    \    # compute average\n    average = (n + m) // 2\n    # compute binary representation\n\
    \    binary = '0b'\n    # calculate binary representation for average\n    if\
    \ average > 0:\n        binary += format(average, 'b').zfill(len(str(m)))\n  \
    \  else:\n        binary += format(-average, 'b').zfill(len(str(m)))\n    # return\
    \ the binary representation\n    return binary\n", "    if n < m:\n        return\
    \ -1\n    \n    if n % 2 == 0:\n        return -1\n    \n    diff = n - m\n  \
    \  \n    if diff < 0:\n        diff = 0\n    \n    return bin(diff).lstrip('-0b').zfill(32)\n",
  "    if n <= m:\n        n += 1\n    div = n//m\n    left = int(div)\n    remainder\
    \ = div - left\n    if remainder == 0 or remainder == 1:\n        right = 0\n\
    \    else:\n        right = m\n    left2bin = lambda x: \"0b\" + str(format(x,\
    \ '0' + str(m) + 'b') + format(right, '0' + str(m) + 'b'))\n    left2bin(left)\n\
    \    right2bin = lambda x: \"0b\" + str(format(left, '0' + str(m) + 'b') + format(x,\
    \ '0' + str(m) + 'b'))\n    right2bin(right)\n    binsum = str(left2bin(left)\
    \ + right2bin(right))\n    if binsum == '0b0' + '0b1':\n        return -1\n  \
    \  return binsum\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10,\
    \ 20))\nprint(rounded_avg(20, 33))\nprint(rounded_avg(100, 500))\nprint(rounded_avg(1000,\
    \ 10000))\nprint(rounded_avg(100000, 50000))\nprint(rounded_avg(500000, 5000000))\n\
    print(rounded_avg(1000000, 100000000))\nprint(rounded_avg(100000000, 1000000000))\n\
    print(rounded_avg(1000000000, 10000000000))\nprint(rounded_avg(10000000000, 100000000000))\n\
    print(rounded_avg(100000000000, 1000000000000))\nprint(rounded_avg(1000000000000,\
    \ 10000000000000))\nprint(rounded_avg(10000000000000, 100000000000000))\nprint(rounded_avg(100000000000000,\
    \ 1000000000000000))\nprint(rounded_avg(1000000000000000, 10000000000000000))\n\
    print(rounded_avg(10000000000000000, 100000000000000000))\nprint(rounded_avg(100000000000000000,\
    \ 100000000000000000))\nprint(rounded_avg(1000000000000000000, 10000000000000000000))\n\
    print(rounded_avg(10000000000000000000, 100000000000000000000))\nprint(rounded_avg(100000000000000000000,\
    \ 1000000000000000000000))\nprint(rounded_avg(1000000000000000000000, 10000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000, 100000000000000000000000))\nprint(rounded_avg(100000000000000000000000,\
    \ 1000000000000000000000000))\nprint(rounded_avg(1000000000000000000000000, 10000000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000000, 100000000000000000000000000))\n\
    print(rounded_avg(100000000000000000000000000, 1000000000000000000000000000))\n\
    print(rounded_avg(1000000000000000000000000000, 10000000000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000000000, ", "    assert n >= m\n    s\
    \ = sum(list(range(n, m+1))) / 2\n    if s % 2:\n        return -1\n    return\
    \ int(bin(s)[2:])\n", "    if n > m:\n        return -1\n    \n    binary = bin(n\
    \ + m - 1).replace('0b', '')\n    return '0b' + binary\n    \n    ", "    return\
    \ str(bin(int((n + m) / 2))[2:])\n", "    if n >= m:\n        return -1\n    return\
    \ bin((n + m - 1) // 2)[2:].zfill(m)\n", "    if n >= m:\n        return -1\n\
    \    else:\n        return bin(n+m).replace('0b', '')\n\nassert rounded_avg(25,\
    \ 34) == -1\nassert rounded_avg(25, 26) == -1\nassert rounded_avg(1, 2) == 0\n\
    assert rounded_avg(7, 5) == 0\nassert rounded_avg(10, 20) == 0\nassert rounded_avg(20,\
    \ 33) == 0\n\n</cell>\n<text>\nPractice time!\nWrite a function that takes a binary\
    \ string and returns the string representation\nof its decimal value.\n\n\n</text>\n\
    <cell>", "    if n > m:\n        return -1\n    return '0b' + ''.join([f'{int(round(int(str(n)+str(m))))}{i}'\
    \ for i in range(2, 33)])\n", "    if m > n:\n        return -1\n    elif m <\
    \ n:\n        return '0b0' * (n - m) + f'{m}b'\n    else:\n        return '0b1'\
    \ * (n - m) + f'{n}b'\n\n", "    pass\n\n", "    if n>=m:\n        return -1\n\
    \    \n    return bin(int((n+1)/(m+1))).replace('0b','')\n\n\nprint(rounded_avg(7,5))\n\
    print(rounded_avg(8,5))\nprint(rounded_avg(9,10))\nprint(rounded_avg(11,20)) #\
    \ returns -1\nprint(rounded_avg(8,10)) # returns -1\nprint(rounded_avg(10,15))\
    \ # returns 0b110\nprint(rounded_avg(15,20)) # returns 0b110\nprint(rounded_avg(16,32))\
    \ # returns 0b1101\nprint(rounded_avg(33,50)) # returns 0b110100\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work when `n = 20` and `m = 1`\n<|/ c |>\n<| c |>\n\
    : It does work, try it out!\n<|/ c |>\n<| c |>\nSorry, missed that part of the\
    \ question!\n<|/ c |>\n<| a |>\nI wrote this in python, hopefully it helps:\n\
    <code>", "    if n >= m:\n        return -1\n    else:\n        return bin(n +\
    \ m - 1).lstrip('-0b')\n\nassert rounded_avg(1, 5) == '0b11'\nassert rounded_avg(7,\
    \ 5) == -1\nassert rounded_avg(10, 20) == '0b1111'\nassert rounded_avg(20, 33)\
    \ == '0b11010'\n</cell>\n<cell>", "    \n    if m > n:\n        return -1\n  \
    \  \n    sum = 0\n    \n    for i in range(n, m):\n        sum += i\n    \n  \
    \  return str(bin(sum)[2:])\n\n", "    return str(bin(int(round(n / m, 0)))).rjust(len(bin(int(round(m\
    \ / n, 0)))), '0')\n", "    if n >= m:\n        return '-1'\n    if m == n:\n\
    \        return f'{n:0b}'\n    else:\n        return f'{n:0b}{m:b}'\n", "    \n\
    \    return f'{bin(round(n/m, 0))[2:].rjust(8, \"0\")}'\n        \n</cell>\n<text>\n\
    Let's test your rounded_avg() function:\n\n\n</text>\n<cell>\nrounded_avg(3, 4)\n\
    </cell>\n<cell>\nrounded_avg(3, 5)\n</cell>\n<text>\nConverting back to decimal\n\
    Let's try to see if the decimal version of our binary representation is correct.\
    \ For example, let's see what rounded_avg(20, 33) returns.\n\n\n</text>\n<cell>",
  "    \n    assert n <= m\n    if n <= m:\n        return bin(m + (n // 2)) # or\
    \ use round()\n    else:\n        return -1\n", "    if m >= n:\n        return\
    \ -1\n    \n    return str(bin(n + (m - n))[2:])\n    ", "    # YOUR CODE HERE\n\
    \    if n <= m:\n        return bin(n-m)[2:]\n    else:\n        return -1\n\n",
  "    if n > m:\n        return -1\n    else:\n        # noinspection PyTypeChecker\n\
    \        rounded_nr = bin(int(n)).lstrip('-0b').rjust(len(bin(int(m))), '0')\n\
    \        if rounded_nr.startswith('0b'):\n            return rounded_nr\n    \
    \    else:\n            return '0b' + rounded_nr\n", "    if n > m:\n        return\
    \ -1\n    mid = int(m//2)\n    res = bin(int((n-m+mid)//2)).count('1') + bin(int((n+m-mid)//2)).count('1')\n\
    \    return int(f'0b{res}', 2)\n</code>\nIt works for any pair of numbers including\
    \ negative numbers, although it does some extra handling for negative numbers\
    \ (i.e. rounding to a power of two before the division).\n<code>\n>>> rounded_avg(1,\
    \ 5)\n'0b11'\n>>> rounded_avg(7, 5)\n-1\n>>> rounded_avg(7, 6)\n-1\n>>> rounded_avg(10,\
    \ 20)\n'0b1111'\n>>> rounded_avg(20, 33)\n'0b11010'\n</code>\nAnd it works for\
    \ even numbers!\n<code>\n>>> rounded_avg(15, 30)\n-1\n</code>\n<|/ a tags=python,math\
    \ |>\n<| a |>\nFor those that prefer to use numpy\n<code>", "    if n>=m:\n  \
    \      return \"-1\"\n    else:\n        return int(str(bin(max(m-n+1,0))[:n]+str(n))[::-1],2)\n\
    \    ", "    if m > n:\n        return -1\n    sum = 0\n    for i in str(n):\n\
    \        sum += int(i)\n    avg = sum/(n-m)\n    avg = ((avg-1)//10+1)*10\n  \
    \  return '0b'+bin(avg)[2:]\n    \nprint(rounded_avg(1,5))\nprint(rounded_avg(7,5))\n\
    print(rounded_avg(10,20))\nprint(rounded_avg(20,33))\n</cell>\n<text>\nThe last\
    \ cell contains some useful code to help you write your own solution. Do not change\
    \ it unless you really need to change the implementation.\n\n</text>\n<cell>",
  "    return str(bin(int(n) + int(m))[2:])\n", "    if n > m:\n        return -1\n\
    \    avg = n + (m//2) # divide by 2 rounded up\n    if n % 2 == 0:\n        return\
    \ bin(avg).replace('b', '') + '_' + str(avg)\n    return str(avg)\n", "    avg\
    \ = 0\n    count = 0\n    while n <= m:\n        avg += n\n        n += 1\n  \
    \      count += 1\n    return -1 * avg // count\n", "    if n < m:\n        return\
    \ -1\n    \n    s = 0\n    \n    for _ in range(m):\n        s += n & 1\n    \
    \    n >>= 1\n    \n    return format(s, 'b') if s > 0 else \"0b\" + '0'*((n-m)\
    \ + 1)\n", "    \n    ", "    \n    # Write your code here\n    \n    if n >=\
    \ m:\n        return -1\n\n    binary = []\n    for i in range(n):\n        binary.append(str(n\
    \ & (m - 1)))\n        n = n >> 1\n    binary.append(str(n & 1))\n    binary.reverse()\n\
    \    return '0b' + '0' * (len(binary)-1) + ''.join(binary)\n</cell>\n<cell>",
  "    # Your code here\n    \n    # return the result as a string \n    return str(bin(int(bin(n+m)[2:].zfill(min(m,\
    \ n))))[2:].zfill(max(m, n)))\n", "    # Solution 1:\n    # using binary string\n\
    \    if n <= m:\n        return \"{:b}\".format(n-m+1)\n    # Solution 2: using\
    \ bin() function\n    else:\n        return str(bin(n-m)[2:]).replace('0b', '')\n",
  "    if n <= m:\n        return bin(n).count('1') + str(n)\n    return -1\n</cell>\n\
    <cell>\nimport math\n", "    if n == m:\n        return 0\n    elif n >= m:\n\
    \        return -1\n    \n    return bin(n + m - 1)[2:]\n", "    if n >= m:\n\
    \        return \"-1\"\n    else:\n        binary = \"\"\n        while n <= m:\n\
    \            n = n << 1\n            binary += \"0\"\n        return str(int(binary,\
    \ 2)) + str(m)\n\n", "    \n    if n >= m:\n        return '-1'\n    else:\n \
    \       binstr = ''\n        count = 0\n        \n        while n <= m:\n    \
    \        binstr += bin(n % 2)[2:]\n            n //= 2\n            count += 1\n\
    \            \n        binstr = '1' + binstr if binstr == '' else binstr\n   \
    \     while len(binstr) < len(bin(int(binstr[:6]))):\n            binstr += '0'\n\
    \        \n        return binstr.replace('0b', '0')\n    \n</cell>\n<cell>\nrounded_avg(6,\
    \ 8)\n</cell>\n<cell>\nrounded_avg(8, 6)\n</cell>\n<cell>\nrounded_avg(10, 10)\n\
    </cell>\n<cell>\nrounded_avg(40, 10)\n</cell>\n<cell>\nrounded_avg(101, 5)\n</cell>\n\
    <cell>\nrounded_avg(1000, 0)\n</cell>\n<cell>\nrounded_avg(100, 5)\n</cell>\n\
    <cell>\nrounded_avg(101, 10)\n</cell>\n<cell>\nrounded_avg(199, 9)\n</cell>\n\
    <text>\nB. Write a Python program to compute the first number that has the second\
    \ digit\n    as 5, and the third digit as 7. For example, if the input is 12345,\
    \ \n    output should be 5.\n\n\n</text>\n<cell>", "    if n < m:\n        return\
    \ -1\n    \n    total = 0\n    for i in range(n):\n        total += i\n    \n\
    \    total += m\n    \n    total += n\n    \n    total = int(total)\n    \n  \
    \  binary = bin(total)\n    binary = binary.replace('b', '')\n    \n    return\
    \ binary\n</cell>\n<cell>\nassert rounded_avg(1, 5) == '0b11'\nassert rounded_avg(7,\
    \ 5) == '-1'\nassert rounded_avg(10, 20) == '0b1111'\nassert rounded_avg(20, 33)\
    \ == '0b11010'\nassert rounded_avg(1, 33) == '-1'\n</cell>\n<text>\nProblem 3\n\
    We are given a list of numbers, and we must add up all the numbers and then find\
    \ the average. \nThen print your sum and average.\nExample: \n>>> [4,5,6,8,9,10,12]\n\
    >>> sum([4,5,6,8,9,10,12]) == 40\n>>> round(sum([4,5,6,8,9,10,12])) == 39\n>>>\
    \ round(sum([4,5,6,8,9,10,12]) / len([4,5,6,8,9,10,12])) == 39.5\n>>> \n[4, 6,\
    \ 8, 10, 12, 15, 18, 21]\n>>> sum([4, 6, 8, 10, 12, 15, 18, 21]) == 40\n>>> round(sum([4,\
    \ 6, 8, 10, 12, 15, 18, 21])) ==39\n>>> round(sum([4, 6, 8, 10, 12, 15, 18, 21])\
    \ / len([4, 6, 8, 10, 12, 15, 18, 21])) ==39.5\n\n</text>\n<cell>", "    if n\
    \ <= m:\n        return -1\n    else:\n        \n        # n = m\n        # n\
    \ = m + 2\n        # n = m + 3\n        # ...\n        # n = m\n        # n =\
    \ m - 1 \n        # ...\n        # n = 1\n        # n = 0\n        # n = -1\n\
    \        \n        # n = m + n\n        # n = m + n - 1\n        # ...\n     \
    \   # n = m + n\n        # ...\n        # n = (m+n)/2\n        \n        # n =\
    \ m\n        # n = m + 2\n        # n = m + 3\n        # ...\n        # n = m\n\
    \        # n = m - 1 \n        # ...\n        # n = (m/2)\n        \n        #\
    \ n = m\n        # n = m + 2\n        # n = m + 3\n        # ...\n        # n\
    \ = m\n        # n = m - 1 \n        # ...\n        # n = (m/2)\n        \n  \
    \      \n        # n = m\n        # n = m + 2\n        # n = m + 3\n        #\
    \ ...\n        # n = m\n        # n = m - 1 \n        # ...\n        # n = (m/2)\n\
    \        \n        # n = m\n        # n = m + 2\n        # n = m + 3\n       \
    \ # ...\n        # n = m\n        # n = m - 1 \n        # ...\n        # n = (m/2)\n\
    \        \n        n = m\n        n = m + 2\n        n = m + 3\n        n = m\
    \ + 4\n        n = m + 5\n        n = m + 6\n        n = m + 7\n        n = m\
    \ + 8\n        n = m + 9\n        n = m + 10\n        n = m + 11\n        n =\
    \ m + 12\n        n = m + 13\n        n = m + 14\n        n = m + 15\n       \
    \ n = m + 16\n        n = m + 17\n        n = m + 18\n        n = m + 19\n   \
    \     n = m + 20\n        n = m + 21\n        n = m + 22\n        n = m + 23\n\
    \        n = m + 24\n        n = m + 25\n        n = m + 26\n        n = m + 27\n\
    \        n = m + 28\n        n = m + 29\n        n = m + 30\n        n = m + 31\n\
    \        n = m + 32\n        n = m + 33\n        n = m + 34\n        n = m + 35\n\
    \        n = m + 36\n        n = m + 37\n        n = m + 38\n        n = m + 39\n\
    \        n = m + 40\n        n = m + 41\n        n = m + 42\n        n = m + 43\n\
    \        n = m + 44\n        n = m + 45\n        n = m + 46\n        n = m + 47\n\
    \        n = m + 48\n        n = m + 49\n        n = m + 50\n        n = m + 51\n\
    \        n = m + 52\n        n = m + 53\n        n = m + 54\n        n = m + 55\n\
    \        n = m + 56\n        n = m + 57\n        n = m + 58\n        n = m + 59\n\
    \        n = m + 60\n        n = m + 61\n        n = m + 62\n        n = m + 63\n\
    \        n = m + 64\n        n = m + 65\n        n = m + 66\n        n = m + 67\n\
    \        n = m + 68\n        n = m + 69\n", "    \n    if n > m:\n        return\
    \ -1\n    if n == m:\n        return f'0b{n}'\n    return f'{int(n+(n-1))//2}'\n\
    \n", "    if n < m:\n        return -1\n    if n == m:\n        return f'{n}'\n\
    \    return f'{bin(n)[2:]:0{len(bin(m)[2:])}b}'\n</cell>\n<cell>\nrounded_avg(1,\
    \ 5)\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n\
    </cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nProblem 3\nUsing the function\
    \ rounded_avg above, write a function that returns the smallest number that is\
    \ evenly divisible by all the numbers from 1 to n. (We will call this number X).\n\
    Example:\nn = 5\n>>> min([x for x in itertools.count(1, 2)])\n4\nn = 20\n>>> min([x\
    \ for x in itertools.count(1, 2)])\n21\n\n\n</text>\n<cell>", "    if not n >=\
    \ m:\n        return \"-1\"\n    else:\n        return \"0b\" + bin(n + (m - n)\
    \ // 2).replace(\"0b\" * n, '')\n\n", "    if n <= m:\n        return n\n    elif\
    \ n == m:\n        return '0b0'\n    else:\n        mid = (n + m) // 2\n     \
    \   ans = str((int(mid) - n) // m * m) + str(int(mid) - n % m)\n        return\
    \ ans\n\n", "    if n >= m:\n        return -1\n    else:\n        avg = n + (m\
    \ // 2)\n        binary = bin(avg).replace('0b', '')\n        return f'0b{binary}'\n\
    \n", "    if n < m:\n        return -1\n    return bin(sum((n-m+1) * i for i in\
    \ range(int(m)))).split(\"0b\")[1][:-1]\n</cell>\n<cell>", "    if n > m:\n  \
    \      return -1\n    \n    s = str(n)\n    e = str(m)\n    \n    l = (len(s)\
    \ - len(e)) // 2\n    \n    return str(bin(int('0b' + s[:l], 2) + int(e, 2)))[-(l\
    \ // 2):]\n</cell>\n<cell>", "    \n    if m > n:\n        return '-1'\n     \
    \   \n    total = 0\n    i = 0\n    while i <= m:\n        total += i\n      \
    \  i += 1\n        \n    return bin(total)[2:].zfill(n)\n\n\nprint(rounded_avg(7,5))\
    \ # --> 0b111\nprint(rounded_avg(20,33)) # --> 0b11010\nprint(rounded_avg(100,200))\
    \ # --> -1\n</cell>\n<cell>\nfrom typing import Union\n", "    \n    if n == m:\n\
    \        return '0b0'\n    \n    if n > m:\n        return -1\n    \n    avg_str\
    \ = '0b' + str(bin(n+1)[2:].rjust(8, '0'))\n    \n    avg_str += str(bin(m+1)[2:].rjust(8,\
    \ '0'))\n    \n    return avg_str\n\n", "    return bin(int((n + m) / 2)) # The\
    \ + / 2 is necessary since Python's int function\n                           \
    \     # always truncates; the / 2 below is only \n                           \
    \     # necessary when rounding down.\n", "    if n >= m:\n        return -1\n\
    \n    return bin(n + (m - n) // 2)[3:]\n", "    # Your code here\n    return -1\n\
    \n</cell>\n<cell>", "    if n > m:\n        return -1\n    total = 0\n    while\
    \ n <= m:\n        total += n\n        n += 1\n    total = total - n # remember\
    \ last value\n    return bin(total)[2:].zfill(8)\n", "    if n <= m:\n       \
    \ return str(n)\n    \n    if n > m:\n        return -1\n\n    sum = 0\n    for\
    \ i in range(n, m):\n        sum += i\n    \n    return str(sum).zfill(m)\n",
  "    total = 0\n    i = 0\n    while i < n and i < m:\n        total += i\n    \
    \    i += 1\n    avg_binary = format(total, f'b{len(str(total))}')\n    if avg_binary\
    \ == '0b0':\n        return -1\n    else:\n        return avg_binary\n", "   \
    \ if n > m:\n        return -1\n    return (n // m) * m\n\n", "    if n < m:\n\
    \        return -1\n    elif n == m:\n        return str(n)\n    else:\n     \
    \   avg = (n - m) // 2\n        binary = []\n        while n <= m:\n         \
    \   binary.append(bin(n))\n            n += 1\n        binary.reverse()\n    \
    \    binary.append(f'{avg:b}')\n        return ''.join(binary)\n", "    assert\
    \ n <= m, \"n must be less than m\"\n    if n >= m:\n        return -1\n    else:\n\
    \        avg_n = int(n//m) #integer division\n        sum = 0\n        while n\
    \ >= m:\n            sum += avg_n\n            n -= m\n            avg_n+=1\n\
    \        return f'{sum:b}'\n    ", "    \n    if n >= m:\n        return -1\n\
    \    \n    binary = ''\n    \n    while n <= m:\n        binary += f'1{n & m}'\n\
    \        n += 1\n        m -= 1\n        \n    return int(binary, 2)\n\n", " \
    \   if m >= n:\n        return \"-1\"\n    \n    binary = bin(n//m).lstrip(\"\
    0b\")\n    \n    if m >= n:\n        binary = bin(n//m).lstrip(\"0b\")\n     \
    \   binary = binary[0] + \"1\" + binary[1:]\n        return binary\n    \n   \
    \ if len(binary) > 5:\n        return \"-1\"\n    \n    return binary\n    ",
  "    if n < m:\n        return -1\n    else:\n        nbin = bin(n)[2:]\n      \
    \  mbin = bin(m)[2:]\n        if len(nbin) == len(mbin):\n            return ''.join((nbin[:mbin.index('m')],\
    \ 'm', mbin))\n        else:\n            return '0b' + ''.join(\n           \
    \     (nbin[:m], '0', mbin[:n], nbin[m:])\n            )\n    ", "    numbers\
    \ = []\n    i = n\n    count = 0\n    while i <= m:\n        numbers.append(i)\n\
    \        count += 1\n        if i == m:\n            i += 1\n    \n    avg = sum(numbers)\
    \ / count\n\n    if avg >= 0.5:\n        return -1\n    \n    binary_string =\
    \ \"\"\n    for n in numbers:\n        binary_string += bin(n).replace(\"0b\"\
    , \"\")\n    return binary_string\n", "    if n > m:\n        return -1\n    digits_between\
    \ = n - m\n    if digits_between < 0: \n        return -1\n    ans = 0\n    while\
    \ n <= m:\n        ans += n & 1\n        n >>= 1\n    return bin(ans)[2:].zfill(digits_between)\n",
  "    if n>m:\n        return \"-1\"\n    else:\n        val = n\n        while val<=m:\n\
    \            val+=1\n        print(bin(val))\n        return \"0b\"+bin(val).replace('b','')\
    \ \n        \n", "    avg = n / m\n    if n < m:\n        return -1\n    return\
    \ str(int(round(avg * 2))).lstrip('0b') + '0'\n", "    # Your code here\n    if\
    \ n < m:\n        return -1\n    else:\n        return bin(int(f'{n}{m}'))[2:]\n",
  "    \n    if n <= m:\n        return bin(n).replace('0b', '')\n    \n    midpoint\
    \ = (n + m) // 2\n    \n    if midpoint <= n:\n        return bin(midpoint).replace('0b',\
    \ '')\n    \n    midpoint = (n + m) // 2\n    \n    if midpoint >= m:\n      \
    \  return -1\n    \n    avg = (midpoint + n - midpoint) // 2\n    \n    return\
    \ bin(avg).replace('0b', '')\n\n", "    if n >= m:\n        return \"-1\"\n\n\
    \    ans = \"\"\n    for i in range(n, m+1):\n        ans += f\"{i}\"\n\n    ans\
    \ = str(int(ans)+1)\n\n    ans = \"0\"*(len(ans)-2) + ans\n\n    return ans\n\
    </cell>\n<cell>", "    if n >= m:\n        return -1\n    \n    binary = ''\n\
    \    while n <= m:\n        binary = f'{n % 2 + 1}{binary}'\n        n = n //\
    \ 2\n    \n    binary = binary.rstrip('0')\n    binary = f'{len(binary)}{binary}'\n\
    \    return f'{int(binary, 2)}'\n\n", "    if m > n:\n        return -1\n    a\
    \ = n // m\n    b = n % m\n    rounded_n = a * 10 + b\n    binary_n = bin(rounded_n)\n\
    \    binary_n = binary_n.replace('0b', '')\n    return binary_n\n", "    return\
    \ bin(int((n+m+1)/2))[2:]\n</code>\n<|/ a tags=python dscore=3 |>\n<| a dscore=3\
    \ tags=python |>\n<code>", "    \n    #assert m >= 0 and n >= m, \"The interval\
    \ must be non-negative and non-zero\"\n    \n    if n == m:\n        return f\"\
    0b{n}\"\n    if n >= m:\n        return -1\n    return f\"0b{int(n+0.5):b}\"\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
