name: HumanEval_120_maximum
language: py
prompt: "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n\
  \    \"\"\"\n    Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n\n    Example 2:\n\n \
  \   >>> maximum([4, -4, 4], 2)\n    [4, 4]\n\n    Example 3:\n\n    >>> maximum([-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n    [2]\n\n    Note:\n        1. The length of the array\
  \ will be in the range of [1, 1000].\n        2. The elements in the array will\
  \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n\
  \    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1,\
  \ 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0, 1, 2, -3], 3)\
  \ == [2, 20, 123]\n    assert candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3,\
  \ 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1,\
  \ 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert\
  \ candidate([-10, 10], 2) == [-10, 10]\n    assert candidate([1, 2, 3, -23, 243,\
  \ -400, 0], 0) == []\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n"
completions: ["    assert 1 <= k <= len(arr), 'invalid input'\n    max_length = max([len(arr),\
    \ k])\n    result = []\n    if max_length <= len(arr):\n        result = arr[:max_length]\n\
    \    else:\n        max_idx = -1\n        for idx in range(max_length):\n    \
    \        idx = idx % (len(arr))\n            if idx < k or (idx == k and arr[idx]\
    \ > arr[max_idx]):\n                arr[idx], arr[max_idx] = arr[max_idx], arr[idx]\n\
    \                max_idx = idx\n        result = [arr[k]]\n    return result\n\
    </cell>\n<cell>", "    pass\n", "    # code here\n    maximum_list = list()\n\
    \    maximum = 0\n    for x in arr:\n        if x > maximum:\n            maximum\
    \ = x\n        if k == maximum:\n            maximum_list.append(x)\n    return\
    \ maximum_list\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\n\
    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n</cell>\n<cell>\nfrom typing import\
    \ List\n", "    \n    left = 0\n    right = len(arr)-1\n    \n    while left<right:\n\
    \        \n        mid = (left+right)//2\n        \n        if mid<=len(arr) and\
    \ arr[mid]>=arr[mid+1]:\n            right = mid-1\n        else:\n          \
    \  left = mid+1\n    \n    return [arr[i] for i in range(left+1, right+1)]\n</cell>\n\
    <cell>", "    n = len(arr)\n    if not (0 <= k <= n):\n        raise Exception('k\
    \ is out of range!')\n    if not (arr[0] >= 0 and arr[-1] >= 0):\n        raise\
    \ Exception('the elements in arr must be positive!')\n    if not (1 <= k <= n):\n\
    \        raise Exception('k is out of range!')\n    maximum = [0 for i in range(k)]\n\
    \    max_index = 0\n    k = k + n - 1\n    while k >= 0:\n        for i in range(k):\n\
    \            if arr[i] > arr[i + k]:\n                maximum[i] = arr[i]\n  \
    \              max_index = i\n                break\n        k -= 1\n    maximum[max_index]\
    \ = arr[-1]\n    return maximum\n\n", "    \n    def f(A: List[int], k: int) ->\
    \ List[int]:\n        if k == 1:\n            return A\n        elif k > len(A):\n\
    \            return [A[-1]]\n        else:\n            lvl2Max = A[-1]\n    \
    \        res = [A[-1]]\n            for idx in range(len(A)-2, k-1, -1):\n   \
    \             lvl2Max = max(A[idx+k], lvl2Max)\n                res.append(lvl2Max)\n\
    \            return res\n\n    return f(arr, k)\n</cell>\n<cell>", "    return\
    \ arr[:k]\n", "    return sorted(arr, key=functools.cmp_to_key(lambda x, y: cmp(y+x,\
    \ y-x)))[-k:]\n", "    # write your code here\n    return sorted(arr)[-k:]\n",
  "    return sorted(arr, reverse=True)[:k]\n\n", "    arr = sorted(arr)\n    if len(arr)\
    \ >= k:\n        return arr[k:]\n    else:\n        return arr[:k]\n\n", "   \
    \ if not arr:\n        return []\n\n    if not k or len(arr) <= k:\n        return\
    \ arr\n\n    arr.sort()\n    arr.reverse()\n\n    return arr[:k]\n", "    import\
    \ copy\n    arr_copy = copy.deepcopy(arr)\n\n    arr_copy.sort()\n\n    if k >\
    \ len(arr_copy):\n        return arr_copy\n\n    arr = arr_copy[:k]\n\n    return\
    \ arr\n\n", "    pass\n", "    # write your code here\n    largest = max(arr)\n\
    \    ans = [i for i in arr if i <= largest]\n    \n    return ans\n\n", "    def\
    \ recur(arr: List[int], i: int, max_k: int) -> List[int]:\n        if i == len(arr):\n\
    \            return arr\n        if max_k == 0:\n            max_k = i\n     \
    \   elif max_k == i:\n            max_k = max_k\n        \n        if arr[i] >\
    \ arr[max_k]:\n            max_k = i\n        \n        res = []\n        for\
    \ j in range(i, len(arr)):\n            res.append(arr[j])\n            res.append(arr[i])\n\
    \        \n        return res\n\n    arr = np.array(arr)\n    max_k = k\n    return\
    \ recur(arr.tolist(), 0, max_k)\n</code>\n<|/ a tags=python,sorting dscore=0 |>\n\
    <| c |>\n`arr.tolist()` already returns a copy, so it's redundant to do that again\
    \ in the recursive function.\n<|/ c |>\n<| a dscore=0 |>\nWe can use heapq to\
    \ get the maximum element in a list by sorting it\n<code>\n>>> import heapq\n\
    >>> heapq.nlargest(5, [-3, -4, 5])\n[-4, -3, 5]\n</code>\n<|/ a tags=python,sorting\
    \ |>\n<| c |>\nWhile this may answer the question, it is better to provide some\
    \ explanation of how your code will help to solve the problem.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "    \n    pass\n\n", "    if len(arr) < 1:\n        return\
    \ []\n    if k >= len(arr):\n        return arr\n    if k == 0:\n        return\
    \ [arr[0]]\n    left = arr[:k]\n    right = arr[k:]\n    return maximum(left,\
    \ k - 1) + maximum(right, k - 1) + arr[:k]\n\n", "    # your code goes here\n\
    \    maximum_list = []\n    sorted_list = sorted(arr)\n    if len(sorted_list)\
    \ > k:\n        maximum_list = sorted_list[-k:]\n    else:\n        maximum_list\
    \ = sorted_list\n    return maximum_list\n\n", "    \n    # Write your code here.\n\
    \    maximumList = arr[:]\n    maxLength = k\n    for i in range(k):\n       \
    \ if maxLength > len(maximumList):\n            break\n        minimum = maximumList.pop()\n\
    \        maximumList.append(minimum)\n        maxLength = maxLength - 1\n    return\
    \ maximumList\n    ", "    arr_max = arr[:k]\n    max_idx = 0\n    \n    # Sort\
    \ the array in descending order\n    arr_max.sort()\n    \n    # Find the index\
    \ of the largest k numbers in the sorted array\n    for idx, num in enumerate(arr_max):\n\
    \        if idx > max_idx:\n            max_idx = idx\n    \n    # Return the\
    \ largest k numbers in sorted array\n    return arr_max[:k]\n</code>\n<|/ a tags=python,python-3.x\
    \ dscore=0 |>\n<| a tags=python,python-3.x dscore=0 |>\n<code>", "    return arr[-k:]\
    \ + arr[:-k]\n", "    answer: List[int] = list()\n    if len(arr) < 1:\n     \
    \   return answer\n    for i in range(0, len(arr) - k + 1, k):\n        answer.append(max(arr[i:i\
    \ + k]))\n    return answer\n", "    return sorted(arr, reverse=True)[:k]\n</cell>\n\
    <cell>", "    \n    if k > len(arr):\n        return arr\n    else:\n        maximum,\
    \ arr[0], arr[-1] = 0, arr[0], arr[-1]\n        \n        for i in range(1, len(arr)):\n\
    \            if arr[i] > maximum:\n                maximum, arr[0], arr[-1] =\
    \ arr[i], arr[0], arr[-1]\n            \n        return arr[:k+1]\n</cell>\n<text>\n\
    Solution 3\nUsing Dynamic Programming\n\n\n</text>\n<cell>", "    pass\n", " \
    \   # write your code here\n    # write your code here\n    if not arr:\n    \
    \    return arr\n    \n    max_value = arr[0]\n    max_index = 0\n    \n    for\
    \ i in range(1, len(arr)):\n        if arr[i] > max_value:\n            max_value\
    \ = arr[i]\n            max_index = i\n    \n    return arr[0 : max_index + 1]\n\
    \n", "    # Your code here\n    maximum_list = []\n    maximum = arr[0]\n    for\
    \ x in arr:\n        if x > maximum:\n            maximum = x\n            maximum_list.append(maximum)\n\
    \        else:\n            if k - 1 > maximum_list:\n                maximum_list.append(maximum)\n\
    \            else:\n                maximum_list.append(x)\n                \n\
    \    return maximum_list\n\n", "    from functools import reduce\n    if len(arr)\
    \ < k or k <= 0 or not isinstance(k, int):\n        raise IndexError('k is out\
    \ of bound')\n    elif k == 1:\n        return arr\n    elif k > 1:\n        return\
    \ reduce(lambda x, y: x if x > y else y, arr)[:k]\n    else:\n        raise IndexError('k\
    \ is out of bound')\n", "    pass\n", "    if k > len(arr):\n        return None\n\
    \    else:\n        return arr[-k:]\n", "    max_i = 0\n    max_num = arr[0]\n\
    \n    for num in arr[1:]:\n        if num > max_num:\n            max_i = len(arr)\
    \ - 2\n            max_num = num\n\n        elif num == max_num:\n           \
    \ max_i += 1\n\n    return arr[:max_i]\n", "    max_length = 1\n    # Find the\
    \ maximum number in the array\n    for i in arr:\n        if max_length < i:\n\
    \            max_length = i\n    \n    # Sort the array based on the maximum number\n\
    \    max_length_arr = [max_length]\n    arr_sorted = sorted(arr)\n\n    # Copy\
    \ the maximum number\n    max_length_arr.extend(arr_sorted)\n\n    # Return the\
    \ sorted array\n    return max_length_arr\n", "    if k >= len(arr):\n       \
    \ return arr\n    \n    # \u6700\u5927\u7684\u524D\u534A\u90E8\u5206\uFF0C\u6700\
    \u5927\u7684\u540E\u534A\u90E8\u5206\n    begin, end = 0, len(arr)-k-1\n\n   \
    \ # \u5904\u7406\u6700\u540E\u534A\u90E8\u5206\u7684\u60C5\u51B5\n    if arr[k]\
    \ < arr[end]:\n        arr[k], arr[end] = arr[end], arr[k]\n        end -= 1\n\
    \n    # \u91CD\u590D\u5904\u7406\u6700\u540E\u534A\u90E8\u5206\u7684\u60C5\u51B5\
    \n    \n    # \u5904\u7406\u6700\u540E\u4E00\u4E2A\u5143\u7D20\n    if arr[k]\
    \ < arr[end]:\n        arr[k], arr[end] = arr[end], arr[k]\n        end -= 1\n\
    \n        # \u5904\u7406\u6700\u540E\u4E00\u4E2A\u5143\u7D20\u7684\u60C5\u51B5\
    \n    if arr[k] < arr[end]:\n        arr[k], arr[end] = arr[end], arr[k]\n   \
    \     end -= 1\n\n    return arr[begin:end]\n\n", "    # write your code here\n\
    \    largest = None\n    length = len(arr)\n    for i in range(length):\n    \
    \    if largest == None or arr[i] > largest:\n            largest = arr[i]\n \
    \       \n    for i in range(k):\n        temp = largest\n        largest = arr.pop(i)\n\
    \        arr.append(temp)\n    return arr\n</cell>\n<text>\nQuestion 9\n\n</text>\n\
    <cell>", "    # write your code here\n    if len(arr) > k:\n        return arr[k:]\n\
    \    return arr[:k]\n\n", "    import bisect\n    \n    def maxIndex(l, val):\n\
    \        for i in range(len(l)-1, -1, -1):\n            if l[i]>val:\n       \
    \         return i\n    \n    maxIndex = 0\n    \n    # sort and get max index\n\
    \    arr.sort()\n    maxIndex = bisect.bisect_left(arr, k)\n    \n    # return\
    \ the max k list\n    return arr[:maxIndex]\n", "    # Your code here\n    return\
    \ sorted(arr, key = lambda val: -val)[:k]\n", "    # Your code here\n    if len(arr)\
    \ < 1:\n        return -1\n    if k > len(arr):\n        return -1\n    left =\
    \ arr[0]\n    right = arr[-1]\n    k = k - 1\n    ans = []\n    while k > 0:\n\
    \        if left >= right:\n            ans.append(left)\n            left = arr[0]\n\
    \            right = arr[-1]\n            k = k - 1\n        elif right - left\
    \ > 1:\n            mid = (left + right) // 2\n            if arr[mid] == left:\n\
    \                left = arr[mid]\n            elif arr[mid] == right:\n      \
    \          right = arr[mid]\n            else:\n                left = arr[mid]\n\
    \                right = arr[mid]\n                k = k - 1\n            else:\n\
    \                left = arr[mid]\n                right = arr[mid]\n         \
    \       k = k - 1\n        else:\n            ans.append(right)\n            left\
    \ = arr[0]\n            right = arr[-1]\n            k = k - 1\n    return ans\n",
  "    # write your code here\n    return sorted(arr)[-k:]\n", "    # write your code\
    \ here\n    heapq.heapify(arr)\n    heapq.heappush(arr, arr[-1])\n    arr.append(arr[-1])\n\
    \    arr.sort()\n    \n    heapq.heappop(arr)\n    if len(arr) < k:\n        return\
    \ arr\n    if k == 0: return arr\n    \n    res = []\n    while k != 0:\n    \
    \    res.append(heapq.heappop(arr))\n        k -= 1\n    return res\n</cell>\n\
    <cell>", "    return arr[:k]\n", "    max_list = []\n    max_length = len(arr)\n\
    \    if max_length <= 0:\n        return max_list\n\n    for i in range(1, max_length):\n\
    \        if arr[i-1] < arr[i]:\n            if k > i:\n                max_list\
    \ = max_list + arr[:i]\n                return max_list\n\n            if k ==\
    \ i:\n                max_list.append(arr[i])\n                return max_list\n\
    \    return max_list\n", "    # \u4F7F\u7528\u6392\u5E8F\u7B97\u6CD5\u6765\u5F97\
    \u5230\u6700\u5927\u7684k\u4E2A\u6570\n    n = len(arr)\n    for i in range(n\
    \ - k):\n        max_num = arr[i]\n        for j in range(i + 1, n):\n       \
    \     if arr[j] > max_num:\n                max_num = arr[j]\n        arr[i],\
    \ arr[j] = arr[j], arr[i]\n    return arr\n</cell>\n<cell>", "    pass\n</cell>\n\
    <cell>", "    # write your code here\n    res=[]\n    heap=[]\n    largest,largestIndex=0,-1\n\
    \    for i in range(len(arr)):\n        if i==0 or arr[i-1]>arr[i]:\n        \
    \    heapq.heappush(heap,arr[i])\n            if i==k or arr[i-1]>largest:\n \
    \               largest=arr[i]\n                largestIndex=i\n        elif i==k\
    \ or arr[i-1]>largest:\n            heapq.heappop(heap)\n            heapq.heappush(heap,arr[i])\n\
    \        elif arr[i-1]<largest:\n            heapq.heappop(heap)\n           \
    \ heapq.heappush(heap,arr[i])\n            largest,largestIndex=0,0\n        \
    \    res=[heapq.heappop(heap) for _ in range(k)]\n            heapq.heappush(heap,arr[i])\n\
    \    return res\n", "    pass\n\n", "    max_arr = []\n    for i in range(len(arr)):\n\
    \        if k >= len(max_arr):\n            max_arr.append(arr[i])\n        elif\
    \ arr[i] > max_arr[k]:\n            max_arr.append(arr[i])\n    return max_arr\n\
    </cell>\n<cell>\nmaximum([1,3,2,4,5,6,7], 1)\n</cell>\n<cell>", "    pass\n",
  "    if k > len(arr):\n        return arr\n    if k == 0:\n        return [arr[0]]\n\
    \n    # Initialize stack to contain largest k elements seen so far\n    stack\
    \ = list()\n    # Initialize a variable to contain largest number seen so far\n\
    \    largest = -1000\n\n    # Iterate over all elements in the array\n    for\
    \ ele in arr:\n        # If the number is greater than current largest,\n    \
    \    # then add it to stack and update largest value\n        if ele > largest:\n\
    \            stack.append(ele)\n            largest = ele\n\n        # Otherwise,\
    \ if the stack is full and largest is greater than the stack's top value,\n  \
    \      # then add largest to stack and update largest value\n        elif len(stack)\
    \ == k and largest > stack[-1]:\n            stack.append(ele)\n            largest\
    \ = ele\n\n        # Otherwise, if the stack is full and largest is less than\
    \ the stack's top value,\n        # then pop the stack and update largest value\n\
    \        elif len(stack) == k and largest < stack[-1]:\n            stack.pop()\n\
    \            largest = ele\n\n    return stack\n", "    # Write your code here.\n\
    \    maximum_list: List[int] = []\n    for ele in arr:\n        if ele > max(maximum_list):\n\
    \            maximum_list = maximum_list+[ele]\n    maximum_list.sort()\n    return\
    \ maximum_list[:k]\n", "    if k == 0: return []\n    if k == 1: return arr\n\
    \    if k < 0 or k > len(arr):\n        raise ValueError(f\"k value must be in\
    \ [0, {len(arr)})\")\n\n    # sort is stable in Python >= 3.7\n    sorted_arr\
    \ = sorted(arr)\n    return sorted_arr[k:]\n", "    if k > len(arr):\n       \
    \ return []\n\n    # Divide the array into two segments\n    left = arr[:k]\n\
    \    right = arr[k:]\n\n    # Find the maximum element in left segment\n    max_left\
    \ = max(left)\n    \n    # Find the index of the maximum element in right segment\n\
    \    index_right = [i for i, x in enumerate(right) if x == max_left]\n\n    #\
    \ Get the maximum element in the right segment and put it in right\n    # place\
    \ in the arr\n    max_right = right[index_right[0]]\n    right.pop(index_right[0])\n\
    \n    # Return the maximum k elements in the array\n    return left + [max_left]\
    \ + right + [max_right]\n", "    arr = sorted(arr)\n    if k > len(arr):\n   \
    \     k = len(arr)\n    return [arr[-1]]*k\n", "    # Solution using heap\n  \
    \  heapq.heapify(arr)\n    length = len(arr)\n    \n    if k > length:\n     \
    \   k = length\n    \n    if k == length:\n        return arr\n    \n    i, j\
    \ = 0, length - 1\n    max_num = arr[0]\n    \n    while j < k:\n        if max_num\
    \ > arr[j]:\n            heapq.heappop(arr)\n            max_num = arr[0]\n  \
    \          \n        arr[i], arr[j] = arr[j], arr[i]\n        i, j = j, i - 1\n\
    \    \n    max_arr = arr[:k]\n    heapq.heapify(max_arr)\n    \n    return max_arr\n",
  "    \n    arr = sorted(arr, reverse = True)\n    \n    return arr[:k]\n</cell>\n\
    <text>\nThe second function, maximum2, has two inputs: arr, which is the given\
    \ array, and k, which is the maximum length of the new sorted array.\n\nThe function\
    \ maximum2 has only one output: arr, which is a sorted array with the maximum\
    \ length k numbers in arr\n\n\n</text>\n<cell>", "    if not (0 <= k <= len(arr)):\n\
    \        raise IndexError(\"k should be in the range of [0, len(arr))\")\n   \
    \ return sorted(arr, reverse=True)[k:]\n", "    max_nums, max_nums_idx = [arr[:],\
    \ 0]\n    for num in arr:\n        if num > max_nums[k-1]:\n            max_nums_idx\
    \ += 1\n            max_nums.append(num)\n        elif num == max_nums[k-1]:\n\
    \            max_nums_idx += 1\n        else:\n            max_nums[k-1] = num\n\
    \    return max_nums[:k]\n\n", "    maximum_list = []\n    maximum = arr[0]\n\
    \    for i in range(1, len(arr)):\n        if arr[i] > maximum:\n            maximum\
    \ = arr[i]\n        maximum_list.append(maximum)\n    return maximum_list\n",
  "    maximum_list: List = list()\n    for i in range(k):\n        max_element: List\
    \ = arr[-i]\n        max_index: int = -1\n        max_element_index: int = 0\n\
    \        for j in range(len(arr)):\n            if arr[j] > max_element:\n   \
    \             max_element = arr[j]\n                max_index = j\n          \
    \      max_element_index = j\n\n        maximum_list.append(max_element)\n\n \
    \   for i in range(k):\n        arr[-i] = maximum_list[i]\n    \n    return arr\n\
    </code>\n<|/ a dscore=0 tags=sorting,python,bubble-sort |>\n<| c |>\nPlease provide\
    \ some explanation for your code.\n<|/ c |>\n<| a |>\n<code>", "    length = len(arr)\n\
    \    k_list = list(range(0, length))\n    largest = arr[0]\n    for i in range(1,\
    \ length):\n        if arr[i] > largest:\n            largest = arr[i]\n     \
    \   if arr[i] > k_list[i - 1]:\n            k_list[i - 1] = arr[i]\n    return\
    \ k_list\n</cell>\n<cell>", "    if not arr:\n        return []\n    \n    length\
    \ = 0\n    if k <= 0:\n        return [arr[0]]\n    \n    while len(arr) > length:\n\
    \        length = len(arr)\n    \n    if length <= k:\n        return arr[:k]\n\
    \    \n    max_length = 0\n    idx = -1\n    while length != k and idx != 0 and\
    \ idx != length - 1:\n        if arr[idx] > arr[idx+1]:\n            arr[idx],\
    \ arr[idx+1] = arr[idx+1], arr[idx]\n            max_length += 1\n        \n \
    \       idx -= 1\n    \n    if idx != 0 and idx != length - 1:\n        arr[idx],\
    \ arr[idx+1] = arr[idx+1], arr[idx]\n        max_length += 1\n    \n    return\
    \ arr[:k]\n</cell>\n<cell>", "    maximum = 0\n    maximum_value = None\n    maximum_index\
    \ = 0\n    arr = [x for x in arr]\n    arr.sort()\n    for index, x in enumerate(arr):\n\
    \        if x > maximum:\n            maximum = x\n            maximum_value =\
    \ arr[index]\n            maximum_index = index\n    if maximum_index >= k - 1:\n\
    \        return arr[0:k]\n    else:\n        return [maximum_value]\n", "    max_list:\
    \ List[int] = []\n    i = 0\n    while i < len(arr):\n        if i == len(arr)\
    \ - 1:\n            max_list.append(arr[i])\n            i += 1\n        elif\
    \ arr[i] > arr[i + 1]:\n            max_list.append(arr[i])\n            i +=\
    \ 1\n        else:\n            i += 1\n    return max_list\n</cell>\n<text>\n\
    Q14. Implement a function named minimum(arr, k) that takes an array arr of integers\
    \ and a positive integer k, and returns the minimum k numbers in arr.\n\nExample\
    \ 1:\n\n>>> minimum([3, -4, 5], 3)\n[-3, -4, 5]\n\nExample 2:\n\n>>> minimum([4,\
    \ -4, 4], 2)\n[4, -4]\n\nExample 3:\n\n>>> minimum([-3, 2, 1, 2, -1, -2, 1], 1)\n\
    [-2, -1, -2]\n\nNote:\n    1). The length of the array will be in the range of\
    \ [1, 1000].\n    2). The elements in the array will be in the range of [-1000,\
    \ 1000].\n    3). 0 <= k <= len(arr)\n    4. All elements in the array are different.\n\
    \    5. No two elements in the array are equal, except for -1000\n    \"\"\"\n\
    \    arr_list = arr[:k]\n    arr_list.sort()\n    return arr_list\n</cell>\n<cell>",
  "    pass\n</cell>\n<cell>", "    import math\n\n    if k > len(arr):\n        k\
    \ = len(arr)\n\n    return [arr[i] for i, v in enumerate(sorted(arr, reverse=True))\
    \ if i < k]\n", "    # Your code here\n    maximum = arr[0]\n    for i in range(1,\
    \ k):\n        if arr[i] > maximum:\n            maximum = arr[i]\n    return\
    \ maximum\n", "    pass\n", "    pass\n", "    if len(arr) < k:\n        return\
    \ arr\n    else:\n        m = max(arr)\n        return sorted(arr)[: k - m]\n\n",
  "    pass\n", "    \n    # write your code here\n    \n    return sorted(arr, key=lambda\
    \ x: x[-1] if x > 0 else 0)[-k:] \n\n", "    pass\n", "    if len(arr) == 0:\n\
    \        return []\n\n    if len(arr) == 1:\n        return [arr[0]]\n\n    if\
    \ k == 0:\n        return arr\n\n    left = 0\n    right = len(arr) - 1\n\n  \
    \  while right > left:\n        if arr[right] > arr[left]:\n            right\
    \ = right - 1\n        else:\n            left = left + 1\n\n    return arr[:left\
    \ + 1]\n\n", "    sorted_arr = sorted(arr)\n    \n    if k > len(sorted_arr):\n\
    \        return sorted_arr\n    elif k == len(sorted_arr):\n        return [sorted_arr[0]]\
    \ # k is greater than length of arr\n\n    # find max value in arr which is bigger\
    \ than k\n    maximum_value = max(sorted_arr[k:], key=lambda x:sorted_arr.index(x))\n\
    \n    # return sorted arr with maximum value at the end\n    return sorted_arr[:k]\
    \ + [maximum_value]\n", "    pass\n", "    pass\n", "    import math\n\n    #\
    \ your code goes here\n    arr.sort()\n    result = arr[0:k]\n    if k==1:\n \
    \       result.append(max(arr))\n    else:\n        for i in range(k-1, len(arr)):\n\
    \            index = math.ceil((i-1)/(k-1))\n            result.append(max(arr[index:index+1]))\n\
    \n    return result\n", "    pass\n</cell>\n<cell>", "    pass\n", "    return\
    \ arr[k:] + arr[:k]\n", "    if k > len(arr) or k < 0:\n        raise IndexError('The\
    \ index must be positive, and k must less than the length of the list.')\n   \
    \ \n    maximum_arr = arr[-k:]\n    if k == 1:\n        return maximum_arr\n \
    \   \n    minimial_arr = arr[:k]\n    return maximum_arr + [max(minimial_arr)]\n\
    \    \n</cell>\n<cell>\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)\n</cell>\n<cell>\n\
    maximum([4, -4, 4], 2)\n</cell>\n<cell>\nmaximum([4, -4, 4], 5)\n</cell>\n<cell>\n\
    maximum([-3, 2, 1, 2, -1, -2, 1], 4)\n</cell>\n<text>\n\uC644\uBCBD\uD558\uC9C0\
    \uB9CC list \uD568\uC218\uC5D0\uB294 for\uBB38\uC774 \uBC18\uBCF5\uBB38\uC744\
    \ \uD3EC\uD568\uD574\uC57C \uD55C\uB2E4.\n\n\n</text>\n<cell>", "    pass\n",
  "    maximums = []\n    for x in range(0, len(arr), k):\n        maximums.append(max(arr[x:x+k]))\n\
    \    return maximums\n", "    # Your code here\n    pass\n", "    return list(\n\
    \        filter(lambda x: x == max(arr), \n               sorted(arr, key=lambda\
    \ x: x % k))[-k:])\n", "    \n    maximum_list = []\n    \n    for i in range(0,len(arr)):\n\
    \        if k == 1:\n            maximum_list.append(arr[i])\n        elif k >\
    \ 1:\n            if arr[i] > arr[i-1]:\n                maximum_list.append(arr[i])\n\
    \            else:\n                maximum_list.append(arr[i-1])\n        else:\n\
    \            print('k must be greater than or equal than 1')\n    \n    return\
    \ maximum_list\n", "    pass\n", "    \n    result = [None]*(k+1)\n    result[0]\
    \ = arr[0]\n    for i in range(1, k):\n        result[i] = max(arr[i-1], result[i-1])\n\
    \    return result\n", "    \n    maximum_list = []\n\n    if k > len(arr):\n\
    \        return maximum_list\n\n    if k == len(arr):\n        maximum_list =\
    \ arr\n\n    else:\n        for i in range(k, len(arr)):\n            if arr[i]\
    \ > arr[i - 1]:\n                maximum_list.append(arr[i])\n\n    return maximum_list\n",
  "    if k >= len(arr):\n        return arr\n    \n    if k == 1: \n        return\
    \ arr\n\n    cur_max = arr[0]\n    cur_max_index = 0\n\n    for i in range(1,\
    \ len(arr)):\n        if arr[i] > cur_max:\n            cur_max = arr[i]\n   \
    \         cur_max_index = i\n\n    cur_max_index += 1\n\n    return arr[:cur_max_index]\
    \ + arr[k:]\n</cell>\n<cell>", "    # Your code here\n    length = len(arr)\n\
    \    arr = sorted(arr)\n    if length >= k:\n        return arr[:k]\n    elif\
    \ length < k:\n        return arr + arr[:k] \n    else:\n        return arr",
  "    pass\n", "    max_nums = []\n    # Sort array and keep max_nums up to k biggest\n\
    \    for i in range(k):\n        max_nums.append(arr[i])\n        arr = sorted(arr)\n\
    \    return max_nums\n", "    \n    # write your code here\n    \n    \n    #\
    \ arr is initialized in the range of [-1000, 1000]\n    if len(arr)<2:\n     \
    \   return arr\n    \n    max=arr[0]\n    for i in range(1,len(arr)):\n      \
    \  if arr[i]>max:\n            max=arr[i]\n    \n    \n    \n    \n    \n    return\
    \ max\n    \n    \n", "    max_heap: List[int] = []\n    heapq.heapify(max_heap)\n\
    \    k = 0\n    while k <= len(arr):\n        heapq.heappush(max_heap, -arr[k])\n\
    \        k += 1\n    # \u4ECE\u6700\u5DE6\u8FB9\u5F00\u59CB\u4EA4\u6362\n    for\
    \ i in range(len(arr) - 1, -1, -1):\n        arr[i], arr[-1 - i] = arr[-1 - i],\
    \ arr[i]\n        arr[i], arr[-1 - i] = arr[-1 - i], arr[i]\n    arr = [-v for\
    \ v in arr]\n    heapq.heapify(arr)\n    return arr\n", "    # write your code\
    \ here\n    if len(arr)<k:\n        return arr\n    if k==1:\n        return arr\n\
    \    max,index=0,0\n    for i in range(0,len(arr)-k+1):\n        if arr[index]>arr[index+1]:\n\
    \            max=arr[index+1]\n            index=index+1\n        else:\n    \
    \        max=arr[index]\n            index=index+1\n    return arr[:index]+[max]+arr[index+1:]\n",
  "    def sort(nums: List[int]) -> List[int]:\n        # Sort from large to small\n\
    \        nums.sort()\n\n        # Return the biggest number from the list\n  \
    \      return nums[:k]\n\n    return sort(arr)\n\n", "    # write your code here\n\
    \    if len(arr) < 2:\n        return arr\n    if k > len(arr):\n        return\
    \ arr\n    if k == len(arr):\n        return arr[:k]\n    maximum = []\n    maximum.append(arr[0])\n\
    \    for i in range(1,len(arr)):\n        if maximum[i-1] > arr[i]:\n        \
    \    maximum.append(arr[i])\n    return maximum\n</cell>\n<cell>", "    if not\
    \ 0 <= k <= len(arr):\n        return [-1]\n\n    def helper(nums: List[int],\
    \ k: int) -> List[int]:\n        if k == 0: return []\n        if k == 1: return\
    \ [nums[0]]\n\n        ans = helper(nums[:k - 1], k - 1)\n\n        cur_max =\
    \ ans[0]\n\n        for num in nums[k - 1:]:\n            if num > cur_max: cur_max\
    \ = num\n            ans.append(num)\n\n        return ans\n\n    return helper(arr,\
    \ k)\n", "    # Your code here\n    pass\n\n", "    pass\n", "    if not k <=\
    \ len(arr):\n        return []\n\n    left = [0] * k\n    right = [0] * k\n\n\
    \    for i in range(k):\n        left[i] = max(arr[i], left[i-1])\n        right[i]\
    \ = min(arr[i], right[i+1])\n\n    if left[k-1] < right[k-1]:\n        return\
    \ maximum([x for x in arr[:k-1]] + arr[k:], k-1)\n    return maximum([x for x\
    \ in arr[:k]] + arr[k:], k)\n", "    arr = sorted(arr)\n    if len(arr) <= k:\n\
    \        return arr\n    else:\n        return arr[0:k+1]\n\n", "    # \u65B9\u6CD5\
    \u4E00\uFF1A\u5206\u6CBB\n    def merge(lefts: List[int], rights: List[int], k:\
    \ int) -> List[int]:\n        arr = []\n        i = 0\n        while i < k:\n\
    \            arr.append(lefts[i])\n            i += 1\n        while i < len(rights):\n\
    \            arr.append(rights[i])\n            i += 1\n        return arr\n \
    \   \n    # \u65B9\u6CD5\u4E8C\uFF1A\u53CC\u6307\u9488\n    def merge2(lefts:\
    \ List[int], rights: List[int], k: int) -> List[int]:\n        res = []\n    \
    \    i = k - 1\n        while i >= 0:\n            if lefts[i] > rights[i]:\n\
    \                res.append(lefts[i])\n                i -= 1\n            else:\n\
    \                res.append(rights[i])\n                i -= 1\n        return\
    \ res\n\n    if len(arr) <= k:\n        return arr\n    \n    if len(arr) == 1:\n\
    \        return arr\n    \n    if len(arr) == 2:\n        if arr[0] > arr[1]:\n\
    \            return arr\n        \n        if arr[0] < arr[1]:\n            return\
    \ arr\n    \n    k = k - 1 if k <= len(arr) else len(arr)\n    \n    # \u65B9\u6CD5\
    \u4E00\n    if k == 1:\n        \n        if arr[0] > arr[1]:\n            return\
    \ arr\n        \n        if arr[0] < arr[1]:\n            return arr\n    \n \
    \   # \u65B9\u6CD5\u4E8C\n    if k == 2:\n        \n        if arr[0] > arr[1]:\n\
    \            return arr\n        \n        if arr[0] < arr[1]:\n            return\
    \ arr\n        \n        if arr[1] > arr[0]:\n            return arr\n       \
    \ \n    if k == 3:\n        \n        if arr[0] > arr[1]:\n            return\
    \ arr\n        \n        if arr[0] < arr[1]:\n            return arr\n       \
    \ \n        if arr[1] > arr[0]:\n            return arr\n        \n        if\
    \ arr[2] > arr[1]:\n            return arr\n        \n    # \u65B9\u6CD5\u4E09\
    \n    if k == 4:\n        \n        if arr[0] > arr[1]:\n            return arr\n\
    \        \n        if arr[0] < arr[1]:\n            return arr\n        \n   \
    \     if arr[1] > arr[0]:\n            return arr\n        \n        if arr[2]\
    \ > arr[1]:\n            return arr\n        \n        if arr[3] > arr[0]:\n \
    \           return arr\n    \n    if k == 5:\n        \n        if arr[0] > arr[1]:\n\
    \            return arr\n        \n        if arr[0] < arr[1]:\n            return\
    \ arr\n        \n        if arr[1] > arr[0]:\n            return arr\n       \
    \ \n        if arr[2] > arr[1]:\n            return arr\n        \n        if\
    \ arr[3] > arr[0]:\n            return arr\n        \n        if arr[4] > arr[0]:\n\
    \            return arr\n    \n    # \u65B9\u6CD5\u56DB\n    if k == 6:\n    \
    \    \n        if arr[0] > arr[1]:\n            return arr\n        \n       \
    \ if arr[0] < arr[1]:\n            return arr\n        \n        if arr[1] > ",
  "    if len(arr) == 0:\n        return arr\n\n    if k > len(arr):\n        return\
    \ arr\n\n    if k == 0:\n        return arr\n    if k == 1:\n        return arr[0]\n\
    \    \n    left = []\n    right = []\n    \n    # sort arr in left\n    count\
    \ = 0\n    length = len(arr)\n    while count < len(arr) and count < k:\n    \
    \    if arr[count] > arr[count + 1]:\n            right.append(arr[count])\n \
    \           count +=1\n        else:\n            left.append(arr[count])\n  \
    \      count +=1\n    \n    # sort arr in right\n    count = 0\n    length = len(arr)\n\
    \    while count < len(arr) and count < k:\n        if arr[count] > arr[count\
    \ - 1]:\n            right.append(arr[count])\n            count +=1\n       \
    \ else:\n            left.append(arr[count])\n        count +=1\n\n    # merge\
    \ 2 sorted arrays\n    i = 0\n    j = 0\n    maxCount = 0\n    while i < len(left)\
    \ and j < len(right):\n        if left[i] < right[j]:\n            arr.append(left[i])\n\
    \            i += 1\n        else:\n            arr.append(right[j])\n       \
    \     j += 1\n        maxCount +=1\n    \n    # merge more if needed\n    if len(left)\
    \ > len(right):\n        while len(left) > len(right):\n            arr.append(left[0])\n\
    \            i +=1\n        while len(right) > len(left):\n            arr.append(right[0])\n\
    \            j +=1\n    else:\n        while len(left) < len(right):\n       \
    \     arr.append(right[0])\n            j +=1\n        while len(right) < len(left):\n\
    \            arr.append(left[0])\n            i +=1\n\n    # shrink array to max\
    \ length k\n    count = 0\n    while count < len(arr):\n        if arr[count]\
    \ > arr[len(arr) - 1]:\n            arr.pop()\n        else:\n            arr.pop()\n\
    \            \n        count +=1\n        \n    return arr\n</cell>\n<cell>\n\
    arr = [3, -4, 5]\nk = 3\nmaximum(arr, k)\n</cell>\n<text>\n\uBB38\uC81C 4.6. \uACF5\
    \uBC30\uC218\n\n</text>\n<text>\n\uBB38\uC81C 4.6.1. \uC601\uC5B4 \uD558\uB098\
    \uC758 \uBB38\uC790\uC5F4\uC774 \uC544\uB2CC \uC218\uC2DD\uC744 \uB9CC\uB4E4\uACE0\
    , \uC5B4\uB5A4 \uAC12\uC774 \uC18C\uC218 \uAC10\uC18C\uD560 \uC218 \uC788\uB294\
    \uC9C0 \uD655\uC778\uD558\uB294 \uD568\uC218 \uAD6C\uD604\n\n\n</text>\n<cell>",
  "    n = len(arr)\n    maximum = arr[0]\n    if k <= 0: return [maximum]\n\n   \
    \ if k > n:\n        k %= n\n\n    maximums = []\n    for _ in range(k):\n   \
    \     maximums.append(maximum)\n    \n    for i in range(0, n):\n        maximum\
    \ = max(maximum, arr[i])\n        maximums.append(maximum)\n    return maximums\n",
  "    max_elements = []\n    max_k = -1\n    \n    for num in arr:\n        if k\
    \ == max_k:\n            max_elements.append(num)\n        else:\n           \
    \ if len(max_elements) < k:\n                max_elements.append(num)\n      \
    \      elif num > max_elements[-1]:\n                max_elements[-1] = num\n\
    \                max_k = k\n\n    return max_elements\n", "    if not arr or len(arr)\
    \ <= k:\n        return []\n\n    if len(arr) < k:\n        return arr\n\n   \
    \ pivot = arr[len(arr) // 2]\n\n    left, right = [arr[0]] + arr[:len(arr) //\
    \ 2], arr[len(arr) // 2:]\n\n    left, right = [ele for ele in left if ele <=\
    \ pivot], [ele for ele in right if ele >= pivot]\n\n    left, right = maximum.maximum_insertion(left,\
    \ pivot, k), maximum.maximum_insertion(right, pivot, k)\n\n    return left + right\n\
    \n\nmaximum.maximum_insertion.__doc__ = \"\"\"\n    Insert the given number into\
    \ the given list after k numbers are found. If the\n    number is already in the\
    \ list, do not insert it.\n\n    Example 1:\n\n    >>> maximum.maximum_insertion([-1,\
    \ -2, 3], -2, 3)\n    [-1, -2, 3]\n\n    Example 2:\n\n    >>> maximum.maximum_insertion([-4,\
    \ -5, -6, -7, -8], -2, 3)\n    [-4, -5, -6, -7, -8, -2]\n\n    Example 3:\n\n\
    \    >>> maximum.maximum_insertion([-4, -5, -6, -7, -8], -2, 3)\n    [-4, -5,\
    \ -6, -7, -8, -2]\n\n    Note:\n        1. The length of the list will be in the\
    \ range of [1, 1000].\n        2. The elements in the list will be in the range\
    \ of [-1000, 1000].\n        3. 0 <= k <= len(list)\n    \"\"\"\n", "    \n  \
    \  arr = sorted(arr)[:k]\n    \n    return arr\n</cell>\n<cell>", "    if k >\
    \ len(arr):\n        return []\n    elif k == 0 or k == len(arr):\n        return\
    \ arr\n    else:\n        max_num = arr[k-1]\n        for i in range(k-2, -1,\
    \ -1):\n            if arr[i] > max_num:\n                max_num = arr[i]\n \
    \       return arr[:k] + [k] + [max_num]\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "    if len(arr) == 0 or k == 0:\n        return []\n    maximum = arr[0]\n    for\
    \ i in range(1, len(arr)):\n        if arr[i] > maximum:\n            maximum\
    \ = arr[i]\n    return arr[0:k]\n\n", "    # \u6700\u5927\u503C \n    max_num\
    \ = arr[0]\n    # \u627E\u5230\u6700\u5927\u503C \n    for num in arr:\n     \
    \   if num >= max_num:\n            max_num = num\n    # \u5C06\u6700\u5927\u503C\
    \u4E0E arr \u4E2D\u5404\u5143\u7D20\u5BF9\u5E94\u4F4D\u7F6E\u7684\u5143\u7D20\u8FDB\
    \u884C\u4EA4\u6362 \n    for i in range(k):\n        tmp = arr[i]\n        arr[i]\
    \ = max_num\n        max_num = tmp\n    return arr\n\n", "    pass\n", "    ans\
    \ = []\n    temp = arr[0]\n\n    # check k validity and initalize ans to arr[0]\n\
    \    if k > len(arr):\n        return arr\n    elif k == 0:\n        return arr\n\
    \    elif k < 0:\n        return arr\n    else:\n        for i in range(k):\n\
    \            index = arr.index(temp)\n            if index == -1:\n          \
    \      break\n            temp = max(arr[index], temp)\n            ans.append(temp)\n\
    \        return ans\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis solution is O(N)\
    \ in the worst case where N <= 4, so you should be fine.\nIt works by going through\
    \ the input list once, finding the max number and the index (which must be the\
    \ first index where arr[index] > arr[index + 1]), and then using that to find\
    \ the max between the two numbers in the sublist, i.e. arr[first_index] > arr[second_index].\
    \ Because of this the complexity is O(N).\n<code>", "    if len(arr) == 0:\n \
    \       return []\n    \n    if k > len(arr):\n        return arr\n\n    if k\
    \ == 0:\n        return arr\n\n    sorted_arr = sorted(arr)\n    return sorted_arr[k-1]\n\
    \n", "    if not arr or not k:\n        return []\n    \n    maximums, maxIndex\
    \ = [], k - 1\n    arrIndex = 0\n    while arrIndex < len(arr):\n        maximums.append(arr[arrIndex])\n\
    \        if arrIndex == maxIndex:\n            arrIndex += 1\n            maxIndex\
    \ -= 1\n        elif arrIndex < maxIndex and arr[arrIndex] > arr[arrIndex + 1]:\n\
    \            arrIndex += 1\n        else:\n            maximums.sort()\n     \
    \       maxIndex -= 1\n            arrIndex += 1\n\n    return maximums\n", " \
    \   def maxMerge(arr, l, r):\n        if r - l == 1: \n            return [arr[l]]\n\
    \        mid = l + (r - l) // 2\n        if arr[mid - 1] > arr[mid]: \n      \
    \      return [arr[l]] + maxMerge(arr, l, mid) + [arr[r]]\n        elif arr[mid\
    \ - 1] < arr[mid]: \n            return [arr[r]] + maxMerge(arr, mid + 1, r)\n\
    \        else: \n            return [arr[l], arr[mid]] + maxMerge(arr, l, mid)\
    \ + [arr[r]]\n\n    if k <= len(arr):\n        return maxMerge(arr, 0, len(arr))\n\
    \    else:\n        return [-1]\n", "    \n    if k <= 0 or len(arr) <= 0:\n \
    \       return []\n    \n    # Sort the array and take top k\n    return sorted(arr)[-k:]\n",
  "    maximum_arr = []\n    for num in arr:\n        if num not in maximum_arr:\n\
    \            maximum_arr.append(num)\n    maximum_arr.sort()\n    return maximum_arr[k:]\n",
  "    \n    arr_max = [0 for _ in range(k+1)]\n    \n    for i, e in enumerate(arr):\n\
    \        if arr_max[i] == 0:\n            arr_max[i] = e\n        else:\n    \
    \        if arr_max[i] > e:\n                arr_max[i] = e\n    \n    return\
    \ [arr_max[k] for k in range(k+1)]\n    \n", "    if k > len(arr):\n        return\
    \ []\n    if len(arr) == 1:\n        return [arr[0]]\n    if k == 1:\n       \
    \ return arr\n    else:\n        # find the min and max number in the array\n\
    \        # because we need to sort the numbers in ascending order\n        min_num\
    \ = min(arr)\n        max_num = max(arr)\n        if max_num - min_num > 1000:\n\
    \            k_range = int((max_num - min_num) / 1000 + 1)\n        else:\n  \
    \          k_range = max_num - min_num + 1\n        # get the numbers whose difference\
    \ is equal to the k value\n        # for example, if we are looking for k = 3,\
    \ numbers in the list are (-3, -4, 5)\n        # difference = 3, (-3 + -4) = -6,\
    \ (-6 + 5) = 5\n        diff = max_num - min_num\n        k_range = range(k_range)\n\
    \        diff_range = [diff // 10 ** x for x in range(len(k_range) - 1)]\n   \
    \     k_range.extend(diff_range)\n        k_range.append(diff % 10 ** len(k_range))\n\
    \        k_range = k_range[:k]\n        # sort the array using the k_range as\
    \ the key to sort\n        arr.sort()\n        arr = [arr[i] for i in k_range]\n\
    \        if arr[-1] < arr[0]:\n            arr.reverse()\n        return arr\n",
  "    \n    # Write your code here.\n    # 1. \u6700\u5927\u503C\u7684\u5217\u8868\
    \n    max_list = [-1] * k\n    \n    # 2. \u904D\u5386\u6570\u7EC4\n    for num\
    \ in arr:\n        if num >= max_list[-1]:\n            max_list.append(num)\n\
    \            \n    # 3. \u8FD4\u56DE\u7ED3\u679C\n    return max_list\n", "  \
    \  # Write your code here.\n    arr=sorted(arr)\n    return arr[:k]\n</cell>\n\
    <cell>", "    \n    # Write your code here\n    \n    return sorted(arr)[-k:]\n",
  "    max_length = 0\n    largest_num = None\n    for i in range(len(arr)):\n   \
    \     if largest_num is None:\n            largest_num = arr[i]\n        if arr[i]\
    \ > largest_num:\n            max_length = i + 1\n            largest_num = arr[i]\n\
    \    if max_length < k:\n        return []\n    return arr[:max_length]\n</cell>\n\
    <text>\nTest your function:\n\n\n</text>\n<cell>\narr = [-4, -3, 2, 1, 2, -1,\
    \ -2]\nassert maximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2, -1]\nassert maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 2) == [2, -1]\nassert maximum([-3, 2, 1, 2, -1, -2, 1],\
    \ 3) == []\nassert maximum([1, 2, 3, 4, 5], 4) == [4, 4, 4]\nassert maximum([10,\
    \ 20, 30], 1) == [10, 20, 30]\nprint(\"Well done!\")\n</cell>\n<text>\nNow use\
    \ list comprehension to implement the function maximum. Iterate through the array\
    \ and append the element to the new list if the new list length is equal to the\
    \ input array length. Otherwise append the element to the new list with the maximum.\n\
    \n\n</text>\n<cell>", "    return sorted(arr)[-k:]\n", "    \n    return sorted(arr)[-k:]\n",
  "    max_list = [0] * k\n    max_list[0] = arr[0]\n    for i in range(1, len(arr)):\n\
    \        if arr[i] > max_list[i-1]:\n            max_list[i-1] = arr[i]\n    \n\
    \    for i in range(1, k):\n        max_list[i] = max(max_list[i], arr[i])\n \
    \   \n    return max_list\n</cell>\n<text>\nGiven the maximum k numbers in the\
    \ array, we can then get those k numbers out the array.\n\n\n</text>\n<cell>",
  "    pass\n</cell>\n<text>\nSolution\n\n</text>\n<cell>", "    def helper(arr: List[int],\
    \ k: int) -> List[int]:\n        if k <= 0:\n            return arr\n        if\
    \ k == 1:\n            if arr[0] <= arr[1]:\n                return [arr[0]]\n\
    \            else:\n                return [arr[1]]\n        left_list = helper(arr[:k//2],\
    \ k//2)\n        right_list = helper(arr[k//2:], k//2)\n        left_list.extend(right_list)\n\
    \        return left_list\n    return helper(arr, k)\n", "    # write your code\
    \ here\n    if len(arr) <= k:\n        return arr\n    else:\n        max_num\
    \ = max(arr)\n        res = []\n        count = 0\n        \n        for i in\
    \ range(k, len(arr)):\n            if arr[i] > max_num:\n                max_num\
    \ = arr[i]\n                count += 1\n            else:\n                break\n\
    \        if count == k:\n            res.append(max_num)\n        else:\n    \
    \        res.extend(arr[count:])\n        return res\n", "    pass\n", "    max_arr\
    \ = []\n    maximum = None\n    for num in arr:\n        if maximum != None and\
    \ num > maximum:\n            max_arr.append(maximum)\n            maximum = num\n\
    \        elif maximum == None and num <= k:\n            maximum = num\n     \
    \   else:\n            pass # do nothing\n    max_arr.append(maximum)\n    return\
    \ max_arr\n", "    # Your code here\n    maximum_res = []\n    for i in range(k,\
    \ len(arr)):\n        max_ele = arr[-k:]\n        max_ele.sort()\n        maximum_res.append(max_ele[-1])\n\
    \    return maximum_res\n", "    pass\n    # \u4F7F\u7528\u6392\u5E8F\u6CD5\u6392\
    \u5E8F\n    # \u5229\u7528heapq\u6A21\u5757\u7684maxheappushpush\u51FD\u6570\u6765\
    \u6784\u9020\u4E00\u4E2A\u5806\u6808\uFF0C\u7136\u540E\u4F7F\u7528max\u51FD\u6570\
    \u53D6\u51FA\u5806\u6808\u4E2D\u7684\u6700\u5927\u503C\uFF0C\u8FD4\u56DE\u3002\
    \n    # \u65F6\u95F4\u590D\u6742\u5EA6\uFF1AO(nlogn)\uFF0Cn\u662F\u5143\u7D20\u7684\
    \u4E2A\u6570\u3002\n    # \u7A7A\u95F4\u590D\u6742\u5EA6\uFF1AO(n)\u3002\n\n",
  "    # Solution 1 : Using heap\n    if len(arr) <= 1:\n        return arr\n    heap\
    \ = [0] * (k + 1)\n    heap[0] = arr[0]\n    for i in range(1, len(arr)):\n  \
    \      heap[i] = max(heap[i // 2] if i // 2 >= 0 else 0, arr[i])\n    result =\
    \ []\n    left = 0\n    while left < k:\n        right = k - 1\n        while\
    \ right >= left:\n            if arr[left] > heap[right]:\n                result.append(heap[right])\n\
    \                right -= 1\n            else:\n                heap[right] =\
    \ heap[left]\n                left += 1\n        heap[right] = arr[left]\n   \
    \     left += 1\n    result.append(heap[0])\n    return result\n", "    pass\n",
  "    pass\n    ", "    # Definition for a binary tree node.\n    class TreeNode:\n\
    \        def __init__(self, val=0, left=None, right=None):\n            self.val\
    \ = val\n            self.left = left\n            self.right = right\n\n    #\
    \ Definition for a binary tree node.\n    class TreeNode:\n        def __init__(self,\
    \ val=0, left=None, right=None):\n            self.val = val\n            self.left\
    \ = left\n            self.right = right\n\n    def helper(node, arr, k, i, max_k):\n\
    \        if max_k == i:\n            return arr\n        if node is None:\n  \
    \          return arr\n\n        left = helper(node.left, arr, k, i+1, max_k)\n\
    \        right = helper(node.right, arr, k, i+1, max_k)\n\n        if left is\
    \ not None and right is not None:\n            if node.val > left.val:\n     \
    \           return right\n            elif node.val > right.val:\n           \
    \     return left\n            else:\n                return node\n        elif\
    \ left is not None:\n            return left\n        elif right is not None:\n\
    \            return right\n\n    if k == 0:\n        return []\n    elif k ==\
    \ 1:\n        return arr\n    else:\n        return helper(None, arr, k, 0, k-1)\n",
  "    # Write your code here.\n\n    arr_len = arr.__len__()\n    if arr_len == 0:\n\
    \        return []\n    elif k > arr_len:\n        return []\n    elif k == 0:\n\
    \        return [arr[0]]\n    else:\n        max_arr = arr[:k]\n        max_num\
    \ = arr[0]\n        for i in range(1, arr_len):\n            if arr[i] > max_num:\n\
    \                max_num = arr[i]\n        max_arr.append(max_num)\n        return\
    \ max_arr\n        \n", "    sorted_list = sorted(arr)\n    if k == len(sorted_list):\n\
    \        return arr\n    elif k == 0 or k == 1 or k > len(sorted_list):\n    \
    \    return sorted_list\n    else:\n        return sorted_list[:k-1] + sorted_list[k-1]\n",
  "    pass\n", "    maximum = [0] * k\n\n    def find(nums: List[int], k: int) ->\
    \ int:\n        \"\"\"\n        Return the index of the first number in the array\
    \ which equals to the \n        specified number in the specified order.\n\n \
    \       Example:\n\n            >>> find([-1, 3, 5, 2, -4, -2, 6], 3)\n      \
    \      4\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[k]\
    \ == nums[i]:\n                return i\n        return -1\n\n    def insert(nums:\
    \ List[int], index: int, num: int) -> int:\n        \"\"\"\n        Insert the\
    \ number in nums at the specified index.\n\n        Example:\n\n            >>>\
    \ insert([-1, 3, 5, 2, -4, -2, 6], 4, -4)\n            [-1, 3, 5, 2, -4, -2, 6,\
    \ -4]\n        \"\"\"\n        if index >= len(nums):\n            nums.append(num)\n\
    \        elif index > 0:\n            nums[index - 1] = num\n        return nums\n\
    \n    def partition(nums: List[int], k: int) -> List[int]:\n        \"\"\"\n \
    \       Partition the list into two sub-lists, the first one contains the \n \
    \       element with the minimum value in the specified order, and the second\
    \ \n        one contains the rest.\n\n        Example:\n\n            >>> partition([-1,\
    \ 3, 5, 2, -4, -2, 6], 3)\n            [-1, 3, 5, 2], [-2, 6]\n\n        Note:\n\
    \            1. For simplicity, the time complexity of the sort is O(nlogn).\n\
    \            2. If k is larger than the length of the array, the algorithm will\
    \ \n            just return the whole array.\n        \"\"\"\n        lo = 0\n\
    \        hi = len(nums) - k\n\n        while lo < hi:\n            mid = (lo +\
    \ hi) // 2\n            if nums[mid] < nums[mid + 1]:\n                lo = mid\
    \ + 1\n            else:\n                hi = mid\n\n        nums = insert(nums,\
    \ lo, nums[lo])\n        return nums[:lo + 1], nums[lo + 1:]\n\n    k, n = 0,\
    \ len(arr)\n    while k < n:\n        lo, los = -1, []\n        k, n = k + 1,\
    \ len(arr)\n        while k < n:\n            index = find(arr, k)\n         \
    \   if index < 0:\n                los.append(arr[k])\n                k = k +\
    \ 1\n            else:\n                lo = index\n                k = k + 1\n\
    \        los = los + arr[k:]\n        nums, los = partition(los, k)\n        maximum[k]\
    \ = los[-1]\n        arr = insert(arr, lo, arr[k])\n\n    return maximum\n", " \
    \   if k <= 0 or len(arr) <= k:\n        return arr\n    \n    left = 0\n    right\
    \ = len(arr)-1\n\n    maximum = arr[left]\n\n    while left < right:\n       \
    \ maximum = max(maximum, arr[right])\n        left += 1\n        right -= 1\n\n\
    \    return maximum\n", "    if k > len(arr):\n        return arr\n    \n    largest\
    \ = arr[0]\n    max_idx = 0\n    idx = 0\n    while idx < len(arr):\n        if\
    \ arr[idx] > largest:\n            largest = arr[idx]\n            max_idx = idx\n\
    \        idx += 1\n    \n    return arr[max_idx:max_idx+k] \n", "    pass\n",
  "    if not 0 <= k <= len(arr):\n        return [-1]*k\n    else:\n        return\
    \ sorted(arr)[-k:]\n", "    # code here\n    if len(arr) == 0:\n        return\
    \ []\n\n    elif len(arr) == 1:\n        return [arr[0]]\n\n    else:\n      \
    \  if k <= 1:\n            return [max(arr)]\n\n        else:\n            arr1\
    \ = sorted(arr)\n            arr2 = sorted(arr)\n            count = 0\n     \
    \       end = k - 1\n\n            for i in range(0, k):\n                if arr1[i]\
    \ < arr2[i]:\n                    arr1[end] = arr1[i]\n                    count\
    \ +=1\n                    end -= 1\n                else:\n                 \
    \   arr2[end] = arr2[i]\n                    count +=1\n                    end\
    \ -= 1\n\n            arr1[end:] = arr2[:end]\n\n            return arr1\n\n",
  "    pass\n\n", "    # Your code here\n    maximum = [arr[0]]*k\n    maximum.extend(sorted(arr[1:])[::-1])\n\
    \    return maximum\n", "    pass\n", "    arr = sorted(arr)\n    if k > len(arr):\n\
    \        return arr\n    elif k == len(arr):\n        return arr\n    else:\n\
    \        return arr[:k]\n</code>\n<|/ a |>\n<| a tags=python,algorithm,sorting\
    \ |>\nYou can use the following approach (a variation of the heap sort):\n<code>",
  "    pass\n</cell>\n<cell>", "    # write your code here\n    return sorted(arr,\
    \ key=lambda x: -x+1 )[k:]\n", "    pass\n</cell>\n<cell>", "    pass\n", "  \
    \  import math\n    arr = sorted(arr)\n    length = len(arr)\n    if length <=\
    \ k:\n        return arr\n    k = k - length\n    left, right = (math.inf, math.inf)\n\
    \    for i in range(length):\n        if arr[i] < arr[left]:\n            left\
    \ = i\n        if arr[i] > arr[right]:\n            right = i\n    if arr[left]\
    \ < k:\n        arr.remove(arr[left])\n    if arr[right] > k:\n        arr.remove(arr[right])\n\
    \    arr.append(k)\n    return arr\n", "    # Your code here\n    maximum_list=[\
    \ ]\n    sorted=sorted(arr)\n    k_list=[ ]\n    while len(sorted)>=k:\n     \
    \   maximum_list.append(sorted[-1])\n        sorted_list=[ ]\n        for num\
    \ in arr:\n            if num not in sorted_list:\n                sorted_list.append(num)\n\
    \        k_list.append(sorted_list[0:k])\n        sorted=sorted[k:]\n    return\
    \ k_list\n", "    if k >= len(arr):\n        return arr\n    maximum = 0\n   \
    \ maximum_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[maximum]:\n\
    \            maximum = arr[i]\n            maximum_index = i\n    if maximum ==\
    \ arr[0] and k > 1:\n        return [arr[0]]\n    elif maximum != arr[0]:\n  \
    \      maximum = arr[maximum_index]\n        maximum_index = -1\n        for i\
    \ in range(1, k):\n            if arr[i] > maximum:\n                maximum =\
    \ arr[i]\n                maximum_index = i\n    if maximum == arr[k]:\n     \
    \   k = k - 1\n    return arr[:maximum_index+1]\n", "    if k > len(arr):\n  \
    \      return []\n\n    if len(arr) == 1:\n        return [arr[0]]\n\n    less,\
    \ equal, greater = [], [], []\n\n    # Find the max element\n    for i in range(len(arr)):\n\
    \        if arr[i] < arr[k]:\n            less.append(arr[i])\n        elif arr[i]\
    \ > arr[k]:\n            greater.append(arr[i])\n        else:\n            equal.append(arr[i])\n\
    \    greater = maximum([greater, less, equal], k + 1)\n\n    return greater\n",
  "    # code here\n    if k > len(arr):\n        return arr\n\n    if k == 1:\n \
    \       return arr\n\n    maximum_values = []\n    for idx in range(1, len(arr)):\n\
    \        if arr[idx] > arr[idx-1]:\n            maximum_values.append(arr[idx])\n\
    \        else:\n            maximum_values.append(arr[idx-1])\n\n    return maximum_values\n",
  "    if not arr or len(arr) == 0:\n        return None\n    if len(arr) == 1:\n\
    \        return arr\n    length = len(arr)\n    if k > length:\n        return\
    \ None\n    if k <= length:\n        return sorted(arr[:k], reverse=True)\n  \
    \  if k > length / 2:\n        return maximum(arr[:length//2], k)\n    return\
    \ maximum(arr[length//2:], k - length//2)\n", "    if not 0 <= k <= len(arr):\n\
    \        raise IndexError(\"invalid k\")\n    \n    answer = []\n    stack = collections.deque([arr[0]])\n\
    \    answer.append(stack.popleft())\n    \n    while len(stack):\n        top\
    \ = stack.popleft()\n        if top > max(answer):\n            answer.append(top)\n\
    \        else:\n            while k and top > max(answer[-k:]):\n            \
    \    answer.append(stack.popleft())\n                k -= 1\n            stack.appendleft(top)\n\
    \    return list(reversed(answer))\n    \n</cell>\n<text>\nNote\nWe could have\
    \ used the built-in max function instead of our custom implementation. However,\
    \ the custom implementation's advantage is that we can use it in a variety of\
    \ scenarios beyond the ones we have covered so far.\n\n\n</text>\n<text>\nNote\n\
    This custom implementation is not very efficient, since it needs to iterate over\
    \ all elements of arr every time it pops an element. An alternative would be to\
    \ simply maintain a mininum and maximum element in each stack node. Then, each\
    \ time the new element is popped, we must check if the new element is greater\
    \ than the current minimum or maximum, respectively. If it is greater, we push\
    \ it into the stack with the new element at the top and decrease the maximum element\
    \ by one. Otherwise, we simply remove the element from the stack. The efficiency\
    \ of this implementation is O(n) where n is the number of elements in the stack.\
    \ Whereas the built-in max implementation is O(1).\n\nTo be more efficient and\
    \ still follow the DRY principle, we could implement a stack using a linked list\
    \ instead. However, this is more complex and would require us to store the length\
    \ of each linked list node as well as the maximum element of the stack. Let's\
    \ leave that as an exercise for you.\n\n\n</text>\n<cell>", "    pass\n", "  \
    \  max_num = 0\n    arr_idx = 0\n    \n    # get the first max number of the arr\
    \ \n    while arr_idx < len(arr) and arr[arr_idx] > max_num:\n        max_num\
    \ = arr[arr_idx]\n        arr_idx += 1\n        \n    # get the k max numbers\
    \ of the arr\n    while arr_idx < len(arr) and arr_idx < k:\n        max_num =\
    \ max(max_num, arr[arr_idx])\n        arr_idx += 1\n        \n    return list(reversed(max_num))\n",
  "    if not 1 <= k <= len(arr):\n        raise Exception(\"The length of arr must\
    \ be larger than 1.\")\n    if k == 1:\n        return arr\n    # sort arr\n \
    \   arr = sorted(arr)\n    # slice arr up to k\n    arr = arr[:k]\n    return\
    \ arr\n", "    if k > len(arr) or k <= 0:\n        return []\n    else:\n    \
    \    sorted_list = list(arr[:k])\n        sorted_list.sort(reverse=True)\n   \
    \     return sorted_list\n", "    import math\n    if k >= len(arr):\n       \
    \ return arr\n    else:\n        maximum_list = arr[:k]\n        maximum_list.sort()\n\
    \        return maximum_list\n", "    \n    return sorted(arr, key = lambda x:\
    \ -x) if k == 1 else sorted(arr, key = lambda x: -abs(x))[:k]\n</code>\n<|/ a\
    \ tags=python,sorting,algorithm |>\n<| c |>\nThis solution doesn't always work.\
    \ `maximum([-1, -2, -2, 1], 1) == [1]`\n<|/ c |>\n<| a |>\nI believe this is the\
    \ most efficient algorithm:\n<code>", "    return sorted(arr, key=lambda x: (-x[1],\
    \ x[0]), reverse=True)[:k]\n\n", "    # Your code goes here\n    # arr=sorted(arr)\n\
    \    # return arr[k:]\n    max_arr=[arr[0]]\n    for index in range(len(arr)-1):\n\
    \        if arr[index]>max_arr[-1]:\n            max_arr.append(arr[index])\n\
    \        else:\n            continue\n    return max_arr[k:]\n", "    maximum_list\
    \ = []\n    maximum_index = -1\n    maximum = arr[0]\n\n    for i in range(0,\
    \ len(arr)):\n        if maximum < arr[i]:\n            maximum_list.append(maximum)\n\
    \            maximum_list.append(arr[i])\n            maximum = arr[i]\n     \
    \       maximum_index = i\n        else:\n            maximum = arr[i]\n\n   \
    \ maximum_list.append(maximum)\n    maximum_list.append(arr[maximum_index])\n\
    \    return maximum_list\n\n", "    if k <= 0 or k > len(arr):\n        return\
    \ []\n\n    if k == 1:\n        return [max(arr)]\n    \n    maximums = maximum(arr,\
    \ k - 1)\n\n    return max([max(maximums, key=lambda x: arr[x]), max(arr)])\n",
  "    maximum_arr = []\n    for i in range(k):\n        max_val = max(arr)\n    \
    \    maximum_arr.append(max_val)\n        arr.remove(max_val)\n    return maximum_arr\n",
  "    if k <= 0 or k > len(arr):\n        return arr\n    maximum = []\n    maximum.extend(arr)\n\
    \    maximum.sort(reverse=True)\n    return maximum[:k]\n</cell>\n<text>\nAnd\
    \ our final solution is really simple. We just have to loop through the array\
    \ and compare it to the previous max value.\n\n\n</text>\n<cell>", "    def maxSort(arr:\
    \ List[int], k: int) -> List[int]:\n        if len(arr) <= k: return arr\n\n \
    \       max_k = -9999999\n        max_v = arr[0]\n\n        for i in range(1,\
    \ k):\n            if arr[i] > max_v:\n                max_v = arr[i]\n      \
    \          max_k = i\n\n        return arr[:max_k] + sorted(arr[max_k:])\n\n \
    \   if k == 1:\n        return [max(arr)]\n    else:\n        return maxSort(arr,\
    \ k - 1)\n", "    ans, i, max_num = 1, k+1, 0\n    while i < len(arr):\n     \
    \   if arr[i] > max_num:\n            max_num = arr[i]\n            ans = arr[i:i+k]\n\
    \        i += 1\n    return ans\n", "    if k <= 0 or k > len(arr):\n        return\
    \ []\n    else:\n        return sorted(arr, key=lambda x: -x)[:k]\n", "    # write\
    \ your code here\n    maximum_list = None\n    index_maximum = 0\n    for index,\
    \ number in enumerate(arr):\n        if index == 0:\n            maximum_list\
    \ = list(number)\n            index_maximum = index\n        elif number > maximum_list[index_maximum]:\n\
    \            maximum_list = list(number)\n            index_maximum = index\n\
    \        elif number == maximum_list[index_maximum]:\n            if index < k:\n\
    \                index_maximum = index\n            else:\n                index_maximum\
    \ += 1\n                maximum_list = list(number)\n    return maximum_list\n",
  "    return sorted(arr, key=lambda x: (-x, x))[-k:]\n\n", "    \n    pass\n", " \
    \   from copy import deepcopy\n    if not (0 <= k <= len(arr)):\n        return\
    \ None\n\n    arr = deepcopy(arr)\n    arr.sort()\n    return arr[k:]\n</code>\n\
    <|/ a tags=python,python-3.x dscore=0 |>\n<| c |>\nI like that you added a test\
    \ to make sure k is in the correct range\n<|/ c |>\n<| c |>\nI did the same! :)\
    \ Thank you !\n<|/ c |>\n<| a dscore=0 tags=python,python-3.x |>\n<code>", " \
    \   \n    max_arr = []\n    \n    if len(arr) == 0:\n        return max_arr\n\
    \    \n    if len(arr) < k:\n        return max_arr\n    \n    for i in range(k):\n\
    \        max_arr.append(max(arr))\n        arr.remove(max(arr))\n    \n    return\
    \ max_arr\n", "    # Write your code here\n    largest = []\n    for i in range(len(arr)):\n\
    \        if i == k:\n            break\n        if arr[i] > max(largest):\n  \
    \          largest = [arr[i]]\n        else:\n            largest.append(arr[i])\n\
    \    largest.sort()\n    return largest\n    ", "    pass\n", "    # write your\
    \ code here\n    maximum_value = -1\n    maximum_index = 0\n    if k == 0 or len(arr)\
    \ == 0:\n        return arr\n    if k == 1:\n        return arr\n    if k == len(arr):\n\
    \        maximum_value = arr[0]\n        maximum_index = 0\n        return arr\n\
    \    for i in range(len(arr)):\n        if i == maximum_index:\n            continue\n\
    \        if arr[i] > maximum_value:\n            maximum_value = arr[i]\n    \
    \        maximum_index = i\n        if maximum_index == k - 1:\n            break\n\
    \        \n    if maximum_index >= k:\n        maximum_value = arr[maximum_index]\n\
    \        maximum_index = k\n    \n    maximum_value = arr[0]\n    maximum_index\
    \ = 1\n    for i in range(1, len(arr)):\n        if arr[i] > maximum_value:\n\
    \            maximum_value = arr[i]\n            maximum_index = i\n        if\
    \ maximum_index == k - 1:\n            break\n    \n    maximum_value = arr[0]\n\
    \    maximum_index = 1\n    \n    return arr[0:maximum_index + 1]\n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n", "    # Solution 1\n    # max_num = [-sys.maxsize]*(k+1)\n\
    \    # for i in range(k, len(arr)):\n    #     if arr[i] > max_num[-1]:\n    #\
    \         max_num[-1] = arr[i]\n    #     if i == k and arr[i] > max_num[-1]:\n\
    \    #         max_num[-1] = arr[i]\n    # return [x for x in range(-1000, 1000)\
    \ if x in max_num]\n    # Solution 2\n    # return sorted(arr, key = lambda x:\
    \ -x)[:k]\n    \n    # Solution 3\n    # return sorted(arr, key = lambda x: -x)[:k]\n",
  "    # write your code here\n    if not arr:\n        return []\n    max_arr = []\n\
    \    max_arr.extend(arr[:k])\n    max_arr.extend(arr[k:])\n    return max_arr\n",
  "    ans = []\n    lower, upper = len(arr) - 1, 0\n\n    while upper < lower:\n\
    \        mid = (upper + lower) // 2\n        if arr[mid] >= k:\n            ans.append(arr[mid])\n\
    \            upper = mid - 1\n        else:\n            lower = mid\n\n    ans.append(arr[lower])\n\
    \    return ans\n\n", "    maximum = []\n    maximum.append(arr[0])\n    for j\
    \ in range(len(arr)-1):\n        if maximum[0] < arr[j]:\n            maximum.append(arr[j])\n\
    \        elif maximum[0] == arr[j] and maximum[1] < arr[j+1]:\n            maximum.append(arr[j+1])\n\
    \    return maximum\n</code>\n<|/ a tags=python,python-3.x |>\n<| c |>\nThat is\
    \ not O(n) algorithm.\n<|/ c |>\n<| c |>\nIt is! The outer loop runs from 0 to\
    \ n-k+1, while the inner loop runs from 1 to k. At every iteration, at most one\
    \ of the two will be used depending on the value of `maximum`. Thus, it takes\
    \ O(n) time, which means it is O(n).\n<|/ c |>\n<| c |>\nIt is O(n) for each individual\
    \ iteration of the outer loop. This can be reduced to O(1) by using a heap data\
    \ structure instead of a list.\n<|/ c |>\n<| c |>\nI don't think this is O(n),\
    \ it runs in O(n^2) time.\n<|/ c |>\n<| c |>\nOh really? Can you provide a counter-example\
    \ for that claim?\n<|/ c |>\n<| a dscore=1 |>\nUse numpy.maximum, this is O(n)\
    \ operation:\n<code>\n>>> import numpy\n>>> numpy.maximum(arr,k)\narray([-4, -3,\
    \ 5])\n>>> \n</code>\n<|/ a tags=python,python-3.x |>\n<| c |>\nIt is not O(n),\
    \ it is O(nlogn).\n<|/ c |>\n<| c |>\nI didn't know that it runs in O(nlogn) time.\
    \ Thanks for sharing this.\n<|/ c |>\n<| a tags=python,python-3.x |>\n<code>",
  "    size = len(arr)\n    high = [0] * k\n\n    low = [arr[0] for _ in range(k)]\n\
    \    high = [0] * k\n\n    for i in range(k):\n        low[i] = min(low[i], arr[0])\n\
    \n    for i in range(size):\n        for j in range(k):\n            if arr[i]\
    \ > low[j] and arr[i] > high[j]:\n                high[j] = arr[i]\n         \
    \   elif arr[i] > low[j]:\n                high[j] = low[j]\n            elif\
    \ arr[i] < low[j]:\n                high[j] = low[j]\n\n        low[k // 2] =\
    \ max(low[k // 2], arr[i])\n\n    return [high[i] for i in range(k)]\n", "   \
    \ # \u52A8\u6001\u89C4\u5212 + \u4F18\u5316\n    # \u5982\u679C k \u5927\u4E8E\
    \ len(arr) \u5219\u8FD4\u56DE arr\n    if len(arr) > k:\n        return arr[:k]\n\
    \    else:\n        best_k = 0\n        max_value = arr[0]\n        for i in range(1,\
    \ len(arr)):\n            if arr[i] > max_value:\n                max_value =\
    \ arr[i]\n                best_k = i\n        return arr[:best_k + 1]\n", "  \
    \  if not arr:\n        return []\n\n    res = []\n    length = len(arr)\n\n \
    \   for i in range(length-1, -1, -1):\n        res.append(arr[i])\n\n    if len(res)\
    \ < k:\n        return res + [0] * (k - len(res))\n\n    return res\n", "    pass\n",
  "    \n    # write your code here\n    if len(arr) < k:\n        return arr\n  \
    \  \n    cur_max = arr[0]\n    max_len = 1\n    for i in range(1, len(arr)):\n\
    \        if arr[i] > cur_max:\n            cur_max = arr[i]\n            max_len\
    \ = i\n    \n    sub_arr = [cur_max] * (max_len - len(arr) + 1)\n    for i in\
    \ range(max_len - len(arr) + 1):\n        sub_arr[i] = arr[i + len(arr)]\n   \
    \ \n    return sub_arr\n", "    def compare(x, y):\n        if x <= y: return\
    \ -1\n        elif x > y: return 1\n        return 0\n    max_list = []\n    for\
    \ i in range(k):\n        max_list.append(max(arr, key = lambda x: compare(x,\
    \ arr[i])))\n    return max_list\n", "    max = arr[0]\n    maximum = []\n   \
    \ for i in range(k-1):\n        if arr[i] > max:\n            max = arr[i]\n \
    \           maximum = [max]\n        else:\n            maximum.append(max)\n\
    \            max = arr[i]\n\n    return maximum\n", "    max_num, max_idx = 0,\
    \ -1\n    max_val = -1000\n\n    for i in range(1, len(arr)):\n        if arr[i]\
    \ > max_val:\n            max_val = arr[i]\n            max_idx = i\n\n      \
    \  if arr[i] == max_val:\n            max_num = max_num + 1\n\n        if max_num\
    \ >= k:\n            break\n\n    return arr[:max_idx+1]\n\n", "    # code here\n\
    \    \n    return sorted(arr[-k:], reverse=True)\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
