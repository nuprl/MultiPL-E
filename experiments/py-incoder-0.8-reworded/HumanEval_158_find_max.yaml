name: HumanEval_158_find_max
language: py
prompt: "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    \"\
  \"\"Write a function that accepts a list of strings.\n    The list contains different\
  \ words. Return the word with maximum number\n    of unique characters. If multiple\
  \ strings have maximum number of unique\n    characters, return the one which comes\
  \ first in lexicographical order.\n\n    >>> find_max(['name', 'of', 'string'])\n\
  \    'string'\n    >>> find_max(['name', 'enam', 'game'])\n    'enam'\n    >>> find_max(['aaaaaaa',\
  \ 'bb', 'cc'])\n    'aaaaaaa'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(['name', 'of', 'string']) == 'string'\n\
  \    assert candidate(['name', 'enam', 'game']) == 'enam'\n    assert candidate(['aaaaaaa',\
  \ 'bb', 'cc']) == 'aaaaaaa'\n    assert candidate(['abc', 'cba']) == 'abc'\n   \
  \ assert candidate(['play', 'this', 'game', 'of', 'footbott']) == 'footbott'\n \
  \   assert candidate(['we', 'are', 'gonna', 'rock']) == 'gonna'\n    assert candidate(['we',\
  \ 'are', 'a', 'mad', 'nation']) == 'nation'\n    assert candidate(['this', 'is',\
  \ 'a', 'prrk']) == 'this'\n    assert candidate(['b']) == 'b'\n    assert candidate(['play',\
  \ 'play', 'play']) == 'play'\n\ndef test_check():\n    check(find_max)\n\ntest_check()\n"
completions: ["    return max(set(words), key=lambda word: len(word))\n\n", "    \n\
    \    pass\n\n", "    word_count = {}\n    for word in words:\n        if word\
    \ not in word_count:\n            word_count[word] = 1\n        else:\n      \
    \      word_count[word] += 1\n\n    if max(word_count.values()) == 1 and min(word_count.keys())\
    \ == len(words):\n        return min(word_count.keys())\n    else:\n        return\
    \ find_max(sorted(words, key=lambda x:word_count[x], reverse=True))\n", "    if\
    \ len(words) < 2:\n        return ''\n    unique_chars = {}\n    unique_chars_idx\
    \ = 0\n    unique_chars_max = -1\n    unique_chars_idx = 0\n    for word in words:\n\
    \        if len(word) >= unique_chars_max:\n            unique_chars_max = len(word)\n\
    \        unique_chars[word] = unique_chars.get(word, 0) + 1\n    unique_chars_keys\
    \ = list(unique_chars.keys())\n    unique_chars_keys.sort(key=lambda x: unique_chars[x],\
    \ reverse=True)\n    unique_chars_keys.sort(key=lambda x: len(x), reverse=True)\n\
    \    for word in unique_chars_keys:\n        if len(word) == unique_chars_max:\n\
    \            return word\n        unique_chars_idx += 1\n        if unique_chars_idx\
    \ >= len(unique_chars_keys):\n            break\n    if unique_chars_idx == len(unique_chars_keys):\n\
    \        return words[0]\n    return ''\n", "    # start coding here\n    unique_chars\
    \ = []\n    unique_words = {}\n    words_with_char = []\n    for word in words:\n\
    \        word = word.lower()\n        unique_chars.append(len(word))\n       \
    \ for letter in word:\n            if letter not in unique_words:\n          \
    \      unique_words[letter] = [word]\n            else:\n                unique_words[letter].append(word)\n\
    \                \n    for letter in unique_chars:\n        if letter in words_with_char:\n\
    \            words_with_char[unique_chars.index(letter)].sort()\n        else:\n\
    \            words_with_char.append(unique_words[letter])\n    \n    if words_with_char.count(words_with_char[0])\
    \ == len(words_with_char):\n        return words_with_char[0]\n    \n    max_length\
    \ = 0\n    words_with_char.sort()\n    for word in words_with_char:\n        max_length\
    \ = max_length if len(word) > max_length else len(word)\n        if word == words_with_char[-1]:\n\
    \            break\n    \n    return words_with_char[words_with_char.index(words_with_char[-1])\
    \ - max_length]\n            \n            \n            \n            \n    \
    \        \n            \n            \n            \n            \n          \
    \  \n            \n            \n            \n            \n            \n  \
    \          \n            \n            \n            \n            \n        \
    \    \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            ", "    pass\n\n", "    dic =\
    \ {}\n    for word in words:\n        num = dic[word]\n        if num:\n     \
    \       if num > len(word):\n                return word\n        else:\n    \
    \        dic[word] = 1\n    return words[0]\n", "    # Fill this in.\n    return\
    \ ''\n\n", "    # TODO your solution here\n\n    return \"\"\n", "    # to_store\
    \ is list\n    to_store = dict()\n    # loop through list\n    for word in words:\n\
    \        # find word as key\n        if word not in to_store:\n            # increment\
    \ count\n            to_store[word] = 1\n        else:\n            # add count\
    \ to value\n            to_store[word] += 1\n    # sort by count in descending\
    \ order\n    return sorted(to_store, key = lambda k: to_store[k], reverse=True)[0]\n\
    \n", "    words_list = []\n    for word in words:\n        words_list.append(word.lower())\n\
    \    unique_set = set(words_list)\n    max_count = 0\n    count_list = {}\n  \
    \  for word in unique_set:\n        count = count_list.get(word)\n        if count\
    \ is None:\n            count = 0\n        count_list[word] = count + 1\n    \
    \    if count > max_count:\n            max_count = count\n        if count <\
    \ len(unique_set):\n            break\n    if max_count < len(unique_set):\n \
    \       return words_list[0]\n    else:\n        return sorted(unique_set)[-1]\n\
    \n", "    pass\n", "    pass\n", "    count = {}\n    for word in words:\n   \
    \     char_count = {}\n        for char in word:\n            if char not in char_count:\n\
    \                char_count[char] = 0\n            char_count[char] += 1\n   \
    \     for char in char_count:\n            if char_count[char] > count[char]:\n\
    \                count[char] = char_count[char]\n    return max(count, key=count.get)\n\
    \n", "    return max((len(word), word) for word in words)[1]\n", "    pass\n",
  "    return words[0]\n", "    counts = collections.Counter(char for word in words\
    \ for char in word)\n    return counts.most_common()[0][0]\n\n", "    \n    if\
    \ len(words) == 0:\n        return ''\n    \n    characters = set()\n    \n  \
    \  for word in words:\n        characters.update(word)\n        \n    return sorted(characters,\
    \ key=lambda x: (characters.count(x), x), reverse=True)[0]\n\n", "    pass\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
